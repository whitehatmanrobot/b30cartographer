********************************************************************
void CNewPrjWResource::OnSerchUFM() 
Search the ufm 

*****************************************************************************************/

void CNewPrjWResource::OnSerchUFM() 
{
	UpdateData() ;
	CString csFilter( _T("*.ufm|*.ufm||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".ufm"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[8192];
	memset(cfd.m_ofn.lpstrFile,0,8192);
	cfd.m_ofn.nMaxFile = 8192;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {
		CString cspath = cfd.GetNextPathName(pos) ;
		m_csaUFMFiles.Add(cspath) ;
	}
	m_csUFMpath = m_csaUFMFiles[0] ;

	SetCurrentDirectory(m_csUFMpath.Left(m_csUFMpath.ReverseFind(_T('\\') ) ) ) ;
	
	UpdateData(FALSE) ;
}

/****************************************************************************************
void CNewPrjWResource::OnSearchGTT() 
Search the gtt files
*****************************************************************************************/

void CNewPrjWResource::OnSearchGTT() 
{
	UpdateData() ;  // in order to upgraded edit string value ;

	CString csFilter( _T("*.gtt|*.gtt||") ) ; 
	
	CFileDialog cfd(TRUE, _T(".gtt"), NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        this);

	cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}
	// save the file path to member string array 	
	for (POSITION pos = cfd.GetStartPosition(); pos; ) {

		m_csaGTTFiles.Add(cfd.GetNextPathName(pos)) ;
	}
	
	m_csGTTpath = m_csaGTTFiles[0] ;
	SetCurrentDirectory(m_csGTTpath.Left(m_csGTTpath.ReverseFind(_T('\\') ) ) ) ;

	UpdateData(FALSE) ;
}

/////////////////////////////////////////////////////////////////////////////
// CNewPrjWResource message handlers

/***************************************************************************************
BOOL CNewPrjWResource::OnInitDialog() 

mainly disable controls 
*****************************************************************************************/

BOOL CNewPrjWResource::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    // uncheck the check box,
	m_cbCheckFonts.SetCheck(false) ;
	
	// disable Add Template Edit box
	
	GetDlgItem(IDC_UFM_PATH)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_GTT_PATH)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_SerchUFM)->EnableWindow(FALSE) ;
	GetDlgItem(IDC_SearchGTT)->EnableWindow(FALSE) ;
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/****************************************************************************************
void CNewPrjWResource::OnCheckFonts() 

user want to include fonts inside new project, this routin does not mapping the RCID in 
a UFM to specifc GTT. user has to change these rcid value after project creation.
*****************************************************************************************/

void CNewPrjWResource::OnCheckFonts() 
{
	CEdit ceTName, ceTPath ;

	if ( m_cbCheckFonts.GetCheck() )  {// check the button
		GetDlgItem(IDC_UFM_PATH)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_GTT_PATH)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_SerchUFM)->EnableWindow(TRUE) ;
		GetDlgItem(IDC_SearchGTT)->EnableWindow(TRUE) ;
			
	} 
	else {
		GetDlgItem(IDC_UFM_PATH)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_GTT_PATH)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_SerchUFM)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_SearchGTT)->EnableWindow(FALSE) ;
	} ;
	
}


/****************************************************************************************
BOOL CNewPrjWResource::OnSetActive() 

*****************************************************************************************/

BOOL CNewPrjWResource::OnSetActive() 
{
	// change the NEXT to FINISH.
	((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
	((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
	((CPropertySheet*)GetOwner())->GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	return CPropertyPage::OnSetActive();
}

/****************************************************************************************
BOOL CNewPrjWResource::OnWizardFinish() 
this is workhouse. Creating directory and fils for project & build environment, and copies 
these files.

*****************************************************************************************/

BOOL CNewPrjWResource::OnWizardFinish() 
{
	UpdateData() ;
	m_pcnp = (CNewProject* )(( CNewProjectWizard* )GetParent() )->GetProjectPage() ;
	

	//// copied the resource file to project directory.////
	
	CString csPrjPath, csNewGPDPat, csUFMDir, csGTTDir,csGPDPath ;
	CStringArray csaNewUFMPath,csaNewGTTPath ;
	
	csPrjPath = m_pcnp->m_csPrjpath ;
	csGPDPath = m_pcnp->GetGPDpath() ;

	csUFMDir = csPrjPath + _T("\\UFM") ;
	csGTTDir = csPrjPath + _T("\\GTT") ;
	
	// create ufm, gtt directory
	SECURITY_ATTRIBUTES st;
	st.nLength = sizeof(SECURITY_ATTRIBUTES);
	st.lpSecurityDescriptor = NULL;
	st.bInheritHandle = FALSE ;

	
	if (!CreateDirectory(csUFMDir.GetBuffer(256),&st) || 
			!CreateDirectory(csGTTDir.GetBuffer(256),&st) ) {
		
		CString csmsg ;
		csmsg = _T("Fail to creat the resources (ufm, gtt) directory") ;
		AfxMessageBox(csmsg) ;
		return FALSE ;
	}
	
	
	// Copy Resource files to project class 
	// UFM files
	for ( int i = 0 ; i< m_csaUFMFiles.GetSize() ; i++ ) {
		CString csname, cssrc, csdest;

		cssrc = m_csaUFMFiles[i] ;
		csname = cssrc.Mid(cssrc.ReverseFind(_T('\\')) + 1) ;
		csdest=	csUFMDir + _T('\\') + csname ;
		
		if (!CopyFile(cssrc, csdest, TRUE)) {
			CString csmsg ;
			csmsg.Format(IDS_AddCopyFailed, cssrc,
						 csdest.Left(csdest.GetLength() - 1)) ;
			csmsg += csdest ;
			AfxMessageBox(csmsg) ;
			return FALSE ;
		}
		m_csaUFMFiles.SetAt(i,csdest) ;

	}

	// GTT files
	for ( i = 0 ; i< m_csaGTTFiles.GetSize() ; i++ ) {
		CString csname, cssrc, csdest;

		cssrc = m_csaGTTFiles[i] ;
		csname = cssrc.Mid(cssrc.ReverseFind(_T('\\')) + 1) ;
		csdest=	csGTTDir + _T('\\') + csname ;
				
		if (!CopyFile(cssrc, csdest, TRUE)) {
			CString csmsg ;
			csmsg.Format(IDS_AddCopyFailed, cssrc,
						 csdest.Left(csdest.GetLength() - 1)) ;
			csmsg += csdest ;
			AfxMessageBox(csmsg) ;
			return FALSE ;
		}
		m_csaGTTFiles.SetAt(i,csdest) ;
	}

	// GPD files
	CString cssrc, csdest;
	cssrc = csGPDPath;
	if(!m_csGpdFileName.GetLength() )
		m_csGpdFileName = csPrjPath.Mid(csPrjPath.ReverseFind('\\') + 1 );
	csdest = csPrjPath + _T('\\') + m_csGpdFileName + _T(".gpd" ) ;
	if (!CopyFile(cssrc, csdest, TRUE)) {
		CString csmsg ;
		csmsg.Format(IDS_AddCopyFailed, cssrc,
					 csdest.Left(csdest.GetLength() - 1)) ;
		csmsg += csdest ;
		AfxMessageBox(csmsg) ;
		return FALSE ;
	}
	csGPDPath.Delete(0,csGPDPath.GetLength());
	csGPDPath = csdest ;
	
	// Create RCID mapping from pcl5eres.txt and target GPD.
	CreateRCID(csdest) ;

	// Copy Stdnames.gpd ; use established module 
	try {
		CString cssrc, csdest ;
		cssrc = ThisApp().GetAppPath() + _T("stdnames.gpd") ;
		csdest = csPrjPath + _T("\\") + _T("stdnames.gpd") ;
		CopyFile(cssrc, csdest, FALSE) ;
		
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
//      return  FALSE ;
    }



	// Create the RC 
	 
	CString csRC,csSources, csMakefile ;
	if(!m_csRCName.GetLength() )
		m_csRCName = csPrjPath.Mid(csPrjPath.ReverseFind('\\') + 1 );
	csRC = csPrjPath + _T('\\') + m_csRCName + _T(".rc" ) ;
	CFile cfRC(csRC,CFile::modeCreate | CFile::modeWrite ) ;
	cfRC.Close() ;

	// Create the SOURCES files
	csSources = csPrjPath + _T("\\sources") ;
	CFile cf(csSources,CFile::modeCreate | CFile::modeWrite ) ;

	HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(150),
		MAKEINTRESOURCE(IDR_NEWSOURCES));
		

	if (!hrsrc) {
		AfxMessageBox(_T("Fail to create new sources due to insufficient resource, you have to \
			make sources file for the build "), MB_ICONEXCLAMATION ) ;
		
	} ;

	HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
	if  (!hgMap)
		return  FALSE;  //  This should never happen!

	int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
	LPVOID lpv = LockResource(hgMap);
	
	cf.Write(lpv,nsize) ;
	CString cssource = cf.GetFilePath() ;
	cf.Close() ;
	
	
	//We need to copy more gpd file if user select PCL6 template mmm..
	//Get file from the resource 3 files ( pjl.gpd, p6disp.gpd, pclxl.gpd )
	


	//Update the SOURCES file
	CModelData cmd;
	cmd.SetKeywordValue(cssource,_T("TARGETNAME"),m_csRCName,true) ;
	cmd.SetKeywordValue(cssource,_T("SOURCES"),m_csRCName + _T(".rc"),true );
	cmd.SetKeywordValue(cssource,_T("MISCFILES"), m_csGpdFileName + _T(".GPD"),true ) ;
	
	
	// Create the MAKEFILE.
	csMakefile = csPrjPath + _T("\\makefile") ;
	CFile cfMakefile(csMakefile,CFile::modeCreate | CFile::modeWrite ) ;
//  should fill the contents of the makefile
	CString cstemp(_T("!INCLUDE $(NTMAKEENV)\\makefile.def") );
	cfMakefile.Write(cstemp,cstemp.GetLength() ) ;
	cfMakefile.Close() ;


	// Create the DEF file
	CString csDeffile = csPrjPath + _T("\\") + m_csRCName + _T(".def") ;
	CFile cfDeffile(csDeffile,CFile::modeCreate | CFile::modeWrite ) ;
	cstemp.Empty() ;
	cstemp = _T("LIBRARY ") + m_csRCName ;
	cfDeffile.Write(cstemp,cstemp.GetLength() ) ;
	cfDeffile.Close() ;

	


//  Call the Frame of the project workspace
	CMultiDocTemplate* pcmdtWorkspace = ThisApp().WorkspaceTemplate() ;

	CDocument*  pcdWS = pcmdtWorkspace->CreateNewDocument();
    
	CProjectRecord *ppr = DYNAMIC_DOWNCAST(CProjectRecord,pcdWS ) ;
	
	ppr->CreateFromNew(m_csaUFMFiles, m_csaGTTFiles,csGPDPath,m_csModelName,m_csRCName,m_csaRcid) ;

	pcmdtWorkspace-> SetDefaultTitle(pcdWS);
    CFrameWnd*  pcfw = pcmdtWorkspace -> CreateNewFrame(pcdWS, NULL);
    
	if  (!pcfw) 
		return FALSE;
    
	pcmdtWorkspace -> InitialUpdateFrame(pcfw, pcdWS);
	
//	SetCurrentDirectory(csPrjPath ) ;
	return CPropertyPage::OnWizardFinish();
}

/****************************************************************************************
LRESULT CNewPrjWResource::OnWizardBack() 
this lead close all windows inlcuding parent window, because this dialog box created under
OnOK of parent dialog box. need to be updated.

*****************************************************************************************/

LRESULT CNewPrjWResource::OnWizardBack() 
{
	
	return ((CPropertySheet*)GetParent())->PressButton(PSBTN_CANCEL ) ;
//	return CPropertyPage::OnWizardBack();
}

/****************************************************************************************
void CNewPrjWResource::OnChangeEditGpd() 

*****************************************************************************************/

void CNewPrjWResource::OnChangeEditGpd() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	UpdateData() ;
	if(m_csGpdFileName.GetLength() && m_csModelName.GetLength() && m_csRCName.GetLength() )
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_FINISH);
	else
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
}		

/****************************************************************************************
void CNewPrjWResource::OnChangeEditModel() 
all these three value(model name, rc name, gdp file name ) should exist for creating project

*****************************************************************************************/

void CNewPrjWResource::OnChangeEditModel() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	UpdateData() ;
	if(m_csGpdFileName.GetLength() && m_csModelName.GetLength() && m_csRCName.GetLength() )
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_FINISH);
	else
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
}


/****************************************************************************************
void CNewPrjWResource::OnChangeEditResourec() 

*****************************************************************************************/
void CNewPrjWResource::OnChangeEditResourec() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function and call CRichEditCtrl().SetEventMask()
	// with the ENM_CHANGE flag ORed into the mask.
	UpdateData() ;
	if(m_csGpdFileName.GetLength() && m_csModelName.GetLength() && m_csRCName.GetLength() )
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_FINISH);
	else
		((CPropertySheet*)GetOwner())->SetWizardButtons(PSWIZB_DISABLEDFINISH);
}
/*****************************************************************************************
void CNewPrjWResource::CreateRCID(CString csGPD)
	if (pcl.txt)
		read the pcl.txt
	else
		read from the resource and create pcl.txt under root
	compare (pcl.txt value and rc value in the gpd)
	creating list of existing string and value
******************************************************************************************/

void CNewPrjWResource::CreateRCID(CString csGPD)
{
	// check pcl.txt: 1st, mdt help directory  2nd. load resource file
	
	CString cstable = AfxGetApp()->m_pszHelpFilePath ;
	cstable = cstable.Left(cstable.ReverseFind(_T('\\')) + 1 )  ;

	cstable += _T("pcl.txt") ;

	CFileFind cff ;
	if (! cff.FindFile(cstable) ) {
		// load from the resource files			
		CFile cf(cstable,CFile::modeCreate | CFile::modeWrite ) ;
		
		HRSRC   hrsrc = FindResource(AfxGetResourceHandle(), MAKEINTRESOURCE(200),
			MAKEINTRESOURCE(IDR_STRINGTABLE));
			

		if (!hrsrc) {
			AfxMessageBox(_T("Fail to create new project due to insufficient resource"), MB_ICONEXCLAMATION ) ;
			return ;
		} ;

		HGLOBAL hgMap = LoadResource(AfxGetResourceHandle(), hrsrc);
		if  (!hgMap)
			return ;  //  This should never happen!
	
		int nsize = SizeofResource(AfxGetResourceHandle(),hrsrc ) ;
		LPVOID lpv = LockResource(hgMap);
		
		cf.Write(lpv,nsize) ;
		cf.Close() ;
	}

	// Get Every rcNameID value from the GPD
	CStringArray csaData;
	
	if(!LoadFile(csGPD,csaData)){	// call global function in minidev.h(which is include for this fucntion)
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csGPD);
		AfxMessageBox(csErr,MB_OK);
		return ;
	}
	
	CDWordArray cdwRcid ;
	CString csline;
	CString csKeyword = _T("rcNameID:") ;
	int offset ;
	for (int i = 0 ; i < csaData.GetSize() ; i ++ ) { 
		csline = csaData[i];
		if(-1 ==(offset=csline.Find(csKeyword)) )
			continue;
		else
		{
			csline = csline.Mid(offset+csKeyword.GetLength());
			int ircid = atoi(csline) ;
			if (ircid)
				cdwRcid.Add(ircid) ;
			
		}
	}

	// Search the pcl.txt for the rcNameID
	csaData.RemoveAll() ;
	if(!LoadFile(cstable,csaData)){
		CString csErr;
		csErr.Format(IDS_InvalidFilename, csGPD);
		AfxMessageBox(csErr,MB_OK);
		return ;
	}

	// save rcid and string to string table array
	CStringTable cstrcid ;
	
	for (i = 0 ; i < csaData.GetSize() ;i ++ ) {
		csline = csaData[i] ;
			
		WORD    wKey = (WORD) atoi(csline);

		if  (!wKey)
			continue  ;  //  0 is not a valid resource number...

		csline = csline.Mid(csline.Find("\""));
		csline = csline.Mid(1, -2 + csline.GetLength());

		cstrcid.Map(wKey, csline);
	}
	
	// save slelected line from pcl.txt after matching pcl.txt data and seleted gpd rcid
	CString cstmp ;
	for ( i = 0 ; i < cdwRcid.GetSize() ; i ++ ) {
		WORD wKey = (WORD) cdwRcid[i] ;

		csline = cstrcid[wKey] ;
		cstmp.Format("%d",wKey) ;
		csline = cstmp + _T("\"") + csline ;
		m_csaRcid.Add(csline ) ;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard


IMPLEMENT_DYNAMIC(CNewProjectWizard, CPropertySheet)

CNewProjectWizard::CNewProjectWizard(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	
}

CNewProjectWizard::CNewProjectWizard(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{

	AddPage(&m_cpwr) ;

	m_pParent = pParentWnd ;
	SetWizardMode() ;
	
}

CNewProjectWizard::~CNewProjectWizard()
{
}


BEGIN_MESSAGE_MAP(CNewProjectWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CNewProjectWizard)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProjectWizard message handlers


/*************************************************************************************
CPropertyPage* CNewProjectWizard::GetProjectPage()

this is just propertysheet for project wizard, Currently project wizard contain only one
propertypage, but it can be expand to more propertypage so medium properysheet is required
for the future use rather that just us one dialog box

**************************************************************************************/
CPropertyPage* CNewProjectWizard::GetProjectPage()
{
	
	CNewComponent* pcnc = (CNewComponent* ) GetParent();
	return (CPropertyPage*)pcnc->GetProjectPage() ; ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newproj.cpp ===
/******************************************************************************

  Source File:  New Project Wizard.CPP

  This contains the implementation of the classes that make u the new project
  wizard- a key component of this tool.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it
  02-28-1998	Ekevans@acsgroup.com		The UI for the wizard was changed
				to only support conversion to Win2K minidrivers.  Be this as
				it may, most - if not all - of the support in this file for
				other conversions is still in this file but is unused.
******************************************************************************/

#include    "StdAfx.h"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "NewProj.H"
#include    <CodePage.H>
#include	<dlgs.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewConvertWizard

//  We use "this" to allow the pages to hook back to us- disable the
//  warnings this causes, as none will use the pointer until after
//  we have been initialized.

#pragma warning(disable : 4355)
CNewConvertWizard::CNewConvertWizard(CProjectRecord& cprFor, CWnd* pParentWnd) :
	CPropertySheet(NewProjectWizardTitle, pParentWnd), m_cfnwp(*this),
    m_cprThis(cprFor), m_cst(*this), m_csd(*this), m_crut(*this),
    m_crng(*this), m_ccf(*this), m_cmcp(*this), m_cgpds(*this), m_cdcps(*this) {

    m_bFastConvert = TRUE;
    m_eGPDConvert = CommonRCWithSpoolerNames;

    AddPage(&m_cfnwp);	//CFirstNewWizardPage
    AddPage(&m_cst);	//CSelectTargets
    AddPage(&m_csd);	//CSelectDestinations
	AddPage(&m_cdcps);	//CDefaultCodePageSel
	AddPage(&m_cgpds);	//CGPDSelection
    AddPage(&m_crut);	//CRunUniTool
    AddPage(&m_cmcp);	//CMapCodePages
    AddPage(&m_ccf);	//CConvertFiles
    AddPage(&m_crng);	//CRunNTGPC
    SetWizardMode();
}

#pragma warning(default : 4355)

CNewConvertWizard::~CNewConvertWizard() {
}

BEGIN_MESSAGE_MAP(CNewConvertWizard, CPropertySheet)
	//{{AFX_MSG_MAP(CNewConvertWizard)
	ON_WM_NCCREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewConvertWizard message handlers

//  restore the system menu to the wizard, and allow it to be minimized

BOOL CNewConvertWizard::OnNcCreate(LPCREATESTRUCT lpCreateStruct) {
	ModifyStyle(WS_CHILD, WS_MINIMIZEBOX | WS_SYSMENU);
	
	if (!CPropertySheet::OnNcCreate(lpCreateStruct))
		return FALSE;
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage property page

CFirstNewWizardPage::CFirstNewWizardPage(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CFirstNewWizardPage::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CFirstNewWizardPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CFirstNewWizardPage::~CFirstNewWizardPage() {
}

void CFirstNewWizardPage::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFirstNewWizardPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CFirstNewWizardPage, CPropertyPage)
	//{{AFX_MSG_MAP(CFirstNewWizardPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage message handlers

BOOL CFirstNewWizardPage::OnSetActive() {
	//  We wish to disable the "Back" button here.
	
    m_cnpwOwner.SetWizardButtons(PSWIZB_NEXT);
	m_cnpwOwner.GetDlgItem(IDHELP)->ShowWindow(SW_HIDE) ;

	return  CPropertyPage::OnSetActive();
}

/******************************************************************************

  CFirstNewWizardPage::OnWizardNext

  When Next is pressed, we invoke a file open dialog to allow us to collect the
  source RC file information.

******************************************************************************/

LRESULT CFirstNewWizardPage::OnWizardNext()
{
	CString		cswrcfspec ;	// Filespec for RC/RC3/W31 file

	//  When the "Next" button is pushed, we need to find the driver we are
    //  going to work with.  Keep prompting the user until a valid filespec
	//	is returned.
		
	do {
		CFileDialog cfd(TRUE, NULL, NULL, OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
			"Driver Resource Scripts (*.w31,*.rc)|*.w31;*.rc||",
			&m_cnpwOwner);

		CString csTitle;
		csTitle.LoadString(OpenRCDialogTitle);

		cfd.m_ofn.lpstrTitle = csTitle;

		if  (cfd.DoModal() != IDOK)
			return  -1;

		// Save the filespec and then exit the loop if the file is ok.
		// Otherwise, reprompt.

		cswrcfspec = cfd.GetPathName() ;
	} while (IsWrongNT4File(cswrcfspec)) ;

    //  Collect the RC file name

    m_cnpwOwner.Project().SetSourceRCFile(cswrcfspec) ;

	// The only conversion supported now is the so called "Fast Conversion" so
	// set that flag and skip some of the other wizard pages and go straight to
	// the destinations page.

    m_cnpwOwner.FastConvert(TRUE) ;
    return CSelectDestinations::IDD ;
}


/******************************************************************************

 CFirstNewWizardPage::IsWrongNT4File

 NT 4.0 minidrivers are made up of (among other things) both an RC file and a
 W31 file.  NT 4.0 minidriver conversions must be driven from the W31 file.
 So, if the filespec references an RC file, check the file to see if it is an
 NT 4 file.  If it is, look for a W31 file and ask the user if it should be
 used.  If yes, change the filespec and return false.  If no or there is no
 W31 file, return true so that the user will be reprompted.

******************************************************************************/

bool CFirstNewWizardPage::IsWrongNT4File(CString& cswrcfspec)
{
	CString		cstmp1 ;		// Temp string
	CString		cstmp2 ;		// Temp string
	CString		cstmp3 ;		// Temp string

	// If the file does not end with .RC, return false (ok).

	cstmp1.LoadString(IDS_RCExt) ;
	int nlen = cstmp1.GetLength() ;
	cstmp2 = cswrcfspec.Right(nlen) ;
	if (cstmp1.CompareNoCase(cstmp2) != 0)
		return false ;

	// The filespec references an RC file so it must be read and scanned to
	// see if this is an NT 4.0 RC file.  Start by reading the file...

    CStringArray    csacontents ;
    if  (!LoadFile(cswrcfspec, csacontents))
        return  FALSE ;

	// Now scan the file looking for a "2 RC_TABLES ... nt.gpc" line that will
	// indicate that this is an NT 4.0 file.

	cstmp1.LoadString(IDS_RCTables) ;
	cstmp2.LoadString(IDS_RCTabID) ;
	cstmp3.LoadString(IDS_RCTabFile) ;
	int n ;
	for (n = 0 ; n < csacontents.GetSize() ; n++) {

		// Skip this line if "RC_TABLES" is not in the line.

		if (csacontents[n].Find(cstmp1) < 0)
			continue ;

		// Skip this line if it doesn't start with "2"

		csacontents[n].TrimLeft() ;
		if (csacontents[n].Find(cstmp2) != 0)
			continue ;

		// If this line contains "nt.gpc", this is the one we want so exit the
		// loop.

		csacontents[n].MakeLower() ;
		if (csacontents[n].Find(cstmp3) >= 0)
			break ;
	} ;

	// If this is NOT an NT 4.0 RC file, return false (ok).

	if (n >= csacontents.GetSize())
		return false ;

	// We have an NT 4.0 RC file, check to see if there is a W31 file in the
	// same dir.  If there is, ask the user if he wants to use it and do so
	// if he says yes.

	cstmp1 = cswrcfspec.Left(cswrcfspec.GetLength() - nlen) ;
	cstmp2.LoadString(IDS_W31Ext) ;
	cstmp1 += cstmp2 ;
	CFileFind cff ;
	if (cff.FindFile(cstmp1)) {
		cstmp3.Format(IDS_SwitchToW31, cswrcfspec, cstmp1) ;
		if (AfxMessageBox(cstmp3, MB_YESNO) == IDYES) {
			cswrcfspec = cstmp1 ;
			return false ;
		} ;
	} ;

	// Either there is no W31 file or the user chose not to use it so return
	// true to indicate that the user should be reprompted to select another
	// file.

	cstmp1.Format(IDS_BadNT4File, cswrcfspec) ;
	AfxMessageBox(cstmp1) ;
	return true ;
}


/////////////////////////////////////////////////////////////////////////////
// CSelectTargets property page

CSelectTargets::CSelectTargets(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CSelectTargets::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CSelectTargets)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSelectTargets::~CSelectTargets() {
}

void CSelectTargets::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectTargets)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectTargets, CPropertyPage)
	//{{AFX_MSG_MAP(CSelectTargets)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets message handlers

BOOL CSelectTargets::OnSetActive() {
	//  We need to enable the "Back" button...

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    SetDlgItemText(IDC_DriverName, m_cnpwOwner.Project().DriverName());
	
	return CPropertyPage::OnSetActive();
}

//  Initialize the controls

BOOL CSelectTargets::OnInitDialog() {

	CPropertyPage::OnInitDialog();
	
	CheckDlgButton(IDC_TargetNT40,
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));
	CheckDlgButton(IDC_TargetNT3x,
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));
	CheckDlgButton(IDC_TargetWin95,
        m_cnpwOwner.Project().IsTargetEnabled(Win95));
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSelectTargets::OnWizardNext() {

	//  Set the flags according to the controls...

    m_cnpwOwner.Project().EnableTarget(WinNT40,
        IsDlgButtonChecked(IDC_TargetNT40));
	m_cnpwOwner.Project().EnableTarget(WinNT3x,
        IsDlgButtonChecked(IDC_TargetNT3x));
	m_cnpwOwner.Project().EnableTarget(Win95,
        IsDlgButtonChecked(IDC_TargetWin95));

	CString csName;
	GetDlgItemText(IDC_DriverName, csName);
    m_cnpwOwner.Project().Rename(csName);
	
	return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations property page

/**********************************************************************
 * Function:    BrowseDlgProc
 *
 * Purpose:     This dialog procedure is used to correctly initialize
 *				a browse dialog box based on the type of browsing to be
 *				performed.
 *
 *				If just a path (folder) is required, hide the file
 *				related controls that are on the dialog box.
 *
 *				If drive filtering is required, install a custom message
 *				handler for the drives combo box that will perform the
 *				filtering.
 *
 * In:          Standard dialog procedure parameters
 *
 * Out:         TRUE if message handle.  FALSE if standard processing
 *              should occur.
 **********************************************************************/

UINT_PTR APIENTRY BrowseDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    // Don't do anything if this is NOT the init message

    if (msg != WM_INITDIALOG)
        return (FALSE) ;

    // Hide the unneeded file related controls

	ShowWindow(GetDlgItem(hdlg, stc2), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, stc3), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, edt1), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, lst1), SW_HIDE) ;
	ShowWindow(GetDlgItem(hdlg, cmb1), SW_HIDE) ;

    // Do the default initialization too.

    return (FALSE) ;
}


//  This routine browses for a directory, beginning with the one named in the
//  given control.  If a directory is selected, the control is appropriately
//  updated.
//
//	An old style common dialog box is used to do this.  There is a function,
//	::SHBrowseForFolder(), that can do this with the new style dialog box but
//	I don't think this function is available on all platforms supported by
//	the MDT.

void    CSelectDestinations::DoDirectoryBrowser(CString& csinitdir)
{
	OPENFILENAME    ofn ;       // Used to send/get info to/from common dlg
    char    acpath[_MAX_PATH] ; // Path is saved here (or an error message)
    char    acidir[_MAX_PATH] ; // Initial directory is built here
    BOOL    brc = FALSE ;       // Return code

	// Update the contents of csinitdir

	UpdateData(TRUE) ;

    // Load the open file name structure

    ofn.lStructSize = sizeof(ofn) ;
    ofn.hwndOwner = m_hWnd ;
    ofn.hInstance = GetModuleHandle(_T("MINIDEV.EXE")) ;
    ofn.lpstrFilter = ofn.lpstrCustomFilter = NULL ;
    ofn.nMaxCustFilter = ofn.nFilterIndex = 0 ;
    StringCchCopyA(acpath, CCHOF(acpath), _T("JUNK")) ;	// No need to localize this string
    ofn.lpstrFile = acpath ;
    ofn.nMaxFile = _MAX_PATH ;
    ofn.lpstrFileTitle = NULL ;
    ofn.nMaxFileTitle = 0 ;
	//n = GetWindowText(hParentDrives, acidir, _MAX_PATH) ;
	//GetWindowText(hfolder, &acidir, _MAX_PATH) ;
	StringCchCopy(acidir, CCHOF(acidir), csinitdir.GetBufferSetLength(256)) ;
	csinitdir.ReleaseBuffer() ;
	ofn.lpstrInitialDir = acidir ;	// Path in parent dialog box
	//LoadString(ofn.hInstance, IDS_SELFOLDTITLE, actitle, 64) ;
    ofn.lpstrTitle = NULL ;
    ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK | OFN_NOCHANGEDIR
        | OFN_NOTESTFILECREATE | OFN_ENABLETEMPLATE | OFN_NONETWORKBUTTON ;
    ofn.lpstrDefExt = NULL ;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPENORD) ;
    ofn.lpfnHook =  BrowseDlgProc ;

    // Display the dialog box.  If the user cancels, just return.

    if (!GetOpenFileName(&ofn))
		return ;

    // Take the bogus file name off the path and put the path into the page's
	// edit box.

    acpath[ofn.nFileOffset - 1] = 0 ;
    csinitdir = acpath ;
	UpdateData(FALSE) ;

	return ;
}

/******************************************************************************

  CSelectDestinations::BuildStructure

  This private member function establishes the selected directory structure,
  if it can, and reports its success or failure as need be.

******************************************************************************/

BOOL    CSelectDestinations::BuildStructure() {
    //  Verify the directory exists (or can be created) for each of the
    //  target directories that is enabled.

    CProjectRecord& cpr = m_cnpwOwner.Project();

    CString csPath;

    if  (cpr.IsTargetEnabled(Win2000)) {
        GetDlgItemText(IDC_W2000Destination, csPath);

		// First, make sure that the path the user selected ends with the
		// directory "W2K".
			// raid 123448
/*	CString cspdir, csw2kdir ;
		csw2kdir.LoadString(IDS_NewDriverRootDir) ;		// R 123448
		cspdir = csPath.Right(csw2kdir.GetLength() + 1) ;
		csw2kdir = _T("\\") + csw2kdir ;
		
		if (cspdir.CompareNoCase(csw2kdir) != 0) {
			csw2kdir = csw2kdir.Right(csw2kdir.GetLength() - 1) ;
			cspdir.Format(IDS_BadDestPath, csw2kdir) ;
			AfxMessageBox(cspdir, MB_ICONEXCLAMATION) ;
			return FALSE ;
		} ;
*/	// raid 123448
		CString csSourcePath;
		csSourcePath = cpr.SourceFile().Left(cpr.SourceFile().ReverseFind('\\') ); 
		if (!csPath.CompareNoCase(csSourcePath) || !csPath.CompareNoCase(csSourcePath + "\\") ) {
			AfxMessageBox("You have to have different Destination from RC source file",MB_ICONEXCLAMATION );
			return FALSE;
		} ;

		// Continue with rest of directory verifications...

        if  (!cpr.SetPath(Win2000, csPath) || !cpr.BuildStructure(Win2000)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_W2000Destination) -> SetFocus();
            return  FALSE;
        }
    }

    if  (cpr.IsTargetEnabled(WinNT40)) {
        GetDlgItemText(IDC_NT40Destination, csPath);
        if  (!cpr.SetPath(WinNT40, csPath) || !cpr.BuildStructure(WinNT40)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT40Destination) -> SetFocus();
            return  FALSE;
        }
    }

    if  (cpr.IsTargetEnabled(WinNT3x)) {
        GetDlgItemText(IDC_NT3xDestination, csPath);
        if  (!cpr.SetPath(WinNT3x, csPath) || !cpr.BuildStructure(WinNT3x)) {
            AfxMessageBox(IDS_CannotMakeDirectory);
            GetDlgItem(IDC_NT3xDestination) -> SetFocus();
            return  FALSE;
        }
    }

    return  TRUE;
}

/******************************************************************************

  CSelectDestinations constructor, destructor, DDX routine and message map.

******************************************************************************/

CSelectDestinations::CSelectDestinations(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CSelectDestinations::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CSelectDestinations)
	m_csW2KDest = _T("");
	//}}AFX_DATA_INIT
}

CSelectDestinations::~CSelectDestinations() {
}

void CSelectDestinations::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectDestinations)
	DDX_Control(pDX, IDC_BrowseNT3x, m_cbBrowseNT3x);
	DDX_Control(pDX, IDC_BrowseNT40, m_cbBrowseNT40);
	DDX_Control(pDX, IDC_BrowseW2000, m_cbBrowseW2000);
	DDX_Text(pDX, IDC_W2000Destination, m_csW2KDest);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSelectDestinations, CPropertyPage)
	//{{AFX_MSG_MAP(CSelectDestinations)
	ON_BN_CLICKED(IDC_BrowseNT40, OnBrowseNT40)
	ON_BN_CLICKED(IDC_BrowseW2000, OnBrowseW2000)
	ON_BN_CLICKED(IDC_BrowseNT3x, OnBrowseNT3x)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations message handlers

BOOL CSelectDestinations::OnInitDialog() {

	CPropertyPage::OnInitDialog();

    //  Place the browser Icon in the Win2K button

    HICON   hiArrow = LoadIcon(AfxGetResourceHandle(),
        MAKEINTRESOURCE(IDI_BrowseArrow));
	m_cbBrowseW2000.SetIcon(hiArrow);

#if 0
	m_cbBrowseNT40.SetIcon(hiArrow);
	m_cbBrowseNT3x.SetIcon(hiArrow);
#else
    m_cbBrowseNT40.ShowWindow(SW_HIDE);
    m_cbBrowseNT3x.ShowWindow(SW_HIDE);
#endif
	
    return TRUE;
}


//  When we are made active, fill in the correct path names.  Note that these
//  might change as a result of activity on other pages, so we do not just do
//  this at init time.

BOOL CSelectDestinations::OnSetActive() {

    //  Fill in the correct path names

    //SetDlgItemText(IDC_W2000Destination,
    //    m_cnpwOwner.Project().TargetPath(Win2000));
    m_csW2KDest = m_cnpwOwner.Project().TargetPath(Win2000) ;
    SetDlgItemText(IDC_NT40Destination,
        m_cnpwOwner.Project().TargetPath(WinNT40));
    SetDlgItemText(IDC_NT3xDestination,
        m_cnpwOwner.Project().TargetPath(WinNT3x));
    SetDlgItemText(IDC_Win95Destination,
        m_cnpwOwner.Project().TargetPath(Win95));

    //  Disable all controls related to non-operative targets

    GetDlgItem(IDC_W2000Destination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(Win2000));

    m_cbBrowseW2000.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(Win2000));
	
    GetDlgItem(IDC_NT40Destination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));

    m_cbBrowseNT40.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT40));

    GetDlgItem(IDC_NT3xDestination) -> EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));

    m_cbBrowseNT3x.EnableWindow(
        m_cnpwOwner.Project().IsTargetEnabled(WinNT3x));

    //  Turn on the back and next buttons.

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT) ;

	// Initialize controls

	UpdateData(FALSE) ;

	return CPropertyPage::OnSetActive();
}

void CSelectDestinations::OnBrowseNT3x() {
	//DoDirectoryBrowser(IDC_NT3xDestination);
}

void CSelectDestinations::OnBrowseNT40() {
	//DoDirectoryBrowser(IDC_NT40Destination);
}

void CSelectDestinations::OnBrowseW2000() {
	DoDirectoryBrowser(m_csW2KDest);
}


/******************************************************************************

  CSelectDestinations::OnWizardNext

  Create the project record, build the destination directories, and begin the
  conversion.  The conversion is started here because the work that is done
  will generate the model information that is displayed on the GPD Selection
  page.

  Note: The original layout of this function is commented out below.  It may
  be need if some of the unimplemented/incomplete function in this program is
  ever finished.

******************************************************************************/

LRESULT CSelectDestinations::OnWizardNext() 
{
    //  This might take a while, so...

    CWaitCursor cwc;

	// Build the directory structure

    if  (!BuildStructure())
        return  -1;

    CProjectRecord& cpr = m_cnpwOwner.Project();

	// Open the conversion logging file.

	cpr.OpenConvLogFile() ;

    // Loading the original resources is done here because some of this
	// info is needed for the GPD selection page.

	if  (!cpr.LoadResources()) {
		// Display error message(s) if the resources could not be loaded.

		cpr.CloseConvLogFile() ;
        AfxMessageBox(IDP_RCLoadFailed) ;
		if (cpr.ThereAreConvErrors()) {
			CString csmsg ;
			csmsg.Format(IDS_FatalConvErrors, cpr.GetConvLogFileName()) ;
			AfxMessageBox(csmsg) ;
		} ;

		m_cnpwOwner.EndDialog(IDCANCEL) ;
        return  -1 ;
    }

    return CPropertyPage::OnWizardNext();
}

/******************************************************************************

  CSelectDestinations::OnWizardBack

  This handles the response to the back button.  We must override the default
  handler in the case of a normal conversion, as the default will go back to
  the target selection page, and we will go back to the initial page in the
  fast-path case.

******************************************************************************/

LRESULT CSelectDestinations::OnWizardBack() {
    return m_cnpwOwner.FastConvert() ?
        CFirstNewWizardPage::IDD : CPropertyPage::OnWizardBack();
}


/////////////////////////////////////////////////////////////////////////////
// CRunUniTool property page

CRunUniTool::CRunUniTool(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CRunUniTool::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CRunUniTool)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRunUniTool::~CRunUniTool() {
}

void CRunUniTool::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRunUniTool)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRunUniTool, CPropertyPage)
	//{{AFX_MSG_MAP(CRunUniTool)
	ON_BN_CLICKED(IDC_RunUniTool, OnRunUniTool)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRunUniTool message handlers

void CRunUniTool::OnRunUniTool() {
	//  Not too terribly difficult, really.  Invoke UniTool, which resides
    //  in the same directory we came from.  Then wait for the user to close it.

    STARTUPINFO         si = {sizeof si, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0,
                        STARTF_FORCEONFEEDBACK, 0, 0, NULL, NULL, NULL, NULL};
    PROCESS_INFORMATION pi;

    CString csCommand("Unitool ");

    csCommand += m_cnpwOwner.Project().SourceFile();

    if  (!CreateProcess(NULL, const_cast <LPTSTR> ((LPCTSTR) csCommand), NULL,
        NULL, FALSE, CREATE_SEPARATE_WOW_VDM, NULL,
        m_cnpwOwner.Project().TargetPath(Win95), &si, &pi)) {
        TRACE("Failed to run Unitool, reason %d <%X>\r\n", GetLastError(),
            GetLastError());
        AfxMessageBox(IDS_UnitoolNotRun);
        return;
    }

    CloseHandle(pi.hThread);    //  We'll wait on the process.
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);
}

/******************************************************************************

  CRunUniTool::OnSetActive

  We never force this to be run, anymore, so just enable both buttons.

******************************************************************************/

BOOL CRunUniTool::OnSetActive() {
	//  We need to deactivate the Next button if Unitool has not yet been run
    //  on this driver.

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CRunUniTool::OnWizardNext

  Go right on ahead, unless the RC file isn't translatable...

******************************************************************************/

LRESULT CRunUniTool::OnWizardNext() {
	//  One last check- we must be able to load and understand the RC file
    //  before we proceed.

    if  (!m_cnpwOwner.Project().LoadResources()) {
        AfxMessageBox(IDP_RCLoadFailed);
        return  -1;
    }

    return CPropertyPage::OnWizardNext();
}

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles property page

CConvertFiles::CConvertFiles(CNewConvertWizard& cnpwOwner) :
CPropertyPage(CConvertFiles::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CConvertFiles)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CConvertFiles::~CConvertFiles() {
}

void CConvertFiles::DoDataExchange(CDataExchange* pDX) {

    CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConvertFiles)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConvertFiles, CPropertyPage)
	//{{AFX_MSG_MAP(CConvertFiles)
	ON_BN_CLICKED(IDC_ConvertFiles, OnConvertFiles)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles message handlers

/******************************************************************************

  CConvertFiles::OnSetActive

  This handler is called whenever the user navigates to where this sheet is
  active.

******************************************************************************/

BOOL CConvertFiles::OnSetActive() {

    //  If there is no NT GPC work to be done, we can be done with it.
	m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
        (m_cnpwOwner.Project().IsTargetEnabled(WinNT3x | WinNT40) ?
            0 : PSWIZB_DISABLEDFINISH));

    //  Set the radio buttons according to the selected GPD conversions

    CheckRadioButton(IDC_Direct, IDC_SpoolerNames,
        IDC_Direct + m_cnpwOwner.GPDConvertFlag());
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CConvertFiles::OnConvertFiles

  Message handler for the user pressing the Convert Files button.

******************************************************************************/

void CConvertFiles::OnConvertFiles() {

    //  This might take a while, so...
    CWaitCursor cwc;

    //  We now need to generate ALL of the necessary files
    m_cnpwOwner.GPDConvertFlag(
        GetCheckedRadioButton(IDC_Direct, IDC_SpoolerNames) - IDC_Direct);
    m_cnpwOwner.Project().GenerateTargets(m_cnpwOwner.GPDConvertFlag());
    if  (m_cnpwOwner.Project().ConversionsComplete())
        m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
            (m_cnpwOwner.Project().IsTargetEnabled(WinNT3x | WinNT40) ?
                PSWIZB_NEXT : PSWIZB_FINISH));
}

/******************************************************************************

  CConvertFiles::OnKillActive

  This is called whenever the page is dismissed.  We save the GPD conversion
  flag, in case we come back to this page later.

******************************************************************************/

BOOL CConvertFiles::OnKillActive() {
	m_cnpwOwner.GPDConvertFlag(
        GetCheckedRadioButton(IDC_Direct, IDC_SpoolerNames) - IDC_Direct);

    return CPropertyPage::OnKillActive();
}

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC property page

CRunNTGPC::CRunNTGPC(CNewConvertWizard &cnpwOwner) :
    CPropertyPage(CRunNTGPC::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CRunNTGPC)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CRunNTGPC::~CRunNTGPC() {
}

void CRunNTGPC::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRunNTGPC)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CRunNTGPC, CPropertyPage)
	//{{AFX_MSG_MAP(CRunNTGPC)
	ON_BN_CLICKED(IDC_RunNtGpcEdit, OnRunNtGpcEdit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC message handlers

void CRunNTGPC::OnRunNtGpcEdit() {
	//  We only hit this step if we are building for NT 3.x or 4.0, so see
    //  which it is.

    CProjectRecord& cprThis = m_cnpwOwner.Project();

    UINT    ufEdit = cprThis.IsTargetEnabled(WinNT3x) ? WinNT3x : WinNT40;

    //  Not too terribly difficult, really.  Invoke the editor, which resides
    //  in the same directory we came from.  Wait for the user to close it.

    STARTUPINFO         si = {sizeof si, NULL, NULL, NULL, 0, 0, 0, 0, 0, 0, 0,
                        STARTF_FORCEONFEEDBACK, 0, 0, NULL, NULL, NULL, NULL};
    PROCESS_INFORMATION pi;

    CString csCommand("NTGPCEdt ");

    csCommand += cprThis.RCName(ufEdit);

    if  (!CreateProcess(NULL, const_cast <LPTSTR> ((LPCTSTR) csCommand), NULL,
        NULL, FALSE, CREATE_SEPARATE_WOW_VDM, NULL,
        m_cnpwOwner.Project().TargetPath(ufEdit), &si, &pi)) {
        TRACE("Failed to run NTGPCEdt, reason %d <%X>\r\n", GetLastError(),
            GetLastError());
        AfxMessageBox(IDS_UnitoolNotRun);
        return;
    }

    CloseHandle(pi.hThread);    //  We'll wait on the process.
    WaitForSingleObject(pi.hProcess, INFINITE);
    CloseHandle(pi.hProcess);

    //  Copy the NT GPC file, if necessary}

    if  (ufEdit == WinNT3x && cprThis.IsTargetEnabled(WinNT40))
        CopyFile(cprThis.TargetPath(WinNT3x) + _TEXT("\\NT.GPC"),
            cprThis.TargetPath(WinNT40) + _TEXT("\\NT.GPC"), FALSE);

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH);
    m_cnpwOwner.Project().OldStuffDone();
}

BOOL CRunNTGPC::OnSetActive() {
    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK |
        (m_cnpwOwner.Project().NTGPCCompleted() ?
            PSWIZB_FINISH : PSWIZB_DISABLEDFINISH));
	
	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages property page

CMapCodePages::CMapCodePages(CNewConvertWizard& cnpwOwner) :
    CPropertyPage(CMapCodePages::IDD), m_cnpwOwner(cnpwOwner) {
	//{{AFX_DATA_INIT(CMapCodePages)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMapCodePages::~CMapCodePages() {
}

void CMapCodePages::DoDataExchange(CDataExchange* pDX) {
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMapCodePages)
	DDX_Control(pDX, IDC_TableToPage, m_clbMapping);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMapCodePages, CPropertyPage)
	//{{AFX_MSG_MAP(CMapCodePages)
	ON_BN_CLICKED(IDC_ChangeCodePage, OnChangeCodePage)
	ON_LBN_DBLCLK(IDC_TableToPage, OnChangeCodePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages message handlers

BOOL CMapCodePages::OnSetActive() {

    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

    m_clbMapping.ResetContent();

    for (unsigned u = 0; u < m_cnpwOwner.Project().MapCount(); u++) {
        CGlyphMap& cgm = m_cnpwOwner.Project().GlyphMap(u);
        int id = m_clbMapping.AddString(cgm.Name() + _TEXT("->") +
            cgm.PageName(0));
        m_clbMapping.SetItemData(id, u);
    }

    m_clbMapping.SetCurSel(0);
	
	return CPropertyPage::OnSetActive();
}

/******************************************************************************

  CMapCodePages::OnChangeCodePaage

  Response to the Change Code Page button.  Invoke the change code page dialog,
  and pass the new selection to the underlying glyph map.  Update the info in
  list, too...

******************************************************************************/

void CMapCodePages::OnChangeCodePage() {
    int idSel = m_clbMapping.GetCurSel();
    if  (idSel < 0)
        return;

    unsigned uidTable = (unsigned) m_clbMapping.GetItemData(idSel) ;

    CGlyphMap&  cgm =  m_cnpwOwner.Project().GlyphMap(uidTable);
	CSelectCodePage cscp(this, cgm.Name(), cgm.PageID(0));

    if  (cscp.DoModal() == IDOK) {
        cgm.SetDefaultCodePage(cscp.SelectedCodePage());

        //  Update the control- alas, this means filling it all in.

        m_clbMapping.ResetContent();

        for (unsigned u = 0; u < m_cnpwOwner.Project().MapCount(); u++) {
            CGlyphMap& cgm = m_cnpwOwner.Project().GlyphMap(u);
            int id = m_clbMapping.AddString(cgm.Name() + _TEXT("->") +
                cgm.PageName(0));
            m_clbMapping.SetItemData(id, u);
            if  (u == uidTable)
                m_clbMapping.SetCurSel(id);
        }
    }
}

LRESULT CMapCodePages::OnWizardNext() {

	// If this fails, it will report why via a message box.

    CWaitCursor cwc;    //  Just in case this takes a while!
	
    return  m_cnpwOwner.Project().LoadFontData() ? 0 : -1;
}

/******************************************************************************

  CSelectCodePage class

  This class implements a dialog which is used in several places where
  selection of a code page is desired.

******************************************************************************/

/******************************************************************************

  CSelectCodePage::CSelectCodePage

  The constructor for this class builds an array of the mapped code page names
  from the CCodePageInformation class.

******************************************************************************/

CSelectCodePage::CSelectCodePage(CWnd* pParent, CString csName,
                                 unsigned uidCurrent)
	: CDialog(CSelectCodePage::IDD, pParent) {
	//{{AFX_DATA_INIT(CSelectCodePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_csName = csName;
    m_uidCurrent = uidCurrent;

    CCodePageInformation    ccpi;

    ccpi.Mapped(m_cdaPages);
}

void CSelectCodePage::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectCodePage)
	DDX_Control(pDX, IDC_SupportedPages, m_clbPages);
	//}}AFX_DATA_MAP
}

/******************************************************************************

  CSelectCodePage::GetCodePageName

  This returns the name of the selected code page.

******************************************************************************/

CString CSelectCodePage::GetCodePageName() const {
    CCodePageInformation    ccpi;

    return  ccpi.Name(m_uidCurrent);
}

/******************************************************************************

  CSelectCodePage::Exclude

  This member function receives a list of code pages which are not to be
  displayed in the selection list.

******************************************************************************/

void    CSelectCodePage::Exclude(CDWordArray& cdaPariah) {

    for (int i = 0; i < cdaPariah.GetSize(); i++)
        for (int j = 0; j < m_cdaPages.GetSize(); j++)
            if  (cdaPariah[i] == m_cdaPages[j]) {
                m_cdaPages.RemoveAt(j);
                break;
            }
}

/******************************************************************************

  CSelectCodePage::LimitTo

  This member receives a list of the pages to select- this list supersedes the
  list of mapped tables we began with.

******************************************************************************/

void    CSelectCodePage::LimitTo(CDWordArray& cdaPages) {
    if  (!cdaPages.GetSize())
        return;

    m_cdaPages.Copy(cdaPages);
}

BEGIN_MESSAGE_MAP(CSelectCodePage, CDialog)
	//{{AFX_MSG_MAP(CSelectCodePage)
	ON_LBN_SELCHANGE(IDC_SupportedPages, OnSelchangeSupportedPages)
	ON_LBN_DBLCLK(IDC_SupportedPages, OnDblclkSupportedPages)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectCodePage message handlers

BOOL CSelectCodePage::OnInitDialog() {
	CDialog::OnInitDialog();
	
	CString csTemp;

    GetWindowText(csTemp);
    csTemp += _TEXT(" ") + m_csName;
    SetWindowText(csTemp);

    CCodePageInformation    ccpi;

    for (int i = 0; i < m_cdaPages.GetSize(); i++) {
        int id = m_clbPages.AddString(ccpi.Name(m_cdaPages[i]));
        m_clbPages.SetItemData(id, m_cdaPages[i]);
    }

    //  The one to select is the current one

    for (i = 0; i < m_cdaPages.GetSize(); i++)
        if  (m_uidCurrent == m_clbPages.GetItemData(i))
        break;

    if  (i < m_cdaPages.GetSize())
        m_clbPages.SetCurSel(i);
    else {
        m_uidCurrent = (unsigned) m_clbPages.GetItemData(0);
        m_clbPages.SetCurSel(0);
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
}

//  When a new code page is selected, record its identity.

void CSelectCodePage::OnSelchangeSupportedPages() {
	//  Determine what the newly selected page is.

    int idCurrent = m_clbPages.GetCurSel();

    if  (idCurrent < 0)
        return;

    m_uidCurrent = (unsigned) m_clbPages.GetItemData(idCurrent);
}

void CSelectCodePage::OnDblclkSupportedPages() {
    CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CGPDSelection property page

CGPDSelection::CGPDSelection(CNewConvertWizard& cnpwOwner) :
	CPropertyPage(CGPDSelection::IDD), m_cnpwOwner(cnpwOwner),
	m_ceclbGPDInfo(&m_ceModelName, &m_cecebFileName),
	m_cecebFileName(&m_ceclbGPDInfo)
{
	//{{AFX_DATA_INIT(CGPDSelection)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	// Initially, the Select All / Deselect All button is set to Select All.

	m_bBtnStateIsSelect = true ;
}


CGPDSelection::~CGPDSelection()
{
}


void CGPDSelection::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGPDSelection)
	DDX_Control(pDX, IDC_GPDSelBtn, m_cbGPDSelBtn);
	DDX_Control(pDX, IDC_ECValue, m_cecebFileName);
	DDX_Control(pDX, IDC_ECName, m_ceModelName);
	DDX_Control(pDX, IDC_ECList, m_ceclbGPDInfo);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGPDSelection, CPropertyPage)
	//{{AFX_MSG_MAP(CGPDSelection)
	ON_BN_CLICKED(IDC_GPDSelBtn, OnGPDSelBtn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGPDSelection message handlers

BOOL CGPDSelection::OnSetActive()
{
    m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_FINISH) ;
	
	// Get the current GPD model names and file names.

	CProjectRecord& cpr = m_cnpwOwner.Project() ;
	CStringArray csamodels, csafiles ;
	if (!cpr.GetGPDModelInfo(&csamodels, &csafiles)) {
        AfxMessageBox(IDS_GPDSelInitFailed) ;
		return FALSE ;
	} ;

	// Load the Edit Control with the data collected above and do the rest of
	// the initialization that is needed.

	//if (!m_ceclbGPDInfo.Init(csamodels, csafiles, 110)) {
	if (!m_ceclbGPDInfo.Init(csamodels, csafiles, 120)) {
        AfxMessageBox(IDS_GPDSelInitFailed) ;
		return FALSE ;
	} ;

	return CPropertyPage::OnSetActive() ;
}


BOOL CGPDSelection::OnWizardFinish()
{
	// Save and verify the GPD info.  Return 0 if this fails so that the
	// wizard won't close.

	if (!GPDInfoSaveAndVerify(true))
		return 0 ;

    //  This might take a while, so...

    CWaitCursor cwc ;

	CProjectRecord& cpr = m_cnpwOwner.Project() ;

	// Continue with the conversion process.  Start by loading the PFMs and
	// CTTs.

	if  (!cpr.LoadFontData()) {
		// Display error message(s) if the fonts could not be loaded.

		cpr.CloseConvLogFile() ;
		if (cpr.ThereAreConvErrors()) {
			CString csmsg ;
			csmsg.Format(IDS_FatalConvErrors, cpr.GetConvLogFileName()) ;
			AfxMessageBox(csmsg) ;
		} ;

		m_cnpwOwner.EndDialog(IDCANCEL) ;
        return  TRUE ;
    }

    //  We now need to generate ALL of the necessary files

    BOOL brc = cpr.GenerateTargets(m_cnpwOwner.GPDConvertFlag()) ;

	// Close the conversion logging file.

	cpr.CloseConvLogFile() ;

	// Tell the user if some conversion errors were logged.

	if (cpr.ThereAreConvErrors()) {
		CString csmsg ;
		csmsg.Format(IDS_ConvErrors, cpr.GetConvLogFileName()) ;
		AfxMessageBox(csmsg) ;
	} ;

	// Handle the failure of the GenerateTargets step

	if (!brc) {
		m_cnpwOwner.EndDialog(IDCANCEL) ;
        return  TRUE ;
	} ;

	// Copy standard file to the new driver's directory

	try {
		CString cssrc, csdest ;
		cssrc = ThisApp().GetAppPath() + _T("stdnames.gpd") ;
		csdest = cpr.GetW2000Path() + _T("\\") + _T("stdnames.gpd") ;
		CopyFile(cssrc, csdest, FALSE) ;
		//cssrc = ThisApp().GetAppPath() + _T("common.rc") ;
		//csdest = cpr.GetW2000Path() + _T("\\") + _T("common.rc") ;
		//CopyFile(cssrc, csdest, FALSE) ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return  FALSE ;
    }

    return  cpr.ConversionsComplete() ;
}


LRESULT CGPDSelection::OnWizardBack()
{
	// Save the GPD info.  Return -1 if this fails so that the wizard page
	// won't change.  (Probably won't fail.)

	if (!GPDInfoSaveAndVerify(false))
		return -1 ;

	return CPropertyPage::OnWizardBack() ;
}


bool CGPDSelection::GPDInfoSaveAndVerify(bool bverifydata)
{
	// Get the file names from the Edit Control.

	CStringArray csafiles ;
	m_ceclbGPDInfo.GetGPDInfo(csafiles) ;

	// If verification is requested and there are no selected files, ask the
	// user if that is what he wants.  If no, return false to indicate that
	// GPD selection should continue.

	if (bverifydata) {
		int numelts = (int)csafiles.GetSize() ;
		for (int n = 0 ; n < numelts ; n++) {
			if (!csafiles[n].IsEmpty())
				break ;
		} ;
		if (n >= numelts) {
			n = AfxMessageBox(IDS_NoGPDsPrompt, MB_YESNO | MB_ICONQUESTION) ;
			if (n == IDYES)
				return 0 ;
		} ;
	} ;
	
	// Send the GPD file names back to the driver conversion code and verify
	// them if requested.  If the verification fails, select the offending
	// list box entry and return false to indicate that verification failed.

	CProjectRecord& cpr = m_cnpwOwner.Project() ;
	int nidx = cpr.SaveVerGPDFNames(csafiles, bverifydata) ;
	if (nidx >= 0) {
		m_ceclbGPDInfo.SelectLBEntry(nidx) ;
		return false ;
	} ;

	// All went well so...

	return true ;
}


void CGPDSelection::OnGPDSelBtn()
{
	// Get the file names and model names from the Edit Control.

	CStringArray csafiles, csamodels ;
	m_ceclbGPDInfo.GetGPDInfo(csafiles, &csamodels) ;

	// Models are selected by generating a file name for them.  Select all
	// unselected models when appropriate...
	
	if (m_bBtnStateIsSelect) {
		CProjectRecord& cpr = m_cnpwOwner.Project() ;
		cpr.GenerateGPDFileNames(csamodels, csafiles) ;

	// ...Otherwise, deselect all models by deleting their file names

	} else {
		int numelts = (int)csafiles.GetSize() ;
		for (int n = 0 ; n < numelts ; n++)
			csafiles[n] = _T("") ;
	} ;

	// Reinitialize the edit control with the modified data.

	m_ceclbGPDInfo.Init(csamodels, csafiles, 120) ;

	// Change the button caption and the button state flag

	CString cscaption ;
	cscaption.LoadString((m_bBtnStateIsSelect) ? IDS_DeselectAll : IDS_SelectAll) ;
	m_cbGPDSelBtn.SetWindowText(cscaption) ;
	m_bBtnStateIsSelect = !m_bBtnStateIsSelect ;
}


/////////////////////////////////////////////////////////////////////////////
// CDefaultCodePageSel property page

CDefaultCodePageSel::CDefaultCodePageSel(CNewConvertWizard& cnpwOwner) :
	CPropertyPage(CDefaultCodePageSel::IDD), m_cnpwOwner(cnpwOwner),
	bInitialized(false)
{
	//{{AFX_DATA_INIT(CDefaultCodePageSel)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


CDefaultCodePageSel::~CDefaultCodePageSel()
{
}


void CDefaultCodePageSel::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDefaultCodePageSel)
	DDX_Control(pDX, IDC_CodePageList, m_clbCodePages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDefaultCodePageSel, CPropertyPage)
	//{{AFX_MSG_MAP(CDefaultCodePageSel)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDefaultCodePageSel message handlers

BOOL CDefaultCodePageSel::OnSetActive()
{
	// Do nothing if the page has been activated already.
	// raid 118881
	m_cnpwOwner.SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);

	if (bInitialized)  // if back from the next property
		return CPropertyPage::OnSetActive() ;

	// Find out how many code pages are installed on the machine.

	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		// There are 3 code pages that seem to make MultiByteToWideChar() to 
		// fail.  Don't let the user choose one of those code pages unless
		// he knows the secret password (ie, undocument command line switch
		// 'CP').

		if (ThisApp().m_bExcludeBadCodePages)
			if (dwcp == 1361 || dwcp == 28595 || dwcp == 28597) 
				continue ;
		StringCchPrintf(accp, CCHOF(accp), _T("%5d"), dwcp) ;
		n = m_clbCodePages.AddString(accp) ;
		if (dwcp == dwdefcp)
			m_clbCodePages.SetCurSel(n) ;
	} ;

	// Everything is set up now so call the base routine.
	
	bInitialized = true ;
	return CPropertyPage::OnSetActive() ;
}


LRESULT CDefaultCodePageSel::OnWizardNext()
{
	// Get the index of the currently selected list box item.

	int nsel ;
	if ((nsel = m_clbCodePages.GetCurSel()) == LB_ERR) {
		AfxMessageBox(IDS_MustSelCP, MB_ICONINFORMATION) ;
		return -1 ;
	} ;

	// Get the selected list box string.

	CString cs ;
	m_clbCodePages.GetText(nsel, cs) ;

	// Turn the string into a number and convert the number into the 
	// corresponding predefined GTT code for Far East code pages when
	// applicable.

	short scp = (short) atoi(cs) ;
	DWORD dwcp = (DWORD) scp ;				// Keep copy of real CP
	switch (scp) {
		case 932:
			scp = -17 ;
			break ;
		case 936:
			scp = -16 ;
			break ;
		case 949:
			scp = -18 ;
			break ;
		case 950:
			scp = -10 ;
			break ;
	} ;

	// Save the default "code page" number in the project class instance.

	CProjectRecord& cpr = m_cnpwOwner.Project() ;
	cpr.SetDefaultCodePageNum(dwcp) ;		// Save real CP number first
	dwcp = (DWORD) scp ;
	cpr.SetDefaultCodePage(dwcp) ;

	// All went well so...
	
	return CPropertyPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\newproj.h ===
/******************************************************************************

  Header File:  New Project Wizard.H

  This file defines the various classes which make up the new project/ new
  mini-driver wizard.  This is a key component of the studio, as it is the tool
  that kicks all the important conversions off for us.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  02-03-1997    Bob_kjelgaard@Prodigy.Net   Created the initial version.

******************************************************************************/

#if !defined(NEW_PROJECT_WIZARD)
#define NEW_PROJECT_WIZARD

#if defined(LONG_NAMES)
#include    "Project Record.H"
#else
#include    "ProjRec.H"
#endif

//  An initial definition of the wizard class

class CNewConvertWizard;

/////////////////////////////////////////////////////////////////////////////
// CFirstNewWizardPage dialog

class CFirstNewWizardPage : public CPropertyPage {

    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CFirstNewWizardPage(CNewConvertWizard &cnpwOwner);
	~CFirstNewWizardPage();

// Dialog Data
	//{{AFX_DATA(CFirstNewWizardPage)
	enum { IDD = IDD_FirstPageNewWizard };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFirstNewWizardPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFirstNewWizardPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	bool IsWrongNT4File(CString& cswrcfspec) ;
};

/////////////////////////////////////////////////////////////////////////////
// CSelectTargets dialog

class CSelectTargets : public CPropertyPage {

    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CSelectTargets(CNewConvertWizard& cnpwOwner);
	~CSelectTargets();

// Dialog Data
	//{{AFX_DATA(CSelectTargets)
	enum { IDD = IDD_NPWSelectTargets };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectTargets)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectTargets)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CSelectDestinations dialog

class CSelectDestinations : public CPropertyPage {

    CNewConvertWizard&  m_cnpwOwner;

    void    DoDirectoryBrowser(CString& csinitdir);
    BOOL    BuildStructure();

// Construction
public:
	CSelectDestinations(CNewConvertWizard& cnpwOwner);
	~CSelectDestinations();

// Dialog Data
	//{{AFX_DATA(CSelectDestinations)
	enum { IDD = IDD_NPWSelectDest };
	CButton	m_cbBrowseNT3x;
	CButton	m_cbBrowseNT40;
	CButton	m_cbBrowseW2000;
	CString	m_csW2KDest;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectDestinations)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectDestinations)
	virtual BOOL OnInitDialog();
	afx_msg void OnBrowseNT40();
	afx_msg void OnBrowseW2000();
	afx_msg void OnBrowseNT3x();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CGPDSelection dialog

class CGPDSelection : public CPropertyPage
{
    CNewConvertWizard&  m_cnpwOwner ;
	bool				m_bBtnStateIsSelect ;

// Construction
public:
	CGPDSelection(CNewConvertWizard& cnpwOwner) ;
	~CGPDSelection();

// Dialog Data
	//{{AFX_DATA(CGPDSelection)
	enum { IDD = IDD_NPWGPDSelection };
	CButton	m_cbGPDSelBtn;
	CEditControlEditBox	m_cecebFileName;
	CEdit	m_ceModelName;
	CEditControlListBox	m_ceclbGPDInfo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGPDSelection)
	public:
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGPDSelection)
	afx_msg void OnGPDSelBtn();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	bool GPDInfoSaveAndVerify(bool bverifydata) ;
};


/////////////////////////////////////////////////////////////////////////////
// CRunUniTool dialog

class CRunUniTool : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CRunUniTool(CNewConvertWizard& cnpwOwner);
	~CRunUniTool();

// Dialog Data
	//{{AFX_DATA(CRunUniTool)
	enum { IDD = IDD_RunUniTool };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRunUniTool)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRunUniTool)
	afx_msg void OnRunUniTool();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CConvertFiles dialog

class CConvertFiles : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CConvertFiles(CNewConvertWizard& cnpwOwner);
	~CConvertFiles();

// Dialog Data
	//{{AFX_DATA(CConvertFiles)
	enum { IDD = IDD_ConvertFiles };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CConvertFiles)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CConvertFiles)
	afx_msg void OnConvertFiles();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CRunNTGPC dialog

class CRunNTGPC : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CRunNTGPC(CNewConvertWizard& cnpwOwner);
	~CRunNTGPC();

// Dialog Data
	//{{AFX_DATA(CRunNTGPC)
	enum { IDD = IDD_GPCEditor };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRunNTGPC)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRunNTGPC)
	afx_msg void OnRunNtGpcEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMapCodePages dialog

class CMapCodePages : public CPropertyPage {
    CNewConvertWizard&  m_cnpwOwner;

// Construction
public:
	CMapCodePages(CNewConvertWizard& cnpwOwner);
	~CMapCodePages();

// Dialog Data
	//{{AFX_DATA(CMapCodePages)
	enum { IDD = IDD_NPWCodePageSelection };
	CListBox	m_clbMapping;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMapCodePages)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMapCodePages)
	afx_msg void OnChangeCodePage();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CDefaultCodePageSel dialog

class CDefaultCodePageSel : public CPropertyPage
{
    CNewConvertWizard&  m_cnpwOwner ;
	bool				bInitialized ;

// Construction
public:
	CDefaultCodePageSel(CNewConvertWizard& cnpwOwner) ;
	~CDefaultCodePageSel();

// Dialog Data
	//{{AFX_DATA(CDefaultCodePageSel)
	enum { IDD = IDD_NPWDefaultCodePageSel };
	CListBox	m_clbCodePages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDefaultCodePageSel)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDefaultCodePageSel)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CNewConvertWizard

class CNewConvertWizard : public CPropertySheet {

    CProjectRecord& m_cprThis;  //  The project being set up
    BOOL                m_bFastConvert; //  Normal/Custom conversion flag
    WORD                m_eGPDConvert; //  Flag for GPD conversion

    //  Property pages contained in this wizard.
    CFirstNewWizardPage m_cfnwp;
    CSelectTargets      m_cst;
    CSelectDestinations m_csd;
    CRunUniTool         m_crut;
    CMapCodePages       m_cmcp;
    CRunNTGPC           m_crng;
    CConvertFiles       m_ccf;
	CGPDSelection		m_cgpds;
	CDefaultCodePageSel m_cdcps ;

// Construction
public:
	CNewConvertWizard(CProjectRecord& cprFor, CWnd* pParentWnd = NULL);
	
// Attributes
public:

    CProjectRecord& Project() { return m_cprThis; }
    BOOL            FastConvert() const { return m_bFastConvert; }

    enum    {Direct, Macro, CommonRC, CommonRCWithSpoolerNames};
    WORD            GPDConvertFlag() const { return m_eGPDConvert; }

// Operations
public:

    void            FastConvert(BOOL bFastConvert) { 
        m_bFastConvert = bFastConvert;
    }

    void            GPDConvertFlag(WORD wf) { m_eGPDConvert = wf; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewConvertWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CNewConvertWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewConvertWizard)
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CSelectCodePage dialog

class CSelectCodePage : public CDialog {
    CString     m_csName;
    unsigned    m_uidCurrent;
    CDWordArray m_cdaPages;
// Construction
public:
	CSelectCodePage(CWnd* pParent, CString csName, unsigned uidPage);

    unsigned    SelectedCodePage() const { return m_uidCurrent; }
    CString     GetCodePageName() const;

    void        Exclude(CDWordArray& cdaExclude);
    void        LimitTo(CDWordArray& cdaExclusive);

// Dialog Data
	//{{AFX_DATA(CSelectCodePage)
	enum { IDD = IDD_SelectPage };
	CListBox	m_clbPages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSelectCodePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSelectCodePage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeSupportedPages();
	afx_msg void OnDblclkSupportedPages();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\nproject.h ===
#if !defined(AFX_NEWTPROJECT_H__BB1A03B5_5555_4DE7_988D_D6F5117D0D77__INCLUDED_)
#define AFX_NEWTPROJECT_H__BB1A03B5_5555_4DE7_988D_D6F5117D0D77__INCLUDED_

#include "utility.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NewPrjWTem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewProject dialog

class CNewProject : public CPropertyPage
{
//	DECLARE_DYNCREATE(CNewProject) 
	DECLARE_SERIAL(CNewProject) 

	
// Construction
public:
	CString GetGPDpath() {return m_csGPDpath ; } ;

	CGPDContainer* GPDContainer () { return m_pcgc ; } 
	CNewProject();   // standard constructor


// Dialog Data
	//{{AFX_DATA(CNewProject)
	enum { IDD = IDD_NEW_PROJECT };
	CButton	m_cbLocprj;
	CButton	m_cbAddT;
	CListCtrl m_clcTemplate ;
	CString	m_csPrjname;
	CString	m_csPrjpath;
	CString	m_cstname;
	CString	m_cstpath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewProject)
	public:
	virtual BOOL OnSetActive();
	virtual void Serialize(CArchive& car);
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewProject)
	afx_msg void OnGpdBrowser();
	afx_msg void OnDirBrowser() ;
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckAdd();
	afx_msg void OnAddTemplate();
	afx_msg void OnChangeEditPrjName();
	afx_msg void OnChangeEditPrjLoc();
	afx_msg void OnClickListTemplate(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListTemplate(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	bool AddGpds(CString& csTemplate);
	void SetButton();
	CString m_csGPDpath;
	CGPDContainer* m_pcgc;
	CString m_csoldPrjpath;
	CPropertySheet* m_pcps;
	CStringArray m_csaTlst;
	CMapStringToString m_cmstsTemplate;

};


/////////////////////////////////////////////////////////////////////////////
// CNewPrjWResource dialog

class CNewPrjWResource : public CPropertyPage
{

	DECLARE_DYNCREATE(CNewPrjWResource) 
// Construction
public:
	CNewPrjWResource();   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewPrjWResource)
	enum { IDD = IDD_NewResource };
	CButton	m_cbCheckFonts;
	CString	m_csUFMpath;
	CString	m_csGTTpath;
	CString	m_csGpdFileName;
	CString	m_csModelName;
	CString	m_csRCName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewPrjWResource)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();
	virtual LRESULT OnWizardBack();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewPrjWResource)
	afx_msg void OnSerchUFM();
	afx_msg void OnSearchGTT();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckFonts();
	afx_msg void OnChangeEditGpd();
	afx_msg void OnChangeEditModel();
	afx_msg void OnChangeEditResourec();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	CStringArray m_csaUFMFiles, m_csaGTTFiles ;

private:
	CStringArray m_csaRcid;
	void CreateRCID(CString csgpd );
	CNewProject*   m_pcnp;
	
};



class CNewProjectWizard : public CPropertySheet
{
	DECLARE_DYNAMIC(CNewProjectWizard)

	
// Construction
public:
	CNewProjectWizard(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CNewProjectWizard(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
	
	CWnd* m_pParent;

public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewProjectWizard)
	//}}AFX_VIRTUAL

// Implementation
public:
	CPropertyPage* GetProjectPage();
//	CPropertyPage * GetTemplatePage( ) { return (CPropertyPage*)&m_cpwt ; } 
	
	virtual ~CNewProjectWizard();

	// Generated message map functions
protected:
	//{{AFX_MSG(CNewProjectWizard)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CNewPrjWResource m_cpwr ;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NEWTPROJECT_H__BB1A03B5_5555_4DE7_988D_D6F5117D0D77__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\pfmconv.c ===
/******************************************************************************

  Source File:  PFMConv.C

  This file is a hack- NT Build can't traverse directories on a SOURCES= line,
  so this file #includes all of the files I need for PFM conversion from 
  elsewhere in the tree.

  Copyright c) 1997 by Microsoft Corporation

  Change History:
  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Created it, hope I never touch it
  again...

******************************************************************************/

#ifdef  DBG
#undef	DBG
#endif


// This definition causes additional code to be compiled in 
// ..\pfm2ufm\pfmconv.c!PGetDefaultGlyphset().

#define	BUILD_FULL_GTT


#include    "..\pfm2ufm\pfm2ufm.c"
#include    "..\pfm2ufm\pfmconv.c"
#include    "..\ctt2gtt\cttconv.c"
#include	"..\..\..\lib\uni\fontutil.c"
#include	"..\..\..\lib\uni\globals.c"
#include	"..\..\..\lib\uni\unilib.c"
#include	"..\..\..\lib\uni\um\umlib.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\pfm2ifi.cpp ===
/*************************** Module Header **********************************
 * pfm2ifi
 *      Program to read Windows 3.1 PFM format data and convert to NT's
 *      IFIMETRICS data.  Note that since IFIMETRICS is somewhat more
 *      elaborate than PFM data,  some of the values are best guesses.
 *      These are made on the basis of educated guesses.
 *
 * Copyright (C) 1992,  Microsoft Corporation
 *
 ****************************************************************************/

#include        "StdAfx.h"
#if (_WIN32_WINNT < 0x0500)
typedef unsigned long DESIGNVECTOR;
#endif
#include        <winddi.h>

#include        <win30def.h>
#include        <uni16gpc.h>
#include        <uni16res.h>
#include        "raslib.h"
#include        "fontinst.h"
#undef DBG
#define	ALIAS_EXT    "._al"             /* The extension on an alias file */


/*   Function prototypes  */
char  **ppcGetAlias( HANDLE, const char * );


PBYTE MapFileA( LPCSTR, DWORD * );
BOOL  bValidatePFM( BYTE *, DWORD );

CD  *GetFontSel(HANDLE hHeap, FONTDAT *pFDat, int bSelect) {
    LOCD	    locd;		/* From originating data */
    CD		   *pCD;
    CD		   *pCDOut;		/* Copy data to here */


    locd = bSelect ? pFDat->DI.locdSelect : pFDat->DI.locdUnSelect;

    if( locd != -1 ) // (NOOCD extended to a long)
    {
	int   size;

	CD    cdTmp;			/* For alignment problems */


	pCD = (CD *)(pFDat->pBase + locd);

        /*
         *   The data pointed at by pCD may not be aligned,  so we copy
         * it into a local structure.  This local structure then allows
         * us to determine how big the CD really is (using it's length field),
         * so then we can allocate storage and copy as required.
         */

        memcpy( &cdTmp, (LPSTR)pCD, sizeof(CD) );

	/* Allocate storage area in the heap */

	size = cdTmp.wLength + sizeof(CD);

	pCDOut = (CD *)HeapAlloc( hHeap, 0, (size + 1) & ~0x1 );
//raid 43535
	if (pCDOut == NULL){
		return 0;
	}

	memcpy( pCDOut, (BYTE *)pCD, size );

	return  pCDOut;
    }

    return   0;
}

short   *GetWidthVector(HANDLE hHeap, FONTDAT *pFDat) {

    /*
     *    For debugging code,  verify that we have a width table!  Then,
     *  allocate memory and copy into it.
     */

    short  *pus;                /* Destination address */

    int     cb;                 /* Number of bytes required */

    /*
     *   There are LastChar - FirstChar width entries,  plus the default
     *  char.  And the widths are shorts.
     */
    cb = (pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 2) * sizeof( short );

    pus = (short *)HeapAlloc( hHeap, 0, cb );

    /*
     *   If this is a bitmap font,  then use the width table, but use
     *  the extent table (in PFMEXTENSION area) as these are ready to
     *  to scale.
     */


    if( pus )
    {
        BYTE   *pb;

        if( pFDat->pETM &&
            pFDat->pETM->emMinScale != pFDat->pETM->emMaxScale &&
            pFDat->PFMExt.dfExtentTable )
        {
            /*   Scalable,  so use the extent table */
            pb = pFDat->pBase + pFDat->PFMExt.dfExtentTable;
        }
        else
        {
            /*   Not scalable.  */
            pb = pFDat->pBase + sizeof( res_PFMHEADER );
        }

        memcpy( pus, pb, cb );
    }

    return  pus;
}

static void ConvFontRes(register FONTDAT *pFDat) {

    BYTE    *pb;		/* Miscellaneous operations */

    res_PFMHEADER    *pPFM;	/* The resource data format */
    res_PFMEXTENSION *pR_PFME;	/* Resource data PFMEXT format */


    /*
     *   Align the PFMHEADER structure.
     */

    pPFM = (res_PFMHEADER *)pFDat->pBase;

    pFDat->PFMH.dfType = pPFM->dfType;
    pFDat->PFMH.dfPoints = pPFM->dfPoints;
    pFDat->PFMH.dfVertRes = pPFM->dfVertRes;
    pFDat->PFMH.dfHorizRes = pPFM->dfHorizRes;
    pFDat->PFMH.dfAscent = pPFM->dfAscent;
    pFDat->PFMH.dfInternalLeading = pPFM->dfInternalLeading;
    pFDat->PFMH.dfExternalLeading = pPFM->dfExternalLeading;
    pFDat->PFMH.dfItalic = pPFM->dfItalic;
    pFDat->PFMH.dfUnderline = pPFM->dfUnderline;
    pFDat->PFMH.dfStrikeOut = pPFM->dfStrikeOut;

    pFDat->PFMH.dfWeight = DwAlign2( pPFM->b_dfWeight );

    pFDat->PFMH.dfCharSet = pPFM->dfCharSet;
    pFDat->PFMH.dfPixWidth = pPFM->dfPixWidth;
    pFDat->PFMH.dfPixHeight = pPFM->dfPixHeight;
    pFDat->PFMH.dfPitchAndFamily = pPFM->dfPitchAndFamily;

    pFDat->PFMH.dfAvgWidth = DwAlign2( pPFM->b_dfAvgWidth );
    pFDat->PFMH.dfMaxWidth = DwAlign2( pPFM->b_dfMaxWidth );

    pFDat->PFMH.dfFirstChar = pPFM->dfFirstChar;
    pFDat->PFMH.dfLastChar = pPFM->dfLastChar;
    pFDat->PFMH.dfDefaultChar = pPFM->dfDefaultChar;
    pFDat->PFMH.dfBreakChar = pPFM->dfBreakChar;

    pFDat->PFMH.dfWidthBytes = DwAlign2( pPFM->b_dfWidthBytes );

    pFDat->PFMH.dfDevice = DwAlign4( pPFM->b_dfDevice );
    pFDat->PFMH.dfFace = DwAlign4( pPFM->b_dfFace );
    pFDat->PFMH.dfBitsPointer = DwAlign4( pPFM->b_dfBitsPointer );
    pFDat->PFMH.dfBitsOffset = DwAlign4( pPFM->b_dfBitsOffset );


    /*
     *   The PFMEXTENSION follows the PFMHEADER structure plus any width
     *  table info.  The width table will be present if the PFMHEADER has
     *  a zero width dfPixWidth.  If present,  adjust the extension address.
     */

    pb = pFDat->pBase + sizeof( res_PFMHEADER );  /* Size in resource data */

    if( pFDat->PFMH.dfPixWidth == 0 )
	pb += (pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 2) * sizeof( short );

    pR_PFME = (res_PFMEXTENSION *)pb;

    /*
     *   Now convert the extended PFM data.
     */

    pFDat->PFMExt.dfSizeFields = pR_PFME->dfSizeFields;

    pFDat->PFMExt.dfExtMetricsOffset = DwAlign4( pR_PFME->b_dfExtMetricsOffset );
    pFDat->PFMExt.dfExtentTable = DwAlign4( pR_PFME->b_dfExtentTable );

    pFDat->PFMExt.dfOriginTable = DwAlign4( pR_PFME->b_dfOriginTable );
    pFDat->PFMExt.dfPairKernTable = DwAlign4( pR_PFME->b_dfPairKernTable );
    pFDat->PFMExt.dfTrackKernTable = DwAlign4( pR_PFME->b_dfTrackKernTable );
    pFDat->PFMExt.dfDriverInfo = DwAlign4( pR_PFME->b_dfDriverInfo );
    pFDat->PFMExt.dfReserved = DwAlign4( pR_PFME->b_dfReserved );

    memcpy( &pFDat->DI, pFDat->pBase + pFDat->PFMExt.dfDriverInfo,
						 sizeof( DRIVERINFO ) );

    /*
     *    Also need to fill in the address of the EXTTEXTMETRIC. This
     *  is obtained from the extended PFM data that we just converted!
     */

    if( pFDat->PFMExt.dfExtMetricsOffset )
    {
        /*
         *    This structure is only an array of shorts, so there is
         *  no alignment problem.  However,  the data itself is not
         *  necessarily aligned in the resource!
         */

        int    cbSize;
        BYTE  *pbIn;             /* Source of data to shift */

        pbIn = pFDat->pBase + pFDat->PFMExt.dfExtMetricsOffset;
        cbSize = DwAlign2( pbIn );

        if( cbSize == sizeof( EXTTEXTMETRIC ) )
        {
            /*   Simply copy it!  */
            memcpy( pFDat->pETM, pbIn, cbSize );
        }
        else
            pFDat->pETM = NULL;         /* Not our size, so best not use it */

    }
    else
        pFDat->pETM = NULL;             /* Is non-zero when passed in */

    return;
}

BOOL    ConvertPFMToIFI(LPCTSTR lpstrPFM, LPCTSTR lpstrIFI, 
                        LPCTSTR lpstrUniq) {
    int       cWidth;           /* Number of entries in width table */
    HANDLE    hheap;            /* Handle to heap for storage */
    HANDLE    hOut;             /* The output file */

    DWORD     dwSize;           /* Size of input file */

    char    **ppcAliasList;     /* The alias list of names,  if present */

    PWSTR     pwstrUniqNm;      /* Unique name */

    IFIMETRICS   *pIFI;

    CD       *pCDSel;           /* Font selection command descriptor */
    CD       *pCDDesel;         /* Deselection - typically not required */

    FI_DATA   fid;              /* Keep track of stuff in the file */

    FONTDAT   FDat;             /* Converted form of data */

    EXTTEXTMETRIC  etm;         /* Additional data on this font */
    INT     bPrint = 0;

    char    acMessage[100];

    /*
     *    Create us a heap,  since all the functions we steal from rasdd
     *  require that we pass a heap handle!
     */

    if( !(hheap = HeapCreate(HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 ))) {
        /*   Not too good!  */
        wsprintf(acMessage, _T("HeapCreate() fails in pfm2ifi") ) ;
        MessageBox(NULL, acMessage, NULL, MB_OK);

        return  FALSE;
    }

    cWidth = strlen(lpstrUniq);

    if ( !(pwstrUniqNm = (PWSTR)HeapAlloc( hheap, 0, (cWidth + 1) * sizeof( WCHAR ) ) ) ){
		wsprintf(acMessage, "HeapAlloc() fails in pfm2ifi" );
        MessageBox(NULL, acMessage, NULL, MB_OK);
        return  FALSE;
    }

    MultiByteToWideChar( CP_ACP, 0, lpstrUniq, cWidth, pwstrUniqNm, cWidth );
    *(pwstrUniqNm + cWidth) = 0;

    /*
     *   Zero out the header structure.  This means we can ignore any
     * irrelevant fields, which will then have the value 0, which is
     * the value for not used.
     */

    memset( &fid, 0, sizeof( fid ) );
    memset( &FDat, 0, sizeof( FONTDAT ) );

    /*
     *   First step is to open the input file - this is done via MapFileA.
     *  We then pass the returned address around to various functions
     *  which do the conversion to something we understand.
     */

    if( !(FDat.pBase = MapFileA( lpstrPFM, &dwSize))) {
        wsprintf(acMessage, "Cannot open input file: %s", lpstrPFM);
        MessageBox(NULL, acMessage, NULL, MB_OK);

        return  FALSE;
    }

    /*
     *    Do some validation on the input file.
     */

    if  (!bValidatePFM( FDat.pBase, dwSize)) {
        wsprintf(acMessage, "%s is not a valid PFM file", lpstrPFM);

        return FALSE;
    }

    /*
     *    If there is a file with the same name as the input file, BUT with
     *  an extension of ._al, this is presumed to be an alias file.  An
     *  alias file consists of a set of alias names for this font.  The
     *  reason is that font names have not been very consistent,  so we
     *  provide aliases to the font mapper,  thus maintaining the format
     *  information for old documents.
     *    The file format is one alias per input line.  Names which
     *  are duplicates of the name in the PFM file will be ignored.
     */

    ppcAliasList = ppcGetAlias(hheap, lpstrPFM);

    FDat.pETM = &etm;               /* Important for scalable fonts */

    /*
     *   Create the output file.
     */

    hOut = CreateFile( lpstrIFI, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                                 FILE_ATTRIBUTE_NORMAL, 0);
    if( hOut == (HANDLE)-1) {
        wsprintf(acMessage, "Could not create output file '%s'", lpstrIFI);
        MessageBox(NULL, acMessage, NULL, MB_OK);
        return  FALSE;
    }

    /*
     *    Now have the data,  so civilise it: alignment etc.
     */

    ConvFontRes( &FDat );

    fid.fCaps = FDat.DI.fCaps;
    fid.wFontType = FDat.DI.wFontType; /* Device  FOnt Type */
    fid.wPrivateData = FDat.DI.wPrivateData;
    fid.sYAdjust = FDat.DI.sYAdjust;
    fid.sYMoved = FDat.DI.sYMoved;
    fid.wXRes = FDat.PFMH.dfHorizRes;
    fid.wYRes = FDat.PFMH.dfVertRes;

    /*
     *    Convert the font metrics.   Note that the last two parameters are
     * chosen with the understanding of how this function does its scaling.
     * Any changes to that method will require changes here too!!!
     */

    pIFI = FontInfoToIFIMetric( &FDat, hheap, pwstrUniqNm, ppcAliasList );
    fid.dsIFIMet.pvData = pIFI;

    if  (fid.dsIFIMet.pvData == 0) {
        /*   Should not happen!  */
        MessageBox(NULL, "Could not create IFIMETRICS", NULL, MB_OK);
        return  FALSE;
    }

    fid.dsIFIMet.cBytes = pIFI->cjThis;

    /*
     *    Also need to record which CTT is used for this font.  When the
     * resource is loaded,  this is turned into the address of the
     * corresponding CTT,  which is a resource somewhere else in the
     * mini-driver,  or in rasdd.
     */
    fid.dsCTT.cBytes = FDat.DI.sTransTab;

    /*
     *   Note that IFIMETRICS is only WORD aligned.  However,  since the
     *  following data only requires WORD alignment, we can ignore any
     *  lack of DWORD alignment.
     */

    /*
     *    If there is a width vector,  now is the time to extract it.
     *  There is one if dfPixWidth field in the PFM data is zero.
     */

    if( FDat.PFMH.dfPixWidth == 0 &&
        (fid.dsWidthTab.pvData = GetWidthVector( hheap, &FDat )) )
    {
        cWidth = pIFI->chLastChar - pIFI->chFirstChar + 1;
        fid.dsWidthTab.cBytes = cWidth * sizeof( short );
    }
    else
        fid.dsWidthTab.cBytes = 0;

    /*
     *    Finally,  the font selection/deselection strings.  These are
     *  byte strings,  sent directly to the printer.   Typically there
     *  is no deselection string.  These require WORD alignment,  and
     *  the GetFontSel function will round the size to that requirement.
     *  Since we follow the width tables,  WORD alignment is guaranteed.
     */

    if( pCDSel = GetFontSel( hheap, &FDat, 1 ) )
    {
        /*   Have a selection string,  so update the red tape etc.  */
        fid.dsSel.cBytes = (int)HeapSize( hheap, 0, (LPSTR)pCDSel );
        fid.dsSel.pvData = pCDSel;
    }

    if( pCDDesel = GetFontSel( hheap, &FDat, 0 ) )
    {
        /*   Also have a deselection string,  so record its presence */
        fid.dsDesel.cBytes = (int)HeapSize( hheap, 0, (LPSTR)pCDDesel );
        fid.dsDesel.pvData = pCDDesel;
    }

    if( FDat.pETM == NULL )
    {
        fid.dsETM.pvData = NULL;
        fid.dsETM.cBytes = 0;
    }
    else
    {
        fid.dsETM.pvData = (VOID*) &etm;
        fid.dsETM.cBytes = sizeof(etm);
    }

    /*
     *   Time to write the output file.
     */

    if( iWriteFDH( hOut, &fid ) < 0 )
        MessageBox(NULL, "CANNOT WRITE OUTPUT FILE", NULL, MB_OK);

    /*   All done,  so clean up and away  */
    UnmapViewOfFile( FDat.pBase );              /* Input no longer needed */

    HeapDestroy(hheap);               /* Probably not needed */
    CloseHandle(hOut);               //  Really, this would be a good idea!  

    return  TRUE;
}

/*
 *   An ASCII based copy of KentSe's mapfile function.
 */


/************************** Function Header *********************************
 * PVOID MapFileA( psz, pdwSize )
 *
 * Returns a pointer to the mapped file defined by psz.
 *
 * Parameters:
 *   psz   ASCII string containing fully qualified pathname of the
 *          file to map.
 *
 * Returns:
 *   Pointer to mapped memory if success, NULL if error.
 *
 * NOTE:  UnmapViewOfFile will have to be called by the user at some
 *        point to free up this allocation.
 *
 * History:
 *  11:32 on Tue 29 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *        Return the size of the file too.
 *
 *   05-Nov-1991    -by-    Kent Settle     [kentse]
 * Wrote it.
 ***************************************************************************/

PBYTE
MapFileA(LPCSTR psz, PDWORD pdwSize) {
    void   *pv;

    HANDLE  hFile, hFileMap;

    BY_HANDLE_FILE_INFORMATION  x;


    /*
     *    First open the file.  This is required to do the mapping, but
     *  it also allows us to find the size,  which is used for validating
     *  that we have something resembling a PFM file.
     */

    hFile = CreateFileA(psz, GENERIC_READ, FILE_SHARE_READ,
                             NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        printf( "MapFileA: CreateFileA( %s ) failed.\n", psz );

        return  NULL;
    }

    /*
     *   Find the size of the file now,  and set it in the caller's area.
     */

    if( GetFileInformationByHandle( hFile, &x ) )
        *pdwSize = x.nFileSizeLow;
    else
        *pdwSize = 0;

    // create the mapping object.

    if( !(hFileMap = CreateFileMappingA( hFile, NULL, PAGE_READONLY,
                                         0, 0, NULL )) )
    {
        printf( "MapFileA: CreateFileMapping failed.\n" );

        return  NULL;
    }

    // get the pointer mapped to the desired file.

    if( !(pv = MapViewOfFile( hFileMap, FILE_MAP_READ, 0, 0, 0 )) )
    {
        printf( "MapFileA: MapViewOfFile failed.\n" );

        return  NULL;
    }

    // now that we have our pointer, we can close the file and the
    // mapping object.

    if( !CloseHandle( hFileMap ) )
        printf( "MapFileA: CloseHandle( hFileMap ) failed.\n" );

    if( !CloseHandle( hFile ) )
        printf( "MapFileA: CloseHandle( hFile ) failed.\n" );

    return  (PBYTE) pv;
}



/************************** Function Header *******************************
 * bValidatePFM
 *      Look at a memory mapped PFM file,  and see if it seems reasonable.
 *
 * RETURNS:
 *      TRUE if OK,  else FALSE
 *
 * HISTORY:
 *  12:22 on Tue 29 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *      First version to improve usability of pfm2ifi.
 *
 **************************************************************************/

BOOL
bValidatePFM( PBYTE pBase, DWORD dwSize ) {

    DWORD    dwOffset;             /* Calculate offset of interest as we go */

    res_PFMHEADER     *rpfm;       /* In Win 3.1 format, UNALIGNED!! */
    res_PFMEXTENSION  *rpfme;      /* Final access to offset to DRIVERINFO */

    DRIVERINFO      di;            /* The actual DRIVERINFO data! */


    /*
     *    First piece of sanity checking is the size!  It must be at least
     *  as large as a PFMHEADER structure plus a DRIVERINFO structure.
     */

    if( dwSize < (sizeof( res_PFMHEADER ) + (sizeof( DRIVERINFO ) ) +
                  sizeof( res_PFMEXTENSION )) )
    {
        return  FALSE;
    }

    /*
     *    Step along to find the DRIVERINFO structure, as this contains
     *  some identifying information that we match to look for legitimacy.
     */
    rpfm = (res_PFMHEADER *)pBase;           /* Looking for fixed pitch */

    dwOffset = sizeof( res_PFMHEADER );

    if( rpfm->dfPixWidth == 0 )
    {
        /*   Proportionally spaced, so allow for the width table too! */
        dwOffset += (rpfm->dfLastChar - rpfm->dfFirstChar + 2) * sizeof( short );

    }

    rpfme = (res_PFMEXTENSION *)(pBase + dwOffset);

    /*   Next is the PFMEXTENSION data  */
    dwOffset += sizeof( res_PFMEXTENSION );

    if( dwOffset >= dwSize )
    {
        return  FALSE;
    }

    dwOffset = DwAlign4( rpfme->b_dfDriverInfo );

    if( (dwOffset + sizeof( DRIVERINFO )) > dwSize )
    {
        return   FALSE;
    }

    /*
     *    A memcpy is used because this data is typically not aigned. Ugh!
     */

    memcpy( &di, pBase + dwOffset, sizeof( di ) );


    if( di.sVersion > DRIVERINFO_VERSION )
    {
        return   FALSE;
    }

    return  TRUE;
}



/************************** Function Header *******************************
 * ppcGetAlias
 *      Return a pointer to an array of pointers to aliases for the given
 *      font name.
 *
 * RETURNS:
 *      Pointer to pointer to aliases;  0 on error.
 *
 * HISTORY:
 *  10:02 on Fri 28 May 1993    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 ***************************************************************************/


char   **
ppcGetAlias( HANDLE hheap, LPCSTR pcFile ) {


    char     *pcAlias;          /* The name of the alias file */
    char     *pcTmp;            /* Temporary stuffing around */
    char     *pcTmp2;           /* Yet more temporary stuffing around */

    char    **ppcRet;           /* The return value */

    FILE     *fAlias;           /* The alias file,  if there */



    ppcRet = (char  **)0;

    /*  The 5 is for the terminating NUL plus the characters "._al"  */
    pcAlias = (char *)HeapAlloc( hheap, 0, strlen( pcFile ) + 5 );

    if( pcAlias )
    {
        /*   Generate the file name, try to open it  */
        strcpy( pcAlias, pcFile );

        if( !(pcTmp = strrchr( pcAlias, '\\' )) )
        {
            /*   No \ in name - is there a /? */
            if( !(pcTmp = strrchr( pcAlias, '/' )) )
            {
                /*  Must be a simple name,  so point at the start of it */
                pcTmp = pcAlias;
            }
        }

        /*
         *    Now pcTmp points at the start of the last component of the
         *  file name.  IF this contains a '.',  then overwrite whatever
         *  follows by our extension,  otherwise add our extension to the end.
         */

        if( !(pcTmp2 = strrchr( pcTmp, '.' )) )
            pcTmp2 = pcTmp + strlen( pcTmp );


        strcpy( pcTmp2, ALIAS_EXT );

        fAlias = fopen( pcAlias, "r" );

        HeapFree( hheap, 0, (LPSTR)pcAlias );            /* No longer used */

        if( fAlias )
        {
            /*
             *    First,  read the file to count how many lines there are.
             *  Thus we can allocate the storage for the array of pointers.
             */

            char  acLine[ 256 ];              /* For reading the input line */
            int   iNum;                       /* Count the number of lines! */
            int   iIndex;                     /* Stepping through input */

            iNum = 0;
            while( fgets( acLine, sizeof( acLine ), fAlias ) )
                ++iNum;


            if( iNum )
            {
                /*  Some data available,  so allocate pointer and off we go */

                ++iNum;
                ppcRet = (char  **)HeapAlloc( hheap, 0, iNum * sizeof( char * ) );

                if( ppcRet )
                {

                    iIndex = 0;

                    rewind( fAlias );             /* Back to the start */

                    while( iIndex < iNum &&
                           fgets( acLine, sizeof( acLine ), fAlias ) )
                    {
                        /*
                         *   Do a little editing - delete leading space,
                         * trailing space + control characters.
                         */


                        pcTmp = acLine;

                        while( *pcTmp &&
                               (!isprint( *pcTmp ) || isspace( *pcTmp )) )
                                       ++pcTmp;


                        /*  Filter out the ending stuff too! */
                        pcTmp2 = pcTmp + strlen( pcTmp );

                        while( pcTmp2 > pcTmp &&
                               (!isprint( *pcTmp2 ) || isspace( *pcTmp2 )) )
                        {
                            /*
                             *   Zap it,  then onto the previous char. NOTE
                             * that this is not the best solution, but it
                             * is convenient.
                             */

                            *pcTmp2-- = '\0';            /* Zap the end */
                        }


                        ppcRet[ iIndex ] = (PSTR) HeapAlloc( hheap, 0,
                                                        strlen( pcTmp ) + 1 );

                        if( ppcRet[ iIndex ] )
                        {
                            /*  Copy input to new buffer */

                            strcpy( ppcRet[ iIndex ], pcTmp );
                            ++iIndex;              /* Next output slot */
                        }

                    }
                    ppcRet[ iIndex ] = NULL;
                }
            }
        }
    }

    return  ppcRet;
}

/************************* Function Header ********************************
 * strcpy2WChar
 *      Convert a char * string to a WCHAR string.  Basically this means
 *      converting each input character to 16 bits by zero extending it.
 *
 * RETURNS:
 *      Value of first parameter.
 *
 * HISTORY:
 *  12:35 on Thu 18 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Use the correct conversion method to Unicode.
 *
 *  09:36 on Thu 07 Mar 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 **************************************************************************/

 static PWSTR   strcpy2WChar(PWSTR pWCHOut, LPSTR lpstr) {

    /*
     *   Put buffering around the NLS function that does all this stuff.
     */

    int     cchIn;             /* Number of input chars */


    cchIn = strlen( lpstr ) + 1;

    MultiByteToWideChar( CP_ACP, 0, lpstr, cchIn, pWCHOut, cchIn );


    return  pWCHOut;
}

/*************************** Function Header *****************************
 * FontInfoToIFIMetric
 *      Convert the Win 3.1 format PFM data to NT's IFIMETRICS.  This is
 *      typically done before the minidrivers are built,  so that they
 *      can include IFIMETRICS, and thus have less work to do at run time.
 *
 * RETURNS:
 *      IFIMETRICS structure,  allocated from heap;  NULL on error
 *
 * HISTORY:
 *  13:58 on Fri 28 May 1993    -by-    Lindsay Harris   [lindsayh]
 *      Goes back a long way,  I am now adding the aliasing code.
 *
 **************************************************************************/

IFIMETRICS  * 
FontInfoToIFIMetric(FONTDAT *pFDat, HANDLE hheap, PWSTR pwstrUniqNm, 
                    char **ppcAliasList) {

    register  IFIMETRICS   *pIFI;

    FWORD  fwdExternalLeading;

    int    cWC;                 /* Number of WCHARS to add */
    int    cbAlloc;             /* Number of bytes to allocate */
    int    iI;                  /* Loop index */
    int    iCount;              /* Number of characters in Win 3.1 font */
    int    cAlias;              /* Number of aliases we have found */

    WCHAR *pwch;                /* For string manipulations */

    WCHAR   awcAttrib[ 256 ];   /* Generate attributes + BYTE -> WCHAR */
    BYTE    abyte[ 256 ];       /* Used (with above) to get wcLastChar etc */



    /*
     *    First step is to determine the length of the WCHAR strings
     *  that are placed at the end of the IFIMETRICS,  since we need
     *  to include these in our storage allocation.
     *
     *    There may also be an alias list.  If so, we need to include
     *  that in our calculation.   We have a NULL terminated array
     *  of pointers to the aliases,  one of which is most likely the
     *  name in the Win 3.1 format data.
     */


    cWC = 0;
    cAlias = 0;                /* No aliases is the default */

    if( ppcAliasList )
    {
        /*  There are aliases - count them and determine their size  */

        char   *pc;

        iI = 0;
        while( pc = ppcAliasList[ iI ] )
        {
            if( strcmp( pc, (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace ) )
            {
                /*   Not a match,  so add this one in too!  */

                cWC += strlen( pc ) + 1;            /* Terminating NUL */
                ++cAlias;
            }
            ++iI;
        }

        ++cWC;             /* There is an extra NUL to terminate the list */

    }


    cWC +=  3 * strlen( (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */

    /*
     *   Produce the desired attributes: Italic, Bold, Light etc.
     * This is largely guesswork,  and there should be a better method.
     */


    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';               /* Write out an empty string */

    if( pFDat->PFMH.dfItalic )
        wcscat( awcAttrib, L" Italic" );

    if( pFDat->PFMH.dfWeight >= 700 )
        wcscat( awcAttrib, L" Bold" );
    else
    {
        if( pFDat->PFMH.dfWeight < 200 )
            wcscat( awcAttrib, L" Light" );
    }

    /*
     *   The attribute string appears in 3 entries of IFIMETRICS,  so
     * calculate how much storage this will take.  NOTE THAT THE LEADING
     * CHAR IN awcAttrib is NOT placed in the style name field,  so we
     * subtract one in the following formula to account for this.
     */

    if( awcAttrib[ 0 ] )
        cWC += 3 * wcslen( awcAttrib ) - 1;

    cWC += wcslen( pwstrUniqNm ) + 1;   /* SHOULD BE PRINTER NAME */
    cWC += 4;                           /* Terminating nulls */

    cbAlloc = sizeof( IFIMETRICS ) + sizeof( WCHAR ) * cWC;

    pIFI = (IFIMETRICS *)HeapAlloc( hheap, 0, cbAlloc );
// raid 43536 prefix
	if (pIFI == NULL){
		return FALSE;
	}

    ZeroMemory( pIFI, cbAlloc );               /* In case we miss something */

    pIFI->cjThis = cbAlloc;                    /* Everything */

    pIFI->cjIfiExtra = 0;   //  Correct for all pre 4.0

    /*   The family name:  straight from the FaceName - no choice?? */

    pwch = (WCHAR *)(pIFI + 1);         /* At the end of the structure */
    pIFI->dpwszFamilyName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);

    strcpy2WChar( pwch, (LPSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */
    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */

    /*
     *   Append the alias list to the end of this,  if there is an alias list.
     */

    if( cAlias )
    {
        /*  Found some aliases - add them on.   */

        char   *pc;

        cAlias = 0;
        while( pc = ppcAliasList[ cAlias ] )
        {
            if( strcmp( pc, (LPCSTR) pFDat->pBase + pFDat->PFMH.dfFace ) )
            {
                /*   Not a match,  so add this one in too!  */

                strcpy2WChar( pwch, pc );
                pwch += wcslen( pwch ) + 1;         /* Next slot to fill */
            }
            ++cAlias;
        }

        /*
         *   The list is terminated with a double NUL.
         */

        *pwch++ = L'\0';
    }

    /*   Now the face name:  we add bold, italic etc to family name */

    pIFI->dpwszFaceName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);

    strcpy2WChar( pwch, (LPSTR) pFDat->pBase + pFDat->PFMH.dfFace );  /* Base name */
    wcscat( pwch, awcAttrib );


    /*   Now the unique name - well, sort of, anyway */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszUniqueName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);

    wcscpy( pwch, pwstrUniqNm );        /* Append printer name for uniqueness */
    wcscat( pwch, L" " );
    wcscat( pwch, (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName) );

    /*  Onto the attributes only component */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszStyleName = (unsigned)((BYTE *)pwch - (BYTE *)pIFI);
    wcscat( pwch, &awcAttrib[ 1 ] );


#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "Rasdd!pfm2ifi: STACK CORRUPTED BY awcAttrib" );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;
    }


    if( ((BYTE *)(pwch + wcslen( pwch ) + 1)) > ((BYTE *)pIFI + cbAlloc) )
    {
        DbgPrint( "Rasdd!pfm2ifi: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwch + wcslen( pwch ) + 1)),
                ((BYTE *)pIFI + cbAlloc) );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;

    }
#endif

    pIFI->dpFontSim   = 0;
    {
        //int i;

        pIFI->lEmbedId     = 0;
        pIFI->lItalicAngle = 0;
        pIFI->lCharBias    = 0;
        /*for (i=0;i<IFI_RESERVED;i++)
            pIFI->alReserved[i] = 0;*/
        pIFI->dpCharSets=0;
    }
    pIFI->jWinCharSet = (BYTE)pFDat->PFMH.dfCharSet;


    if( pFDat->PFMH.dfPixWidth )
    {
        pIFI->jWinPitchAndFamily |= FIXED_PITCH;
        pIFI->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);
    }
    else
        pIFI->jWinPitchAndFamily |= VARIABLE_PITCH;


    pIFI->jWinPitchAndFamily |= (((BYTE) pFDat->PFMH.dfPitchAndFamily) & 0xf0);

    pIFI->usWinWeight = (USHORT)pFDat->PFMH.dfWeight;

//
// IFIMETRICS::flInfo
//
    pIFI->flInfo |=
        FM_INFO_TECH_BITMAP    |
        FM_INFO_1BPP           |
        FM_INFO_INTEGER_WIDTH  |
        FM_INFO_NOT_CONTIGUOUS |
        FM_INFO_RIGHT_HANDED;

    /*  Set the alias bit,  if we have added an alias!  */

    if( cAlias )
        pIFI->flInfo |= FM_INFO_FAMILY_EQUIV;


    /*
     *    A scalable font?  This happens when there is EXTTEXTMETRIC data,
     *  and that data has a min size different to the max size.
     */

    if( pFDat->pETM && (pFDat->pETM->emMinScale != pFDat->pETM->emMaxScale) )
    {
       pIFI->flInfo        |= FM_INFO_ISOTROPIC_SCALING_ONLY;
       pIFI->fwdUnitsPerEm  = pFDat->pETM->emMasterUnits;
    }
    else
    {
        pIFI->fwdUnitsPerEm =
            (FWORD) (pFDat->PFMH.dfPixHeight - pFDat->PFMH.dfInternalLeading);
    }

    pIFI->fsSelection =
        ((pFDat->PFMH.dfItalic            ) ? FM_SEL_ITALIC     : 0)    |
        ((pFDat->PFMH.dfUnderline         ) ? FM_SEL_UNDERSCORE : 0)    |
        ((pFDat->PFMH.dfStrikeOut         ) ? FM_SEL_STRIKEOUT  : 0)    |
        ((pFDat->PFMH.dfWeight >= FW_BOLD ) ? FM_SEL_BOLD       : 0) ;

    pIFI->fsType        = FM_NO_EMBEDDING;
    pIFI->fwdLowestPPEm = 1;


    /*
     * Calculate fwdWinAscender, fwdWinDescender, fwdAveCharWidth, and
     * fwdMaxCharInc assuming a bitmap where 1 font unit equals one
     * pixel unit
     */

    pIFI->fwdWinAscender = (FWORD)pFDat->PFMH.dfAscent;

    pIFI->fwdWinDescender =
        (FWORD)pFDat->PFMH.dfPixHeight - pIFI->fwdWinAscender;

    pIFI->fwdMaxCharInc   = (FWORD)pFDat->PFMH.dfMaxWidth;
    pIFI->fwdAveCharWidth = (FWORD)pFDat->PFMH.dfAvgWidth;

    fwdExternalLeading = (FWORD)pFDat->PFMH.dfExternalLeading;

//
// If the font was scalable, then the answers must be scaled up
// !!! HELP HELP HELP - if a font is scalable in this sense, then
//     does it support arbitrary transforms? [kirko]
//

    if( pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
    {
        /*
         *    This is a scalable font:  because there is Extended Text Metric
         *  information available,  and this says that the min and max
         *  scale sizes are different:  thus it is scalable! This test is
         *  lifted directly from the Win 3.1 driver.
         */

        int iMU,  iRel;            /* Adjustment factors */

        iMU  = pFDat->pETM->emMasterUnits;
        iRel = pFDat->PFMH.dfPixHeight;

        pIFI->fwdWinAscender = (pIFI->fwdWinAscender * iMU) / iRel;

        pIFI->fwdWinDescender = (pIFI->fwdWinDescender * iMU) / iRel;

        pIFI->fwdMaxCharInc = (pIFI->fwdMaxCharInc * iMU) / iRel;

        pIFI->fwdAveCharWidth = (pIFI->fwdAveCharWidth * iMU) / iRel;

        fwdExternalLeading = (fwdExternalLeading * iMU) / iRel;
    }

    pIFI->fwdMacAscender =    pIFI->fwdWinAscender;
    pIFI->fwdMacDescender = - pIFI->fwdWinDescender;

    pIFI->fwdMacLineGap   =  fwdExternalLeading;

    pIFI->fwdTypoAscender  = pIFI->fwdMacAscender;
    pIFI->fwdTypoDescender = pIFI->fwdMacDescender;
    pIFI->fwdTypoLineGap   = pIFI->fwdMacLineGap;

    if( pFDat->pETM )
    {
        /*
         *    Zero is a legitimate default for these.  If 0, gdisrv
         *  chooses some default values.
         */
        pIFI->fwdCapHeight = pFDat->pETM->emCapHeight;
        pIFI->fwdXHeight = pFDat->pETM->emXHeight;

        pIFI->fwdSubscriptYSize = pFDat->pETM->emSubScriptSize;
        pIFI->fwdSubscriptYOffset = pFDat->pETM->emSubScript;

        pIFI->fwdSuperscriptYSize = pFDat->pETM->emSuperScriptSize;
        pIFI->fwdSuperscriptYOffset = pFDat->pETM->emSuperScript;

        pIFI->fwdUnderscoreSize = pFDat->pETM->emUnderlineWidth;
        pIFI->fwdUnderscorePosition = pFDat->pETM->emUnderlineOffset;

        pIFI->fwdStrikeoutSize = pFDat->pETM->emStrikeOutWidth;
        pIFI->fwdStrikeoutPosition = pFDat->pETM->emStrikeOutOffset;

    }
    else
    {
        /*  No additional information, so do some calculations  */
        pIFI->fwdSubscriptYSize = pIFI->fwdWinAscender/4;
        pIFI->fwdSubscriptYOffset = -(pIFI->fwdWinAscender/4);

        pIFI->fwdSuperscriptYSize = pIFI->fwdWinAscender/4;
        pIFI->fwdSuperscriptYOffset = (3 * pIFI->fwdWinAscender)/4;

        pIFI->fwdUnderscoreSize = pIFI->fwdWinAscender / 12;
        if( pIFI->fwdUnderscoreSize < 1 )
            pIFI->fwdUnderscoreSize = 1;

        pIFI->fwdUnderscorePosition = -pFDat->DI.sUnderLinePos;

        pIFI->fwdStrikeoutSize     = pIFI->fwdUnderscoreSize;

        pIFI->fwdStrikeoutPosition = (FWORD)pFDat->DI.sStrikeThruPos;
        if( pIFI->fwdStrikeoutPosition  < 1 )
            pIFI->fwdStrikeoutPosition = (pIFI->fwdWinAscender + 2) / 3;
    }

    pIFI->fwdSubscriptXSize = pIFI->fwdAveCharWidth/4;
    pIFI->fwdSubscriptXOffset =  (3 * pIFI->fwdAveCharWidth)/4;

    pIFI->fwdSuperscriptXSize = pIFI->fwdAveCharWidth/4;
    pIFI->fwdSuperscriptXOffset = (3 * pIFI->fwdAveCharWidth)/4;



    pIFI->chFirstChar = pFDat->PFMH.dfFirstChar;
    pIFI->chLastChar  = pFDat->PFMH.dfLastChar;

    /*
     *   We now do the conversion of these to Unicode.  We presume the
     * input is in the ANSI code page,  and call the NLS converion
     * functions to generate proper Unicode values.
     */

    iCount = pFDat->PFMH.dfLastChar - pFDat->PFMH.dfFirstChar + 1;

    for( iI = 0; iI < iCount; ++iI )
        abyte[ iI ] = iI + pFDat->PFMH.dfFirstChar;

    MultiByteToWideChar( CP_ACP, 0, (LPCSTR) abyte, iCount, awcAttrib, iCount );

    /*
     *   Now fill in the IFIMETRICS WCHAR fields.
     */

    pIFI->wcFirstChar = 0xffff;
    pIFI->wcLastChar = 0;

    /*   Look for the first and last  */
    for( iI = 0; iI < iCount; ++iI )
    {
        if( pIFI->wcFirstChar > awcAttrib[ iI ] )
            pIFI->wcFirstChar = awcAttrib[ iI ];

        if( pIFI->wcLastChar < awcAttrib[ iI ] )
            pIFI->wcLastChar = awcAttrib[ iI ];

    }

    pIFI->wcDefaultChar = awcAttrib[ pFDat->PFMH.dfDefaultChar ];
    pIFI->wcBreakChar = awcAttrib[ pFDat->PFMH.dfBreakChar ];

    pIFI->chDefaultChar = pFDat->PFMH.dfDefaultChar + pFDat->PFMH.dfFirstChar;
    pIFI->chBreakChar   = pFDat->PFMH.dfBreakChar   + pFDat->PFMH.dfFirstChar;


    if( pFDat->PFMH.dfItalic )
    {
    //
    // tan (17.5 degrees) = .3153
    //
        pIFI->ptlCaret.x      = 3153;
        pIFI->ptlCaret.y      = 10000;
    }
    else
    {
        pIFI->ptlCaret.x      = 0;
        pIFI->ptlCaret.y      = 1;
    }

    pIFI->ptlBaseline.x = 1;
    pIFI->ptlBaseline.y = 0;

    pIFI->ptlAspect.x =  pFDat->PFMH.dfHorizRes;
    pIFI->ptlAspect.y =  pFDat->PFMH.dfVertRes;

    pIFI->rclFontBox.left   = 0;
    pIFI->rclFontBox.top    =   (LONG) pIFI->fwdWinAscender;
    pIFI->rclFontBox.right  =   (LONG) pIFI->fwdMaxCharInc;
    pIFI->rclFontBox.bottom = - (LONG) pIFI->fwdWinDescender;

    pIFI->achVendId[0] = 'U';
    pIFI->achVendId[1] = 'n';
    pIFI->achVendId[2] = 'k';
    pIFI->achVendId[3] = 'n';

    pIFI->cKerningPairs = 0;

    pIFI->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    pIFI->panose.bFamilyType      = PAN_ANY;
    pIFI->panose.bSerifStyle      = PAN_ANY;
    if(pFDat->PFMH.dfWeight >= FW_BOLD)
    {
        pIFI->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else if (pFDat->PFMH.dfWeight > FW_EXTRALIGHT)
    {
        pIFI->panose.bWeight = PAN_WEIGHT_MEDIUM;
    }
    else
    {
        pIFI->panose.bWeight = PAN_WEIGHT_LIGHT;
    }
    pIFI->panose.bProportion      = PAN_ANY;
    pIFI->panose.bContrast        = PAN_ANY;
    pIFI->panose.bStrokeVariation = PAN_ANY;
    pIFI->panose.bArmStyle        = PAN_ANY;
    pIFI->panose.bLetterform      = PAN_ANY;
    pIFI->panose.bMidline         = PAN_ANY;
    pIFI->panose.bXHeight         = PAN_ANY;

    return   pIFI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projrec.cpp ===
/******************************************************************************

  Source File:  Project Record.CPP

  This implements the project record class, which tracks the details for
  multiple mini-drivers.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@prodigy.net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "NewProj.H"
#include	"projnode.h"
#include	"StrEdit.h"
#include	"codepage.h"
#include	<io.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord

IMPLEMENT_DYNCREATE(CProjectRecord, CDocument)

BEGIN_MESSAGE_MAP(CProjectRecord, CDocument)
	//{{AFX_MSG_MAP(CProjectRecord)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord construction/destruction

CProjectRecord::CProjectRecord() {
	m_ufTargets = Win2000;
    m_ufStatus = 0;
	m_bRCModifiedFlag = FALSE ;
	m_ctRCFileTimeStamp = (time_t) 0 ;
	m_dwDefaultCodePage = 1252 ;	// Not always correct but better than nothing
	m_dwDefaultCodePageNum = 1252 ;	// Not always correct but better than nothing
}

CProjectRecord::~CProjectRecord() {
}


/******************************************************************************

  CProjectRecord::OnOpenDocument

  First, open the file directly and try to read version information from it.
  Complain and fail the open if the file's version is greater than the MDT's
  current version number.  IE, fail if someone is trying to open a workspace
  on a down level (older) version of the MDT.

  Second, open a workspace in the normal way.  Then check the workspace's
  version to see if it is out of date.  If it is and the user agrees, do what is
  necessary to bring it up to date and then save the updated workspace file.

  All version related upgrade work should be managed from this routine.
  Depending on the age of the workspace file, there may be multiple upgrade
  steps required.  Be that as it may, the user should only be prompted once.
  NEW UPGRADE CHECKS AND STEPS SHOULD FOLLOW THE FORMAT LAYED OUT BELOW.

  There are various other workspace related checks that need to be done.  For
  example, the timestamp of the RC file needs to be checked to see if it has
  been changed by something other than the the MDT.  That work should be done
  and/or managed by code in this routine, too.  If possible (and I'm not sure
  it is), prompt the user no more than once per file (eg, RC or INF) for these
  things, too.  AGAIN, FOLLOW THE FORMAT LAYED OUT BELOW.

  The last thing done in this routine is to try to verify and - if necessary -
  update the location of files in the workspace.  If this fails and the user
  doesn't want to continue anyway, the Open is failed.  See VerUpdateFilePaths()
  for more information.

******************************************************************************/

BOOL CProjectRecord::OnOpenDocument(LPCTSTR lpszPathName)
{
	// Complain and fail if the user is trying to open a bogus file.

	CString cstmp(lpszPathName), cstmp2 ;
	cstmp.MakeUpper() ;
	cstmp2.LoadString(IDS_MDWExtension) ;
	if (cstmp.Find(cstmp2) == -1) {
		cstmp.LoadString(IDS_UnExpFilTypError) ;
		AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
		return FALSE ;
	} ;

	// Start by reading the MDW file's version stamp.
	
	try {
		CFile cfmdw(lpszPathName, CFile::modeRead | CFile::shareDenyNone) ;
		cfmdw.Read(&m_mvMDWVersion, MDWVERSIONSIZE) ;
		cfmdw.Close() ;
	}
	catch (CException* pce) {
		pce->ReportError() ;
		pce->Delete() ;
		return FALSE ;
	} ;

	// If the version tag is invalid, set the version number to the
	// default version number; IE, 0.

	if (strncmp(m_mvMDWVersion.acvertag, VERTAGSTR, MDWVERSIONSIZE) != 0)
		m_mvMDWVersion.uvernum = MDW_DEFAULT_VERSION ;

	// Now. make sure that the MDW's version isn't newer than the MDT's version.

	if (m_mvMDWVersion.uvernum > MDW_CURRENT_VERSION) {
		CString csmsg, cstmp ;
		cstmp = lpszPathName ;
		int nloc = cstmp.ReverseFind(_T('\\')) ;
		if (nloc >= 0)
			cstmp = cstmp.Right(cstmp.GetLength() - nloc - 1) ;
		csmsg.Format(IDS_MDWTooNewError, cstmp, m_mvMDWVersion.uvernum,
					 MDW_CURRENT_VERSION) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return FALSE ;
	} ;

	if (!CDocument::OnOpenDocument(lpszPathName))
		return FALSE ;

	// Save the project file's filespec.

	m_csProjFSpec = lpszPathName ;

	// If the workspace version is too old to upgrade, just return TRUE to
	// indicate that the file was successfully opened and that nothing else
	// can be done.

	if (m_mvMDWVersion.uvernum < MDW_FIRST_UPGRADABLE_VER)
		return TRUE ;

	// ***  Beginning of workspace upgrade management code.
	//
	//	o	Declare flags for each of the required upgrade steps.  These
	//		flags will be set in the following switch statement.
	//	o	There is also a flag that is set when any workspace upgrading is
	//		required.
	//	o	Make sure that all flags are initialized to false.
	//
	// NOTE: That the cases in the switch statement do not end with break
	// statements.  This is so that all of the upgrade flags for a workspace
	// currently at a particular version will be set when needed.  The
	// switch statement is set up so that if the workspace is version X, then
	// all of the upgrade flags for versions > X are set.
	//
	// Whenever a new workspace version is added:
	//	o	Declare a new flag for it.
	//	o	Add a new case statement to the switch statement for it.  (See note
	//		above.  You are actually adding a case statement for the previous
	//		version that will set the new version's flag.)
	//	o	Bupgradeneeded should always be set by the last case statement.
	//		Move the bupgradeneeded setting statement to the last case statement
	//		whenever a new case statement is added.

	bool bupgradeneeded, brctimestamp, bdefaultcodepage, bresdllnamechanged ;
	bool bnodrpathsinmdw, bfilesinw2ktree ;
	bupgradeneeded = brctimestamp = bdefaultcodepage = false ;
	bresdllnamechanged = bnodrpathsinmdw = bfilesinw2ktree = false ;
	switch (m_mvMDWVersion.uvernum) {
		case MDW_VER_STRING_RCIDS:	
			bdefaultcodepage = true ;
		case MDW_VER_DEFAULT_CPAGE:
			brctimestamp = true ;
		case MDW_VER_RC_TIMESTAMP:
			bresdllnamechanged = true ;
		case MDW_VER_NEW_DLLNAME:
			bnodrpathsinmdw = true ;
		case MDW_VER_NO_FILE_PATHS:
			bfilesinw2ktree = true ;
			bupgradeneeded = true ;
	} ;

	// If upgrade(s) are needed, declare a flag that indicates if any upgrading,
	// checking, or updating error has occurred.  If this flag is set, all
	// processing should stop.  Then...

	bool bprocerror = false ;
	bool buserwantstoupgrade = false ;
	CString csprompt ;
	if (bupgradeneeded) {

		// ...  Build a customized prompt for the user.
		//	o	Statements about upgrade tasks relevant to the user should also
		//		be added to the prompt.  For example, it should be noted when
		//		the RC file will be rewritten.  In this case (and below when
		//		other RC related checks are made), it is only necessary to
		//		test the "newest" RC related flag.  IE, the one associated with
		//		the latest MDW version.  This works because if any of the older
		//		RC flags are set, the newest one must be set too.
		//	o	Be concise so the message doesn't get too long.

		csprompt.Format(IDS_MDWUpgradeMsg1, DriverName()) ;
		if (bresdllnamechanged) {
			cstmp.LoadString(IDS_RCFileChanging) ;
			csprompt += cstmp ;
		} ;
		cstmp.LoadString(IDS_MDWUpgradeMsg2) ;
		csprompt += cstmp ;

		// ...	Do the work if the user wants to upgrade.
		//	o	Each upgrade step should be enclosed in an if statement that
		//		checks its individual flag and the processing error flag.

		if (AfxMessageBox(csprompt, MB_ICONQUESTION + MB_YESNO) == IDYES) {
			buserwantstoupgrade = true ;

			// If required, prompt the user for a default code page for the
			// driver and save it.
			
			if (!bprocerror && bdefaultcodepage)
				bprocerror = !UpdateDfltCodePage() ;

			// Reparse the RC file, rewrite it, and update its timestamp when
			// required.

			if (!bprocerror && bresdllnamechanged)
				bprocerror = !UpdateRCFile() ;

			// If required, rename the driver's subtree root directory from
			// "NT5" to "W2K".

			if (!bprocerror && bfilesinw2ktree)
				bprocerror = !UpdateDrvSubtreeRootName() ;

			// If everything is ok, update the MDW's version number.  (The MDW
			// file is saved later so that this only has to be done once.)

			if (!bprocerror)
				m_mvMDWVersion.uvernum = MDW_CURRENT_VERSION ;
		} ;
	} ;

	// ***	End of workspace upgrade management code except for possible MDW
	// ***	file reload.  (See below for details.)
	
	// ***	Begin workspace related checks and updates
	//		
	//	o	All of the checks for a specific file should be grouped together in
	//		one if statement so that only one prompt is required when the file
	//		needs to be updated.
	//	o	The if statement must contain the specific checks and, optionally,
	//		test if a related MDW upgrade step has already been performed or
	//		if a processing error has already occurred.
	//	o	If all of the checks/tests are "passed", perform whatever processing
	//		is required.
	//	o	If any updates are performed that require the MDW file to be
	//		rewritten, set bupgradeneeded.
	//	o	Always set bprocerror if an error occurs and tell the user what
	//		happened.

	// Reread the RC file if it has been changed and user oks it.

	if (!bprocerror && !bresdllnamechanged && RCFileChanged()) {
		cstmp = m_csRCName ;
		cstmp.MakeUpper() ;
		csprompt.Format(IDS_UpdateRCFile, cstmp) ;
		if (AfxMessageBox(csprompt, MB_ICONQUESTION + MB_YESNO) == IDYES) {
			if (!(bprocerror = !UpdateRCFile()))
				bupgradeneeded = true ;
		} ;
	} ;

	// ***	End of workspace related checks and updates
	
	// Save any MDW file changes that were made by any of the code above.

	if (bupgradeneeded && !bprocerror)
		bprocerror = (bool) !CDocument::OnSaveDocument(lpszPathName) ;

	// Occassionally, one of the changes done above requires the reloading of
	// the driver's MDW file.  That is done here.  The reasons are listed below.
	//	o When the driver's subtree root has been renamed from "NT5" to "W2K",
	//	  there are still copies of "NT5" in paths and filespecs in class
	//	  instances all over the place.  The easiest way to correct those paths,
	//	  etc is by reloading the MDW file.

	if (buserwantstoupgrade && bfilesinw2ktree && !bprocerror)
		if (!CDocument::OnOpenDocument(lpszPathName))
			return FALSE ;

    // Try to detect if driver files were moved and if they can be found.
	// Continue processing if the files were found or the user wants to
	// continue anyway.  Otherwise, cancel the loading of the workspace.
	
	if (!VerUpdateFilePaths())
		return FALSE ;

	// Workspace was loaded so return TRUE.
	// DEAD_BUG: Should I return TRUE even if there was a processing error???

	return TRUE ;
}


/******************************************************************************

  CProjectRecord::RCFileChanged

  If the MDW version is NOT large enough for this info to be relevant, return
  false.  If the version is large enough but m_ctRCFileTimeStamp is
  uninitialized, assert.

  If the everything is ok, get the timestamp for the RC file and compare it
  with m_ctRCFileTimeStamp.  If the RC file has changed, return true.
  Otherwise, return false.

******************************************************************************/

bool CProjectRecord::RCFileChanged()
{
	// Return no change if the MDW version is too low.

	if (m_mvMDWVersion.uvernum < MDW_VER_RC_TIMESTAMP)
		return false ;

	// Blow if the saved time is uninitialized.

	ASSERT(m_ctRCFileTimeStamp.GetTime() > 0) ;

	// Get the timestamp for the RC file, compare it with the time the MDT last
	// modified the file, and return the result.

	CTime ct ;
	if (!GetRCFileTimeStamp(ct))
		return false ;
	//TRACE("RC timestamp = %s     Saved timestamp = %s\n", ct.Format("%c"), m_ctRCFileTimeStamp.Format("%c")) ;
	if (ct > m_ctRCFileTimeStamp)
		return true ;
	else
		return false ;
}


/******************************************************************************

  CProjectRecord::GetRCFileTimeStamp

  Get the last modified time stamp for this project's RC file and load it into
  the specified parameter.  Return true if this succeeds.  Otherwise, return
  false.

******************************************************************************/

bool CProjectRecord::GetRCFileTimeStamp(CTime& ct)
{
	try {
		// Open the RC file

		CString csrcfspec(TargetPath(Win2000) + '\\' + m_csRCName) ;
		CFile cfrc(csrcfspec, CFile::modeRead + CFile::shareDenyNone) ;
		
		// Get RC file status information
		
		CFileStatus cfs ;
		cfrc.GetStatus(cfs) ;

		// Copy the last modified time stamp into the caller's variable

		ct = cfs.m_mtime ;

		// All went well so...

		return true ;
	}
	catch (CException* pce) {
		pce->ReportError() ;
		pce->Delete() ;
		return false ;
	} ;

	return false ;
}


/******************************************************************************

  CProjectRecord::UpdateRCFile

  This routine is called when it has been determined that the RC file was
  modified outside of the MDT.  This routine will reparse the RC file to
  update the internal data structures, merge the new data with the old data,
  and write a new RC file based on the combined information.  Then the
  timestamp for the last time the MDT modified the RC file is updated.

  Return true if all goes well.  Otherwise, return false.

******************************************************************************/

bool CProjectRecord::UpdateRCFile()
{
	// Build a filespec for the RC file.

	CString csrcfspec(TargetPath(Win2000) + '\\' + m_csRCName) ;

	// Reparse the RC file and update internal data structures.

	if (!m_cdr.ReparseRCFile(csrcfspec))
		return false ;

	// Write a new RC file base on the updated information.

	if  (!m_cdr.Generate(Win2000, csrcfspec))	{
		AfxMessageBox(IDS_RCWriteError) ;
		return  false ;  //  TODO:   Cleanup and backtracking
	} ;

	// Update the last time the RC file was written by the MDT timestamp.

	GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CProjectRecord::UpdateDfltCodePage

  Prompt the user for a default code page and save it.  Fail (return) false if
  the user cancels.  Return true if all goes well.

******************************************************************************/

bool CProjectRecord::UpdateDfltCodePage()
{
	// Display the dialog box to prompt for the code page.

	CGetDefCodePage dlg ;
	if (dlg.DoModal() == IDCANCEL)
		return false ;

	// A code page was selected, get it out of the dialog class and save it in
	// this class.  Both the cp/translated Far East resource ID and the real
	// CP are saved.

	SetDefaultCodePage(dlg.GetDefaultCodePage()) ;
	SetDefaultCodePageNum(dlg.GetDefaultCodePageNum()) ;


	// All went well so...

	return true ;
}


/******************************************************************************

  CProjectRecord::UpdateDrvSubtreeRootName

  This routine is called when the root of the driver's subtree needs to be
  renamed.  Older versions of the MDT would create a directory named "NT5" in
  which to put the driver's files and subdirectories.  Now that NT 5.0 has
  been renamed to Windows 2000 the new driver root directory should be called
  "W2K".  This routine will rename the driver's "NT5" directory to "W2K".
  Return true if the directory rename is successful.  Otherwise, return false.

******************************************************************************/

bool CProjectRecord::UpdateDrvSubtreeRootName()
{
	// Isolate the path for the MDW file.

	int npos = m_csProjFSpec.ReverseFind(_T('\\')) ;
	CString cspath = m_csProjFSpec.Left(npos + 1) ;

	// Now use the MDW file's path to build the old and new root directory
	// paths.

	CString csoldpath, csnewpath ;
	csoldpath.LoadString(IDS_OldDriverRootDir) ;
	csoldpath = cspath + csoldpath ;
	csnewpath.LoadString(IDS_NewDriverRootDir) ;
	csnewpath = cspath + csnewpath ;

	// Rename the directory.  Complain and return false if this fails.

	try {
		if (rename(csoldpath, csnewpath) != 0)
			return false ;
	}
	catch (CException *pce) {
		pce->ReportError() ;
		pce->Delete() ;
		return FALSE ;
	} ;

	// Update this path so that the RC file checks will work later in the
	// code.

	m_csW2000Path = csnewpath ;
	// All went well so...

	return true ;
}


/******************************************************************************

  CProjectRecord::OnSaveDocument

  Before saving the document, rebuild the RC file when needed and check the
  workspace for consistency.

******************************************************************************/

BOOL CProjectRecord::OnSaveDocument(LPCTSTR lpszPathName)
{
	// Check to see if the RC file needs to be rewritten first.  If the RC file
	// needs to be rewritten but this operation fails, return false (FAILURE).

	if (m_bRCModifiedFlag) {

		// If the workspace has no version information, rewriting the RC file
		// will erase the string table from the file.  The user probably
		// won't want to do this.  Only continue if he says so.

		int nqr = IDYES ;		// Query result
		if (m_mvMDWVersion.uvernum == MDW_DEFAULT_VERSION) {
			CString csmsg ;
			csmsg.Format(IDS_RCRewriteQuestion, m_cdr.Name(), m_csRCName) ;
			nqr = AfxMessageBox(csmsg, MB_YESNO+MB_ICONQUESTION+MB_DEFBUTTON2) ;
		} ;

		if (nqr == IDYES) {
			if  (!m_cdr.Generate(Win2000, TargetPath(Win2000) + '\\' + m_csRCName))	{
				AfxMessageBox(IDS_RCWriteError) ;
				return  FALSE ;  //  TODO:   Cleanup and backtracking
			} ;

			// Update the last time the RC file was written by the MDT timestamp.

			GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;
		} ;
		m_bRCModifiedFlag = FALSE ;
	} ;

	// Check the workspace for consistency before continuing.  Save, set, and
	// restore the directory around this call.

	CString cscurdir ;
	::GetCurrentDirectory(512, cscurdir.GetBuffer(512)) ;
	cscurdir.ReleaseBuffer() ;
	SetCurrentDirectory(m_csW2000Path) ;
	BOOL brc = m_cdr.WorkspaceChecker(true) ;
	SetCurrentDirectory(cscurdir) ;

	// Save the project file's filespec.

	m_csProjFSpec = lpszPathName ;

	// Now save the document (workspace) file.
	//
	// NOTE:	The value returned is virtually assured to be TRUE.  This is
	//			done to make sure the document is saved when the user requests
	//			it.  This has some unwanted side effects that I don't know
	//			how to avoid.  First, if the save is happening because the
	//			document is closing, it will still close even if there are
	//			workspace errors that the user wants to see.  Second, if the
	//			save is happening because the app is closing, the app will
	//			still close even if there are workspace errors that the user
	//			wants to see.
	// raid 123448
	if (m_mvMDWVersion.uvernum == MDW_VER_FILES_IN_W2K_TREE )
		m_mvMDWVersion.uvernum = MDW_VER_YES_FILE_PATHS ;

	return CDocument::OnSaveDocument(lpszPathName) ;
}


CString CProjectRecord::TargetPath(UINT ufFlags) const {

    switch(ufFlags) {
        case    Win95:
            return  m_csWin95Path;

        case    WinNT3x:
            return  m_csNT3xPath;

        case    WinNT40:
            return  m_csNT40Path;

        case    Win2000:
            return  m_csW2000Path;
    }

    AfxThrowNotSupportedException();

    return  m_csWin95Path;
}

//  This routine establishes the source RC file's name, and the initial paths
//  for all of the potential targets.

void    CProjectRecord::SetSourceRCFile(LPCTSTR lpstrSource) {
    m_csSourceRCFile = lpstrSource;

    m_csW2000Path = m_csNT40Path = m_csNT3xPath = m_csWin95Path =
        m_csSourceRCFile.Left(m_csSourceRCFile.ReverseFind(_T('\\')));
		
	// The last path component of the Windows 2000 files' directory, depends on
	// the version of the MDW file.

	CString cs ;
	if (m_mvMDWVersion.uvernum >= MDW_VER_FILES_IN_W2K_TREE)
		cs.LoadString(IDS_NewDriverRootDir) ;
	else
		cs.LoadString(IDS_OldDriverRootDir) ;
	m_csW2000Path += _T("\\") ;
	m_csW2000Path += cs ;

    m_csNT40Path += _T("\\NT4");
    m_csNT3xPath += _T("\\NT3");

    //  Trim the path name (including trailing \) to get driver name and RC
    m_csRCName = m_csSourceRCFile.Mid(1 + m_csWin95Path.GetLength());
    if  (m_csRCName.Find('.') != -1)
        m_csRCName = m_csRCName.Left(m_csRCName.Find('.'));
    m_cdr.Rename(m_csRCName);
    m_csRCName += _T(".RC");
    m_ufStatus = 0;
}

//  This is a helper function- it validates a new path name, and if it is
//  valid, returns TRUE, and stores it in the given CString;

static BOOL ValidatePath(CString& csTarget, LPCTSTR lpstrPath) {

    if  (!csTarget.CompareNoCase(lpstrPath)) {
        //  Trivial- no change = success!
        return  TRUE;
    }

    //  Determine the current directory, so we don't lose it.

    CString csCurrentDirectory, csNewOne;

    GetCurrentDirectory(MAX_PATH, csCurrentDirectory.GetBuffer(MAX_PATH));

    csCurrentDirectory.ReleaseBuffer();

    //  Attempt to switch to the new directory.  If we succeed, we're done.

    if  (SetCurrentDirectory(lpstrPath)) {
        GetCurrentDirectory(MAX_PATH, csTarget.GetBuffer(MAX_PATH));
        csTarget.ReleaseBuffer();

        SetCurrentDirectory(csCurrentDirectory);
        return  TRUE;
    }

    //  Attempt to create the new directory.  If this succeeds, delete the
    //  directory, and note our success our failure, either way.

    if  (CreateDirectory(lpstrPath, NULL)) {
        SetCurrentDirectory(lpstrPath);
        GetCurrentDirectory(MAX_PATH, csTarget.GetBuffer(MAX_PATH));
        csTarget.ReleaseBuffer();

        SetCurrentDirectory(csCurrentDirectory);
        RemoveDirectory(csTarget);
        return  TRUE;
    }
    return  FALSE;  //  Nothing worked, give it up...
}

//  The following loads all of the driver resources.

BOOL    CProjectRecord::LoadResources() {

    if  (!m_cdr.Load(*this))
        return  FALSE;

    m_ufStatus |= UniToolRun;
    m_ufStatus &= ~(ConversionsDone | NTGPCDone);
    SetModifiedFlag();

    return  TRUE;
}

//  The following member validates a new target path name.

BOOL    CProjectRecord::SetPath(UINT ufTarget, LPCTSTR lpstrPath) {

    switch  (ufTarget) {
        case    Win2000:
            m_ufStatus&= ~ConversionsDone;
            return  ValidatePath(m_csW2000Path, lpstrPath);

        case    WinNT40:
            m_ufStatus&= ~(ConversionsDone | NTGPCDone);
            return  ValidatePath(m_csNT40Path, lpstrPath);

        case    WinNT3x:
            m_ufStatus&= ~(ConversionsDone | NTGPCDone);
            return  ValidatePath(m_csNT3xPath, lpstrPath);
    }

    _ASSERTE(FALSE); //  This should never happen!
    return  FALSE;
}

//  When we create a new document (aka project, aka driver), we invoke the
//  new project wizard

BOOL CProjectRecord::OnNewDocument() {
	if  (!CDocument::OnNewDocument())
        return  FALSE;
		// raid 104822 : add real new document : kill below
    //  Invoke the wizard.
    CNewConvertWizard cnpw(*this);

	// Initialize the workspace's version number.
	
	m_mvMDWVersion.uvernum = MDW_CURRENT_VERSION ;

    return  cnpw.DoModal() == ID_WIZFINISH;

	return TRUE;
  }


/////////////////////////////////////////////////////////////////////////////
// CProjectRecord serialization
//
// See "MDT Workspace Versioning" in projrec.h for more information.
//

void CProjectRecord::Serialize(CArchive& car)
{
	// The first thing to do when storing is to build and write out the MDW
	// version information.  Only do this when the workspace's version number
	// is not MDW_DEFAULT_VERSION; IE, the WS has a version number.
	
	if (car.IsStoring()) {
		if (m_mvMDWVersion.uvernum > MDW_DEFAULT_VERSION) {
			StringCchCopyA(m_mvMDWVersion.acvertag, CCHOF(m_mvMDWVersion.acvertag), VERTAGSTR) ;
			car.Write(&m_mvMDWVersion, MDWVERSIONSIZE) ;
		} ;

	// When loading, CProjectRecord::OnOpenDocument() initializes and uses
	// m_mvMDWVersion.  Then the file is closed.  The file is reopened at the
	// beginning by CDocument::OnOpenDocument().  This means that when the file
	// contains version info, we must skip passed it so that the rest of the
	// serialization process can continue as expected.

	} else if (m_mvMDWVersion.uvernum >= MDW_FIRST_UPGRADABLE_VER)
		car.Read(&m_mvMDWVersion, MDWVERSIONSIZE) ;

	// m_csW2000Path needs to be loaded before m_cdr.Serialize() is called
	// so that the string can be used in the function and/or the routines it
	// calls.
//   raid 123448
	if (m_mvMDWVersion.uvernum < MDW_VER_YES_FILE_PATHS) {
		m_csW2000Path = car.GetFile()->GetFilePath() ;
		m_csW2000Path = m_csW2000Path.Left(m_csW2000Path.ReverseFind(_T('\\'))) ;
		
		// The last path component depends on the version of the MDW file.

		CString cs ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_FILES_IN_W2K_TREE)
			cs.LoadString(IDS_NewDriverRootDir) ;
		else
			cs.LoadString(IDS_OldDriverRootDir) ;
		m_csW2000Path += _T("\\") ;	// b. 2 lines : Raid 123448 !;; can cancel W2K dir.
		m_csW2000Path += cs ;
	} ; 

	// Now that versioning is done, get on with saving or restoring the
	// workspace's state.

    m_cdr.Serialize(car) ;
	if (car.IsStoring()) {
		if (m_mvMDWVersion.uvernum >= MDW_VER_YES_FILE_PATHS)   // Raid 123448
			car << m_csW2000Path ;
		car << m_csNT40Path << m_csNT3xPath << m_csWin95Path <<
            m_csSourceRCFile << m_ufTargets << m_ufStatus << m_csRCName ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_DEFAULT_CPAGE)
			car << m_dwDefaultCodePage ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_RC_TIMESTAMP)
			car << m_ctRCFileTimeStamp ;
	} else {
		if (m_mvMDWVersion.uvernum >= MDW_VER_YES_FILE_PATHS)
			car >> m_csW2000Path ;
		car >> m_csNT40Path >> m_csNT3xPath >> m_csWin95Path >>
            m_csSourceRCFile >> m_ufTargets >> m_ufStatus >> m_csRCName ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_DEFAULT_CPAGE) {
			car >> m_dwDefaultCodePage ;

			// Use m_dwDefaultCodePage to compute m_dwDefaultCodePageNum so
			// that a new MDW version is NOT needed to support
			// m_dwDefaultCodePageNum.  (See the declaration of these variables
			// for more info.)

			short scp = (short) ((WORD) m_dwDefaultCodePage) ;
			switch (scp) {
				case -10:
					m_dwDefaultCodePageNum = 950 ;
					break ;
				case -16:
					m_dwDefaultCodePageNum = 936 ;
					break ;
				case -17:
					m_dwDefaultCodePageNum = 932 ;
					break ;
				case -18:
					m_dwDefaultCodePageNum = 949 ;
					break ;
				default:
					m_dwDefaultCodePageNum = m_dwDefaultCodePage ;
					break ;
			} ;
		} ;
		if (m_mvMDWVersion.uvernum >= MDW_VER_RC_TIMESTAMP)
			car >> m_ctRCFileTimeStamp ;
	}

	
	// Last, tell the user that the driver in this workspace should be
	// reconverted when there is no version information in the MDW file.
	// Only do this when loading.

	if (!car.IsStoring() && m_mvMDWVersion.uvernum == MDW_DEFAULT_VERSION) {
		CString csmsg ;
		csmsg.Format(IDS_NoVersionError, m_cdr.Name()) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
	} ;
}


//  Private Worker Routine- this establishes a directory, by first attempting
//  to go to it, then creating it if that failes.  The current directory is
//  preserved.

static BOOL Establish(CString   csNew) {
    CString csCurrent;

    GetCurrentDirectory(MAX_PATH, csCurrent.GetBuffer(MAX_PATH));
    csCurrent.ReleaseBuffer();

    if  (SetCurrentDirectory(csNew)) {
        SetCurrentDirectory(csCurrent);
        return  TRUE;
    }

    return  CreateDirectory(csNew, NULL);
}

//  Private worker routine.  This establishes the directory structure given it,
//  consisting of a named route, and two branches.

static BOOL CreateStructure(const CString& csRoot, LPCTSTR lpstrFont,
                            LPCTSTR lpstrMap) {
    return  Establish(csRoot) && Establish(csRoot + '\\' + lpstrFont) &&
        Establish(csRoot + '\\' + lpstrMap);
}

/******************************************************************************

  CProjectRecord::BuildStructure

  This builds the directory structure needed for all conversion targets.  This
  is done before files are generated so that the renaming calls in many of the
  project nodes do not fail.

******************************************************************************/

BOOL    CProjectRecord::BuildStructure(unsigned uVersion) {

    switch  (uVersion) {

        case    Win2000:

            return  CreateStructure(TargetPath(Win2000), _T("UFM"), _T("GTT"));

        case    WinNT40:

            return  CreateStructure(TargetPath(WinNT40), _T("IFI"), _T("RLE"));

        case    WinNT3x:

            return  CreateStructure(TargetPath(WinNT3x), _T("IFI"), _T("RLE"));
    }

    _ASSERTE(FALSE);

    return  FALSE;
}


/******************************************************************************

  CProjectRecord::GenerateTargets

  This one is a workhorse- it generates all of the files needed for all of the
  enabled targets, using the Win 3.x files as a base, with the exception of the
  NT GPC extensions, which require an interactive step.

******************************************************************************/

BOOL    CProjectRecord::GenerateTargets(WORD wfGPDConvert)
{
	int			nerrorid ;		// Error message ID returned by some routines

    //  Generate the files needed for Win2K

    if  (!CreateStructure(TargetPath(Win2000), _TEXT("UFM"), _TEXT("GTT")))
        return  FALSE;  //  TODO:   Feedback

    m_cdr.ForceCommonRC(FALSE);	// Don't use common.rc at all

	// Find and remove the standard include files from the array of include
	// files.  This will keep them from being added to the RC file twice.

	CString cs ;
	cs.LoadString(IDS_StdIncludeFile1) ;
	m_cdr.RemUnneededRCInclude(cs) ;
    if  (wfGPDConvert > 1) {
		cs.LoadString(IDS_StdIncludeFile2) ;
		m_cdr.RemUnneededRCInclude(cs) ;
	} ;
	cs.LoadString(IDS_StdIncludeFile3) ;
	m_cdr.RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile4) ;
	m_cdr.RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile5) ;
	m_cdr.RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_OldIncludeFile1) ;
	m_cdr.RemUnneededRCInclude(cs) ;

    //  Generate the RC file

	if  (!m_cdr.Generate(Win2000, TargetPath(Win2000) + '\\' + m_csRCName))
        return  FALSE;  //  TODO:   Cleanup and feedback

	// Update the last time the RC file was written by the MDT timestamp.

	GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

	//  Generate the GTT files

#if 0
    for (unsigned u = 0; u < m_cdr.MapCount(); u++) {

		CString	csfspec ;
        try {
			csfspec = m_cdr.GlyphTable(u).FileName() ;
            CFile   cfGTT(csfspec,
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive);

            if  (!m_cdr.GlyphTable(u).Generate(cfGTT)) {
				m_cdr.LogConvInfo(IDS_FileWriteError, 1, &csfspec) ;
				return  FALSE ;
			} ;
        }
        catch   (CException *pce) {
            pce -> ReportError();
            pce -> Delete();
			m_cdr.LogConvInfo(IDS_FileWriteError, 1, &csfspec) ;
            return  FALSE;
        }
    }
#else
	unsigned u ;
#endif

    //  Generate the UFM files

	CGlyphMap* pcgm ;
    for (u = 0; u < m_cdr.FontCount(); u++) {
		CFontInfo& cfi = m_cdr.Font(u) ;

		// Load the UFM's PFM if it hasn't been loaded already.  This is done
		// here to get possible GTT mapping info that is used if a GTT must be
		// built for this UFM.  This shouldn't fail.  If it does fail, the
		// conversion cannot continue.

		if (!cfi.MapPFM()) {
			CString	csfspec ;
			csfspec = cfi.FileName() ;
			m_cdr.LogConvInfo(IDS_UFMGenError, 1, &csfspec) ;
            return  FALSE;
		} ;

        // Map the UFM -> GTT, so we can convert the UFM
		//
		// DEAD_BUG:	The code page field in the font class instances has not
		//			been set yet so send 0 instead.  This might be fixable.

		/*		res_PFMHEADER  *pPFM = (res_PFMHEADER *) cfi.m_cbaPFM.GetData();
	
		BYTE dfCharSet = pPFM ->dfCharSet;
		WORD  CharSetCodePage = 0;
		switch (dfCharSet) {
		case  SHIFTJIS_CHARSET:
				CharSetCodePage = 932;
				break;
		case GB2312_CHARSET:
				CharSetCodePage = 936;
				break;
		case HANGEUL_CHARSET:
		case JOHAB_CHARSET:
				CharSetCodePage = 936;
				break;
		case CHINESEBIG5_CHARSET:
				CharSetCodePage = 950;
				break;
		}
*/		
		//TRACE("***  GetFirstPFM() = %d\t\tGetLastPFM() = %d\n", cfi.GetFirstPFM(), cfi.GetLastPFM()) ;
        pcgm = CGlyphMap::Public(cfi.Translation(), 0, GetDefaultCodePage(),
								 cfi.GetFirstPFM(), cfi.GetLastPFM()) ;
        if (pcgm)
            cfi.SetTranslation(pcgm) ;
        else
            for (unsigned uGTT = 0; uGTT < m_cdr.MapCount(); uGTT++)
                if (cfi.Translation() ==
                 ((WORD) m_cdr.GlyphTable(uGTT).nGetRCID())) {
                    cfi.SetTranslation(&m_cdr.GlyphTable(uGTT));
                    break;
                }

		// Log an error if the UFM could not be generated and stop.  Continuing
		// could cause things like the RC file and Workspace View to be wrong.
		// In addition, delete any partially generated UFM file.

		if  ((nerrorid = cfi.Generate(cfi.FileName())) != 0) {
			CString	csfspec ;
			csfspec =
				(nerrorid == IDS_BadCTTID) ? cfi.SourceName() : cfi.FileName() ;
			m_cdr.LogConvInfo(nerrorid, 1, &csfspec) ;
			try {
				CFile::Remove(cfi.FileName()) ;
			}
			catch(CFileException* pce) {
				pce = pce ;
			}
            return  FALSE;
		} ;
    }

    //  Generate the GPD files

    if  (!m_cdr.ConvertGPCData(*this, wfGPDConvert))
        return  FALSE;  //  Error will already have been reported to user.

    //  Simplest case is no NT versions selected.  By definition, we are done.

    if  (!IsTargetEnabled(WinNT40 | WinNT3x)) {
        m_ufStatus |= ConversionsDone;
        return  TRUE;
    }

    //  Generate the files needed for NT 4.0

    if  (IsTargetEnabled(WinNT40)) {
        if  (!CreateStructure(TargetPath(WinNT40), _TEXT("IFI"), _TEXT("RLE")))
            return  FALSE;  //  TODO:   Feedback

        //  Generate the RC file
        if  (!m_cdr.Generate(WinNT40, TargetPath(WinNT40) + '\\' + m_csRCName))
            return  FALSE;  //  TODO:   Cleanup and feedback

		// Update the last time the RC file was written by the MDT timestamp.

		GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

		//  Copy the GPC file
        if  (!CopyFile(TargetPath(Win95) + m_cdr.GPCName(0),
             TargetPath(WinNT40) + m_cdr.GPCName(0), FALSE))
             return FALSE;  //  TODO:   Cleanup and feedback

        //  Generate the RLE files

        for (u = 0; u < m_cdr.MapCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\RLE\\") +
                m_cdr.GlyphTable(u).Name() + _TEXT(".RLE");

            CFile   cfRLE;

            if  (!cfRLE.Open(csName,
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
                return  FALSE;  //  As usal, TODO:  Feedback...

            if  (!m_cdr.GlyphTable(u).RLE(cfRLE))
                return  FALSE;  //  TODO:   Ditto
        }

        //  Generate the IFI files
        for (u = 0; u < m_cdr.OriginalFontCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\IFI\\") +
                m_cdr.Font(u).Name() + _TEXT(".IFI");
            if  (!m_cdr.Font(u).Generate(csName))
                return  FALSE;  //  TODO:   Ditto
        }
    }

    //  Generate the files needed for NT 3.x

    if  (IsTargetEnabled(WinNT3x)) {
        if  (!CreateStructure(TargetPath(WinNT3x), _TEXT("IFI"), _TEXT("RLE")))
            return  FALSE;  //  TODO:   Feedback

        //  Generate the RC file
        if  (!m_cdr.Generate(WinNT3x, TargetPath(WinNT3x) + '\\' + m_csRCName))
            return  FALSE;  //  TODO:   Cleanup and feedback

		// Update the last time the RC file was written by the MDT timestamp.

		GetRCFileTimeStamp(m_ctRCFileTimeStamp) ;

        //  Copy the GPC file
        if  (!CopyFile(TargetPath(Win95) + m_cdr.GPCName(0),
             TargetPath(WinNT3x) + m_cdr.GPCName(0), FALSE))
             return FALSE;  //  TODO:   Cleanup and feedback

        //  Generate the RLE files

        for (u = 0; u < m_cdr.MapCount(); u++) {
            CString csName = TargetPath(WinNT40) + _TEXT("\\RLE\\") +
                m_cdr.GlyphTable(u).Name() + _TEXT(".RLE");

            CFile   cfRLE;

            if  (!cfRLE.Open(csName,
                CFile::modeCreate | CFile::modeWrite | CFile::shareExclusive))
                return  FALSE;  //  As usal, TODO:  Feedback...

            if  (!m_cdr.GlyphTable(u).RLE(cfRLE))
                return  FALSE;  //  TODO:   Ditto
        }

        //  Generate the IFI files
        for (u = 0; u < m_cdr.OriginalFontCount(); u++) {
            CString csName = TargetPath(WinNT3x) + _TEXT("\\IFI\\") +
                m_cdr.Font(u).Name() + _TEXT(".IFI");
            if  (!m_cdr.Font(u).Generate(csName))
                return  FALSE;  //  TODO:   Ditto
        }
    }

    m_ufStatus |= ConversionsDone;

    return  TRUE;
}

/******************************************************************************

  CProjectRecord::GPDConversionCheck

  If any of the GPD files have unresolved errors from the conversion process,
  it will open all of them, if the user asks, so they can fix the problem(s)
  forthwith- or leave them for the next time the workspace is edited.

******************************************************************************/

void    CProjectRecord::GPDConversionCheck(BOOL bReportSuccess) {
    CUIntArray  cuaSuspects;

    for (unsigned u = 0; u < m_cdr.Models(); u ++)
        if  (m_cdr.Model(u).HasErrors())
            cuaSuspects.Add(u);

    if  (!cuaSuspects.GetSize()) {
        if (bReportSuccess)
            AfxMessageBox(IDS_NoErrorsAnywhere);
        return;
    }

    if  (AfxMessageBox(IDS_ConversionErrors, MB_YESNO) == IDNO)
        return;

    while   (cuaSuspects.GetSize()) {
        m_cdr.Model(cuaSuspects[0]).Edit();
        cuaSuspects.RemoveAt(0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CProjectRecord diagnostics

#ifdef _DEBUG
void CProjectRecord::AssertValid() const {
	CDocument::AssertValid();
}

void CProjectRecord::Dump(CDumpContext& dc) const {
	CDocument::Dump(dc);
}
#endif //_DEBUG




/////////////////////////////////////////////////////////////////////////////
// CProjectRecord commands

/////////////////////////////////////////////////////////////////////////////
//	VerUpdateFilePaths - Verify and update paths/filespecs in workspace file
//
//	Use the information read from the workspace file to see if the Win2K RC
//	file is where it is supposed to be.  If it is, assume that all is ok.  If
//	not, assume that either the workspace (.MDW) file or the files reference by
//	the workspace file have moved.
//
//	Tell the user and ask if he wants to locate the RC file for us.  If yes,
//	prompt for and verify the new RC file path.  Reprompt if it is wrong.  If
//	the user cancels, exit.
//
//	Once a path to the RC file is verified, use the file's grandparent
//	directory to update the paths used for all UFMs, GTTs, GPDs, and the rest
//	of the paths read from the MDW file and managed by this document.  The
//	grandparent directory is used because it is needed to correct some of
//	the filespecs saved in the workspace.  All of the Win2K files are
//  expected to be in directory(s) beneath the grandparent directory.  Lastly,
//	set the document's modified flag so that the updated paths can be saved
//	later.
//
//	void CProjectRecord::VerUpdateFilePaths()
//
//	Args:
//		None
//
//	Returns
//		Nothing
//
//	Notes
//		First, the Workspace View Add/Insert/Clone/Copy context menu commands
//		must make sure that the destination files for these commands always
//		end up in the appropriate workspace directories for this scheme to
//		work.
//
//		Second, if it is decided that more than one root directory is needed
//		for a workspace, this function will have to prompt for multiple
//		directories and then use the appropriate directory to update the paths
//		for UFMs, GTTs, GPDs, and the rest of the paths referenced by the
//		workspace file.
//
//		Third, if this tool is ever enhanced to handle conversions to anything
//		other than Win2K drivers, this routine will need to be enhanced to
//		handle those cases too.
//
	
bool CProjectRecord::VerUpdateFilePaths()
{
    CFileFind	cff ;			// Used to find the RC file
	bool		borig = true ;	// True iff the original RC file was found
	BOOL		bfound ;		// True iff an RC file was found
	CString		csprompt ;		// Used to prompt the user
	int			nresponse = 0 ;	// User's response to prompt

	// Make a copy of the file path and build a filespec for the Win2000 RC file

	CString	csrcpath(m_csW2000Path) ;
	CString	csrcfspec(csrcpath) ;
	if (csrcfspec.Right(1) != _T('\\'))
		csrcfspec += _T("\\") ;
	csrcfspec += m_csRCName ;

	// Keep checking for the existence of the RC file and prompting the user
	// until the file is found or the user doesn't want to continue any more.

	while (true) {
		// If the Win2000 RC file exists, we're done so exit.

		if (bfound = cff.FindFile(csrcfspec))
			break ;

		// Explain the situation to the user and ask if they want to tell us where
		// the file is.	 (Only do this the first time.)

		if (borig) {
			csprompt.Format(IDS_RCFindPrompt, DriverName(), csrcpath) ;
			nresponse = AfxMessageBox(csprompt, MB_YESNOCANCEL+MB_ICONQUESTION);
			if (nresponse != IDYES)
				break ;
		} ;

		// Prompt the user for a new RC file

		CFileDialog cfd(TRUE, _T(".RC"), m_csRCName,
						OFN_FILEMUSTEXIST | OFN_HIDEREADONLY,
						_T("RC File (*.rc)|*.rc||")) ;
		cfd.m_ofn.lpstrInitialDir = csrcpath ;
		if  (cfd.DoModal() != IDOK)
			break ;

		// Prepare to check the new filespec

		csrcfspec = cfd.GetPathName() ;
		csrcpath = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\'))) ;
		borig = false ;
	} ;

	// If the original RC file was found or the user did not provide a new
	// filespec or the user cancels, just return without changing anything.
	// Return false if the user cancelled.

	if (borig || !bfound)
		return (nresponse != IDCANCEL) ;

	// When the MDT performs a conversion, the resulting files are put into
	// a directory tree with a root directory like NT4 or Win2K by default.  The
	// directory layout and files from that root directory on down are expected
	// to be maintained.  The RC file is expected to be in that root directory,
	// too.  Therefore, the paths in this workspace up to BUT NOT INCLUDING that
	// root directory must be updated; ie, the path for the RC file's
	// grandparent directory.  So, get the new path for the grandparent
	// directory.

	CString csrcnewgrand(csrcpath) ;
	csrcnewgrand = csrcnewgrand.Left(csrcnewgrand.ReverseFind(_T('\\')) + 1) ;

	// As a safety measure, existing paths are only updated if they begin with
	// the RC file's OLD grandparent directory.

	CString csrcoldgrand(m_csW2000Path) ;
	csrcoldgrand = csrcoldgrand.Left(csrcoldgrand.ReverseFind(_T('\\')) + 1) ;
	int noldlen = csrcoldgrand.GetLength() ;

	// Variables used to process arrays of objects and their paths

	unsigned u ;
	unsigned unumobjs ;
	CString  cspath ;

	// Update UFM filespecs

    for (unumobjs = m_cdr.FontCount(), u = 0 ; u < unumobjs ; u++) {
        cspath = m_cdr.Font(u).GetPath() ;
		if (cspath.Find(csrcoldgrand) == 0)	{
			cspath = csrcnewgrand + cspath.Right(cspath.GetLength() - noldlen) ;
			m_cdr.Font(u).SetPath(cspath) ;
		} ;
	} ;

	// Update GTT filespecs

    for (unumobjs = m_cdr.MapCount(), u = 0 ; u < unumobjs ; u++) {
        cspath = m_cdr.GlyphTable(u).GetPath() ;
		if (cspath.Find(csrcoldgrand) == 0)	{
			cspath = csrcnewgrand + cspath.Right(cspath.GetLength() - noldlen) ;
			m_cdr.GlyphTable(u).SetPath(cspath) ;
		} ;
	} ;

	// Update GPD filespecs

    for (unumobjs = m_cdr.Models(), u = 0 ; u < unumobjs ; u++) {
        cspath = m_cdr.Model(u).GetPath() ;
		if (cspath.Find(csrcoldgrand) == 0)	{
			cspath = csrcnewgrand + cspath.Right(cspath.GetLength() - noldlen) ;
			m_cdr.Model(u).SetPath(cspath) ;
		} ;
	} ;

	// Now, update the paths that are in the workspace.

	if (m_csSourceRCFile.Find(csrcoldgrand) == 0)
		m_csSourceRCFile = csrcnewgrand + m_csSourceRCFile.Right(m_csSourceRCFile.GetLength() - noldlen) ;
	if (m_csW2000Path.Find(csrcoldgrand) == 0)
		m_csW2000Path = csrcnewgrand + m_csW2000Path.Right(m_csW2000Path.GetLength() - noldlen) ;
	if (m_csNT40Path.Find(csrcoldgrand) == 0)
		m_csNT40Path = csrcnewgrand + m_csNT40Path.Right(m_csNT40Path.GetLength() - noldlen) ;
	if (m_csNT3xPath.Find(csrcoldgrand) == 0)
		m_csNT3xPath = csrcnewgrand + m_csNT3xPath.Right(m_csNT3xPath.GetLength() - noldlen) ;
	if (m_csWin95Path.Find(csrcoldgrand) == 0)
		m_csWin95Path = csrcnewgrand + m_csWin95Path.Right(m_csWin95Path.GetLength() - noldlen) ;

	// Lastly, mark the workspace file as being dirty so that it can be saved
	// later.

	SetModifiedFlag() ;
    return TRUE;
}


/******************************************************************************

  CProjectRecord::SaveModified

  This overridable function is used to make sure that the "subdocuments"
  associated with this document that are NOT file based are saved before this
  document closes.  The normal saving mechanisms employed by the MFC document
  view architectured don't always work in these cases.  The work required to
  save each subdocument is subdocument dependent.  The current list of
  subdocuments that fall into this category are:
	
  o	String Table Editor - The editor just modifies the string table portion of
	the RC file that is associated with the documented managed by this
	instance of CProjectRecord.  If the editor exists, tell it to save the
	string table.  If this succeeds, the document's save flags will be updated
	when needed.  If this fails, return FALSE so that the calling function
	will know that this document should not be closed.

******************************************************************************/

BOOL CProjectRecord::SaveModified()
{
	// Save the string table if it was modified.
	//
	// Begin by getting a pointer to the string editor for this project.

	CMDIChildWnd* pcmcw = m_cdr.GetStringsNode()->GetEditor() ;

	// If there is a string editor, call it to save the string table.

	if (pcmcw != NULL) {
		CStringEditorDoc* pcsed = (CStringEditorDoc*) pcmcw->GetActiveDocument() ;

		// Return FALSE (do not close this document) if the string table needed
		// to be saved but it couldn't be saved because it is invalid.

		if (!pcsed->SaveStringTable()) {
			pcmcw->SetFocus() ;
			return FALSE ;
		} ;
	} ;
	
	return CDocument::SaveModified();
}


/////////////////////////////////////////////////////////////////////////////
// CGetDefCodePage dialog


CGetDefCodePage::CGetDefCodePage(CWnd* pParent /*=NULL*/)
	: CDialog(CGetDefCodePage::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetDefCodePage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CGetDefCodePage::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetDefCodePage)
	DDX_Control(pDX, IDC_CodePageList, m_clbCodePages);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGetDefCodePage, CDialog)
	//{{AFX_MSG_MAP(CGetDefCodePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetDefCodePage message handlers

BOOL CGetDefCodePage::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// Find out how many code pages are installed on the machine.

	CCodePageInformation ccpi ;
	unsigned unumcps = ccpi.InstalledCount() ;

	// Get the installed code page numbers and load them into the code page
	// list box.

	DWORD dwcp, dwdefcp ;
	dwdefcp = GetACP() ;
	TCHAR accp[32] ;
	int n2 ; ;
	for (unsigned u = 0 ; u < unumcps ; u++) {
		dwcp = ccpi.Installed(u) ;

		StringCchPrintf(accp, CCHOF(accp), _T("%5d"), dwcp) ;

		n2 = m_clbCodePages.AddString(accp) ;
		if (dwcp == dwdefcp)
			m_clbCodePages.SetCurSel(n2) ;
	} ;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CGetDefCodePage::OnOK()
{
	// Get the index of the currently selected list box item.

	int nsel ;
	if ((nsel = m_clbCodePages.GetCurSel()) == LB_ERR) {
		AfxMessageBox(IDS_MustSelCP, MB_ICONINFORMATION) ;
		return ;
	} ;

	// Get the selected list box string, turn it into a number, and save it.

	CString cs ;
	m_clbCodePages.GetText(nsel, cs) ;

	// Turn the string into a number and convert the number into the
	// corresponding predefined GTT code for Far East code pages when
	// applicable.

	short scp = (short) atoi(cs) ;
	m_dwDefaultCodePageNum = (DWORD) scp ;	// Save real CP number first
	switch (scp) {
		case 932:
			scp = -17 ;
			break ;
		case 936:
			scp = -16 ;
			break ;
		case 949:
			scp = -18 ;
			break ;
		case 950:
			scp = -10 ;
			break ;
	} ;
	DWORD dwcp = (DWORD) scp ;

	m_dwDefaultCodePage = dwcp ;

	// All went well so...

	CDialog::OnOK();
}

BOOL CProjectRecord::CreateFromNew(CStringArray &csaUFMFiles, CStringArray &csaGTTFiles, CString &csGpdPath, CString &csModelName, CString &csRC,CStringArray& csaRcid)
{
	
	
	// customize GPD keyword value
	CModelData cmd ;
	CString cspath, csmodel, csdll ; 
	cspath = csGpdPath.Mid(csGpdPath.ReverseFind('\\') + 1 ) ;

	cmd.SetKeywordValue(csGpdPath,_T("*GPDFileName"),cspath);
	cmd.SetKeywordValue(csGpdPath,_T("*ModelName"),csModelName) ;
	cmd.SetKeywordValue(csGpdPath,_T("*ResourceDLL"),csRC + _T(".dll") ) ;
	
	
	// Fill RC member data : m_csRCName, m_csW2000Path ;
	m_csW2000Path = csGpdPath.Left(csGpdPath.ReverseFind('\\') ) ;
	m_csRCName = csRC + _T(".rc") ; 
	GetRCFileTimeStamp(m_ctRCFileTimeStamp) ; // set the last time stamp
	SetRCModifiedFlag(TRUE ) ;

	// Set project version 
	m_mvMDWVersion.uvernum = MDW_VER_FILES_IN_W2K_TREE ;
	m_dwDefaultCodePage = 
	m_dwDefaultCodePageNum = 1252 ;  
	 
	// Set project name; top name in the tree
	CString csPrjname;
	csPrjname = m_csW2000Path.Mid(m_csW2000Path.ReverseFind('\\') + 1 ) ;
	Rename(csPrjname ) ;
	
	
	// copy the resource data to project member data 
	m_cdr.CopyResources(csaUFMFiles,csaGTTFiles, csGpdPath, csaRcid) ;
	

	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projnode.cpp ===
/******************************************************************************

  Source File:  Project Node.CPP

  This implements the CProjectNode class which alows individual nodes in the
  tree view to control their behavior without the control itself having to know
  what all that behavior is.

  The original header file (from the prototype) said this class didn't need an
  implementation file, but this no longer makes sense, so it's bite the bullet
  time here at Pretty Penny Enterprises...

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Resreved.

  A Pretty Penny Enterprises Production

  Change History:
  02-20-1997    Bob_Kjelgaard#Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include	<gpdparse.h>
#include    "Resource.H"
#include    "ProjNode.H"
#include	"gtt.h"
#include	"fontinfo.h"
#include	"rcfile.h"
#include	"projrec.h"
#include	"comctrls.h"
#include	"StrEdit.h"


IMPLEMENT_SERIAL(CBasicNode, CObject, 0)

CBasicNode::CBasicNode() { 
    m_pcmcwEdit = NULL; 
    m_pcdOwner = NULL;
    m_pctcOwner = NULL;
    m_hti = NULL;
    m_pcbnWorkspace = NULL;
	m_bUniqueNameChange = false ;
}

CBasicNode::~CBasicNode() {
    if (m_pcmcwEdit)
		if (IsWindow(m_pcmcwEdit->m_hWnd))
			m_pcmcwEdit -> DestroyWindow();
}


// Changed() - If the node contains a document pointer, use it to indicate
// that the document does or does not need to be saved.  If the RC file
// needs to be rewritten, call the routine in the document class to save
// this info.

void CBasicNode::Changed(BOOL bModified, BOOL bWriteRC) 
{ 
    if (m_pcdOwner) {
		m_pcdOwner->SetModifiedFlag(bModified) ; 
		if (bWriteRC) 
			((CProjectRecord *) m_pcdOwner)->SetRCModifiedFlag(TRUE) ;
	} ;
}


//  Name ourselves and children- default to just our name, no children

void    CBasicNode::Fill(CTreeCtrl *pctcWhere, HTREEITEM htiParent) {
    m_pctcOwner = pctcWhere;
    m_hti = pctcWhere -> InsertItem(m_csName, htiParent);
    pctcWhere -> SetItemData(m_hti, PtrToUlong(this));
}

//  Display a context menu using the ID array, if it has any members

void    CBasicNode::ContextMenu(CWnd *pcw, CPoint cp) {

    if  (!m_cwaMenuID.GetSize())
        return;

    CMenu   cmThis;

    if  (!cmThis.CreatePopupMenu())
        return;

    for (int i = 0; i < m_cwaMenuID.GetSize(); i++) {

        if  (m_cwaMenuID[i]) {
            CString csWork;

            csWork.LoadString(m_cwaMenuID[i]);
            cmThis.AppendMenu(MF_STRING | MF_ENABLED, m_cwaMenuID[i], csWork);
        }
        else
            cmThis.AppendMenu(MF_SEPARATOR);
    }

    cmThis.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, cp.x, cp.y, pcw);
}



//  This override is called if our label is edited, or we are otherwise
//  renamed...
BOOL    CBasicNode::Rename(LPCTSTR lpstrNewName) {
    if  (!lpstrNewName)
        return  FALSE;

    if  (lpstrNewName == m_csName)
        return  TRUE;

    //  We'll return TRUE, unless the rename produces an exception
    try {
        m_csName = lpstrNewName;
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    WorkspaceChange();
    return  TRUE;
}

void    CBasicNode::Edit() {
    if  (!m_pcmcwEdit)
        m_pcmcwEdit = CreateEditor();
    else {
        if  (IsWindow(m_pcmcwEdit -> m_hWnd))
            m_pcmcwEdit -> ActivateFrame();
		else
			m_pcmcwEdit = CreateEditor();
	} ;
}


/******************************************************************************\

  CBasicNode::GetEditor

  Get the node's editor frame pointer and check to see if it is valid.  Return
  it if it is valid.  If it isn't valid, clear the pointer and return NULL.

******************************************************************************/

CMDIChildWnd* CBasicNode::GetEditor()
{ 
    if (m_pcmcwEdit != NULL && !IsWindow(m_pcmcwEdit->m_hWnd))
		m_pcmcwEdit = NULL ;

	return m_pcmcwEdit ;
}


/******************************************************************************\

  CBasicNode::UniqueName

  Add a character or replace a character in the node's name to try to make it
  unique.  The new character will be in one of the following ranges a-z or 
  0-9.

******************************************************************************/

void CBasicNode::UniqueName(bool bsizematters, bool bfile, LPCTSTR lpstrpath)
{
	CString	csnew(m_csName) ;
	TCHAR	tch ;				// Unique character
	int		nposlen ;			// Name's change position/length

	// Determine the 0-based length of the name

	nposlen = csnew.GetLength() - 1 ;

	// If the name has been changed before, use the last "unique" character to
	// determine the new unique character.  Then replace the old unique 
	// character with the new unique character.

	if (m_bUniqueNameChange) {
		tch = csnew.GetAt(nposlen) + 1 ;
		if (tch == _T('{'))
			tch = _T('0') ;
		else if (tch == _T(':'))
			tch = _T('a') ;
		csnew.SetAt(nposlen, tch) ;

	// If the name has not been changed before, add a unique character to the
	// end of the name if this won't make the name longer than 8 characters
	// or we don't care how long the name is.  Otherwise, replace the last
	// character with the new unique character.

	} else {
		if (nposlen < 7 || !bsizematters)
			csnew += _T("a") ;
		else
			csnew.SetAt(nposlen, _T('a')) ;
	} ;

	// Rename the node/file by calling the appropriate Rename() routine.  If
	// CFileNode::Rename() m_csName must be zapped to force it to take the
	// correct code path.  In addition, the file's path must be prepended to
	// its name.

	if (bfile) {
		m_csName.Empty() ;
		csnew = lpstrpath + csnew ;
		Rename(csnew) ;
	} else
		CBasicNode::Rename(csnew) ;
	
	// Indicate that the name has been changed.

	m_bUniqueNameChange = true ;
}


/******************************************************************************\

  CBasicNode::Serialize

  Pretty simple- the names the only field we will be keeping...

******************************************************************************/

void    CBasicNode::Serialize(CArchive& car) {
    CObject::Serialize(car);
    if  (car.IsLoading())
        car >> m_csName;
    else
        car << m_csName;
}

/******************************************************************************

  CFixedNode implementation

******************************************************************************/

IMPLEMENT_DYNAMIC(CFixedNode, CBasicNode)

CFixedNode::CFixedNode(unsigned uidName, CSafeObArray& csoa, FIXEDNODETYPE fnt, 
                       CMultiDocTemplate *pcmdt, CRuntimeClass *pcrc) :
    m_csoaDescendants(csoa) {
    m_uidName = uidName;
	m_fntType = fnt;
    m_pcmdt = pcmdt;
    m_pcrc = pcrc;
}


/******************************************************************************

  CFixedNode::Zap

  This method is called when an underlying object is to be destroyed.  It finds
  a matching pointer in the array, and then deletes that entry.

******************************************************************************/

void CFixedNode::Zap(CProjectNode *pcpn, BOOL bdelfile)
{
	// Try to find the node we want to delete in the array of descendants for
	// this node.  Just return if it can't be found.

    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
        if  (pcpn == m_csoaDescendants[u]) 
			break ;
	} ;
	if (u >= m_csoaDescendants.GetSize())
		return ;

	// If the user wants to remove the file too, do it.

    if  (bdelfile)
        DeleteFile(pcpn->FileName()) ;

	// Save a copy of the node's tree handle
		
    HTREEITEM htiGone = pcpn->Handle() ;

	// Remove the project node from the array of descendants and delete it from
	// the tree.

    m_csoaDescendants.RemoveAt(u);
    m_pctcOwner -> DeleteItem(htiGone);
    
	// Update this (fixed) node's entry in the tree so that it will accurately
	// reflect the new number of descendants.

	CString csWork;
    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);

	// Mark the workspace and RC file as needing to be saved.

    WorkspaceChange(TRUE, TRUE);
}


/******************************************************************************

  CFixedNode::Import

  This member function will import one or more files of the given type if there
  is a document template and dynamic constructor available.  It uses the 
  template to customize the File Open dialog, and the constructor to build the
  elements.
  
  NOTE:  There is a fair amount of common code between this routine and
  Copy().  If a bug/change is made in this routine, check to see if the 
  same change needs to be made to Copy().

******************************************************************************/

void    CFixedNode::Import() {
    if  (!m_pcmdt || !m_pcrc || !m_pcrc -> m_pfnCreateObject)
        return;

    CString csExtension, csFilter;

    m_pcmdt -> GetDocString(csExtension, CDocTemplate::filterExt); 
    m_pcmdt -> GetDocString(csFilter, CDocTemplate::filterName);
    csFilter += _T("|*") + csExtension + _T("||");

    CFileDialog cfd(TRUE, csExtension, NULL, 
        OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT, csFilter, 
        m_pctcOwner);
	// raid 104822
    cfd.m_ofn.lpstrFile = new char[4096];
	memset(cfd.m_ofn.lpstrFile,0,4096);
	cfd.m_ofn.nMaxFile = 4096;
    if  (cfd.DoModal() != IDOK) {
        delete cfd.m_ofn.lpstrFile ;
		return;
	}

	// Get the first, new RC ID to use if this is a resource node.

	int nnewrcid = GetNextRCID() ;

	// Build a path to the directory for the added files.  The path is node
	// type specific.

	CString csnodepath = ((CDriverResources *) m_pcbnWorkspace)->GetW2000Path() ;
	if (csnodepath.Right(1) != _T("\\"))
		csnodepath += _T("\\") ;
	CString cstmp ;
	if (m_fntType == FNT_UFMS)
		cstmp.LoadString(IDS_FontDir) ;
	else if (m_fntType == FNT_GTTS)
		cstmp.LoadString(IDS_GTTDir) ;
	csnodepath += cstmp ;

    //  Import all of the named files...

	CString cssrc ;				// Source fspec
    for (POSITION pos = cfd.GetStartPosition(); pos; ) {

        //  Create the underlying object using dynamic creation.  Only a 
        //  CProjectNode has the required function, here.

        CProjectNode*   pcpn = (CProjectNode *) m_pcrc -> CreateObject();
        if  (!pcpn || !pcpn -> IsKindOf(RUNTIME_CLASS(CProjectNode))) {
            TRACE("Imported object not derived from CProjectNode");
            delete  pcpn;
            continue;
        }

		// If the file is already in the right directory, make sure that it is
		// not already a part of the workspace.

		cssrc = cfd.GetNextPathName(pos) ;
		if (csnodepath.CompareNoCase(cssrc.Left(csnodepath.GetLength())) == 0) {
			if (IsFileInWorkspace(cssrc)) {
				// Build and display error message.  Then skip this file.
				CString csmsg ;
				csmsg.Format(IDS_AddDupError, cssrc) ;
				AfxMessageBox(csmsg) ;
			    delete  pcpn ;
		        continue ;
	        } ;
			cstmp = cssrc ;

		// If the file is not in the right directory, try to copy it there.

		} else {
			cstmp = cssrc.Mid(cssrc.ReverseFind(_T('\\')) + 1) ;
			cstmp =	csnodepath + cstmp ;
			if (!CopyFile(cssrc, cstmp, TRUE)) {
				// Build and display error message.  Then skip this file.
				CString csmsg ;
				csmsg.Format(IDS_AddCopyFailed, cssrc,
							 csnodepath.Left(csnodepath.GetLength() - 1)) ;
				csmsg += cstmp ;
				AfxMessageBox(csmsg) ;
			    delete  pcpn ;
		        continue ;
			} ;
		} ;

		// Initialize the new node
		// RAID: 17897 : 
		// Add CModelData::GetKeywordValue
		// CBN::Rename(ModelName) after SetFileName() by pcpn->Rename(ModelName)
       CModelData cmd;

		pcpn -> SetFileName(cstmp); //goes to CBN::Rename(FileName)
        if (m_fntType == FNT_GPDS)   //add 1/3
			pcpn ->Rename(cmd.GetKeywordValue(cstmp,_T("ModelName")));		 //add 2/3
		else						 //add 3/3
			pcpn -> Rename(pcpn -> FileTitle());
        
		pcpn -> NoteOwner(*m_pcdOwner);
        pcpn -> SetWorkspace(m_pcbnWorkspace);
		m_csoaDescendants.Add(pcpn);
        WorkspaceChange(TRUE, TRUE);
        pcpn -> EditorInfo(m_pcmdt);

		
		// load actual UFM, GTT data.	// raid 128653
		if (m_fntType == FNT_UFMS ) {
			
			CFontInfo *pfi = (CFontInfo* )pcpn;
			
			CDriverResources* pcdr = (CDriverResources*) pfi->GetWorkspace() ;

			pcdr -> LinkAndLoadFont(*pfi,TRUE);
				
		} 

		else if (m_fntType == FNT_GTTS) {

			CGlyphMap *pcgm = (CGlyphMap* ) pcpn;

			pcgm ->Load();
		
		} ;
			
		// Add the new node to the workspace view

        pcpn -> Fill(m_pctcOwner, m_hti, nnewrcid++, m_fntType);
    } ;

	delete cfd.m_ofn.lpstrFile;
    //  Now, update our own appearance (get the count right)

    CString csWork;
    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);
}


/******************************************************************************

  CFixedNode::Copy

  This member function will make a copy of one the this node's children.  The
  UI needed to determine the source child and the destination file name was
  done in CProjectView and the information is passed into this routine.
  
  NOTE:  There is a fair amount of common code between this routine and
  Import().  If a bug/change is made in this routine, check to see if the 
  same change needs to be made to Import().

******************************************************************************/

void CFixedNode::Copy(CProjectNode *pcpnsrc, CString csorgdest)
{
	// Can't do anything if the following pointers are set.

    if  (!m_pcmdt || !m_pcrc || !m_pcrc -> m_pfnCreateObject)
        return;

    // Build the destination filespec by isolating the name in the destination
	// string and adding on this source's path and extension.  

	CString csdest(csorgdest) ;
	int npos ;
	if ((npos = csdest.ReverseFind(_T('\\'))) != -1)
		csdest = csdest.Mid(npos + 1) ;
	if ((npos = csdest.ReverseFind(_T('.'))) != -1)
		csdest = csdest.Left(npos) ;
	if (csdest.GetLength() <= 0) {
		csdest.Format(IDS_CopyNameError, csorgdest) ;
		AfxMessageBox(csdest) ;
		return ;
	} ;
	csdest = csdest + pcpnsrc->FileExt() ;
	CString csdesttitleext(csdest) ;
	csdest = pcpnsrc->FilePath() + csdest ;

    // Copy the source file to the destination

	if (!CopyFile(pcpnsrc->FileName(), csdest, TRUE)) {
		// Build and display error message.  Then return.
		CString csmsg, cspath(pcpnsrc->FilePath()) ;
		cspath.Left(cspath.GetLength() - 1) ;
		csmsg.Format(IDS_CopyCopyFailed, pcpnsrc->FileTitleExt(),
					 csdesttitleext, cspath) ;
		AfxMessageBox(csmsg) ;
		return ;
	} ;

    //  Create the underlying object using dynamic creation.  Only a 
    //  CProjectNode has the required function, here.

	int nnewrcid = GetNextRCID() ;
    CProjectNode*   pcpn = (CProjectNode *) m_pcrc -> CreateObject();
    if  (!pcpn || !pcpn -> IsKindOf(RUNTIME_CLASS(CProjectNode))) {
        TRACE("Imported object not derived from CProjectNode");
        delete  pcpn;
        return;
    } ;

	// Initialize the new node

    pcpn->SetFileName(csdest);
    pcpn->Rename(pcpn->FileTitle());
    pcpn->NoteOwner(*m_pcdOwner);
    pcpn->SetWorkspace(m_pcbnWorkspace);
	m_csoaDescendants.Add(pcpn);
    WorkspaceChange(TRUE, TRUE);
    pcpn->EditorInfo(m_pcmdt);

	// Add the new node to the workspace view

    pcpn->Fill(m_pctcOwner, m_hti, nnewrcid, m_fntType);

    //  Now, update our own appearance (get the count right)

    CString csWork;
    csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
    m_csName.LoadString(m_uidName);
    m_csName += csWork;
    m_pctcOwner -> SetItemText(m_hti, m_csName);

	// Last but not least...  If a new GPD was just added, tell the user to
	// change the name in the GPD to make sure it is unique.

	if (m_fntType == FNT_GPDS) {
		csdest.Format(IDS_GPDReminder, pcpn->Name()) ;
		AfxMessageBox(csdest) ;
	} ;
}


/******************************************************************************

  CFixedNode::GetNextRCID

  If this is a resource (UFM or GTT) node, all of its descendants have RC IDs.
  Find the largest one and return one greater than that for use in a new
  descendant.  If this is not a resource node, just return -1.

******************************************************************************/

int CFixedNode::GetNextRCID()
{
	// Return -1 if this is not a resource node that requires RC IDs

	if (m_fntType != FNT_UFMS && m_fntType != FNT_GTTS)
		return -1 ;

	// Find the largest used RC ID.  Use the descendant's index if it does not
	// have an RC ID.

	int nlargestusedid = 0 ;
	int nrcid ;
    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
		nrcid = ((CProjectNode *) m_csoaDescendants[u])->nGetRCID() ;
		if (nrcid == -1)
			nrcid = (int) u + 1 ;
		if (nrcid > nlargestusedid)
			nlargestusedid = nrcid ;
	} ;

	// Return the next RC ID to use

	return (nlargestusedid + 1) ;
}


/******************************************************************************

  CFixedNode::IsFileInWorkspace

  Check the node's descendants to see if one of them matches the given filespec.
  Return true if a match is found.  Otherwise, return false.

******************************************************************************/

bool CFixedNode::IsFileInWorkspace(LPCTSTR strfspec)
{
	CString		csdescfspec ;	// Filespec for current descendant

    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
		csdescfspec = ((CProjectNode *) m_csoaDescendants[u])->FileName() ;
		if (csdescfspec.CompareNoCase(strfspec) == 0)
			return true ;
	} ;

	return false ;
}


/******************************************************************************

  CFixedNode::IsRCIDUnique

  Check the node's descendants to see if one of them has the same RC ID as the
  one passed in.  Return true if a no match is found.  Otherwise, return false.

******************************************************************************/

bool CFixedNode::IsRCIDUnique(int nid) 
{
    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++) {
		if (((CProjectNode *) m_csoaDescendants[u])->nGetRCID() == nid)
			return false ;
	}

	return true ;
}


/******************************************************************************

  CFixedNode::Fill

  This is a generic fill- the node names itself, then fills its node using the
  array of nodes given to it at init time.

******************************************************************************/

void    CFixedNode::Fill(CTreeCtrl *pctc, HTREEITEM hti) {
    CString csWork;

	// Add the number of descendants to the node's name IFF this is the UFMs,
	// GTTs, or GPDs nodes.  Then add the node to the tree.

    m_csName.LoadString(m_uidName);
    if (m_fntType == FNT_UFMS || m_fntType == FNT_GTTS || m_fntType == FNT_GPDS) {
		csWork.Format(_TEXT(" (%d)"), m_csoaDescendants.GetSize());
	    m_csName += csWork;
	} ;
    CBasicNode::Fill(pctc, hti);

	// Add this node's descendants to the tree.

    for (unsigned u = 0; u < m_csoaDescendants.GetSize(); u++)
		((CProjectNode *) m_csoaDescendants[u]) -> Fill(pctc, m_hti, u + 1, m_fntType) ;
}


/******************************************************************************

  CStringsNode implementation

******************************************************************************/

IMPLEMENT_DYNAMIC(CStringsNode, CBasicNode)

CStringsNode::CStringsNode(unsigned uidName, CSafeObArray& csoa, 
						   FIXEDNODETYPE fnt, CMultiDocTemplate *pcmdt, 
						   CRuntimeClass *pcrc) : m_csoaDescendants(csoa) {
    m_uidName = uidName;
	m_fntType = fnt;
    m_pcmdt = pcmdt;
    m_pcrc = pcrc;
	m_nFirstSelRCID = -1 ;	
}


/******************************************************************************

  CStringsNode::Fill

  This is a generic fill- the node names itself, then fills its node using the
  array of nodes given to it at init time.

******************************************************************************/

void    CStringsNode::Fill(CTreeCtrl *pctc, HTREEITEM hti) {
    CString csWork;

	// Add this node to the tree

    m_csName.LoadString(m_uidName);
    CBasicNode::Fill(pctc, hti);
}


/*****************************************************************************

  CStringsNode::CreateEditor

  This member function launches an editing view for the strings.

******************************************************************************/

CMDIChildWnd* CStringsNode::CreateEditor()
{
	// Allocate and initialize the document.

	CProjectRecord* cpr = (CProjectRecord*) m_pcdOwner ;
    CStringEditorDoc* pcsed = new CStringEditorDoc(this, cpr, cpr->GetStrTable()) ;

	// Set the editor's title

	CString cstitle ;
	cstitle.Format(IDS_StringEditorTitle, cpr->DriverName()) ;
    pcsed->SetTitle(cstitle) ;	

	// Create the window.

    CMDIChildWnd* pcmcwnew ;
	pcmcwnew = (CMDIChildWnd *) m_pcmdt->CreateNewFrame(pcsed, NULL) ;

	// If the window was created, finish the initialization and return the 
	// frame pointer.  Otherwise, clean up and return NULL.

    if  (pcmcwnew) {
        m_pcmdt->InitialUpdateFrame(pcmcwnew, pcsed, TRUE) ;
        m_pcmdt->AddDocument(pcsed) ;
		return pcmcwnew ;
	} else {
		delete pcsed ;
		return NULL ;
	} ;
}


/******************************************************************************

  CFileNode implementation

******************************************************************************/

IMPLEMENT_SERIAL(CFileNode, CBasicNode, 0);

CFileNode::CFileNode() {
    m_cwaMenuID.Add(ID_RenameItem);
    m_bEditPath = FALSE;
    m_bCheckForValidity = TRUE;
}

/******************************************************************************

  CFileNode::Rename

  If there is no name currently, then see if the named file can be created.
  The other case, means the file should already be on the disk, so it is a bit 
  trickier.

  First, check to see if the name violates the current naming conventions.  If
  so, reject it.  Then attempt to move the file.  IF the name is OK and the
  file is moved, set the new name in the item label.  Always returns FALSE.

******************************************************************************/

BOOL    CFileNode::Rename(LPCTSTR lpstrNew) {
    CString csNew = lpstrNew;

    if  (!lpstrNew) {   //  This only happens if the label edit was canceled.
        csNew.LoadString(IDS_FileName);
        if  (m_pctcOwner)
            m_pctcOwner -> SetItemText(m_hti, csNew + ViewName());
        WorkspaceChange(TRUE, TRUE);	// ** Parameters might be wrong
        return  FALSE;
    }

	// Add an extension to the file name if it is needed.

    if  (m_csExtension.CompareNoCase(csNew.Right(m_csExtension.GetLength())))
        csNew += m_csExtension;

	// This path is taken when a driver is being converted.  
	
    if  (m_csName.IsEmpty()) {
        CFile   cfTemp;

        //  This check needs to be optional since in some instances, we know
        //  the name is valid because the file is open, and we're just trying
        //  to collect the name.

        if  (!cfTemp.Open(csNew, CFile::modeCreate | CFile::modeNoTruncate |
            CFile::modeWrite | CFile::shareDenyNone) && m_bCheckForValidity) {
            CString csWork, csDisplay;

            csWork.LoadString(IDS_InvalidFilename);
            csDisplay.Format(csWork, (LPCTSTR) csNew);
            AfxMessageBox(csDisplay);
            return  FALSE;
        }

        try {
            m_csPath = cfTemp.GetFilePath();
            m_csPath = m_csPath.Left(1 + m_csPath.ReverseFind(_T('\\')));
        }
        catch   (CException *pce) {
            pce -> ReportError();
            pce -> Delete();
            return  FALSE;
        }

        //  If the file type isn't registered, then GetFileTitle returns the
        //  extension, so strip it!

        csNew = cfTemp.GetFileTitle();
        if  (!m_csExtension.CompareNoCase(csNew.Right(
             m_csExtension.GetLength())))
            csNew = csNew.Left(csNew.GetLength() - m_csExtension.GetLength());

        return  CBasicNode::Rename(csNew);  //  OK from this path
    }

    //  Strip any path if it cannot be changed, and substitute the real one

    if  (!m_bEditPath)
        csNew = m_csPath + csNew.Mid(1 + csNew.ReverseFind(_T('\\')));

    try {
        LPSTR   lpstr;

        CFile::Rename(FullName(), csNew);

        GetFullPathName(csNew, MAX_PATH, csNew.GetBuffer(MAX_PATH), &lpstr);
        csNew.ReleaseBuffer();
        m_csPath = csNew.Left(1 + csNew.ReverseFind(_T('\\')));
        csNew = csNew.Mid(m_csPath.GetLength());
        m_csName = csNew.Left(csNew.GetLength() - 
            m_csExtension.GetLength());
        csNew.LoadString(IDS_FileName);
        if  (m_pctcOwner)
            m_pctcOwner -> SetItemText(m_hti, csNew + m_csName);
        WorkspaceChange(TRUE, TRUE);
        return  FALSE;  //  Force the change (above) to be kept.
    }
    catch   (CFileException *pcfe) {    //  Don't get a file name with statics
        if  (pcfe -> m_cause == ERROR_FILE_NOT_FOUND)
            csNew = FullName();
        pcfe -> m_strFileName = csNew;
        pcfe -> ReportError();
        pcfe -> Delete();
        return  FALSE;
    }
    catch   (CException *pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }
}


/******************************************************************************

  CFileNode::SetPathAndName

  Set the node's path and file name in a way that works when someone has
  directly editted the UFM table in the RC file.  This is the only time that
  this routine should be called.  It doesn't perform any checks.  We rely on the
  person who editted the RC file to have done it correctly.

******************************************************************************/

void CFileNode::SetPathAndName(LPCTSTR lpstrpath, LPCTSTR lpstrname)
{
	m_csPath = lpstrpath ;
	m_csName = lpstrname ;
}


/******************************************************************************

  CFileNode::CanEdit

  This will return TRUE, but it will first have to remove the File Name: stuff
  from the label, so we can get a cleaner edit.

******************************************************************************/

BOOL    CFileNode::CanEdit() const {

    CEdit*   pce = m_pctcOwner -> GetEditControl();
    if  (pce)
        pce -> SetWindowText(m_bEditPath ? m_csPath + m_csName : m_csName);
    return  !!pce;
}

/******************************************************************************

  CFileNode::Fill

  We play a bit of a game here, changing our name temporarily to use the base 
  class implementation.

******************************************************************************/

void    CFileNode::Fill(CTreeCtrl* pctc, HTREEITEM htiParent) {
    CString csTemp = Name();

    m_csName.LoadString(IDS_FileName);
    m_csName += csTemp;
    CBasicNode::Fill(pctc, htiParent);
    m_csName = csTemp;
}


/******************************************************************************

  CFileNode::Serialize

  Since the name is covered by the base class, we only need to serialize the 
  boolean controlling long/short file names.  The file paths are only handled
  in down level versions of the MDW. 

******************************************************************************/

void    CFileNode::Serialize(CArchive& car) 
{
    CBasicNode::Serialize(car) ;

	// The file path is only kept in the MDW file when the MDW version is less
	// than MDW_VER_NO_FILE_PATHS.  Process it in this case.

	unsigned uver = ((CProjectRecord*) car.m_pDocument)->GetMDWVersion() ;
	if (uver >= MDW_VER_YES_FILE_PATHS) {  // raid 123448
		if  (car.IsLoading())
			car >> m_csPath ;
		else
			car << m_csPath ;
	} ;
}


/******************************************************************************

  CProjectNode implementation

******************************************************************************/

IMPLEMENT_SERIAL(CProjectNode, CBasicNode, 1)

CProjectNode::CProjectNode() 
{
    m_pcmdt = NULL ;

	m_bRefFlag = false ;		// Clear the referenced flag
}

void    CProjectNode::Fill(CTreeCtrl *pctc, HTREEITEM hti, unsigned urcid,
						   FIXEDNODETYPE fnt)
{
	// Add this node to the tree

    CBasicNode::Fill(pctc, hti);

	// Add this node's file node to the tree

    m_cfn.SetWorkspace(m_pcbnWorkspace);
    m_cfn.Fill(pctc, m_hti);
	
	// Add this node's RC ID node to the tree IFF it needs to use it

	if (fnt == FNT_UFMS || fnt == FNT_GTTS) {
		m_crinRCID.SetWorkspace(m_pcbnWorkspace) ;
		m_crinRCID.Fill(pctc, m_hti, urcid, fnt) ; 
	} ;
}


void CProjectNode::Serialize(CArchive& car) 
{
    CBasicNode::Serialize(car);
    m_cfn.Serialize(car);
    m_crinRCID.Serialize(car);
}


void CProjectNode::ChangeID(CRCIDNode* prcidn, int nnewid, CString csrestype)
{
    //  Walk back up the hierarchy to find this project node's owning Fixed node.

    CFixedNode&  cfn = * (CFixedNode *) m_pctcOwner->GetItemData(
        m_pctcOwner->GetParentItem(m_hti)) ;
    ASSERT(cfn.IsKindOf(RUNTIME_CLASS(CFixedNode))) ;

	// Make sure that the new ID is unique for this resource type

	if (!cfn.IsRCIDUnique(nnewid)) {
		CString csmsg ;
		csmsg.Format(IDS_IDNotUnique, nnewid, csrestype) ;
		AfxMessageBox(csmsg) ;
		return ;
	} ;

	// Change this node's ID, update the display, and mark the workspace and
	// RC file as needing to be saved.

	nSetRCID(nnewid) ;
	m_crinRCID.BuildDisplayName() ;
	m_pctcOwner->SetItemText(m_crinRCID.Handle(), m_crinRCID.Name()) ; 
    WorkspaceChange(TRUE, TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
//	CRCIDNode Implementation
//
//	Note: This class must be enhanced to support extra functionality.
//
    
IMPLEMENT_SERIAL(CRCIDNode, CBasicNode, 0) ;

CRCIDNode::CRCIDNode() 
{
	// Initialze as unset or unknown.

	m_nRCID = -9999 ;				
	m_fntType = FNT_UNKNOWN ;

	// Build the context sensitive menu for this node type

    m_cwaMenuID.Add(ID_ChangeID);
}


/******************************************************************************

  CRCIDNode::Fill

  Add the RC ID node for the current resource to the workspace view.

******************************************************************************/

void CRCIDNode::Fill(CTreeCtrl *pctc, HTREEITEM hti, int nid, FIXEDNODETYPE fnt) 
{
	// Set the RC ID and the node type.  The info passed in should only be used
	// if these member variables are "unset".  (This class has other functions
	// that can be used to change these variables once they've been set.)
	
	if (m_nRCID == -9999)	// raid 167257
		m_nRCID = nid ;
	if (m_fntType == FNT_UNKNOWN)
		m_fntType = fnt ;

	// Build the string to display for this node based on the RC ID & node type

	BuildDisplayName() ;

	// Add the node to the view

    CBasicNode::Fill(pctc, hti);
}


void CRCIDNode::BuildDisplayName()
{
	CString csid ;				// Holds ID string
	
	// Build the string to display for this node based on the RC ID & node type

	if (m_nRCID != -9999)
		csid.Format(_T("%d"), m_nRCID) ;
	else
		csid.LoadString(IDS_Unknown) ;
	switch (m_fntType) {
		case FNT_UFMS:
			m_csName.Format(IDS_RCUFM, csid) ;
			break ;
		case FNT_GTTS:
			m_csName.Format(IDS_RCGTT, csid) ;
			break ;
		default :
			m_csName.Format(IDS_RCUNK, csid) ;
			break ;
	} ;
}


void    CRCIDNode::Serialize(CArchive& car)
{
	int		nfnt = (int) m_fntType ;	// CArchive doesn't handle enumerations

    CBasicNode::Serialize(car);
    if  (car.IsLoading()) 
		car >> m_nRCID >> nfnt ;
    else
		car << m_nRCID << nfnt ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projnode.h ===
/******************************************************************************

  Header File:  Project Node.H

  This describes the Project Node.  This keeps the Project Control Window code
  simple, by having a project node which can create new intances of itself, 
  import itself from another source, edit itself, etc.  Most Menu and tree view
  notification messages wind up being handled by being passed to the currently
  selected node on the tree, which will be an instance of a class derived from
  this one.

  Copyright (c) 1996 by Microsoft Corporation

  A Pretty Penny Enterprises Production

  Change History:
  12-16-96  KjelgaardR@acm.org  Created it

******************************************************************************/

#if !defined(PROJECT_NODES)

#define PROJECT_NODES

#if defined(LONG_NAMES)
#include    "Utility Classes.H"
#else
#include    "Utility.H"
#endif

//  CBasicNode - base class for stuff we can manipulate

class CBasicNode : public CObject {
    DECLARE_SERIAL(CBasicNode)
    CBasicNode*     m_pcbnWorkspace;//  Basic Node for the workspace

protected:
    CString         m_csName;       //  These should always have a name...
    HTREEITEM       m_hti;          //  Handle in the owning tree view
    CTreeCtrl       *m_pctcOwner;   //  The window that owns us
    CMDIChildWnd    *m_pcmcwEdit;   //  The window we're being edited in.
    CDocument       *m_pcdOwner;    //  Document we are part of
    CWordArray      m_cwaMenuID;    //  Menu auto-fill
	bool			m_bUniqueNameChange ;	// True iff name change to make it
											// uniqe.  (See UniqueName().)

public:
    CBasicNode();
    ~CBasicNode();

    CString         Name() const { return m_csName; }

    HTREEITEM   Handle() const { return m_hti; }

    void		NoteOwner(CDocument& cdOwner) { m_pcdOwner = &cdOwner; }
    CDocument*	GetOwner() { return m_pcdOwner ; }

    void    SetWorkspace(CBasicNode* pcbnWS) { m_pcbnWorkspace = pcbnWS; }
    CBasicNode* GetWorkspace() { return m_pcbnWorkspace ; }

	void    Changed(BOOL bModified = TRUE, BOOL bWriteRC = FALSE) ;

	void	UniqueName(bool bsizematters, bool bfile, LPCTSTR lpstrpath = _T("")) ;

	//  Name ourselves and children- default to just our name, no children
    virtual void    Fill(CTreeCtrl *pctcWhere, 
                         HTREEITEM htiParent = TVI_ROOT);
    
    //  Overridable functions to allow polymorphic tree node handling
    virtual void            ContextMenu(CWnd *pcw, CPoint cp);
    virtual CMDIChildWnd    *CreateEditor() { return NULL; }
    virtual BOOL            CanEdit() const { return  TRUE; }
    virtual void            Delete() { }  //  Default is don't honor it!
    virtual void            Import() { }    //  Never at this level!
    //  This override is called if our label is edited, or we are otherwise
    //  renamed...
    virtual BOOL            Rename(LPCTSTR lpstrNewName);

    void			Edit() ;
    void			OnEditorDestroyed() { m_pcmcwEdit = NULL ; }
	CMDIChildWnd*	GetEditor() ;

    virtual void    Serialize(CArchive& car);
    
    void    WorkspaceChange(BOOL bModified = TRUE, BOOL bWriteRC = FALSE) { 
        if  (m_pcbnWorkspace)
            m_pcbnWorkspace -> Changed(bModified, bWriteRC);
    }
};


// Sometimes, it is useful to know something about the type of data managed by
// a fixed node or a strings node.  The following enumeration one way to do 
// this.

typedef enum {
	FNT_RESOURCES = 0,
	FNT_UFMS,
	FNT_GTTS,
	FNT_GPDS,
	FNT_STRINGS,
	FNT_OTHER,
	FNT_UNKNOWN
} FIXEDNODETYPE ;


// CStringsNode is a hybrid between CFixedNode and CProjectNode.  It is a fixed
// node that can be opened and edited.

class CStringsNode : public CBasicNode {
	unsigned        m_uidName;
    CSafeObArray    &m_csoaDescendants;
    CMultiDocTemplate*  m_pcmdt;    // Used for importing data
    CRuntimeClass*      m_pcrc;     // The second half of the import
    FIXEDNODETYPE	m_fntType ;		// Node type
	int m_nFirstSelRCID ;			// RC ID of first entry to select in editor
    DECLARE_DYNAMIC(CStringsNode)

public:
    CStringsNode(unsigned uidName, CSafeObArray& csoa, 
				 FIXEDNODETYPE fnt = FNT_OTHER, CMultiDocTemplate *pcmdt = NULL, 
				 CRuntimeClass *pcrc = NULL);
                 
	void    SetMenu(CWordArray& cwaSpec) { m_cwaMenuID.Copy(cwaSpec); }

    virtual BOOL			CanEdit() const { return TRUE; }
    virtual void			Fill(CTreeCtrl *pctc, HTREEITEM hti);
    virtual CMDIChildWnd*   CreateEditor();
	int  GetFirstSelRCID() { return m_nFirstSelRCID ; }
	void SetFirstSelRCID(int nrcid) { m_nFirstSelRCID = nrcid ; }
};

class CFileNode : public CBasicNode {
    
    BOOL    m_bEditPath, m_bCheckForValidity;
    CString m_csExtension, m_csPath;

    DECLARE_SERIAL(CFileNode)

    const CString ViewName() { 
        return m_bEditPath ? m_csPath + m_csName : m_csName;
    }

public:
    CFileNode();

    //  Attributes
    CString NameExt() const { return Name() + m_csExtension; }
    CString FullName() const { return m_csPath + Name() + m_csExtension; }
    const CString   Path() const { return m_csPath; }
    const CString   Extension() const { return m_csExtension; }
    virtual BOOL    CanEdit() const;
    //  Operations
    void    SetExtension(LPCTSTR lpstrExt) { m_csExtension = lpstrExt; }
    void    AllowPathEdit(BOOL bOK = TRUE) { m_bEditPath = bOK; }
    void    EnableCreationCheck(BOOL bOn = TRUE) { m_bCheckForValidity = bOn; }
	void	SetPath(LPCTSTR lpstrNew) { m_csPath = lpstrNew ; }
	void	SetPathAndName(LPCTSTR lpstrpath, LPCTSTR lpstrname) ;

    //  Overriden CBasicNode operations

    virtual BOOL    Rename(LPCTSTR lpstrNewName);
    virtual void    Fill(CTreeCtrl* pctc, HTREEITEM htiParent);
    virtual void    Serialize(CArchive& car);
};


// This class is used to manage the RC ID nodes in the Workspace view.  
// Currently, there is one of these for each UFM and GTT node.
//
// Note: This class must be enhanced to support extra functionality.
    
class CRCIDNode : public CBasicNode {
    int				m_nRCID;		// RC ID
    FIXEDNODETYPE	m_fntType ;		//  Node type
    DECLARE_SERIAL(CRCIDNode)

public:
    CRCIDNode() ;
	~CRCIDNode() {} ;

    virtual void Fill(CTreeCtrl *pctc, HTREEITEM hti, int nid, FIXEDNODETYPE fnt) ;
	int				nGetRCID() { return m_nRCID ; }
	void			nSetRCID(int nrcid) { m_nRCID = nrcid ; }
	FIXEDNODETYPE	fntGetType() { return m_fntType ; }
	void			fntSetType(FIXEDNODETYPE fnt) { m_fntType = fnt ; }

    virtual void    Serialize(CArchive& car);

	void			BuildDisplayName() ;
};


//  We bring it all together in a limited fashion at least, for the project
//  level node- it always contains a file name node.

class CProjectNode : public CBasicNode {
    DECLARE_SERIAL(CProjectNode)

	bool				m_bRefFlag ;	// Referenced flag used in WS checking

protected:
    CMultiDocTemplate*  m_pcmdt;

public:
    CProjectNode();

    CFileNode           m_cfn;
	CRCIDNode			m_crinRCID;		//  Workspace view, RC ID node

    const CString   FileName() const { return m_cfn.FullName(); }
    const CString   FilePath() const { return m_cfn.Path(); }
    const CString   FileTitle() const { return m_cfn.Name(); }
    const CString   FileExt() const { return m_cfn.Extension(); }
    const CString   FileTitleExt() const { return m_cfn.NameExt(); }
	
	const CString	GetPath() const { return m_cfn.Path() ; }
	void  SetPath(LPCTSTR lpstrNew) { m_cfn.SetPath(lpstrNew) ; }

    BOOL    SetFileName(LPCTSTR lpstrNew) { return m_cfn.Rename(lpstrNew); }
    void    EditorInfo(CMultiDocTemplate* pcmdt) { m_pcmdt = pcmdt; }
    BOOL    ReTitle(LPCTSTR lpstrNewName) {
        return m_cfn.CBasicNode::Rename(lpstrNewName);
    }

    virtual void    Fill(CTreeCtrl *pctcWhere, HTREEITEM htiParent = TVI_ROOT,
                         unsigned urcid = -1, FIXEDNODETYPE fnt = FNT_UNKNOWN);

    virtual void    Serialize(CArchive& car);

    // RC ID management routines

	int		nGetRCID() { return m_crinRCID.nGetRCID() ; }
	void	nSetRCID(int nrcid) { m_crinRCID.nSetRCID(nrcid) ; }
	void	ChangeID(CRCIDNode* prcidn, int nnewid, CString csrestype) ;

	// Reference flag management routines

	bool GetRefFlag() { return m_bRefFlag ; } 
	void SetRefFlag() { m_bRefFlag = true ; } 
	void ClearRefFlag() { m_bRefFlag = false ; } 
};


// This is a special class for nodes with constant names.  IE, labels for 
// groups of UFMs, GTTs, etc most of the time.	

class CFixedNode : public CBasicNode {
	unsigned        m_uidName;
    CSafeObArray    &m_csoaDescendants;
    CMultiDocTemplate*  m_pcmdt;    //  Used for importing data
    CRuntimeClass*      m_pcrc;     //  The second half of the import
    FIXEDNODETYPE	m_fntType ;		//  Node type
    DECLARE_DYNAMIC(CFixedNode)

public:
    CFixedNode(unsigned uidName, CSafeObArray& csoa, FIXEDNODETYPE fnt = FNT_OTHER,  
               CMultiDocTemplate *pcmdt = NULL, CRuntimeClass *pcrc = NULL);

	void    SetMenu(CWordArray& cwaSpec) { m_cwaMenuID.Copy(cwaSpec); }

    //  GPD Deletion support

    void    Zap(CProjectNode * pcpn, BOOL bdelfile) ;

    virtual BOOL    CanEdit() const { return FALSE; }
    virtual void    Import();
	void			Copy(CProjectNode *pcpnsrc, CString csorgdest) ;
	int				GetNextRCID() ;
    virtual void    Fill(CTreeCtrl *pctc, HTREEITEM hti);

	bool			IsFileInWorkspace(LPCTSTR strfspec)	;
	bool			IsRCIDUnique(int nid) ;

    FIXEDNODETYPE	GetType() { return m_fntType ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\parser.c ===
/******************************************************************************

  Source File:	Parser.C

  This is an NT Build hack.  It includes all of the "C" files used for the
  GPD parser, because Build can't handle directories beyond ..

  This file also contains some of the code used to access parts of the parser.
  It is put here so that there will be no need to grovel around to find the 
  appropriate include files needed to call the parser.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved

  A Pretty Penny Enterprises Production

  Change History:

  06-20-1997	Bob_Kjelgaard@Prodigy.Net	Did the dirty deed
  07-18-1998	ekevans@acsgroup.com		Added first parser access routines

******************************************************************************/

#define	UNICODE
#define	_UNICODE

#undef	WINVER	//	Undo the MFC weirdness
#define	WINVER	0x0500
#define	_DEBUG_H_
#include "lib.h"

extern void _cdecl DebugPrint(PCSTR, ...);

#define	ERR(x)	DebugPrint x
#define	WARNING(x) DebugPrint x
#define	VERBOSE(x)
#define	ASSERT(x)
#define RIP(x)

//	Parser files
#if defined(WIN32)
#include	"..\..\..\parsers\gpd\preproc1.c"
#include	"..\..\..\parsers\gpd\command.c"
#include	"..\..\..\parsers\gpd\constrnt.c"
#include	"..\..\..\parsers\gpd\helper1.c"
#include	"..\..\..\parsers\gpd\installb.c"
#include	"..\..\..\parsers\gpd\macros1.c"
#include	"..\..\..\parsers\gpd\postproc.c"
#include	"..\..\..\parsers\gpd\semanchk.c"
#include	"..\..\..\parsers\gpd\shortcut.c"
#include	"..\..\..\parsers\gpd\snapshot.c"
#include	"..\..\..\parsers\gpd\snaptbl.c"
#include	"..\..\..\parsers\gpd\state1.c"
#include	"..\..\..\parsers\gpd\state2.c"
#include	"..\..\..\parsers\gpd\token1.c"
#include	"..\..\..\parsers\gpd\value1.c"
#include	"..\..\..\parsers\gpd\treewalk.c"
#include	"..\..\..\parsers\gpd\framwrk1.c"
#else
#include	"..\..\parsers\gpd\preproc1.c"
#include	"..\..\parsers\gpd\command.c"
#include	"..\..\parsers\gpd\constrnt.c"
#include	"..\..\parsers\gpd\helper1.c"
#include	"..\..\parsers\gpd\installb.c"
#include	"..\..\parsers\gpd\macros1.c"
#include	"..\..\parsers\gpd\postproc.c"
#include	"..\..\parsers\gpd\semanchk.c"
#include	"..\..\parsers\gpd\shortcut.c"
#include	"..\..\parsers\gpd\snapshot.c"
#include	"..\..\parsers\gpd\snaptbl.c"
#include	"..\..\parsers\gpd\state1.c"
#include	"..\..\parsers\gpd\state2.c"
#include	"..\..\parsers\gpd\token1.c"
#include	"..\..\parsers\gpd\value1.c"
#include	"..\..\parsers\gpd\treewalk.c"
#include	"..\..\parsers\gpd\framwrk1.c"
#endif


BOOL bKeywordInitDone = FALSE ;		// TRUE iff the keyword table has been initialized
int  nKeywordTableSize = -1 ;		// The number of valid entries in the keyword table


/******************************************************************************

  InitGPDKeywordTable()

  Call the part of the GPD parser that is needed to initialize the GPD keyword
  table.  This must be done before GPD keyword string pointers can be returned
  by GetGPDKeywordStr().

  If all goes well, a flag is set, the size of the table is saved, and the size
  of the table is returned.  If something fails, return -1.

******************************************************************************/

int InitGPDKeywordTable(PGLOBL pglobl)
{			
    PRANGE  prng ;				// Used to reference the table section ranges

	// Initialize the GPD parser

	VinitGlobals(0, pglobl) ;
	if (!BpreAllocateObjects(pglobl) || !BinitPreAllocatedObjects(pglobl)) 
		return -1 ;
	bKeywordInitDone = TRUE ;

	// Save the size of the table

    prng  = (PRANGE)(gMasterTable[MTI_RNGDICTIONARY].pubStruct) ;
    nKeywordTableSize = (int) (prng[END_ATTR - 1].dwEnd) ;

	// Return the size of the table

	return nKeywordTableSize ;
}


/******************************************************************************

  GetGPDKeywordStr()

  Return a pointer to the specified (numbered) GPD keyword string.  The pointer
  might be NULL.  Always return a NULL pointer if the GPD keyword table has not
  been initialized or a request for a string passed the end of the table is
  requested.

******************************************************************************/

PSTR GetGPDKeywordStr(int nkeyidx, PGLOBL pglobl)
{
	// Nothing can be done if the GPD parser could not be initialized or the
	// key index is too big.

	if (!bKeywordInitDone || nkeyidx > nKeywordTableSize)
		return NULL ;

	// Return the requested keyword string pointer.

	return (mMainKeywordTable[nkeyidx].pstrKeyword) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projview.cpp ===
/******************************************************************************

  Source File:  Project View.CPP

  This implements the view class for project level information.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:

  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.h"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"comctrls.h"
#include    "ProjView.H"
#include	"INFWizrd.H"
#include    "Gpdfile.H"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProjectView

IMPLEMENT_DYNCREATE(CProjectView, CFormView)

BEGIN_MESSAGE_MAP(CProjectView, CFormView)
	//{{AFX_MSG_MAP(CProjectView)
	ON_NOTIFY(TVN_BEGINLABELEDIT, IDC_DriverView, OnBeginlabeleditDriverView)
	ON_NOTIFY(TVN_ENDLABELEDIT, IDC_DriverView, OnEndLabelEdit)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_DBLCLK, IDC_DriverView, OnDblclkDriverView)
	ON_COMMAND(ID_FILE_PARSE, OnFileParse)
	ON_NOTIFY(TVN_KEYDOWN, IDC_DriverView, OnKeydownDriverView)
	ON_WM_SIZE()
    ON_COMMAND(ID_FILE_CheckWS, OnCheckWorkspace)
	ON_COMMAND(ID_FILE_INF, OnFileInf)
	//}}AFX_MSG_MAP
	// Standard printing commands
//	ON_COMMAND(ID_FILE_PRINT, CFormView::OnFilePrint)	//RAID 135232 no printing in project view
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CFormView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CFormView::OnFilePrintPreview)
    //  Commands we pop up from context menus
    ON_COMMAND(ID_ExpandBranch, OnExpandBranch)
    ON_COMMAND(ID_CollapseBranch, OnCollapseBranch)
    ON_COMMAND(ID_RenameItem, OnRenameItem)
    ON_COMMAND(ID_OpenItem, OnOpenItem)
    //ON_COMMAND(ID_GenerateOne, OnGenerateItem)
    ON_COMMAND(IDOK, OnOpenItem)    //  We'll open an item if ENTER is hit
    ON_COMMAND(ID_Import, OnImport)
    ON_COMMAND(ID_DeleteItem, OnDeleteItem)
    ON_COMMAND(ID_CopyItem, OnCopyItem)
    ON_COMMAND(ID_ChangeID, OnChangeID)
    ON_COMMAND(ID_CheckWS, OnCheckWorkspace)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProjectView construction/destruction

CProjectView::CProjectView() : CFormView(CProjectView::IDD) {
	//{{AFX_DATA_INIT(CProjectView)
	//}}AFX_DATA_INIT
	
	// Resizing is not ok, yet

	bResizingOK = false ;
}


CProjectView::~CProjectView()
{
}


void CProjectView::DoDataExchange(CDataExchange* pDX) {
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProjectView)
	DDX_Control(pDX, IDC_DriverView, m_ctcDriver);
	//}}AFX_DATA_MAP
}

BOOL CProjectView::PreCreateWindow(CREATESTRUCT& cs) {
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.lpszClass = _T("Workspace") ;	 // raid 104822	
	return CScrollView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView drawing

void CProjectView::OnInitialUpdate() {
	CFormView::OnInitialUpdate();

    ResizeParentToFit(FALSE);

    //GetDocument() -> VerUpdateFilePaths();
    GetDocument() -> InitUI(&m_ctcDriver);
    GetParentFrame() -> ShowWindow(SW_SHOW);
    GetDocument() -> GPDConversionCheck();
	
	// Get the current dimensions of the workspace view window and the other
	// control(s) that can be resized.  Then set the flag that says that
	// resizing is ok now.

	WINDOWPLACEMENT wp ;
	wp.length = sizeof(WINDOWPLACEMENT) ;
	GetWindowPlacement(&wp) ;
	crWSVOrgDims = wp.rcNormalPosition ;
	crWSVCurDims = crWSVOrgDims ;
	m_ctcDriver.GetWindowPlacement(&wp) ;
	crTreeOrgDims = wp.rcNormalPosition ;
	crTreeCurDims = crTreeOrgDims ;
	HWND	hlblhandle ;		
	GetDlgItem(IDC_ProjectLabel, &hlblhandle) ;
	::GetWindowPlacement(hlblhandle, &wp) ;
	crLblOrgDims = wp.rcNormalPosition ;
	crLblCurDims = crLblOrgDims ;
	bResizingOK = true ;
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView printing

BOOL CProjectView::OnPreparePrinting(CPrintInfo* pInfo) {
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CProjectView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/) {
	// TODO: add extra initialization before printing
}

void CProjectView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/) {
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CProjectView diagnostics

#ifdef _DEBUG
void CProjectView::AssertValid() const {
	CScrollView::AssertValid();
}

void CProjectView::Dump(CDumpContext& dc) const {
	CScrollView::Dump(dc);
}

CProjectRecord* CProjectView::GetDocument() {// non-debug version is inline
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CProjectRecord)));
	return (CProjectRecord*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CProjectView message handlers

void CProjectView::OnBeginlabeleditDriverView(NMHDR* pnmh, LRESULT* plr) {
	TV_DISPINFO* ptvdi = (TV_DISPINFO*) pnmh;

    *plr = !((CBasicNode *) ptvdi -> item.lParam) -> CanEdit();
}

/******************************************************************************

  CProjectView::OnEndLabelEdit

  Called when a label in the view has been edited- the user has either
  canceled (new text in item will be empty), or changed the text.  We pass the
  whole information on to the CBasicNode which handles this object.

******************************************************************************/

void CProjectView::OnEndLabelEdit(NMHDR* pnmh, LRESULT* plr) {
	TV_DISPINFO* ptvdi = (TV_DISPINFO*) pnmh;

    *plr = ((CBasicNode *) ptvdi -> item.lParam) -> Rename(ptvdi -> 
        item.pszText);
	//raid 19658
	CString csfile = ptvdi->item.pszText;
	int offset;
	if(-1 != (offset=csfile.ReverseFind(_T('\\')) ) ) {
		CModelData cmd;
		CString csValue = csfile.Mid(offset+1);
//		csValue.MakeUpper();
		csValue +=  _T(".GPD");
		csfile += _T(".gpd");
		cmd.SetKeywordValue(csfile,_T("*GPDFileName"),csValue);
	}


}

/******************************************************************************

  CProjectView::OnContextMenu

  This is called when the user right-clicks the mouse.  We determine if the
  mouse is within an item in the tree view.  If it is, then we pass it on to
  the CBasicNode-derived object which handles that item.  That object is then
  responsible for displaying the proper context menu.

******************************************************************************/

void CProjectView::OnContextMenu(CWnd* pcw, CPoint cp) {
	if  (pcw != &m_ctcDriver)
        return;

    CPoint  cpThis(cp);

    m_ctcDriver.ScreenToClient(&cpThis);

    //  If the mouse is inside the area of any item, display its context menu

    UINT    ufItem;

    HTREEITEM hti = m_ctcDriver.HitTest(cpThis, &ufItem);

    if  (!hti || !(ufItem & (TVHT_ONITEM | TVHT_ONITEMBUTTON)))
        return;
        
    //  Some operations require we know which item, so we're going to
    //  select the given item.  If this is really a problem, we can change
    //  it later (cache it in a member).

    m_ctcDriver.SelectItem(hti);

    ((CBasicNode *) m_ctcDriver.GetItemData(hti)) -> ContextMenu(this, cp);
}

/******************************************************************************

  CProjectView::OnExpandBranch

  This is called when the user selects an expand item from a context menu.  In
  this case, we don't need to pass this through the CBasicNode- we just expand
  it using the normal common control methods (actually using an MFC method, 
  since this promises greater future portability).

******************************************************************************/

void    CProjectView::OnExpandBranch() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.Expand(htiSelected, TVE_EXPAND);
}

/******************************************************************************

  CProjectView::OnCollapseBranch

  In this case, the user has selected the Collapse item from a context menu.
  We collapse the branch at the selected tree view item.

******************************************************************************/

void    CProjectView::OnCollapseBranch() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.Expand(htiSelected, TVE_COLLAPSE);
}

/******************************************************************************

  CProjectView::OnRenameItem

  This handles a user selecting a Rename item.  This results in us ordering the
  view to begin label editing of the selected item.  The interactions regarding
  label editing are routed to the underlying CBasicNode object via 
  OnBeginLabelEdit and OnEndLabelEdit.

******************************************************************************/

void    CProjectView::OnRenameItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    m_ctcDriver.EditLabel(htiSelected);
}

/******************************************************************************

  CProjectView::OnOpenItem

  This method is invoked when the user wishes to edit an item in the tree.
  This is always routed through the underlying CBasicNode-derived item.  Some
  items can't be edited, and will ignore this (in fact, this is the base class
  behavior).

******************************************************************************/

void    CProjectView::OnOpenItem() { 
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();
	

    if  (!htiSelected) 
        return;
	// raid 8350
	CWnd *cwd = FromHandle(m_hWnd); 
	(cwd->GetParent()) -> ShowWindow(SW_SHOWNORMAL );


  ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Edit();
}

//  Generate an image of the selected item (usable for building)
/*		No longer supported
void    CProjectView::OnGenerateItem() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    //((CProjectNode *) m_ctcDriver.GetItemData(htiSelected)) -> Generate();
}
*/

/******************************************************************************

  CProjectView::OnDblClkDriverView

  This is called when the user double-clicks anywhere in the tree view.  We
  route it through the Open message handler, as this will always be the desired
  action.

******************************************************************************/

void CProjectView::OnDblclkDriverView(NMHDR* pNMHDR, LRESULT* pResult) {
	OnOpenItem();
}

/******************************************************************************

  CProjectView::OnFileParse

  This method invokes the parser on each of the GPD files in the project.

******************************************************************************/

void CProjectView::OnFileParse() {
    {
        CWaitCursor cwc;    //  This could take a while...

        for (unsigned u = 0; u < GetDocument() -> ModelCount(); u++) {
            GetDocument() -> Model(u).Parse(0);
            GetDocument() -> Model(u).UpdateEditor();
        }
    }

    GetDocument() -> GPDConversionCheck(TRUE);

}

/******************************************************************************

  CProjectView::OnKeydownDriverView

  This handles various keystrokes we want handled over and above what the
  default handling by the control supplies.

******************************************************************************/

void CProjectView::OnKeydownDriverView(NMHDR* pnmh, LRESULT* plr) {
	TV_KEYDOWN* ptvkd = (TV_KEYDOWN*)pnmh;

    HTREEITEM htiSelected = m_ctcDriver.GetSelectedItem();

	*plr = 0;

    if  (!htiSelected)
        return;

    CRect   crThis;
    
    m_ctcDriver.GetItemRect(htiSelected, crThis, FALSE);

    CBasicNode& cbn = *(CBasicNode *) m_ctcDriver.GetItemData(htiSelected);
	
    switch  (ptvkd -> wVKey) {
        case    VK_F10:
            //  Create a context menu for this item.
            m_ctcDriver.ClientToScreen(crThis);
            cbn.ContextMenu(this, crThis.CenterPoint());
            return;

        case    VK_DELETE:
            //  If the item is successfully deleted, remove it from the
            //  view
            OnDeleteItem();  //add (raid 7227)
//			cbn.Delete();   //delete(raid 7227)
            return;
//RAID 7227 add hot key
		//Open F2, Copy F3, Rename, Delete DELETE Key,
		case     VK_F2:
			OnOpenItem();
			return;
		case     VK_F3:
			OnCopyItem();
			return;
		case     VK_F4:
			OnRenameItem();
			return;
    }
}

/******************************************************************************

  CProjectView::OnImport

  This method is invoked when the user selects an "Import" item on a context
  menu.  How this is handled is entirely the responsibility of the underlying
  CBasicNode-derived item, so the request gets routed there by this code.

******************************************************************************/

void    CProjectView::OnImport() {
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

    ((CBasicNode *) m_ctcDriver.GetItemData(htiSelected)) -> Import();
}

/******************************************************************************

  CProjectView::OnDeleteItem

  For item deletion via context menu.  The delete key is handled in 
  OnKeydownDriverView.  Once again, the underlying object handles what happens.
  BUT, before that happens, this routine handles the common UI because of
  oddities with working with the DLLs.

******************************************************************************/

void    CProjectView::OnDeleteItem() 
{
    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();

    if  (!htiSelected)
        return;

	// The selected item should be a pointer to a project node+.  Get a pointer
	// to the node and verify its type.  Return if the type is incorrect.

	CProjectNode* pcpn = (CProjectNode*) m_ctcDriver.GetItemData(htiSelected) ;
    if (!pcpn->IsKindOf(RUNTIME_CLASS(CProjectNode)))
		return ;

	// Init and prompt for the new RC ID.  Return if the user cancels.

    CDeleteQuery cdq;
	CString cstmp(pcpn->FileExt()) ;
	cstmp = cstmp.Mid(1) ;
	cdq.Init(cstmp, pcpn->Name()) ;
    if  (cdq.DoModal() != IDYES)
        return ;

    //  Walk back up the hierarchy to find the owning Fixed node, and
    //  remove us from the array for that node- since that member is a
    //  reference to the array, all will work as it should.

    CFixedNode&  cfn = * (CFixedNode *) m_ctcDriver.GetItemData(
        m_ctcDriver.GetParentItem(pcpn->Handle())) ;
    ASSERT(cfn.IsKindOf(RUNTIME_CLASS(CFixedNode))) ;
    cfn.Zap(pcpn, cdq.KillFile());

    //  WARNING:  the object pointed to by this has been deleted do NOTHING
    //  from this point on that could cause the pointer to be dereferenced!
}


/******************************************************************************

  CProjectView::OnCopyItem

  For item copy via context menu.  Once again, the underlying object handles 
  what happens. BUT, before that happens, this routine handles the common UI
  because of oddities with working with the DLLs.

******************************************************************************/

void    CProjectView::OnCopyItem()
{
	// Just return if nothing is selected.

    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();
    if  (!htiSelected)
        return ;

	// The selected item should be a pointer to a project node+.  Get a pointer
	// to the node and verify its type.  Return if the type is incorrect.

	CProjectNode* pcpn = (CProjectNode*) m_ctcDriver.GetItemData(htiSelected) ;
    if (!pcpn->IsKindOf(RUNTIME_CLASS(CProjectNode)))
		return ;

	// Prompt for the new file name.  Return if the user cancels.

	CCopyItem cci ;
	cci.Init(pcpn->FileTitleExt()) ;
	if (cci.DoModal() == IDCANCEL)
		return ;

    //  Walk back up the hierarchy to find this project node's owning Fixed node.

    CFixedNode&  cfn = * (CFixedNode *) m_ctcDriver.GetItemData(
        m_ctcDriver.GetParentItem(pcpn->Handle())) ;
    ASSERT(cfn.IsKindOf(RUNTIME_CLASS(CFixedNode)));

	// Call the fixed node to make the copy of its child.

	cfn.Copy(pcpn, cci.m_csCopyName) ;
}


/******************************************************************************

  CProjectView::OnChangeID

  Called to change a resource ID via context menu.  Once again, the underlying
  object handles what happens.  BUT, before that happens, this routine handles
  the common UI because of oddities with working with the DLLs.

******************************************************************************/

void    CProjectView::OnChangeID()
{
	// Just return if nothing is selected.

    HTREEITEM   htiSelected = m_ctcDriver.GetSelectedItem();
    if  (!htiSelected)
        return ;

	// The selected item should be a pointer to a RCID node.  Get a pointer
	// to the node and verify its type.  Return if the type is incorrect.

	CRCIDNode* prcidn = (CRCIDNode*) m_ctcDriver.GetItemData(htiSelected) ;
    if (!prcidn->IsKindOf(RUNTIME_CLASS(CRCIDNode)))
		return ;

    //  Walk back up the hierarchy to find this RCID node's owning project node.

    CProjectNode&  cpn = * (CProjectNode *) m_ctcDriver.GetItemData(
        m_ctcDriver.GetParentItem(prcidn->Handle())) ;
    ASSERT(cpn.IsKindOf(RUNTIME_CLASS(CProjectNode)));

	// Init and prompt for the new RC ID.  Return if the user cancels.

	CChangeID ccid ;
	CString cstmp(cpn.FileExt()) ;
	cstmp = cstmp.Mid(1) ;
	ccid.Init(cstmp, cpn.Name(), prcidn->nGetRCID()) ;
	if (ccid.DoModal() == IDCANCEL)
		return ;

	// Call a project node function to finish the work.

	cpn.ChangeID(prcidn, ccid.m_nNewResID, cstmp) ;
}


/******************************************************************************

  CProjectView::OnCheckWorkspace

  Called to check a workspace for completeness and tidiness.

******************************************************************************/

void    CProjectView::OnCheckWorkspace()
{
	// Save the current directory

	CString cscurdir ;
	::GetCurrentDirectory(512, cscurdir.GetBuffer(512)) ;
	cscurdir.ReleaseBuffer() ;

	// Change the current directory to the directory containing the GPDs and
	// then check the workspace.

	SetCurrentDirectory(((CProjectRecord*) GetDocument())->GetW2000Path()) ;
	GetDocument()->WorkspaceChecker(false) ;

	// Reset the original directory

	SetCurrentDirectory(cscurdir) ;
}


/******************************************************************************

  CProjectView::OnSize

  Resize the label and tree control in the workspace view when the view is
  resized.

******************************************************************************/

void CProjectView::OnSize(UINT ntype, int cx, int cy)
{
	// First, call this routine for the base class

	CFormView::OnSize(ntype, cx, cy) ;

	// Do nothing else if the other data needed for resizing is uninitialized.
	// Also ignore all WM_SIZE messages except those with types of either
	// SIZE_MAXIMIZED or SIZE_RESTORED.

	if (!bResizingOK || (ntype != SIZE_MAXIMIZED && ntype != SIZE_RESTORED))
		return ;

	// Determine how much the window's dimensions have changed

	int ndx = cx - crWSVCurDims.Width() ;
	int ndy = cy - crWSVCurDims.Height() ;
	crWSVCurDims.right += ndx ;
	crWSVCurDims.bottom += ndy ;

	// Update the tree control's dimensions based on how much the window has
	// changed, make sure the control's minimums have not been exceeded, and
	// then change the size of the tree control.
				   
	crTreeCurDims.right += ndx ;
	crTreeCurDims.bottom += ndy ;
	if (crTreeOrgDims.Width() > crTreeCurDims.Width() 
	 || crWSVOrgDims.Width() >= crWSVCurDims.Width())
		crTreeCurDims.right = crTreeOrgDims.right ;
	if (crTreeOrgDims.Height() > crTreeCurDims.Height() 
	 || crWSVOrgDims.Height() >= crWSVCurDims.Height())
		crTreeCurDims.bottom = crTreeOrgDims.bottom ;
	m_ctcDriver.MoveWindow(crTreeCurDims, TRUE) ;

	// Now, do the same thing for the label.  The one difference is that only
	// label's width is allowed to change.

	crLblCurDims.right += ndx ;
	if (crLblOrgDims.Width() > crLblCurDims.Width() 
	 || crWSVOrgDims.Width() >= crWSVCurDims.Width())
		crLblCurDims.right = crLblOrgDims.right ;
	HWND	hlblhandle ;		
	GetDlgItem(IDC_ProjectLabel, &hlblhandle) ;
	::MoveWindow(hlblhandle, crLblCurDims.left, crLblCurDims.top, 
	 crLblCurDims.Width(), crLblCurDims.Height(), TRUE) ;

}


/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog


CCopyItem::CCopyItem(CWnd* pParent /*=NULL*/)
	: CDialog(CCopyItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCopyItem)
	m_csCopyName = _T("");
	m_csCopyPrompt = _T("");
	//}}AFX_DATA_INIT
}


void CCopyItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyItem)
	DDX_Text(pDX, IDC_CopyName, m_csCopyName);
	DDX_Text(pDX, IDC_CopyPrompt, m_csCopyPrompt);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCopyItem, CDialog)
	//{{AFX_MSG_MAP(CCopyItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyItem message handlers

void CCopyItem::Init(CString cssrcfile)
{
	// Build the copy prompt string.

	m_csCopyPrompt.Format(IDS_CopyPrompt, cssrcfile) ;
}
/////////////////////////////////////////////////////////////////////////////
// CChangeID dialog


CChangeID::CChangeID(CWnd* pParent /*=NULL*/)
	: CDialog(CChangeID::IDD, pParent)
{
	//{{AFX_DATA_INIT(CChangeID)
	m_csResourceLabel = _T("");
	m_csResourceName = _T("");
	m_nCurResID = 0;
	m_nNewResID = 0;
	//}}AFX_DATA_INIT
}


void CChangeID::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChangeID)
	DDX_Text(pDX, IDC_ResourceLabel, m_csResourceLabel);
	DDX_Text(pDX, IDC_ResourceName, m_csResourceName);
	DDX_Text(pDX, IDC_CurResID, m_nCurResID);
	DDX_Text(pDX, IDC_NewResID, m_nNewResID);
	DDV_MinMaxInt(pDX, m_nNewResID, 1, 999999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangeID, CDialog)
	//{{AFX_MSG_MAP(CChangeID)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangeID message handlers

void CChangeID::Init(CString csrestype, CString csname, int ncurid)
{
	m_csResourceLabel.Format(IDS_ResourceLabel,	csrestype) ;
	m_csResourceName = csname ;
	m_nCurResID	= ncurid ;
}


/******************************************************************************
 
  CDeleteQuery dialog

  This implements the dialog that validates and verifies the removal of a 
  file from the workspace.

******************************************************************************/

CDeleteQuery::CDeleteQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteQuery::IDD, pParent) {
	//{{AFX_DATA_INIT(CDeleteQuery)
	m_csTarget = _T("");
	m_bRemoveFile = FALSE;
	//}}AFX_DATA_INIT
}


void CDeleteQuery::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteQuery)
	DDX_Text(pDX, IDC_DeletePrompt, m_csTarget);
	DDX_Check(pDX, IDC_Remove, m_bRemoveFile);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDeleteQuery, CDialog)
	//{{AFX_MSG_MAP(CDeleteQuery)
	ON_BN_CLICKED(IDNO, OnNo)
	ON_BN_CLICKED(IDYES, OnYes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteQuery message handlers

void CDeleteQuery::Init(CString csrestype, CString csname) 
{
	m_csTarget.Format(IDS_DeletePrompt, csrestype, csname) ;
}


void CDeleteQuery::OnYes() {
	if  (UpdateData())
        EndDialog(IDYES);
	
}


void CDeleteQuery::OnNo() {
	EndDialog(IDNO);
}


/******************************************************************************

  CProjectView::OnFileInf

  Called when the Generate INF command is selected on the File menu.  This
  routine invokes the INF file generation wizard to collect input and generate
  the INF file.  Then create and initialize a window to display the INF file.

******************************************************************************/

void CProjectView::OnFileInf() 
{
	// INF files can only be generated for projects that contain models (GPDs).

	if (GetDocument()->ModelCount() == 0) {
		CString csmsg ;
		csmsg.LoadString(IDS_INFNoModelsError) ;
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return ;
	} ;

    // Initialize the INF generation wizard.

    CINFWizard* pciw = new CINFWizard(this) ;

    // Invoke the INF generation wizard. Clean up and return if the user 
	// cancels.

    if (pciw->DoModal() == IDCANCEL) {
		delete pciw ;
		return ;
	} ;

	// Generate the INF file based on the information collected.

	if (!pciw->GenerateINFFile()) {
		delete pciw ;
		return ;
	} ;

	// Allocate and initialize the document.

    CINFWizDoc* pciwd = new CINFWizDoc((CProjectRecord*) GetDocument(), pciw) ;

	// Create the window.

    CMDIChildWnd* pcmcwnew ;
	CMultiDocTemplate* pcmdt = INFViewerTemplate() ;
	pcmcwnew = (CMDIChildWnd *) pcmdt->CreateNewFrame(pciwd, NULL) ;

	// If the window was created, finish the initialization.  Otherwise, just 
	// return.

    if  (pcmcwnew) {
        pcmdt->InitialUpdateFrame(pcmcwnew, pciwd, TRUE) ;
        pcmdt->AddDocument(pciwd) ;
	} ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projrec.h ===
/******************************************************************************

  Header File:  Project Record.H

  This defines the CProjectRecord class, which tracks and controls the progress
  and content of a single project workspace in the studio.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(AFX_PROJREC_H__50303D0C_EKE1_11D2_AB62_00C04FA30E4A__INCLUDED_)
#define AFX_PROJREC_H__50303D0C_EKE1_11D2_AB62_00C04FA30E4A__INCLUDED_

#if defined(LONG_NAMES)
#include    "Driver Resources.H"
#else
#include    "RCFile.H"
#endif

///////////////////////////////////////////////////////////////////////////////
//
// MDT Workspace Versioning
//
// The MDT uses MFC's Serialization support to save and restore the state of a
// driver's workspace.  This data is saved in an MDW file.  The Serialization
// support is supposed to include versioning but it doesn't seem to be working
// so I have implemented my own versioning support for workspace files.
//
// A version stamp in the form of the following structure 
// (plus related definitions) will be added to the beginning of each MDW file.
// The CProjectRecord::Serialize() will read and write the version stamp.  The
// version info is saved in a member variable (m_mvMDWVersion) and the number 
// is accessible via GetMDWVersion().  A version number of 0 is put into 
// m_nMDWVersion if the an old MDW with no version is read.  In this case, the
// workspace is marked as being dirty so that it can be updated later.
//
// The current version number is set by the value for MDW_CURRENT_VERSION.  
// Version numbers are unsigned integers.  Each time the version number is
// changed, an entry should be made in the following table describing the 
// reason for the change.
//
//
// MDW VERSION HISTORY
//
// Version		Date		Description
// ----------------------------------------------------------------------------
//	  0			02/01/98	Contains no version info.  Should be the MDW 
//							version that has UFM and GTT RC IDs in it.
//	  1			04/21/98	String table RC IDs were added to the MDW files.
//	  2			10/08/98	Default code page number added to the MDW files.
//	  3			09/15/98	RC file timestamp was added to the MDW file.
//	  4			12/14/98	Resource DLL name changed from xxxxxRES.DLL to 
//							xxxxxxxx.DLL.
//	  5			03/02/99	Driver file paths removed from the MDW file.
//	  6			08/16/99	Changed the root of the driver files' subtree from
//							NT5 to W2K so that the directory name matches the
//							OS name.
//
//
// The version information below is used to determine what is in an MDW file 
// and when to upgrade that file and other parts of a driver's workspace; most
// notably the RC file.  Upgrade determination and work (or at least the code 
// that manages the upgrading) are in CProjectRecord::OnOpenDocument().  See
// that member function for more information.
//

// Definitions for the current MDW version, each MDW version that has been
// used, the first upgradable version, and the default MDW version.
										
#define MDW_CURRENT_VERSION			7	// See table above for more info
#define MDW_VER_YES_FILE_PATHS      7	// Give .mdw file saving place flexibility. //raid 123448
#define MDW_VER_FILES_IN_W2K_TREE	6	// Driver files in W2K tree
#define MDW_VER_NO_FILE_PATHS		5	// Removed file paths from MDW file
#define MDW_VER_NEW_DLLNAME			4	// Ver # when resource DLL name changed
#define MDW_VER_RC_TIMESTAMP		3	// Ver # when RC file timestamp added
#define MDW_VER_DEFAULT_CPAGE		2	// Ver # when default code page added
#define MDW_VER_STRING_RCIDS		1	// Ver # when string IDs added
#define MDW_FIRST_UPGRADABLE_VER	1	// All vers >= to this can be upgraded
#define MDW_DEFAULT_VERSION			0	// Ver # when no ver info in MDW file

#define VERTAGLEN				12				// Length of the version tag
#define	VERTAGSTR				"EKE MDW VER"	// Version tag string

typedef struct mdwversioninfo {
	char		acvertag[VERTAGLEN] ;	// Used to identify version stamp
	unsigned	uvernum ;				// Version number
} MDWVERSION, *PMDWVERSION ;

#define	MDWVERSIONSIZE	sizeof(MDWVERSION) 


enum {Win95 = 1, WinNT3x, WinNT40 = 4, Win2000 = 8, NotW2000 = 16};

class CProjectRecord : public CDocument {
    CString m_csSourceRCFile, m_csRCName;
    CString m_csW2000Path, m_csNT40Path, m_csNT3xPath, m_csWin95Path;
	
	CString m_csProjFSpec ;		// Location of project file.

	// True iff the RC file should be rewritten whenever the project workspace
	// file is saved.

	BOOL	m_bRCModifiedFlag ;	
    
	UINT    m_ufTargets;

    CDriverResources    m_cdr;  //  A record of the RC file contents
    
    //  Enumerated flags for the project's status

    enum {UniToolRun = 1, ConversionsDone = 2, NTGPCDone = 4};
    UINT    m_ufStatus;

	MDWVERSION	m_mvMDWVersion ;	// MDW version information

	virtual BOOL OnSaveDocument( LPCTSTR lpszPathName ) ;

	// Last time RC file was changed by MDT.

	CTime	m_ctRCFileTimeStamp ;
	
	// The next two variables are used to save the default code page number.
	// Two variables are used because the Far East code pages are built into
	// the MDT as resources so - in these cases - the Far East code pages'
	// resource number (actually negative resource number) is needed too.

	DWORD	m_dwDefaultCodePage ;	// Code page number / neg resource ID
	DWORD	m_dwDefaultCodePageNum ;// Code page number 

protected: // create from serialization only
	CProjectRecord();
	DECLARE_DYNCREATE(CProjectRecord)

// Attributes
public:

	void	SetRCModifiedFlag(BOOL bsetting) {m_bRCModifiedFlag = bsetting ; }

    BOOL    IsTargetEnabled(UINT ufTarget) const { 
        return m_ufTargets & ufTarget;
    }

    BOOL    UniToolHasBeenRun() const { return m_ufStatus & UniToolRun; }
    BOOL    ConversionsComplete() const {
        return m_ufStatus & ConversionsDone; 
    }
    BOOL    NTGPCCompleted() const { return m_ufStatus & NTGPCDone; }

    CString SourceFile() const { return m_csSourceRCFile; }

    CString     DriverName() { return m_cdr.Name(); }

    CString TargetPath(UINT ufTarget) const;

    CString     RCName(UINT ufTarget) const {
        return  TargetPath(ufTarget) + _TEXT("\\") + m_csRCName;
    }

    unsigned    MapCount() const { return m_cdr.MapCount(); }
    CGlyphMap&  GlyphMap(unsigned u) { return m_cdr.GlyphTable(u); }

    unsigned    ModelCount() const { return m_cdr.Models(); }
    CModelData& Model(unsigned u) { return m_cdr.Model(u); }

	CString		GetW2000Path() { return m_csW2000Path ; }

	unsigned	GetMDWVersion() { return m_mvMDWVersion.uvernum ; }

	void		SetMDWVersion(unsigned nver) { m_mvMDWVersion.uvernum = nver ; } 
	
	CStringTable* GetStrTable() { return m_cdr.GetStrTable() ; }

	bool		RCFileChanged() ;

	bool		GetRCFileTimeStamp(CTime& ct) ;

	// See variable declarations for more info about these functions.

	DWORD GetDefaultCodePage() { return m_dwDefaultCodePage ; }
	DWORD GetDefaultCodePageNum() { return m_dwDefaultCodePageNum ; }
	void SetDefaultCodePage(DWORD dwcp) { m_dwDefaultCodePage = dwcp ; }
	void SetDefaultCodePageNum(DWORD dwcp) { m_dwDefaultCodePageNum = dwcp ; }

	CString		GetProjFSpec() { return m_csProjFSpec ; }

// Operations
public:

    void    EnableTarget(UINT ufTarget, BOOL bOn = TRUE) {
        UINT    ufCurrent = m_ufTargets;
        if  (bOn)
            m_ufTargets |= ufTarget;
        else
            m_ufTargets &= ~ufTarget;
        if  (ufCurrent == m_ufTargets)
            return;
        if  (ufTarget & (WinNT3x | WinNT40 | Win2000) ) { //raid 105917
            m_ufStatus &=~(ConversionsDone | NTGPCDone);
            return;
        }
    }

    void    SetSourceRCFile(LPCTSTR lpstrSource);

    BOOL    LoadResources();

    BOOL    LoadFontData() { return m_cdr.LoadFontData(*this); }
    
	// The next 3 functions support the GPD Selection feature in the Conversion
	// Wizard.

	BOOL    GetGPDModelInfo(CStringArray* pcsamodels, CStringArray* pcsafiles) {
		return m_cdr.GetGPDModelInfo(pcsamodels, pcsafiles) ; 
	}

	int		SaveVerGPDFNames(CStringArray& csafiles, bool bverifydata) {
		return m_cdr.SaveVerGPDFNames(csafiles, bverifydata) ;
	} ;
    
	void   GenerateGPDFileNames(CStringArray& csamodels, CStringArray& csafiles) {
		m_cdr.GenerateGPDFileNames(csamodels, csafiles) ; 
	}

	BOOL    SetPath(UINT ufTarget, LPCTSTR lpstrNewPath);

    BOOL    BuildStructure(unsigned uVersion);

    BOOL    GenerateTargets(WORD wfGPDConvert);

    void    OldStuffDone() { m_ufStatus |= NTGPCDone; }
    void    Rename(LPCTSTR lpstrNewName) { m_cdr.Rename(lpstrNewName); }
    void    InitUI(CTreeCtrl *pctc) { m_cdr.Fill(pctc, *this); }
    void    GPDConversionCheck(BOOL bReportSuccess = FALSE);

	// Conversion log file management routines

	bool	OpenConvLogFile(void) { 
		return m_cdr.OpenConvLogFile(m_csSourceRCFile) ; 
	}
	void	CloseConvLogFile(void) { m_cdr.CloseConvLogFile() ; }
	CString	GetConvLogFileName() const {return m_cdr.GetConvLogFileName() ; }
	bool	ThereAreConvErrors() {return m_cdr.ThereAreConvErrors() ; }

	bool	WorkspaceChecker(bool bclosing) {
		return m_cdr.WorkspaceChecker(bclosing) ;
	}

	// Upgrade management routines.

	bool	UpdateRCFile() ;
	bool	UpdateDfltCodePage() ;
	bool	UpdateDrvSubtreeRootName() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectRecord)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	CGlyphMap& GlyphTable(unsigned u) { return m_cdr.GlyphTable(u) ; } ;
	BOOL CreateFromNew(CStringArray& csaUFMFiles,CStringArray& csaGTTFiles,CString& csGpdPath,CString& csModelName,CString& csResourceDll,CStringArray& csaRcid );
	bool    VerUpdateFilePaths(void);
	virtual ~CProjectRecord();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CProjectRecord)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CGetDefCodePage dialog

class CGetDefCodePage : public CDialog
{
	// The next two variables are used to save the default code page number.
	// Two variables are used because the Far East code pages are built into
	// the MDT as resources so - in these cases - the Far East code pages'
	// resource number (actually negative resource number) is needed too.

	DWORD	m_dwDefaultCodePage ;	// Code page number / neg resource ID
	DWORD	m_dwDefaultCodePageNum ;// Code page number 

// Construction
public:
	CGetDefCodePage(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGetDefCodePage)
	enum { IDD = IDD_UpgDefCPage };
	CListBox	m_clbCodePages;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetDefCodePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	// See variable declarations for more info about these functions.

	DWORD GetDefaultCodePage() { return m_dwDefaultCodePage ; }
	DWORD GetDefaultCodePageNum() { return m_dwDefaultCodePageNum ; }

protected:

	// Generated message map functions
	//{{AFX_MSG(CGetDefCodePage)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // !defined(AFX_PROJREC_H__50303D0C_EKE1_11D2_AB62_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\prtdlg.cpp ===
// PrtDlg.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"

#include "PrtDlg.h"
#include "Windows.h"
#include "commdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrtDlg dialog


CPrtDlg::CPrtDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPrtDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPrtDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPrtDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPrtDlg)
	DDX_Control(pDX, IDC_PRINT_COMBO, m_ccbPrtList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPrtDlg, CDialog)
	//{{AFX_MSG_MAP(CPrtDlg)
	ON_BN_CLICKED(IDC_PRINT_SETUP, OnPrintSetup)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPrtDlg message handlers
/*
  	show print standard sheet dialog box and set up
  
*/
void CPrtDlg::OnPrintSetup() 
{
/*
	HRESULT hResult;
	LPPRINTDLGEX pPDX = NULL;
LPPRINTPAGERANGE pPageRanges = NULL;

// Allocate the PRINTDLGEX structure.

pPDX = (LPPRINTDLGEX)GlobalAlloc(GPTR, sizeof(PRINTDLGEX));
if (!pPDX)
    return E_OUTOFMEMORY;

// Allocate an array of PRINTPAGERANGE structures.

pPageRanges = (LPPRINTPAGERANGE) GlobalAlloc(GPTR, 
                   10 * sizeof(PRINTPAGERANGE));
if (!pPageRanges)
    return E_OUTOFMEMORY;

//  Initialize the PRINTDLGEX structure.

pPDX->lStructSize = sizeof(PRINTDLGEX);
pPDX->hwndOwner = hWnd;
pPDX->hDevMode = NULL;
pPDX->hDevNames = NULL;
pPDX->hDC = NULL;
pPDX->Flags = PD_RETURNDC | PD_COLLATE;
pPDX->Flags2 = 0;
pPDX->ExclusionFlags = 0;
pPDX->nPageRanges = 0;
pPDX->nMaxPageRanges = 10;
pPDX->lpPageRanges = pPageRanges;
pPDX->nMinPage = 1;
pPDX->nMaxPage = 1000;
pPDX->nCopies = 1;
pPDX->hInstance = 0;
pPDX->lpPrintTemplateName = NULL;
pPDX->lpCallback = NULL;
pPDX->nPropertyPages = 0;
pPDX->lphPropertyPages = NULL;
pPDX->nStartPage = START_PAGE_GENERAL;
pPDX->dwResultAction = 0;

//  Invoke the Print property sheet.

hResult = PrintDlgEx(pPDX);

if ( (hResult == S_OK) &&
           pPDX->dwResultAction == PD_RESULT_PRINT) {

    // User clicked the Print button, so
    // use the DC and other information returned in the 
    // PRINTDLGEX structure to print the document
	
*/	
}	
	
	
/*void CPrtDlg::OnOK()
Print out Gpd view
	
  Get DOCINFO
  Get PrintDC, 
  1. StartDoc(), StartPage(), EndPage(),  
	
	
  2. Things to consider
	
     2.1  line number of printable area
	 2.2  character height for 2.1
	 2.3  Clipping area  --> 
	       2.3.1  selection part -> capture string(avoid disrupting its format)
           2.3.2  All -> GPDDOC();
     
	   
*/	

void CPrtDlg::OnOK() 
{   
//	CGPDViewer* pcgv = (CGPDViewer *)GetParent();
// get View, Doc class 
	CWnd *pcw = GetParent();

//	CDocument *pcd = pcw ->GetDocument();

// Get PrintDC
        

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\projview.h ===
/******************************************************************************

  Header File:  Project View.H

  This defines the class which provides the UI for viewing and manipulating
  project level information for the studio.

  Copyright (c) 1997 by Microsoft Corporaiton.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/
#if defined(LONG_NAMES)
#include    "Project Record.H"
#else
#include    "ProjRec.H"
#endif

class CProjectView : public CFormView {
protected: // create from serialization only
	CProjectView();
	CRect	crWSVOrgDims ;		// Window's original dimensions
	CRect	crWSVCurDims ;		// Window's current dimensions
	CRect	crTreeCurDims ;		// Current tree (m_ctcDriver) control dimensions
	CRect	crTreeOrgDims ;		// Original tree (m_ctcDriver) control dimensions
	CRect	crLblCurDims ;		// Current label dimensions
	CRect	crLblOrgDims ;		// Current label dimensions
	bool	bResizingOK ;		// True iff it is OK to resize the control(s)
	DECLARE_DYNCREATE(CProjectView)

// Attributes
public:
	//{{AFX_DATA(CProjectView)
	enum { IDD = IDD_ProjectForm };
	CTreeCtrl	m_ctcDriver;
	//}}AFX_DATA
	CProjectRecord* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProjectView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CProjectView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

    //  Messages generated by tree view nodes derived from CProjectNode
    afx_msg void    OnExpandBranch();
    afx_msg void    OnCollapseBranch();
    afx_msg void    OnRenameItem();
    afx_msg void    OnOpenItem();
    //afx_msg void    OnGenerateItem();
    afx_msg void    OnImport();
    afx_msg void    OnDeleteItem();
    afx_msg void    OnCopyItem();
    afx_msg void    OnChangeID();
    afx_msg void    OnCheckWorkspace();

// Generated message map functions
protected:
	//{{AFX_MSG(CProjectView)
	afx_msg void OnBeginlabeleditDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDblclkDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFileParse();
	afx_msg void OnKeydownDriverView(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSize(UINT ntype, int cx, int cy) ;
	afx_msg void OnFileInf();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in Project View.cpp
inline CProjectRecord* CProjectView::GetDocument()
   { return (CProjectRecord*)m_pDocument; }
#endif
/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog

class CCopyItem : public CDialog
{
// Construction
public:
	CCopyItem(CWnd* pParent = NULL);   // standard constructor
	void Init(CString cssrcfile);

// Dialog Data
	//{{AFX_DATA(CCopyItem)
	enum { IDD = IDD_CopyItem };
	CString	m_csCopyName;
	CString	m_csCopyPrompt;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCopyItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCopyItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CChangeID dialog

class CChangeID : public CDialog
{
// Construction
public:
	void Init(CString csrestype, CString csname, int ncurid);
	CChangeID(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CChangeID)
	enum { IDD = IDD_ChangeID };
	CString	m_csResourceLabel;
	CString	m_csResourceName;
	int		m_nCurResID;
	int		m_nNewResID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangeID)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CChangeID)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDeleteQuery dialog

class CDeleteQuery : public CDialog {
// Construction
public:
	CDeleteQuery(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteQuery)
	enum { IDD = IDD_DeleteQuery };
	CString	m_csTarget;
	BOOL	m_bRemoveFile;
	//}}AFX_DATA

    void    Init(CString csrestype, CString csname) ;
    BOOL    KillFile() const { return m_bRemoveFile; }
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteQuery)
	afx_msg void OnNo();
	afx_msg void OnYes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\prtdlg.h ===
#if !defined(AFX_PRTDLG_H__E2A3A53B_A5AE_46A8_8822_E5B8D9B2FD97__INCLUDED_)
#define AFX_PRTDLG_H__E2A3A53B_A5AE_46A8_8822_E5B8D9B2FD97__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PrtDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPrtDlg dialog


class CPrtDlg : public CDialog
{
// Construction
public:
	CPrtDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPrtDlg)
	enum { IDD = IDD_FILE_PRINT };
	CComboBox	m_ccbPrtList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPrtDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPrtDlg)
	afx_msg void OnPrintSetup();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PRTDLG_H__E2A3A53B_A5AE_46A8_8822_E5B8D9B2FD97__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	MiniDev.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\rcfile.cpp ===
/******************************************************************************

  Source File:  Driver Resources.CPP

  This implements the driver resource class, which tracks the resources in the
  driver.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-08-1997    Bob_Kjelgaard@Prodigy.Net   Created it
													
******************************************************************************/

#include    "StdAfx.h"
#include	<gpdparse.h>
#include    "MiniDev.H"
#include    "Resource.H"
#include	"WSCheck.h"
#include    "ProjRec.H"


//  First, we're going to implement the CStringTable class

IMPLEMENT_SERIAL(CStringTable, CObject, 0)

CString CStringTable::operator[](WORD wKey) const {

    for (unsigned u = 0; u < Count(); u++)
        if  (wKey == m_cuaKeys[u])
            break;

    return  u < Count() ? m_csaValues[u] : m_csEmpty;
}

void    CStringTable::Map(WORD wKey, CString csValue) {
    if  (!wKey || csValue.IsEmpty()) return;

    if  (!Count() || wKey > m_cuaKeys[-1 + Count()]) {
        m_cuaKeys.Add(wKey);
        m_csaValues.Add(csValue);
        return;
    }

    for (unsigned u = 0; u < Count(); u++)
        if  (m_cuaKeys[u] >= wKey)
            break;

    if  (m_cuaKeys[u] != wKey){
        m_cuaKeys.InsertAt(u, wKey);
        m_csaValues.InsertAt(u, csValue);
    }
    else
        m_csaValues.SetAt(u, csValue);
}



void    CStringTable::Remove(WORD wKey) {

    for (unsigned u = 0; u < Count(); u++)
        if  (wKey >= m_cuaKeys[u])
            break;

    if  (u == Count() || wKey != m_cuaKeys[u])
        return;
    m_csaValues.RemoveAt(u);
    m_cuaKeys.RemoveAt(u);
}

void    CStringTable::Details(unsigned u, WORD &wKey, CString &csValue) {
    if  (u > Count()) u = 0;
    wKey = (WORD)m_cuaKeys[u];

    csValue = operator[](wKey);
}

void    CStringTable::Serialize(CArchive& car)
{
	// First, call the base class' serialization routine.
	
    CObject::Serialize(car);

	// CUIntArray is not serializable so the keys array's size and values have
	// to be saved/restored manually.  This is only done when the MDW should
	// contain (save) or does contain (restore) this information.

	int n = 0 ;
	int ncnt = (int)m_cuaKeys.GetSize() ;
	CProjectRecord* cpr = (CProjectRecord *) car.m_pDocument ;
	if (cpr->GetMDWVersion() > MDW_DEFAULT_VERSION) {
		if (car.IsStoring()) {
			car << ncnt ;
			for (n ; n < ncnt ; n++)
				car << m_cuaKeys[n] ;
		} else {
			car >> ncnt ;
			m_cuaKeys.SetSize(ncnt) ;
			int nvalue ;
			for (n ; n < ncnt ; n++) {
				car >> nvalue ;
				m_cuaKeys[n] = nvalue ;
			} ;
		} ;
	} ;

    // Now save/restore the values array.

    m_csaValues.Serialize(car);
}


void CStringTable::InitRefFlags()
{
	// Initialize the number of elements in the array to the number of strings
	// in the table.

	unsigned ucount = Count() ;
	m_cuaRefFlags.SetSize(ucount) ;

	// Clear all of the flags

	for (unsigned u = 0 ; u < ucount ; u++)
		ClearRefFlag(u) ;
}


IMPLEMENT_SERIAL(CDriverResources, CBasicNode, 0)

void    CDriverResources::Serialize(CArchive& car)
{
	CBasicNode::Serialize(car);

    m_csaIncludes.Serialize(car);
    m_csoaFonts.Serialize(car);
    m_csaTables.Serialize(car);
    m_csoaAtlas.Serialize(car);
    m_csaDefineNames.Serialize(car);
    m_csaDefineValues.Serialize(car);
    m_cst.Serialize(car);
    m_csaRemnants.Serialize(car);
    m_csoaModels.Serialize(car);

	// There are no paths for driver files in the MDW file when the MDW version
	// is at least MDW_VER_NO_FILE_PATHS.  Build and set the paths in this case.

	unsigned uver = ((CProjectRecord*) car.m_pDocument)->GetMDWVersion() ;
	if (uver < MDW_VER_YES_FILE_PATHS) {	// raid 123448
		CString csw2kpath = ((CProjectRecord*) car.m_pDocument)->GetW2000Path() ;
		unsigned unumobjs, u ;
		CString  cspath ;

		// Set the GPD file paths.

		cspath = csw2kpath + _T('\\') ;
		for (unumobjs = Models(), u = 0 ; u < unumobjs ; u++)
			Model(u).SetPath(cspath) ;

		// Set the UFM file paths.

		cspath.LoadString(IDS_FontDir) ;
		cspath = csw2kpath + _T('\\') + cspath ;
		for (unumobjs = FontCount(), u = 0 ; u < unumobjs ; u++)
			Font(u).SetPath(cspath) ;

		// Set the GTT file paths.

		cspath.LoadString(IDS_GTTDir) ;
		cspath = csw2kpath + _T('\\') + cspath ;
		for (unumobjs = MapCount(), u = 0 ; u < unumobjs ; u++)
			GlyphTable(u).SetPath(cspath) ;
	} ;
}


/******************************************************************************

  CDriverResources::CheckTable(int iWhere, CString csLine,
    CStringTable& cstTarget)

  Internal work routine- this looks at a line, and some parameters, decides
  whether to work on it or not, and if it does, validates the resource number
  and adds the file name and resource number to its list.

  This override is needed because the resource IDs for translation tables have
  not heretofore been a compact set.

******************************************************************************/

UINT    CDriverResources::CheckTable(int iWhere, CString csLine,
                                     CStringTable& cstTarget) {
    if  (iWhere == -1)
        return  ItWasIrrelevant;

    //  See if the ID is valid or not.  It must be an integer > 0

    int iKey = atoi(csLine);

    if  (iKey < 0 || iKey > 0x7FFF) //  Valid range for resource IDs in Win16
        LogConvInfo(IDS_ORangeRCID, 1, &csLine) ;
        //return  ItFailed;

	// Find the filespec at the end of the line.  Fail if there is no filespec.

    for (int i = -1 + csLine.GetLength(); i; i--) {
        if  (csLine[i] == _TEXT(' ') || csLine[i] == _TEXT('\t'))
            break;
    }
    if  (!i)  {
        LogConvInfo(IDS_NoFSpecInRCLine, 1, &csLine) ;
        return  ItWorked;		// Cause the line to be skipped.
        //return  ItFailed;
	} ;

    cstTarget.Map((WORD) iKey, csLine.Mid(++i));

    return  ItWorked;
}

/******************************************************************************

  CDriverResources::CheckTable(int iWhere, CString csLine,
    CStringArray& csaTarget)

  Internal work routine- this looks at a line, and some parameters, decides
  whether to work on it or not, and if it does, validates the resource number
  and adds the file name to its list.

******************************************************************************/

UINT    CDriverResources::CheckTable(int iWhere, CString csLine,
                                     CStringArray& csaTarget,
                                     BOOL bSansExtension) {
    if  (iWhere == -1)
        return  ItWasIrrelevant;

    //  See if the name is valid or not

    if  (atoi(csLine) != 1 +csaTarget.GetSize())
        LogConvInfo(IDS_DupInvRCID, 1, &csLine) ;
        //return  ItFailed;

	// Find the filespec at the end of the line.  Fail if there is no filespec.

    for (int i = -1 + csLine.GetLength(); i; i--) {
        if  (csLine[i] == _TEXT(' ') || csLine[i] == _TEXT('\t'))
            break;
    }
    if  (!i)  {
        LogConvInfo(IDS_NoFSpecInRCLine, 1, &csLine) ;
        return  ItWorked;		// Cause the line to be skipped.
        //return  ItFailed;
	} ;

    if  (!bSansExtension) {
        //  Don't bother to strip the extension
        csaTarget.Add(csLine.Mid(++i));
        return  ItWorked;
    }

    //  Strip everything after the last period.

    CString csName = csLine.Mid(++i);

    if  (csName.ReverseFind(_T('.')) > csName.ReverseFind(_T('\\')))
        csName = csName.Left(csName.ReverseFind(_T('.')));

    csaTarget.Add(csName);

    return  ItWorked;
}

//  Private work member.  This parses a line from a string table to extract
//  the value and the string itself.

BOOL    CDriverResources::AddStringEntry(CString csLine,
										 CStringTable& cstrcstrings)
{
    WORD    wKey = (WORD) atoi(csLine);

    if  (!wKey)
        return  FALSE;  //  0 is not a valid resource number...

    csLine = csLine.Mid(csLine.Find("\""));
    csLine = csLine.Mid(1, -2 + csLine.GetLength());

    cstrcstrings.Map(wKey, csLine);

    return  TRUE;
}

//  Constructor- would be trivial, except we need to initialize some of the
//  fancier UI objects

CDriverResources::CDriverResources() :
	m_cfnAtlas(IDS_Atlas, m_csoaAtlas, FNT_GTTS, GlyphMapDocTemplate(),
        RUNTIME_CLASS(CGlyphMap)),
    m_cfnFonts(IDS_FontList, m_csoaFonts, FNT_UFMS, FontTemplate(),
        RUNTIME_CLASS(CFontInfo)),
    m_cfnModels(IDS_Models, m_csoaModels, FNT_GPDS, GPDTemplate(),
        RUNTIME_CLASS(CModelData)),
	m_cfnResources(IDS_Resources, m_csoaResources, FNT_RESOURCES),
	m_csnStrings(IDS_Strings, m_csoaStrings, FNT_STRINGS, StringEditorTemplate(),
		RUNTIME_CLASS(CStringsNode))
{
	// Set the context sensitive menus for the workspace, resources, UFMs, GTTs,
	// GPDs, and Strings nodes.

	m_cwaMenuID.Add(ID_OpenItem);
    m_csnStrings.SetMenu(m_cwaMenuID);
	m_cwaMenuID.SetAt(0, ID_ExpandBranch);
    m_cwaMenuID.Add(ID_CollapseBranch);
    m_cfnResources.SetMenu(m_cwaMenuID);
    m_cwaMenuID.InsertAt(0, 0, 1);
    m_cwaMenuID.InsertAt(0, ID_Import);
	m_cfnAtlas.SetMenu(m_cwaMenuID);
    m_cfnFonts.SetMenu(m_cwaMenuID);
    m_cfnModels.SetMenu(m_cwaMenuID);
    m_cwaMenuID.SetAt(0, ID_RenameItem);
    m_cwaMenuID.InsertAt(0, ID_CheckWS);

	m_ucSynthesized = 0;

	m_pcsfLogFile = NULL;
	m_bErrorsLogged = false;

	m_pwscdCheckDoc = NULL ;
	m_pcmcwCheckFrame = NULL ;
	m_bFirstCheckMsg = true ;
}


CDriverResources::~CDriverResources()
{
	// Make sure that if there is a log file, it gets closed.

	CloseConvLogFile() ;
}


//  Member function for returning a GPC file name.  These come ready for
//  concatenation, so they are preceded by '\'

CString CDriverResources::GPCName(unsigned u) {
    CString csReturn('\\');

    csReturn += m_csaTables[u] + _TEXT(".GPC");

    return  csReturn;
}


/******************************************************************************

  CDriverResources::ReportFileFailure

  This is a private routine- it loads a string table resource with an error
  message, formats it using the given file name, displays a message box,
  then returns FALSE.

******************************************************************************/

BOOL CDriverResources::ReportFileFailure(int idMessage,
												LPCTSTR lpstrFile)
{
    CString csfile(lpstrFile) ;
	LogConvInfo(idMessage, 1, &csfile) ;
    return FALSE ;
}


/******************************************************************************

  CDriverResources::OpenConvLogFile

  This function allocates an instance of CFile to manage the conversion log
  file and opens the log file.

******************************************************************************/

bool CDriverResources::OpenConvLogFile(CString cssourcefile)
{
	// Return "failure" if CFile instance cannot be allocated.

	if ((m_pcsfLogFile = new CStdioFile) == NULL)
		return false ;

	// Build the log file name from the input source file name.

	m_csConvLogFile = cssourcefile ;
	int npos ;
	if ((npos = m_csConvLogFile.Find(_T('.'))) >= 0)
		m_csConvLogFile = m_csConvLogFile.Left(npos) ;
	m_csConvLogFile += _T(".LOG") ;

	// Open the log file

    if (!m_pcsfLogFile->Open(m_csConvLogFile, CFile::modeCreate | CFile::modeWrite |
        CFile::shareExclusive)) {
		CloseConvLogFile() ;
		return  false ;
	} ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CDriverResources::CloseConvLogFile

  This function closes the conversion log file and deletes the instance of
  CFile used to manage the log file.

******************************************************************************/

void CDriverResources::CloseConvLogFile(void)
{
	// Do nothing if the pointer is null.

	if (m_pcsfLogFile == NULL)
		return ;

	// Close the file if it is open

	if (m_pcsfLogFile->m_pStream != NULL)
		m_pcsfLogFile->Close() ;

	delete m_pcsfLogFile ;
	m_pcsfLogFile = NULL ;
}


/******************************************************************************

  CDriverResources::LogConvInfo

  Assuming the log file is ready to use, build and write a message to the
  conversion log file.

******************************************************************************/

void CDriverResources::LogConvInfo(int nmsgid, int numargs, CString* pcsarg1,
								   int narg2)
{
	CString		csmsg ;			// Log message is loaded/built here

	// Do nothing if the log file pointer is null or the file handle is
	// uninitialized.

	if (m_pcsfLogFile == NULL || m_pcsfLogFile->m_pStream == NULL)
		return ;

	// Load and/or build the message based on the number of arguments

	switch (numargs) {
		case 0:
			csmsg.LoadString(nmsgid) ;
			break ;
		case 1:
			csmsg.Format(nmsgid, *pcsarg1) ;
			break ;
		case 2:
			csmsg.Format(nmsgid, *pcsarg1, narg2) ;
			break ;
		default:
			return ;
	} ;

	// Write the message and indicate that a message has been written

	try {
		m_pcsfLogFile->WriteString(csmsg) ;
	}
    catch (CException *pce) {
        pce->ReportError() ;
        pce->Delete() ;
        return ;
    }
	m_bErrorsLogged = true ;
}


/******************************************************************************

  CDriverResources::Load

  This function loads and reads the RC file for the driver, and determines all
  of the needed resources.  It initializes the structures used to fetermine the
  glyph map file set, font file set, etc.

******************************************************************************/

BOOL    CDriverResources::Load(class CProjectRecord& cprOwner)
{
    CWaitCursor     cwc;    //  Just in case this takes a while...
    NoteOwner(cprOwner);

	// Load the RC file and save its data into data specific arrays.

    CStringTable    cstFonts;    //  Names First!
    CStringTable    cstMaps;
    if  (!LoadRCFile(cprOwner.SourceFile(), m_csaDefineNames, m_csaDefineValues,
					 m_csaIncludes, m_csaRemnants, m_csaTables, m_cst, cstFonts,
					 cstMaps, NotW2000))
        return  FALSE ;

	// The string table with font info in it needs to be copied into a string
	// array for further processing.

	CStringArray csaFonts ;
	int numelts = cstFonts.Count() ;
    WORD wKey ;
	csaFonts.SetSize(numelts) ;
	for (int n = 0 ; n < numelts ; n++)
		cstFonts.Details(n, wKey, csaFonts[n]) ;

    //  RAID 103242- people can load totally bogus files.  Die now if there is
    //  no GPC data as a result of this.

    if  (!m_csaTables.GetSize()) {
        AfxMessageBox(IDS_NoGPCData);
        return  FALSE;
    }

    //  End 103242

    if  (m_csaTables.GetSize() == 1)
        m_csaTables.Add(_TEXT("NT"));   //  Usually necessary.

    //  Now, let's name the translation tables- we wil load them later...
	//  Note: Different rules are used for naming the node and the file.

	CString cstmp ;
	int		npos ;
    for (unsigned u = 0; u < cstMaps.Count(); u++) {
        CString csName;
        m_csoaAtlas.Add(new CGlyphMap);
        cstMaps.Details(u, wKey, csName);
		if (csName[0] == _T('\\'))
			GlyphTable(u).SetSourceName(cprOwner.TargetPath(Win95) + csName) ;
		else
			GlyphTable(u).SetSourceName(cprOwner.TargetPath(Win95) + _T('\\') +
				csName) ;
        //if  (!GlyphTable(u).SetFileName(cprOwner.TargetPath(Win2000) +
        //    _T("\\GTT\\") + GlyphTable(u).Name()))
		if ((npos = csName.ReverseFind(_T('\\'))) >= 0)
			cstmp = csName.Mid(npos + 1) ;
		else
			cstmp = csName ;
		cstmp = cprOwner.TargetPath(Win2000) + _T("\\GTT\\") + cstmp ;
        if  (!GlyphTable(u).SetFileName(cstmp))	{
			LogConvInfo(IDS_GTTSetName, 1, &cstmp) ;
            return  FALSE;
		};
        GlyphTable(u).nSetRCID((int) wKey);
    }

    //  Now, cycle it again, but this time, make sure all of the root file
    //  names and display names are unique.

    for (u = 1; u < MapCount(); u++) {
        for (unsigned uCompare = 0; uCompare < u; uCompare++) {

			// If a matching file title is found, make it unique.

            if  (!GlyphTable(uCompare).FileTitle().CompareNoCase(
             GlyphTable(u).FileTitle())) {
				GlyphTable(u).m_cfn.UniqueName(true, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
				continue ;
            } ;

			// If a matching display name is found, make it unique.

            if  (!GlyphTable(uCompare).Name().CompareNoCase(
             GlyphTable(u).Name())) {
				GlyphTable(u).UniqueName(false, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
            } ;
		} ;
	} ;

    //  Now, let's name the fonts - we wil load them later...
	//  Note: Different rules are used for naming the node and the file.

    for (u = 0; u < (unsigned) csaFonts.GetSize(); u++) {
        m_csoaFonts.Add(new CFontInfo);
		cstmp = csaFonts[u] ;
		if (cstmp.GetAt(0) == _T('\\'))
			Font(u).SetSourceName(cprOwner.TargetPath(Win95) + cstmp) ;
		else
			Font(u).SetSourceName(cprOwner.TargetPath(Win95) + _T('\\') +
				cstmp) ;
        Font(u).SetUniqueName(m_csName);
		if ((npos = cstmp.ReverseFind(_T('\\'))) >= 0)
			cstmp = cstmp.Mid(npos + 1) ;
		cstmp = cprOwner.TargetPath(Win2000) + _T("\\UFM\\") + cstmp ;
        if  (!Font(u).SetFileName(cstmp)) {
			LogConvInfo(IDS_UFMSetName, 1, &cstmp) ;
            return  FALSE;
		};
    }

    //  Now, cycle it again, but this time, make sure all of the root file
    //  names and display names are unique.

    for (u = 1; u < FontCount(); u++) {
        for (unsigned uCompare = 0; uCompare < u; uCompare++) {

			// If a matching file title is found, make it unique.

            if  (!Font(uCompare).FileTitle().CompareNoCase(
             Font(u).FileTitle())) {
				Font(u).m_cfn.UniqueName(true, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
				continue ;
            } ;

			// If a matching display name is found, make it unique.

            if  (!Font(uCompare).Name().CompareNoCase(
             Font(u).Name())) {
				Font(u).UniqueName(false, false) ;
                uCompare = (unsigned) -1;   //  Check the names again
            } ;
		} ;
	} ;

    //  Attempt to load the GPC data if there is any.  Then begin the
	//  process of splitting GPCs that manage multiple models into multiple
	//  GPDs.

    CFile               cfGPC;

    if  (!cfGPC.Open(cprOwner.TargetPath(Win95) + GPCName(0),
        CFile::modeRead | CFile::shareDenyWrite) || !m_comdd.Load(cfGPC))
        return  ReportFileFailure(IDS_FileOpenError,
            cprOwner.TargetPath(Win95) + GPCName(0));
	if (!m_comdd.SplitMultiGPCs(m_cst))
        return  ReportFileFailure(IDS_FileOpenError,
            cprOwner.TargetPath(Win95) + GPCName(0));

	n = m_cst.Count() ;

    return  TRUE;
}


/******************************************************************************

  CDriverResources::LoadRCFile

  This function loads and reads the RC file for the driver, and determines all
  of the needed resources.  The data is loaded into the arguments.

  Args:
	csrcfpec				The RC filespec for the file to load
	csadefinenames     Definition names
	csadefinevalues		Definition values
	csaincludes				Include statement filespecs
	csaremnants         RC statements that don't fall into other categories
	csatables           GPC info
	cstrcstrings        String table strings
	cstfonts            Font (UFM/PFM) info
	cstmaps				Map (CTT/GTT) info
	ufrctype			Win2000 iff parsing Win2K RC file.  Otherwise, NotW2000.

  Returns true if the file is successfully loaded.  Otherwise, false.

******************************************************************************/

bool CDriverResources::LoadRCFile(CString& csrcfpec,
								  CStringArray& csadefinenames,
								  CStringArray& csadefinevalues,
								  CStringArray& csaincludes,
								  CStringArray& csaremnants,
								  CStringArray& csatables,
								  CStringTable& cstrcstrings,
								  CStringTable& cstfonts,
								  CStringTable& cstmaps,
								  UINT ufrctype)
{
	// Read the RC file

    CStringArray    csacontents ;
    while (!LoadFile(csrcfpec, csacontents)){		// Raid 3176
		CString cstmp;int iRet;	
		cstmp.LoadString(IDS_NotFoundRC);
		if ( (iRet = AfxMessageBox(cstmp,MB_YESNO) ) == IDYES) {
			CFileDialog cfd(TRUE);   
			if(IDCANCEL == cfd.DoModal())
				return false;
			csrcfpec = cfd.GetPathName();
			continue;
		}
		else 
			return false ;
	}
    //  Clean everything up, in case we were previously loaded...

    csadefinenames.RemoveAll();
    csadefinevalues.RemoveAll();
    csaincludes.RemoveAll();
    csaremnants.RemoveAll();
    csatables.RemoveAll();
    cstrcstrings.Reset();
    cstfonts.Reset();
    cstmaps.Reset();

	// Declare and load the Map and Font table keyword variables

	CString	csfontlabel, cstranslabel ;
    if  (ufrctype == Win2000) {
        csfontlabel = _T("RC_UFM");
        cstranslabel = _T("RC_GTT");
    } else {
        csfontlabel = _T("RC_FONT");
        cstranslabel = _T("RC_TRANSTAB");
    } ;

    //  Let the parsing begin
    //  03-14-1997  We can't assume sequential numbering of the table resources

    BOOL    bLookingForBegin=false, bLookingForEnd=false, bInComment=false ;
	CString cscurline, cshold ;
	int nloc, nloc2 ;
	bool blastlinewasremnant = false ;
    while (csacontents.GetSize()) {

		// Get the next line to process.  Usually this is the next line in the
		// contents array.  Occassionally, a line held for later processing
		// should be used.

		if (cshold.IsEmpty()) {
			cscurline = csacontents[0] ;
			csacontents.RemoveAt(0) ;		// *** csacontents updated here
		} else {
			cscurline = cshold ;
			cshold.Empty() ;
		} ;


        // Add multiline comments to the remnants array.  If the comment is
		// continuing, just add the line and continue.  If this is the last line
		// of the comment, check to see if there is anything after the ending
		// comment characters.  If there is, save everything up to and including
		// the comment chars and then set up to process the rest of the line.

        if  (bInComment) {
			blastlinewasremnant = true ;
            if ((nloc = cscurline.Find(_TEXT("*/"))) >= 0) {
				bInComment = false ;
		        cscurline.TrimRight();
				if (nloc + 2 < cscurline.GetLength()) {
					csaremnants.Add(cscurline.Left(nloc + 2)) ;
					cscurline = cscurline.Mid(nloc + 2) ;
				} else {
					csaremnants.Add(cscurline) ;
		            continue ;
				} ;

			// Add the comment line to the remnants array.
				
			} else {
				csaremnants.Add(cscurline) ;
				continue ;
			} ;
		} ;

        // Remove partial line comments

        if  ((nloc = cscurline.Find(_TEXT("//"))) != -1)
            cscurline = cscurline.Left(nloc) ;

        // Handle the other style of comments.
		
        while   (-1 != (nloc = cscurline.Find(_TEXT("/*")))) {

			// Remove all partial line comments.

            if  ((nloc2 = cscurline.Find(_TEXT("*/"))) > nloc)
                cscurline = cscurline.Left(nloc) + cscurline.Mid(nloc2 + 2) ;

			// If this is the beginning of a multiline comment that starts at
			// the beginning of the line, set the comments flag and continue
			// processing.  It will be saved later.

			else if (nloc == 0) {
                bInComment = true ;
				break ;

			// If this is the beginning of a multiline comment that does NOT
			// start at the beginning of the line, save the comment for latter
			// processing and set up to continue processing the beginning of
			// the line.

			} else {
                cshold = cscurline.Mid(nloc + 1) ;
                cscurline = cscurline.Left(nloc) ;
            } ;
        } ;

        //  Now for the leading blanks and trailing blanks

        cscurline.TrimLeft();
        cscurline.TrimRight();

		// Handle blank lines.  If the previous line was a nonblank, remnant
		// line, add the blank line to the remnants array.  Always contine;
		// ie go get the next line.

        if  (cscurline.IsEmpty()) {
			if (blastlinewasremnant) {
				csaremnants.Add(cscurline) ;
				blastlinewasremnant = false ;
			} ;
            continue ;
		} ;
		blastlinewasremnant = false ;

        //  If we are processing a string table, press onward...

        if  (bLookingForBegin) {
            if  (cscurline.CompareNoCase(_TEXT("BEGIN")))
                return  false;  //  Parsing failure
            bLookingForBegin = false;
            bLookingForEnd = true;
            continue;
        }

        if  (bLookingForEnd) {
            if  (!cscurline.CompareNoCase(_TEXT("END"))) {
                bLookingForEnd = false;
                continue;
            }

            if  (!AddStringEntry(cscurline, cstrcstrings))
                return  false;  //  Parsing error

            continue;
        }

        //  If it is an include, add it to the list

        if  (cscurline.Find(_TEXT("#include")) != -1) {
            cscurline =
                cscurline.Mid(cscurline.Find(_TEXT("#include")) + 8);
            cscurline.TrimLeft();
            csaincludes.Add(cscurline);
            continue;
        }

        //  If it is a #define, do the same

        if  (cscurline.Find(_TEXT("#define")) != -1) {
            cscurline =
                cscurline.Mid(cscurline.Find(_TEXT("#define")) + 7);
            cscurline.TrimLeft();
            //  TODO:   Handle macros with parameters
            csadefinenames.Add(cscurline.SpanExcluding(_TEXT(" \t")));
            cscurline =
                cscurline.Mid(
                    csadefinenames[-1 + csadefinenames.GetSize()].
                    GetLength());
            cscurline.TrimLeft();
            csadefinevalues.Add(cscurline);
            continue;
        }

        //  GPC Tables, fonts, Glyph Tables
        switch  (CheckTable(cscurline.Find(_TEXT("RC_TABLES")),
                    cscurline, csatables)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  false;  //  Parsing error
        }

        switch  (CheckTable(cscurline.Find(csfontlabel),
                    cscurline, cstfonts)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  false;  //  Parsing error
        }

        switch  (CheckTable(cscurline.Find(cstranslabel),
                    cscurline, cstmaps)) {
            case    ItWorked:
                continue;
            case    ItFailed:
                return  false;  //  Parsing error
        }

        //  String table...

        if  (cscurline.CompareNoCase(_TEXT("STRINGTABLE"))) {
            csaremnants.Add(cscurline) ;
			blastlinewasremnant = true ;
        } else
            bLookingForBegin = true ;
    }

	//unsigned u, unuments ;
	//for (u = 0, unuments = csaremnants.GetSize() ; u < unuments ; u++)
	//	TRACE("Remnants[%d] = '%s' (%d)\n", u, csaremnants[u], unuments) ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CDriverResource::LoadFontData

  This member function loads the CTT files from the Win 3.1 mini-driver to
  initialize the glyph table array.  It is a separate function because the
  Wizard must first verify the code page selection for each of the tables
  with the user.

******************************************************************************/

BOOL    CDriverResources::LoadFontData(CProjectRecord& cprOwner) {

    CWaitCursor cwc;
	int			nerrorid ;

	// Conversion of drivers that have CTTs **>AND<** are using a Far East 
	// default code page are not support.  Complain and stop the conversion
	// when this situation is detected.

	if (MapCount() > 0 && ((int) cprOwner.GetDefaultCodePage()) < 0) {
		LogConvInfo(IDS_CTTFarEastCPError, 0) ;
		return FALSE ;
	} ;

    //  Now, let's load the translation tables.

    for (unsigned u = 0; u < MapCount(); u++) {
		GlyphTable(u).NoteOwner(cprOwner) ;

        //  Load the file..
        if  ((nerrorid = GlyphTable(u).ConvertCTT()) != 0) {
			CString cstmp ;
			cstmp = GlyphTable(u).SourceName() ;
            return  ReportFileFailure(IDS_LoadFailure, cstmp) ;
		} ;
	} ;

    //  Now, let's load the Font Data.

    for (u = 0; u < FontCount() - m_ucSynthesized; u++) {

        //  Load the file..  (side effect of GetTranslation)

        //if  ((nerrorid = Font(u).GetTranslation(this)) != 0) {
        if  ((nerrorid = Font(u).GetTranslation(m_csoaAtlas)) != 0) {
			CString cstmp ;
			cstmp = Font(u).SourceName() ;
			LogConvInfo(abs(nerrorid), 1, &cstmp) ;
			if (nerrorid < 0)
				return  ReportFileFailure(IDS_LoadFailure, cstmp);
		} ;

        //  Generate the CTT/PFM mapping so we generate UFMs correctly

        if  (!Font(u).Translation()) {
            /*
                For each model, check and see if this font is in its map.
                If it is, then add the CTT to the list used, and the model,
                as well.

            */

            CMapWordToDWord cmw2dCTT;   //  Used to count models per ID
            CWordArray      cwaModel;   //  Models which used this font
            DWORD           dwIgnore;

            for (unsigned uModel = 0; uModel < m_comdd.ModelCount(); uModel++)
                if  (m_comdd.FontMap(uModel).Lookup(u + 1, dwIgnore)) {
                    //  This model needs to be remembered, along with the CTT
                    cmw2dCTT[m_comdd.DefaultCTT(uModel)]++;
                    cwaModel.Add((WORD)uModel);
                }

            if  (!cmw2dCTT.Count()) {
				CString cstmp ;
				cstmp = Font(u).SourceName() ;
				LogConvInfo(IDS_UnusedFont, 1, &cstmp) ;
                continue;
            }

            if  (cmw2dCTT.Count() == 1) {
                //  Only one CTT ID was actually used.
                Font(u).SetTranslation(m_comdd.DefaultCTT(cwaModel[0]));	
                continue;   //  We're done with this one
            }

            /*

                OK, this font has multiple CTTs in different models.  Each
                will require a new UFM to be created.  The IDs of the new UFMs
                need to be added to the set, the new defaults established, and
                a list of the font ID remapping needed for each model all need
                maintenance.

            */

            unsigned uGreatest = 0;

            for (POSITION pos = cmw2dCTT.GetStartPosition(); pos; ) {
                WORD    widCTT;
                DWORD   dwcUses;

                cmw2dCTT.GetNextAssoc(pos, widCTT, dwcUses);
                if  (dwcUses > uGreatest) {
                    uGreatest = dwcUses;
                    Font(u).SetTranslation(widCTT);
                }
            }

            //  The models that used the most common CTT will be dropped from
            //  the list

            for (uModel = (unsigned) cwaModel.GetSize(); uModel--; )
                if  (m_comdd.DefaultCTT(cwaModel[uModel]) == Font(u).Translation())
                    cwaModel.RemoveAt(uModel);

            //  Now, we create a new UFM for each CTT ID, and add the new index to
            //  the mapping required for the each affected model.

            m_ucSynthesized += cmw2dCTT.Count() - 1;

            for (pos = cmw2dCTT.GetStartPosition(); pos; ) {

                WORD    widCTT;	
                DWORD   dwcUses;

                cmw2dCTT.GetNextAssoc(pos, widCTT, dwcUses);

                if  (widCTT == Font(u).Translation())
                    continue;   //  This one has already been done.

				// Add a new font and make sure its file name is unique

                int nnewpos = m_csoaFonts.Add(new CFontInfo(Font(u), widCTT));
				for (unsigned ucomp = 0 ; ucomp < FontCount() ; ucomp++) {
					if ((unsigned) nnewpos == ucomp)
						continue ;

					// If a matching file title is found, try to make it unique
					// and restart the checking.

					if  (!Font(nnewpos).FileTitle().CompareNoCase(Font(ucomp).FileTitle())) {
						Font(nnewpos).m_cfn.UniqueName(true, true, Font(nnewpos).m_cfn.Path()) ;
						ucomp = (unsigned) -1 ;
					} ;
				} ;

                for (uModel = (unsigned) cwaModel.GetSize(); uModel--; )
                    if  (m_comdd.DefaultCTT(cwaModel[uModel]) == widCTT) {
                        m_comdd.NoteTranslation(cwaModel[uModel], u + 1,
                            FontCount());
                        cwaModel.RemoveAt(uModel);
                    }
            }

        }
    }

	// Change the GTT ID in each CGlyphMap instance.  Currently, these IDs are
	// set to whatever was used in the old RC file.  The new RC file may
	// renumber the GTTs so the IDs in CGlyphMap instances should match what
	// will be in the RC file.  When the RC file is written, the GTTs are
	// number consecutively starting at 1.  (Don't change IDs that are <= 0.)

    for (u = 0 ; u < MapCount(); u++)
		if  (GlyphTable(u).nGetRCID() > 0)	
			GlyphTable(u).nSetRCID((int) (u + 1)) ;

    // Point each font at its associated GTT file, if there is one.

    for (u = 0 ; u < FontCount(); u++)
        for (unsigned uGTT = 0; uGTT < MapCount(); uGTT++)
            if  (Font(u).Translation() == ((WORD) GlyphTable(uGTT).nGetRCID()))
                Font(u).SetTranslation(&GlyphTable(uGTT));

    Changed();

    return  TRUE;
}

/******************************************************************************

  CDriverResources::ConvertGPCData

  This will handle the conversion of the GPC data to GPD format.  It has to be
  done after the framework (especially the target directory) is created.

******************************************************************************/

BOOL    CDriverResources::ConvertGPCData(CProjectRecord& cprOwner,
                                         WORD wfGPDConvert)
{
    //  We've already loaded the GPC data, so now we just generate the files.

	unsigned umidx = -1 ;		// Used to index Model
	unsigned ugpcidx = 0 ;		// Used to indext GPC info
	int nsc ;					// Each entries split code

    for (unsigned u = 0 ; u < m_comdd.ModelCount(); u++) {
        CString csModel = m_csaModelFileNames[u] ;

		// Skip this GPD if it was not selected by the user; ie, it does not
		// have a file name.
		//
		// Before the GPD can be skipped, the GPC info index may need to be
		// incremented.  See below for a description of when this is done.

		if (csModel.IsEmpty()) {
			nsc = m_comdd.GetSplitCode(u) ;
			if (nsc == COldMiniDriverData::NoSplit)
				ugpcidx++ ;
			else if ((u + 1) < m_comdd.ModelCount()
			 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::NoSplit)
				ugpcidx++ ;
			else if	((u + 1) < m_comdd.ModelCount()
			 && nsc == COldMiniDriverData::OtherSplit
			 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::FirstSplit)
				ugpcidx++ ;

			continue ;
		} ;

		// Add a new model node and increment the index used to reference them.

        m_csoaModels.Add(new CModelData) ;
		umidx++ ;

		// Set the node's file name and display name.  Then load the other
		// pointers, etc needed for this node to perform correctly.

        if  (!Model(umidx).SetFileName(cprOwner.TargetPath(Win2000) + _T("\\") +
             csModel))
            return  FALSE;
        Model(umidx).NoteOwner(cprOwner);
        Model(umidx).EditorInfo(GPDTemplate());

		// Set the node's display name.  Normally, a node's display name is
		// pulled from the string table.  A separate array of names is used
		// to get the names of nodes that are based on GPC entries that
		// reference multiple models.

		if ((nsc = m_comdd.GetSplitCode(u)) == COldMiniDriverData::NoSplit)
			Model(umidx).Rename(m_cst[m_comdd.ModelName(u)]) ;
		else
			Model(umidx).Rename(m_comdd.SplitModelName(u)) ;
																			
		// Convert and save the GPD.

        //if  (!Model(umidx).Load(m_comdd.Image(), Name(), u + 1,
        if  (!Model(umidx).Load(m_comdd.Image(), Name(), ugpcidx + 1,
             m_comdd.FontMap(u), wfGPDConvert) || !Model(umidx).Store())
            return  ReportFileFailure(IDS_GPCConversionError, Model(umidx).Name());

		// Only increment the GPC index when
		//	1. The current entry does not reference multiple models
		//  2. The next entry does not reference multiple models
		//  3. The last model in the current entry is being processed
		// This is done to make sure that every model in an entry use the same
		// GPC index and that the index is kept in sync with each entry that
		// is processed.

		if (nsc == COldMiniDriverData::NoSplit)
			ugpcidx++ ;
		else if ((u + 1) < m_comdd.ModelCount()
		 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::NoSplit)
			ugpcidx++ ;
		else if	((u + 1) < m_comdd.ModelCount()
		 && nsc == COldMiniDriverData::OtherSplit
		 && m_comdd.GetSplitCode(u + 1) == COldMiniDriverData::FirstSplit)
			ugpcidx++ ;
    }

    Changed();
    return  TRUE;
}


/******************************************************************************

  CDriverResources::GetGPDModelInfo

  Load the string arrays with with the GPD model names and file names.

******************************************************************************/

BOOL    CDriverResources::GetGPDModelInfo(CStringArray* pcsamodels,
										  CStringArray* pcsafiles)
{
	// If this is the first time this routine is called, initialize
	// m_csaModelFileNames.

	unsigned unummodels = m_comdd.ModelCount() ;
	if (unummodels != (unsigned) m_csaModelFileNames.GetSize()) {
		try {
			m_csaModelFileNames.SetSize(unummodels) ;
		}
		catch(CException* pce) {	// Caller processes error
			pce -> Delete() ;
			return  FALSE ;
		} ;
	} ;

	// Size the destination arrays

	try {
		pcsamodels->SetSize(unummodels) ;
		pcsafiles->SetSize(unummodels) ;
	}
	catch(CException* pce) {		// Caller processes error
		pce -> Delete() ;
		return  FALSE ;
	} ;

	// Loop through all of the GPDs and copy the information

    for (unsigned u = 0 ; u < m_comdd.ModelCount() ; u++) {
		if (m_comdd.GetSplitCode(u) == COldMiniDriverData::NoSplit)
			pcsamodels->SetAt(u, m_cst[m_comdd.ModelName(u)]) ;
		else
			pcsamodels->SetAt(u, m_comdd.SplitModelName(u)) ;
		pcsafiles->SetAt(u, m_csaModelFileNames[u]) ;
	} ;

	// All went well so...

	return TRUE ;
}


/******************************************************************************

  CDriverResources::SaveVerGPDFNames

  Save the GPD file names that entered into the GPD Selection page of the
  Conversion Wizard.  If requested, the names will be verified, too.  Two tests
  are made.  First, the file names are checked to make sure they only contain
  valid file name characters.  Second, the file names are checked to make sure
  they are all unique.

  Return -1 if all is ok.  If an error was found, return the index of the first
  offending entry so that that entry can be highlighted on the GPD Selection
  page.

******************************************************************************/

int	CDriverResources::SaveVerGPDFNames(CStringArray& csafiles, bool bverifydata)
{
	int numelts = (int)csafiles.GetSize() ;

	// Save the GPD file names

    for (int n = 0 ; n < numelts ; n++)
		m_csaModelFileNames[n] = csafiles[n] ;
	
	// Return "all is ok" if no verification is needed.

	if (!bverifydata)
		return -1 ;

	// Complain if any of the file names contains an illegal character and
	// return the index for that file.

    for (n = 0 ; n < numelts ; n++) {
		if (m_csaModelFileNames[n].FindOneOf(_T(":<>/\\\"|")) < 0)
			continue ;
		CString csmsg ;
        csmsg.Format(IDS_BadFileChars, m_csaModelFileNames[n]) ;
        AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
		return n ;
	} ;

	// Complain if any of the file names are dups and return the index for that
	// file.

    for (n = 1 ; n < numelts ; n++) {

		// Skip this entry if it is empty.

		if (m_csaModelFileNames[n].IsEmpty())
			continue ;

		for (int m = 0 ; m < n ; m++) {

			// If these files don't match, continue checking.

			if (m_csaModelFileNames[n] != m_csaModelFileNames[m])
				continue ;

			// A duplicate was found so display an error message and return
			// its index.

			CString csmsg ;
			csmsg.Format(IDS_DupGPDFName, m, n, m_csaModelFileNames[n]) ;
			AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
			return n ;
		} ;
	} ;

	// The file names passed the tests so...

	return -1 ;
}


/******************************************************************************

  CDriverResources::GenerateGPDFileNames

  Generate a file name (sans extension) for each GPD that doesn't already have
  a file name.  This is done by taking the first two characters of the model
  name + the last 6 characters of the model name.  Then make sure that each
  name is unique.  (Note: This last phase might change one of the user's
  names.)

******************************************************************************/

void CDriverResources::GenerateGPDFileNames(CStringArray& csamodels,
											CStringArray& csafiles)
{
	CString		csfname ;		// New file name
	CString		csmodel ;		// Used to build file names
	int			npos ;			// Positions of specific chars in a string
	TCHAR	tch ;				// Unique character

	// Loop through all of the file names looking for onces that are empty

	int numelts = (int)csafiles.GetSize() ;
    for (int n = 0 ; n < numelts ; n++) {
		
		// Continue if the current file name is already set

		if (!csafiles[n].IsEmpty())
			continue ;

		// The current model has no file name so generate one from the model
		// name.  Start by making a copy of the model name and remove all bad
		// characters from it.

		csmodel = csamodels[n] ;
		while ((npos = csmodel.FindOneOf(_T(":<>/\\\"|"))) >= 0)
			csmodel = csmodel.Left(npos) + csmodel.Mid(npos + 1) ;

		// Add the first 2 characters of the model name (usually the first 2
		// letters of the manufacturer's name) to the file name.

		csfname = csmodel.Left(2) ;

		// Remove the first space delimited word (usually manufacturer's name)
		// from the model name.

		if ((npos = csmodel.Find(_T(' '))) >= 0)
			csmodel = csmodel.Mid(npos + 1) ;

		// Use up to 6 characters from the right of the remaining model name
		// characters to finish the file name.  Then save the file name.

		csfname += csmodel.Right(6) ;
		csafiles[n] = csfname ;
	} ;

	// Now we need to make sure that the file names are unique.  The algorithm
	// used is much like the one in CBasicNode::UniqueName().  That function
	// is not used because we aren't dealing with Workspace View nodes here.

    bool bchanged = false ;
	for (n = 1 ; n < numelts ; n++, bchanged = false) {
		for (int m = 0 ; m < n ; m++) {
			if (csafiles[n] != csafiles[m])
				continue ;

			// The current file name is not unique so it has to be changed.
			// Begin by determine the 0-based length of the name.

			npos = csafiles[n].GetLength() - 1 ;

			// If the name has been changed before, use the last "unique"
			// character to determine the new unique character.  Then replace
			// the old unique character with the new unique character.

			if (bchanged) {
				tch = csafiles[n].GetAt(npos) + 1 ;
				if (tch == _T('{'))
					tch = _T('0') ;
				else if (tch == _T(':'))
					tch = _T('a') ;
				csafiles[n].SetAt(npos, tch) ;

			// If the name has not been changed before, add a unique character
			// to the end of the name if this won't make the name longer than
			// 8 characters.  Otherwise, replace the last character with the
			// new unique character.

			} else {
				if (npos < 7)
					csafiles[n] += _T("a") ;
				else
					csafiles[n].SetAt(npos, _T('a')) ;
			} ;

			// Note that this name has been changed and reset the inner loop
			// counter so that the changed name will be rechecked against all
			// of the file names it needs to be checked against.

			bchanged = true ;
			m = -1 ;
		} ;
	} ;
}


/******************************************************************************

  CDriverResources::Generate

  This member function generates the RC file for one of the target environments

******************************************************************************/

BOOL    CDriverResources::Generate(UINT ufTarget, LPCTSTR lpstrPath)
{
	int		nrcid ;				// Holds a resource's ID
    CString csFontPrefix, csTransPrefix, csFontLabel, csTransLabel;
    unsigned    ucTables = 0, ucFonts =
                    (ufTarget == Win2000) ? FontCount() : OriginalFontCount();

    if  (ufTarget == Win2000) {
        csFontLabel = _T("RC_UFM");
        csTransLabel = _T("RC_GTT");
    }
    else {
        csFontLabel = _T("RC_FONT");
        csTransLabel = _T("RC_TRANSTAB");
    }

    switch  (ufTarget) {
        case    Win2000:
            csFontPrefix = _TEXT("UFM");
            csTransPrefix = _TEXT("GTT");
            break;

        case    WinNT40:
        case    WinNT3x:
            csFontPrefix = _TEXT("IFI");
            csTransPrefix = _TEXT("RLE");
            ucTables = 2;
            break;

        case    Win95:
            csFontPrefix = _TEXT("PFM");
            csTransPrefix = _TEXT("CTT");
            ucTables = 1;
            break;

        default:
            _ASSERTE(FALSE);    //  This shouldn't happen
            return  FALSE;
    }

    //  Create the RC file first.

    CStdioFile  csiof;

    if  (!csiof.Open(lpstrPath, CFile::modeCreate | CFile::modeWrite |
            CFile::shareExclusive | CFile::typeText)) {
        _ASSERTE(FALSE);    //  This shouldn't be possible
        return  FALSE;
    }

    //  Write out our header- it identifies this tool as the source, and it
    //  will (eventually) include the Copyright and other strings used to
    //  customize the environment.
    try {
		CString cs, cs2 ;
		cs.LoadString(IDS_RCCommentHdr1) ;
		csiof.WriteString(cs) ;
		cs.LoadString(IDS_RCCommentHdr2) ;
		csiof.WriteString(cs) ;
		cs.LoadString(IDS_RCCommentHdr3) ;
		csiof.WriteString(cs) ;

        //csiof.WriteString(_TEXT("/********************************************")
        //    _TEXT("**********************************\n\n"));
        //csiof.WriteString(_T("  RC file generated by the Minidriver ")
        //    _T("Development Tool\n\n"));
        //csiof.WriteString(_TEXT("*********************************************")
        //    _TEXT("*********************************/\n\n"));

        // Write out the standard definition and include statements for Win2K
		// style RC files.
		ForceCommonRC(FALSE);	// Don't use common.rc at all	// raid 141064
        if  (ufTarget == Win2000) { //  NT knows best.  What do developers know?
			cs.LoadString(IDS_StdIncludeFile1) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;
            if  (m_bUseCommonRC) {
				cs.LoadString(IDS_StdIncludeFile2) ;
				cs2.Format(IDS_IncStmt, cs) ;
				csiof.WriteString(cs2) ;
			} ;
			cs.LoadString(IDS_StdIncludeFile3) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;
			cs.LoadString(IDS_StdIncludeFile4) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;

            //csiof.WriteString(_T("#include <Minidrv.H>\n"));
            //if  (m_bUseCommonRC)
            //    csiof.WriteString(_T("#include <Common.RC>\n"));
            //csiof.WriteString(_T("#include <Windows.H>\n"));
            //csiof.WriteString(_T("#include <NTVerP.H>\n"));

			// Add the version definitions to the RC file.

			csiof.WriteString(_T("#define VER_FILETYPE VFT_DRV\n"));
            csiof.WriteString(_T("#define VER_FILESUBTYPE VFT2_DRV_PRINTER\n"));
            csiof.WriteString(_T("#define VER_FILEDESCRIPTION_STR \""));

			csiof.WriteString(Name());
            csiof.WriteString(_T(" Printer Driver\"\n"));
            csiof.WriteString(_T("#define VER_INTERNALNAME_STR \""));
            csiof.WriteString(Name().Left(8));
            csiof.WriteString(_T(".dll\"\n"));
            csiof.WriteString(_T("#define VER_ORIGINALFILENAME_STR \""));
            csiof.WriteString(Name().Left(8));
            csiof.WriteString(_T(".dll\"\n"));

			// Source RC files often contain the same version definitions as
			// those added above.  Make sure they aren't added to the Win2K RC
			// file twice by removing them from the definitions from the source
			// file.
			//
			// If any new definitions are added in the section above, add a
			// statement for that definition below.

			RemUnneededRCDefine(_T("VER_FILETYPE")) ;
			RemUnneededRCDefine(_T("VER_FILESUBTYPE")) ;
			RemUnneededRCDefine(_T("VER_FILEDESCRIPTION_STR")) ;
			RemUnneededRCDefine(_T("VER_INTERNALNAME_STR")) ;
			RemUnneededRCDefine(_T("VER_ORIGINALFILENAME_STR")) ;
			
			// Add include statement for common version info.

			cs.LoadString(IDS_StdIncludeFile5) ;
			cs2.Format(IDS_IncStmt, cs) ;
			csiof.WriteString(cs2) ;

            //csiof.WriteString(_T("#include \"common.ver\"\n"));
        } ;

		// Write out the rest (all if < NT 4) of the include statements.
/*	raid 141064
        for (unsigned u = 0; u < (unsigned) m_csaIncludes.GetSize(); u++) {
            CString csTest = m_csaIncludes[u];
            csTest.MakeLower();
            if  (m_csaIncludes[u].Find(_TEXT(".ver")) != -1)
                continue;
            csTest = _TEXT("#include ");
            csTest += m_csaIncludes[u] + _TEXT('\n');
            csiof.WriteString(csTest);
        }
*/
        csiof.WriteString(_TEXT("\n"));

        //  Now, write out all of the #defines

        for (unsigned u = 0; u < (unsigned) m_csaDefineNames.GetSize(); u++) {
            CString csDefine;
            csDefine.Format(_TEXT("#define %-32s %s\n"),
                (LPCTSTR) m_csaDefineNames[u], (LPCTSTR) m_csaDefineValues[u]);
            csiof.WriteString(csDefine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  GPC tables

        if  (ufTarget != Win2000)
            for (u = 0; u < ucTables; u++) {
                CString csLine;
                csLine.Format(_T("%-5u RC_TABLES PRELOAD MOVEABLE "), u + 1);
                if  (m_csaTables[u] != _T("NT"))
                    csLine += _T("\"");
                csLine += m_csaTables[u] + _T(".GPC");
                if  (m_csaTables[u] != _T("NT"))
                    csLine += _T("\"");
                csiof.WriteString(csLine + _T("\n"));
            }

        csiof.WriteString(_TEXT("\n"));

        //  Font tables

        for (u = 0; u < ucFonts; u++) {
            CString csLine;

			// Get the RC ID from the font node.  If the ID == -1, use the
			// font's index as its ID.

			if ((nrcid = Font(u).nGetRCID()) == -9999)
				nrcid = u + 1 ;

#if defined(NOPOLLO)
            csLine.Format(_TEXT("%-5u %s LOADONCALL DISCARDABLE \""),
                nrcid, (LPCTSTR) csFontLabel);
            csLine += csFontPrefix + _TEXT('\\') + Font(u).FileTitle() +
                _TEXT('.') + csFontPrefix + _TEXT("\"\n");
#else
            csLine.Format(_TEXT("%-5u %s LOADONCALL DISCARDABLE "),
                nrcid, (LPCTSTR) csFontLabel);
            csLine += csFontPrefix + _TEXT('\\') + Font(u).FileTitle() +
                _TEXT('.') + csFontPrefix + _TEXT("\n");
#endif
            csiof.WriteString(csLine);
        }

        csiof.WriteString(_TEXT("\n"));

        //  Mapping tables

        for (u = 0; u < MapCount(); u++) {
            CString csLine;

			// Get the RC ID from the GTT node.  If the ID == -1, use the
			// GTT's index as its ID.

			if ((nrcid = GlyphTable(u).nGetRCID()) == -1)
				nrcid = u + 1 ;

#if defined(NOPOLLO)
            csLine.Format(_TEXT("%-5u %s LOADONCALL MOVEABLE \""),
                nrcid, (LPCTSTR) csTransLabel);
            csLine += csTransPrefix + _TEXT('\\') + GlyphTable(u).FileTitle() +
                _TEXT('.') + csTransPrefix + _TEXT("\"\n");
#else
            csLine.Format(_TEXT("%-5u %s LOADONCALL MOVEABLE "),
                nrcid, (LPCTSTR) csTransLabel);
            csLine += csTransPrefix + _TEXT('\\') + GlyphTable(u).FileTitle() +
                _TEXT('.') + csTransPrefix + _TEXT("\n");
#endif
            csiof.WriteString(csLine);
        }

        csiof.WriteString(_TEXT("\n"));

		int n ;
		n = m_cst.Count() ;

        //  Time to do the String Table
        if  (m_cst.Count()) {
            csiof.WriteString(_TEXT("STRINGTABLE\n  BEGIN\n"));
            for (u = 0; u < m_cst.Count(); u++) {
                WORD    wKey;
                CString csValue, csLine;

                m_cst.Details(u, wKey, csValue);

                csLine.Format(_TEXT("    %-5u  \""), wKey);
                csLine += csValue + _TEXT("\"\n");
                csiof.WriteString(csLine);
            }
            csiof.WriteString(_TEXT("  END\n\n"));
        }

        //  Now, write out any .ver includes

        if  (ufTarget != Win2000)   //  Already hardcoded them here
            for (u = 0; u < (unsigned) m_csaIncludes.GetSize(); u++) {
                CString csTest = m_csaIncludes[u];
                csTest.MakeLower();
                if  (m_csaIncludes[u].Find(_TEXT(".ver")) == -1)
                    continue;
                csTest = _TEXT("#include ");
                csTest += m_csaIncludes[u] + _TEXT('\n');
                csiof.WriteString(csTest);
            }

        csiof.WriteString(_TEXT("\n"));

        //  Now, any of the remnants
// RAID 3449 kill below 2 line
//        for (u = 0; u < (unsigned) m_csaRemnants.GetSize(); u++)
//            csiof.WriteString(m_csaRemnants[u] + TEXT('\n'));
    }
    catch (CException* pce) {
        pce -> ReportError();
        pce -> Delete();
        return  FALSE;
    }

    return  TRUE;
}


/******************************************************************************

  CDriverResources::RemUnneededRCDefine

  Remove the specified definition from the array of definitions that will be
  added to the definitions in the output RC file.

******************************************************************************/

void CDriverResources::RemUnneededRCDefine(LPCTSTR strdefname)
{
    for (unsigned u = 0 ; u < (unsigned) m_csaDefineNames.GetSize() ; u++) {
        if (m_csaDefineNames[u].CompareNoCase(strdefname) != 0)
			continue ;
		m_csaDefineNames.RemoveAt(u) ;
		m_csaDefineValues.RemoveAt(u) ;
		return ;
    } ;
}


/******************************************************************************

  CDriverResources::RemUnneededRCInclude

  Remove the specified include file from the array of include files that will
  be added to the include statements in the output RC file.

******************************************************************************/

void CDriverResources::RemUnneededRCInclude(LPCTSTR strincname)
{
    for (unsigned u = 0 ; u < (unsigned) m_csaIncludes.GetSize() ; u++) {
		//TRACE("Inc[%d] = '%s'   incname = '%s'\n", u, m_csaIncludes[u], strincname) ;
        if (m_csaIncludes[u].CompareNoCase(strincname) != 0)
			continue ;
		m_csaIncludes.RemoveAt(u) ;
		return ;
    } ;
}


/******************************************************************************

  CDriverResources::ReparseRCFile

  Read in the new RC file, parse its statements, and update all of the internal
  data structures with the information from the new RC file.

******************************************************************************/

bool CDriverResources::ReparseRCFile(CString& csrcfspec)
{
    CWaitCursor     cwc ;		//  Just in case this takes a while...
	CString			cs, cs2 ;

	// Load the RC file and save its data into data specific arrays.

    CStringTable cstfonts, cstmaps ;
	CStringArray csa ;			// Use this instead of m_csaTables
    if  (!LoadRCFile(csrcfspec, m_csaDefineNames, m_csaDefineValues,
					 m_csaIncludes, m_csaRemnants, csa, m_cst, cstfonts,
					 cstmaps, Win2000)) {
		cs.LoadString(IDS_RCRepFailed1) ;
        AfxMessageBox(cs, MB_ICONEXCLAMATION) ;
        return false ;
	} ;

	// LoadRCFile() will have correctly reloaded m_csaDefineNames,
	// m_csaDefineValues, and m_csaIncludes.  Nothing needs to be done with csa.
	// Now, the rest of the data needs to be processed.  Start by finding and
	// removing the standard comment header from the remnants array.

	cs.LoadString(IDS_RCCommentHdr2) ;
	cs.TrimLeft() ;
	cs.TrimRight() ;
	CString csrem ;
	for (int n = 0 ; n < m_csaRemnants.GetSize() ; n++) {
		//TRACE("Rem[%d] = '%s'   hdr2 = '%s'\n", n, m_csaRemnants[n], cs) ;
		csrem = m_csaRemnants[n] ;
		csrem.TrimLeft() ;
		csrem.TrimRight() ;
		if (csrem == cs)
			break ;
	} ;
	if (n < m_csaRemnants.GetSize()) {
		n -= 2 ;
		int nc = n + 6 ;
		m_csaRemnants.RemoveAt(n, nc) ;
	} ;

	// Find and remove the standard include files from m_csaIncludes.

	cs.LoadString(IDS_StdIncludeFile1) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile2) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile3) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile4) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_StdIncludeFile5) ;
	RemUnneededRCInclude(cs) ;
	cs.LoadString(IDS_OldIncludeFile1) ;
	RemUnneededRCInclude(cs) ;

	// Get the path to the RC file.

	CString csrcpath ;
	csrcpath = csrcfspec.Left(csrcfspec.ReverseFind(_T('\\')) + 1) ;

	// Update the old/current GTT list with data from the new GTT list.

	CUIntArray cuaboldfound, cuabnewfound ;
	int nc ;	// Count of elements in new list.
	UpdateResourceList(cstmaps, m_csoaAtlas, cuaboldfound, cuabnewfound,
					   csrcpath, nc) ;

	// GTT List Update Step 3:  Update the old list with data for items from
	// the new list whenever a new list item was not found in the old list.

	CGlyphMap* pcgm ;
	WORD wkey ;
	for (n = 0 ; n < nc ; n++) {
		if (cuabnewfound[n])
			continue ;
		pcgm = new CGlyphMap ;
		cstmaps.Details(n, wkey, cs) ;
		pcgm->nSetRCID((int) wkey) ;				// Set resource handle
		UpdateResourceItem(pcgm, csrcpath, wkey, cs, FNT_GTTS) ;
		m_csoaAtlas.InsertAt(n, pcgm) ;
	} ;

	// Update the old/current UFM list with data from the new UFM list.

	UpdateResourceList(cstfonts, m_csoaFonts, cuaboldfound, cuabnewfound,
					   csrcpath, nc) ;

	// UFM List Update Step 3:  Update the old list with data for items from
	// the new list whenever a new list item was not found in the old list.

	CFontInfo* pcfi ;
	for (n = 0 ; n < nc ; n++) {
		if (cuabnewfound[n])
			continue ;
		pcfi = new CFontInfo ;
		cstfonts.Details(n, wkey, cs) ;
		UpdateResourceItem(pcfi, csrcpath, wkey, cs, FNT_UFMS) ;
		m_csoaFonts.InsertAt(n, pcfi) ;
	} ;

	// All went well so...
	
	return true ;
}


/******************************************************************************

  CDriverResources::UpdateResourceList

  Three steps are needed to update a resource list.  Two of those steps are
  performed in this version of UpdateResourceList().

  Step 1: Compare the old and new lists.  Whenever a new resource file matches
  an old one, update the RC ID when necessary and mark them both as being found.

  Step 2: Remove any of the old resource class instances that were not found in
  Step 1.

******************************************************************************/

void CDriverResources::UpdateResourceList(CStringTable& cst, CSafeObArray& csoa,
										  CUIntArray& cuaboldfound,
										  CUIntArray& cuabnewfound,
										  CString& csrcpath, int& nc)
{
	// Declare and initialize the variables that will control the loops, etc.

	nc = cst.Count() ;
	cuabnewfound.RemoveAll() ;
	cuabnewfound.SetSize(nc) ;
	int ncold = csoa.GetSize() ;
	cuaboldfound.RemoveAll() ;
	cuaboldfound.SetSize(ncold) ;
	WORD wkey ;
	CString cs ;

	// Try to find each new resource in the list of old resources.

	for (int n = 0 ; n < nc ; n++) {
		cst.Details(n, wkey, cs) ;
		cs = csrcpath + cs ;
		for (int n2 = 0 ; n2 < ncold ; n2++) {
			//TRACE("+++ Resource path = %s\n", ((CProjectNode *) csoa[n2])->FileName()) ;
			if (cs == ((CProjectNode *) csoa[n2])->FileName()) {

				// Update the matching old resource's ID if it isn't the same
				// as the new one.

				if (wkey != ((CProjectNode *) csoa[n2])->nGetRCID())
					((CProjectNode *) csoa[n2])->nSetRCID(wkey) ;

				// Note that a match for the old and new resources was found.

				cuabnewfound[n] = (unsigned) true ;
				cuaboldfound[n2] = (unsigned) true ;
				break ;
			} ;
		} ;
	} ;

	// Remove the old resource class instances that are no longer in the new
	// list.

	for (n = ncold - 1 ; n >= 0 ; n--) {
		if (cuaboldfound[n])
			continue ;
		csoa.RemoveAt(n) ;
	} ;
}


/******************************************************************************

  CDriverResources::UpdateResourceItem

  This function does most of the work for the third resource update step.  It
  initializes new resources that are going to be added to the resource list.
  Essentially, it does what the serialize routines do.

******************************************************************************/

void CDriverResources::UpdateResourceItem(CProjectNode* pcpn, CString& csrcpath,
										  WORD wkey, CString& cs,
										  FIXEDNODETYPE fnt)
{
	// Build the full filespec for the resource, its name, and its path.

	CString csfspec, csname, cspath ;
	csfspec = csrcpath + cs ;
	int n = csfspec.ReverseFind(_T('\\')) ;
	cspath = csfspec.Left(n + 1) ;
	csname = csfspec.Mid(n + 1)  ;
	n = csname.ReverseFind(_T('.')) ;
	if (n >= 0)
		csname = csname.Left(n) ;
	
	// Use the file name (no extension) as the default resource name.

	CString csfs ;
	pcpn->Rename(csname) ;
	csfs = pcpn->Name() ;

	// Set the file node's path and file name.
	
	pcpn->m_cfn.SetPathAndName(cspath, csname) ;
	csfs = pcpn->FileName() ;
	
	// Set the rc id and resource type.

	pcpn->nSetRCID(wkey) ;
	pcpn->m_crinRCID.fntSetType(FNT_GTTS) ;
}


/******************************************************************************

  CDriverResources::Fill

  This is a CProjectNode override- it fills in the material relevant to this
  driver.

******************************************************************************/

void    CDriverResources::Fill(CTreeCtrl *pctcWhere, CProjectRecord& cpr)
{
    CWaitCursor cwc;

    NoteOwner(cpr);
    SetWorkspace(this);
    CBasicNode::Fill(pctcWhere);

	// Add the resources node
	m_cfnResources.Fill(pctcWhere, m_hti) ;
    m_cfnResources.NoteOwner(cpr) ;

    //  Fill in the font information
    m_cfnFonts.NoteOwner(cpr);
    for (unsigned u = 0; u < FontCount(); u++) {
        Font(u).SetWorkspace(this);
        Font(u).EditorInfo(FontTemplate());
    }
    m_cfnFonts.Fill(pctcWhere, m_cfnResources.Handle());
    m_cfnFonts.SetWorkspace(this);

    //  Fill in the glyph map information
    m_cfnAtlas.NoteOwner(cpr);
    for (u = 0; u < MapCount(); u++) {
        GlyphTable(u).SetWorkspace(this);
        GlyphTable(u).EditorInfo(GlyphMapDocTemplate());
    }
    m_cfnAtlas.Fill(pctcWhere, m_cfnResources.Handle());
    m_cfnAtlas.SetWorkspace(this);

	// Add the strings node
    m_csnStrings.Fill(pctcWhere, m_cfnResources.Handle());
    m_csnStrings.NoteOwner(cpr);
    m_csnStrings.SetWorkspace(this);

    //  Fill in the model data information.
    for (u = 0; u < Models(); u++) {
        Model(u).SetWorkspace(this);
        Model(u).EditorInfo(GPDTemplate());
    }
    m_cfnModels.NoteOwner(cpr);
    m_cfnModels.Fill(pctcWhere, m_hti);
    m_cfnModels.SetWorkspace(this);

	// Expand the first couple of levels of the tree
	pctcWhere -> Expand(m_hti, TVE_EXPAND);
	pctcWhere -> Expand(m_cfnResources.Handle(), TVE_EXPAND);

    //  Load the font and GTT files, then map them together.  Also load any
    //  predefined tables now.

    for (u = 0; u < MapCount(); u++)
        GlyphTable(u).Load();

    for (u = 0; u < FontCount(); u++)
		LinkAndLoadFont(Font(u), true) ;

	// Save a copy of the Win2K path in this class because the path is easier to
	// get and use when it is in this class.

	m_csW2000Path = cpr.GetW2000Path() ;
}


/******************************************************************************

  CDriverResources::LinkAndLoadFont


******************************************************************************/
// raid 0003
void CDriverResources::LinkAndLoadFont(CFontInfo& cfi, bool bworkspaceload, bool bonlyglyph)
{
	CGlyphMap* pcgm ;

	// If this is part of a workspace load (ie, called from Fill()), load the
	// font the first time to get the GTT ID and code page number in the font.

	if (bworkspaceload)
		cfi.Load(true) ;

	// Now that the font has been loaded, use the data in it to see if it
	// references a predefined GTT.

	pcgm = CGlyphMap::Public(cfi.Translation(), (WORD) cfi.m_ulDefaultCodepage,
							 ((CProjectRecord*) GetOwner())->GetDefaultCodePage(),
							 cfi.GetFirst(), cfi.GetLast()) ;

	// If a GTT was found, save a pointer to it in the font's class.  Otherwise,
	// look for the font's GTT amongst the GTTs in the font's workspace.  Again,
	// save a pointer to the GTT if a match is found.

    if  (pcgm)
        cfi.SetTranslation(pcgm) ;
    else {
		//TRACE(    "UFM = %s   GTT ID = %d\n", cfi.Name(), cfi.Translation()) ;
        for (unsigned uGTT = 0; uGTT < MapCount(); uGTT++) {
			//TRACE("Checking %dth ID = %d    Name = %s\n", uGTT+1, 
			//	  GlyphTable(uGTT).nGetRCID(), GlyphTable(uGTT).Name()) ;
            if  (cfi.Translation() == ((WORD) GlyphTable(uGTT).nGetRCID())) {
                cfi.SetTranslation(&GlyphTable(uGTT)) ;
				break ;
			} ;
		} ;
	} ;

	if (bonlyglyph && cfi.m_pcgmTranslation != NULL)
		return ;
	// Load the font again if we now know the linkage; ie the GTT/CP.
	// Otherwise, warn the user.  (The font is loaded again because parts of
	// the UFM cannot be correctly loaded until the GTT is available.)

	if (cfi.m_pcgmTranslation != NULL)
		cfi.Load(true) ;
	else {
		cfi.SetNoGTTCP(true) ;
		CString csmsg ;
		csmsg.Format(IDS_NoGTTForUFMError, cfi.Name()) ; 
		AfxMessageBox(csmsg, MB_ICONEXCLAMATION) ;
	} ;
}


/******************************************************************************

  CDriverResources::WorkspaceChecker

  Check the workspace for completeness and tidiness.  The following checks are
  made:
	1.  All GTTs referenced in the UFMs exist.
	2. 	All GTTs are referenced by at least one UFM.
	3.  All UFMs referenced in the GPDs exist.
	4.  All UFMs are referenced by at least one GPD.
	5.  All strings referenced in the GPDs exist.
	6.	All strings are referenced by at least one GPD.
	7.  All GPD model names are unique.
	8.  All GPD file names are unique.

  Workspaces that pass tests 1, 3, 5, 7, and 8 are considered to be complete.
  These test must be passed before the driver is built and used. Workspaces
  that pass tests 2, 4, and 6 are considered to be tidy.  Failure to pass these
  tests generate warnings.

******************************************************************************/

bool CDriverResources::WorkspaceChecker(bool bclosing)
{
	bool		bwsproblem ;		// True iff an error or warning was found

    //  This might take a while, so...

    CWaitCursor cwc ;

	// First reset any existing error window for this workspace to make sure
	// that the window won't contain duplicate error/warning messages.	Then
	// initialize the error found flag.

	ResetWorkspaceErrorWindow(bclosing) ;
	bwsproblem = false ;

	// Perform the GTT related checks (1 & 2)

	DoGTTWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Perform the GPD related checks (7 & 8)

	DoGPDWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Perform the UFM related checks (3 & 4)

	DoUFMWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Perform the string related checks (5 & 6).  This check should only be
	// done if the workspace contains RC IDs for the strings that we want to
	// check.

	CProjectRecord* pcpr = (CProjectRecord *) m_pcdOwner ;
	if (pcpr != NULL && pcpr->GetMDWVersion() > MDW_DEFAULT_VERSION)
		DoStringWorkspaceChecks(bclosing, bwsproblem) ;

	if (m_bIgnoreChecks)		// Just return if further checking should be
		return false ;			// skipped.

	// Tell the user if no problems were found.  Only do this when the
	// workspace is not closing.

	if (!bwsproblem && !bclosing) {
		CString csmsg ;
		csmsg.Format(IDS_NoWSProblems, Name()) ;
		AfxMessageBox(csmsg) ;
	} ;

	// Let the caller know if any problems were found.

	return bwsproblem ;
}


/******************************************************************************

  CDriverResources::DoGTTWorkspaceChecks

  The following checks are made:
	1.  All GTTs referenced in the UFMs exist.
	2. 	All GTTs are referenced by at least one UFM.

******************************************************************************/

void CDriverResources::DoGTTWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	short		srcid ;			// Current RC ID being checked
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	ucount2 ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2 ;			// Loop counters
	CString		csmsg ;			// Error or warning message
	CGlyphMap*	pcgm ;			// Used to streamline code
	CFontInfo*	pcfi ;			// Used to streamline code
	
	// Clear the referenced flag in each GTT node

	for (ucount = MapCount(), u = 0 ; u < ucount ; u++)
        GlyphTable(u).ClearRefFlag() ;

	// Completeness Check #1
	// Check each UFM to make sure that the GTT it references, exists.  This is
	// done by checking the GTT RC ID in each UFM against all of the GTT RC IDs
	// to see if a match is found.

	for (ucount = FontCount(), u = 0 ; u < ucount ; u++) {
		pcfi = &Font(u) ;

		// Get the GTT RC ID referenced in the current UFM.  Continue if the ID
		// is one of the special GTT IDs (-1 to -18).

		srcid = pcfi->Translation() ;
		if (srcid >= CGlyphMap::Wansung && srcid <= CGlyphMap::CodePage437)
			continue ;

		// Try to find a matching GTT ID.  If one is found, mark that GTT as
		// being referenced.
	
		for (ucount2 = MapCount(), u2 = 0 ; u2 < ucount2 ; u2++) {
			if (srcid == GlyphTable(u2).nGetRCID()) {
				GlyphTable(u2).SetRefFlag() ;
				break ;
			} ;
		} ;

		// If the GTT was not found, format and post an error message.  Also,
		// set the flag indicating that an error has occurred.

		if (u2 >= ucount2) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			if(srcid == 0)  //RAID 18518
				csmsg.Format(IDS_UFMCompWarning, pcfi->Name(), srcid) ;
			else			//END RAID
				csmsg.Format(IDS_UFMCompError, pcfi->Name(), srcid) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcfi) ;
			bwsproblem = true ;
		} ;
	} ;

	// Tidiness Check #2
	// Each GTT that is referenced by a UFM was marked above.  Now we need to
	// find out if any GTT is unreferenced.  Post a warning message for each
	// unreferenced GTT.

	for (ucount = MapCount(), u = 0 ; u < ucount ; u++) {
		pcgm = &GlyphTable(u) ;
        if (!pcgm->GetRefFlag()) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_GTTTidyWarning, pcgm->Name(), pcgm->nGetRCID()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcgm) ;
		} ;
	} ;
}


void CDriverResources::DoUFMWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	int			nrcid ;			// Current RC ID being checked
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	ucount2 ;		// Count of nodes, etc processed in a loop
	unsigned	ucount3 ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2, u3 ;		// Loop counters
	CString		csmsg ;			// Error or warning message
	CFontInfo*	pcfi ;			// Used to streamline code
	CModelData*	pcmd ;			// Used to streamline code
	
	// Clear the referenced flag in each UFM

	for (ucount = FontCount(), u = 0 ; u < ucount ; u++)
        Font(u).ClearRefFlag() ;

	// Completeness Check #3
	// Check to see if all of the UFMs referenced by each GPD exist in the
	// workspace.

    for (ucount = Models(), u = 0; u < ucount ; u++) {
        pcmd = &Model(u) ;

		// Update the list of UFMs in the GPD.  This may fail.  If it does,
		// post an error message explaining the problem and how to fix it.
		// Then skip further processing of this GPD.

		if (!pcmd->UpdateResIDs(true)) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_BadGPDError, pcmd->Name()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
			bwsproblem = true ;
			continue ;
		} ;

		// Check to see if each UFM referenced by the GPD is in the workspace.

		for (ucount2 = pcmd->NumUFMsInGPD(), u2 = 0 ; u2 < ucount2 ; u2++) {
			// Skip this UFM if it is 0x7fffffff.  That ID has a special
			// meaning.

			if ((nrcid = pcmd->GetUFMRCID(u2)) == 0x7fffffff || nrcid < 0
			 || nrcid >= 32768)
				continue ;
			
			// Try to find a UFM in the workspace that matches the current ID
			// from the GPD.  If one is found, mark that UFM as being
			// referenced.

			for (ucount3 = FontCount(), u3 = 0 ; u3 < ucount3 ; u3++) {
				if (nrcid == Font(u3).nGetRCID()) {
					Font(u3).SetRefFlag() ;
					break ;
				} ;
			} ;

			// If the UFM was not found, format and post an error message.
			// Also, set the flag indicating that an error has occurred.

			if (u3 >= ucount3) {
				if (IgnoreChecksWhenClosing(bclosing))
					return ;
				csmsg.Format(IDS_GPDUFMCompError, pcmd->Name(), nrcid) ;
				PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
				bwsproblem = true ;
			} ;
		} ;
	} ;

	// Tidiness Check #4
	// Each UFM that is referenced by a GPD was marked above.  Now we need to
	// find out if any UFM is unreferenced.  Post a warning message for each
	// unreferenced UFM.

	for (ucount = FontCount(), u = 0 ; u < ucount ; u++) {
		pcfi = &Font(u) ;
        if (!pcfi->GetRefFlag()) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_UFMTidyWarning, pcfi->Name(), pcfi->nGetRCID()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcfi) ;
		} ;
	} ;
}


/******************************************************************************

  CDriverResources::DoStringWorkspaceChecks

  The following checks are made:
	5.  All strings referenced in the GPDs exist.
	6.	All strings are referenced by at least one GPD.

******************************************************************************/

void CDriverResources::DoStringWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	int			nrcid ;			// Current RC ID being checked
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	ucount2 ;		// Count of nodes, etc processed in a loop
	unsigned	ucount3 ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2, u3 ;		// Loop counters
	CString		csmsg ;			// Error or warning message
	CModelData*	pcmd ;			// Used to streamline code
	WORD		wkey ;			// String RC ID
	CString		csstr ;			// String associated with wkey & other strings
	
	// Clear the referenced flags for each of the strings in the table

	m_cst.InitRefFlags() ;

	// Completeness Check #5
	// Check to see if all of the strings referenced by each GPD exist in the
	// workspace.

    for (ucount = Models(), u = 0; u < ucount ; u++) {
        pcmd = &Model(u) ;

		// Update the list of strings in the GPD.  This may fail.  If it does,
		// post an error message explaining the problem and how to fix it.
		// Then skip further processing of this GPD.

		if (!pcmd->UpdateResIDs(false)) {
			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_BadGPDError, pcmd->Name()) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
			bwsproblem = true ;
			continue ;
		} ;

		// Check to see if each string referenced by the GPD is in the
		// workspace.

		for (ucount2 = pcmd->NumStringsInGPD(), u2 = 0 ; u2 < ucount2 ; u2++) {
			// Get the current string ID from the GPD.

			nrcid = pcmd->GetStringRCID(u2) ;
			
			// Skip this ID if it is 0x7fffffff or in the range of IDs in 
			// common.rc or the ID comes from a resource DLL or the ID is 0 
			// because 0 IDs are just placeholders for constant strings in the
			// GPD.

			if (nrcid == 0x7fffffff
			 || (nrcid >= FIRSTCOMMONRCSTRID && nrcid <= LASTCOMMONRCSTRID)
			 || nrcid >= 65536 || nrcid == 0)
				continue ;

			// Try to find a string in the workspace that matches the current
			// ID from the GPD.  If one is found, mark that string as being
			// referenced.

			for (ucount3 = m_cst.Count(), u3 = 0 ; u3 < ucount3 ; u3++) {
				m_cst.Details(u3, wkey, csstr) ;
				if (nrcid == wkey) {
					m_cst.SetRefFlag(u3) ;
					break ;
				} ;
			} ;

			// If the string was not found, format and post an error message.
			// Also, set the flag indicating that an error has occurred.

			if (u3 >= ucount3) {
				if (IgnoreChecksWhenClosing(bclosing))
					return ;
				csmsg.Format(IDS_GPDStrCompError, pcmd->Name(), nrcid) ;
				PostWSCheckingMessage(csmsg, (CProjectNode *) pcmd) ;
				bwsproblem = true ;
			} ;
		} ;
	} ;

	// Tidiness Check #6
	// Each string that is referenced by a GPD was marked above.  Now we need to
	// find out if any string is unreferenced.  Post a warning message for each
	// unreferenced string.

	for (ucount = m_cst.Count(), u = 0 ; u < ucount ; u++) {
        if (m_cst.GetRefFlag(u))		// Skip this string if it was referenced
			continue ;

		m_cst.Details(u, wkey, csstr) ;	// Skip this string if ID in low range
		if (wkey >= 1 && wkey <= 256)
			continue ;
		
		if (IgnoreChecksWhenClosing(bclosing))
			return ;
		csmsg.Format(IDS_StrTidyWarning, csstr, wkey) ;
		// NULL should be replaced with something that will allow the
		// string editor to be invoked once the string editor is
		// implemented.
		PostWSCheckingMessage(csmsg, NULL) ;
		bwsproblem = true ;
	} ;
}


/******************************************************************************

  CDriverResources::DoGPDWorkspaceChecks

  The following checks are made:
	7.  All GPD model names are unique.
	8.  All GPD file names are unique.

******************************************************************************/

void CDriverResources::DoGPDWorkspaceChecks(bool bclosing, bool& bwsproblem)
{
	unsigned	ucount ;		// Count of nodes, etc processed in a loop
	unsigned	u, u2 ;			// Loop counters
	CString		csmsg ;			// Error or warning message
	CString		csstr ;			// Temp string
	
	// Completeness Check #7
	// Check to see if all of the GPD model names are unique.

    for (ucount = Models(), u = 0; u < ucount ; u++) {					
		csstr = Model(u).Name() ;
		for (u2 = 0 ; u2 < u ; u2++) {									

			// If these model names don't match, continue checking.

			if (csstr != Model(u2).Name())
				continue ;

			// A duplicate was found so post an error message and indicate
			// that there is a problem.

			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_GPDModNameCompError, u, csstr) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) &Model(u)) ;
			bwsproblem = true ;
		} ;
	} ;

	// Completeness Check #8
	// Check to see if all of the GPD file names are unique.

    for (ucount = Models(), u = 0; u < ucount ; u++) {					
		csstr = Model(u).FileTitleExt() ;
		for (u2 = 0 ; u2 < u ; u2++) {									

			// If these model names don't match, continue checking.

			if (csstr != Model(u2).FileTitleExt())
				continue ;

			// A duplicate was found so post an error message  and indicate
			// that there is a problem.

			if (IgnoreChecksWhenClosing(bclosing))
				return ;
			csmsg.Format(IDS_GPDFileNameCompError, u, csstr) ;
			PostWSCheckingMessage(csmsg, (CProjectNode *) &Model(u)) ;
			bwsproblem = true ;
		} ;
	} ;
}


/******************************************************************************

  CDriverResources::IgnoreChecksWhenClosing

  This function is used to end workspace checking and return to the caller
  when the workspace is closing iff the user says to do so.  This routine is
  only called - and therefore the user is only prompted - when an error or
  warning has been detected.  The up side of this is that no user intervention
  is needed unless a problem is detected.  The downside is that more checking
  (and sometimes all of the checking) has to be performed before we can find
  out if we should stop.  This is why the GPD checking is the last thing done
  by WorkspaceChecker().  Hopefully, if there is a problem, it will be found
  in the faster checks before the GPD checks have to be done.

******************************************************************************/

bool CDriverResources::IgnoreChecksWhenClosing(bool bclosing)
{
	// If this is the first message to be posted and the WS is closing, ask
	// the user what he wants to do.

	if (m_bFirstCheckMsg) {
		m_bIgnoreChecks = false ;	// Assume checks are NOT ignored
		if (bclosing) {
			CString csmsg ;
			csmsg.Format(IDS_WSCloseCheckPrmt, Name()) ;
			int nrc = AfxMessageBox(csmsg, MB_YESNO) ;
			m_bIgnoreChecks = (nrc == IDNO) ;
		} ;

		// Reset flag now that first check processing is done

		m_bFirstCheckMsg = false ;	
	} ;

	// By the time this point is reached, the value of m_bIgnoreChecks will
	// contain whatever should be returned by this function.

	return m_bIgnoreChecks ;
}


/******************************************************************************

  CDriverResources::PostWSCheckingMessage

  Create the checking results window if needed and then post a message to it.

******************************************************************************/

bool CDriverResources::PostWSCheckingMessage(CString csmsg, CProjectNode* ppn)
{
	// Create the workspace checking, error and warning display window if one
	// does not exist.

	if (m_pwscdCheckDoc == NULL) {
		m_pwscdCheckDoc = new CWSCheckDoc(this) ;
		if (m_pwscdCheckDoc == NULL)
			return false ;
		CString cstitle ;
		cstitle.Format(IDS_WSCheckTitle, Name()) ;
		m_pwscdCheckDoc->SetTitle(cstitle) ;
		CMultiDocTemplate*  pcmdt = WSCheckTemplate() ;	
		m_pcmcwCheckFrame = (CMDIChildWnd *) pcmdt->CreateNewFrame(m_pwscdCheckDoc, NULL) ;
		if  (m_pcmcwCheckFrame) {
			pcmdt->InitialUpdateFrame(m_pcmcwCheckFrame, m_pwscdCheckDoc, TRUE) ;
			pcmdt->AddDocument(m_pwscdCheckDoc) ;
		} else {
			delete m_pwscdCheckDoc ;
			m_pwscdCheckDoc = NULL ;
			m_bIgnoreChecks = true ;
			return false ;
		} ;
		m_bFirstCheckMsg = false ;
	} ;

	// Post the message and return

	m_pwscdCheckDoc->PostWSCMsg(csmsg, ppn) ;
	return true ;
}


/******************************************************************************

  CDriverResources::ResetWorkspaceErrorWindow

  If there is an existing checking results window for this workspace, clear
  out its contents.  Next, initialize a couple of flags that have to be set
  before the ws checking begins.

******************************************************************************/

void CDriverResources::ResetWorkspaceErrorWindow(bool bclosing)
{
	// Clear the checking window if there is one.

	if (m_pwscdCheckDoc && m_pcmcwCheckFrame && IsWindow(m_pcmcwCheckFrame->m_hWnd))
		m_pwscdCheckDoc->DeleteAllMessages() ;
	else {
		m_pwscdCheckDoc = NULL ;
		m_pcmcwCheckFrame = NULL ;
		// BUG_BUG - Do I need to delete these classes first???
	} ;

	// Initialize checking flags

	m_bFirstCheckMsg = true ;
	m_bIgnoreChecks = false ;
}


/******************************************************************************

  CDriverResources::RunEditor

  Run the String Editor if requested and the string RC ID is not a common ID.
  Otherwise, run the UFM Editor with the requested UFM loaded if the UFM ID
  is valid.

  Return true if it is possible to run an editor.  Otherwise, return false.

******************************************************************************/

bool CDriverResources::RunEditor(bool bstring, int nrcid)
{
	// If the String Editor is requested...

	if (bstring) {
		// Can't do anything if this is a special or common string ID.

		if (nrcid == 0x7fffffff
		 || (nrcid >= FIRSTCOMMONRCSTRID && nrcid <= LASTCOMMONRCSTRID))
			return false ;

		// Run the editor and return true because this was possible.

		m_csnStrings.SetFirstSelRCID(nrcid) ;
		m_csnStrings.Edit() ;
		return true ;
	} ;

	// UFM Editor requested so...
	
	// Fail if the UFM ID is invalid.

	if (nrcid < 1 || nrcid > (int) FontCount())
		return false ;

	// Since the UFMs might not be in RC ID order, I have to search for the UFM
	// with the matching ID.

	for (unsigned u = 0 ; u < FontCount() ; u++)
		if (Font(u).nGetRCID() == nrcid) {
			Font(u).Edit() ;
			return true ;
		} ;

	// Could not find UFM with matching RC ID so...

	return false ;
}



void CDriverResources::CopyResources(CStringArray& csaUFMFiles, CStringArray& csaGTTFiles, CString& csModel,CStringArray& csaRcid)
{
	// copy files to CDriverResources member data
	// UFM 
	for (int i = 0 ;  i < csaUFMFiles.GetSize(); i++ ) {
		CFontInfo* pcfi = new CFontInfo ; 
		pcfi->SetFileName(csaUFMFiles.GetAt(i)) ;
		pcfi->Rename(pcfi->FileTitle() ) ;
		m_csoaFonts.Add(pcfi) ;
	}

	// GTT
	for (i = 0 ; i < csaGTTFiles.GetSize() ; i ++ ) {
		CGlyphMap* pcgm = new CGlyphMap ;
		pcgm->SetFileName(csaGTTFiles.GetAt(i)) ;
		pcgm->Rename(pcgm->FileTitle() ) ;
		m_csoaAtlas.Add(pcgm) ;
	}

	// GPD
	
	for (i = 0 ; i < 1 ; i ++ ) {
		CModelData* pcmd = new CModelData ;
		pcmd->SetFileName(csModel);
		pcmd->Rename(pcmd->FileTitle() );
		m_csoaModels.Add(pcmd) ;
	}

	for (i = 0 ; i < csaRcid.GetSize() ; i ++ ) {
		AddStringEntry(csaRcid[i], m_cst) ;
	}
}



/******************************************************************************

  CDriverResources::SyncUFMWidth

To Do : call all UFM and reload the width table regard to change of the GTT
return; true at end of the process

******************************************************************************/
	
	

BOOL CDriverResources::SyncUFMWidth()
{
	unsigned uufms, u ;
	for (uufms = FontCount(), u = 0 ; u < uufms ; u++) {
		CFontInfo& cfi = Font(u) ;	
		CString cspath = cfi.FileName() ;

		cfi.CheckReloadWidths() ;
		cfi.Store(cspath,true ) ;
			
	}
	return true ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\raslib.h ===
/************************** Module Header ***********************************
 * raslib.h
 *      Include file to provide prototypes and data types for the rasdd
 *      private library.
 *
 * Copyright (C) 1992 - 1993    Microsoft Corporation.
 *
 *****************************************************************************/

/*
 *   The simple way to turn ANSI to UNICODE>
 */


/*
 *   A convenient grouping for passing around information about the
 * Win 3.1 font information.
 */

typedef  struct
{
    BYTE           *pBase;      /* The base address of data area */
    DRIVERINFO      DI;         /* DRIVERINFO for this font */
    PFMHEADER       PFMH;       /* Properly aligned, not resource format */
    PFMEXTENSION    PFMExt;     /* Extended PFM data,  properly aligned! */
    EXTTEXTMETRIC  *pETM;       /* Extended text metric */
} FONTDAT;

/*
 *   Function prototypes for functions that convert Win 3.1 PFM style
 *  font info to the IFIMETRICS etc required by NT.
 */

/*   Convert PFM style metrics to IFIMETRICS  */
IFIMETRICS *FontInfoToIFIMetric( FONTDAT  *, HANDLE, PWSTR, char ** );

/*   Extract the Command Descriptors for (de)selecting a font */
CD *GetFontSel( HANDLE, FONTDAT *, int );


/*   Convert from non-aligned x86 format Win 3.1 data to aligned versions */
void ConvFontRes( FONTDAT * );

/*   Obtain the width vector - proportionally spaced fonts only */
short  *GetWidthVector( HANDLE, FONTDAT * );

/*
 *     Functions to return the integer value in a WORD or DWORD.  Functions
 *  do two operations:   first is to align the data,  second is to
 *  adjuest the byte order to the current machine.  The input is
 *  assumed to be little endian,  like the x86.
 */

extern "C" WORD   DwAlign2( BYTE * );
extern "C" DWORD  DwAlign4( BYTE * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MiniDev.rc
//
#define NewProjectWizardTitle           1
#define OpenRCDialogTitle               2
#define IDOK2                           2
#define IDS_UnitoolNotRun               3
#define IDP_UnitoolNotRun               3
#define IDS_RCLoadFailed                4
#define IDP_RCLoadFailed                4
#define IDS_Unimplemented               5
#define IDS_CannotMakeDirectory         6
#define IDP_CannotMakeDirectory         6
#define IDS_Atlas                       7
#define IDS_FontList                    8
#define ID_RenameItem                   9
#define ID_ExpandBranch                 10
#define ID_CollapseBranch               11
#define ID_OpenItem                     12
#define IDS_MapColumn0                  13
#define IDS_MapColumn1                  14
#define IDS_MapColumn2                  15
#define IDS_MapsGenerated               16
#define IDS_NoPredefined                16
#define IDS_MapsFailed                  17
#define IDS_NoErrorsAnywhere            17
#define ID_ChangeInvocation             18
#define ID_ChangeCodePage               19
#define ID_DeleteItem                   20
#define IDS_DeleteItemQuery             21
#define ID_GenerateOne                  22
#define IDS_DefaultPage                 41
#define ID_AddItem                      42
#define IDS_NoUnmappedGlyphs            43
#define IDP_NoUnmappedGlyphs            43
#define IDS_LengthMismatch              44
#define IDS_LoadFailure                 45
#define IDS_Models                      46
#define IDS_ConversionErrors            47
#define IDP_ConversionErrors            47
#define IDS_FileName                    48
#define IDS_InvalidFilename             49
#define IDS_OverwritePrompt             50
#define ID_Import                       51
#define IDS_FileOpenError               52
#define IDS_GPCConversionError          53
#define IDS_RemovedInvalid              54
#define IDS_BadFileChars                54
#define IDS_UnusedFont                  55
#define IDS_ResourceID                  56
#define IDS_WidthColumn0                57
#define IDS_WidthColumn1                58
#define IDS_KernColumn0                 59
#define IDS_KernColumn1                 60
#define IDS_KernColumn2                 61
#define IDS_InvalidNumberFormat         62
#define ID_ChangeAmount                 63
#define IDS_CapH                        64
#define IDS_LowerX                      65
#define IDS_SuperSizeX                  66
#define IDS_SuperSizeY                  67
#define IDS_SubSizeX                    68
#define IDS_SubSizeY                    69
#define IDS_SuperMoveX                  70
#define IDS_SuperMoveY                  71
#define IDS_SubMoveX                    72
#define IDS_SubMoveY                    73
#define IDS_ItalicAngle                 74
#define IDS_UnderSize                   75
#define IDS_UnderOffset                 76
#define IDS_StrikeSize                  77
#define IDS_StrikeOffset                78
#define IDS_Baseline                    79
#define IDS_InterlineGap                80
#define IDS_Lowerp                      81
#define IDS_Lowerd                      82
#define IDS_InternalLeading             83
#define IDS_Overweight                  84
#define IDS_InvalidCharSet              85
#define IDS_InvalidCharacter            86
#define IDS_NoDBCS                      87
#define IDS_LimitsSwapped               88
#define IDS_NotWindowed                 89
#define IDS_ScaleReversed               90
#define IDS_WidthReversed               91
#define IDS_AngleTooBig                 92
#define IDS_BadCTTID                    93
#define IDS_NoSyntaxErrors              94
#define IDS_NoUnicodePoint              95
#define IDS_InvalidCTTFormat            96
#define IDS_WaitToFill                  97
#define IDS_NoGPCData                   98
#define IDS_RCFindPrompt                99
#define IDD_ABOUTBOX                    100
#define IDS_Resources                   100
#define IDS_Strings                     101
#define IDD_FORMVIEW                    101
#define CG_IDS_PHYSICAL_MEM             102
#define CG_IDS_DISK_SPACE               103
#define CG_IDS_DISK_SPACE_UNAVAIL       104
#define IDB_LIGHTBULB                   105
#define IDS_GPDSelInitFailed            105
#define IDD_TIP                         106
#define IDS_DupGPDFName                 106
#define CG_IDS_TIPOFTHEDAY              107
#define CG_IDS_TIPOFTHEDAYMENU          108
#define CG_IDS_DIDYOUKNOW               109
#define CG_IDS_FILE_ABSENT              110
#define CG_IDP_FILE_CORRUPT             111
#define CG_IDS_TIPOFTHEDAYHELP          112
#define ID_LineIndicator                113
#define IDS_SelectAll                   113
#define IDR_CP1252                      114
#define IDS_DeselectAll                 114
#define IDR_MAINFRAME                   128
#define IDR_MINIWSTYPE                  129
#define IDD_FirstPageNewWizard          130
#define IDD_NPWSelectDest               131
#define IDD_NPWSelectTargets            132
#define IDD_NPWDefaultCodePageSel       133
#define IDD_RunUniTool                  136
#define IDD_ConvertFiles                137
#define IDD_GPCEditor                   138
#define IDD_ProjectForm                 139
#define IDR_GLYPHMAP                    140
#define IDD_GlyphMappings               142
#define IDD_NPWCodePageSelection        143
#define IDD_SelectPage                  144
#define IDD_CodePageView                145
#define IDD_PredefinedPage              146
#define IDD_AddCodePoints               147
#define IDR_FONT_VIEWER                 148
#define IDD_UFM1_Dlg                    150
#define IDB_PlusButton                  152
#define IDB_DeleteButton                153
#define IDR_GPD_VIEWER                  155
#define IDB_Wizard                      156
#define IDD_GPDErrors                   157
#define IDD_GPDActionBar                157
#define IDD_KerningPairs                166
#define IDD_FontSimulations             168
#define IDI_BrowseArrow                 173
#define IDD_AddKernPair                 175
#define IDD_FILE_NEW_DIALOG             176
#define IDD_UFM2_dpCharSet_Dlg          178
#define IDD_UFM2_dpCharSets_Dlg         178
#define IDD_WSCheck                     179
#define IDD_DIALOG1                     181
#define IDD_StringEditor                182
#define IDD_UFM3_Dlg                    183
#define IDD_UFM2_flINFO_DIALOG          185
#define IDD_DIALOG2                     186
#define IDD_UFM2_PANOSE_DLG             188
#define IDD_RECT_DLG                    189
#define IDD_POINT_DLG                   190
#define IDD_BASE_DIALOG                 191
#define IDD_GotoLine                    192
#define IDD_ErrorLevel                  193
#define IDD_UFM2_fsSelection_Dlg        195
#define IDD_UFM2_jWinPitchAndFamily_Dlg 197
#define IDD_UFM2_jWinCharSet_Dlg        198
#define IDD_UpgDefCPage                 199
#define IDD_UFM2_Dlg                    200
#define IDD_UFM1_fCaps_Dlg              201
#define IDD_UFM1_wType_Dlg              202
#define IDD_CharWidths                  203
#define IDD_UFM1_flGenFlags_Dlg         204
#define IDD_INFW_Sub_NewSection         205
#define IDD_UFM2_Family_Dlg             206
#define IDD_INFCheck                    207
#define IDD_UFM3_ExtMetrics             208
#define IDD_UFM2_IFIMetrics             209
#define IDD_UFM1_Header                 210
#define IDD_UFM1S_GenFlags              211
#define IDD_UFM1S_Caps                  212
#define IDD_UFM1S_Types                 213
#define IDD_UFM2S_Rect                  214
#define IDD_UFM2S_CharSets              215
#define IDD_UFM2S_Family                216
#define IDD_UFM2S_FontSims              217
#define IDD_UFM2S_Info                  218
#define IDD_UFM2S_Panose                219
#define IDD_UFM2S_Point                 220
#define IDD_UFM2S_Selection             221
#define IDD_UFM2S_WinCharSet            222
#define IDD_UFM2S_WinPitchFamily        223
#define IDD_WidthKernCheckResults       224
#define IDD_INFW_IncludeFiles           225
#define IDD_INFW_InstallSections        226
#define IDD_INFW_DataSections           227
#define IDD_INFW_NonStdModelSecs        228
#define IDD_INFW_ModelPnPIDS            229
#define IDD_NewFiles                    230
#define IDD_NewFile                     230
#define IDB_MULTI_ICONS                 231
#define IDB_BITMAP1                     232
#define IDB_MAINFRAME                   233
#define IDB_GPD_VIEWER                  234
#define IDB_GLYPHMAP                    235
#define IDB_FONT_VIEWER                 236
#define IDB_MINIWSTYPE                  237
#define IDD_ProjNew                     238
#define IDD_NewConvert                  239
#define IDD_FILE_PRINT                  240
#define IDD_DIALOG3                     241
#define IDD_DIALOG4                     243
#define IDD_NEW_PROJECT                 244
#define IDD_DIALOG6                     245
#define IDD_NewResource                 246
#define IDB_BITMAP2                     249
#define IDB_SMALLGLYPH                  254
#define IDD_ConvertPFM                  255
#define IDD_ConvertCTT                  256
#define IDC_TargetW2000                 1000
#define IDC_BULB                        1000
#define IDC_TargetNT40                  1001
#define IDC_W2000Destination            1001
#define IDC_STARTUP                     1001
#define IDC_BrowseW2000                 1002
#define IDC_TargetNT3x                  1002
#define IDC_NEXTTIP                     1002
#define IDC_NT40Destination             1003
#define IDC_RunUniTool                  1003
#define IDC_TargetWin95                 1004
#define IDC_BrowseNT40                  1004
#define IDC_PhysicalMemory              1004
#define IDC_TIPSTRING                   1004
#define IDC_FreeDiskSpace               1005
#define IDC_NT3xDestination             1005
#define IDC_RunNtGpcEdit                1005
#define IDC_BrowseNT3x                  1006
#define IDC_ConvertFiles                1006
#define IDC_CodePages                   1006
#define IDC_DriverName                  1007
#define IDC_DriverView                  1008
#define IDC_Win95Destination            1009
#define IDC_GlyphMapping                1009
#define IDC_InstalledPages              1010
#define IDC_SupportedPages              1011
#define IDC_TableToPage                 1011
#define IDC_ChangeCodePage              1012
#define IDC_CodePageList                1014
#define IDC_CurrentPage                 1015
#define IDC_SelectString                1016
#define IDC_DeselectString              1017
#define IDC_AddPage                     1018
#define IDC_RemovePage                  1019
#define IDC_NoPredefined                1020
#define IDC_PredefinedAddTo             1021
#define IDC_RemovePredefined            1022
#define IDC_ReplacePredefined           1023
#define IDC_PredefinedList              1024
#define IDC_GlyphList                   1025
#define IDC_FamilyNames                 1026
#define IDC_FaceName                    1027
#define IDC_UniqueName                  1028
#define IDC_FixedPitch                  1029
#define IDC_VariablePitch               1030
#define IDC_Italic                      1031
#define IDC_Underline                   1032
#define IDC_StrikeOut                   1033
#define IDC_AddFamily                   1034
#define IDC_RemoveFamily                1035
#define IDC_StyleName                   1036
#define IDC_Errors                      1037
#define IDC_RemoveError                 1038
#define IDC_Previous                    1039
#define IDC_Next                        1040
#define NormalConversion                1041
#define CustomConversion                1042
#define IDC_Direct                      1043
#define IDC_Macros                      1044
#define IDC_Common                      1045
#define IDC_SpoolerNames                1046
#define IDC_FamilyBits                  1047
#define IDC_CharSet                     1048
#define IDC_FontWeight                  1049
#define IDC_FontHeight                  1051
#define IDC_FontWidth                   1052
#define IDC_SpecialMetric               1053
#define IDC_FontSpecialValue            1054
#define IDC_SpinFontSpecial             1055
#define IDC_Scalable                    1057
#define IDC_MasterDevice                1059
#define IDC_MasterFont                  1060
#define IDC_PortraitFont                1061
#define IDC_LandscapeFont               1062
#define IDC_MinimumScale                1063
#define IDC_MaximumScale                1064
#define IDC_ScalePoints                 1065
#define IDC_ScaleDevice                 1066
#define IDC_KerningTree                 1067
#define IDC_CharacterWidths             1068
#define IDC_FirstCharacter              1069
#define IDC_LastCharacter               1070
#define IDC_DefaultCharacter            1071
#define IDC_BreakCharacter              1072
#define IDC_ShowANSI                    1073
#define IDC_UnicodeShown                1074
#define IDC_EnableItalicSim             1076
#define IDC_EnableBoldSim               1077
#define IDC_EnableBISim                 1078
#define IDC_ItalicWeight                1079
#define IDC_IMaxWidth                   1080
#define IDC_IAverage                    1081
#define IDC_ItalicSlant                 1082
#define IDC_BoldWeight                  1083
#define IDC_BMaxWidth                   1084
#define IDC_BAverage                    1085
#define IDC_BIWeight                    1086
#define IDC_BIMaxWidth                  1087
#define IDC_BIAverage                   1088
#define IDC_BoldItalicSlant             1089
#define IDC_FontSelector                1090
#define IDC_FontUnselector              1091
#define IDC_FontLocation                1092
#define IDC_FontTechnology              1093
#define IDC_VerticalResolution          1094
#define IDC_HorizontalResolution        1095
#define IDC_PreAdjustY                  1096
#define IDC_PostAdjustY                 1097
#define IDC_CenteringAdjustment         1098
#define IDC_PrivateData                 1099
#define IDC_GTTDescription              1100
#define IDC_ItalicSim                   1101
#define IDC_CanUnderline                1102
#define IDC_CROK                        1103
#define IDC_BoldSim                     1104
#define IDC_DoubleUnderline             1105
#define IDC_StrikeThru                  1106
#define IDC_Backspace                   1107
#define IDC_KernFirst                   1112
#define IDC_KernSecond                  1113
#define IDC_KernAmount                  1114
#define IDC_Overstrike                  1115
#define IDC_Banner                      1116
#define IDC_CopyPrompt                  1119
#define IDC_CopyName                    1120
#define IDC_ResourceLabel               1121
#define IDC_ResourceName                1122
#define IDC_ResIDLabel                  1123
#define IDC_CurResID                    1124
#define IDC_NewResID                    1125
#define IDC_ProjectLabel                1127
#define IDC_CHECK1                      1128
#define IDC_ECName                      1128
#define IDC_ECValue                     1129
#define IDC_ECList                      1130
#define IDC_rbConvertOrGeneric          1131
#define IDC_GPDSelBtn                   1131
#define IDC_rbConvertOrGeneric2         1132
#define IDC_ErrWrnLstBox                1132
#define IDC_rbColorLaser                1133
#define IDC_RecheckBtn                  1133
#define IDC_rbMonochromeLaser           1134
#define IDC_WSCLabel                    1134
#define IDC_rbColorSerial               1135
#define IDC_rbMonochromeSerial          1136
#define IDC_RADIO1                      1137
#define IDC_LIST1                       1137
#define IDC_ErrorLst                    1137
#define IDC_SELabel1                    1138
#define IDC_SELabel2                    1139
#define IDC_SELabel3                    1140
#define IDC_SELstCtrl                   1141
#define IDC_SEGotoBtn                   1142
#define IDC_SEGotoBox                   1143
#define IDC_SESearchBox                 1144
#define IDC_SESearchBtn                 1145
#define IDC_SrchNextBtn                 1146
#define IDC_SrchPrevBtn                 1147
#define IDC_SearchBox                   1148
#define IDC_GotoBox                     1149
#define IDC_UndoBtn                     1150
#define IDC_GotoBtn                     1151
#define IDC_SyntaxBtn                   1152
#define IDC_EWLevelBox                  1153
#define IDC_EWLst                       1153
#define IDC_EditAidsCBox                1154
#define IDC_ErrorLabel                  1155
#define IDC_LIST2                       1156
#define IDC_BUTTON1                     1157
#define IDC_ebUFM1_DefaultCodepage      1158
#define IDC_BUTTON2                     1158
#define IDC_ebUFM1_GlyphSetDataRCID     1159
#define IDC_EDIT1                       1159
#define IDC_CTTBrowser                  1159
#define IDC_EDIT2                       1160
#define IDC_cb_FamilyNames              1162
#define IDC_COMBO1                      1166
#define IDC_ErrorLevelLst               1166
#define IDC_NEWFILES_PROJECT            1166
#define IDC_PRINT_COMBO                 1166
#define IDC_ComboCodePage               1166
#define IDC_ModelsList                  1167
#define IDC_BrowseBtn                   1168
#define IDC_ModelsLst                   1169
#define IDC_ProfileFSpecsBox            1170
#define IDC_ManufacturerBox             1171
#define IDC_eb_Fields                   1172
#define IDC_ProviderBox                 1172
#define IDC_eb_Values                   1173
#define IDC_SectionLst                  1173
#define IDC_lb_Strings                  1174
#define IDC_KeyValueBox                 1174
#define IDC_ModelLst                    1175
#define IDC_BrowsBtn                    1176
#define IDC_SummaryBox                  1177
#define IDC_ICMFSpecsLst                1178
#define IDC_ExtraFSpecsLst              1179
#define IDC_KeyValueLst                 1180
#define IDC_NewSectionBtn               1181
#define IDOK_Subclassed                 1182
#define IDC_NewSectionBox               1182
#define IDC_INFCLabel                   1183
#define IDC_cb_UFM2_Family              1184
#define IDC_UniDrvLst                   1184
#define IDC_pb_UFM2_Family_Add          1185
#define IDC_DefaultCodepageBox          1185
#define IDC_pb_UFM2_Family_Remove       1186
#define IDC_GlyphSetDataRCIDBox         1186
#define IDC_IFIMetricsLst               1187
#define IDC_ExtMetricsLst               1188
#define IDC_SaveCloseChk                1189
#define IDC_FlagsLst                    1190
#define IDC_PointsLst                   1192
#define IDC_PanoseLst                   1193
#define IDC_NamesLst                    1194
#define IDC_RectLst                     1195
#define IDC_BadKerningPairs             1196
#define IDC_WidthTblResults             1197
#define IDC_KernTblResults              1198
#define IDC_IncludeFileBox              1199
#define IDC_UnidrvChk                   1200
#define IDC_UnidrvBidiChk               1201
#define IDC_PscriptChk                  1202
#define IDC_OtherChk                    1203
#define IDC_TtfsubChk                   1204
#define IDC_OtherBox                    1205
#define IDC_ModelSectionLst             1207
#define IDC_ModelsPnPIDList             1208
#define IDC_ReplacePage                 1209
#define IDC_NEWFILES_LIST               1210
#define IDC_NEWFILES_FILENAME           1211
#define IDC_NEWFILENAME                 1211
#define IDC_NEWFILES_LOCATION           1212
#define IDC_FILE_LOC                    1212
#define IDC_CHECK_PROJECT               1213
#define IDC_EDIT_PRJ_NAME               1214
#define IDC_STATIC_ADDTOPRJ             1215
#define IDC_DeletePage                  1216
#define IDC_Browser                     1217
#define IDC_PRINT_ALL                   1220
#define IDC_PRINT_SELECTED              1221
#define IDC_PRINT_SETUP                 1222
#define IDC_CHECK2                      1224
#define IDC_CHECK3                      1225
#define IDC_CHECK4                      1226
#define IDC_CHECK5                      1227
#define IDC_CHECK6                      1228
#define IDC_TREE1                       1232
#define IDC_CHECK7                      1233
#define IDC_CHECK8                      1234
#define IDC_CHECK9                      1235
#define IDC_CHECK10                     1236
#define IDC_EDIT3                       1237
#define IDC_EDIT_RESOUREC               1237
#define IDC_PfmFiles                    1237
#define IDC_UFM_PATH                    1238
#define IDC_GttPath                     1238
#define IDC_NEW_PROJECT                 1239
#define IDC_GTT_PATH                    1239
#define IDC_CONVERT                     1240
#define IDC_CONV_PRJ                    1240
#define IDC_CHECK_FONTS                 1241
#define IDC_SerchUFM                    1242
#define IDC_SearchGTT                   1243
#define IDC_EDIT_NPRJNAME               1244
#define IDC_EDIT_NPRJLOC                1245
#define IDC_Search_PRJ                  1246
#define IDC_DirBrowser                  1247
#define IDC_EDIT_AddTName               1249
#define IDC_EDIT_AddTPath               1250
#define IDC_CHECK_ADD                   1251
#define IDC_LIST_ProjectTemplate        1252
#define IDC_AddTemplate                 1253
#define IDC_EDIT_MODEL                  1254
#define IDC_EDIT_GPD                    1255
#define IDC_CONV_UFM                    1256
#define IDC_CONV_PFM                    1256
#define IDC_CONV_GTT                    1257
#define IDC_CONV_CTT                    1257
#define IDC_PFMBrowser                  1258
#define IDC_EDIT_CTTFile                1259
#define IDC_GTTBrowser                  1259
#define IDC_COMBO_Codepage              1260
#define IDC_UfmDirBrowser               1260
#define IDC_GttDirectory                1261
#define IDC_UfmDir                      1262
#define IDS_Unknown                     2000
#define IDS_RCUFM                       2001
#define IDS_RCGTT                       2002
#define IDS_RCUNK                       2003
#define ID_CopyItem                     2004
#define ID_ChangeID                     2005
#define IDS_FontDir                     2006
#define IDS_GTTDir                      2007
#define IDS_AddCopyFailed               2008
#define IDS_AddDupError                 2009
#define IDS_RCWriteError                2010
#define IDS_CopyCopyFailed              2011
#define IDS_CopyNameError               2012
#define IDS_CopyPrompt                  2013
#define IDS_GPDReminder                 2014
#define IDS_ResourceLabel               2015
#define IDS_IDNotUnique                 2016
#define IDD_DeleteQuery                 2017
#define IDS_DeletePrompt                2017
#define IDC_DeletePrompt                2018
#define ID_CheckWS                      2018
#define IDC_Remove                      2019
#define IDS_FILE_CheckWS                2019
#define IDD_CopyItem                    2020
#define IDS_RCExt                       2020
#define IDD_ChangeID                    2021
#define IDS_W31Ext                      2021
#define IDD_FILEOPENORD                 2022
#define IDS_RCTables                    2022
#define IDS_RCTabID                     2023
#define IDD_NPWGPDSelection             2023
#define IDD_INFW_Welcome                2024
#define IDS_RCTabFile                   2024
#define IDD_INFW_ChooseModels           2025
#define IDS_SwitchToW31                 2025
#define IDD_INFW_MfgName                2026
#define IDS_BadNT4File                  2026
#define IDD_INFW_FileName               2027
#define IDS_NoGPDsPrompt                2027
#define IDD_INFW_BiDi                   2028
#define IDS_DupInvRCID                  2028
#define IDD_INFW_ICMProfiles            2029
#define IDS_NoFSpecInRCLine             2029
#define IDD_INFW_ExtraFiles             2030
#define IDS_ORangeRCID                  2030
#define IDD_INFW_NonStdElements         2031
#define IDS_GTTSetName                  2031
#define IDD_INFW_Summary                2032
#define IDS_UFMSetName                  2032
#define IDS_ConvErrors                  2033
#define IDS_FileReadError               2034
#define IDS_UnicodeConvFailed           2035
#define IDS_Invalid2CTTFormat           2036
#define IDS_PFMTooSmall                 2037
#define IDS_PFMCharError                2038
#define IDS_BadPFMInfoOffset            2039
#define IDS_BadPFMInfoVersion           2040
#define IDS_FileWriteError              2041
#define IDS_UFMGenError                 2042
#define IDS_FatalConvErrors             2043
#define IDS_UFMCompError                2044
#define IDS_GTTTidyWarning              2045
#define IDS_BadGPDError                 2046
#define IDS_GPDUFMCompError             2047
#define IDS_UFMTidyWarning              2048
#define IDS_GPDStrCompError             2049
#define IDS_StrTidyWarning              2050
#define IDS_GPDModNameCompError         2051
#define IDS_GPDFileNameCompError        2052
#define IDR_WSCHECK                     2053
#define IDS_WSCloseCheckPrmt            2054
#define IDS_WSCheckTitle                2055
#define IDS_NoWSProblems                2056
#define IDS_NoVersionError              2057
#define IDS_RCRewriteQuestion           2058
#define IDS_UFMSetGTTID                 2059
#define IDS_UnexpectedCPError           2060
#define IDR_STRINGEDITOR                2060
#define IDS_StringEditorTitle           2061
#define IDS_StrEditRCIDColLab           2062
#define IDS_StrEditStringColLab         2063
#define IDS_BadGotoRCID                 2064
#define IDS_NoGotoRCID                  2065
#define IDS_BadSearchString             2066
#define IDS_NoSearchString              2067
#define IDS_SaveStrTabPrompt            2068
#define IDS_InvalidRCID                 2069
#define IDS_DuplicateRCID               2070
#define IDS_EmptyStringInStrTab         2071
#define IDS_UnusualError                2072
#define IDS_ErrorLabel                  2073
#define IDS_BadGotoLineNum              2074
#define IDS_GPDBackupFailed             2075
#define IDS_HeapCFailed                 2076
#define IDS_ConvCTTFailed               2077
#define IDS_RCForUFMPrompt              2078
#define IDS_UFMCompWarning              2079
#define MAPPING_TABLE                   2622
#define IDS_XXXUnexpectedCPError        2623
#define IDS_ReqOSError                  2624
#define IDS_Delete2ItemQuery            2625
#define IDS_StandAloneFontLoad          2626
#define IDS_CantStoreStandAlone         2627
#define IDS_GPDStringSearchFailed       2628
#define IDS_MDWUpgradeMsg1              2629
#define IDS_MDWUpgradeMsg2              2630
#define IDS_RCFileChanging              2631
#define IDS_RCRepFailed1                2632
#define IDS_RCCommentHdr1               2633
#define IDS_RCCommentHdr2               2634
#define IDS_RCCommentHdr3               2635
#define IDS_StdIncludeFile1             2636
#define IDS_StdIncludeFile2             2637
#define IDS_StdIncludeFile3             2638
#define IDS_StdIncludeFile4             2639
#define IDS_StdIncludeFile5             2640
#define IDS_IncStmt                     2641
#define IDS_OldIncludeFile1             2642
#define IDS_MDWTooNewError              2643
#define IDS_UpdateRCFile                2644
#define IDS_MustSelCP                   2645
#define IDS_HeapInGLoad                 2646
#define IDS_PGetFailedInGLoad           2647
#define IDS_INFWizTitle                 2648
#define IDS_INFModelsColLab             2649
#define IDS_INFIncludesColLab           2650
#define IDS_INFModelsToggleStr          2651
#define IDS_INFNoModelsSel              2652
#define IDS_INFBiDiColLab               2653
#define IDS_INFBiDiToggleStr            2654
#define IDS_INFICMColLab                2655
#define IDS_CommonRCFile                2656
#define IDS_CommonICMFile               2657
#define IDS_INFExFilesColLab            2658
#define IDS_CommonExtraFile             2659
#define IDS_NoMfgError                  2660
#define IDS_NoMfgAbbrevError            2661
#define IDS_NonStdColLab                2662
#define IDS_ModelsSumTxt                2663
#define IDS_BIDISumTxt                  2664
#define IDS_NoneSumTxt                  2665
#define IDS_ICMSumTxt                   2666
#define IDS_NonStdFilesSumTxt           2667
#define IDS_MfgSumTxt                   2668
#define IDS_ProvSumTxt                  2669
#define IDS_NonStdSecSumTxt             2670
#define IDR_INF_FILE_VIEWER             2671
#define ID_FILE_Check_INF               2672
#define ID_FILE_Change_INF              2673
#define IDS_INFText_HeaderCmt           2674
#define IDS_INFText_Version             2675
#define IDS_INFText_PCAddr              2676
#define IDS_INFText_MfgCmt              2677
#define IDS_INFText_Manufacturer        2678
#define IDS_INFText_ClInst32            2679
#define IDS_INFText_ModCmt              2680
#define IDS_INFText_CopySecCmt          2681
#define IDS_INFText_CopyKey             2682
#define IDS_INFText_CopyDataEntry       2683
#define IDS_INFText_UNIDRV              2684
#define IDS_INFText_UnidrvSec           2685
#define IDS_INFText_UnidrvDataSec       2686
#define IDS_INFText_InstallCmt          2687
#define IDS_INFText_DestDirs            2688
#define IDS_INFText_SrcDiskNamesI       2689
#define IDS_INFTextSrcDiskFilesHdr      2690
#define IDS_INFText_CtrlFlags           2691
#define IDS_INFText_Strings             2692
#define IDS_INFText_SrcDiskNamesA       2693
#define IDS_INFTextSrcDiskFilesEntry    2694
#define IDS_INFText_SrcDiskFilesEntry   2694
#define IDS_INFText_UnidrvSrcDskFiles   2695
#define IDS_INFFile                     2720
#define IDS_INFGPDReadError             2721
#define IDS_INFNoModelsError            2722
#define IDS_INFOpenError                2723
#define IDR_INFCHECK                    2724
#define IDS_INFChk_NoModErr             2725
#define IDS_INFChk_NoIncFileErr         2726
#define IDS_INFChk_GPDReadErr           2727
#define IDS_INFChk_NoICMFileErr         2728
#define IDS_INFChk_NoNonStdFileErr      2729
#define IDS_INFChk_NoResDLLErr          2730
#define IDS_INFChecksOK                 2731
#define IDS_INFCheckTitle               2732
#define IDS_UFMTooSmallError            2733
#define IDS_ReservedRCIDUsed            2734
#define IDS_BadKernPairError            2735
#define IDS_NoFamilyNamesError          2736
#define IDS_MissingFieldError           2737
#define IDS_LessEqZeroError             2738
#define IDS_EmptyStrError               2739
#define IDS_LessZeroError               2740
#define IDS_GrterEqZeroError            2741
#define IDS_EqualsZeroError             2742
#define IDS_EqFieldsError               2743
#define IDS_BadWidth                    2744
#define IDS_NoGTTForUFMError            2745
#define IDS_NoGTTForUFMFatalError       2746
#define IDS_GTTCPChangedMsg             2747
#define IDS_CPID                        2748
#define IDS_GTTID                       2749
#define IDS_WidthsTableOK               2750
#define IDS_WidthsTableTooBig           2751
#define IDS_KerningTableBadEnts         2752
#define IDS_KerningTableOK              2753
#define IDS_DefINFIncFile               2754
#define IDS_INFMissingIncError          2755
#define IDS_INFMissingInstSecError      2756
#define IDS_INFNoOtherStrError          2757
#define IDS_IncFilesSumTxt              2758
#define IDS_InstSecsSumTxt              2759
#define IDS_DataSecsSumTxt              2760
#define IDS_InstSecUni                  2761
#define IDS_InstSecUniBiDi              2762
#define IDS_InstSecPScript              2763
#define IDS_InstSecTtf                  2764
#define IDS_DataSecUni                  2765
#define IDS_DataSecUniBiDi              2766
#define IDS_DataSecPScript              2767
#define IDS_INFText_IncludeKey          2768
#define IDS_INFText_NeedsKey            2769
#define IDS_INFText_DataSecKey          2770
#define IDS_INFMissingDataSecError      2771
#define IDS_INFText_DataFileKey         2772
#define IDS_INFSecNeededColLab          2773
#define IDS_INF_NSMS_ToggleStr          2774
#define IDS_NonStdModelsSumTxt          2775
#define IDS_INFNoDLLError               2776
#define IDS_INFPnPIDColLab              2777
#define IDS_PnPIDSumTxt                 2778
#define IDS_INFText_ICMDest             2779
#define IDS_PnPSpacesError              2780
#define IDS_GTTCPOnlySaved              2781
#define IDS_UFMOKNow                    2782
#define IDS_UnExpFilTypError            2783
#define IDS_MDWExtension                2784
#define IDS_CTTFarEastCPError           2785
#define IDS_OldDriverRootDir            2786
#define IDS_NewDriverRootDir            2787
#define IDS_BadDestPath                 2788
#define IDS_ResourceError               2789
#define IDS_LoadGTTError                2790
#define IDS_StrEditNoSave               2791
#define IDS_NotFoundRC                  2792
#define IDS_StrEditNoEdit               2793
#define IDS_NewUFM                      2794
#define IDS_NewUFMError                 2795
#define IDS_NewGTT                      2796
#define IDS_NewGTTError                 2797
#define IDS_FileNewExist                2798
#define IDS_FileAlreadExist             2799
#define IDS_FileCreateDirectory         2800
#define IDS_NoFileName                  2801
#define IDS_TemplateCreated             2802
#define IDS_FailCreateTemplate          2803
#define IDS_FailCreateTempDir           2804
#define ID_FILE_GENERATEMAPS            32771
#define ID_FILE_PARSE                   32772
#define ID_FILE_INF                     32773
#define ID_FILE_CheckWS                 -32759
#define ID_EDIT_GOTO                    32778
#define ID_EDIT_ENABLE_AIDS             32779
#define ID_FILE_ERROR_LEVEL             32780
#define ID_BOGUS_SBOX                   32783
#define ID_BOGUS_NBTN                   32784
#define ID_BOGUS_PBTN                   32785
#define ID_SrchNextBtn                  32786
#define ID_SrchPrevBtn                  32787
#define ID_BUTTON32788                  32788
#define ID_PROJECT_NEW                  32790
#define ID_PROJECT_INSERT               32791
#define IDM_FILE_PRINT                  32793
#define ID_PROJECT_INSERT_UFM           32794
#define ID_PROJECT_INSERT_GTT           32795
#define ID_PROJECT_INSERT_GPD           32796
#define IDR_NEWFILE                     32797
#define IDR_NEWPROJECT                  32798
#define IDR_NEWSOURCES                  32799
#define IDR_STRINGTABLE                 32800

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        258
#define _APS_NEXT_COMMAND_VALUE         32797
#define _APS_NEXT_CONTROL_VALUE         1264
#define _APS_NEXT_SYMED_VALUE           115
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stdafx.h ===
/******************************************************************************

  Source File:  StdAfx.H

  This is a standard MFC file.  It includes everything we want to have 
  pre-compiled through StdAfx.CPP.  Hence items being worked on never belong 
  here.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.
  
  A Pretty Penny Enterprises Production

  Change History:
  03-03-1997    Bob_Kjelgaard@Prodigy.Net   Created it when I re-orged the
                project.

******************************************************************************/

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include    <AfxWin.H>      // MFC core and standard components
#include    <AfxExt.H>      // MFC extensions
#include    <AfxCmn.H>		// MFC support for Windows Common Controls
#include    <AfxRich.H>     // MFC Support for rich edit controls and views

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxpriv.h>


// Identifies this program in other include files.  First use is in DEBUG.H.

#define __MDT__		1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\rcfile.h ===
/******************************************************************************

  Header File:  Driver Resources.H

  This defines the CDriverResource class, which contains all of the information
  required to build the RC file for the mini-driver.

  It contains a list of all of the #include files, any #define'd constants
  (which will now go to a separate header file), the GPC tables, of all of the
  fonts (in all three formats) and glyph translation tables (again, in all 3
  formats).  It is designed to be initializaed by reading the Win 3.1 RC file,
  and a member function can then generate the RC file for any desired version.

  We allow UFM and GTT files to be added to the list without having an 
  associated PFM, as one purpose of this tool is to wean people away from
  UniTool.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production.

  Change History:
  02-08-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(DRIVER_RESOURCES)

#define DRIVER_RESOURCES

#include    "GTT.H"				//  Glyph Mapping classes
#include    "FontInfo.H"		//  Font information classes
#include    "GPDFile.H"
#include    "utility.H"


class CWSCheckDoc ;				// Forward declaration


// Definitions used during string ID verification to skip string IDs that are
// in COMMON.RC.

#define	FIRSTCOMMONRCSTRID	1000
#define	LASTCOMMONRCSTRID	2400


class CDriverResources : public CBasicNode {

    DECLARE_SERIAL(CDriverResources)

    BOOL                m_bUseCommonRC;

    CStringArray        m_csaIncludes, m_csaTables;

    CStringArray        m_csaDefineNames, m_csaDefineValues;

    //  The String table is a separate class, defined above
    
    CStringTable        m_cst;

	// Manages selected GPDs file names
	
	CStringArray		m_csaModelFileNames ;	

    //  TODO:   Handle the version resource so it is under project control

    //  For now, simply let it and any other untranslated lines sit in another
    //  array.

    CStringArray        m_csaRemnants;

    //  Collections of Various items of interest

    CFixedNode          m_cfnAtlas, m_cfnFonts, m_cfnModels;
    CSafeObArray        m_csoaAtlas, m_csoaFonts, m_csoaModels;
    CFixedNode          m_cfnResources ;	// "Resources" node in workspace view
    CSafeObArray        m_csoaResources ;	// An empty place holder
    CStringsNode        m_csnStrings ;		// "Strings" node in workspace view
    CSafeObArray        m_csoaStrings ;		// An empty place holder
    COldMiniDriverData  m_comdd;
    unsigned            m_ucSynthesized;    //  "Artificial" UFM count

    enum    {ItWorked, ItFailed, ItWasIrrelevant};

    UINT    CheckTable(int iWhere, CString csLine, CStringArray& csaTarget,
                       BOOL bSansExtension = TRUE);
    UINT    CheckTable(int iWhere, CString csLine, CStringTable& cstTarget);

    BOOL    AddStringEntry(CString  csDefinition, CStringTable& cstrcstrings);

    CString m_csW2000Path ;		// Path to Win2K files

	CStdioFile*	m_pcsfLogFile ;	// Used to write log file
	bool		m_bErrorsLogged ;	// True iff errors have been written to the log file
	CString		m_csConvLogFile ;	// Conversion log file name

	// Workspace consistency checking related variables

	CWSCheckDoc*	m_pwscdCheckDoc ;		// Checking window document
	bool			m_bFirstCheckMsg ;	// True iff next check msg will be first one
	bool			m_bIgnoreChecks ;	// True iff WS check problems should be ignored
	CMDIChildWnd*	m_pcmcwCheckFrame ;	// Checking window frame

public:
	CDriverResources() ;
	~CDriverResources() ;
	
	BOOL SyncUFMWidth();
	void CopyResources(CStringArray& pcsaUFMFiles,CStringArray& pcsaGTTFiles, CString& pcsModel,CStringArray& cstrcid);

    //  Attributes
    CString     GPCName(unsigned u);
    unsigned    MapCount() const { return m_csoaAtlas.GetSize(); }
    CGlyphMap&  GlyphTable(unsigned u) { 
        return *(CGlyphMap *) m_csoaAtlas[u]; 
    }
    unsigned    FontCount() const { return m_csoaFonts.GetSize(); }
    unsigned    OriginalFontCount() const { 
        return FontCount() - m_ucSynthesized; 
    }
    CFontInfo&  Font(unsigned u) const { 
        return *(CFontInfo *) m_csoaFonts[u]; 
    }

    unsigned    Models() const { return m_csoaModels.GetSize(); }
    CModelData&  Model(unsigned u) const { 
        return *(CModelData *) m_csoaModels[u];
    }

	CString		GetW2000Path() { return m_csW2000Path ; }

	CStringTable* GetStrTable() { return &m_cst ; }
    
	//  Operations
    BOOL    Load(class CProjectRecord& cpr);
	bool	LoadRCFile(CString& csrcfpec, CStringArray& csadefinenames, 
				CStringArray& csadefinevalues, CStringArray& csaincludes, 
				CStringArray& csaremnants, CStringArray& csatables, 
				CStringTable& cstrcstrings, CStringTable& cstfonts, 
				CStringTable& cstmaps, UINT ufrctype) ;
    BOOL    LoadFontData(CProjectRecord& cpr);
    BOOL    ConvertGPCData(CProjectRecord& cpr, WORD wfGPDConvert);
    BOOL    Generate(UINT ufTarget, LPCTSTR lpstrPath);
	void	RemUnneededRCDefine(LPCTSTR strdefname) ;
	void	RemUnneededRCInclude(LPCTSTR strincname) ;

	// The next 3 functions support the GPD Selection feature in the Conversion
	// Wizard.

	BOOL    GetGPDModelInfo(CStringArray* pcsamodels, CStringArray* pcsafiles) ;
	int		SaveVerGPDFNames(CStringArray& csafiles, bool bverifydata) ;
	void   GenerateGPDFileNames(CStringArray& csamodels, CStringArray& csafiles) ;

    void    ForceCommonRC(BOOL bOn) { m_bUseCommonRC = bOn; }

	// The next group of functions handle conversion log file management.

	bool	OpenConvLogFile(CString cssourcefile) ;
	void	CloseConvLogFile(void) ;
	void	LogConvInfo(int nmsgid, int numargs, CString* pcsarg1 = NULL, 
	    				int narg2 = 0) ;
	CString	GetConvLogFileName() const {return m_csConvLogFile ; }
	bool	ThereAreConvErrors() {return m_bErrorsLogged ; }
	BOOL	ReportFileFailure(int idMessage, LPCTSTR lpstrFile) ;

	// The next group of functions handle checking a workspace for completeness
	// and tidiness.

	bool	WorkspaceChecker(bool bclosing) ;
	void	DoGTTWorkspaceChecks(bool bclosing, bool& bwsproblem) ;
	void	DoUFMWorkspaceChecks(bool bclosing, bool& bwsproblem) ;
	void	DoStringWorkspaceChecks(bool bclosing, bool& bwsproblem)	;
	void	DoGPDWorkspaceChecks(bool bclosing, bool& bwsproblem) ;
	void	ResetWorkspaceErrorWindow(bool bclosing) ;
	bool	PostWSCheckingMessage(CString csmsg, CProjectNode* ppn) ;
	bool	IgnoreChecksWhenClosing(bool bclosing) ;

    void    Fill(CTreeCtrl *pctcWhere, CProjectRecord& cpr);
    virtual void    Serialize(CArchive& car);

    CStringsNode*	GetStringsNode() { return &m_csnStrings ; }

	bool	RunEditor(bool bstring, int nrcid) ;
	
	bool	ReparseRCFile(CString& csrcfspec) ;
	void	UpdateResourceList(CStringTable& cst, CSafeObArray& csoa,
							   CUIntArray& cuaboldfound, 
							   CUIntArray& cuabnewfound, CString& csrcpath, 
							   int& nc) ;
	void	UpdateResourceItem(CProjectNode* pcpn, CString& csrcpath, 
							   WORD wkey, CString& cs, FIXEDNODETYPE fnt) ;
	void	LinkAndLoadFont(CFontInfo& cfi, bool bworkspaceload, bool bonlyglyph = false) ;
} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stredit.cpp ===
// StrEdit.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"
#include <gpdparse.h>
#include "rcfile.h"
#include "projrec.h"
#include "projnode.h"
#include "comctrls.h"
#include "StrEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStringEditorView

IMPLEMENT_DYNCREATE(CStringEditorView, CFormView)

CStringEditorView::CStringEditorView()
	: CFormView(CStringEditorView::IDD)
{
	//{{AFX_DATA_INIT(CStringEditorView)
	m_csGotoID = _T("");
	m_csSearchString = _T("");
	m_csLabel1 = _T("Press INS to add or insert a new string.\tDouble click an item or press ENTER to begin editing.");
	m_csLabel2 = _T("Press DEL to delete the selected strings.\tPress TAB to move between columns when editing.");
	//}}AFX_DATA_INIT

	m_bFirstActivate = true ;
}

CStringEditorView::~CStringEditorView()
{
}

void CStringEditorView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStringEditorView)
	DDX_Control(pDX, IDC_SESearchBox, m_ceSearchBox);
	DDX_Control(pDX, IDC_SEGotoBox, m_ceGotoBox);
	DDX_Control(pDX, IDC_SEGotoBtn, m_cbGoto);
	DDX_Control(pDX, IDC_SELstCtrl, m_cflstStringData);
	DDX_Text(pDX, IDC_SEGotoBox, m_csGotoID);
	DDX_Text(pDX, IDC_SESearchBox, m_csSearchString);
	DDX_Text(pDX, IDC_SELabel1, m_csLabel1);
	DDX_Text(pDX, IDC_SELabel2, m_csLabel2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStringEditorView, CFormView)
	//{{AFX_MSG_MAP(CStringEditorView)
	ON_BN_CLICKED(IDC_SEGotoBtn, OnSEGotoBtn)
	ON_BN_CLICKED(IDC_SESearchBtn, OnSESearchBtn)
	ON_WM_DESTROY()
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStringEditorView diagnostics

#ifdef _DEBUG
void CStringEditorView::AssertValid() const
{
	CFormView::AssertValid();
}

void CStringEditorView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CStringEditorView message handlers

/******************************************************************************

  CStringEditorView::OnSEGotoBtn

  Find and select the list control row that contains the requested RC ID.

******************************************************************************/

void CStringEditorView::OnSEGotoBtn()
{
	CString		cserrmsg ;		// Used to display error messages

	// Get the RC ID string and trim it.  Convert it to an integer to make sure
	// it is valid.

	UpdateData(TRUE) ;
	m_csGotoID.TrimLeft() ;
	m_csGotoID.TrimRight() ;
	int nrcid = atoi(m_csGotoID) ;
	if (nrcid <= 0) {
		cserrmsg.Format(IDS_BadGotoRCID, m_csGotoID) ;
		AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	// Now that we know what RC ID the user wants, try to find and select it.

	FindSelRCIDEntry(nrcid, true) ;
}


/******************************************************************************

  CStringEditorView::FindSelRCIDEntry

  Find and select the list control row that contains the requested RC ID.
  Return true if the entry was found.  Otherwise, display an error message if
  berror = true and return false.

******************************************************************************/

bool CStringEditorView::FindSelRCIDEntry(int nrcid, bool berror)
{
	CString		cserrmsg ;		// Used to display error messages

	// Look for an item with the specified RC ID.  Complain and return if it
	// is not found.

	LV_FINDINFO lvfi ;
	lvfi.flags = LVFI_STRING ;
	TCHAR acbuf[16] ;
	lvfi.psz = _itoa(nrcid, acbuf, 10) ;
	int nitem = m_cflstStringData.FindItem(&lvfi) ;
	if (nitem == -1) {
		if (berror) {
			cserrmsg.Format(IDS_NoGotoRCID, acbuf) ;
			AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
		} 
		return false ;
	} ;

	// Select the row containing the specified RC ID and deselect any other
	// selected rows.

	m_cflstStringData.SingleSelect(nitem) ;

	// All went well so...

	return true ;
}


/******************************************************************************

  CStringEditorView::OnSESearchBtn

  Find and select the list control row that contains the requested search
  string.  The search begins with the row after the first selected row and
  will wrap around to the beginning of the table if needed and stop at the
  first selected row.  Of course, it only happens that way if it doesn't
  find a matching field first.  The fields (including the RC ID field) in
  each row are checked from left to right.  A case insensitive search is
  performed.  The search string must be contained within a field string.
  IE, "abc", "abcde", and "bc" will all match the search string "bc".

******************************************************************************/

void CStringEditorView::OnSESearchBtn()
{
	CString			cserrmsg ;	// Used to display error messages

	// Get the search string.  Complain if it is empty.

	UpdateData(TRUE) ;
	if (m_csSearchString == _T("")) {
		AfxMessageBox(IDS_BadSearchString, MB_ICONEXCLAMATION) ;
		return ;
	} ;

	CWaitCursor	cwc ;

	// Get the currently selected row number and the number of rows in the
	// table.

	int ncurrentrow = m_cflstStringData.GetNextItem(-1, LVNI_SELECTED) ;
	int numrows = m_cflstStringData.GetItemCount() ;

	// Make an uppercased copy of the search string.

	CString cssrchstr(m_csSearchString) ;
	cssrchstr.MakeUpper() ;

	// Search for the string in the part of the table starting after the
	// current row and ending at the end of the table.  If a match is found,
	// select the row and return.

	if (SearchHelper(cssrchstr, ncurrentrow + 1, numrows))
		return ;

	// Search for the string in the part of the table starting at the first
	// row and ending at the first selected row.  If a match is found, select
	// the row and return.

	if (SearchHelper(cssrchstr, 0, ncurrentrow + 1))
		return ;

	// Tell the user that a match was not found.

	cserrmsg.Format(IDS_NoSearchString, m_csSearchString) ;
	AfxMessageBox(cserrmsg, MB_ICONEXCLAMATION) ;
}


/******************************************************************************

  CStringEditorView::SearchHelper

  Search the specified rows for one that contains a field that contains the
  search string.  See OnSESearchBtn() for more details.

******************************************************************************/

bool CStringEditorView::SearchHelper(CString cssrchstr, int nfirstrow,
									 int numrows)
{
	CStringArray	csafields ; // Used to hold fields in a row
	bool			bfound = false ;	// True iff a match is found

	// Search the specified rows.

	for (int nrow = nfirstrow ; nrow < numrows ; nrow++) {
		m_cflstStringData.GetRowData(nrow, csafields) ;

		// Check each field in the current row for a match.

		for (int nfld = 0 ; nfld < m_cflstStringData.GetNumColumns() ; nfld++) {
			csafields[nfld].MakeUpper() ;
			if (csafields[nfld].Find(cssrchstr) >= 0) {
				bfound = true ;
				break ;
			} ;
		} ;
		
		// Select the row and return success if a match was found.

		if (bfound) {
			m_cflstStringData.SingleSelect(nrow) ;
			return true ;
		} ;
	} ;

	// No match was found so...

	return false ;
}


/******************************************************************************

  CStringEditorView::OnInitialUpdate

  Resize the frame to better fit the controls in it.  Then load the list
  control with the RC IDs and strings for this project.

******************************************************************************/

void CStringEditorView::OnInitialUpdate()
{
    CRect	crtxt ;				// Coordinates of first label
	CRect	crbtnfrm ;			// Coordinates of goto button and frame

	CFormView::OnInitialUpdate() ;
	CWaitCursor cwc ;

	// Get the dimensions of the first label

	HWND	hlblhandle ;		
	GetDlgItem(IDC_SELabel1, &hlblhandle) ;
	::GetWindowRect(hlblhandle, crtxt) ;
	crtxt.NormalizeRect() ;
	

	// Get the dimensions of the Goto button and then combine them with the
	// dimensions of the label to get the dimensions for the form.

	m_cbGoto.GetWindowRect(crbtnfrm) ;
	crbtnfrm.top = crtxt.top ;
	crbtnfrm.right = crtxt.right ;

	// Make sure the frame is big enough for these 2 controls, everything in
	// between, plus a little bit more.

	crbtnfrm.right += 32 ;
	crbtnfrm.bottom += 32 ;
    GetParentFrame()->CalcWindowRect(crbtnfrm) ;
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crbtnfrm.Width(), crbtnfrm.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE) ;

	// Make a copy of the string table information for two reasons.  First,
	// CFullEditListCtrl takes data in a different format.  Second, the string
	// table can't be changed until the user says ok.  The local variables can
	// be updated when needed.  Begin by sizing the local arrays.

	CStringTable* pcst = ((CStringEditorDoc*) GetDocument())->GetRCData() ;
	m_uStrCount	= pcst->Count() ;
	m_csaStrings.SetSize(m_uStrCount) ;
	m_cuiaRCIDs.SetSize(m_uStrCount) ;

	// Copy the string table if it has a nonzero length.

	CString	cstmp ;
	if (m_uStrCount > 0) {
		WORD	wkey ;
		for (unsigned u = 0 ; u < m_uStrCount ; u++) {
			pcst->Details(u, wkey, cstmp) ;
			m_cuiaRCIDs[u] = (unsigned) wkey ;
			m_csaStrings[u] = cstmp ;
		} ;
	} ;

	// Now, initialize the list control by telling it we want full row select
	// and the number of rows and columns needed.

	m_cflstStringData.InitControl(LVS_EX_FULLROWSELECT, m_uStrCount, 2) ;

	// Put the RC IDs into the list control's first column.

	cstmp.LoadString(IDS_StrEditRCIDColLab) ;
	m_cflstStringData.InitLoadColumn(0, cstmp, COMPUTECOLWIDTH, 20, true, true,
									 COLDATTYPE_INT, (CObArray*) &m_cuiaRCIDs) ;

	// Put the strings into the list control's second column.

	cstmp.LoadString(IDS_StrEditStringColLab) ;
	m_cflstStringData.InitLoadColumn(1, cstmp, SETWIDTHTOREMAINDER, -36, true,
									 true, COLDATTYPE_STRING,
									 (CObArray*) &m_csaStrings) ;

	m_cflstStringData.SetFocus() ;	// The list control gets the focus
}


/******************************************************************************

  CStringEditorView::OnActivateView

  If the editor has been invoked from the GPD Editor (or wherever) and there
  is a string entry that should be selected based on its RC ID, do it.

******************************************************************************/

void CStringEditorView::OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView)
{
	CFormView::OnActivateView(bActivate, pActivateView, pDeactiveView) ;

	// Do nothing if the view is not being activated.  Skip the first
	// activate too because the view hasn't been displayed yet.  This
	// is a problem when there is an invalid RC ID.

	if (!bActivate || pActivateView != this || m_bFirstActivate) {
		m_bFirstActivate = false ;
		return ;
	} ;

	// Do nothing if the strings node pointer hasn't been set yet.

	CStringEditorDoc* pcsed = (CStringEditorDoc*) GetDocument() ;
	CStringsNode* pcsn = pcsed->GetStrNode() ;
	if (pcsn == NULL) {		// raid 3176

		m_csLabel1.LoadString(IDS_StrEditNoEdit);
		m_csLabel2 = _T(" ");  
		UpdateData(FALSE); 
		
		m_cflstStringData.EnableWindow(FALSE);
		int rcid;
		CWinApp *cwa = AfxGetApp();
		rcid = cwa->GetProfileInt(_T("StrEditDoc"),_T("StrEditDoc"),1);
		if ( -1 != rcid )	{
			cwa->WriteProfileInt(_T("StrEditDoc"),_T("StrEditDoc"), -1);
			FindSelRCIDEntry(rcid,true);
		}
		return ;
	}
	// Select the entry containing the specified RC ID if the RC ID is valid.
	// Otherwise, just select row 0.

	int nrcid = pcsn->GetFirstSelRCID() ;
	if (nrcid != -1) {
		((CStringEditorDoc*) GetDocument())->GetStrNode()->SetFirstSelRCID(-1) ;
		FindSelRCIDEntry(nrcid, true) ;
	} ;
}


/******************************************************************************

  CStringEditorView::OnDestroy

  When the view is being destroyed, called the parent string node and tell it
  to delete the corresponding document class and clear its pointer to the
  document class.

******************************************************************************/

void CStringEditorView::OnDestroy()
{
	CFormView::OnDestroy();
	
	if (((CStringEditorDoc*) GetDocument())->GetStrNode())
        ((CStringEditorDoc*) GetDocument())->GetStrNode()->OnEditorDestroyed() ;
}


/******************************************************************************

  CStringEditorView::SaveStringTable

  Update this project's string table if needed and (optionally) the user
  requests it.

  If the user wants to save the table (optional) and the table is valid, save
  it and return true.  If the table hasn't changed or the user doesn't want to
  save the table, return true.  Otherwise, return false.

******************************************************************************/

bool CStringEditorView::SaveStringTable(CStringEditorDoc* pcsed, bool bprompt)
{
	// Make sure the new table contents are sorted in ascending order by RC ID.

	m_cflstStringData.SortControl(0) ;
	if (!m_cflstStringData.GetColSortOrder(0))
		m_cflstStringData.SortControl(0) ;

	// Get the string table data out of the list control and into the member
	// variables.  Then get a pointer to the project's string table.

	m_cflstStringData.GetColumnData((CObArray*) &m_cuiaRCIDs, 0) ;
	m_cflstStringData.GetColumnData((CObArray*) &m_csaStrings, 1) ;
	CStringTable* pcst = ((CStringEditorDoc*) GetDocument())->GetRCData() ;

	// Check the table/array lengths and the individual items to see if
	// anything has changed.

	bool		bchanged = false ;
	CString		cstmp ;
	WORD		wkey ;
	unsigned	unumitems = (unsigned)m_cuiaRCIDs.GetSize() ;
	if (pcst->Count() != unumitems)
		bchanged = true ;
	else {
		for (unsigned u = 0 ; u < unumitems ; u++) {
			pcst->Details(u, wkey, cstmp) ;
			if ((unsigned) wkey != m_cuiaRCIDs[u] || cstmp != m_csaStrings[u]) {
				bchanged = true ;
				break ;
			} ;
		} ;
	} ;

	// Return true if nothing is saved because nothing has changed.

	if (!bchanged)
		return true ;

	// If requested,  ask the user if the changes should be saved.  Return
	// true if he says no.

	CProjectRecord* pcpr = pcsed->GetOwner() ;
	if (bprompt) {
		cstmp.Format(IDS_SaveStrTabPrompt, pcpr->DriverName()) ;
		if (AfxMessageBox(cstmp, MB_ICONQUESTION + MB_YESNO) == IDNO)
			return true ;
	} ;

	// Check to see if there are any invalid or duplicate RC IDs or if there
	// are any missing strings.  If any are found, complain, select the
	// offending row, and return false since nothing is saved.

	for (unsigned u = 0 ; u < unumitems ; u++) {
		if (((int) m_cuiaRCIDs[u]) <= 0) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_InvalidRCID) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
		if (m_cuiaRCIDs[u] >= 10000 && m_cuiaRCIDs[u] <= 20000) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_ReservedRCIDUsed) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
		if (u > 0 && m_cuiaRCIDs[u] == m_cuiaRCIDs[u - 1]) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_DuplicateRCID) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
		if (m_csaStrings[u].GetLength() == 0) {
			m_cflstStringData.SingleSelect(u) ;
			cstmp.LoadString(IDS_EmptyStringInStrTab) ;
			AfxMessageBox(cstmp, MB_ICONEXCLAMATION) ;
			SetFocus() ;
			return false ;
		} ;
	} ;

	// The new data is valid and should be saved so copy it into the project's
	// string table.

	pcst->Reset() ;
	for (u = 0 ; u < unumitems ; u++)
		pcst->Map((WORD) m_cuiaRCIDs[u], m_csaStrings[u]) ;

	// Mark the project's RC/MDW file data as being dirty and then return true
	// since the data was saved.

	pcpr->SetRCModifiedFlag(TRUE) ;
	pcpr->SetModifiedFlag(TRUE) ;
	return true ;
}


/******************************************************************************

  CStringEditorView::PreTranslateMessage

  Check for a return key being released while the Goto box or the Search box
  has the focus.  Treat the key like the Goto button or the Search button
  being pressed when this is detected.

******************************************************************************/

BOOL CStringEditorView::PreTranslateMessage(MSG* pMsg)
{
	// When the return key was just released...

	if (pMsg->message == WM_KEYUP && pMsg->wParam == VK_RETURN) {
		// ...and the Goto box has the focus, perform a goto operation.

		if (GetFocus() == &m_ceGotoBox)
			OnSEGotoBtn() ;		

		// ...or the Search box has the focus, perform a search operation.

		else if (GetFocus() == &m_ceSearchBox)
			OnSESearchBtn() ;
	} ;
		
	// Always process the key normally, too.  I think this is ok in this case.

	return CFormView::PreTranslateMessage(pMsg) ;
}


LRESULT CStringEditorView::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	AfxGetApp()->WinHelp(HID_BASE_RESOURCE + IDR_STRINGEDITOR) ;
	return TRUE ;
}



/******************************************************************************

  CStringEditorView::OnFileSave()

  FILE SAVE message handler.

  just call SaveSTringTable(document, bprompt);
//raid 27250
******************************************************************************/


void CStringEditorView::OnFileSave() 
{
	
	CStringEditorDoc* pcsed = (CStringEditorDoc* )GetDocument();

	if( !pcsed ->GetOwner() ) {	// R 3176
		CString cstmp;
		cstmp.LoadString(IDS_StrEditNoSave) ;
		AfxMessageBox(cstmp);
		return;
	}

	SaveStringTable(pcsed,0);

}








/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc

IMPLEMENT_DYNCREATE(CStringEditorDoc, CDocument)

CStringEditorDoc::CStringEditorDoc()
{
	// Raid 3176
	
	CDriverResources* pcdr = new CDriverResources();
	CStringArray csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5;
	CStringTable cst, cstFonts, cstTemp2;
	CString csrcfile;
	m_pcstRCData = new CStringTable;
	
	// seek rc file
	CWinApp *cwa = AfxGetApp();
	csrcfile = cwa->GetProfileString(_T("StrEditDoc"),_T("StrEditDocS") );

	pcdr->LoadRCFile(csrcfile, csaTemp1, csaTemp2,csaTemp3,csaTemp4,csaTemp5,
				*m_pcstRCData, cstFonts, cstTemp2,Win2000);
	
	m_pcsnStrNode = NULL;
	m_pcprOwner = NULL;
	
	
}


/******************************************************************************

  CStringEditorDoc::CStringEditorDoc

  This is the only form of the constructor that should be called.  It will save
  pointers to the project's string node, document class, and RC file string
  table.  Blow if any of these pointers is NULL.

******************************************************************************/

CStringEditorDoc::CStringEditorDoc(CStringsNode* pcsn, CProjectRecord* pcpr,
								   CStringTable* pcst)
{
	VERIFY(m_pcsnStrNode = pcsn) ;
	VERIFY(m_pcprOwner = pcpr) ;
	VERIFY(m_pcstRCData = pcst) ;

	//m_pcsnStrNode = NULL ;
}


BOOL CStringEditorDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}


CStringEditorDoc::~CStringEditorDoc()
{
}


BEGIN_MESSAGE_MAP(CStringEditorDoc, CDocument)
	//{{AFX_MSG_MAP(CStringEditorDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc diagnostics

#ifdef _DEBUG
void CStringEditorDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CStringEditorDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc serialization

void CStringEditorDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	
	}
	else
	{
	
	}
}


/******************************************************************************

  CStringEditorDoc::CanCloseFrame

  Save the new string table if this is needed, the user says ok, and the new
  table's contents are valid.  Don't let the frame close if the user wants
  the table saved but it couldn't be saved because the table is invalid.

******************************************************************************/

BOOL CStringEditorDoc::CanCloseFrame(CFrameWnd* pFrame)
{
	if (!SaveStringTable())
		return FALSE ;
	
	return CDocument::CanCloseFrame(pFrame);
}


/******************************************************************************

  CStringEditorDoc::SaveStringTable

  Save the new string table if this is needed, the user says ok, and the new
  table's contents are valid.  Don't let the frame close if the user wants
  the table saved but it couldn't be saved because the table is invalid.  This
  is done by returning false.  True is returned in all other circumstances.

******************************************************************************/

bool CStringEditorDoc::SaveStringTable()
{
	// Begin looking for a view pointer.  This should work but if it doesn't,
	// just say all is ok by returning true.

	POSITION pos = GetFirstViewPosition() ;
	if (pos == NULL)
		return true ;
	
	// Finish getting the view pointer and call the view to save the string
	// table when needed.  Return whatever the view function returns.
	
	CStringEditorView* pcsev = (CStringEditorView*) GetNextView(pos) ;
	return (pcsev->SaveStringTable(this, true)) ;
}


/******************************************************************************

  CStringEditorDoc::SaveModified

  Make sure that the MFC's default saving mechanism never kicks in by always
  clearing the document's modified flag.

******************************************************************************/

BOOL CStringEditorDoc::SaveModified()
{
	SetModifiedFlag(FALSE) ;
	
	return CDocument::SaveModified();
}






BOOL CStringEditorDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
	if (!CDocument::OnOpenDocument(lpszPathName))
		return FALSE;
	

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\tips.cpp ===
/******************************************************************************

  Source File:  Tip of the Day.CPP

  This implements the Tip of the Day dialog.  It was originally generated by
  Component Gallery, but I expect to be changing it shortly.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.
  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#include    "Resource.H"
// CG: This file added by 'Tip of the Day' component.

#include    <WinReg.H>
#include    <Sys\Stat.H>
#include    <Sys\Types.H>
#include	"tips.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTipOfTheDay dialog

#define MAX_BUFLEN 1000

static const TCHAR szSection[] = _T("Tip");
static const TCHAR szIntFilePos[] = _T("FilePos");
static const TCHAR szTimeStamp[] = _T("TimeStamp");
static const TCHAR szIntStartup[] = _T("StartUp");

CTipOfTheDay::CTipOfTheDay(CWnd* pParent /*=NULL*/)
	: CDialog(IDD_TIP, pParent) {

	//{{AFX_DATA_INIT(CTipOfTheDay)
	m_bStartup = TRUE;
	//}}AFX_DATA_INIT

	// We need to find out what the startup and file position parameters are
	// If startup does not exist, we assume that the Tips on startup is checked TRUE.
	CWinApp* pApp = AfxGetApp();
	m_bStartup = !pApp->GetProfileInt(szSection, szIntStartup, 0);
	UINT iFilePos = pApp->GetProfileInt(szSection, szIntFilePos, 0);
	
	//raid 104081 :: tips.txt file is in the same directory with help file
	CString csTipFile = pApp->m_pszHelpFilePath;
	csTipFile = csTipFile.Left(csTipFile.ReverseFind(_T('\\')));
	csTipFile = csTipFile + _T("\\tips.txt");
	
	// Now try to open the tips file
	m_pStream = fopen(csTipFile, "r");
	if (m_pStream == NULL) 
	{
		m_strTip.LoadString(CG_IDS_FILE_ABSENT);
		return;
	} 

	// If the timestamp in the INI file is different from the timestamp of
	// the tips file, then we know that the tips file has been modified
	// Reset the file position to 0 and write the latest timestamp to the
	// ini file
	struct _stat buf;
	_fstat(_fileno(m_pStream), &buf);
	CString strCurrentTime = ctime(&buf.st_ctime);
	strCurrentTime.TrimRight();
	CString strStoredTime = 
		pApp->GetProfileString(szSection, szTimeStamp, NULL);
	if (strCurrentTime != strStoredTime) 
	{
		iFilePos = 0;
		pApp->WriteProfileString(szSection, szTimeStamp, strCurrentTime);
	}

	if (fseek(m_pStream, iFilePos, SEEK_SET) != 0) 
	{
		AfxMessageBox(CG_IDP_FILE_CORRUPT);
	}
	else 
	{
		GetNextTipString(m_strTip);
	}
}

CTipOfTheDay::~CTipOfTheDay() {
	// This destructor is executed whether the user had pressed the escape key
	// or clicked on the close button. If the user had pressed the escape key,
	// it is still required to update the filepos in the ini file with the 
	// latest position so that we don't repeat the tips! 
    
	// But make sure the tips file existed in the first place....
	if (m_pStream != NULL) {
		CWinApp* pApp = AfxGetApp();
		pApp->WriteProfileInt(szSection, szIntFilePos, ftell(m_pStream));
		fclose(m_pStream);
	}
}
        
void CTipOfTheDay::DoDataExchange(CDataExchange* pDX) {
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTipOfTheDay)
	DDX_Check(pDX, IDC_STARTUP, m_bStartup);
	DDX_Text(pDX, IDC_TIPSTRING, m_strTip);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTipOfTheDay, CDialog)
	//{{AFX_MSG_MAP(CTipOfTheDay)
	ON_BN_CLICKED(IDC_NEXTTIP, OnNextTip)
	ON_WM_CTLCOLOR()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTipOfTheDay message handlers

void CTipOfTheDay::OnNextTip() {
	GetNextTipString(m_strTip);
	UpdateData(FALSE);
}

void CTipOfTheDay::GetNextTipString(CString& strNext) {
	LPTSTR lpsz = strNext.GetBuffer(MAX_BUFLEN);

	// This routine identifies the next string that needs to be
	// read from the tips file
	BOOL bStop = FALSE;
	while (!bStop) 	{
		if (_fgetts(lpsz, MAX_BUFLEN, m_pStream) == NULL) {
			// We have either reached EOF or enocuntered some problem
			// In both cases reset the pointer to the beginning of the file
			// This behavior is same as VC++ Tips file
			if (fseek(m_pStream, 0, SEEK_SET) != 0) 
				AfxMessageBox(CG_IDP_FILE_CORRUPT);
		} 
		else { // raid 200630
			if (*lpsz != ' ' && *lpsz != '\t' && 
				*lpsz != '\n' && *lpsz != ';' && *lpsz != '*') {
				// There should be no space at the beginning of the tip
				// This behavior is same as VC++ Tips file
				// Comment lines are ignored and they start with a semicolon
				bStop = TRUE;
			}
		}
	}
	strNext.ReleaseBuffer();
}

HBRUSH CTipOfTheDay::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) {
	if (pWnd->GetDlgCtrlID() == IDC_TIPSTRING)
		return (HBRUSH)GetStockObject(WHITE_BRUSH);

	return CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
}

void CTipOfTheDay::OnOK() {
	CDialog::OnOK();
	
    // Update the startup information stored in the INI file
	CWinApp* pApp = AfxGetApp();
	pApp->WriteProfileInt(szSection, szIntStartup, !m_bStartup);
}

BOOL CTipOfTheDay::OnInitDialog() {
	CDialog::OnInitDialog();

	// If Tips file does not exist then disable NextTip
	if (m_pStream == NULL)
		GetDlgItem(IDC_NEXTTIP)->EnableWindow(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
}

void CTipOfTheDay::OnPaint() {
	CPaintDC dc(this); // device context for painting

	// Get paint area for the big static control
	CWnd* pStatic = GetDlgItem(IDC_BULB);
	CRect rect;
	pStatic->GetWindowRect(&rect);
	ScreenToClient(&rect);

	// Paint the background white.
	CBrush brush;
	brush.CreateStockObject(WHITE_BRUSH);
	dc.FillRect(rect, &brush);

	// Load bitmap and get dimensions of the bitmap
	CBitmap bmp;
	bmp.LoadBitmap(IDB_LIGHTBULB);
	BITMAP bmpInfo;
	bmp.GetBitmap(&bmpInfo);

	// Draw bitmap in top corner and validate only top portion of window
	CDC dcTmp;
	dcTmp.CreateCompatibleDC(&dc);
	dcTmp.SelectObject(&bmp);
	rect.bottom = bmpInfo.bmHeight + rect.top;
	dc.BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), 
		&dcTmp, 0, 0, SRCCOPY);

	// Draw out "Did you know..." message next to the bitmap
	CString strMessage;
	strMessage.LoadString(CG_IDS_DIDYOUKNOW);
	rect.left += bmpInfo.bmWidth;
	dc.DrawText(strMessage, rect, DT_VCENTER | DT_SINGLELINE);

	// Do not call CDialog::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\stredit.h ===
#if !defined(AFX_STREDIT_H__50303D0C_054D_11D2_AB62_00C04FA30E4A__INCLUDED_)
#define AFX_STREDIT_H__50303D0C_054D_11D2_AB62_00C04FA30E4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// StrEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStringEditorView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif


class CFullEditListCtrl ;
class CStringEditorDoc ;


class CStringEditorView : public CFormView
{
protected:
	CStringEditorView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CStringEditorView)

// Form Data
public:
	//{{AFX_DATA(CStringEditorView)
	enum { IDD = IDD_StringEditor };
	CEdit	m_ceSearchBox;
	CEdit	m_ceGotoBox;
	CButton	m_cbGoto;
	CFullEditListCtrl	m_cflstStringData;
	CString	m_csGotoID;
	CString	m_csSearchString;
	CString	m_csLabel1;
	CString	m_csLabel2;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:
	bool SaveStringTable(CStringEditorDoc* pcsed, bool bprompt) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStringEditorView)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView, CView* pDeactiveView);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CStringEditorView();
	bool SearchHelper(CString cssrchstr, int nfirstrow, int numrows) ;
	bool FindSelRCIDEntry(int nrcid, bool berror) ;
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CStringEditorView)
	afx_msg void OnSEGotoBtn();
	afx_msg void OnSESearchBtn();
	afx_msg void OnDestroy();
	afx_msg void OnFileSave();
	//}}AFX_MSG
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

protected:			
	CStringArray	m_csaStrings ;	// String table's strings
	CUIntArray		m_cuiaRCIDs ;	// String table's RC IDs
	unsigned		m_uStrCount ;	// Number of strings
	bool			m_bFirstActivate ;	// True iff first time activated
};

/////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////
// CStringEditorDoc document

class CStringEditorDoc : public CDocument
{
protected:
	CStringEditorDoc() ;		// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CStringEditorDoc)

	CStringsNode*	m_pcsnStrNode ;	// Used to reference editor's string node
	CProjectRecord* m_pcprOwner ;	// Used to reference editor's project document
	CStringTable*	m_pcstRCData ;	// Used to reference project's string table

// Attributes
public:
	// The next 3 functions are used to reference the pointers passed to this
	// class's constructor.

	CStringsNode*	GetStrNode() { return m_pcsnStrNode ; }	
	CProjectRecord* GetOwner()   { return m_pcprOwner ; }
	CStringTable*	GetRCData()  { return m_pcstRCData ; }
	
// Operations
public:
    CStringEditorDoc(CStringsNode* pcsn, CProjectRecord* pcpr, 
					 CStringTable* pcst) ;
	bool SaveStringTable() ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStringEditorDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	protected:
	virtual BOOL OnNewDocument();
	virtual BOOL SaveModified();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CStringEditorDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CStringEditorDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STREDIT_H__50303D0C_054D_11D2_AB62_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\utility.cpp ===
/******************************************************************************

  Header File:  Utility Classes.CPP

  These classes are generally useful classes which can be used for a variety
  of purposes.  I created this separate file for quicker reuse later, and also
  to avoid having to include some very specific header file just to get these
  general-purpose classes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#include    "StdAfx.H"
#if defined(LONG_NAMES)
#include    "Utility Classes.H"
#else
#include    "Utility.H"
#endif

/******************************************************************************

  CMapWordToDWord class

  This class uses CMapWordToPtr to do its dirty work.  When the need arises, I
  will make it serializable

******************************************************************************/

BOOL    CMapWordToDWord::Lookup(WORD wKey, DWORD& dwItem) const {
    union {
        void*   pv;
        DWORD   dw;
    };

    if  (!CMapWordToPtr::Lookup(wKey, pv))
        return  FALSE;

    dwItem = dw;
    return  TRUE;
}

/******************************************************************************

  CMapWordToDWord::GetNextAssoc

  This is the map iteration method.  We call the same method on the bas class,
  and update the DWORD parameter if the underlying method is successful.

******************************************************************************/

void    CMapWordToDWord::GetNextAssoc(POSITION& pos, WORD& wKey, 
                                      DWORD& dwItem) const {
    union {
        void*   pv;
        DWORD   dw;
    };

    CMapWordToPtr::GetNextAssoc(pos, wKey, pv);

    dwItem = dw;
}

/******************************************************************************

  CMapWordToDWord::Operator[]

  This implements an l-value only operator usable for adding new associations or
  updating existing ones.

******************************************************************************/

DWORD&  CMapWordToDWord::operator[](WORD wKey) {
    return  (DWORD&) CMapWordToPtr::operator[](wKey);
}

/******************************************************************************

  CSafeObArray class implementation

  This provides a "Safe" CObArray class which can't leak!

******************************************************************************/

IMPLEMENT_SERIAL(CSafeObArray, CObject, 0);

/******************************************************************************

  CSafeObArray::~CSafeObArray

  The class destructor will delete the object foreach non-NULL pointer in the 
  array.

******************************************************************************/

CSafeObArray::~CSafeObArray() {
    for (unsigned u = 0; u < GetSize(); u++)
        if  (m_coa[u])
            delete  m_coa[u];
}

/******************************************************************************

  CSafeObArray::RemoveAll

  Almost the same as the destructor, isn't it?

******************************************************************************/

void    CSafeObArray::RemoveAll() {
    for (unsigned u = 0; u < GetSize(); u++)
        if  (m_coa[u])
            delete  m_coa[u];

    m_coa.RemoveAll();
}

/******************************************************************************

  CSafeObArray::RemoveAt

  This removes one element from the array- after deleting it, of course.

******************************************************************************/

void    CSafeObArray::RemoveAt(int i) {
    if  (m_coa[i])
        delete  m_coa[i];
    m_coa.RemoveAt(i);
}


/******************************************************************************

  CSafeObArray::Copy

  Copy the contents of one array to another.

******************************************************************************/

void    CSafeObArray::Copy(CSafeObArray& csoa)
{
	m_coa.Copy(*(csoa.GetCOA())) ;
}


/******************************************************************************

  CSafeObArray::Serialize

  I call the CObject serializer to maintain the proper typ einformation, then
  let the CObArray serialize itself.

******************************************************************************/

void    CSafeObArray::Serialize(CArchive& car) {
    if  (car.IsLoading())
        RemoveAll();

    CObject::Serialize(car);
    m_coa.Serialize(car);
}

/******************************************************************************

  CSafeMapWordToOb implementation

  Making the workd safe for maps.

******************************************************************************/

IMPLEMENT_SERIAL(CSafeMapWordToOb, CObject, 0)

/******************************************************************************

  CSafeMapWordToOb::~CSafeMapWordToOb

  The class destructor must ensure the underlying objects are deleted.

******************************************************************************/

CSafeMapWordToOb::~CSafeMapWordToOb() {
    WORD    wKey;
    CObject *pco;

    for (POSITION pos = m_cmw2o.GetStartPosition(); pos; ) {
        m_cmw2o.GetNextAssoc(pos, wKey, pco);
        if  (pco)
            delete  pco;
    }
}

/******************************************************************************

  CSafeMapWordToOb::operator[]

  The problem here is that this is used only to put elements in the map-
  therefore, I intercept the call and delete any existing item.  This could 
  cause problems if the same pointer is re-inserted into the map, but for now,
  I'll take my chances.

******************************************************************************/

CObject*&   CSafeMapWordToOb::operator[](WORD wKey) {
    CObject*&   pco = m_cmw2o.operator[](wKey);

    if  (pco)   delete  pco;
    return  pco;
}

/******************************************************************************

  CSafeMapWordToOb::RemoveKey

  Pretty Obvious- if there was an object there, remove it.

******************************************************************************/

BOOL    CSafeMapWordToOb::RemoveKey(WORD wKey) {

    CObject *pco;

    if  (!m_cmw2o.Lookup(wKey, pco))
        return  FALSE;

    if  (pco)
        delete  pco;

    return m_cmw2o.RemoveKey(wKey);
}

/******************************************************************************

  CSafeMapWordToOb::RemoveAll

  Again, this is pretty obvious- destroy anything that lives!

******************************************************************************/

void    CSafeMapWordToOb::RemoveAll() {
    WORD    wKey;
    CObject *pco;

    for (POSITION pos = m_cmw2o.GetStartPosition(); pos; ) {
        GetNextAssoc(pos, wKey, pco);
        if  (pco)
            delete  pco;
    }

    m_cmw2o.RemoveAll();
}

/******************************************************************************

  CSafeMapWordToOb::Serialize

  First, I depopulate the map if it is being loaded.  Then I call the CObject
  serializer to handle run-time typing checks, and then serialize the
  underlying map.

******************************************************************************/

void    CSafeMapWordToOb::Serialize(CArchive& car) {
    if  (car.IsLoading())
        RemoveAll();

    CObject::Serialize(car);
    m_cmw2o.Serialize(car);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\tips.h ===
/******************************************************************************

  Header File:  Tip of the Day.H

  This defines the Tip of the Day dialog class.  It was originally created by
  the Component Gallery, but I expect I will et around to tweaking it here and 
  there pretty soon.

  Copyright (c) 1997 by Microsoft Corporation.  All rights reserved.
  A Pretty Penny Enterprises Production

  Change History:
  03-02-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

class CTipOfTheDay : public CDialog {
// Construction
public:
	CTipOfTheDay(CWnd* pParent = NULL);	 // standard constructor

// Dialog Data
	//{{AFX_DATA(CTipOfTheDay)
	// enum { IDD = IDD_TIP };
	BOOL	m_bStartup;
	CString	m_strTip;
	//}}AFX_DATA

	FILE* m_pStream;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTipOfTheDay)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTipOfTheDay();

protected:
	// Generated message map functions
	//{{AFX_MSG(CTipOfTheDay)
	afx_msg void OnNextTip();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void GetNextTipString(CString& strNext);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\writefnt.cpp ===
/******************************* MODULE HEADER *******************************
 * writefnt.c
 *      Function to take a FI_DATA_HEADER structure and write the data to
 *      the passed in file handle as a font record.  This layout is used
 *      in both minidrivers and the font installer font file.
 *
 * Copyright (C) 1992   Microsoft Corporation.
 *
 *****************************************************************************/

#include        "StdAfx.H"
#include        "fontinst.h"

/************************* Function Header *********************************
 * bWrite
 *      Writes data out to a file handle.  Returns TRUE on success.
 *      Functions as a nop if the size request is zero.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  17:38 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      # 1
 *
 ****************************************************************************/

static BOOL    bWrite(HANDLE hFile, PVOID pvBuf, int iSize ) {
    /*
     *   Simplify the ugly NT interface.  Returns TRUE if the WriteFile
     * call returns TRUE and the number of bytes written equals the
     * number of bytes desired.
     */

    
    BOOL   bRet;
    DWORD  dwSize;              /* Filled in by WriteFile */


    bRet = TRUE;

    if( iSize > 0 &&
        (!WriteFile( hFile, pvBuf, (DWORD)iSize, &dwSize, NULL ) ||
         (DWORD)iSize != dwSize) )
             bRet = FALSE;              /* Too bad */


    return  bRet;
}

/******************************* Function Header *****************************
 * iWriteFDH
 *      Write the FI_DATA_HEADER data out to our file.  We do the conversion
 *      from addresses to offsets, and write out any data we find.
 *
 * RETURNS:
 *      The number of bytes actually written; -1 for error, 0 for nothing.
 *
 * HISTORY:
 *  16:58 on Thu 05 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      Based on an experimental version first used in font installer.
 *
 *  17:11 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 *****************************************************************************/

int iWriteFDH(HANDLE hFile, FI_DATA *pFD) {
    /*
     *   Decide how many bytes will be written out.  We presume that the
     * file pointer is located at the correct position when we are called.
     */

    int  iSize;         /* Evaluate output size */


    FI_DATA_HEADER   fdh;       /* Header written to file */




    if  (!pFD)
        return  0;      /* Perhaps only deleting?  */

    memset( &fdh, 0, sizeof( fdh ) );           /* Zero for convenience */

    /*
     *  Set the miscellaneous flags etc.
     */

    fdh.cjThis = sizeof( fdh );

    fdh.fCaps = pFD->fCaps;
    fdh.wFontType= pFD->wFontType; /* Device Font Type */

    fdh.wXRes = pFD->wXRes;
    fdh.wYRes = pFD->wYRes;

    fdh.sYAdjust = pFD->sYAdjust;
    fdh.sYMoved = pFD->sYMoved;

    fdh.u.sCTTid = (short)pFD->dsCTT.cBytes;

    fdh.dwSelBits = pFD->dwSelBits;

    fdh.wPrivateData = pFD->wPrivateData;


    iSize = sizeof( fdh );              /* Our header already */
    fdh.dwIFIMet = iSize;               /* Location of IFIMETRICS */

    iSize += pFD->dsIFIMet.cBytes;              /* Bytes in struct */

    /*
     *   And there may be a width table too!  The pFD values are zero if none.
     */

    if( pFD->dsWidthTab.cBytes )
    {
        fdh.dwWidthTab = iSize;

        iSize += pFD->dsWidthTab.cBytes;
    }

    /*
     *  Finally are the select/deselect strings.
     */

    if( pFD->dsSel.cBytes )
    {
        fdh.dwCDSelect = iSize;
        iSize += pFD->dsSel.cBytes;
    }

    if( pFD->dsDesel.cBytes )
    {
        fdh.dwCDDeselect = iSize;
        iSize += pFD->dsDesel.cBytes;
    }

    /*
     *   There may also be some sort of identification string.
     */

    if( pFD->dsIdentStr.cBytes )
    {
        fdh.dwIdentStr = iSize;
        iSize += pFD->dsIdentStr.cBytes;
    }

    if( pFD->dsETM.cBytes )
    {
        fdh.dwETM = iSize;
        iSize += pFD->dsETM.cBytes;
    }


    /*
     *   Sizes all figured out,  so write the data!
     */

    if( !bWrite( hFile, &fdh, sizeof( fdh ) ) ||
        !bWrite( hFile, pFD->dsIFIMet.pvData, pFD->dsIFIMet.cBytes ) ||
        !bWrite( hFile, pFD->dsWidthTab.pvData, pFD->dsWidthTab.cBytes ) ||
        !bWrite( hFile, pFD->dsSel.pvData, pFD->dsSel.cBytes ) ||
        !bWrite( hFile, pFD->dsDesel.pvData, pFD->dsDesel.cBytes ) ||
        !bWrite( hFile, pFD->dsIdentStr.pvData, pFD->dsIdentStr.cBytes ) ||
        !bWrite( hFile, pFD->dsETM.pvData, pFD->dsETM.cBytes ) )
                return   -1;


    return  iSize;                      /* Number of bytes written */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\utility.h ===
/******************************************************************************

  Header File:  Utility Classes.H

  These classes are generally useful classes which can be used for a variety
  of purposes.

  Copyright (c) 1997 by Microsoft Corporation.  All Rights Reserved.

  A Pretty Penny Enterprises Production

  Change History:
  03-01-1997    Bob_Kjelgaard@Prodigy.Net   Created it

******************************************************************************/

#if !defined(UTILITY_CLASSES)
#define UTILITY_CLASSES

/******************************************************************************

  CMapWordToDWord class

  This class uses CMapWordToPtr to do its dirty work.  When the need arises, I
  will make it serializable

******************************************************************************/

class CMapWordToDWord : public CMapWordToPtr {

public:
    unsigned    Count() const { return (unsigned)CMapWordToPtr::GetCount(); }
    BOOL        Lookup(WORD wKey, DWORD& dwItem) const;

    void        GetNextAssoc(POSITION& pos, WORD& wKey, DWORD& dwItem) const;

    DWORD&      operator[](WORD wKey);
};

/******************************************************************************

  CSafeObArray- This class, unlike CObArray, will delete any objects removed
  from the array.  Otherwise it is identical.

******************************************************************************/

class CSafeObArray : public CObject {
    CObArray    m_coa;
    DECLARE_SERIAL(CSafeObArray)
public:
    CSafeObArray() {}
    ~CSafeObArray();

    //  Attributes
    unsigned    GetSize() const { return (unsigned) m_coa.GetSize(); }
    CObject*    operator[](unsigned u) const { return m_coa.GetAt(u); }

    //Operations
    int     Add(CObject *pco) { return((int)m_coa.Add(pco)) ; }
    void    InsertAt(unsigned uid, CObject *pco) { m_coa.InsertAt(uid, pco); }
    void    RemoveAll();
    void    RemoveAt(int i);
    void    SetAt(int i, CObject *pco) { m_coa.SetAt(i, pco) ; }
    void    Copy(CSafeObArray& csoa) ;
	void	SetSize(int nsize, int ngrow = -1) { m_coa.SetSize(nsize, ngrow) ; }
	CObArray* GetCOA() { return &m_coa ; }
    virtual void    Serialize(CArchive& car);
};

/******************************************************************************

  CSafeMapWordToOb

  This class encapsulates a CMapWordToOb object, but it does what the
  documentation says the CMapWordToOb does, and definitely oes not do- delete
  the underling objects when the map no longer references them!

******************************************************************************/

class CSafeMapWordToOb : public CObject {
    CMapWordToOb    m_cmw2o;
    DECLARE_SERIAL(CSafeMapWordToOb)

public:
    CSafeMapWordToOb() {}
    ~CSafeMapWordToOb();

    //  Attributes

    unsigned    GetCount() const { return (unsigned) m_cmw2o.GetCount(); }

    BOOL    Lookup(WORD wKey, CObject*& pco) const {
        return m_cmw2o.Lookup(wKey, pco);
    }

    POSITION    GetStartPosition() const { return m_cmw2o.GetStartPosition(); }

    void        GetNextAssoc(POSITION& pos, WORD& wKey, CObject*& pco) const {
        m_cmw2o.GetNextAssoc(pos, wKey, pco);
    }

    //  Operations

    CObject*&   operator[](WORD wKey);
    BOOL        RemoveKey(WORD wKey);
    void        RemoveAll();

    virtual void    Serialize(CArchive& car);
};


class CStringTable : public CObject {

    DECLARE_SERIAL(CStringTable)

    CString             m_csEmpty;
    CUIntArray          m_cuaKeys;
    CStringArray        m_csaValues;
	CUIntArray			m_cuaRefFlags ;	// Referenced flags used in WS checking

public:

    CStringTable() {}

    //  Attributes
    unsigned    Count() const { return (unsigned)m_cuaKeys.GetSize(); }

    CString operator[](WORD wKey) const;

    void    Details(unsigned u, WORD &wKey, CString &csValue);

    //  Operations

    void    Map(WORD wKey, CString csValue);

    void    Remove(WORD wKey);

    void    Reset() {
        m_csaValues.RemoveAll();
        m_cuaKeys.RemoveAll();
    }

    virtual void    Serialize(CArchive& car);

	// Reference flag management routines

	bool GetRefFlag(unsigned u) { return (m_cuaRefFlags[u] != 0) ; }
	void SetRefFlag(unsigned u) { m_cuaRefFlags[u] = (unsigned) true ; }
	void ClearRefFlag(unsigned u) { m_cuaRefFlags[u] = (unsigned) false ; }
	void InitRefFlags() ;
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\wscheck.h ===
#if !defined(AFX_WSCHECK_H__82E3CFBA_D2DB_11D1_AB19_00C04FA30E4A__INCLUDED_)
#define AFX_WSCHECK_H__82E3CFBA_D2DB_11D1_AB19_00C04FA30E4A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// WSCheck.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWSCheckView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif


class CDriverResources ;		// Forward declarations
class CProjectNode ;


class CWSCheckView : public CFormView
{
protected:
	CWSCheckView() ;           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWSCheckView)

// Form Data
public:
	//{{AFX_DATA(CWSCheckView)
	enum { IDD = IDD_WSCheck };
	CListBox	m_lstErrWrn;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

	void PostWSCMsg(CString& csmsg, CProjectNode* ppn) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWSCheckView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWSCheckView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWSCheckView)
	afx_msg void OnDblclkErrWrnLstBox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc document

class CWSCheckDoc : public CDocument
{
protected:
	CWSCheckDoc() ;			// protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWSCheckDoc)

	CDriverResources*	m_pcdrOwner ;	// Ptr to document's creator

// Attributes
public:

// Operations
public:
	CWSCheckDoc(CDriverResources* pcdr) ;

	void PostWSCMsg(CString& csmsg, CProjectNode* ppn) ;
	void DeleteAllMessages(void) ;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWSCheckDoc)
	public:
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
	protected:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWSCheckDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CWSCheckDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WSCHECK_H__82E3CFBA_D2DB_11D1_AB19_00C04FA30E4A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\minidev.new\wscheck.cpp ===
// WSCheck.cpp : implementation file
//

#include "stdafx.h"
#include "minidev.h"
#include "WSCheck.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWSCheckView

IMPLEMENT_DYNCREATE(CWSCheckView, CFormView)

CWSCheckView::CWSCheckView()
	: CFormView(CWSCheckView::IDD)
{
	//{{AFX_DATA_INIT(CWSCheckView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWSCheckView::~CWSCheckView()
{
}

void CWSCheckView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWSCheckView)
	DDX_Control(pDX, IDC_ErrWrnLstBox, m_lstErrWrn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWSCheckView, CFormView)
	//{{AFX_MSG_MAP(CWSCheckView)
	ON_LBN_DBLCLK(IDC_ErrWrnLstBox, OnDblclkErrWrnLstBox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWSCheckView diagnostics

#ifdef _DEBUG
void CWSCheckView::AssertValid() const
{
	CFormView::AssertValid();
}

void CWSCheckView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CWSCheckView message handlers


void CWSCheckView::OnDblclkErrWrnLstBox() 
{
	// TODO: Add your control notification handler code here
	
}


/******************************************************************************

  CWSCheckView::OnInitialUpdate

  Resize the frame to better fit the visible controls in it.

******************************************************************************/

void CWSCheckView::OnInitialUpdate() 
{
    CRect	crtxt ;				// Coordinates of list box label
	CRect	crlbfrm ;			// Coordinates of list box and frame

	CFormView::OnInitialUpdate() ;

	// Get the dimensions of the list box label

	HWND	hlblhandle ;		
	GetDlgItem(IDC_WSCLabel, &hlblhandle) ;
	::GetWindowRect(hlblhandle, crtxt) ;
	crtxt.NormalizeRect() ;

	// Get the dimensions of the list box and then add the height of the label
	// to those dimensions.

	m_lstErrWrn.GetWindowRect(crlbfrm) ;
	crlbfrm.bottom += crtxt.Height() ;

	// Make sure the frame is big enough for these 2 controls plus a little bit
	// more.

	crlbfrm.right += 40 ;
	crlbfrm.bottom += 40 ;
    GetParentFrame()->CalcWindowRect(crlbfrm) ;
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crlbfrm.Width(), crlbfrm.Height(),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE) ;

	/*
	CRect   crPropertySheet;
    m_cps.GetWindowRect(crPropertySheet);

	crPropertySheet -= crPropertySheet.TopLeft();
    m_cps.MoveWindow(crPropertySheet, FALSE);								// Position property sheet within the
																			//  child frame
    GetParentFrame()->CalcWindowRect(crPropertySheet);
    GetParentFrame()->SetWindowPos(NULL, 0, 0, crPropertySheet.Width(),
        crPropertySheet.Height(), 
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
	*/
}


/******************************************************************************

  CWSCheckView::PostWSCMsg

  Add an error or warning message along with its associated Project Node 
  pointer to the list box.

******************************************************************************/

void CWSCheckView::PostWSCMsg(CString& csmsg, CProjectNode* ppn)
{	
	int n = m_lstErrWrn.AddString(csmsg) ;
	m_lstErrWrn.SetItemData(n, (DWORD) PtrToUlong(ppn)) ;
}


/******************************************************************************

  CWSCheckView::DeleteAllMessages

  Delete all of the messages in the list box.

******************************************************************************/

void CWSCheckView::DeleteAllMessages(void)
{
	m_lstErrWrn.ResetContent() ;
}


/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc

IMPLEMENT_DYNCREATE(CWSCheckDoc, CDocument)

CWSCheckDoc::CWSCheckDoc()
{
}


/******************************************************************************

  CWSCheckDoc::CWSCheckDoc

  This is the only form of the constructor that should be called.  It will save
  a pointer the class that created it.

******************************************************************************/

CWSCheckDoc::CWSCheckDoc(CDriverResources* pcdr) 
{
	m_pcdrOwner = pcdr ;
}


CWSCheckDoc::~CWSCheckDoc()
{
}


BOOL CWSCheckDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}


/******************************************************************************

  CWSCheckDoc::PostWSCMsg

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CWSCheckDoc::PostWSCMsg(CString& csmsg, CProjectNode* ppn)
{	
	POSITION pos = GetFirstViewPosition() ;   
	if (pos != NULL) {
		CWSCheckView* pwscv = (CWSCheckView *) GetNextView(pos) ;      
		pwscv->PostWSCMsg(csmsg, ppn) ;
		pwscv->UpdateWindow() ;
	} ;  
}


/******************************************************************************

  CWSCheckDoc::DeleteAllMessages

  Pass the specified request on to what should be the one and only view
  attached to this document.

******************************************************************************/

void CWSCheckDoc::DeleteAllMessages(void)
{
	POSITION pos = GetFirstViewPosition() ;   
	if (pos != NULL) {
		CWSCheckView* pwscv = (CWSCheckView *) GetNextView(pos) ;      
		pwscv->DeleteAllMessages() ;
		pwscv->UpdateWindow() ;
	} ;  
}


BEGIN_MESSAGE_MAP(CWSCheckDoc, CDocument)
	//{{AFX_MSG_MAP(CWSCheckDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc diagnostics

#ifdef _DEBUG
void CWSCheckDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWSCheckDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWSCheckDoc serialization

void CWSCheckDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\brush.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    brush.h

Abstract:

    Brush object header file

Environment:

        Windows NT Unidrv driver

Revision History:

    05/14/96 -amandan-
        Created

--*/

#ifndef _BRUSH_H_
#define _BRUSH_H_

#define DBCACHE_INC                 16
#define DBCACHE_MAX                 256

#define DITHERED_COLOR             -1
#define BLACK_COLOR_CMD_INDEX       0
#define MAX_COLOR_SELECTION         8
#define CMD_COLORSELECTION_FIRST    CMD_SELECTBLACKCOLOR

#define BRUSH_BLKWHITE              1
#define BRUSH_SHADING               2
#define BRUSH_CROSSHATCH            3
#define BRUSH_USERPATTERN           4
#define BRUSH_PROGCOLOR             5
#define BRUSH_NONPROGCOLOR          6

typedef struct _RECTW {
    WORD    l;
    WORD    t;
    WORD    r;
    WORD    b;
    } RECTW, *PRECTW;

BOOL
Download1BPPHTPattern(
    PDEV    *pPDev,
    SURFOBJ *pso,
    DWORD   dwPatID
    );

WORD
GetBMPChecksum(
    SURFOBJ *pso,
    PRECTW  prcw
    );

LONG
FindCachedHTPattern(
    PDEV    *pPDev,
    WORD    wChecksum
    );

BOOL
BFoundCachedBrush(
    PDEV    *pPDev,
    PDEVBRUSH pDevBrush
    );

//
// The following macro return a density value from 1 to 100 where 1 is the
// lightest and 100 is darkest, it will never return 0 (WHITE) because we
// using 23r + 66g + 10b = 99w
//

#define GET_SHADING_PERCENT(dw)    (BYTE)(100-((((DWORD)RED_VALUE(dw)  * 23) + \
                                             ((DWORD)GREEN_VALUE(dw)* 66) + \
                                             ((DWORD)BLUE_VALUE(dw) * 10) + \
                                             127) / 255))

#define CACHE_CURRENT_BRUSH(pPDev, pDevBrush) \
    pPDev->GState.CurrentBrush.dwBrushType = pDevBrush->dwBrushType; \
    pPDev->GState.CurrentBrush.iColor = pDevBrush->iColor;  \



#endif // _STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\brush.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    brush.c

Abstract:

    DrvRealizeBrush

Environment:

    Windows NT Unidrv driver

Revision History:

    05/14/97 -amandan-
        Created

--*/

#include "unidrv.h"

BRGBColorSpace(PDEV *);


LONG
FindCachedHTPattern(
    PDEV    *pPDev,
    WORD    wChecksum
    )

/*++

Routine Description:

    This function find the cached text brush pattern color, if not there then
    it will add it to the cached.


Arguments:

    pPDev       - Pointer to our PDEV
    wCheckSum   - Checksum of pattern brush


Return Value:

    LONG    >0  - Found the cached, return value is the pattern ID
            =0  - Out of memory, not cached
            <0  - not in the cached, add to the cached, return value is
                  the negated pattern ID

Author:

    08-Apr-1997 Tue 19:42:21 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPWORD  pDBCache;
    WORD    cMaxDB;
    WORD    cUsedDB;
    WORD    Index;


    //
    // The first is the cMaxDB, the 2nd is the cUsedDB
    //

    if (pDBCache = pPDev->GState.pCachedPatterns)
    {
        cMaxDB    = *(pDBCache + 0);
        cUsedDB   = *(pDBCache + 1);
        pDBCache += 2;

        for (Index = 1; Index <= cUsedDB; Index++, pDBCache++)
        {
            if (*pDBCache == wChecksum)
            {

                VERBOSE(("\n\tRaddd:FindCachedHTPat(%04lx): FOUND=%ld    ",
                            wChecksum, Index));

                return((LONG)Index);
            }
        }

        //
        // If we can't find a cached one, add the new one to the list
        //

        if (cUsedDB < cMaxDB)
        {
            *pDBCache               = wChecksum;
            *(pPDev->GState.pCachedPatterns + 1) += 1;

            VERBOSE(("\n\tRaddd:FindCachedHTPat(%04lx): NOT FOUND=%ld    ",
                        wChecksum, -(LONG)Index));

            return(-(LONG)Index);
        }

    }
    else
    {

        cUsedDB =
        cMaxDB  = 0;
    }

    //
    // We need to expand the checksum cached buffer
    //

    VERBOSE(("\n\tUnidrv:FindCachedHTPat(%04lx): pDBCache=%08lx, cUsedDB=%ld, cMaxDB=%ld",
                wChecksum, pDBCache, cUsedDB, cMaxDB));

    if (((cMaxDB + DBCACHE_INC) < DBCACHE_MAX)  &&
        (pDBCache = (LPWORD)MemAllocZ((cMaxDB + DBCACHE_INC + 2) *
                                                            sizeof(WORD))))
    {

        if ((cMaxDB) && (pPDev->GState.pCachedPatterns))
        {

            CopyMemory(pDBCache + 2,
                       pPDev->GState.pCachedPatterns + 2,
                       cMaxDB * sizeof(WORD));

            MemFree(pPDev->GState.pCachedPatterns);
        }

        *(pDBCache + 0)           = cMaxDB + DBCACHE_INC;
        *(pDBCache + 1)           = cUsedDB + 1;
        *(pDBCache + 2 + cUsedDB) = wChecksum;
        pPDev->GState.pCachedPatterns    = pDBCache;

        VERBOSE (("\n\tUnidrv:FindCachedHTPat(%04lx): pDBCache=%08lx, cUsedDB=%ld, cMaxDB=%ld, EMPTY=%ld   ",
                    wChecksum, pDBCache, *(pDBCache + 1), *(pDBCache + 0), -(LONG)(cUsedDB + 1)));

        return(-(LONG)(cUsedDB + 1));
    }

    //
    // Out of memory
    //

    WARNING(("\n\tUnidrv:FindCachedHTPat: OUT OF MEMORY"));

    return(0);

}


BOOL
Download1BPPHTPattern(
    PDEV    *pPDev,
    SURFOBJ *pso,
    DWORD   dwPatID
    )

/*++

Routine Description:

    This function donload a user define pattern

Arguments:

    pPDev       - Pointer to the PDEV

    pDevBrush   - Pointer to the cached device brush


Return Value:

    INT to indicate a pattern number downloaed/defined

Author:

    08-Apr-1997 Tue 19:41:00 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    SURFOBJ so;
    LPBYTE  pb;
    LPBYTE  pbEnd;
    LPBYTE  pSrc;
    DWORD   cbCX;
    DWORD   cb;
    WORD    cxcyRes;
    INT     Len;
    BYTE    Buf[64];
    BYTE    XorMask;
    BYTE    EndMask;


    so    = *pso;
    pb    = Buf;
    pbEnd = pb + sizeof(Buf) - 4;
    cbCX  = (DWORD)(((DWORD)so.sizlBitmap.cx + 7) >> 3);


    //
    // Update standard variable and send command
    //

    pPDev->dwPatternBrushType = BRUSH_USERPATTERN;
    pPDev->dwPatternBrushSize = (DWORD)(cbCX * so.sizlBitmap.cy) + 12;
    pPDev->dwPatternBrushID = dwPatID;

    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DOWNLOAD_PATTERN));


    //
    // Send header and pattern data
    //

    *pb++ = 20;
    *pb++ = 0;
    *pb++ = (so.iBitmapFormat == BMF_1BPP) ? 1 : 8;
    *pb++ = 0;
    *pb++ = HIBYTE((WORD)so.sizlBitmap.cx);
    *pb++ = LOBYTE((WORD)so.sizlBitmap.cx);
    *pb++ = HIBYTE((WORD)so.sizlBitmap.cy);
    *pb++ = LOBYTE((WORD)so.sizlBitmap.cy);
    *pb++ = HIBYTE((WORD)pPDev->ptGrxRes.x);
    *pb++ = LOBYTE((WORD)pPDev->ptGrxRes.x);
    *pb++ = HIBYTE((WORD)pPDev->ptGrxRes.y);
    *pb++ = LOBYTE((WORD)pPDev->ptGrxRes.y);

    //
    // The XorMask is used to flip the BLACK/WHITE bit depends on the output
    // and EndMask is to mask off any unwanted bit in the last byte to 0
    // this is to fix LJ5si, LJ4si firmware bugs, REMEMBER our palette always
    // in RGB additive mode so the passed in 1BPP format has 0=Black, 1=White
    //

    XorMask = (BRGBColorSpace(pPDev)) ? 0x00 : 0xff;

    if (!(EndMask = (BYTE)(0xff << (8 - (so.sizlBitmap.cx & 0x07)))))
    {
        EndMask = 0xff;
    }

    VERBOSE(("\n\tRaddd:DownLoaHTPattern: PatID=%ld, Format=%ld, %ld x %ld, XorMask=%02lx, EndMaks=%02lx\t\t",
          dwPatID, pso->iBitmapFormat, so.sizlBitmap.cx, so.sizlBitmap.cy,
          XorMask, EndMask));

    while (so.sizlBitmap.cy--)
    {
        cb                  = cbCX;
        pSrc                = so.pvScan0;
        (LPBYTE)so.pvScan0 += so.lDelta;

        while (cb--)
        {
            *pb++ = (BYTE)(*pSrc++ ^ XorMask);

            if (!cb) {

                *(pb - 1) &= EndMask;
            }

            if (pb >= pbEnd) {

                WriteSpoolBuf(pPDev, Buf, (DWORD)(pb - Buf));
                pb = Buf;
            }
        }
    }

    //
    // Send remaining data
    //

    if (Len = (INT)(pb - Buf))
    {
        WriteSpoolBuf(pPDev, Buf, Len);
    }

    return(TRUE);
}


WORD
GetBMPChecksum(
    SURFOBJ *pso,
    PRECTW  prcw
    )

/*++

Routine Description:




Arguments:




Return Value:




Author:

    22-Apr-1997 Tue 11:32:37 created  -by-  Daniel Chou (danielc)


Revision History:


--*/

{
    LPBYTE  pb;
    RECTW   rcw;
    LONG    cy;
    LONG    cPixels;
    LONG    lDelta;
    WORD    wChecksum;
    UINT    c1stPixels;
    UINT    Format;
    BYTE    BegMask;
    BYTE    EndMask;
    BYTE    XorMask;


    rcw      = *prcw;
    Format   = (UINT)pso->iBitmapFormat;
    wChecksum = 0;

    VERBOSE(("\nComputeChecksum(%ld): (%4ld, %4ld)-(%4ld, %4ld)=%3ldx%3ld\t\t",
                Format, rcw.l, rcw.t, rcw.r, rcw.b,
                rcw.r - rcw.l, rcw.b - rcw.t));

    if (rcw.l > (WORD)pso->sizlBitmap.cx) {

        rcw.l = (WORD)pso->sizlBitmap.cx;
    }

    if (rcw.t > (WORD)pso->sizlBitmap.cy) {

        rcw.t = (WORD)pso->sizlBitmap.cy;
    }

    if (rcw.r > (WORD)pso->sizlBitmap.cx) {

        rcw.r = (WORD)pso->sizlBitmap.cx;
    }

    if (rcw.b > (WORD)pso->sizlBitmap.cy) {

        rcw.b = (WORD)pso->sizlBitmap.cy;
    }

    if ((rcw.r <= rcw.l) || (rcw.b <= rcw.t)) {

        return(wChecksum);
    }

    cPixels = (LONG)(rcw.r - rcw.l);
    cy      = (LONG)(rcw.b - rcw.t);
    lDelta  = pso->lDelta;
    pb      = (LPBYTE)pso->pvScan0 + ((LONG)rcw.t * lDelta);
    XorMask = 0xFF;

    //
    // rcw.r and rcw.b are exclusive
    //

    --rcw.r;
    --rcw.b;

    switch (Format) {

    case BMF_1BPP:

        pb         += (rcw.l >> 3);
        c1stPixels  = (UINT)(8 - (rcw.l & 0x07));
        BegMask     = (BYTE)(0xff >> (rcw.l & 0x07));
        EndMask     = (BYTE)(0xff << (8 - (rcw.r & 0x07)));

        break;

    case BMF_4BPP:

        if (rcw.l & 0x01) {

            BegMask    = 0x07;
            c1stPixels = 4;

        } else {

            BegMask    = 0x77;
            c1stPixels = 0;
        }

        pb       += (rcw.l >> 1);
        cPixels <<= 2;
        EndMask   = (BYTE)((rcw.r & 0x01) ? 0x70 : 0x77);
        XorMask   = 0x77;

        break;

    case BMF_8BPP:
    case BMF_16BPP:
    case BMF_24BPP:

        BegMask      =
        EndMask      = 0xFF;
        c1stPixels   = (UINT)(Format - BMF_8BPP + 1);
        pb          += (rcw.l * c1stPixels);
        cPixels     *= (c1stPixels << 3);
        c1stPixels   = 0;

        break;
    }

    while (cy--) {

        LPBYTE  pbCur;
        LONG    Count;
        WORD    w;


        pbCur  = pb;
        pb    += lDelta;
        Count  = cPixels;
        w      = (WORD)((c1stPixels) ? ((*pbCur++ ^ XorMask) & BegMask) : 0);

        if ((Count -= c1stPixels) >= 8) {

            do {

                w        <<= 8;
                w         |= (*pbCur++ ^ XorMask);
                wChecksum  += w;

            } while ((Count -= 8) >= 8);
        }

        if (Count > 0) {

            w <<= 8;
            w  |= (WORD)((*pbCur ^ XorMask) & EndMask);

        } else {

            w &= EndMask;
        }

        wChecksum += w;
    }

     VERBOSE(("\nComputeChecksum(%ld:%04lx): (%4ld, %4ld)-(%4ld, %4ld)=%3ldx%3ld [%3ld], pb=%08lx [%02lx:%02lx], %1ld\t",
                Format, wChecksum,
                rcw.l, rcw.t, rcw.r + 1, rcw.b + 1,
                rcw.r - rcw.l + 1, rcw.b - rcw.t + 1, cPixels,
                pb, BegMask, EndMask, c1stPixels));

    return(wChecksum);
}


BOOL
BRGBColorSpace(
    PDEV    *pPDev
    )
{

     LISTNODE   *pListNode = NULL;

     if (pPDev->pDriverInfo && pPDev->pColorModeEx)
         pListNode = LISTNODEPTR(pPDev->pDriverInfo,pPDev->pColorModeEx->liColorPlaneOrder);

     while (pListNode)
     {
            switch (pListNode->dwData)
            {

            case COLOR_RED:
            case COLOR_GREEN:
            case COLOR_BLUE:
                return TRUE;

            default:
                break;
            }

           if (pListNode->dwNextItem == END_OF_LIST)
                break;
            else
                pListNode = LOCALLISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
    }

    return FALSE;

}

BOOL
BFoundCachedBrush(
    PDEV    *pPDev,
    PDEVBRUSH pDevBrush
    )
{

    //
    // search the cache only if we want to use the last color. If
    // MODE_BRUSH_RESET_COLOR is set then we want to explicitly reset the brush
    // color by sending the command to the printer.
    //
    if (  (!(pPDev->ctl.dwMode & MODE_BRUSH_RESET_COLOR)) )
    {
        if ( (pDevBrush->dwBrushType == pPDev->GState.CurrentBrush.dwBrushType) &&
             (pDevBrush->iColor == pPDev->GState.CurrentBrush.iColor) )
        {
            return TRUE;
        }

    }
    else
    {
        //
        // Reset the MODE_BRUSH_RESET_COLOR flag as we want to search the cache
        // next time.
        //
        pPDev->ctl.dwMode &= ~MODE_BRUSH_RESET_COLOR;

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\pfm2ufm\pfm2ufm.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    pfm2ufm.c

Abstract:

    Program to read Windows 16 PFM format data and convert to NT's
    IFIMETRICS data.  Note that since IFIMETRICS is somewhat more
    elaborate than PFM data,  some of the values are best guesses.
    These are made on the basis of educated guesses.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/16/96 -eigos-
        Created from rasdd.

--*/

#include        "precomp.h"

#if !defined(DEVSTUDIO) //  MDS doesn't need this stuff...

//
// Global variables
//

#define NUM_OF_ERROR1 15
static BYTE *gcstrError1[NUM_OF_ERROR1] = {
                 "Usage: pfm2ufm [-vcpf] [-s#] [-aCodePage] uniqname pfmfile [gttfile/codepage/predefined gtt id] ufmfile\n",
                 "   -v print out PFM and IFIMETRICS\n",
                 "   -c specify codepage instead of gtt file\n",
                 "   -p specify predefined gtt id instead of gtt file\n",
                 "   -f enable font simulation\n",
                 "   -a facename conversion to unicode using codepage\n",
                 "   -s# specify scaling option, can be -s0, -s1, -s2\n\n",
                 "   uniqname is used to create IFIMETRIC.dpwszUniqueName\n",
                 "   pfm_file is input, read only usage\n",
                 "   gtt_file is input, read only usage\n",
                 "   predefind gtt id can be -1,-2,-3,-10,-11,-13,-14,-15,-16,-17,-18\n",
                 "   ufm_file is output\n       Files must be different\n\n",
                 "   E.g.\n",
                 "   (Specify code page) pfm2ufm -c UniqName XXX.PFM 1452 XXX.UFM\n",
                 "   (Specify predefined gtt id) pfm2ufm -p UniqName XXX.PFM -13 XXX.UFM\n"
                 "   (FaceName codepage conversion) pfm2ufm -p -a437 UniqName XXX.PFM -1 XXX.UFM\n"
                 };
static BYTE gcstrError2[]    = "HeapCreate() fails in pfm2ufm.\n";
static BYTE gcstrError3[]    = "Cannot open input file: %ws.\n";
static BYTE gcstrError4[]    = "%ws is not a valid PFM file - ignored.\n";
static BYTE gcstrError5[]    = "Could not align PFM file.\n";
static BYTE gcstrError6[]    = "Failed to convert from FONTINFO to IFIMETRICS.\n";
static BYTE gcstrError7[]    = "Could not get font selection command\n";
static BYTE gcstrError8[]    = "Could not get font unselection command\n";
static BYTE gcstrError9[]    = "Could not open gtt file '%ws'\n";
static BYTE gcstrError10[]   = "Cannot convert PFM to UFM\n";
static BYTE gcstrError11[]   = "Cannot create output file: '%ws'\n";
static BYTE gcstrError12[]   = "Cannot write %ws data to output file.\n";
static BYTE gcstrError13[]   = "Invalid ctt id: %d\n";

static WCHAR *gwstrGTT[3]    = { TEXT("CP437_GTT"),
                                 TEXT("CP850_GTT"),
                                 TEXT("CP863_GTT") };

#define WRITEDATAINTOFILE(pData, dwSize, pwstrErrorStr) \
    if (!WriteFile(hUFMFile, \
                   (pData), \
                   (dwSize), \
                   &dwWrittenSize, \
                   NULL)) \
    { \
        fprintf(stderr, gcstrError12, (pwstrErrorStr)); \
        return -12; \
    }

#else

#define WRITEDATAINTOFILE(pData, dwSize) \
    if (!WriteFile(hUFMFile, \
                   (pData), \
                   (dwSize), \
                   &dwWrittenSize, \
                   NULL)) \
        return  FALSE;

#endif

DWORD gdwOutputFlags;

//
// Internal macros
//

#define FILENAME_SIZE 512

//
// Internal structure define
//

typedef VOID (*VPRINT) (char*,...);

//
// Internal function definition
//

VOID VPrintIFIMETRICS (IFIMETRICS*,    VPRINT);
VOID VPrintPFM        (PFMHEADER*,     VPRINT);
VOID VPrintPFMExt     (PFMEXTENSION*,  VPRINT);
VOID VPrintETM        (EXTTEXTMETRIC*, VPRINT);
VOID VPrintFontCmd    (CD*,            BOOL, VPRINT);
VOID VPrintKerningPair(w3KERNPAIR*,    DWORD, VPRINT);
VOID VPrintWidthTable (PSHORT,         DWORD, VPRINT);

BOOL BArgCheck(IN INT, IN CHAR**, OUT PWSTR, OUT PWSTR, OUT PWSTR, OUT PWSTR, OUT PDWORD);
BOOL BValidatePFM(BYTE *, DWORD);
DWORD DwGetCodePageFromCTTID(LONG);
DWORD DwGetCodePageFromGTTID(LONG);
INT ICodePage2GTTID( DWORD dwCodePage);
INT ICttID2GttID( LONG lPredefinedCTTID);

#if defined(DEVSTUDIO)

BOOL    BConvertPFM(LPBYTE  lpbPFM, DWORD dwCodePage, LPBYTE lpbGTT, 
                    PWSTR pwstrUnique, LPSTR lpstrUFM, int iGTTID) {

    HANDLE            hHeap;
    HANDLE            hUFMFile;

    PUNI_GLYPHSETDATA pGlyph = (PUNI_GLYPHSETDATA) lpbGTT;
    EXTTEXTMETRIC     Etm;

    FONTOUT           FOutData;
    FONTIN            FInData;
    FONTMISC          FMiscData;

    DWORD             dwWrittenSize;

    //
    //  Create a heap.
    //

    if ( !(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )) )
        return FALSE;
    
    //
    // Init MiscData
    //

    FMiscData.pwstrUniqName = pwstrUnique;
    
    //
    // Init FInData
    //

    ZeroMemory( &FInData, sizeof(FONTIN));
    FInData.pETM = &Etm;

    //
    //  Convert PFM to UFM
    //

    if (!BConvertPFM2UFM(hHeap,
                         lpbPFM,
                         pGlyph,
                         dwCodePage,
                         &FMiscData,
                         &FInData,
                         iGTTID, 
                         &FOutData,
                         0L))
        return FALSE;

    //
    // Create the output file.
    //

    hUFMFile = CreateFileA( lpstrUFM,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          0 );

    if( hUFMFile == (HANDLE)-1 )
        return  FALSE;

    //
    // Write the output file.
    //

    //  First, tweak the GTT ID- the library code pulls it from the PFM,
    //  which may not be correct.

    WRITEDATAINTOFILE(&FOutData.UniHdr,     sizeof(UNIFM_HDR));
    WRITEDATAINTOFILE(&FOutData.UnidrvInfo, sizeof(UNIDRVINFO));

    if (FOutData.SelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.SelectFont.pCmdString,
                          FOutData.SelectFont.dwSize);
    }

    if (FOutData.UnSelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.UnSelectFont.pCmdString,
                          FOutData.UnSelectFont.dwSize);
    }

    //  Pad to get DWORD alignment

    SetFilePointer(hUFMFile, 
        FOutData.UnidrvInfo.dwSize - (sizeof FOutData.UnidrvInfo +
        FOutData.SelectFont.dwSize + FOutData.UnSelectFont.dwSize), NULL, 
        FILE_CURRENT);

    WRITEDATAINTOFILE(FOutData.pIFI, FOutData.dwIFISize);
    if  (FOutData.pETM) 
    {
        WRITEDATAINTOFILE(FOutData.pETM, sizeof(EXTTEXTMETRIC));
    }
    if (FOutData.dwWidthTableSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pWidthTable, FOutData.dwWidthTableSize);
    }
    if (FOutData.dwKernDataSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pKernData, FOutData.dwKernDataSize);
    }

    //  Clean it all up...

    CloseHandle(hUFMFile);
    HeapDestroy(hHeap);

    return  TRUE;

}

#else
// 
// Input data
//     Unique face name
//     ID string
//     pfm file name
//     gtt file name
//     ufm file name
//
// main function 
// 
// 1. Check argument. Unique facename, pfm filename, gtt file name, ufm filename
// 2. Open pfm file
// 3. PFM file validation
//     4. Align non-aligned PFM file 
//     5. Convert Fontinfo to Ifimetrics 
//     6. Get font selection/unselection command
//     7. Get kerning pair table and convert it to GTT base table
//     8. Get width table and convert it to GTT base table
// 9. Open UFM file
// 10. Write to UFM file
//

INT __cdecl
main(
    INT    iArgc,
    CHAR **ppArgv)
/*++

Routine Description:

    main function of pfm to unifm converter

Arguments:

    iArgc - the number of an argument
    ppArgv - the pointer to the argument string list

Return Value:

    0 if successful, otherwise failed to complete conversion

--*/

{
    HFILEMAP          hPFMFileMap;
    HFILEMAP          hGTTFileMap;
    HANDLE            hHeap;
    HANDLE            hUFMFile;

    PUNI_GLYPHSETDATA pGlyph;

    FONTOUT           FOutData;
    FONTIN            FInData;
    FONTMISC          FMiscData;

    EXTTEXTMETRIC     Etm;

    HMODULE           hModule;
    HRSRC             hRes;
    DWORD             dwOffset;
    DWORD             dwPFMSize;
    DWORD             dwGTTSize;
    DWORD             dwWrittenSize;
    DWORD             dwCodePage;
    DWORD             dwCodePageOfFacenameConv;
    DWORD             dwGTTID;
    LONG              lPredefinedCTTID;

    WCHAR             awchUniqName[FILENAME_SIZE];
    WCHAR             awchPFMFile[FILENAME_SIZE];
    WCHAR             awchGTTFile[FILENAME_SIZE];
    WCHAR             awchUFMFile[FILENAME_SIZE];

    DWORD             dwFlags = 0L;

    INT               iI, iGTTID;

    PBYTE             pPFMData;

    //RIP(("Start pfm2ufm\n"));

    //
    // Argument check
    //

    if (!BArgCheck(iArgc,
                   ppArgv,
                   awchUniqName,
                   awchPFMFile,
                   awchGTTFile,
                   awchUFMFile,
                   &dwCodePageOfFacenameConv))
    {
        for (iI = 0; iI < NUM_OF_ERROR1; iI ++)
        {
            fprintf( stderr, gcstrError1[iI]);
        }
        return -1;
    }

    //
    // Create a heap.
    //

    if ( !(hHeap = HeapCreate( HEAP_NO_SERIALIZE, 10 * 1024, 256 * 1024 )) )
    {
        fprintf( stderr, gcstrError2);
        return -2;
    }

    //
    // Open PFM file
    //

    if( !(hPFMFileMap = MapFileIntoMemory(awchPFMFile,
                                          &pPFMData,
                                          &dwPFMSize)))
    {
        fprintf( stderr, gcstrError3, awchPFMFile );
        return -3;
    }

    //
    // PFM validation.
    // PFM Header, DRIVERINFO, PFMEXTENSION, DRIVERINFO_VERSION
    //

    if( !BValidatePFM( pPFMData, dwPFMSize ) )
    {
        fprintf( stderr, gcstrError4, awchPFMFile );
        return -4;
    }

    //
    // Open GTT file/Get codepage/predefined GTT
    //

    iGTTID = 0;

    pGlyph = NULL;

    if (gdwOutputFlags & OUTPUT_CODEPAGEMODE)
    {
        dwCodePage = _wtol(awchGTTFile);
        iGTTID = ICodePage2GTTID(dwCodePage);
    }
    else
    if (gdwOutputFlags & OUTPUT_PREDEFINED)
    {
        hModule = GetModuleHandle(TEXT("pfm2ufm.exe"));
        lPredefinedCTTID = _wtol(awchGTTFile);

        //
        // Bug support
        // Previous implementation only support plug value like
        // 1, 2, 3, 13, 263 etc.
        // We need to support this type still
        //

        if (lPredefinedCTTID > 0)
            lPredefinedCTTID = -lPredefinedCTTID;

        iGTTID = lPredefinedCTTID;

        //
        // UNI16 FE CTT ID handlig
        //
        if (-256 >= lPredefinedCTTID && lPredefinedCTTID >= -263)
        {
             //
             // CTT_BIG5      -261  // Chinese (PRC, Singapore)
             // CTT_ISC       -258  // Korean
             // CTT_JIS78     -256  // Japan
             // CTT_JIS83     -259  // Japan
             // CTT_JIS78_ANK -262  // Japan
             // CTT_JIS83_ANK -263  // Japan
             // CTT_NS86      -257  // Chinese (PRC, Singapore)
             // CTT_TCA       -260  // Chinese (PRC, Singapore)
             //
             gdwOutputFlags &= ~OUTPUT_PREDEFINED;
             gdwOutputFlags |= OUTPUT_CODEPAGEMODE;
             dwCodePage = DwGetCodePageFromCTTID(lPredefinedCTTID);
             iGTTID     = ICttID2GttID(lPredefinedCTTID);
        }
        else
        //
        // UNI32 GTTID handling
        //
        if (-18 <= iGTTID && iGTTID <= -10 ||
            -3  <= iGTTID && iGTTID <= -1   )
        {
            dwCodePage  = DwGetCodePageFromGTTID(iGTTID);
            if (-3 <= iGTTID && iGTTID <= -1)
            {
                if (lPredefinedCTTID)
                {
                    hRes = FindResource(hModule,
	        gwstrGTT[lPredefinedCTTID - 1],
	        TEXT("RC_GLYPH"));
                    pGlyph = (PUNI_GLYPHSETDATA)LoadResource(hModule, hRes);
                }
            }
        }
        else
        //
        // UNI16 US ID handling
        //
        if (1 <= lPredefinedCTTID || lPredefinedCTTID <= 3)
        {
            //
            // CC_CP437 -1
            // CC_CP850 -2
            // CC_CP863 -3
            //
            dwCodePage  = DwGetCodePageFromCTTID(lPredefinedCTTID);

            if (lPredefinedCTTID)
            {
                hRes = FindResource(hModule,
	    gwstrGTT[lPredefinedCTTID - 1],
	    TEXT("RC_GLYPH"));
                pGlyph = (PUNI_GLYPHSETDATA)LoadResource(hModule, hRes);
            }
        }
    }
    else
    {
        if( !(hGTTFileMap = MapFileIntoMemory(awchGTTFile,
                                              &pGlyph,
                                              &dwGTTSize)))
        {
            fprintf( stderr, gcstrError9, awchGTTFile );
            return -9;
        }

        dwCodePage = 0;
    }

    //
    // Init MiscData
    //

    FMiscData.pwstrUniqName = awchUniqName;

    //
    // Init FInData
    //

    ZeroMemory( &FInData, sizeof(FONTIN));
    FInData.pETM = &Etm;

    if ( gdwOutputFlags & OUTPUT_FONTSIM)
        FInData.dwFlags = FLAG_FONTSIM;
    else
        FInData.dwFlags = 0;
    
    if ( gdwOutputFlags & OUTPUT_FACENAME_CONV)
        FInData.dwCodePageOfFacenameConv = dwCodePageOfFacenameConv;
    else
        FInData.dwCodePageOfFacenameConv = 0;

    if ( gdwOutputFlags & OUTPUT_SCALING_ANISOTROPIC )
        dwFlags |= PFM2UFM_SCALING_ANISOTROPIC;
    else if ( gdwOutputFlags & OUTPUT_SCALING_ARB_XFORMS )
        dwFlags |= PFM2UFM_SCALING_ARB_XFORMS;

    //
    // Convert PFM to UFM
    //

    if (!BConvertPFM2UFM(hHeap,
                         pPFMData,
                         pGlyph,
                         dwCodePage,
                         &FMiscData,
                         &FInData,
                         iGTTID,
                         &FOutData,
                         dwFlags))
    {
        fprintf( stderr, gcstrError10 );
        return -10;
    }

    if (gdwOutputFlags & OUTPUT_PREDEFINED)
    {
        FreeResource(hRes);
    }

    if (gdwOutputFlags & OUTPUT_VERBOSE)
    {
        VPrintPFM         (&FInData.PFMH, printf);
        VPrintPFMExt      (&FInData.PFMExt, printf);
        if (FInData.pETM)
        {
            VPrintETM         (FInData.pETM, printf);
        }
        VPrintFontCmd     (FInData.pCDSelectFont, TRUE, printf);
        VPrintFontCmd     (FInData.pCDUnSelectFont, FALSE, printf);
        VPrintKerningPair (FInData.pKernPair,
                           FInData.dwKernPairSize,
                           printf);
        VPrintWidthTable  (FInData.psWidthTable,
                           FInData.dwWidthTableSize,
                           printf);
        VPrintIFIMETRICS(FOutData.pIFI, printf);
    }

    //
    // Create the output file.
    //

    hUFMFile = CreateFile( awchUFMFile,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL,
                          0 );

    if( hUFMFile == (HANDLE)-1 )
    {
        fprintf( stderr, gcstrError11, awchUFMFile );
        return  -11;
    }

    //
    // Write the output file.
    //

    WRITEDATAINTOFILE(&FOutData.UniHdr,     sizeof(UNIFM_HDR),  L"UNIFM_HDR");
    WRITEDATAINTOFILE(&FOutData.UnidrvInfo, sizeof(UNIDRVINFO), L"UNIDRVINFO");

    if (FOutData.SelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.SelectFont.pCmdString,
                          FOutData.SelectFont.dwSize,
                          L"SelectFont");
    }

    if (FOutData.UnSelectFont.dwSize)
    {
        WRITEDATAINTOFILE(FOutData.UnSelectFont.pCmdString,
                          FOutData.UnSelectFont.dwSize,
                          L"UnSelectFont");
    }

    //  Pad to get DWORD alignment

    SetFilePointer(hUFMFile, 
        FOutData.UnidrvInfo.dwSize - (sizeof FOutData.UnidrvInfo +
        FOutData.SelectFont.dwSize + FOutData.UnSelectFont.dwSize), NULL, 
        FILE_CURRENT);

    WRITEDATAINTOFILE(FOutData.pIFI, FOutData.dwIFISize, L"IFIMETRICS");
    if (FOutData.pETM != NULL)
    {
        WRITEDATAINTOFILE(FOutData.pETM, sizeof(EXTTEXTMETRIC), L"EXTEXTMETRIC");
    }
    if (FOutData.dwWidthTableSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pWidthTable, FOutData.dwWidthTableSize, L"WIDTHTABLE");
    }
    if (FOutData.dwKernDataSize != 0)
    {
        WRITEDATAINTOFILE(FOutData.pKernData, FOutData.dwKernDataSize, L"KERNDATA");
    }

    //
    //   All done,  so clean up and away
    //

    UnmapViewOfFile( hGTTFileMap );              /* Input no longer needed */

    UnmapViewOfFile( hPFMFileMap );              /* Input no longer needed */

    CloseHandle(hUFMFile);

    HeapDestroy( hHeap );               /* Probably not needed */

    return  0;
}

//
// Internal functions
//

BOOL
BValidatePFM(
    IN BYTE  *pBase,
    IN DWORD  dwSize)

/*++

Routine Description:

    Look at a memory mapped PFM file,  and see if it seems reasonable.

Arguments:

    pBase - base address of file
    dwSize - size of bytes available

Return Value:

    TRUE if successful, otherwise PFM file is invalid.

--*/

{
    res_PFMHEADER     *rpfm;     // In Win 3.1 format, UNALIGNED!!
    res_PFMEXTENSION  *rpfme;    // Final access to offset to DRIVERINFO
    DRIVERINFO         di;       // The actual DRIVERINFO data!
    DWORD              dwOffset; // Calculate offset of interest as we go


    //
    //    First piece of sanity checking is the size!  It must be at least
    //  as large as a PFMHEADER structure plus a DRIVERINFO structure.
    //

    if( dwSize < (sizeof( res_PFMHEADER ) +
                  sizeof( DRIVERINFO ) +
                  sizeof( res_PFMEXTENSION )) )
    {
        return  FALSE;
    }

    //
    //    Step along to find the DRIVERINFO structure, as this contains
    //  some identifying information that we match to look for legitimacy.
    //

    rpfm = (res_PFMHEADER *)pBase;           /* Looking for fixed pitch */

    dwOffset = sizeof( res_PFMHEADER );

    if( rpfm->dfPixWidth == 0 )
    {
        /*   Proportionally spaced, so allow for the width table too! */
        dwOffset += (rpfm->dfLastChar - rpfm->dfFirstChar + 2) *
                    sizeof( short );

    }

    rpfme = (res_PFMEXTENSION *)(pBase + dwOffset);

    //
    //   Next is the PFMEXTENSION data
    //

    dwOffset += sizeof( res_PFMEXTENSION );

    if( dwOffset >= dwSize )
    {
        return  FALSE;
    }

    dwOffset = DwAlign4( rpfme->b_dfDriverInfo );

    if( (dwOffset + sizeof( DRIVERINFO )) > dwSize )
    {
        return   FALSE;
    }

    //
    //    A memcpy is used because this data is typically not aigned. Ugh!
    //

    CopyMemory( &di, pBase + dwOffset, sizeof( di ) );


    if( di.sVersion > DRIVERINFO_VERSION )
    {
        return   FALSE;
    }

    return  TRUE;
}

BOOL
BCheckIFIMETRICS(
    IFIMETRICS *pIFI,
    VPRINT vPrint
    )
/*++

Routine Description:

    This is where you put sanity checks on an incomming IFIMETRICS structure.

Arguments:


Return Value:

    TRUE if successful, otherwise PFM file is invalid.

--*/

{
    BOOL bGoodPitch;

    BYTE jPitch = pIFI->jWinPitchAndFamily &
                  (DEFAULT_PITCH | FIXED_PITCH | VARIABLE_PITCH);


    if (pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
    {
        bGoodPitch = (jPitch == FIXED_PITCH);
    }
    else
    {
        bGoodPitch = (jPitch == VARIABLE_PITCH);
    }

    if (!bGoodPitch)
    {
        vPrint("\n\n<INCONSISTENCY DETECTED>\n");
        vPrint( "    jWinPitchAndFamily = %-#2x, flInfo = %-#8lx\n\n",
                    pIFI->jWinPitchAndFamily, pIFI->flInfo);

        return FALSE;
    }

    return TRUE;
}


BOOL
BArgCheck(
    IN  INT    iArgc,
    IN  CHAR **ppArgv,
    OUT PWSTR  pwstrUniqName,
    OUT PWSTR  pwstrPFMFile,
    OUT PWSTR  pwstrGTTFile,
    OUT PWSTR  pwstrUFMFile,
    OUT PDWORD pdwCodePageOfFacenameConv)
{

    DWORD dwI;
    PTSTR pstrCodePageOfFacenameConv;
    INT   iCount, iRet;

    ASSERT(pwstrUniqName != NULL ||
           pwstrPFMFile  != NULL ||
           pwstrGTTFile  != NULL ||
           pwstrUFMFile  != NULL  );


    if (iArgc < 5)
    {
        return FALSE;
    }

    ppArgv++;
    iArgc --;
    iCount = 0;

    while (iArgc > 0)
    {
        if ( (**ppArgv == '-' || **ppArgv == '/') &&

                // minus value GTT or CTT ID handling
             !(**ppArgv == '-' && 0x30 <= *(*ppArgv+1) && *(*ppArgv+1) <= 0x39)
           )
        {
            dwI = 1;
            while(*(*ppArgv+dwI))
            {
                switch(*(*ppArgv+dwI))
                {
                case 'v':
                    gdwOutputFlags |= OUTPUT_VERBOSE;
                    break;

                case 'c':
                    gdwOutputFlags |= OUTPUT_CODEPAGEMODE;
                    break;

                case 'p':
                    gdwOutputFlags |= OUTPUT_PREDEFINED;
                    break;

                case 'f':
                    gdwOutputFlags |= OUTPUT_FONTSIM;
                    break;

                case 'n':
                    gdwOutputFlags |= OUTPUT_FONTSIM_NONADD;
                    break;

                case 'a':
                    gdwOutputFlags |= OUTPUT_FACENAME_CONV;
                    pstrCodePageOfFacenameConv = (PTSTR)(*ppArgv + dwI + 1);
                    *pdwCodePageOfFacenameConv = (DWORD)atoi((const char*)pstrCodePageOfFacenameConv);
                    break;
                case 's':
                    if ('1' == *((PSTR)(*ppArgv + dwI + 1)))
                        gdwOutputFlags |= OUTPUT_SCALING_ANISOTROPIC;
                    else if ('2' == *((PSTR)(*ppArgv + dwI + 1)))
                        gdwOutputFlags |= OUTPUT_SCALING_ARB_XFORMS;
                    break;
                }
                dwI ++;
            }

            if ((gdwOutputFlags & (OUTPUT_PREDEFINED|OUTPUT_CODEPAGEMODE)) ==
                 (OUTPUT_PREDEFINED|OUTPUT_CODEPAGEMODE) )
            {
                return FALSE;
            }
        }
        else
        {
            if (iCount == 0)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrUniqName,
                                           FILENAME_SIZE);
                *(pwstrUniqName + iRet) = (WCHAR)NULL;
            }
            else if (iCount == 1)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrPFMFile,
                                           FILENAME_SIZE);
                *(pwstrPFMFile + iRet) = (WCHAR)NULL;

            }
            else if (iCount == 2)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrGTTFile,
                                           FILENAME_SIZE);
                *(pwstrGTTFile + iRet) = (WCHAR)NULL;
            }
            else if (iCount == 3)
            {
                iRet = MultiByteToWideChar(CP_ACP, 
                                           0,
                                           *ppArgv,
                                           strlen(*ppArgv),
                                           pwstrUFMFile,
                                           FILENAME_SIZE);
                *(pwstrUFMFile + iRet) = (WCHAR)NULL;
            }

            if (iRet == 0)
            {
                return FALSE;
            }

            iCount ++;
        }
        iArgc --;
        ppArgv++;
    }

    return TRUE;
}

//
// Verbose output functions
//

VOID
VPrintIFIMETRICS(
    IFIMETRICS *pIFI,
    VPRINT vPrint
    )
/*++

Routine Description:

    Dumps the IFMETERICS to the screen

Arguments:

    pIFI - pointer to IFIMETRICS
    vPrint - output function pointer

Return Value:

    None

--*/
{
    //
    // Convenient pointer to Panose number
    //

    PANOSE *ppan = &pIFI->panose;

    PWSTR pwszFamilyName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFamilyName);
    PWSTR pwszStyleName  = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszStyleName) ;
    PWSTR pwszFaceName   = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName)  ;
    PWSTR pwszUniqueName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszUniqueName);

    vPrint("********* IFIMETRICS ***************\n");
    vPrint("cjThis                 %-#8lx\n" , pIFI->cjThis );
    vPrint("cjIfiExtra             %-#8lx\n" , pIFI->cjIfiExtra);
    vPrint("pwszFamilyName         \"%ws\"\n", pwszFamilyName );

    if( pIFI->flInfo & FM_INFO_FAMILY_EQUIV )
    {
        /*  Aliasing is in effect!  */

        while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            vPrint("                               \"%ws\"\n", pwszFamilyName );
    }

    vPrint("pwszStyleName          \"%ws\"\n", pwszStyleName );
    vPrint("pwszFaceName           \"%ws\"\n", pwszFaceName );
    vPrint("pwszUniqueName         \"%ws\"\n", pwszUniqueName );
    vPrint("dpFontSim              %-#8lx\n" , pIFI->dpFontSim );
    vPrint("lEmbedId               %d\n",      pIFI->lEmbedId    );
    vPrint("lItalicAngle           %d\n",      pIFI->lItalicAngle);
    vPrint("lCharBias              %d\n",      pIFI->lCharBias   );
    vPrint("dpCharSets             %d\n",      pIFI->dpCharSets   );
    vPrint("jWinCharSet            %04x\n"   , pIFI->jWinCharSet );
    vPrint("jWinPitchAndFamily     %04x\n"   , pIFI->jWinPitchAndFamily );
    vPrint("usWinWeight            %d\n"     , pIFI->usWinWeight );
    vPrint("flInfo                 %-#8lx\n" , pIFI->flInfo );
    vPrint("fsSelection            %-#6lx\n" , pIFI->fsSelection );
    vPrint("fsType                 %-#6lx\n" , pIFI->fsType );
    vPrint("fwdUnitsPerEm          %d\n"     , pIFI->fwdUnitsPerEm );
    vPrint("fwdLowestPPEm          %d\n"     , pIFI->fwdLowestPPEm );
    vPrint("fwdWinAscender         %d\n"     , pIFI->fwdWinAscender );
    vPrint("fwdWinDescender        %d\n"     , pIFI->fwdWinDescender );
    vPrint("fwdMacAscender         %d\n"     , pIFI->fwdMacAscender );
    vPrint("fwdMacDescender        %d\n"     , pIFI->fwdMacDescender );
    vPrint("fwdMacLineGap          %d\n"     , pIFI->fwdMacLineGap );
    vPrint("fwdTypoAscender        %d\n"     , pIFI->fwdTypoAscender );
    vPrint("fwdTypoDescender       %d\n"     , pIFI->fwdTypoDescender );
    vPrint("fwdTypoLineGap         %d\n"     , pIFI->fwdTypoLineGap );
    vPrint("fwdAveCharWidth        %d\n"     , pIFI->fwdAveCharWidth );
    vPrint("fwdMaxCharInc          %d\n"     , pIFI->fwdMaxCharInc );
    vPrint("fwdCapHeight           %d\n"     , pIFI->fwdCapHeight );
    vPrint("fwdXHeight             %d\n"     , pIFI->fwdXHeight );
    vPrint("fwdSubscriptXSize      %d\n"     , pIFI->fwdSubscriptXSize );
    vPrint("fwdSubscriptYSize      %d\n"     , pIFI->fwdSubscriptYSize );
    vPrint("fwdSubscriptXOffset    %d\n"     , pIFI->fwdSubscriptXOffset );
    vPrint("fwdSubscriptYOffset    %d\n"     , pIFI->fwdSubscriptYOffset );
    vPrint("fwdSuperscriptXSize    %d\n"     , pIFI->fwdSuperscriptXSize );
    vPrint("fwdSuperscriptYSize    %d\n"     , pIFI->fwdSuperscriptYSize );
    vPrint("fwdSuperscriptXOffset  %d\n"     , pIFI->fwdSuperscriptXOffset);
    vPrint("fwdSuperscriptYOffset  %d\n"     , pIFI->fwdSuperscriptYOffset);
    vPrint("fwdUnderscoreSize      %d\n"     , pIFI->fwdUnderscoreSize );
    vPrint("fwdUnderscorePosition  %d\n"     , pIFI->fwdUnderscorePosition);
    vPrint("fwdStrikeoutSize       %d\n"     , pIFI->fwdStrikeoutSize );
    vPrint("fwdStrikeoutPosition   %d\n"     , pIFI->fwdStrikeoutPosition );
    vPrint("chFirstChar            %-#4x\n"  , (int) (BYTE) pIFI->chFirstChar );
    vPrint("chLastChar             %-#4x\n"  , (int) (BYTE) pIFI->chLastChar );
    vPrint("chDefaultChar          %-#4x\n"  , (int) (BYTE) pIFI->chDefaultChar );
    vPrint("chBreakChar            %-#4x\n"  , (int) (BYTE) pIFI->chBreakChar );
    vPrint("wcFirsChar             %-#6x\n"  , pIFI->wcFirstChar );
    vPrint("wcLastChar             %-#6x\n"  , pIFI->wcLastChar );
    vPrint("wcDefaultChar          %-#6x\n"  , pIFI->wcDefaultChar );
    vPrint("wcBreakChar            %-#6x\n"  , pIFI->wcBreakChar );
    vPrint("ptlBaseline            {%d,%d}\n"  , pIFI->ptlBaseline.x,
            pIFI->ptlBaseline.y );
    vPrint("ptlAspect              {%d,%d}\n"  , pIFI->ptlAspect.x,
            pIFI->ptlAspect.y );
    vPrint("ptlCaret               {%d,%d}\n"  , pIFI->ptlCaret.x,
            pIFI->ptlCaret.y );
    vPrint("rclFontBox             {%d,%d,%d,%d}\n",pIFI->rclFontBox.left,
                                                    pIFI->rclFontBox.top,
                                                    pIFI->rclFontBox.right,
                                                    pIFI->rclFontBox.bottom );
    vPrint("achVendId              \"%c%c%c%c\"\n",pIFI->achVendId[0],
                                               pIFI->achVendId[1],
                                               pIFI->achVendId[2],
                                               pIFI->achVendId[3] );
    vPrint("cKerningPairs          %d\n"     , pIFI->cKerningPairs );
    vPrint("ulPanoseCulture        %-#8lx\n" , pIFI->ulPanoseCulture);
    vPrint(
           "panose                 {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                             , ppan->bFamilyType
                                             , ppan->bSerifStyle
                                             , ppan->bWeight
                                             , ppan->bProportion
                                             , ppan->bContrast
                                             , ppan->bStrokeVariation
                                             , ppan->bArmStyle
                                             , ppan->bLetterform
                                             , ppan->bMidline
                                             , ppan->bXHeight );
    BCheckIFIMETRICS(pIFI, vPrint);
}

VOID
VPrintPFM(
    PFMHEADER *pPFMHdr,
    VPRINT vPrint)
/*++

Routine Description:

    Dumps the PFM to the screen

Arguments:

    pFInData - pointer to FONTIN
    vPrint - output function pointer

Return Value:

    None

--*/
{

    vPrint("*************************************************************\n");
    vPrint(" PFM HEADER\n");
    vPrint("*************************************************************\n");
    vPrint("PFM.dfType            =  %d\n", pPFMHdr->dfType);
    vPrint("PFM.dfPoints          =  %d\n", pPFMHdr->dfPoints);
    vPrint("PFM.dfVertRes         =  %d\n", pPFMHdr->dfVertRes);
    vPrint("PFM.dfHorizRes        =  %d\n", pPFMHdr->dfHorizRes);
    vPrint("PFM.dfAscent          =  %d\n", pPFMHdr->dfAscent);
    vPrint("PFM.dfInternalLeading =  %d\n", pPFMHdr->dfInternalLeading);
    vPrint("PFM.dfExternalLeading =  %d\n", pPFMHdr->dfExternalLeading);
    vPrint("PFM.dfItalic          =  %d\n", pPFMHdr->dfItalic);
    vPrint("PFM.dfUnderline       =  %d\n", pPFMHdr->dfUnderline);
    vPrint("PFM.dfStrikeOut       =  %d\n", pPFMHdr->dfStrikeOut);
    vPrint("PFM.dfWeight          =  %d\n", pPFMHdr->dfWeight);
    vPrint("PFM.dfCharSet         =  %d\n", pPFMHdr->dfCharSet);
    vPrint("PFM.dfPixWidth        =  %d\n", pPFMHdr->dfPixWidth);
    vPrint("PFM.dfPixHeight       =  %d\n", pPFMHdr->dfPixHeight);
    vPrint("PFM.dfPitchAndFamily  =  %d\n", pPFMHdr->dfPitchAndFamily);
    vPrint("PFM.dfAvgWidth        =  %d\n", pPFMHdr->dfAvgWidth);
    vPrint("PFM.dfMaxWidth        =  %d\n", pPFMHdr->dfMaxWidth);
    vPrint("PFM.dfFirstChar       =  %d\n", pPFMHdr->dfFirstChar);
    vPrint("PFM.dfLastChar        =  %d\n", pPFMHdr->dfLastChar);
    vPrint("PFM.dfDefaultChar     =  %d\n", pPFMHdr->dfDefaultChar);
    vPrint("PFM.dfBreakChar       =  %d\n", pPFMHdr->dfBreakChar);
    vPrint("PFM.dfWidthBytes      =  %d\n", pPFMHdr->dfWidthBytes);
    vPrint("PFM.dfDevice          =  %d\n", pPFMHdr->dfDevice);
    vPrint("PFM.dfFace            =  %d\n", pPFMHdr->dfFace);
    vPrint("PFM.dfBitsPointer     =  %d\n", pPFMHdr->dfBitsPointer);


}

VOID
VPrintPFMExt(
    PFMEXTENSION *pPFMExt,
    VPRINT        vPrint)
{
    vPrint("*************************************************************\n");
    vPrint(" PFM EXTENSION\n");
    vPrint("*************************************************************\n");
    vPrint("PFMExt.dfSizeFields       =  %d\n", pPFMExt->dfSizeFields);
    vPrint("PFMExt.dfExtMetricsOffset =  %d\n", pPFMExt->dfExtMetricsOffset);
    vPrint("PFMExt.dfExtentTable      =  %d\n", pPFMExt->dfExtentTable);
    vPrint("PFMExt.dfOriginTable      =  %d\n", pPFMExt->dfOriginTable);
    vPrint("PFMExt.dfPairKernTable    =  %d\n", pPFMExt->dfPairKernTable);
    vPrint("PFMExt.dfTrackKernTable   =  %d\n", pPFMExt->dfTrackKernTable);
    vPrint("PFMExt.dfDriverInfo       =  %d\n", pPFMExt->dfDriverInfo);
    vPrint("PFMExt.dfReserved         =  %d\n", pPFMExt->dfReserved);
}

VOID
VPrintETM(
    EXTTEXTMETRIC *pETM,
    VPRINT         vPrint)
{
    vPrint("*************************************************************\n");
    vPrint(" EXTTEXTMETRIC\n");
    vPrint("*************************************************************\n");
    vPrint("pETM->emSize                       = %d\n", pETM->emSize);
    vPrint("pETM->emPointSize                  = %d\n", pETM->emPointSize);
    vPrint("pETM->emOrientation                = %d\n", pETM->emOrientation);
    vPrint("pETM->emMasterHeight               = %d\n", pETM->emMasterHeight);
    vPrint("pETM->emMinScale                   = %d\n", pETM->emMinScale);
    vPrint("pETM->emMaxScale                   = %d\n", pETM->emMaxScale);
    vPrint("pETM->emMasterUnits                = %d\n", pETM->emMasterUnits);
    vPrint("pETM->emCapHeight                  = %d\n", pETM->emCapHeight);
    vPrint("pETM->emXHeight                    = %d\n", pETM->emXHeight);
    vPrint("pETM->emLowerCaseAscent            = %d\n", pETM->emLowerCaseAscent);
    vPrint("pETM->emLowerCaseDescent           = %d\n", pETM->emLowerCaseDescent);
    vPrint("pETM->emSlant                      = %d\n", pETM->emSlant);
    vPrint("pETM->emSuperScript                = %d\n", pETM->emSuperScript);
    vPrint("pETM->emSubScript                  = %d\n", pETM->emSubScript);
    vPrint("pETM->emSuperScriptSize            = %d\n", pETM->emSuperScriptSize);
    vPrint("pETM->emSubScriptSize              = %d\n", pETM->emSubScriptSize);
    vPrint("pETM->emUnderlineOffset            = %d\n", pETM->emUnderlineOffset);
    vPrint("pETM->emUnderlineWidth             = %d\n", pETM->emUnderlineWidth);
    vPrint("pETM->emDoubleUpperUnderlineOffset = %d\n", pETM->emDoubleUpperUnderlineOffset);
    vPrint("pETM->emDoubleLowerUnderlineOffset = %d\n", pETM->emDoubleLowerUnderlineOffset);
    vPrint("pETM->emDoubleUpperUnderlineWidth  = %d\n", pETM->emDoubleUpperUnderlineWidth);
    vPrint("pETM->emDoubleLowerUnderlineWidth  = %d\n", pETM->emDoubleLowerUnderlineWidth);
    vPrint("pETM->emStrikeOutOffset            = %d\n", pETM->emStrikeOutOffset);
    vPrint("pETM->emStrikeOutWidth             = %d\n", pETM->emStrikeOutWidth);
    vPrint("pETM->emKernPairs                  = %d\n", pETM->emKernPairs);
    vPrint("pETM->emKernTracks                 = %d\n", pETM->emKernTracks);
}

VOID
VPrintFontCmd(
    CD     *pCD,
    BOOL    bSelect,
    VPRINT  vPrint)
{
    INT   iI;
    PBYTE pCommand;

    if (!pCD)
        return;

    pCommand = (PBYTE)(pCD + 1);

    if (!pCD->wLength)
    {
        return;
    }

    if (bSelect)
    {
        vPrint("*************************************************************\n");
        vPrint(" COMMAND\n");
        vPrint("*************************************************************\n");

        vPrint("Font Select Command = ");
    }
    else
    {
        vPrint("Font UnSelect Command = ");
    }

    for (iI = 0; iI < pCD->wLength; iI ++, pCommand++)
    {
        if (*pCommand < 0x20 || 0x7e < *pCommand )
        {
            vPrint("\\x%X",*pCommand);
        }
        else
        {
            vPrint("%c",*pCommand);
        }
    }

    vPrint("\n");
}

VOID
VPrintKerningPair(
    w3KERNPAIR *pKernPair,
    DWORD       dwKernPairSize,
    VPRINT      vPrint)
{
}

VOID
VPrintWidthTable(
    PSHORT psWidthTable,
    DWORD  dwWidthTableSize,
    VPRINT vPrint)
{
}

#endif  //  defined(DEVSTUDIO)

DWORD
DwGetCodePageFromGTTID(
    LONG lPredefinedGTTID)
{
    DWORD dwRet;
    switch(lPredefinedGTTID)
    {
        case CC_CP437:
            dwRet = 437;
            break;

        case CC_CP850:
            dwRet = 850;
            break;

        case CC_CP863:
            dwRet = 863;
            break;

        case CC_BIG5:
            dwRet = 950;
            break;

        case CC_ISC:
            dwRet = 949;
            break;

        case CC_JIS:
            dwRet = 932;
            break;

        case CC_JIS_ANK:
            dwRet = 932;
            break;

        case CC_NS86:
            dwRet = 949;
            break;

        case CC_TCA:
            dwRet = 950;
            break;

        case CC_GB2312:
            dwRet = 936;
            break;

        case CC_SJIS:
            dwRet = 932;
            break;

        case CC_WANSUNG:
            dwRet = 949;
            break;

        default:
            dwRet =1252;
            break;

    }
    return dwRet;
}

DWORD
DwGetCodePageFromCTTID(
    LONG lPredefinedCTTID)
{
    DWORD dwRet;

    switch (lPredefinedCTTID)
    {
    case CTT_CP437:
        dwRet = 437;
        break;

    case CTT_CP850:
        dwRet = 850;
        break;

    case CTT_CP863:
        dwRet = 863;
        break;

    case CTT_BIG5:
        dwRet = 950;
        break;

    case CTT_ISC:
        dwRet = 949;
        break;

    case CTT_JIS78:
        dwRet = 932;
        break;

    case CTT_JIS83:
        dwRet = 932;
        break;

    case CTT_JIS78_ANK:
        dwRet = 932;
        break;

    case CTT_JIS83_ANK:
        dwRet = 932;
        break;

    case CTT_NS86:
        dwRet = 950;
        break;

    case CTT_TCA:
        dwRet = 950;
        break;
    default:
        dwRet = 1252;
        break;
    }

    return dwRet;
}

INT ICodePage2GTTID(
    DWORD dwCodePage)
{
    INT iRet;

    switch (dwCodePage)
    {
    case 1252:
        iRet = 0;
        break;

    case 950:
        iRet = CC_BIG5;
        break;

    case 949:
        iRet = CC_WANSUNG;
        break;

    case 932:
        iRet = CC_JIS_ANK;
        break;

    default:
        iRet = 0;
        break;
    }

    return iRet;
}

INT ICttID2GttID(
    LONG lPredefinedCTTID)
{
    INT iRet = lPredefinedCTTID;
    switch (lPredefinedCTTID)
    {

    case CTT_CP437:
        iRet = CC_CP437;
        break;

    case CTT_CP850:
        iRet = CC_CP850;
        break;

    case CTT_CP863:
        iRet = CC_CP863;
        break;

    case CTT_BIG5:
        iRet = CC_BIG5;
        break;

    case CTT_ISC:
        iRet = CC_ISC;
        break;

    case CTT_JIS78:
        iRet = CC_JIS;
        break;

    case CTT_JIS83:
        iRet = CC_JIS;
        break;

    case CTT_JIS78_ANK:
        iRet = CC_JIS_ANK;
        break;

    case CTT_JIS83_ANK:
        iRet = CC_JIS_ANK;
        break;

    case CTT_NS86:
        iRet = CC_NS86;
        break;

    case CTT_TCA:
        iRet = CC_TCA;
        break;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\pfm2ufm\pfmconv.c ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    pfmconv.c

Abstract:

    Windows NT utilities to handle new font format

Environment:

    Windows NT Universal printer driver

Revision History:

    10/31/96 -eigos-
        Created it.

--*/

#include "precomp.h"

//
// Internal macros
//

#define DRIVERINFO_VERSION_WIN31    0x0100
#define DRIVERINFO_VERSION_SIMULATE 0x0150
#define DRIVERINFO_VERSION          0x0200

#define FONT_SIM_NO_ITALIC          1
#define FONT_SIM_NO_BOLD            2
#define FONT_SIM_DJ_BOLD            4

//
// HP DeskJet permutation flags
//

#define HALF_PITCH                  0x01
#define DOUBLE_PITCH                0x02
#define HALF_HEIGHT                 0x04
#define MAKE_BOLD                   0x08

#define BASE_BOLD_MASK      0x30
#define BASE_BOLD_SHIFT     4
#define BASE_BOLD_ADD_0     0x00
#define BASE_BOLD_ADD_1     0x10
#define BASE_BOLD_ADD_2     0x20
#define BASE_BOLD_ADD_3     0x30

//    6/6/97 yasuho: Some PFM have -1 value in wPrivateData.
#define DO_DJFONTSIMBOLD(pFInData)  ((pFInData->DI.wPrivateData != 0xFFFF) && (pFInData->DI.wPrivateData & MAKE_BOLD))

#define DO_FONTSIM(pFInData) \
    (((pFInData)->DI.sVersion == DRIVERINFO_VERSION_WIN31)    || \
     ((pFInData)->DI.sVersion == DRIVERINFO_VERSION_SIMULATE) || \
     IS_DBCSCHARSET((pFInData)->PFMH.dfCharSet) )

#define DWORD_ALIGN(p) ((((ULONG)(p)) + 3) & ~3)

#define IS_DBCSCTTTYPE(sCTT)     \
    (  ((sCTT) == CTT_JIS78)     \
    || ((sCTT) == CTT_JIS78_ANK) \
    || ((sCTT) == CTT_JIS83)     \
    || ((sCTT) == CTT_JIS83_ANK) \
    || ((sCTT) == CTT_NS86)      \
    || ((sCTT) == CTT_TCA)       \
    || ((sCTT) == CTT_BIG5)      \
    || ((sCTT) == CTT_ISC))

#define CTT_TYPE_TO_CHARSET(sCTT) \
    (((sCTT) == CTT_JIS78)     ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_JIS78_ANK) ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_JIS83)     ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_JIS83_ANK) ? SHIFTJIS_CHARSET : \
    (((sCTT) == CTT_NS86)      ? CHINESEBIG5_CHARSET : \
    (((sCTT) == CTT_TCA)       ? CHINESEBIG5_CHARSET : \
    (((sCTT) == CTT_BIG5)      ? CHINESEBIG5_CHARSET : \
    (((sCTT) == CTT_ISC)       ? HANGEUL_CHARSET : 1))))))))
    
#define OUTPUT_VERBOSE 0x00000001

#define BBITS       8
#define DWBITS       (BBITS * sizeof( DWORD ))
#define DW_MASK       (DWBITS - 1)


//
// Definitions
//

extern DWORD gdwOutputFlags;

typedef VOID (*VPRINT) (char*,...);

//
// Internal function prorotypes
//

BOOL BCreateWidthTable( IN HANDLE, IN PWORD, IN WORD, IN WORD, IN PSHORT, OUT PWIDTHTABLE *, OUT PDWORD);
BOOL BCreateKernData( IN HANDLE, IN w3KERNPAIR*, IN DWORD, OUT PKERNDATA*, OUT PDWORD);
WORD WGetGlyphHandle(PUNI_GLYPHSETDATA, WORD);
PUNI_GLYPHSETDATA PGetDefaultGlyphset( IN HANDLE, IN WORD, IN WORD, IN DWORD);
LONG LCtt2Cc(IN SHORT, IN SHORT);

//
//
// PFM file handling functions
//
//

BOOL
BFontInfoToIFIMetric(
    IN HANDLE       hHeap,
    IN FONTIN     *pFInData,
    IN PWSTR        pwstrUniqNm,
    IN DWORD        dwCodePageOfFacenameConv,
    IN OUT PIFIMETRICS *ppIFI,
    IN OUT PDWORD   pdwSize,
    IN DWORD        dwFlags)

/*++

Routine Description:

    Convert the Win 3.1 format PFM data to NT's IFIMETRICS.  This is
    typically done before the minidrivers are built,  so that they
    can include IFIMETRICS, and thus have less work to do at run time.

Arguments:

    pFInData - Font data info for conversion
    pwstrUniqNm - Unique name component

Return Value:

    TRUE if successfull, otherwise FALSE.

--*/

{
    FONTSIM  *pFontSim;
    FONTDIFF *pfdiffBold = 0, *pfdiffItalic = 0, *pfdiffBoldItalic = 0;
    PIFIEXTRA pIFIExtra;

    FWORD  fwdExternalLeading;

    INT    icWChar;             /* Number of WCHARS to add */
    INT    icbAlloc;             /* Number of bytes to allocate */
    INT    iI;                  /* Loop index */
    INT    iCount;              /* Number of characters in Win 3.1 font */

    WCHAR *pwchTmp;             /* For string manipulations */

    WCHAR   awcAttrib[ 256 ];   /* Generate attributes + BYTE -> WCHAR */
    BYTE    abyte[ 256 ];       /* Used (with above) to get wcLastChar etc */

    WORD fsFontSim = 0;
    INT cFontDiff;
    UINT uiCodePage;

    CHARSETINFO ci;

    //
    // Calculate the size of three face names buffer
    //

    icWChar =  3 * strlen( pFInData->pBase + pFInData->PFMH.dfFace );

    //
    //   Produce the desired attributes: Italic, Bold, Light etc.
    // This is largely guesswork,  and there should be a better method.
    // Write out an empty string 
    //

    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';

    if( pFInData->PFMH.dfItalic )
    {
        StringCchCatW( awcAttrib, CCHOF(awcAttrib), L" Italic" );
    }

    if( pFInData->PFMH.dfWeight >= 700 )
    {
        StringCchCatW( awcAttrib, CCHOF(awcAttrib), L" Bold" );
    }
    else if( pFInData->PFMH.dfWeight < 200 )
    {
        StringCchCatW( awcAttrib, CCHOF(awcAttrib), L" Light" );
    }

    //
    //   The attribute string appears in 3 entries of IFIMETRICS,  so
    // calculate how much storage this will take.  NOTE THAT THE LEADING
    // CHAR IN awcAttrib is NOT placed in the style name field,  so we
    // subtract one in the following formula to account for this.
    //

    if( awcAttrib[ 0 ] )
    {
        icWChar += 3 * wcslen( awcAttrib ) - 1;
    }

    //
    // Should be printer name
    //

    icWChar += wcslen( pwstrUniqNm ) + 1;

    //
    // Terminating nulls
    //

    icWChar += 4;

    //
    // Total size of IFIMETRICS structure
    //

    icbAlloc = DWORD_ALIGN(sizeof( IFIMETRICS ) + sizeof( WCHAR ) * icWChar);

    //
    // For HeskJet font.
    //
    if (DO_DJFONTSIMBOLD(pFInData))
    {
        fsFontSim |= FONT_SIM_DJ_BOLD;
        icbAlloc = DWORD_ALIGN(icbAlloc) +
                   DWORD_ALIGN(sizeof(FONTSIM)) +
                   DWORD_ALIGN(sizeof(FONTDIFF));
    }
    else
    //
    // For CJK font.
    // Judge which font simulation to be enabled, then allocate the
    // necessary storage.
    //
    if (DO_FONTSIM(pFInData) || pFInData->dwFlags & FLAG_FONTSIM)
    {
        cFontDiff = 4;

        //
        // Decide which attribute should be diabled.  We won't simulate
        // if the user does not desires it.  We won't italicize in case
        // it is an italic font, etc.
        //

        if ( pFInData->PFMH.dfItalic || (pFInData->DI.fCaps & DF_NOITALIC))
        {
            fsFontSim |= FONT_SIM_NO_ITALIC;
            cFontDiff /= 2;
        }

        if( pFInData->PFMH.dfWeight >= 700 || (pFInData->DI.fCaps & DF_NO_BOLD))
        {
            fsFontSim |= FONT_SIM_NO_BOLD;
            cFontDiff /= 2;
        }

        cFontDiff--;

        if ( cFontDiff > 0)
        {
            icbAlloc  = DWORD_ALIGN(icbAlloc);
            icbAlloc += (DWORD_ALIGN(sizeof(FONTSIM)) +
                        cFontDiff * DWORD_ALIGN(sizeof(FONTDIFF)));
        }
    }
#if DBG
    DbgPrint( "cFontDiff = %d", cFontDiff);
#endif

    //
    // IFIEXTRA
    //
    // Fill out IFIEXTRA.cig.
    //

    icbAlloc += sizeof(IFIEXTRA);

    //
    // Allocate memory
    //

    *ppIFI = (IFIMETRICS *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, icbAlloc);
    *pdwSize = icbAlloc;

    if (NULL == *ppIFI)
    {
        return FALSE;
    }

    (*ppIFI)->cjThis     = icbAlloc;
    (*ppIFI)->cjIfiExtra = 0;

    //
    // The family name:  straight from the FaceName - no choice??
    //
    // -IFIMETRICS memory image-
    //   IFIMETRICS
    //   IFIEXTRA
    //   FamilyName
    //   StyleName
    //   FaceName
    //   UniqueName
    //

    pIFIExtra                 = (PIFIEXTRA)(*ppIFI + 1);
    pIFIExtra->dpFontSig      = 0;
    pIFIExtra->cig            = pFInData->PFMH.dfLastChar -
                                pFInData->PFMH.dfFirstChar + 1;
    pIFIExtra->dpDesignVector = 0;
    pIFIExtra->dpAxesInfoW    = 0;


    pwchTmp = (WCHAR*)((PBYTE)(*ppIFI + 1) + sizeof(IFIEXTRA));
	(*ppIFI)->dpwszFamilyName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));

    if (dwCodePageOfFacenameConv)
        uiCodePage = dwCodePageOfFacenameConv;
    else
        uiCodePage = UlCharsetToCodePage(pFInData->PFMH.dfCharSet);

    DwCopyStringToUnicodeString( uiCodePage,
                                 pFInData->pBase + pFInData->PFMH.dfFace,
                                 pwchTmp,
                                 icWChar);

    pwchTmp += wcslen( pwchTmp ) + 1;
    icWChar -= wcslen( pwchTmp ) + 1;

    //
    // Now the face name:  we add bold, italic etc to family name
    //
    (*ppIFI)->dpwszFaceName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));


    DwCopyStringToUnicodeString( uiCodePage,
                                 pFInData->pBase + pFInData->PFMH.dfFace,
                                 pwchTmp,
                                 icWChar);

    StringCchCatW( pwchTmp, icWChar, awcAttrib );

    //
    //   Now the unique name - well, sort of, anyway
    //

    icWChar -= (wcslen( pwchTmp ) + 1);
    pwchTmp += wcslen( pwchTmp ) + 1;         /* Skip what we just put in */
    (*ppIFI)->dpwszUniqueName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));

    StringCchCopyW( pwchTmp, icWChar, pwstrUniqNm );     /* Append printer name for uniqueness */
    StringCchCatW( pwchTmp, icWChar, L" " );
    StringCchCatW( pwchTmp, icWChar, (PWSTR)((BYTE *)(*ppIFI) + (*ppIFI)->dpwszFaceName) );

    /*  Onto the attributes only component */

    icWChar -= (wcslen( pwchTmp ) + 1);
    pwchTmp += wcslen( pwchTmp ) + 1;         /* Skip what we just put in */
    (*ppIFI)->dpwszStyleName = (PTRDIFF)((BYTE *)pwchTmp - (BYTE *)(*ppIFI));
    StringCchCatW( pwchTmp, icWChar, &awcAttrib[ 1 ] );


#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "BFontInfoToIFIMetrics: STACK CORRUPTED BY awcAttrib" );

        HeapFree(hHeap, 0, (LPSTR)(*ppIFI) );         /* No memory leaks */

        return  FALSE;
    }


    if( ((BYTE *)(pwchTmp + wcslen( pwchTmp ) + 1)) > ((BYTE *)(*ppIFI) + icbAlloc) )
    {
        DbgPrint( "BFontInfoToIFIMetrics: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwchTmp + wcslen( pwchTmp ) + 1)),
                ((BYTE *)(*ppIFI) + icbAlloc) );

        HeapFree(hHeap, 0, (LPSTR)(*ppIFI) );         /* No memory leaks */

        return  0;

    }
#endif

    pwchTmp += wcslen( pwchTmp ) + 1;         /* Skip what we just put in */

    //
    // For HeskJet font.
    //
    if (fsFontSim & FONT_SIM_DJ_BOLD)
    {
        pFontSim = (FONTSIM *)pwchTmp;

        (*ppIFI)->dpFontSim = (PTRDIFF)((BYTE *)pFontSim - (BYTE *)(*ppIFI) );

        pFontSim->dpBold = DWORD_ALIGN(sizeof(FONTSIM));
        pfdiffBold = (FONTDIFF *)((BYTE *)pFontSim + pFontSim->dpBold);

        pFontSim->dpItalic     = 0;
        pFontSim->dpBoldItalic = 0;
    }
    else
    if ((DO_FONTSIM( pFInData ) || pFInData->dwFlags & FLAG_FONTSIM) && cFontDiff > 0)
    //
    // For CJK font.
    // Judge which font simulation to be enabled, then allocate the
    // necessary storage.
    //
    {
        PTRDIFF dpTmp;

        // n.b.: FONTSIM, FONTDIFF have to be dword-aligned

//      pFontSim = (FONTSIM *)PtrToUlong(pwchTmp);

		pFontSim = (FONTSIM *)pwchTmp;

        (*ppIFI)->dpFontSim = (PTRDIFF)((BYTE *)pFontSim - (BYTE *)(*ppIFI) );

        dpTmp = DWORD_ALIGN(sizeof(FONTSIM));

        if (!(fsFontSim & FONT_SIM_NO_BOLD))
        {
            pFontSim->dpBold = dpTmp;
            pfdiffBold = (FONTDIFF *)((BYTE *)pFontSim + dpTmp);
            dpTmp += DWORD_ALIGN(sizeof(FONTDIFF));

            if (!(fsFontSim & FONT_SIM_NO_ITALIC))
            {
                pFontSim->dpBoldItalic = dpTmp;
                pfdiffBoldItalic = (FONTDIFF *)((BYTE *)pFontSim + dpTmp);
                dpTmp += DWORD_ALIGN(sizeof(FONTDIFF));
            }
        }
        else
        if (!(fsFontSim & FONT_SIM_NO_ITALIC))
        {
            pFontSim->dpItalic = dpTmp;
            pfdiffItalic = (FONTDIFF *)((BYTE *)pFontSim + dpTmp);
            dpTmp += DWORD_ALIGN(sizeof(FONTDIFF));
        }

        pwchTmp = (WCHAR *)((BYTE *)pFontSim + dpTmp);
    }

    // check again...

    if ((BYTE *)(pwchTmp) > ((BYTE *)(*ppIFI) + icbAlloc))
    {
#if DBG
        DbgPrint( "BFontInfoToIFIMetrics: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)pwchTmp),
                ((BYTE *)(*ppIFI) + icbAlloc) );
#endif

        HeapFree( hHeap, 0, (LPSTR)(*ppIFI) );         /* No memory leaks */

        return  0;

    }

    {
        int i;

        (*ppIFI)->lEmbedId     = 0;
        (*ppIFI)->lItalicAngle = 0;
        (*ppIFI)->lCharBias    = 0;
        (*ppIFI)->dpCharSets   = 0; // no multiple charsets in rasdd fonts
    }
    (*ppIFI)->jWinCharSet = (BYTE)pFInData->PFMH.dfCharSet;

    //
    // If FE Ctt table is used, this overrides what defined in charset
    //

    if (IS_DBCSCTTTYPE(-(pFInData->DI.sTransTab)))
    {
        (*ppIFI)->jWinCharSet = CTT_TYPE_TO_CHARSET(-(pFInData->DI.sTransTab));
    }


    if( pFInData->PFMH.dfPixWidth )
    {
        (*ppIFI)->jWinPitchAndFamily |= FIXED_PITCH;
        (*ppIFI)->flInfo |= (FM_INFO_CONSTANT_WIDTH | FM_INFO_OPTICALLY_FIXED_PITCH);


       if(IS_DBCSCHARSET((*ppIFI)->jWinCharSet))
        {
            // it is too strict to call a DBCS font "fixed pitch" since it has
            // both halfwidth glyphs and fullwidth glyphs.
            (*ppIFI)->flInfo &= ~FM_INFO_CONSTANT_WIDTH;
            (*ppIFI)->flInfo |= (FM_INFO_OPTICALLY_FIXED_PITCH |
                             FM_INFO_DBCS_FIXED_PITCH);
        }


    }
    else
    {
        (*ppIFI)->jWinPitchAndFamily |= VARIABLE_PITCH;

        if(IS_DBCSCHARSET((*ppIFI)->jWinCharSet))
        {
            // DBCS glyphs are always fixed pitch even if the SBCS part is
            // variable pitch.
            (*ppIFI)->flInfo |= FM_INFO_DBCS_FIXED_PITCH;
        }
    }


    (*ppIFI)->jWinPitchAndFamily |= (((BYTE) pFInData->PFMH.dfPitchAndFamily) & 0xf0);

    (*ppIFI)->usWinWeight = (USHORT)pFInData->PFMH.dfWeight;

    //
    // IFIMETRICS::flInfo
    //

    (*ppIFI)->flInfo |=
        FM_INFO_TECH_BITMAP    |
        FM_INFO_1BPP           |
        FM_INFO_INTEGER_WIDTH  |
        FM_INFO_NOT_CONTIGUOUS |
        FM_INFO_RIGHT_HANDED;


    /*
     *    A scalable font?  This happens when there is EXTTEXTMETRIC data,
     *  and that data has a min size different to the max size.
     */

    if( pFInData->pETM &&
        pFInData->pETM->emMinScale != pFInData->pETM->emMaxScale )
    {
       (*ppIFI)->flInfo        |= FM_INFO_ISOTROPIC_SCALING_ONLY;
       (*ppIFI)->fwdUnitsPerEm  = pFInData->pETM->emMasterUnits;
    }
    else
    {
        (*ppIFI)->fwdUnitsPerEm =
            (FWORD) (pFInData->PFMH.dfPixHeight - pFInData->PFMH.dfInternalLeading);
    }

#ifndef PFM2UFM_SCALING_ANISOTROPIC
#define PFM2UFM_SCALING_ANISOTROPIC     1
#endif
#ifndef PFM2UFM_SCALING_ARB_XFORMS
#define PFM2UFM_SCALING_ARB_XFORMS      2
#endif

    if ((*ppIFI)->flInfo & FM_INFO_ISOTROPIC_SCALING_ONLY) {

        // Allow forcing non-standard scaling only if the
        // font is already scalable.
        if ((dwFlags & PFM2UFM_SCALING_ANISOTROPIC)) {
           (*ppIFI)->flInfo &= ~FM_INFO_ISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo |= FM_INFO_ANISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo &= ~FM_INFO_ARB_XFORMS;
        }
        else  if ((dwFlags & PFM2UFM_SCALING_ARB_XFORMS)) {
           (*ppIFI)->flInfo &= ~FM_INFO_ISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo &= ~FM_INFO_ANISOTROPIC_SCALING_ONLY;
           (*ppIFI)->flInfo |= FM_INFO_ARB_XFORMS;
        }
    }

    (*ppIFI)->fsSelection =
        ((pFInData->PFMH.dfItalic            ) ? FM_SEL_ITALIC     : 0)    |
        ((pFInData->PFMH.dfUnderline         ) ? FM_SEL_UNDERSCORE : 0)    |
        ((pFInData->PFMH.dfStrikeOut         ) ? FM_SEL_STRIKEOUT  : 0)    |
        ((pFInData->PFMH.dfWeight >= FW_BOLD ) ? FM_SEL_BOLD       : 0) ;

    (*ppIFI)->fsType        = FM_NO_EMBEDDING;
    (*ppIFI)->fwdLowestPPEm = 1;


    /*
     * Calculate fwdWinAscender, fwdWinDescender, fwdAveCharWidth, and
     * fwdMaxCharInc assuming a bitmap where 1 font unit equals one
     * pixel unit
     */

    (*ppIFI)->fwdWinAscender = (FWORD)pFInData->PFMH.dfAscent;

    (*ppIFI)->fwdWinDescender =
        (FWORD)pFInData->PFMH.dfPixHeight - (*ppIFI)->fwdWinAscender;

    (*ppIFI)->fwdMaxCharInc   = (FWORD)pFInData->PFMH.dfMaxWidth;
    (*ppIFI)->fwdAveCharWidth = (FWORD)pFInData->PFMH.dfAvgWidth;

    fwdExternalLeading = (FWORD)pFInData->PFMH.dfExternalLeading;

//
// If the font was scalable, then the answers must be scaled up
// !!! HELP HELP HELP - if a font is scalable in this sense, then
//     does it support arbitrary transforms? [kirko]
//

    if( (*ppIFI)->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY |
                          FM_INFO_ANISOTROPIC_SCALING_ONLY |
                          FM_INFO_ARB_XFORMS))
    {
        /*
         *    This is a scalable font:  because there is Extended Text Metric
         *  information available,  and this says that the min and max
         *  scale sizes are different:  thus it is scalable! This test is
         *  lifted directly from the Win 3.1 driver.
         */

        int iMU,  iRel;            /* Adjustment factors */

        iMU  = pFInData->pETM->emMasterUnits;
        iRel = pFInData->PFMH.dfPixHeight;

        (*ppIFI)->fwdWinAscender = ((*ppIFI)->fwdWinAscender * iMU) / iRel;

        (*ppIFI)->fwdWinDescender = ((*ppIFI)->fwdWinDescender * iMU) / iRel;

        (*ppIFI)->fwdMaxCharInc = ((*ppIFI)->fwdMaxCharInc * iMU) / iRel;

        (*ppIFI)->fwdAveCharWidth = ((*ppIFI)->fwdAveCharWidth * iMU) / iRel;

        fwdExternalLeading = (fwdExternalLeading * iMU) / iRel;
    }

    (*ppIFI)->fwdMacAscender =    (*ppIFI)->fwdWinAscender;
    (*ppIFI)->fwdMacDescender = - (*ppIFI)->fwdWinDescender;

    (*ppIFI)->fwdMacLineGap   =  fwdExternalLeading;

    (*ppIFI)->fwdTypoAscender  = (*ppIFI)->fwdMacAscender;
    (*ppIFI)->fwdTypoDescender = (*ppIFI)->fwdMacDescender;
    (*ppIFI)->fwdTypoLineGap   = (*ppIFI)->fwdMacLineGap;

    // for Windows 3.1J compatibility

    if(IS_DBCSCHARSET((*ppIFI)->jWinCharSet))
    {
        (*ppIFI)->fwdMacLineGap = 0;
        (*ppIFI)->fwdTypoLineGap = 0;
    }

    if( pFInData->pETM )
    {
        /*
         *    Zero is a legitimate default for these.  If 0, gdisrv
         *  chooses some default values.
         */
        (*ppIFI)->fwdCapHeight = pFInData->pETM->emCapHeight;
        (*ppIFI)->fwdXHeight = pFInData->pETM->emXHeight;

        (*ppIFI)->fwdSubscriptYSize = pFInData->pETM->emSubScriptSize;
        (*ppIFI)->fwdSubscriptYOffset = pFInData->pETM->emSubScript;

        (*ppIFI)->fwdSuperscriptYSize = pFInData->pETM->emSuperScriptSize;
        (*ppIFI)->fwdSuperscriptYOffset = pFInData->pETM->emSuperScript;

        (*ppIFI)->fwdUnderscoreSize = pFInData->pETM->emUnderlineWidth;
        (*ppIFI)->fwdUnderscorePosition = pFInData->pETM->emUnderlineOffset;

        (*ppIFI)->fwdStrikeoutSize = pFInData->pETM->emStrikeOutWidth;
        (*ppIFI)->fwdStrikeoutPosition = pFInData->pETM->emStrikeOutOffset;

    }
    else
    {
        /*  No additional information, so do some calculations  */
        (*ppIFI)->fwdSubscriptYSize = (*ppIFI)->fwdWinAscender/4;
        (*ppIFI)->fwdSubscriptYOffset = -((*ppIFI)->fwdWinAscender/4);

        (*ppIFI)->fwdSuperscriptYSize = (*ppIFI)->fwdWinAscender/4;
        (*ppIFI)->fwdSuperscriptYOffset = (3 * (*ppIFI)->fwdWinAscender)/4;

        (*ppIFI)->fwdUnderscoreSize = (*ppIFI)->fwdWinAscender / 12;
        if( (*ppIFI)->fwdUnderscoreSize < 1 )
            (*ppIFI)->fwdUnderscoreSize = 1;

        (*ppIFI)->fwdUnderscorePosition = -pFInData->DI.sUnderLinePos;

        (*ppIFI)->fwdStrikeoutSize     = (*ppIFI)->fwdUnderscoreSize;

        (*ppIFI)->fwdStrikeoutPosition = (FWORD)pFInData->DI.sStrikeThruPos;
        if( (*ppIFI)->fwdStrikeoutPosition  < 1 )
            (*ppIFI)->fwdStrikeoutPosition = ((*ppIFI)->fwdWinAscender + 2) / 3;
    }

    (*ppIFI)->fwdSubscriptXSize = (*ppIFI)->fwdAveCharWidth/4;
    (*ppIFI)->fwdSubscriptXOffset =  (3 * (*ppIFI)->fwdAveCharWidth)/4;

    (*ppIFI)->fwdSuperscriptXSize = (*ppIFI)->fwdAveCharWidth/4;
    (*ppIFI)->fwdSuperscriptXOffset = (3 * (*ppIFI)->fwdAveCharWidth)/4;



    (*ppIFI)->chFirstChar = pFInData->PFMH.dfFirstChar;
    (*ppIFI)->chLastChar  = pFInData->PFMH.dfLastChar;

    //
    //   We now do the conversion of these to Unicode.  We presume the
    // input is in the ANSI code page,  and call the NLS converion
    // functions to generate proper Unicode values.
    //

    iCount = pFInData->PFMH.dfLastChar - pFInData->PFMH.dfFirstChar + 1;

    for( iI = 0; iI < iCount; ++iI )
        abyte[ iI ] = iI + pFInData->PFMH.dfFirstChar;

    DwCopyStringToUnicodeString( uiCodePage,
                                 abyte,
                                 awcAttrib,
                                 iCount);

    //
    // Now fill in the IFIMETRICS WCHAR fields.
    //

    (*ppIFI)->wcFirstChar = 0xffff;
    (*ppIFI)->wcLastChar = 0;

    //
    //   Look for the first and last
    //

    for( iI = 0; iI < iCount; ++iI )
    {
        if( (*ppIFI)->wcFirstChar > awcAttrib[ iI ] )
            (*ppIFI)->wcFirstChar = awcAttrib[ iI ];

        if( (*ppIFI)->wcLastChar < awcAttrib[ iI ] )
            (*ppIFI)->wcLastChar = awcAttrib[ iI ];

    }

    (*ppIFI)->wcDefaultChar = awcAttrib[ pFInData->PFMH.dfDefaultChar ];

    (*ppIFI)->wcBreakChar = awcAttrib[ pFInData->PFMH.dfBreakChar ];

    (*ppIFI)->chDefaultChar = pFInData->PFMH.dfDefaultChar + pFInData->PFMH.dfFirstChar;
    (*ppIFI)->chBreakChar   = pFInData->PFMH.dfBreakChar   + pFInData->PFMH.dfFirstChar;


    if( pFInData->PFMH.dfItalic )
    {
    //
    // tan (17.5 degrees) = .3153
    //
        (*ppIFI)->ptlCaret.x      = 3153;
        (*ppIFI)->ptlCaret.y      = 10000;
    }
    else
    {
        (*ppIFI)->ptlCaret.x      = 0;
        (*ppIFI)->ptlCaret.y      = 1;
    }

    (*ppIFI)->ptlBaseline.x = 1;
    (*ppIFI)->ptlBaseline.y = 0;

    (*ppIFI)->ptlAspect.x =  pFInData->PFMH.dfHorizRes;
    (*ppIFI)->ptlAspect.y =  pFInData->PFMH.dfVertRes;

    (*ppIFI)->rclFontBox.left   = 0;
    (*ppIFI)->rclFontBox.top    =   (LONG) (*ppIFI)->fwdWinAscender;
    (*ppIFI)->rclFontBox.right  =   (LONG) (*ppIFI)->fwdMaxCharInc;
    (*ppIFI)->rclFontBox.bottom = - (LONG) (*ppIFI)->fwdWinDescender;

    (*ppIFI)->achVendId[0] = 'U';
    (*ppIFI)->achVendId[1] = 'n';
    (*ppIFI)->achVendId[2] = 'k';
    (*ppIFI)->achVendId[3] = 'n';

    (*ppIFI)->cKerningPairs = 0;

    (*ppIFI)->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    (*ppIFI)->panose.bFamilyType      = PAN_ANY;
    (*ppIFI)->panose.bSerifStyle      = PAN_ANY;
    if(pFInData->PFMH.dfWeight >= FW_BOLD)
    {
        (*ppIFI)->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else if (pFInData->PFMH.dfWeight > FW_EXTRALIGHT)
    {
        (*ppIFI)->panose.bWeight = PAN_WEIGHT_MEDIUM;
    }
    else
    {
        (*ppIFI)->panose.bWeight = PAN_WEIGHT_LIGHT;
    }
    (*ppIFI)->panose.bProportion      = PAN_ANY;
    (*ppIFI)->panose.bContrast        = PAN_ANY;
    (*ppIFI)->panose.bStrokeVariation = PAN_ANY;
    (*ppIFI)->panose.bArmStyle        = PAN_ANY;
    (*ppIFI)->panose.bLetterform      = PAN_ANY;
    (*ppIFI)->panose.bMidline         = PAN_ANY;
    (*ppIFI)->panose.bXHeight         = PAN_ANY;

    if (fsFontSim & FONT_SIM_DJ_BOLD)
    {
        FONTDIFF FontDiff;
        SHORT    sAddBold;

        FontDiff.jReserved1        = 0;
        FontDiff.jReserved2        = 0;
        FontDiff.jReserved3        = 0;
        FontDiff.bWeight           = (*ppIFI)->panose.bWeight;
        FontDiff.usWinWeight       = (*ppIFI)->usWinWeight;
        FontDiff.fsSelection       = (*ppIFI)->fsSelection;
        FontDiff.fwdAveCharWidth   = (*ppIFI)->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc     = (*ppIFI)->fwdMaxCharInc;
        FontDiff.ptlCaret          = (*ppIFI)->ptlCaret;

        if (pfdiffBold)
        {
            sAddBold = (pFInData->DI.wPrivateData & BASE_BOLD_MASK) >>
                        BASE_BOLD_SHIFT;

            *pfdiffBold                  = FontDiff;
            pfdiffBold->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;
            pfdiffBold->fwdAveCharWidth += sAddBold;
            pfdiffBold->fwdMaxCharInc   += sAddBold;
        }
    }
    else
    if ( (DO_FONTSIM( pFInData ) || pFInData->dwFlags & FLAG_FONTSIM) &&
         cFontDiff > 0 )
    {
        FONTDIFF FontDiff;

        FontDiff.jReserved1        = 0;
        FontDiff.jReserved2        = 0;
        FontDiff.jReserved3        = 0;
        FontDiff.bWeight           = (*ppIFI)->panose.bWeight;
        FontDiff.usWinWeight       = (*ppIFI)->usWinWeight;
        FontDiff.fsSelection       = (*ppIFI)->fsSelection;
        FontDiff.fwdAveCharWidth   = (*ppIFI)->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc     = (*ppIFI)->fwdMaxCharInc;
        FontDiff.ptlCaret          = (*ppIFI)->ptlCaret;

        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBold->bWeight                = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection           |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight            = FW_BOLD;
            pfdiffBold->fwdAveCharWidth       += 1;
            pfdiffBold->fwdMaxCharInc         += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection         |= FM_SEL_ITALIC;
            pfdiffItalic->ptlCaret.x           = 1;
            pfdiffItalic->ptlCaret.y           = 2;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;
            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
            pfdiffBoldItalic->ptlCaret.x       = 1;
            pfdiffBoldItalic->ptlCaret.y       = 2;
        }
    }

    return TRUE;
}


BOOL
BGetFontSelFromPFM(
    HANDLE      hHeap,
    FONTIN     *pFInData,       // Access to font info,  aligned
    BOOL        bSelect,
    CMDSTRING  *pCmdStr)
{
    LOCD locd;     // From originating data
    CD  *pCD, **ppCDTrg;


    if (bSelect)
    {
        locd   = pFInData->DI.locdSelect;
        ppCDTrg = &pFInData->pCDSelectFont;
    }
    else
    {
        locd   = pFInData->DI.locdUnSelect;
        ppCDTrg = &pFInData->pCDUnSelectFont;
    }


    if( locd != 0xFFFFFFFF) // NOOCD
    {
        DWORD   dwSize;

        pCD = (CD *)(pFInData->pBase + locd);

        //
        //   The data pointed at by pCD may not be aligned,  so we copy
        // it into a local structure.  This local structure then allows
        // us to determine how big the CD really is (using it's length field),
        // so then we can allocate storage and copy as required.
        //

        //
        // Allocate storage area in the heap 
        //

        dwSize = pCD->wLength;

        pCmdStr->pCmdString = (PBYTE)HeapAlloc( hHeap,
                                                0,
                                                (dwSize + 3) & ~0x3 );

        if (NULL == pCmdStr->pCmdString)
            //
            // Check if HeapAlloc succeeded.
            //
            return FALSE;

        pCmdStr->dwSize = dwSize;

        CopyMemory((PBYTE)pCmdStr->pCmdString, (PBYTE)(pCD + 1), dwSize);

        *ppCDTrg = pCD;

        return  TRUE;
    }

    pCmdStr->dwSize = 0;

    return   FALSE;
}

BOOL
BAlignPFM(
    FONTIN   *pFInData) //  Has ALL we need!

/*++

Routine Description:

    Convert the non-aligned windows format data into a properly
    aligned structure for our use.  Only some of the data is converted
    here,  since we are mostly interested in extracting the addresses
    contained in these structures.

Arguments:

    pFInData - pointer to FONTIN


Return Value:

    TRUE if successfull, otherwise fail to convert.

--*/

{
    BYTE    *pb;        /* Miscellaneous operations */

    res_PFMHEADER    *pPFM;    /* The resource data format */
    res_PFMEXTENSION *pR_PFME;    /* Resource data PFMEXT format */


    /*
     *   Align the PFMHEADER structure.
     */

    pPFM = (res_PFMHEADER *)pFInData->pBase;

    pFInData->PFMH.dfType            = pPFM->dfType;
    pFInData->PFMH.dfPoints          = pPFM->dfPoints;
    pFInData->PFMH.dfVertRes         = pPFM->dfVertRes;
    pFInData->PFMH.dfHorizRes        = pPFM->dfHorizRes;
    pFInData->PFMH.dfAscent          = pPFM->dfAscent;
    pFInData->PFMH.dfInternalLeading = pPFM->dfInternalLeading;
    pFInData->PFMH.dfExternalLeading = pPFM->dfExternalLeading;
    pFInData->PFMH.dfItalic          = pPFM->dfItalic;
    pFInData->PFMH.dfUnderline       = pPFM->dfUnderline;
    pFInData->PFMH.dfStrikeOut       = pPFM->dfStrikeOut;

    pFInData->PFMH.dfWeight          = DwAlign2( pPFM->b_dfWeight );

    pFInData->PFMH.dfCharSet         = pPFM->dfCharSet;
    pFInData->PFMH.dfPixWidth        = pPFM->dfPixWidth;
    pFInData->PFMH.dfPixHeight       = pPFM->dfPixHeight;
    pFInData->PFMH.dfPitchAndFamily  = pPFM->dfPitchAndFamily;

    pFInData->PFMH.dfAvgWidth        = DwAlign2( pPFM->b_dfAvgWidth );
    pFInData->PFMH.dfMaxWidth        = DwAlign2( pPFM->b_dfMaxWidth );

    pFInData->PFMH.dfFirstChar       = pPFM->dfFirstChar;
    pFInData->PFMH.dfLastChar        = pPFM->dfLastChar;
    pFInData->PFMH.dfDefaultChar     = pPFM->dfDefaultChar;
    pFInData->PFMH.dfBreakChar       = pPFM->dfBreakChar;

    pFInData->PFMH.dfWidthBytes      = DwAlign2( pPFM->b_dfWidthBytes );

    pFInData->PFMH.dfDevice          = DwAlign4( pPFM->b_dfDevice );
    pFInData->PFMH.dfFace            = DwAlign4( pPFM->b_dfFace );
    pFInData->PFMH.dfBitsPointer     = DwAlign4( pPFM->b_dfBitsPointer );
    pFInData->PFMH.dfBitsOffset      = DwAlign4( pPFM->b_dfBitsOffset );


    /*
     *   The PFMEXTENSION follows the PFMHEADER structure plus any width
     *  table info.  The width table will be present if the PFMHEADER has
     *  a zero width dfPixWidth.  If present,  adjust the extension address.
     */

    pb = pFInData->pBase + sizeof( res_PFMHEADER );  /* Size in resource data */

    if( pFInData->PFMH.dfPixWidth == 0 )
    {
        pb += (pFInData->PFMH.dfLastChar - pFInData->PFMH.dfFirstChar + 2) *
              sizeof( short );
    }

    pR_PFME = (res_PFMEXTENSION *)pb;

    //
    // Now convert the extended PFM data.
    //

    pFInData->PFMExt.dfSizeFields       = pR_PFME->dfSizeFields;

    pFInData->PFMExt.dfExtMetricsOffset = DwAlign4( pR_PFME->b_dfExtMetricsOffset );
    pFInData->PFMExt.dfExtentTable      = DwAlign4( pR_PFME->b_dfExtentTable );

    pFInData->PFMExt.dfOriginTable      = DwAlign4( pR_PFME->b_dfOriginTable );
    pFInData->PFMExt.dfPairKernTable    = DwAlign4( pR_PFME->b_dfPairKernTable );
    pFInData->PFMExt.dfTrackKernTable   = DwAlign4( pR_PFME->b_dfTrackKernTable );
    pFInData->PFMExt.dfDriverInfo       = DwAlign4( pR_PFME->b_dfDriverInfo );
    pFInData->PFMExt.dfReserved         = DwAlign4( pR_PFME->b_dfReserved );

    CopyMemory( &pFInData->DI,
                pFInData->pBase + pFInData->PFMExt.dfDriverInfo,
                sizeof( DRIVERINFO ) );

    //
    // Also need to fill in the address of the EXTTEXTMETRIC. This
    // is obtained from the extended PFM data that we just converted!
    //

    if( pFInData->PFMExt.dfExtMetricsOffset )
    {
        //
        //    This structure is only an array of shorts, so there is
        //  no alignment problem.  However,  the data itself is not
        //  necessarily aligned in the resource!
        //

        int    cbSize;
        BYTE  *pbIn;             /* Source of data to shift */

        pbIn = pFInData->pBase + pFInData->PFMExt.dfExtMetricsOffset;
        cbSize = DwAlign2( pbIn );

        if( cbSize == sizeof( EXTTEXTMETRIC ) )
        {
            /*   Simply copy it!  */
            CopyMemory( pFInData->pETM, pbIn, cbSize );
        }
        else
        {
            pFInData->pETM = NULL;        /* Not our size, so best not use it */
        }

    }
    else
    {
        pFInData->pETM = NULL;             /* Is non-zero when passed in */
    }


    return TRUE;
}

BOOL
BGetWidthVectorFromPFM(
    HANDLE   hHeap,
    FONTIN  *pFInData,        // Details of the current font 
    PSHORT   *ppWidth,
    PDWORD    pdwSize)
{

    //
    // For debugging code,  verify that we have a width table!  Then,
    // allocate memory and copy into it.
    //

    int     icbSize;                 // Number of bytes required

    if( pFInData->PFMH.dfPixWidth )
    {
        ERR(( "BGetWidthVectorFromPFM called for FIXED PITCH FONT\n" ));
        return  FALSE;
    }

    //
    // There are LastChar - FirstChar width entries,  plus the default
    // char.  And the widths are shorts.
    //

    icbSize = (pFInData->PFMH.dfLastChar - pFInData->PFMH.dfFirstChar + 2) *
              sizeof( short );

    *ppWidth = (PSHORT) HeapAlloc( hHeap, 0, icbSize );
    *pdwSize = icbSize;

    //
    // If this is a bitmap font,  then use the width table, but use
    // the extent table (in PFMEXTENSION area) as these are ready to
    // to scale.
    //


    if( *ppWidth )
    {
        BYTE   *pb;

        if( pFInData->pETM &&
            pFInData->pETM->emMinScale != pFInData->pETM->emMaxScale &&
            pFInData->PFMExt.dfExtentTable )
        {
            //
            //   Scalable,  so use the extent table
            //

            pb = pFInData->pBase + pFInData->PFMExt.dfExtentTable;
        }
        else
        {
            //
            //   Not scalable
            //

            pb = pFInData->pBase + sizeof( res_PFMHEADER );
        }

        CopyMemory( *ppWidth, pb, icbSize );
    }
    else
    {
        ERR(( "GetWidthVec(): HeapAlloc( %ld ) fails\n", icbSize ));
        return FALSE;
    }


    return  TRUE;
}


BOOL
BGetKerningPairFromPFM(
    HANDLE       hHeap,
    FONTIN     *pFInData, 
    w3KERNPAIR **ppSrcKernPair)
{

    if (pFInData->PFMExt.dfPairKernTable)
    {
        *ppSrcKernPair = (w3KERNPAIR*)(pFInData->pBase + pFInData->PFMExt.dfPairKernTable);
        return TRUE;
    }

    return FALSE;
}

LONG
LCtt2Cc(
    IN SHORT sTransTable,
    IN SHORT sCharSet)
{
    LONG lRet;

    if (sTransTable > 0)
    {
        lRet = (LONG)sTransTable;
    }
    else
    {
        switch (sTransTable)
        {
        case CTT_CP437:
        case CTT_CP850:
        case CTT_CP863:
            lRet = (LONG)sTransTable;
            break;

        case CTT_BIG5:
            lRet = (LONG)CC_BIG5;
            break;

        case CTT_ISC:
            lRet = (LONG)CC_ISC;
            break;

        case CTT_JIS78:
        case CTT_JIS83:
            lRet = (LONG)CC_JIS;
            break;

        case CTT_JIS78_ANK:
        case CTT_JIS83_ANK:
            lRet = (LONG)CC_JIS_ANK;
            break;

        case CTT_NS86:
            lRet = (LONG)CC_NS86;
            break;

        case CTT_TCA:
            lRet = (LONG)CC_TCA;
            break;

        default:
            switch (sCharSet)
            {
            case SHIFTJIS_CHARSET:
                lRet = CC_SJIS;
                break;

            case HANGEUL_CHARSET:
                lRet = CC_WANSUNG;
                break;

            case GB2312_CHARSET:
                lRet = CC_GB2312;
                break;

            case CHINESEBIG5_CHARSET:
                lRet = CC_BIG5;
                break;

            default:
                lRet = 0;
                break;
            }
            break;
        }
    }

    return lRet;
}

WORD
WGetGlyphHandle(
    PUNI_GLYPHSETDATA pGlyph,
    WORD wUnicode)
{

    PGLYPHRUN pGlyphRun;
    DWORD     dwI;
    WORD      wGlyphHandle;
    BOOL      bFound;

    pGlyphRun         = (PGLYPHRUN)((PBYTE)pGlyph + pGlyph->loRunOffset);
    wGlyphHandle      = 0;
    bFound            = FALSE;

    for (dwI = 0; dwI < pGlyph->dwRunCount; dwI ++)
    {
        if (pGlyphRun->wcLow <= wUnicode &&
            wUnicode < pGlyphRun->wcLow + pGlyphRun->wGlyphCount)
        {
            // 
            // Glyph handle starting from ONE!
            //

            wGlyphHandle += wUnicode - pGlyphRun->wcLow + 1;
            bFound        = TRUE;
            break;
        }

        wGlyphHandle += pGlyphRun->wGlyphCount;
        pGlyphRun++;
    }

    if (!bFound)
    {
        //
        // Couldn't find.
        //

        wGlyphHandle = 0;
    }

    return wGlyphHandle;
}


BOOL
BCreateWidthTable(
    IN HANDLE        hHeap,
    IN PWORD         pwGlyphHandleVector,
    IN WORD          wFirst,
    IN WORD          wLast,
    IN PSHORT        psWidthVectorSrc,
    OUT PWIDTHTABLE *ppWidthTable,
    OUT PDWORD       pdwWidthTableSize)
{
    struct {
        WORD wGlyphHandle;
        WORD wCharCode;
    } GlyphHandleVectorTrg[256];

    PWIDTHRUN pWidthRun;
    DWORD     loWidthTableOffset;
    PWORD     pWidth;
    WORD      wI, wJ;
    WORD      wHandle, wMiniHandle, wMiniHandleId, wRunCount;

    //
    // Sort in the order of Glyph Handle.
    // Simple sort
    // Basically it's not necessary to think about a performance.
    //
    // pwGlyphHandleVector 0 -> glyph handle of character code wFirst
    //                     1 -> glyph handle of character code wFirst + 1
    //                     2 -> glyph handle of character code wFirst + 2
    //                     ...
    //
    // GlyphHandleVectorTrg 0 -> minimum glyph handle
    //                      1 -> second minimum glyph handle
    //                      2 -> third minimum glyph handle
    //

    for (wJ = 0; wJ <= wLast - wFirst; wJ++)
    {
        wMiniHandle = 0xFFFF;
        wMiniHandleId =  wFirst;

        for (wI = wFirst ; wI <= wLast; wI++)
        {
            if (wMiniHandle > pwGlyphHandleVector[wI])
            {
                wMiniHandle   = pwGlyphHandleVector[wI];
                wMiniHandleId = wI;
            }
        }

        pwGlyphHandleVector[wMiniHandleId]    = 0xFFFF;
        GlyphHandleVectorTrg[wJ].wGlyphHandle = wMiniHandle;
        GlyphHandleVectorTrg[wJ].wCharCode    = wMiniHandleId;
    }

    //
    // Count Width run
    //

    wHandle   = GlyphHandleVectorTrg[0].wGlyphHandle;
    wRunCount = 1;

    for (wI = 1; wI < wLast - wFirst + 1 ; wI++)
    {
        if (++wHandle != GlyphHandleVectorTrg[wI].wGlyphHandle)
        {
            wHandle = GlyphHandleVectorTrg[wI].wGlyphHandle;
            wRunCount ++;
        }
    }

    //
    // Allocate WIDTHTABLE buffer
    //

    *pdwWidthTableSize = sizeof(WIDTHTABLE) +
                         (wRunCount - 1) * sizeof(WIDTHRUN) +
                         sizeof(SHORT) * wLast + 1 - wFirst;
               
    *ppWidthTable = HeapAlloc(hHeap,
                              0,
                              *pdwWidthTableSize);

    if (!*ppWidthTable)
    {
        *pdwWidthTableSize = 0;
        return FALSE;
    }

    //
    // Fill in a WIDTHTABLE
    //

    (*ppWidthTable)->dwSize   = sizeof(WIDTHTABLE) +
                                sizeof(WIDTHRUN) * (wRunCount - 1) +
                                sizeof(SHORT) * (wLast + 1 - wFirst);
    (*ppWidthTable)->dwRunNum = wRunCount;

    loWidthTableOffset = sizeof(WIDTHTABLE) +
                         (wRunCount - 1) * sizeof(WIDTHRUN); 

    pWidth = (PWORD)((PBYTE)*ppWidthTable + loWidthTableOffset);
    pWidthRun = (*ppWidthTable)->WidthRun;

    wHandle =
    pWidthRun[0].wStartGlyph       = GlyphHandleVectorTrg[0].wGlyphHandle;
    pWidthRun[0].loCharWidthOffset = loWidthTableOffset;

    pWidthRun[0].wGlyphCount = 1;
    wJ = 1;
    wI = 0;

    while (wI < wRunCount)
    {
        while (GlyphHandleVectorTrg[wJ].wGlyphHandle == ++wHandle)
        {
            pWidthRun[wI].wGlyphCount ++;
            wJ ++;
        };

        wI++;
        wHandle = 
        pWidthRun[wI].wStartGlyph       = GlyphHandleVectorTrg[wJ].wGlyphHandle;
        pWidthRun[wI].loCharWidthOffset = loWidthTableOffset;
        pWidthRun[wI].wGlyphCount       = 1;

        loWidthTableOffset += sizeof(SHORT) *
                              pWidthRun[wI].wGlyphCount;
        wJ ++;
    }

    for (wI = 0; wI < wLast + 1 - wFirst; wI ++)
    {
        pWidth[wI] = psWidthVectorSrc[GlyphHandleVectorTrg[wI].wCharCode-wFirst];
    }

    return TRUE;
}


BOOL
BCreateKernData(
    HANDLE      hHeap,
    w3KERNPAIR *pKernPair,
    DWORD       dwCodePage,
    PKERNDATA  *ppKernData,
    PDWORD      pdwKernDataSize)
{
    FD_KERNINGPAIR   *pDstKernPair;
    DWORD             dwNumOfKernPair;
    DWORD             dwI, dwJ, dwId;
    WORD              wUnicode[2];
    WCHAR             wcMiniSecond, wcMiniFirst;
    BYTE              ubMultiByte[2];
    BOOL              bFound;

    //
    // Count kerning pairs
    //

    dwNumOfKernPair = 0;

    while( pKernPair[dwNumOfKernPair].kpPair.each[0] != 0 &&
           pKernPair[dwNumOfKernPair].kpPair.each[1] != 0  )
           
    {
        dwNumOfKernPair ++;
    }

    if (!dwNumOfKernPair)
    {
        *pdwKernDataSize = 0;
        *ppKernData = NULL;

        return TRUE;
    }

    //
    // Allocate memory
    //

    *pdwKernDataSize = sizeof(FD_KERNINGPAIR) * dwNumOfKernPair;

    pDstKernPair = HeapAlloc(hHeap,
                             HEAP_ZERO_MEMORY,
                             *pdwKernDataSize);
                             
    if (!pDstKernPair)
    {
        HeapDestroy(hHeap);
        return FALSE;
    }

    //
    // Convert kerning pair table from character code base to unicode base.
    //

    for (dwI = 0; dwI < dwNumOfKernPair; dwI ++)
    {
        ubMultiByte[0] = (BYTE)pKernPair->kpPair.each[0];
        ubMultiByte[1] = (BYTE)pKernPair->kpPair.each[1];

        MultiByteToWideChar(dwCodePage,
                            0,
                            (LPCSTR)ubMultiByte,
                            2,
                            (LPWSTR)wUnicode,
                            2);

        pDstKernPair[dwI].wcFirst  = wUnicode[0];
        pDstKernPair[dwI].wcSecond = wUnicode[1];
        pDstKernPair[dwI].fwdKern  = pKernPair->kpKernAmount;
        pKernPair++;
    }

    //
    // Sort kerning pair table.  
    //  An extra FD_KERNPAIR is allocated for the NULL sentinel 
    //  (built into KERNDATA size)- it is zero'd by the HeapAlloc
    //

    *pdwKernDataSize += sizeof(KERNDATA);

    (*ppKernData) = HeapAlloc(hHeap,
                              HEAP_ZERO_MEMORY,
                              *pdwKernDataSize);
                             
    if (*ppKernData == NULL)
    {
        HeapDestroy(hHeap);
        return FALSE;
    }

    //
    // Fill the final format of kerning pair.
    //

    (*ppKernData)->dwSize        = *pdwKernDataSize;
    (*ppKernData)->dwKernPairNum = dwNumOfKernPair;

    for (dwI = 0; dwI < dwNumOfKernPair; dwI ++)
    {
        wcMiniSecond = 0xFFFF;
        wcMiniFirst  = 0xFFFF;
        dwId         = 0xFFFF;
        bFound       = FALSE;

        for (dwJ = 0; dwJ < dwNumOfKernPair; dwJ ++)
        {
            if (pDstKernPair[dwJ].wcSecond < wcMiniSecond)
            {
                wcMiniSecond = pDstKernPair[dwJ].wcSecond;
                wcMiniFirst  = pDstKernPair[dwJ].wcFirst;
                dwId         = dwJ;
                bFound       = TRUE;
            }
            else
            if (pDstKernPair[dwJ].wcSecond == wcMiniSecond)
            {
                if (pDstKernPair[dwJ].wcFirst < wcMiniFirst)
                {
                    wcMiniFirst  = pDstKernPair[dwJ].wcFirst;
                    dwId         = dwJ;
                    bFound       = TRUE;
                }
            }
        }

        if (bFound)
        {
            (*ppKernData)->KernPair[dwI].wcFirst  = wcMiniFirst;
            (*ppKernData)->KernPair[dwI].wcSecond = wcMiniSecond;
            (*ppKernData)->KernPair[dwI].fwdKern  = 
                                      pDstKernPair[dwId].fwdKern;
            pDstKernPair[dwId].wcSecond = 0xFFFF;
            pDstKernPair[dwId].wcFirst  = 0xFFFF;
        }
    }

    return TRUE;
}

BOOL
BConvertPFM2UFM(
    HANDLE            hHeap,
    PBYTE             pPFMData, 
    PUNI_GLYPHSETDATA pGlyph,
    DWORD             dwCodePage,
    PFONTMISC         pMiscData,
    PFONTIN           pFInData,
    INT               iGTTID,
    PFONTOUT          pFOutData,
    DWORD             dwFlags)
{
    DWORD   dwOffset;
    DWORD   dwI;
    SHORT   sWidthVectorSrc[256];
    WORD    awMtoUniDst[256];
    WORD    awGlyphHandle[256];
    BYTE    aubMultiByte[256];


    //
    // Zero out the header structure.  This means we can ignore any
    // irrelevant fields, which will then have the value 0, which is
    // the value for not used.
    //


    pFInData->pBase = pPFMData;

    if ( !BAlignPFM( pFInData))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // dwCodePage has to be same as pGlyph->loCodePageInfo->dwCodePage.
    //

    if (pGlyph && pGlyph->loCodePageOffset)
    {
        dwCodePage = ((PUNI_CODEPAGEINFO)((PBYTE)pGlyph +
                                    pGlyph->loCodePageOffset))->dwCodePage;
        
    }
    else
    {
        pGlyph = PGetDefaultGlyphset(hHeap,
                                     (WORD)pFInData->PFMH.dfFirstChar,
                                     (WORD)pFInData->PFMH.dfLastChar,
                                     dwCodePage);
    }

    if (NULL == pGlyph)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Fill in IFIMETRICS
    //

    if ( !BFontInfoToIFIMetric(hHeap,
                               pFInData,
                               pMiscData->pwstrUniqName,
                               pFInData->dwCodePageOfFacenameConv,
                               &pFOutData->pIFI,
                               &pFOutData->dwIFISize,
                               dwFlags))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if (BGetKerningPairFromPFM(hHeap, pFInData, &pFInData->pKernPair))
    {
        if (!BCreateKernData(hHeap,
                            pFInData->pKernPair,
                            dwCodePage,
                            &pFOutData->pKernData,
                            &pFOutData->dwKernDataSize))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        pFOutData->pIFI->cKerningPairs = pFOutData->pKernData->dwKernPairNum;
    }
    else
    {
        pFOutData->dwKernDataSize = 0;
        pFOutData->pKernData      = NULL;
    }

    BGetFontSelFromPFM(hHeap, pFInData, TRUE, &pFOutData->SelectFont);

    BGetFontSelFromPFM(hHeap, pFInData, FALSE, &pFOutData->UnSelectFont);

    if( pFInData->PFMH.dfPixWidth == 0 &&
        BGetWidthVectorFromPFM(hHeap,
                               pFInData,
                               &(pFInData->psWidthTable),
                               &(pFInData->dwWidthTableSize)))
    {
        for (dwI = 0; dwI < 256; dwI++)
        {
            aubMultiByte[dwI] = (BYTE)dwI;
        }

        MultiByteToWideChar(dwCodePage,
                            0,
                            (LPCSTR)aubMultiByte,
                            256,
                            (LPWSTR)awMtoUniDst,
                            256 );
                            
        //
        // Glyph handle base
        //

        for (dwI = (DWORD)pFInData->PFMH.dfFirstChar;
             dwI <= (DWORD)pFInData->PFMH.dfLastChar;
             dwI ++)
        {
            awGlyphHandle[dwI] = WGetGlyphHandle(pGlyph, awMtoUniDst[dwI]);
        }

        if (!BCreateWidthTable(hHeap,
                               awGlyphHandle,
                               (WORD)pFInData->PFMH.dfFirstChar,
                               (WORD)pFInData->PFMH.dfLastChar,
                               pFInData->psWidthTable,
                               &pFOutData->pWidthTable,
                               &pFOutData->dwWidthTableSize))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    else
    {
        pFOutData->dwWidthTableSize = 0;
        pFOutData->pWidthTable      = NULL;
    }

    //
    // Fill in UNIFM
    //

    //  Fix the ETM pointer, instead oi leaving it uninitialized.
    pFOutData -> pETM = pFInData -> pETM;

    pFOutData->UniHdr.dwSize            = sizeof(UNIFM_HDR) +
                                          DWORD_ALIGN(sizeof(UNIDRVINFO) +
                                          pFOutData->SelectFont.dwSize +
                                          pFOutData->UnSelectFont.dwSize) +
                                          pFOutData->dwIFISize +
                                          !!pFOutData -> pETM * sizeof(EXTTEXTMETRIC) +
                                          pFOutData->dwWidthTableSize +
                                          pFOutData->dwKernDataSize;
    pFOutData->UniHdr.dwVersion         = UNIFM_VERSION_1_0;
    pFOutData->UniHdr.ulDefaultCodepage = dwCodePage;
                       
    pFOutData->UniHdr.lGlyphSetDataRCID = iGTTID;

    pFOutData->UniHdr.loUnidrvInfo      = sizeof(UNIFM_HDR);

    pFOutData->UniHdr.loIFIMetrics      = pFOutData->UniHdr.loUnidrvInfo +
                                          DWORD_ALIGN(sizeof(UNIDRVINFO) +
                                          pFOutData->SelectFont.dwSize +
                                          pFOutData->UnSelectFont.dwSize);

    dwOffset = pFOutData->UniHdr.loIFIMetrics + pFOutData->dwIFISize;

    if  (pFOutData->pETM)
    {
        pFOutData->UniHdr.loExtTextMetric = dwOffset;
        dwOffset += sizeof(EXTTEXTMETRIC);
    }
    else 
    {
        pFOutData->UniHdr.loExtTextMetric = 0;
    }

    if (pFOutData->dwWidthTableSize && pFOutData->pWidthTable)
    {
        pFOutData->UniHdr.loWidthTable = dwOffset;
        dwOffset += pFOutData->dwWidthTableSize;
    }
    else
    {
        pFOutData->UniHdr.loWidthTable = 0;
    }

    if (pFOutData->dwKernDataSize && pFOutData->pKernData)
    {
        pFOutData->UniHdr.loKernPair = dwOffset;
    }
    else
    {
        pFOutData->UniHdr.loKernPair = 0;
    }

    memset(pFOutData->UniHdr.dwReserved, 0, sizeof pFOutData->UniHdr.dwReserved);

    //
    // Fill in DRIVERINFO
    //


    pFOutData->UnidrvInfo.dwSize           = DWORD_ALIGN(sizeof(UNIDRVINFO) +
                                           pFOutData->SelectFont.dwSize +
                                           pFOutData->UnSelectFont.dwSize);

    pFOutData->UnidrvInfo.flGenFlags       = 0;
    pFOutData->UnidrvInfo.wType            = pFInData->DI.wFontType;
    pFOutData->UnidrvInfo.fCaps            = pFInData->DI.fCaps;
    pFOutData->UnidrvInfo.wXRes            = pFInData->PFMH.dfHorizRes;
    pFOutData->UnidrvInfo.wYRes            = pFInData->PFMH.dfVertRes;
    pFOutData->UnidrvInfo.sYAdjust         = pFInData->DI.sYAdjust;
    pFOutData->UnidrvInfo.sYMoved          = pFInData->DI.sYMoved;
    pFOutData->UnidrvInfo.sShift           = pFInData->DI.sShift;
    pFOutData->UnidrvInfo.wPrivateData     = pFInData->DI.wPrivateData;

    if (pFOutData->pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY   |
                                   FM_INFO_ANISOTROPIC_SCALING_ONLY |
                                   FM_INFO_ARB_XFORMS)              )
    {
        pFOutData->UnidrvInfo.flGenFlags  |= UFM_SCALABLE;
    }

    dwOffset =  sizeof(UNIDRVINFO);

    if (pFOutData->SelectFont.dwSize != 0)
    {
        pFOutData->UnidrvInfo.SelectFont.loOffset = dwOffset;
        pFOutData->UnidrvInfo.SelectFont.dwCount  = pFOutData->SelectFont.dwSize;
        dwOffset += pFOutData->SelectFont.dwSize;
    }
    else
    {
        pFOutData->UnidrvInfo.SelectFont.loOffset  = (DWORD)0;
        pFOutData->UnidrvInfo.SelectFont.dwCount   = (DWORD)0;
    }

    if (pFOutData->UnSelectFont.dwSize != 0)
    {
        pFOutData->UnidrvInfo.UnSelectFont.loOffset  = dwOffset;
        pFOutData->UnidrvInfo.UnSelectFont.dwCount   = pFOutData->UnSelectFont.dwSize;
        dwOffset += pFOutData->UnSelectFont.dwSize;
    }
    else
    {
        pFOutData->UnidrvInfo.UnSelectFont.loOffset  = (DWORD)0;
        pFOutData->UnidrvInfo.UnSelectFont.dwCount   = (DWORD)0;
    }

    memset(pFOutData->UnidrvInfo.wReserved, 0, sizeof pFOutData->UnidrvInfo.wReserved);

    return TRUE;
}

PUNI_GLYPHSETDATA
PGetDefaultGlyphset(
    IN HANDLE hHeap,
    IN WORD   wFirstChar,
    IN WORD   wLastChar,
    IN DWORD  dwCodePage)
{
    PUNI_GLYPHSETDATA pGlyphSetData;
    PGLYPHRUN         pGlyphRun, pGlyphRunTmp;
    DWORD             dwcbBits, *pdwBits, dwNumOfRuns;
    WORD              wI, wNumOfHandle;
    WCHAR             awchUnicode[256], wchMax, wchMin;
    BYTE              aubAnsi[256];
    BOOL              bInRun;
    DWORD              dwGTTLen;
#ifdef BUILD_FULL_GTT
    PUNI_CODEPAGEINFO pCPInfo;
    PMAPTABLE          pMap;
    PTRANSDATA          pTrans;
    int                  i, j, k, m ;
    WORD              wUnicode ;
#endif

    wNumOfHandle = wLastChar - wFirstChar + 1;

    for( wI = wFirstChar; wI <= wLastChar; ++wI )
    {
        aubAnsi[wI - wFirstChar] = (BYTE)wI;
    }

    if( ! MultiByteToWideChar(dwCodePage,
                              0,
                              aubAnsi,
                              wNumOfHandle,
                              awchUnicode,
                              wNumOfHandle))
    {
        return NULL;
    }

    //
    //  Get min and max Unicode value
    //  Find the largest Unicode value, then allocate storage to allow us
    //  to  create a bit array of valid unicode points.  Then we can
    //  examine this to determine the number of runs.
    //

    for( wchMax = 0, wchMin = 0xffff, wI = 0; wI < wNumOfHandle; ++wI )
    {
        if( awchUnicode[ wI ] > wchMax )
            wchMax = awchUnicode[ wI ];
        if( awchUnicode[ wI ] < wchMin )
            wchMin = awchUnicode[ wI ];
    }

    //
    //  Create Unicode bits table from CTT.
    //  Note that the expression 1 + wchMax IS correct.   This comes about
    //  from using these values as indices into the bit array,  and that
    //  this is essentially 1 based.
    //

    dwcbBits = (1 + wchMax + DWBITS - 1) / DWBITS * sizeof( DWORD );

    if( !(pdwBits = (DWORD *)HeapAlloc( hHeap, 0, dwcbBits )) )
    {
        return  FALSE;     /*  Nothing going */
    }

    ZeroMemory( pdwBits, dwcbBits );

    //
    //   Set bits in this array corresponding to Unicode code points
    //

    for( wI = 0; wI < wNumOfHandle; ++wI )
    {
        pdwBits[ awchUnicode[ wI ] / DWBITS ]

                    |= (1 << (awchUnicode[ wI ] & DW_MASK));
    }

    //
    // Count the number of run.
    //

    //
    //  Now we can examine the number of runs required.  For starters,
    //  we stop a run whenever a hole is discovered in the array of 1
    //  bits we just created.  Later we MIGHT consider being a little
    //  less pedantic.
    //

    bInRun = FALSE;
    dwNumOfRuns = 0;

    for( wI = 0; wI <= wchMax; ++wI )
    {
        if( pdwBits[ wI / DWBITS ] & (1 << (wI & DW_MASK)) )
        {
            /*   Not in a run: is this the end of one? */
            if( !bInRun )
            {
                /*   It's time to start one */
                bInRun = TRUE;
                ++dwNumOfRuns;

            }

        }
        else
        {
            if( bInRun )
            {
                /*   Not any more!  */
                bInRun = FALSE;
            }
        }
    }

    //
    // 7. Allocate memory for GTT and begin to fill in its header.
    //

    dwGTTLen = sizeof(UNI_GLYPHSETDATA) + dwNumOfRuns *    sizeof(GLYPHRUN) ;
#ifdef BUILD_FULL_GTT
    dwGTTLen += sizeof(UNI_CODEPAGEINFO) + sizeof(MAPTABLE) 
                + sizeof(TRANSDATA) * (wNumOfHandle - 1) ;
#endif

    if( !(pGlyphSetData = (PUNI_GLYPHSETDATA)HeapAlloc(hHeap,
                                                       HEAP_ZERO_MEMORY,
                                                       dwGTTLen )) )
    {
        return  FALSE;
    }

#ifdef BUILD_FULL_GTT
    pGlyphSetData->dwSize         = dwGTTLen ;
    pGlyphSetData->dwVersion     = UNI_GLYPHSETDATA_VERSION_1_0 ;
    pGlyphSetData->lPredefinedID = CC_NOPRECNV ;
    pGlyphSetData->dwGlyphCount  = wNumOfHandle ;
#endif
    pGlyphSetData->dwRunCount    = dwNumOfRuns;
    pGlyphSetData->loRunOffset   = sizeof(UNI_GLYPHSETDATA);
    pGlyphRun = pGlyphRunTmp     = (PGLYPHRUN)(pGlyphSetData + 1);

    //
    // 8. Create GLYPHRUN
    //

    bInRun = FALSE;

    for (wI = 0; wI <= wchMax; wI ++)
    {
        if (pdwBits[ wI/ DWBITS ] & (1 << (wI & DW_MASK)) )
        {
            if (!bInRun)
            {
                bInRun = TRUE;
                pGlyphRun->wcLow = wI;
                pGlyphRun->wGlyphCount = 1;
            }
            else
            {
                pGlyphRun->wGlyphCount++;
            }
        }
        else
        {

            if (bInRun)
            {
                bInRun = FALSE;
                pGlyphRun++;
            }
        }
    }

    //
    // 9. Create CODEPAGEINFO and set related GTT header fields.
    //

#ifdef BUILD_FULL_GTT
    pGlyphSetData->dwCodePageCount = 1 ;
    pGlyphSetData->loCodePageOffset = pGlyphSetData->loRunOffset 
                                      + dwNumOfRuns * sizeof(GLYPHRUN) ;
    pCPInfo = (PUNI_CODEPAGEINFO) 
              ((UINT_PTR) pGlyphSetData + pGlyphSetData->loCodePageOffset) ;
    pCPInfo->dwCodePage = dwCodePage ;
    pCPInfo->SelectSymbolSet.dwCount = pCPInfo->SelectSymbolSet.loOffset = 0 ;
    pCPInfo->UnSelectSymbolSet.dwCount = pCPInfo->UnSelectSymbolSet.loOffset = 0 ;

    //
    // 10. Create MAPTABLE and set related GTT header fields.
    //

    pGlyphSetData->loMapTableOffset = pGlyphSetData->loCodePageOffset +
                                      sizeof(UNI_CODEPAGEINFO) ;
    pMap = (PMAPTABLE) ((UINT_PTR) pGlyphSetData + pGlyphSetData->loMapTableOffset) ;
    pMap->dwSize = sizeof(MAPTABLE) + sizeof(TRANSDATA) * (wNumOfHandle - 1) ;
    pMap->dwGlyphNum = wNumOfHandle ;
    pTrans = (PTRANSDATA) &(pMap->Trans[0]) ;        

    pGlyphRun = pGlyphRunTmp ;
    for (i = m = 0 ; i <= (int) pGlyphSetData->dwRunCount ; i++, pGlyphRun++) {
        for (j = 0 ; j <= pGlyphRun->wGlyphCount ; j ++) {
            wUnicode = pGlyphRun->wcLow + j ;
            for (k = 0 ; k <= 255 ; k ++) 
                if (wUnicode == awchUnicode[k])
                    break ;
            ASSERT(k < 256) ;
            pTrans->uCode.ubCode = aubAnsi[k] ;
            pTrans->ubCodePageID = 0 ;
            pTrans->ubType = MTYPE_DIRECT ;
            pTrans++;
        } ;
        m += pGlyphRun->wGlyphCount ;
    } ;
    ASSERT(m != wNumOfHandle) ;
#endif

    return pGlyphSetData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\tools\uni\pfm2ufm\precomp.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    UNI_GLYPHSETDATA dump tool precompile header.
    All other header files should be included in this precompiled header.

Environment:

    Windows NT printer drivers

Revision History:

    11/01/96 -eigos-
        Created it.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include        <lib.h>
#include        <win30def.h>
#include        <uni16res.h>
#include        <uni16gpc.h>
#include        <prntfont.h>
#include        <unilib.h>
#include        <fmlib.h>
#include        <unirc.h>

#define OUTPUT_VERBOSE        0x00000001
#define OUTPUT_CODEPAGEMODE   0x00000002
#define OUTPUT_PREDEFINED     0x00000004
#define OUTPUT_FONTSIM        0x00000008
#define OUTPUT_FONTSIM_NONADD 0x00000010
#define OUTPUT_FACENAME_CONV  0x00000020
#define OUTPUT_SCALING_ANISOTROPIC  0x00000040
#define OUTPUT_SCALING_ARB_XFORMS   0x00000080

#define PFM2UFM_SCALING_ANISOTROPIC     1
#define PFM2UFM_SCALING_ARB_XFORMS      2

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\data.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    data.h

Abstract:

    data.h header file.  Interface with GPD/PPD parsers and getting
    binary data.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _DATA_H_
#define _DATA_H_

BOOL
BMergeFormToTrayAssignments(
    PDEV *
    );

PGPDDRIVERINFO
PGetDefaultDriverInfo(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData
    );

PGPDDRIVERINFO
PGetUpdateDriverInfo(
    IN  PDEV *          pPDev,
    IN  HANDLE          hPrinter,
    IN  PINFOHEADER     pInfoHeader,
    IN  POPTSELECT      pOptionsArray,
    IN  PRAWBINARYDATA  pRawData,
    IN  WORD            wMaxOptions,
    IN  PDEVMODE        pdmInput,
    IN  PPRINTERDATA    pPrinterData
    );

/* VOID
VFixOptionsArray(
    IN  HANDLE          hPrinter,
    IN  PINFOHEADER     pInfoHeader,
    OUT POPTSELECT      pOptionsArray,
    IN  PDEVMODE        pdmInput,
    IN  BOOL            bMetric,
    PRECTL              prcFormImageArea
    );
*/

VOID
VFixOptionsArray(
    PDEV    *pPDev,
    PRECTL              prcFormImageArea
    ) ;


PWSTR
PGetROnlyDisplayName(
    PDEV    *pPDev,
    PTRREF      loOffset,
    PWSTR       wstrBuf,
    WORD    wsize
    )  ;


VOID
VFixOptionsArrayWithPaperSizeID(
    PDEV    *pPDev
    ) ;

#endif  // !_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\data.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    data.h

Abstract:

    Interface to PPD/GPD parsers and deals with getting binary data.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/15/96 -amandan-
        Created

--*/

#include "unidrv.h"


PGPDDRIVERINFO
PGetDefaultDriverInfo(
    IN  HANDLE          hPrinter,
    IN  PRAWBINARYDATA  pRawData
    )
/*++

Routine Description:

    This function just need to get default driverinfo

Arguments:

    hPrinter   - Handle to printer.
    pRawData   - Pointer to RAWBINARYDATA

Return Value:

    Returns pUIInfo

Note:


--*/

{

    PINFOHEADER pInfoHeader;

    //
    // Set the current driver version
    //

    pInfoHeader = InitBinaryData(pRawData, NULL, NULL);

    //
    // Get GPDDRIVERINFO
    //

    if (pInfoHeader == NULL)
        return NULL;
    else
        return(OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loDriverOffset));

}



PGPDDRIVERINFO
PGetUpdateDriverInfo (
    IN  PDEV *          pPDev,
    IN  HANDLE          hPrinter,
    IN  PINFOHEADER     pInfoHeader,
    IN  POPTSELECT      pOptionsArray,
    IN  PRAWBINARYDATA  pRawData,
    IN  WORD            wMaxOptions,
    IN  PDEVMODE        pdmInput,
    IN  PPRINTERDATA    pPrinterData
    )
/*++

Routine Description:

    This function calls the parser to get the updated INFOHEADER
    for the binary data.

Arguments:

    hPrinter        Handle to printer
    pOptionsArray   pointer to optionsarray
    pRawData        Pointer to RAWBINARYDATA
    wMaxOptions     max count for optionsarray
    pdmInput        Pointer to input DEVMODE
    pPrinterData    Pointer to PRINTERDATA

Return Value:

    PINFOHEADER , NULL if failure.

Note:

    At this point the input devmode have been validated. And its option
    array is either the default or its own valid array. Don't need to check
    again in this function.

    Once completed, this function should have filled out the pOptionsArray with
    1. Combined array from PRINTERDATA and DEVMODE
    2. Resolve UI Conflicts



--*/

{
    PUNIDRVEXTRA     pdmPrivate;
    POPTSELECT       pDocOptions, pPrinterOptions;
    RECTL            rcFormImageArea;
    OPTSELECT        DocOptions[MAX_PRINTER_OPTIONS];
    OPTSELECT        PrinterOptions[MAX_PRINTER_OPTIONS];


    //
    // Check for PRINTERDATA.dwChecksum32, If matches with current binary data,
    // Use it to combine PRINTERDATA.aOptions to combined array
    //

    pPrinterOptions = pPrinterData->dwChecksum32 == pRawData->dwChecksum32 ?
                      pPrinterData->aOptions : NULL;

    if (pdmInput)
    {
        pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdmInput);
        pDocOptions = pdmPrivate->aOptions;
    }
    else
        pDocOptions = NULL;

    //
    // Combine the option arrays to pOptionsArray
    // Note: pDocOptions and pPrinterOptions cannot be NULL when combining
    // options array to get snapshot.
    //

    if (pDocOptions == NULL)
    {
        if (! InitDefaultOptions(pRawData,
                                 DocOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_DOCUMENT_STICKY))
        {
            return FALSE;
        }

        pDocOptions = DocOptions;
    }

    if (pPrinterOptions == NULL)
    {
        if (! InitDefaultOptions(pRawData,
                                 PrinterOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_PRINTER_STICKY))
        {
            return FALSE;
        }

        pPrinterOptions = PrinterOptions;
    }


    CombineOptionArray(pRawData, pOptionsArray, wMaxOptions, pDocOptions, pPrinterOptions);

    if (! BMergeFormToTrayAssignments(pPDev))
    {
        ERR(("BMergeFormToTrayAssignments failed"));
    }

    //
    // Resolve any UI conflicts.
    //

    if (!ResolveUIConflicts( pRawData,
                             pOptionsArray,
                             MAX_PRINTER_OPTIONS,
                             MODE_DOCANDPRINTER_STICKY))
    {
        VERBOSE(("Resolved conflicting printer feature selections.\n"));
    }

    //
    // We are here means pOptionsArray is valid. Call parser to UpdateBinaryData
    //

    pInfoHeader = InitBinaryData(pRawData,
                                 pInfoHeader,
                                 pOptionsArray);

    //
    // Get GPDDRIVERINFO
    //

    if (pInfoHeader == NULL)
        return NULL;
    else
        return(OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loDriverOffset));

}

VOID
VFixOptionsArray(
    PDEV    *pPDev,
    PRECTL              prcFormImageArea
    )
/*++

Routine Description:

    This functions is called to propagate public devmode settings
    to the combined option array.

Arguments:

    hPrinter        Handle to printer
    pInfoHeader     Pointer to INFOHEADER
    pOptionsArray   Pointer to the options array
    pdmInput        Pointer to input devmode
    bMetric         Flag to indicate running in metric system
    prcImageArea    Returns the logical imageable area associated with the requested form

Return Value:

    None

Note:

--*/

{
    WORD    wGID, wOptID, wOption;
    HANDLE          hPrinter = pPDev->devobj.hPrinter ;
    PINFOHEADER     pInfoHeader = pPDev->pInfoHeader ;
    POPTSELECT      pOptionsArray = pPDev->pOptionsArray ;
    PDEVMODE        pdmInput = pPDev->pdm ;
    BOOL            bMetric = pPDev->PrinterData.dwFlags & PFLAGS_METRIC ;

    //
    // Validate the form-related fields in the input devmode and
    // make sure they're consistent with each other.
    //

    if (BValidateDevmodeFormFields(hPrinter, pdmInput, prcFormImageArea, NULL, 0) == FALSE)
    {
        //
        // If failed to validate the form fields, ask parser to
        // use the default
        //

        VDefaultDevmodeFormFields(pPDev->pUIInfo, pdmInput, bMetric );

        prcFormImageArea->top = prcFormImageArea->left = 0;
        prcFormImageArea->right = pdmInput->dmPaperWidth * DEVMODE_PAPER_UNIT;
        prcFormImageArea->bottom = pdmInput->dmPaperLength * DEVMODE_PAPER_UNIT;


    }

    for (wOption = 0; wOption < MAX_GID; wOption++)
    {
        switch(wOption)
        {

        case 0:
            wGID = GID_PAGESIZE;
                VFixOptionsArrayWithPaperSizeID(pPDev) ;
            continue;
            break;

        case 1:
            wGID = GID_DUPLEX;
            break;

        case 2:
            wGID = GID_INPUTSLOT;
            break;

        case 3:
            wGID = GID_MEDIATYPE;
            break;

        case 4:
            wGID = GID_COLORMODE;
            break;

        case 5:
            wGID = GID_COLLATE;
            break;

        case 6:
            wGID = GID_RESOLUTION;
            break;

        case 7:
            wGID = GID_ORIENTATION;
            break;

        default:
            continue;

        }

        ChangeOptionsViaID(pInfoHeader, pOptionsArray, wGID, pdmInput);

    }
}

PWSTR
PGetROnlyDisplayName(
    PDEV    *pPDev,
    PTRREF      loOffset,
    PWSTR       wstrBuf,
    WORD    wsize
    )

/*++


revised capabilities:
caller must pass in a local buffer to
 hold the string, the local buffer
 shall be of fixed size  say
         WCHAR   wchbuf[MAX_DISPLAY_NAME];


The return value shall be either the passed
in ptr or a ptr pointing directly to the buds
binary data.

Routine Description:

    Get a read-only copy of a display name:
    1)  if the display name is in the binary printer description data,
        then we simply return a pointer to that data.
    2)  otherwise, the display name is in the resource DLL.
        we allocate memory out of the driver's heap and
        load the string.

    Caller should  NOT attempt to free the returned pointer unless
    that pointer is one he allocated.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset

Return Value:

    Pointer to the requested display name string
    NULL if there is an error or string not found in resource.dll

--*/

{
    if (loOffset & GET_RESOURCE_FROM_DLL)
    {
        //
        // loOffset specifies a string resource ID
        // in the resource DLL
        //

        INT     iLength;

        //
        // First ensure the resource DLL has been loaded
        // and a heap has already been created
        //

        //  nah, just look here!

        //  pPDev->WinResData.hModule ;

        //
        // Load string resource into a temporary buffer
        // and allocate enough memory to hold the string
        //

//  #ifdef  RCSTRINGSUPPORT
#if 0

        if(((loOffset & ~GET_RESOURCE_FROM_DLL) >= RESERVED_STRINGID_START)
            &&  ((loOffset & ~GET_RESOURCE_FROM_DLL) <= RESERVED_STRINGID_END))
        {
            iLength = ILoadStringW(     &pPDev->localWinResData,
                (int)( loOffset & ~GET_RESOURCE_FROM_DLL),
                wstrBuf, wsize );
        }
        else
#endif

        {
            iLength = ILoadStringW(     &pPDev->WinResData,
                (int)( loOffset & ~GET_RESOURCE_FROM_DLL),
                wstrBuf, wsize );
        }




        if( iLength)
            return (wstrBuf);    //  debug check that buffer is null terminated.
        return(NULL);  //  no string was found!
    }
    else
    {
        //
        // loOffset is a byte offset from the beginning of
        // the resource data block
        //

        return OFFSET_TO_POINTER(pPDev->pUIInfo->pubResourceData, loOffset);
        //  note  wchbuf is ignored in this case.
    }
}





VOID
VFixOptionsArrayWithPaperSizeID(
    PDEV    *pPDev

    )

/*++

Routine Description:

    Fix up combined options array with paper size information from public devmode fields

Arguments:

    pci - Points to basic printer info

Return Value:

    NONE


function uses:

    UImodule                            Render Module equiv

    pci->pUIInfo                        pPDev->pUIInfo
    pci->pInfoHeader                pPDev->pInfoHeader
    pci->pdm                            pPDev->pdm
    pci->pRawData                   pPDev->pRawData
    pci->pCombinedOptions       pPDev->pOptionsArray

    MapToDeviceOptIndex
    PGetIndexedOption
    PGetReadOnlyDisplayName
    ReconstructOptionArray

--*/

{

    PFEATURE pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_PAGESIZE);
    BOOL     abEnabledOptions[MAX_PRINTER_OPTIONS];
    PDWORD   pdwPaperIndex = (PDWORD)abEnabledOptions;
    DWORD    dwCount, dwOptionIndex, i;

    if (pFeature == NULL)
        return;

    dwCount = MapToDeviceOptIndex(pPDev->pInfoHeader,
                                  GID_PAGESIZE,
                                  pPDev->pdm->dmPaperWidth * DEVMODE_PAPER_UNIT,
                                  pPDev->pdm->dmPaperLength * DEVMODE_PAPER_UNIT,
                                  pdwPaperIndex);
    if (dwCount == 0 )
        return;

    dwOptionIndex = pdwPaperIndex[0];

    if (dwCount > 1 )
    {
        POPTION pOption;
        PCWSTR   pDisplayName;
        WCHAR   wchBuf[MAX_DISPLAY_NAME];


        for (i = 0; i < dwCount; i++)
        {
            if (pOption = PGetIndexedOption(pPDev->pUIInfo, pFeature, pdwPaperIndex[i]))
            {
                if(pOption->loDisplayName == 0xffffffff)  //use papername from EnumForms()
                {
                    PFORM_INFO_1    pForms;
                    DWORD   dwFormIndex ;

//  temp hack!!!    possibly needed for NT40 ?

//                    dwOptionIndex = pdwPaperIndex[i];
//                    break;
//  end hack.
                    // -----  the fix ------  //
                    if (pPDev->pSplForms == NULL)
                        pPDev->pSplForms = MyEnumForms(pPDev->devobj.hPrinter, 1, &pPDev->dwSplForms);

                    if (pPDev->pSplForms == NULL)
                    {
                        //   ERR(("No spooler forms.\n"));  just a heads up.
                        //   dwOptionIndex already set to safe default
                        break;
                    }

                    pForms =  pPDev->pSplForms ;
                    dwFormIndex =  ((PPAGESIZE)pOption)->dwPaperSizeID - 1 ;


                    if ( (dwFormIndex <  pPDev->dwSplForms)  &&
                        (pDisplayName = (pForms[dwFormIndex]).pName) &&
                        (_wcsicmp(pPDev->pdm->dmFormName, pDisplayName) == EQUAL_STRING) )
                    {
                        dwOptionIndex = pdwPaperIndex[i];
                        break;
                    }

                }




                else  if ( (pDisplayName = PGetROnlyDisplayName(pPDev, pOption->loDisplayName,
                    wchBuf, MAX_DISPLAY_NAME )) &&
                    (_wcsicmp(pPDev->pdm->dmFormName, pDisplayName) == EQUAL_STRING) )
                {
                    dwOptionIndex = pdwPaperIndex[i];
                    break;
                }
            }
        }   //  if name doesn't match we default to the first candidate.
    }

    ZeroMemory(abEnabledOptions, sizeof(abEnabledOptions));
    abEnabledOptions[dwOptionIndex] = TRUE;
    ReconstructOptionArray(pPDev->pRawData,
                           pPDev->pOptionsArray,
                           MAX_COMBINED_OPTIONS,
                           GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature),
                           abEnabledOptions);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\font.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Implementation of font related DDI entry points:
        DrvQueryFont
        DrvQueryFontTree
        DrvQueryFontData
        DrvGetGlyphMode
        DrvFontManagement
        DrvQueryAdvanceWidths

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support
--*/

#include "unidrv.h"


PIFIMETRICS
DrvQueryFont(
    DHPDEV  dhpdev,
    ULONG_PTR   iFile,
    ULONG   iFace,
    ULONG_PTR  *pid
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryFont.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iFile  - Identifies the driver font file
    iFace  - One-based index of the driver font
    pid    - Points to a LONG variable for returning an identifier
             which GDI will pass to DrvFree

Return Value:

    Pointer to an IFIMETRICS structure for the given font
    NULL if there is an error

--*/

{
    PDEV *pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    UNREFERENCED_PARAMETER(iFile);
    VERBOSE(("Entering DrvQueryFont...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryFont,
                    PFN_OEMQueryFont,
                    PIFIMETRICS,
                    (dhpdev,
                     iFile,
                     iFace,
                     pid));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryFont,
                    VMQueryFont,
                    PIFIMETRICS,
                    (dhpdev,
                     iFile,
                     iFace,
                     pid));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);
    if (pFontProcs->FMQueryFont == NULL)
        return NULL;
    else
        return (pFontProcs->FMQueryFont(pPDev,
                                        iFile,
                                        iFace,
                                        pid) );

}

PVOID
DrvQueryFontTree(
    DHPDEV  dhpdev,
    ULONG_PTR   iFile,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR  *pid
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryFontTree.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle
    iFile  - Identifies the driver font file
    iFace  - One-based index of the driver font
    iMode  - Specifies the type of information to be provided
    pid    - Points to a LONG variable for returning an identifier
             which GDI will pass to DrvFree

Return Value:

    Depends on iMode, NULL if there is an error

--*/

{

    PDEV *pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryFontTree...\n"));
    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryFontTree,
                    PFN_OEMQueryFontTree,
                    PVOID,
                    (dhpdev,
                     iFile,
                     iFace,
                     iMode,
                     pid));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryFontTree,
                    VMQueryFontTree,
                    PVOID,
                    (dhpdev,
                     iFile,
                     iFace,
                     iMode,
                     pid));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

    if (pFontProcs->FMQueryFontTree == NULL)
        return NULL;
    else
        return ( pFontProcs->FMQueryFontTree(pPDev,
                                            iFile,
                                            iFace,
                                            iMode,
                                            pid) );
}


LONG
DrvQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryFontData.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev  - Driver device handle
    pfo     - Points to a FONTOBJ structure
    iMode   - Type of information requested
    hg      - A glyph handle
    pgd     - Points to a GLYPHDATA structure
    pv      - Points to output buffer
    cjSize  - Size of output buffer

Return Value:

    Depends on iMode. FD_ERROR if there is an error

--*/

{
    PDEV *pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryFontData...\n"));
    ASSERT(pfo && VALID_PDEV(pPDev));

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryFontData,
                    PFN_OEMQueryFontData,
                    LONG,
                    (dhpdev,
                     pfo,
                     iMode,
                     hg,
                     pgd,
                     pv,
                     cjSize));


    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryFontData,
                    VMQueryFontData,
                    LONG,
                    (dhpdev,
                     pfo,
                     iMode,
                     hg,
                     pgd,
                     pv,
                     cjSize));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

    if (pFontProcs->FMQueryFontData == NULL)
        return FD_ERROR;
    else
        return (pFontProcs->FMQueryFontData(pPDev,
                                              pfo,
                                              iMode,
                                              hg,
                                              pgd,
                                              pv,
                                              cjSize) );
}

ULONG
DrvFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvFontManagement.
    Please refer to DDK documentation for more details.

Arguments:

    pso     - Points to a SURFOBJ structure
    pfo     - Points to a FONTOBJ structure
    iMode   - Escape number
    cjIn    - Size of input buffer
    pvIn    - Points to input buffer
    cjOut   - Size of output buffer
    pvOut   - Points to output buffer

Return Value:

    0x00000001 to 0x7fffffff for success
    0x80000000 to 0xffffffff for failure
    0 if the specified escape number if not supported

--*/

{
    PDEV * pPDev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryFontManagement...\n"));

    //
    // pso could be NULL in case of QUERYESCSUPPORT
    //

    if (iMode == QUERYESCSUPPORT)
    {
        //
        // we don't allow OEM dll to overwrite our font management capability.
        // By not call OEM for this escape, we are also enforcing that the OEM
        // support the same set of font management escapes as Unidrv does.
        //
        return ( *((PULONG)pvIn) == GETEXTENDEDTEXTMETRICS ) ? 1 : 0;
    }

    ASSERT(pso);
    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    ASSERT(pfo);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMFontManagement,
                    PFN_OEMFontManagement,
                    ULONG,
                    (pso,
                     pfo,
                     iMode,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMFontManagement,
                    VMFontManagement,
                    ULONG,
                    (pso,
                     pfo,
                     iMode,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    switch (iMode)
    {
    case GETEXTENDEDTEXTMETRICS:
    {
        pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

        if (pFontProcs->FMFontManagement == NULL)
            return 0;
        else
            return ( pFontProcs->FMFontManagement(pso,
                                                  pfo,
                                                  iMode,
                                                  cjIn,
                                                  pvIn,
                                                  cjOut,
                                                  pvOut) );

    }
    default:
        return 0;
    }
}

BOOL
DrvQueryAdvanceWidths(
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH *phg,
    PVOID  *pvWidths,
    ULONG   cGlyphs
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvQueryAdvanceWidths.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev  - Driver device handle
    pfo     - Points to a FONTOBJ structure
    iMode   - Type of information to be provided
    phg     - Points to an array of HGLYPHs for which the driver will
              provide character advance widths
    pvWidths - Points to a buffer for returning width data
    cGlyphs - Number of glyphs in the phg array

Return Value:

    Depends on iMode

--*/

{
    PDEV * pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvQueryAdvanceWidths...\n"));
    ASSERT(pfo && VALID_PDEV(pPDev));

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMQueryAdvanceWidths,
                    PFN_OEMQueryAdvanceWidths,
                    BOOL,
                    (dhpdev,
                     pfo,
                     iMode,
                     phg,
                     pvWidths,
                     cGlyphs));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMQueryAdvanceWidths,
                    VMQueryAdvanceWidths,
                    BOOL,
                    (dhpdev,
                     pfo,
                     iMode,
                     phg,
                     pvWidths,
                     cGlyphs));

    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);

    if (pFontProcs->FMQueryAdvanceWidths == NULL)
        return FALSE;
    else
       return ( pFontProcs->FMQueryAdvanceWidths(pPDev,
                                                pfo,
                                                iMode,
                                                phg,
                                                pvWidths,
                                                cGlyphs) );

}

ULONG
DrvGetGlyphMode(
    DHPDEV  dhpdev,
    FONTOBJ *pfo
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvGetGlyphMode.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev  - Driver device handle
    pfo     - Points to a FONTOBJ structure

Return Value:

    The glyph mode or FO_GLYPHMODE, which is the default

--*/
{
    PDEV * pPDev = (PDEV *)dhpdev;
    PFMPROCS   pFontProcs;

    VERBOSE(("Entering DrvGetGlyphMode...\n"));
    ASSERT(pfo && VALID_PDEV(pPDev));

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMGetGlyphMode,
                    PFN_OEMGetGlyphMode,
                    ULONG,
                    (dhpdev,
                     pfo));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMGetGlyphMode,
                    VMGetGlyphMode,
                    ULONG,
                    (dhpdev,
                     pfo));


    pFontProcs = (PFMPROCS)(pPDev->pFontProcs);
    if (pFontProcs->FMGetGlyphMode == NULL)
        return  FO_GLYPHBITS;
    else
        return ( pFontProcs->FMGetGlyphMode(pPDev, pfo) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\enable.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    enable.c

Abstract:

    Implementation of device and surface related DDI entry points:
        DrvEnableDriver
        DrvDisableDriver
        DrvEnablePDEV
        DrvResetPDEV
        DrvCompletePDEV
        DrvDisablePDEV
        DrvEnableSurface
        DrvDisableSurface

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    03/31/97 -zhanw-
        Added OEM customization support. Hooked out all DDI drawing functions.

--*/

#include "unidrv.h"
#pragma hdrstop("unidrv.h")

//Comment out this line to disable FTRACE and FVALUE.
//#define FILETRACE
#include "unidebug.h"

#ifdef WINNT_40

DECLARE_CRITICAL_SECTION;

//
// The global link list of ref counts for currently loaded OEM render plugin DLLs
//

extern POEM_PLUGIN_REFCOUNT gpOEMPluginRefCount;

#endif // WINNT_40

//
// Our DRVFN table which tells the engine where to find the routines we support.
//

static DRVFN UniDriverFuncs[] = {
    //
    // enable.c
    //
    { INDEX_DrvEnablePDEV,          (PFN) DrvEnablePDEV         },
    { INDEX_DrvResetPDEV,           (PFN) DrvResetPDEV          },
    { INDEX_DrvCompletePDEV,        (PFN) DrvCompletePDEV       },
    { INDEX_DrvDisablePDEV,         (PFN) DrvDisablePDEV        },
    { INDEX_DrvEnableSurface,       (PFN) DrvEnableSurface      },
    { INDEX_DrvDisableSurface,      (PFN) DrvDisableSurface     },
#ifndef WINNT_40
    { INDEX_DrvDisableDriver,        (PFN)DrvDisableDriver      },
#endif
    //
    // print.c
    //
    {  INDEX_DrvStartDoc,        (PFN)DrvStartDoc               },
    {  INDEX_DrvStartPage,       (PFN)DrvStartPage              },
    {  INDEX_DrvSendPage,        (PFN)DrvSendPage               },
    {  INDEX_DrvEndDoc,          (PFN)DrvEndDoc                 },
    {  INDEX_DrvStartBanding,    (PFN)DrvStartBanding           },
    {  INDEX_DrvNextBand,        (PFN)DrvNextBand               },
    //
    // graphics.c
    //
    {  INDEX_DrvPaint,           (PFN)DrvPaint                  },  // new hook
    {  INDEX_DrvBitBlt,          (PFN)DrvBitBlt                 },
    {  INDEX_DrvStretchBlt,      (PFN)DrvStretchBlt             },
#ifndef WINNT_40
    {  INDEX_DrvStretchBltROP,   (PFN)DrvStretchBltROP          },  // new in NT5
    {  INDEX_DrvPlgBlt,          (PFN)DrvPlgBlt                 },  // new in NT5
#endif
    {  INDEX_DrvCopyBits,        (PFN)DrvCopyBits               },
    {  INDEX_DrvDitherColor,     (PFN)DrvDitherColor            },
    {  INDEX_DrvRealizeBrush,    (PFN)DrvRealizeBrush           },  // in case OEM wants
    {  INDEX_DrvLineTo,          (PFN)DrvLineTo                 },  // new hook
    {  INDEX_DrvStrokePath,      (PFN)DrvStrokePath             },  // new hook
    {  INDEX_DrvFillPath,        (PFN)DrvFillPath               },  // new hook
    {  INDEX_DrvStrokeAndFillPath, (PFN)DrvStrokeAndFillPath    },  // new hook
#ifndef WINNT_40
    {  INDEX_DrvGradientFill,    (PFN)DrvGradientFill           },  // new in NT5
    {  INDEX_DrvAlphaBlend,      (PFN)DrvAlphaBlend             },  // new in NT5
    {  INDEX_DrvTransparentBlt,  (PFN)DrvTransparentBlt         },  // new in NT5
#endif
    //
    // textout.c
    //
    {  INDEX_DrvTextOut,         (PFN)DrvTextOut                },
    //
    // escape.c
    //
    { INDEX_DrvEscape,              (PFN) DrvEscape             },
    //
    // font.c
    //
    { INDEX_DrvQueryFont,           (PFN) DrvQueryFont          },
    { INDEX_DrvQueryFontTree,       (PFN) DrvQueryFontTree      },
    { INDEX_DrvQueryFontData,       (PFN) DrvQueryFontData      },
    { INDEX_DrvGetGlyphMode,        (PFN) DrvGetGlyphMode       },
    { INDEX_DrvFontManagement,      (PFN) DrvFontManagement     },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) DrvQueryAdvanceWidths },
};

//
// Unidrv hooks out every drawing DDI to analyze page content for optimization
//
#ifndef WINNT_40
#define HOOK_UNIDRV_FLAGS   (HOOK_BITBLT |            \
                             HOOK_STRETCHBLT |        \
                             HOOK_PLGBLT |            \
                             HOOK_TEXTOUT |           \
                             HOOK_PAINT |             \
                             HOOK_STROKEPATH |        \
                             HOOK_FILLPATH |          \
                             HOOK_STROKEANDFILLPATH | \
                             HOOK_LINETO |            \
                             HOOK_COPYBITS |          \
                             HOOK_STRETCHBLTROP |     \
                             HOOK_TRANSPARENTBLT |    \
                             HOOK_ALPHABLEND |        \
                             HOOK_GRADIENTFILL)
#else
#define HOOK_UNIDRV_FLAGS   (HOOK_BITBLT |            \
                             HOOK_STRETCHBLT |        \
                             HOOK_TEXTOUT |           \
                             HOOK_PAINT |             \
                             HOOK_STROKEPATH |        \
                             HOOK_FILLPATH |          \
                             HOOK_STROKEANDFILLPATH | \
                             HOOK_LINETO |            \
                             HOOK_COPYBITS)
#endif

//
// Unidrv driver memory pool tag, required by common library headers
//

DWORD   gdwDrvMemPoolTag = '5nuD';

#if ENABLE_STOCKGLYPHSET
//
// Stock glyphset data
//

FD_GLYPHSET *pStockGlyphSet[MAX_STOCK_GLYPHSET];
HSEMAPHORE   hGlyphSetSem = NULL;

VOID FreeGlyphSet(VOID);

#endif //ENABLE_STOCKGLYPHSET


#ifdef WINNT_40 //NT 4.0

HSEMAPHORE  hSemBrushColor = NULL;

#endif //WINNT_40


//
// Forward declarations
//

PPDEV PAllocPDEVData(HANDLE);
VOID VFreePDEVData( PDEV *);
VOID VDisableSurface(PDEV *);
BPaperSizeSourceSame(PDEV * , PDEV *);
HSURF HCreateDeviceSurface(PDEV *, INT);
HBITMAP HCreateBitmapSurface(PDEV *, INT);


HINSTANCE ghInstance;


BOOL WINAPI
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    DLL initialization procedure.

Arguments:

    hModule - DLL instance handle
    ulReason - Reason for the call
    pContext - Pointer to context (not used by us)

Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        ghInstance = hModule;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


BOOL
DrvQueryDriverInfo(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Query driver information

Arguments:

    dwMode - Specify the information being queried
    pBuffer - Points to output buffer
    cbBuf - Size of output buffer in bytes
    pcbNeeded - Return the expected size of output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    switch (dwMode)
    {
#ifndef WINNT_40
    case DRVQUERY_USERMODE:

        ASSERT(pcbNeeded != NULL);
        *pcbNeeded = sizeof(DWORD);

        if (pBuffer == NULL || cbBuf < sizeof(DWORD))
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *((PDWORD) pBuffer) = TRUE;
        return TRUE;
#endif

    default:

        ERR(("Unknown dwMode in DrvQueryDriverInfo: %d\n", dwMode));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
}

BOOL
DrvEnableDriver(
    ULONG           iEngineVersion,
    ULONG           cb,
    PDRVENABLEDATA  pDrvEnableData
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    iEngineVersion - Specifies the DDI version number that GDI is written for
    cb - Size of the buffer pointed to by pDrvEnableData
    pDrvEnableData - Points to an DRVENABLEDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    VERBOSE(("Entering DrvEnableDriver...\n"));

    //
    // Make sure we have a valid engine version and
    // we're given enough room for the DRVENABLEDATA.
    //

    if (iEngineVersion < DDI_DRIVER_VERSION_NT4 || cb < sizeof(DRVENABLEDATA))
    {
        ERR(("DrvEnableDriver failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }

    //
    // Fill in the DRVENABLEDATA structure for the engine.
    //

    pDrvEnableData->iDriverVersion = DDI_DRIVER_VERSION_NT4;
    pDrvEnableData->c = sizeof(UniDriverFuncs) / sizeof(DRVFN);
    pDrvEnableData->pdrvfn = UniDriverFuncs;

    #ifdef WINNT_40   // NT 4.0

    INIT_CRITICAL_SECTION();
    if (!IS_VALID_DRIVER_SEMAPHORE())
    {
        ERR(("Failed to initialize semaphore.\n"));
        SetLastError(ERROR_NO_SYSTEM_RESOURCES);
        return FALSE;
    }

    ENTER_CRITICAL_SECTION();

        gpOEMPluginRefCount = NULL;

    LEAVE_CRITICAL_SECTION();

    if (!(hSemBrushColor = EngCreateSemaphore()))
    {
        return(FALSE);
    }

    #endif //WINNT_40

    #if ENABLE_STOCKGLYPHSET

    //
    // Initialize stock glyphset data
    //

    if (!(hGlyphSetSem = EngCreateSemaphore()))
    {
        ERR(("DrvEnableDriver: EngCreateSemaphore failed.\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return FALSE;
    }
    EngAcquireSemaphore(hGlyphSetSem);
    ZeroMemory(pStockGlyphSet, MAX_STOCK_GLYPHSET * sizeof(FD_GLYPHSET*));
    EngReleaseSemaphore(hGlyphSetSem);

    #endif //ENABLE_STOCKGLYPHSET

    return TRUE;
}


DHPDEV
DrvEnablePDEV(
    PDEVMODE  pdm,
    PWSTR     pLogAddress,
    ULONG     cPatterns,
    HSURF    *phsurfPatterns,
    ULONG     cjGdiInfo,
    ULONG    *pGdiInfo,
    ULONG     cjDevInfo,
    DEVINFO  *pDevInfo,
    HDEV      hdev,
    PWSTR     pDeviceName,
    HANDLE    hPrinter
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnablePDEV.
    Please refer to DDK documentation for more details.

Arguments:

    pdm - Points to a DEVMODEW structure that contains driver data
    pLogAddress - Points to the logical address string
    cPatterns - Specifies the number of standard patterns
    phsurfPatterns - Buffer to hold surface handles to standard patterns
    cjGdiInfo - Size of GDIINFO buffer
    pGdiInfo - Points to a GDIINFO structure
    cjDevInfo - Size of DEVINFO buffer
    pDevInfo - Points to a DEVINFO structure
    hdev - GDI device handle
    pDeviceName - Points to device name string
    hPrinter - Spooler printer handle

Return Value:

    Driver device handle, NULL if there is an error

--*/

{

    PDEV   *pPDev;
    RECTL   rcFormImageArea;
    DRVENABLEDATA       ded;        // for OEM customization support
    PDEVOEM             pdevOem;
    PFN_OEMEnablePDEV   pfnOEMEnablePDEV;

    VERBOSE(("Entering DrvEnablePDEV...\n"));

    ZeroMemory(phsurfPatterns, sizeof(HSURF) * cPatterns);

    //
    // Allocate PDEV,
    // Initializes binary data,
    // Get default binary data snapshot,
    //

    if (! (pPDev = PAllocPDEVData(hPrinter)) ||
        ! (pPDev->pDriverInfo3 = MyGetPrinterDriver(hPrinter, hdev, 3)) ||
        ! (pPDev->pRawData = LoadRawBinaryData(pPDev->pDriverInfo3->pDataFile)) ||
        ! (pPDev->pDriverInfo = PGetDefaultDriverInfo(hPrinter, pPDev->pRawData) ) ||
        ! (pPDev->pInfoHeader = pPDev->pDriverInfo->pInfoHeader) ||
        ! (pPDev->pUIInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loUIInfoOffset)) )
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // Must load OEM dll's before setting devmode
    //

    if( ! BLoadAndInitOemPlugins(pPDev) ||
        ! BInitWinResData(&pPDev->WinResData, pPDev->pDriverInfo3->pDriverPath, pPDev->pUIInfo) ||
        ! (pPDev->pOptionsArray = MemAllocZ(MAX_PRINTER_OPTIONS * sizeof(OPTSELECT))))

    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // Since output is expected to follow this call,  allocate storage
    // for the output buffer.  This used to be statically allocated
    // within UNIDRV's PDEV,  but now we can save that space for INFO
    // type DCs.
    //
    //  Not!  according to Bug 150881   StartDoc and EndDoc
    //  are optional calls, but pbOBuf is required.
    //

    if( !(pPDev->pbOBuf = MemAllocZ( CCHSPOOL )) )
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }



    //
    // Use the default binary data to validate input devmode
    // and merges with the system, devmode.
    // Get printer properties.
    // and loads minidriver resource data
    //

    if (! BGetPrinterProperties(pPDev->devobj.hPrinter, pPDev->pRawData, &pPDev->PrinterData) ||
        ! BMergeAndValidateDevmode(pPDev, pdm, &rcFormImageArea))
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // get updated binary snapshot with the validated/merged devmode
    //

    if (! (pPDev->pDriverInfo = PGetUpdateDriverInfo (
                                        pPDev,
                                        hPrinter,
                                        pPDev->pInfoHeader,
                                        pPDev->pOptionsArray,
                                        pPDev->pRawData,
                                        MAX_PRINTER_OPTIONS,
                                        pPDev->pdm,
                                        &pPDev->PrinterData)))
    {
        ERR(("PGetUpdateDriverInfo failed: %d\n", GetLastError()));
        pPDev->pInfoHeader = NULL ;   //  deleted by PGetUpdateDriverInfo
        //  better fix is to pass a pointer to pPDev->pInfoHeader so     PGetUpdateDriverInfo
        //  can update the pointer immediately.
        VFreePDEVData(pPDev);
        return NULL;
    }

    if(! (pPDev->pInfoHeader = pPDev->pDriverInfo->pInfoHeader) ||
        ! (pPDev->pUIInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loUIInfoOffset)) )

    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));
        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // pPDev->pUIInfo is reset so update the winresdata pUIInfo also.
    //
    pPDev->WinResData.pUIInfo = pPDev->pUIInfo;

    //
    // Initialize the rest of PDEV and GDIINFO, DEVINFO and
    // call the Font, Raster modules to
    // initialize their parts of the PDEVICE, GDIINFO and DEVINFO
    //  Palette initialization is done by control module.
    //

    //
    // This is necessary to initialize for FMInit.
    //

    pPDev->devobj.hEngine = hdev;
    pPDev->fHooks = HOOK_UNIDRV_FLAGS;

    if (! BInitPDEV(pPDev, &rcFormImageArea )           ||
        ! BInitGdiInfo(pPDev, pGdiInfo, cjGdiInfo)      ||
        ! BInitDevInfo(pPDev, pDevInfo, cjDevInfo)      ||
        ! VMInit(pPDev, pDevInfo, (PGDIINFO)pGdiInfo)   ||
        ! RMInit(pPDev, pDevInfo, (PGDIINFO)pGdiInfo)   ||
        ! BInitPalDevInfo(pPDev, pDevInfo, (PGDIINFO)pGdiInfo) ||
        ! FMInit(pPDev, pDevInfo, (PGDIINFO)pGdiInfo))
    {
        ERR(("DrvEnablePDEV failed: %d\n", GetLastError()));

        VFreePDEVData(pPDev);
        return NULL;
    }

    FTRACE(Tracing Palette);
    FVALUE((pDevInfo->flGraphicsCaps & GCAPS_ARBRUSHTEXT), 0x%x);


    ded.iDriverVersion = PRINTER_OEMINTF_VERSION;
    ded.c = sizeof(UniDriverFuncs) / sizeof(DRVFN);
    ded.pdrvfn = (DRVFN*) UniDriverFuncs;

    //
    // Call EnablePDEV for the vector plugins.
    // Put the return value in (((PDEVOBJ)pPDev)->pdevOEM)
    //

    HANDLE_VECTORPROCS_RET(pPDev, VMEnablePDEV, (pPDev)->pVectorPDEV,
                                            ((PDEVOBJ) pPDev,
                                            pDeviceName,
                                            cPatterns,
                                            phsurfPatterns,
                                            cjGdiInfo,
                                            (GDIINFO *)pGdiInfo,
                                            cjDevInfo,
                                            (DEVINFO *)pDevInfo,
                                            &ded) ) ;

    //
    // If there is present a vector module and it exports EnablePDEV
    // but its EnablePDEV has failed, then we cannot continue.
    //
    if ( pPDev->pVectorProcs &&
         ( (PVMPROCS)(pPDev->pVectorProcs) )->VMEnablePDEV &&
         !(pPDev->pVectorPDEV)
       )
    {
        ERR(("Vector Module's EnablePDEV failed \n"));
        VFreePDEVData(pPDev);
        return NULL;
    }

    //
    // Call OEMEnablePDEV entrypoint for each OEM dll
    //
    START_OEMENTRYPOINT_LOOP(pPDev)

        if (pOemEntry->pIntfOem != NULL)
        {
            if (HComOEMEnablePDEV(pOemEntry,
                                  (PDEVOBJ)pPDev,
                                  pDeviceName,
                                  cPatterns,
                                  phsurfPatterns,
                                  cjGdiInfo,
                                  (GDIINFO *) pGdiInfo,
                                  cjDevInfo,
                                  (DEVINFO *) pDevInfo,
                                  &ded,
                                  &pOemEntry->pParam) == E_NOTIMPL)
                continue;

        }
        else
        {
            if ((pfnOEMEnablePDEV = GET_OEM_ENTRYPOINT(pOemEntry, OEMEnablePDEV)))
            {
                pOemEntry->pParam = pfnOEMEnablePDEV(
                                        (PDEVOBJ) pPDev,
                                        pDeviceName,
                                        cPatterns,
                                        phsurfPatterns,
                                        cjGdiInfo,
                                        (GDIINFO *) pGdiInfo,
                                        cjDevInfo,
                                        (DEVINFO *) pDevInfo,
                                        &ded);

            }
            else
                continue;

        }

        if (pOemEntry->pParam == NULL)
        {
            ERR(("OEMEnablePDEV failed for '%ws': %d\n",
                pOemEntry->ptstrDriverFile,
                GetLastError()));

            VFreePDEVData(pPDev);
            return NULL;
        }

        //
        // Add support for OEM's 8bpp multi-level color
        //
        if (((GDIINFO *)pGdiInfo)->ulHTOutputFormat == HT_FORMAT_8BPP &&
            ((GDIINFO *)pGdiInfo)->flHTFlags & HT_FLAG_8BPP_CMY332_MASK &&
            ((GDIINFO *)pGdiInfo)->flHTFlags & HT_FLAG_USE_8BPP_BITMASK)
        {
            VInitPal8BPPMaskMode(pPDev,(GDIINFO *)pGdiInfo);
        }
        pOemEntry->dwFlags |= OEMENABLEPDEV_CALLED;

#if 0
        //
        // in the extremely simple case, OEM dll may not need to create
        // a PDEV at all.
        //

        else // OEMEnablePDEV is not exported. Error!
        {
            ERR(("OEMEnablePDEV is not exported for '%ws'\n",
                 pOemEntry->ptstrDriverFile));

            VFreePDEVData(pPDev);
            return NULL;

        }

        //
        // for every OEM DLL, OEMDisablePDEV is also a required export.
        //
        if (!GET_OEM_ENTRYPOINT(pOemEntry, OEMDisablePDEV))
        {
            ERR(("OEMDisablePDEV is not exported for '%ws'\n",
                 pOemEntry->ptstrDriverFile));

            VFreePDEVData(pPDev);
            return NULL;

        }
#endif

    END_OEMENTRYPOINT_LOOP


    //
    // Unload and free binary data allocated by the parser.
    // Will need to reload at DrvEnableSurface
    //

    VUnloadFreeBinaryData(pPDev);

    return (DHPDEV) pPDev;
}


BOOL
DrvResetPDEV(
    DHPDEV  dhpdevOld,
    DHPDEV  dhpdevNew
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvResetPDEV.
    Please refer to DDK documentation for more details.

Arguments:

    phpdevOld - Driver handle to the old device
    phpdevNew - Driver handle to the new device

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    PPDEV    pPDevOld, pPDevNew;
    PFN_OEMResetPDEV    pfnOEMResetPDEV;
    POEM_PLUGIN_ENTRY   pOemEntryOld;
    BOOL    bResult = TRUE;

    VERBOSE(("Entering DrvResetPDEV...\n"));

    pPDevOld = (PDEV *) dhpdevOld;
    pPDevNew = (PDEV *) dhpdevNew;

    ASSERT_VALID_PDEV(pPDevOld);
    ASSERT_VALID_PDEV(pPDevNew);

    //
    // Carry relevant information from old pdev to new pdev
    // BUG_BUG, what other information should we carry over here ?
    //

    //
    // Set the PF_SEND_ONLY_NOEJECT_CMDS flag if the only
    // thing that changed between the old and new devmode
    // require only commands that do not cause a page ejection.
    //

    //
    // Don't need to resend the page initialization iff
    // The Document has started printing AND
    // The device support DUPLEX AND
    // The Duplex option selected is DM_DUPLEX AND
    // The previous duplex option matches the current duplex option AND
    // The Paper Size, Paper Source , and Orientation is the same
    //  Due to unloading of rawbinary data and snapshot,    pPDevNew->pDuplex
    //  and other related fields are null at this time.  must use devmode.
    //



    if( (pPDevOld->fMode & PF_DOCSTARTED) &&
        (pPDevNew->pdm->dmFields & DM_DUPLEX) &&
        (pPDevOld->pdm->dmFields & DM_DUPLEX) &&
        (pPDevNew->pdm->dmDuplex != DMDUP_SIMPLEX)  &&
        (pPDevNew->pdm->dmDuplex == pPDevOld->pdm->dmDuplex) )
    {
        BOOL     bUseNoEjectSubset = TRUE ;
        COMMAND    *pSeqCmd;
        DWORD       dwCmdIndex ;

        if (!BPaperSizeSourceSame(pPDevNew,pPDevOld))
            bUseNoEjectSubset = FALSE ;

        //
        // if  orientation command is  not NO_PageEject
        //
        if( bUseNoEjectSubset  &&
            (pPDevNew->pdm->dmFields & DM_ORIENTATION) &&
             (pPDevOld->pdm->dmFields & DM_ORIENTATION) &&
             (pPDevNew->pdm->dmOrientation != pPDevOld->pdm->dmOrientation) &&
             pPDevOld->pOrientation   &&
             ((dwCmdIndex = pPDevOld->pOrientation->GenericOption.dwCmdIndex)  != UNUSED_ITEM) &&
             (pSeqCmd = INDEXTOCOMMANDPTR(pPDevOld->pDriverInfo, dwCmdIndex)) &&
             !(pSeqCmd->bNoPageEject))
                    bUseNoEjectSubset = FALSE ;

        //
        //  if  colormode command is  not NO_PageEject
        //
        if( bUseNoEjectSubset  &&
            (pPDevNew->pdm->dmFields & DM_COLOR) &&
             (pPDevOld->pdm->dmFields & DM_COLOR) &&
             (pPDevNew->pdm->dmColor != pPDevOld->pdm->dmColor)  &&
             pPDevOld->pColorMode   &&
             ((dwCmdIndex = pPDevOld->pColorMode->GenericOption.dwCmdIndex)  != UNUSED_ITEM)  &&
             (pSeqCmd = INDEXTOCOMMANDPTR(pPDevOld->pDriverInfo, dwCmdIndex)) &&
             !(pSeqCmd->bNoPageEject))
                    bUseNoEjectSubset = FALSE ;

        //check all other doc properties if you want:
        if(bUseNoEjectSubset)
            pPDevNew->fMode |= PF_SEND_ONLY_NOEJECT_CMDS;
    }

    //
    //  if Job commands already sent, don't send them again.
    //
    if( pPDevOld->fMode & PF_JOB_SENT)
        pPDevNew->fMode |= PF_JOB_SENT;

    //
    //  if Doc commands already sent, don't send them again.
    //
    if( pPDevOld->fMode & PF_DOC_SENT)
        pPDevNew->fMode |= PF_DOC_SENT;

    pPDevNew->dwPageNumber   =  pPDevOld->dwPageNumber  ;
    //  preserve pageNumber across ResetDC.

    //
    // Call Raster and Font module to carry over their stuff from old
    // pPDev to new pPDev
    //

    if (!(((PRMPROCS)(pPDevNew->pRasterProcs))->RMResetPDEV(pPDevOld, pPDevNew)) ||
        !(((PFMPROCS)(pPDevNew->pFontProcs))->FMResetPDEV(pPDevOld, pPDevNew)))
    {
        bResult = FALSE;
    }

    //
    // Also call the vector module.
    //
    if ( pPDevOld->pVectorProcs )
    {
        pPDevOld->devobj.pdevOEM = pPDevOld->pVectorPDEV;
        HANDLE_VECTORPROCS_RET( pPDevNew, VMResetPDEV, bResult,
                                            ((PDEVOBJ) pPDevOld,
                                            (PDEVOBJ) pPDevNew ) ) ;
    }

    //
    // Call OEMResetPDEV entrypoint
    //

    ASSERT(pPDevNew->pOemPlugins);
    ASSERT(pPDevOld->pOemPlugins);

    START_OEMENTRYPOINT_LOOP(pPDevNew)

        pOemEntryOld = PFindOemPluginWithSignature(pPDevOld->pOemPlugins,
                                                       pOemEntry->dwSignature);

        if (pOemEntryOld != NULL)
        {
            pPDevOld->devobj.pdevOEM = pOemEntryOld->pParam;
            pPDevOld->devobj.pOEMDM = pOemEntryOld->pOEMDM;

            if (pOemEntry->pIntfOem != NULL)
            {
                HRESULT hr;

                hr = HComOEMResetPDEV(pOemEntry,
                                      (PDEVOBJ)pPDevOld,
                                      (PDEVOBJ)pPDevNew);

                if (hr == E_NOTIMPL)
                    continue;

                if (FAILED(hr))
                {
                    ERR(("OEMResetPDEV failed for '%ws': %d\n",
                        pOemEntry->ptstrDriverFile,
                        GetLastError()));

                    bResult = FALSE;
                }

            }
            else
            {
                if (!(pfnOEMResetPDEV = GET_OEM_ENTRYPOINT(pOemEntry, OEMResetPDEV)))
                    continue;

                if (! pfnOEMResetPDEV((PDEVOBJ) pPDevOld, (PDEVOBJ) pPDevNew))
                {
                    ERR(("OEMResetPDEV failed for '%ws': %d\n",
                        pOemEntry->ptstrDriverFile,
                        GetLastError()));

                    bResult = FALSE;
                }
            }
        }
    END_OEMENTRYPOINT_LOOP

    return bResult;
}


HSURF
DrvEnableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEnableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    Handle to newly created surface, NULL if there is an error

--*/

{

    HSURF     hSurface;         // Handle to the surface
    HBITMAP   hBitmap;          // The bitmap handle
    // SIZEL     szSurface;        // Device surface size
    INT       iFormat;          // Bitmap format
    ULONG     cbScan;           // Scan line byte length (DWORD aligned)
    int       iBPP;             // Bits per pel, as # of bits
    int       iPins;            // Basic rounding factor for banding size
    PDEV      *pPDev = (PDEV*)dhpdev;
    DWORD     dwNumBands;       // Number of bands to use

    PFN_OEMDriverDMS  pfnOEMDriverDMS;
    DWORD     dwHooks = 0, dwHooksSize = 0; // used to query what kind of surface should be created
    POEM_PLUGINS    pOemPlugins; // OEM Plugin Module
    PTSTR           ptstrDllName;

    DEVOBJ  DevObj;
    BOOL    bReturn = FALSE;

    VERBOSE(("Entering DrvEnableSurface...\n"));

    //
    // Reloads the binary data and reinit the offsets and pointers
    // to binary data
    //

    if (!BReloadBinaryData(pPDev))
        return NULL;

    //
    // BUG_BUG, Need to put test code here to force banding for testing purposes
    //

    // szSurface.cx = pPDev->sf.szImageAreaG.cx;
    // szSurface.cy = pPDev->sf.szImageAreaG.cy;

    iBPP = pPDev->sBitsPixel;

    switch (pPDev->sBitsPixel)
    {
        case 1:
            iFormat = BMF_1BPP;
            break;
        case 4:
            iFormat = BMF_4BPP;
            break;
        case 8:
            iFormat = BMF_8BPP;
            break;
        case 24:
            iFormat = BMF_24BPP;
            break;
        default:
            ERR(("Unknown sBitsPixels in DrvEnableSurface"));
            break;
    }

    //
    // Time to allocate surface bitmap
    DevObj = pPDev->devobj;
    //

    //
    // First call Vector pseudo-plugin
    //
    HANDLE_VECTORPROCS_RET( pPDev, VMDriverDMS, bReturn,
                                        ((PDEVOBJ) pPDev,
                                        &dwHooks,
                                        sizeof(DWORD),
                                        &dwHooksSize) ) ;
    {
        if ( bReturn && dwHooks)
            pPDev->fMode |= PF_DEVICE_MANAGED;
        else
            pPDev->fMode &= ~PF_DEVICE_MANAGED;
    }



    // Call OEMGetInfo to find out if the Oem wants to create
    // a bitmap surface or a device surface
    pOemPlugins = pPDev->pOemPlugins;
    if (pOemPlugins->dwCount > 0)
    {
        //
        // Before the HANDLE_VECTORPROCS_RET was placed above, it made sense to initialize
        // dwHooks. But now we dont want to reinitialize it.
        //
        // dwHooks = 0;
        dwHooksSize = 0;
        START_OEMENTRYPOINT_LOOP(pPDev)

        VERBOSE(("Getting the OEMDriverDMS address\n"));

            if (pOemEntry->pIntfOem != NULL)
            {
                HRESULT hr;

                hr = HComDriverDMS(pOemEntry,
                                      (PDEVOBJ)pPDev,
                                      &dwHooks,
                                      sizeof(DWORD),
                                      &dwHooksSize);
                //
                // We need to explicitly check for E_NOTIMPL. SUCCEEDED macro
                // will fail for this error.
                //
                if (hr == E_NOTIMPL)
                    continue;

                if(!SUCCEEDED(hr))
                {
                    WARNING(("OEMDriverDMS returned FALSE '%ws': ErrorCode = %d\n",
                         pOemEntry->ptstrDriverFile,
                         GetLastError()));
                    dwHooks = 0;

                }
                if (dwHooks)
                   pPDev->fMode |= PF_DEVICE_MANAGED;
                else
                   pPDev->fMode &= ~PF_DEVICE_MANAGED;


            }

            else
            {
                if ((pfnOEMDriverDMS = GET_OEM_ENTRYPOINT(pOemEntry, OEMDriverDMS)))
                {
                    bReturn = pfnOEMDriverDMS((PDEVOBJ)pPDev,
                                      &dwHooks,
                                      sizeof(DWORD),
                                      &dwHooksSize);

                    if (bReturn == FALSE)
                    {
                        WARNING(("OEMDriverDMS returned FALSE '%ws': ErrorCode = %d\n",
                             pOemEntry->ptstrDriverFile,
                             GetLastError()));
                        dwHooks = 0;

                    }
                    if (dwHooks)
                       pPDev->fMode |= PF_DEVICE_MANAGED;
                    else
                       pPDev->fMode &= ~PF_DEVICE_MANAGED;
                }
            }


        END_OEMENTRYPOINT_LOOP
    }


    //
    // If the OEM Plugin Module wants a device managed surface
    // (from OEMGetInfo) - then create it.
    // Otherwise a bitmap surface is created. Note: Banding must be
    // turned off for a device surface.
    //
    if (DRIVER_DEVICEMANAGED (pPDev))   // device surface
    {
        VERBOSE(("DrvEnableSurface: creating a DEVICE surface.\n"));

        //
        // Hack for monochrome HPGL2 pseudo-plugin driver.
        // The gpd indicates the driver is monochrome, but the plugin wants the
        // driver surface to be 24bpp color. Even though the rendering is done in monochrome,
        // but the plugin wants GDI to send it all color information. So it wants destination
        // surface to be declared color surface. Putting color information in gpd, though simple,
        // breaks backward compatibility (e.g. if new gpd is used with old unidrv). Therefore
        // this hack. If the personality in gpd is hpgl2 and the VectorProc structure is
        // initialized (which means that Graphics Mode has been chosen as HP-GL/2 from the UI),
        // then we assume we are printing to monochrome HPGL printer.
        // Therefore for plugin's happiness we create the device managed surface
        // as 24bpp.
        // Question: This creates a wierd situation, where the surface is color, but
        // unidrv thinks it is monochrome and creates palette accordingly.
        // Answer: Since all the rendering is done by the plugin and unidrv is not used,
        // I think we should be ok.
        //
        if ((pPDev->ePersonality == kHPGL2 ||
             pPDev->ePersonality == kPCLXL ) &&
             pPDev->pVectorProcs != NULL   &&
             iFormat == BMF_1BPP)
        {
            hSurface = HCreateDeviceSurface (pPDev, BMF_24BPP);
        }
        else
        {
            hSurface = HCreateDeviceSurface (pPDev, iFormat);
        }

        // if we can't create the surface fail the call.

        if (!hSurface)
        {
            ERR(("Unidrv!DrvEnableSurface:HCreateBitmapSurface  Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }

        pPDev->hSurface = hSurface;
        pPDev->hbm = NULL;
        pPDev->pbScanBuf = NULL; // Don't need this buffer
    }
    else   // bitmap surface
    {
        //
        // Create a surface.   Try for a bitmap for the entire surface.
        // If this fails,  then switch to journalling and a somewhat smaller
        // surface.   If journalling,  we still create the bitmap here.  While
        // it is nicer to do this at DrvSendPage() time,  we do it here to
        // ensure that it is possible.  By maintaining the bitmap for the
        // life of the DC,  we can be reasonably certain of being able to
        // complete printing regardless of how tight memory becomes later.
        //
        VERBOSE(("DrvEnableSurface: creating a BITMAP surface.\n"));
        hBitmap = HCreateBitmapSurface (pPDev, iFormat);

        // if we can't create the bitmap fail the call.
        if (!hBitmap)
        {
            ERR(("Unidrv!DrvEnableSurface:HCreateBitmapSurface  Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }

        //
        // We will always use szBand to describe the bitmap surface, a band
        // could be the whole page or a part of a page.
        //

        //
        // Allocate array to represent the page in scanlines,
        // for z-ordering fix
        //

        if( (pPDev->pbScanBuf = MemAllocZ(pPDev->szBand.cy)) == NULL)
        {
            VDisableSurface( pPDev );
            return  NULL;
        }
        //
        // Allocate array to represents the page in scanlines, for erasing surface
        //

        if( (pPDev->pbRasterScanBuf = MemAllocZ((pPDev->szBand.cy / LINESPERBLOCK)+1)) == NULL)
        {
            VDisableSurface( pPDev );
            return  NULL;
        }
#ifndef DISABLE_NEWRULES
        //
        // Allocate array to store black rectangle optimization
        // Device must support rectangle commands and unidrv must dump the raster
        //
        if ((pPDev->fMode & PF_RECT_FILL) &&
            !(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS) &&
            !(pPDev->fMode2 & PF2_MIRRORING_ENABLED) &&
            ((COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)) ||
             (COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL)) ||
             !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL))) &&
            (pPDev->pColorModeEx == NULL || pPDev->pColorModeEx->dwPrinterBPP))
        {
            if( (pPDev->pbRulesArray = MemAlloc(sizeof(RECTL) * MAX_NUM_RULES)) == NULL)
            {
                VDisableSurface( pPDev );
                return  NULL;
            }
        }
        else
            pPDev->pbRulesArray = NULL;
#endif
        pPDev->dwDelta = pPDev->szBand.cx / MAX_COLUMM;

        pPDev->hbm = hBitmap;
        pPDev->hSurface = NULL;

    }

    //
    // Call Raster and Font module EnableSurface for surface intialization
    //

    if ( !(((PRMPROCS)(pPDev->pRasterProcs))->RMEnableSurface(pPDev)) ||
         !(((PFMPROCS)(pPDev->pFontProcs))->FMEnableSurface(pPDev)) )
    {
        VDisableSurface( pPDev );
        return  NULL;
    }

    //
    // Now need to associate this surface with the pdev passed in at
    // DrvCompletePDev time.
    // Note: BUG_BUG, The RMInit() and FMInit() calls should have
    // initialized the pPDev->fHooks already.  All we need to do here is use it
    //

    ASSERT(pPDev->fHooks != 0);

    if (DRIVER_DEVICEMANAGED (pPDev))   // device surface
    {
        pPDev->fHooks = dwHooks;
        EngAssociateSurface (hSurface, pPDev->devobj.hEngine, pPDev->fHooks);
        return hSurface;
    }
    else
    {
#ifdef DISABLEDEVSURFACE
        EngAssociateSurface( (HSURF)hBitmap, pPDev->devobj.hEngine, pPDev->fHooks );
        pPDev->pso = EngLockSurface( (HSURF)hBitmap);
        if (pPDev->pso == NULL)
        {
            ERR(("Unidrv!DrvEnableSurface:EngLockSurface Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }
        return (HSURF)hBitmap;

#else
        // HSURF hSurface;
        // SIZEL szSurface;

        EngAssociateSurface( (HSURF)hBitmap, pPDev->devobj.hEngine, 0 );
        pPDev->pso = EngLockSurface( (HSURF)hBitmap);
        if (pPDev->pso == NULL)
        {
            ERR(("Unidrv!DrvEnableSurface:EngLockSurface Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }
        //
        // Create a device surface to make sure GDI always calls the driver first
        // for any drawing
        //
        hSurface = EngCreateDeviceSurface((DHSURF)pPDev, pPDev->szBand, iFormat);
        if (!hSurface)
        {
            ERR(("Unidrv!DrvEnableSurface:EngCreateDeviceSurface Failed"));
            VDisableSurface( pPDev );
            return NULL;
        }
        // If banding is enabled mark the device surface as a banding surface
        //
        if (pPDev->bBanding)
            EngMarkBandingSurface(hSurface);

        pPDev->hSurface = hSurface;

        EngAssociateSurface( (HSURF)hSurface, pPDev->devobj.hEngine, pPDev->fHooks );

        return (HSURF)hSurface;
#endif
    }
}


VOID
DrvDisableSurface(
    DHPDEV dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableSurface.
    Please refer to DDK documentation for more details.

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{

    VERBOSE(("Entering DrvDisableSurface...\n"));

    VDisableSurface( (PDEV *)dhpdev );

}


VOID
DrvDisablePDEV(
    DHPDEV  dhpdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisablePDEV.
    Please refer to DDK documentation for more details.

    Free up all memory allocated for PDEV

Arguments:

    dhpdev - Driver device handle

Return Value:

    NONE

--*/

{

    PDEV    *pPDev = (PDEV *) dhpdev;

    VERBOSE(("Entering DrvDisablePDEV...\n"));

    if (!VALID_PDEV(pPDev))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return;
    }

//    ASSERT_VALID_PDEV(pPDev);

    //
    // Free up resources associated with the PDEV
    //

    FlushSpoolBuf( pPDev );  //  may need to do this per bug 250963
    VFreePDEVData(pPDev);
}

VOID
DrvDisableDriver(
    VOID
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvDisableDriver.
    Please refer to DDK documentation for more details.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    //
    // Free everything that is allocated at DrvEnableDriver
    //

    VERBOSE(("Entering DrvDisableDriver...\n"));

    #if ENABLE_STOCKGLYPHSET
    EngAcquireSemaphore(hGlyphSetSem);
    FreeGlyphSet();
    EngReleaseSemaphore(hGlyphSetSem);
    EngDeleteSemaphore(hGlyphSetSem) ;
    #endif

    #ifdef WINNT_40

    ENTER_CRITICAL_SECTION();

        VFreePluginRefCountList(&gpOEMPluginRefCount);

    LEAVE_CRITICAL_SECTION();

    DELETE_CRITICAL_SECTION();

    #endif  // WINNT_40

    return;

}

VOID
DrvCompletePDEV(
    DHPDEV  dhpdev,
    HDEV    hdev
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCompletePDEV.
    Please refer to DDK documentation for more details.

    This function is called when the engine completed the installation of
    the physical device, some Engine functions requires the engine hdev as
    a parameter, so we save it in our PDEVICE for later use.

Arguments:

    dhpdev - Driver device handle
    hdev - GDI device handle

Return Value:

    NONE

--*/

{
    PDEV    *pPDev = (PDEV *) dhpdev;

    VERBOSE(("Entering DrvCompletePDEV...\n"));

    if (!VALID_PDEV(pPDev))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return;
    }
//    ASSERT_VALID_PDEV(pPDev);

    pPDev->devobj.hEngine = hdev;

}



PPDEV
PAllocPDEVData(
    HANDLE hPrinter
    )

/*++

Routine Description:

    Allocate a new PDEV structure

Arguments:

    hPrinter - handle to the current printer

Return Value:

    Pointer to newly allocated PDEV structure,
    NULL if there is an error

--*/

{
    PDEV  *pPDev;

    //
    // Allocate a zero-init PDEV structure and
    // mark the signature fields
    //

    ASSERT(hPrinter != NULL);

    if ((pPDev = MemAllocZ(sizeof(PDEV))) != NULL)
    {
        pPDev->pvStartSig = pPDev->pvEndSig = (PVOID) pPDev;
        pPDev->devobj.dwSize = sizeof(DEVOBJ);
        pPDev->devobj.hPrinter = hPrinter;
        //
        // set up pPDev->devobj.pPublicDM after pPDev->pdm has been set up
        // (init.c)
        //
        pPDev->ulID = PDEV_ID;
    }
    else
        ERR(("PAllocPDEVData: Memory allocation failed: %d\n", GetLastError()));

    return pPDev;
}


VOID
VFreePDEVData(
    PDEV    * pPDev
    )

/*++

Routine Description:

    Dispose of a PDEV structure

Arguments:

    pPDev - Pointer to a previously allocated PDEV structure

Return Value:

    NONE

--*/

{
    if (pPDev == NULL)
        return;

    VUnloadOemPlugins(pPDev);

    //
    // Call parser to free memory allocated for binary data
    //

    VUnloadFreeBinaryData(pPDev);

    //
    // Free other memory allocated for PDEV
    //

    if(pPDev->pSplForms)
    {
        MemFree(pPDev->pSplForms);
        pPDev->pSplForms = NULL ;
    }

    //
    //   Free the output buffer
    //

    if(pPDev->pbOBuf )
    {
        MemFree(pPDev->pbOBuf);
        pPDev->pbOBuf = NULL;
    }



    if (pPDev->pOptionsArray)
        MemFree(pPDev->pOptionsArray);

    //Unload Unidrv Module Handle, loaded for Unidrv resources
    if (pPDev->hUniResDLL)
        EngFreeModule(pPDev->hUniResDLL);
    //
    // Call Raster and Font module to clean up at DrvDisablePDEV
    //

    if (pPDev->pRasterProcs)
    {
        ((PRMPROCS)(pPDev->pRasterProcs))->RMDisablePDEV(pPDev);
    }

    if (pPDev->pFontProcs)
    {
        ((PFMPROCS)(pPDev->pFontProcs))->FMDisablePDEV(pPDev);
    }

    HANDLE_VECTORPROCS( pPDev, VMDisablePDEV, ((PDEVOBJ) pPDev)) ;
    HANDLE_VECTORPROCS( pPDev, VMDisableDriver, ()) ;

    //
    // Free the Palette data
    //
    if (pPDev->pPalData)
    {
        //
        // Free the Palette
        //
        if ( ((PAL_DATA *)pPDev->pPalData)->hPalette )
            EngDeletePalette( ((PAL_DATA *)pPDev->pPalData)->hPalette );

        if (((PAL_DATA*)(pPDev->pPalData))->pulDevPalCol)
            MemFree(((PAL_DATA*)(pPDev->pPalData))->pulDevPalCol);

        MemFree(pPDev->pPalData);
        pPDev->pPalData = NULL;
    }

    //
    // Free Resource Data
    //

    VWinResClose(&pPDev->WinResData);
    //  VWinResClose(&pPDev->localWinResData);

    //
    // Free devmode data
    //

    MemFree(pPDev->pdm);

    MemFree(pPDev->pDriverInfo3);

    if (pPDev->pbScanBuf)    // may be NULL for a device surface
    {
        MemFree(pPDev->pbScanBuf);
    }

    if (pPDev->pbRasterScanBuf)
    {
        MemFree(pPDev->pbRasterScanBuf);
    }
#ifndef DISABLE_NEWRULES
    if (pPDev->pbRulesArray)
    {
        MemFree(pPDev->pbRulesArray);
    }
#endif
    //
    // Free cached patterns
    //

    MemFree(pPDev->GState.pCachedPatterns);


    //
    // Free the PDEV structure itself
    //

    MemFree(pPDev);

}

HSURF
HCreateDeviceSurface(
    PDEV    * pPDev,
    INT       iFormat
    )

/*++

Routine Description:

    Creates a device surface and returns a handle that the driver
    will manage.

Arguments:

    pPDev - Pointer to PDEV structure
    iFormat - pixel depth of the device

Return Value:

    Handle to the surface if successful, NULL otherwise

--*/

{
    HSURF hSurface;
    SIZEL szSurface;

    ASSERT_VALID_PDEV(pPDev);

    szSurface.cx = pPDev->sf.szImageAreaG.cx;
    szSurface.cy = pPDev->sf.szImageAreaG.cy;

    hSurface = EngCreateDeviceSurface((DHSURF)pPDev, szSurface, iFormat);
    if (hSurface == NULL)
    {
        ERR(("EngCreateDeviceSurface failed\n"));
        SetLastError(ERROR_BAD_DRIVER_LEVEL);
        return NULL;
    }

    pPDev->rcClipRgn.top = 0;
    pPDev->rcClipRgn.left = 0;
    pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
    pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;

    pPDev->bBanding = FALSE;

    pPDev->szBand.cx = szSurface.cx;
    pPDev->szBand.cy = szSurface.cy;

    return hSurface;
}

HBITMAP
HCreateBitmapSurface(
    PDEV    * pPDev,
    INT       iFormat
    )

/*++

Routine Description:

    Creates a bitmap surface and returns a handle that the driver
    will manage.

Arguments:

    pPDev - Pointer to PDEV structure
    iFormat - pixel depth of the device

Return Value:

    Handle to the bitmap if successful, NULL otherwise

--*/

{
    SIZEL     szSurface;
    HBITMAP   hBitmap;
    ULONG     cbScan;           // Scan line byte length (DWORD aligned)
    DWORD     dwNumBands;       // Number of bands to use
    int       iBPP;             // Bits per pel, as # of bits
    int       iPins;            // Basic rounding factor for banding size
    PFN_OEMMemoryUsage pfnOEMMemoryUsage;
    DWORD     dwMaxBandSize;     // Maximum size of band to use

    szSurface.cx = pPDev->sf.szImageAreaG.cx;
    szSurface.cy = pPDev->sf.szImageAreaG.cy;

    iBPP = pPDev->sBitsPixel;

    //
    // define the maximum size bitmap band we will allow
    //
    dwMaxBandSize = MAX_SIZE_OF_BITMAP;

    //
    // adjust the maximum size of the bitmap buffer based on
    // the amount of memory used by the OEM driver.
    //
    if (pPDev->pOemHookInfo && (pfnOEMMemoryUsage = (PFN_OEMMemoryUsage)pPDev->pOemHookInfo[EP_OEMMemoryUsage].pfnHook))
    {
        OEMMEMORYUSAGE MemoryUsage;
        MemoryUsage.dwPercentMemoryUsage = 0;
        MemoryUsage.dwFixedMemoryUsage = 0;
        MemoryUsage.dwMaxBandSize = dwMaxBandSize;
        FIX_DEVOBJ(pPDev,EP_OEMMemoryUsage);

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                    HRESULT  hr ;
                    hr = HComMemoryUsage((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                (PDEVOBJ)pPDev,&MemoryUsage);
                    if(SUCCEEDED(hr))
                        ;  //  cool !
            }
            else
            {
                pfnOEMMemoryUsage((PDEVOBJ)pPDev,&MemoryUsage);
            }
        }


        dwMaxBandSize = ((dwMaxBandSize - MemoryUsage.dwFixedMemoryUsage) * 100) /
            (100 + MemoryUsage.dwPercentMemoryUsage);
    }
    if (dwMaxBandSize < (MIN_SIZE_OF_BITMAP*2L))
        dwMaxBandSize = MIN_SIZE_OF_BITMAP*2L;

    //
    // Create a surface.   Try for a bitmap for the entire surface.
    // If this fails,  then switch to journalling and a somewhat smaller
    // surface.   If journalling,  we still create the bitmap here.  While
    // it is nicer to do this at DrvSendPage() time,  we do it here to
    // ensure that it is possible.  By maintaining the bitmap for the
    // life of the DC,  we can be reasonably certain of being able to
    // complete printing regardless of how tight memory becomes later.
    //
    cbScan = ((szSurface.cx * iBPP + DWBITS - 1) & ~(DWBITS - 1)) / BBITS;

    //
    // Determine the number of bands to use based on the max size of
    // a band.
    //
    dwNumBands = ((cbScan * szSurface.cy) / dwMaxBandSize)+1;

    //
    // Test registry for forced number of bands for testing
    //
#if DBG
    {
        DWORD dwType;
        DWORD ul;
        int   RegistryBands;
        if( !GetPrinterData( pPDev->devobj.hPrinter, L"Banding", &dwType,
                       (BYTE *)&RegistryBands, sizeof( RegistryBands ), &ul ) &&
             ul == sizeof( RegistryBands ) )
        {
            /*   Some sanity checking:  if iShrinkFactor == 0, disable banding */
            if (RegistryBands > 0)
                dwNumBands = RegistryBands;
        }
    }
#endif
#ifdef BANDTEST
    //
    // Test code for forcing number of bands via GPD
    //
    if (pPDev->pGlobals->dwMaxNumPalettes > 0)
        dwNumBands = pPDev->pGlobals->dwMaxNumPalettes;
#endif

    //
    // Time to allocate surface bitmap
    //
    if (dwNumBands > 1 || pPDev->fMode & PF_FORCE_BANDING ||
        pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER  ||
        !(hBitmap = EngCreateBitmap( szSurface, (LONG) cbScan, iFormat, BMF_TOPDOWN|
BMF_NOZEROINIT|BMF_USERMEM, NULL )) )
    {
        //
        // The bitmap creation failed,  so we will try for smaller ones
        // until we find one that is OK OR we cannot create one with
        // enough scan lines to be useful.
        //

        //
        // Calculate the rounding factor for band shrink operations.
        // Basically this is to allow more effective use of the printer,
        // by making the bands a multiple of the number of pins per
        // pass.  In interlaced mode, this is the number of scan lines
        // in the interlaced band, not the number of pins in the print head.
        // For single pin printers,  make this a multiple of 8.  This
        // speeds up processing a little.
        //
        // If this is 1bpp we need to make the band size a multiple of the halftone
        // pattern to avoid a certain GDI bug where it doesn't correctly align
        // a pattern brush at the beginning of each band.
        //
        if (iBPP == 1 && pPDev->pResolutionEx->dwPinsPerLogPass == 1)
        {
            INT iPatID;
            if (pPDev->pHalftone)
                iPatID = pPDev->pHalftone->dwHTID;
            else
                iPatID= HT_PATSIZE_AUTO;
            if (iPatID == HT_PATSIZE_AUTO)
            {
                INT dpi = pPDev->ptGrxRes.x;
                if (dpi > pPDev->ptGrxRes.y)
                    dpi = pPDev->ptGrxRes.y;
                if (dpi >= 2400)    // 16x16 pattern
                    iPins = 16;
                else if (dpi >= 1800) // 14x14 pattern
                    iPins = 56;
                else if (dpi >= 1200) // 12x12 pattern
                    iPins = 24;
                else if (dpi >= 800)  // 10x10 pattern
                    iPins = 40;
                else
                    iPins = 8;
            }
            else if (iPatID == HT_PATSIZE_6x6_M || iPatID == HT_PATSIZE_12x12_M)
                iPins = 24;
            else if (iPatID == HT_PATSIZE_10x10_M)
                iPins = 40;
            else if (iPatID == HT_PATSIZE_14x14_M)
                iPins = 56;
            else if (iPatID == HT_PATSIZE_16x16_M)
                iPins = 16;
            else
                iPins = 8;
        }
        else
            iPins = (pPDev->pResolutionEx->dwPinsPerLogPass + BBITS - 1) & ~(BBITS - 1);

        if (dwNumBands <= 1)
            dwNumBands = SHRINK_FACTOR;

        while (1)
        {
            //
            // Shrink the bitmap each time around.  Note that we are
            // rotation sensitive.  In portrait mode,  we shrink the
            // Y coordinate, so that the bands fit across the page.
            // In landscape when we rotate,  shrink the X coordinate, since
            // that becomes the Y coordinate after transposing.
            //
            if( pPDev->fMode & PF_ROTATE )
            {
                //
                //   We rotate the bitmap, so shrink the X coordinates.
                //

                szSurface.cx = pPDev->sf.szImageAreaG.cx / dwNumBands;
                if( szSurface.cx < iPins)
                    return NULL;
                szSurface.cx += iPins - (szSurface.cx % iPins);
                cbScan = ((szSurface.cx * iBPP + DWBITS - 1) & ~(DWBITS - 1)) / BBITS;
            }
            else
            {
                //
                //  Normal operation,  so shrink the Y coordinate.
                //

                szSurface.cy = pPDev->sf.szImageAreaG.cy / dwNumBands;
                if( szSurface.cy < iPins)
                    return NULL;
                szSurface.cy += iPins - (szSurface.cy % iPins);
            }
            dwNumBands *= SHRINK_FACTOR;

            //
            // Try to allocate the bitmap surface
            //

            if (hBitmap = EngCreateBitmap( szSurface, (LONG) cbScan, iFormat, BMF_TOPDOWN|BMF_NOZEROINIT|BMF_USERMEM, NULL ))
                break;

            //
            // if we failed to allocate the bitmap surface we will give up
            // at some point if the band becomes too small
            //
            if ((cbScan * szSurface.cy / 2) < MIN_SIZE_OF_BITMAP)
                return NULL;
        }
        //
        // Success so mark the surface for banding
        //
#ifdef DISABLEDEVSURFACE
        EngMarkBandingSurface((HSURF)hBitmap);
#endif
        pPDev->bBanding = TRUE;
    }
    else
    {
        //
        // The speedy way: into a big bitmap.  Set the clipping region
        // to full size,  and the journal handle to 0.
        //

        pPDev->rcClipRgn.top = 0;
        pPDev->rcClipRgn.left = 0;
        pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
        pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;

        pPDev->bBanding = FALSE;
    }

    pPDev->szBand.cx = szSurface.cx;
    pPDev->szBand.cy = szSurface.cy;
    return hBitmap;
}

VOID
VDisableSurface(
    PDEV    * pPDev
    )

/*++

Routine Description:

    Clean up resources allocated at DrvEnableSurface and
    call Raster and Font module to clean up their internal data
    and deallocated memory associated with the surface

Arguments:

    pPDev - Pointer to PDEV structure

Return Value:

    NONE

--*/

{

    //
    // Call the Raster and Font module to free
    // rendering storage, position sorting memory etc.
    //

    ((PRMPROCS)(pPDev->pRasterProcs))->RMDisableSurface(pPDev);
    ((PFMPROCS)(pPDev->pFontProcs))->FMDisableSurface(pPDev);


    //
    // Delete the surface
    //

    if( pPDev->hbm )
    {
        //
        // unlock surface first if necessary
        //
        if (pPDev->pso)
        {
            EngUnlockSurface(pPDev->pso);
            pPDev->pso = NULL;
        }
        EngDeleteSurface( (HSURF)pPDev->hbm );
        pPDev->hbm = (HBITMAP)0;
    }

    if (pPDev->hSurface)
    {
        EngDeleteSurface (pPDev->hSurface);
        pPDev->hSurface = NULL;
    }

}


BOOL
BPaperSizeSourceSame(
    PDEV    * pPDevNew,
    PDEV    * pPDevOld
    )

/*++

Routine Description:

    This function check for the following condition:
    - paper size and souce has not changed.

Arguments:

    pPDevNew - Pointer to the new PDEV
    pPDevOld - Pointer to the old PDEV

Return Value:

    TRUE if both are unchanged, otherwise FALSE

--*/
{

//    if (pPDevNew->pdm->dmOrientation == pPDevOld->pdm->dmOrientation)
//        return FALSE;

    //
    // Check paper size, Note PDEVICE->pf.szPhysSize is in Portrait mode.
    //

    return (pPDevNew->pf.szPhysSizeM.cx == pPDevOld->pf.szPhysSizeM.cx &&
            pPDevNew->pf.szPhysSizeM.cy == pPDevOld->pf.szPhysSizeM.cy &&
            pPDevNew->pdm->dmDefaultSource == pPDevOld->pdm->dmDefaultSource
            );

}

BOOL
BMergeFormToTrayAssignments(
    PDEV    * pPDev
    )

/*++

Routine Description:

    This function reads the form to tray table and merges the values in the devmode.
Arguments:

    pPDev - Pointer to the PDEV


Return Value:

    TRUE for success, otherwise FALSE

--*/

{
    PFEATURE            pInputSlotFeature;
    DWORD               dwInputSlotIndex, dwIndex;
    POPTION             pOption;
    FORM_TRAY_TABLE     pFormTrayTable = NULL;
    PUIINFO             pUIInfo = pPDev->pUIInfo;
    POPTSELECT          pOptionArray = pPDev->pOptionsArray;
    BOOL                bFound = FALSE;
    PDEVMODE            pdm = pPDev->pdm;

    #if DBG
    PTSTR               pTmp;
    PFEATURE            pPageSizeFeature;
    DWORD               dwPageSizeIndex;
    #endif

    //
    // If there is no *InputSlot feature (which shouldn't happen),
    // simply ignore and return success
    //

    if (! (pInputSlotFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_INPUTSLOT)))
        return TRUE;

    dwInputSlotIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pInputSlotFeature);

    //
    // If the input slot is "AutoSelect", then go through
    // the form-to-tray assignment table and see if the
    // requested form is assigned to an input slot.
    //

    if (((pdm->dmFields & DM_DEFAULTSOURCE) &&
         (pdm->dmDefaultSource == DMBIN_FORMSOURCE)) &&
        (pdm->dmFormName[0] != NUL) &&
        (pFormTrayTable = PGetFormTrayTable(pPDev->devobj.hPrinter, NULL)))
    {
        FINDFORMTRAY    FindData;
        PTSTR           ptstrName;

        //
        // Find the tray name corresponding to the requested form name
        //

        RESET_FINDFORMTRAY(pFormTrayTable, &FindData);
        ptstrName = pdm->dmFormName;

        #if 0
        pTmp = pFormTrayTable;
        VERBOSE(("Looking for form [%ws] in the Form Tray Table\n",ptstrName));
        VERBOSE(("BEFORE SETTING: Value of pOptionArray[dwInputSlotIndex].ubCurOptIndex is = %d \n",pOptionArray[dwInputSlotIndex].ubCurOptIndex));
        #endif

        while (!bFound && *FindData.ptstrNextEntry)
        {
            if (BSearchFormTrayTable(pFormTrayTable, NULL, ptstrName, &FindData))
            {
                //
                // Convert the tray name to an option index
                //

                bFound = FALSE;

                //
                //Search from index 1 as the first input slot is a dummy tray
                //for DMBIN_FORMSOURCE.
                //

                for (dwIndex = 1; dwIndex < pInputSlotFeature->Options.dwCount; dwIndex++)
                {
                    pOption = PGetIndexedOption(pUIInfo, pInputSlotFeature, dwIndex);

                    if (pOption->loDisplayName & GET_RESOURCE_FROM_DLL)
                    {
                        //
                        // loOffset specifies a string resource ID
                        // in the resource DLL
                        //

                        WCHAR   wchbuf[MAX_DISPLAY_NAME];

//#ifdef  RCSTRINGSUPPORT
#if 0
                        if(((pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL) >= RESERVED_STRINGID_START)
                            &&  ((pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL) <= RESERVED_STRINGID_END))
                        {
                            if (!ILoadStringW ( &(pPDev->localWinResData),
                                       (pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL),
                                        wchbuf, MAX_DISPLAY_NAME) )
                            {
                                WARNING(("\n UniFont!BMergeFormToTrayAssignments:Input Tray Name not found in resource DLL\n"));
                                continue;
                            }
                        }

                        else
#endif

                            if (!ILoadStringW ( &(pPDev->WinResData),
                                       (pOption->loDisplayName & ~GET_RESOURCE_FROM_DLL),
                                        wchbuf, MAX_DISPLAY_NAME) )
                        {
                            WARNING(("\n UniFont!BMergeFormToTrayAssignments:Input Tray Name not found in resource DLL\n"));
                            continue;
                        }

                         ptstrName = wchbuf;
                    }
                    else
                        ptstrName = OFFSET_TO_POINTER(pPDev->pDriverInfo->pubResourceData, pOption->loDisplayName);

                    ASSERTMSG((ptstrName && FindData.ptstrTrayName),("\n NULL Tray Name,\
                                ptstrName = 0x%p,FindData.ptstrTrayName = 0x%p\n",
                                ptstrName, FindData.ptstrTrayName ));
                    #if 0
                    VERBOSE(("\nInput Tray Name for Option %d  = %ws\n",dwIndex, ptstrName));
                    VERBOSE(("The required Tray Name = %ws\n",FindData.ptstrTrayName));
                    VERBOSE(("\tInput TrayName for FormTray table index %d = %ws\n",dwIndex, pTmp));
                    pTmp += (wcslen(pTmp) + 1);
                    VERBOSE(("\tForm Name for FormTray table index %d = %ws\n\n",dwIndex, pTmp));
                    #endif

                    if (ptstrName && (_tcsicmp(ptstrName, FindData.ptstrTrayName) == EQUAL_STRING))
                    {
                        pOptionArray[dwInputSlotIndex].ubCurOptIndex = (BYTE) dwIndex;
                        bFound = TRUE;

                        break;
                    }
                }
            }
        }

        MemFree(pFormTrayTable);
    }

    if (!bFound)
    {
        if (pFormTrayTable)
        {
            TERSE(("Form '%ws' is not currently assigned to a tray.\n",
               pdm->dmFormName));
        }

        //
        // Set the Inputbin option to default input Bin, if current value is
        // set to dummy one.
        //

        if (pOptionArray[dwInputSlotIndex].ubCurOptIndex == 0)
        {
            pOptionArray[dwInputSlotIndex].ubCurOptIndex =
                                (BYTE)pInputSlotFeature->dwDefaultOptIndex;

        }
    }

    pPDev->pdmPrivate->aOptions[dwInputSlotIndex].ubCurOptIndex   =  pOptionArray[dwInputSlotIndex].ubCurOptIndex;

    //
    //TRACE CODE
    //

    #if 0
    if (pPageSizeFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE))
        dwPageSizeIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPageSizeFeature);

    if (pdm->dmFields & DM_DEFAULTSOURCE)
    {
        VERBOSE(("DM_DEFAULTSOURCE BIT IS ON. \n"));
    }
    else
    {
        VERBOSE(("DM_DEFAULTSOURCE BIT IS OFF.\n"));
    }

    VERBOSE(("pdm->dmDefaultSource = %d\n",pdm->dmDefaultSource));
    VERBOSE(("pFormTrayTable = 0x%p\n",pFormTrayTable));
    VERBOSE(("Value of pOptionArray[dwPageSizeIndex].ubCurOptIndex = %d \n",pOptionArray[dwPageSizeIndex].ubCurOptIndex));
    VERBOSE(("AFTER SETTING:Value of pOptionArray[dwInputSlotIndex].ubCurOptIndex = %d\n",pOptionArray[dwInputSlotIndex].ubCurOptIndex));
    VERBOSE(("AFTER SETTING:Value of pdmPrivate->aOptions[dwInputSlotIndex].ubCurOptIndex = %d\n",pPDev->pdmPrivate->aOptions[dwInputSlotIndex].ubCurOptIndex));
    VERBOSE(("Value of pInputSlotFeature->dwDefaultOptIndex is %d \n",pInputSlotFeature->dwDefaultOptIndex));
    VERBOSE(("END TRACING BMergeFormToTrayAssignments.\n\n"));
    #endif

    return TRUE;
}

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\graphics.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    graphics.c

Abstract:

    Implementation of graphics related DDI entry points:
        DrvCopyBits
        DrvBitBlt
        DrvStretchBlt
        DrvStretchBltROP
        DrvDitherColor
        DrvPlgBlt
        DrvPaint
        DrvLineTo
        DrvStrokePath
        DrvFillPath
        DrvStrokeAndFillPath
        DrvRealizeBrush
        DrvAlphaBlend
        DrvGradientFill
        DrvTransparentBlt

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support

--*/

//#define DBGNEWRULES 1

#include "unidrv.h"

VOID CheckBitmapSurface(
    SURFOBJ *pso,
    RECTL   *pRect
    )
/*++

Routine Description:

    This function checks whether the bitmap surface has
    been erased and if not it erases it. It needs to be
    called before every Drv draw function.

Arguments:

    pso     Points to surface

--*/
{
    PDEV * pPDev = (PDEV *)pso->dhpdev;
    int iWhiteIndex;

    //
    // This function should only be called from a bitmap
    // surface driver. If the driver is device managed
    // just return
    if (DRIVER_DEVICEMANAGED (pPDev))   // a device surface
    {
        WARNING(("CheckBitmapSurface is being called from a device surface driver"));
        return;
    }

    //
    // If it hasn't already been done, erase the
    // bitmap surface.
    //
    if (!(pPDev->fMode & PF_SURFACE_USED))
    {
        pPDev->fMode |= PF_SURFACE_USED;
        if (pPDev->pbRasterScanBuf == NULL)
        {
            RECTL rcPage;
            iWhiteIndex = ((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;

            rcPage.left = 0;
            rcPage.top = 0;
            rcPage.right = pPDev->szBand.cx;
            rcPage.bottom = pPDev->szBand.cy;

            EngEraseSurface( pso, &rcPage, iWhiteIndex );
            pPDev->fMode |= PF_SURFACE_ERASED;
        }
    }
#ifndef DISABLE_NEWRULES
    //
    // determine whether there are any rules that have previously been
    // detected but now need to be drawn because they overlap with this object
    //
    if (pPDev->pbRulesArray && pPDev->dwRulesCount)
    {
        DWORD i = 0;
        RECTL SrcRect;
        DWORD dwRulesCount = pPDev->dwRulesCount;
        PRECTL pRules = pPDev->pbRulesArray;
        pPDev->pbRulesArray = NULL;

        if (pRect == NULL)
        {
            SrcRect.left = SrcRect.top = 0;
            SrcRect.right = pPDev->szBand.cx;
            SrcRect.bottom = pPDev->szBand.cy;
        }
        else
        {
            SrcRect = *pRect;
            if (SrcRect.top > SrcRect.bottom)
            {
                int tmp = SrcRect.top;
                SrcRect.top = SrcRect.bottom;
                SrcRect.bottom = tmp;
            }
            if (SrcRect.top < 0)
                SrcRect.top = 0;
            if (SrcRect.bottom > pPDev->szBand.cy)
                SrcRect.bottom = pPDev->szBand.cy;
            if (SrcRect.left > SrcRect.right)
            {
                int tmp = SrcRect.left;
                SrcRect.left = SrcRect.right;
                SrcRect.right = tmp;
            }
            if (SrcRect.left < 0)
                SrcRect.left = 0;
            if (SrcRect.right > pPDev->szBand.cx)
                SrcRect.right = pPDev->szBand.cx;
        }

        // Now we loop once for every potential rule to see if the current object
        // overlaps any of them. If so we need to bitblt black into that area but we
        // try to save any of the rule that extends outside the current object.
        //
        while (i < dwRulesCount)
        {
            PRECTL pTmp = &pRules[i];
            POINTL BrushOrg = {0,0};

            if (pTmp->right > SrcRect.left &&
                pTmp->left < SrcRect.right &&
                pTmp->bottom > SrcRect.top &&
                pTmp->top < SrcRect.bottom)
            {
                if (pTmp->top < SrcRect.top && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->bottom = SrcRect.top;
                    pTmp->top = SrcRect.top;
                }
                if (pTmp->bottom > SrcRect.bottom && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->top = SrcRect.bottom;
                    pTmp->bottom = SrcRect.bottom;
                }
                if (pTmp->right > SrcRect.right && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->left = SrcRect.right;
                    pTmp->right = SrcRect.right;
                }
                if (pTmp->left < SrcRect.left && dwRulesCount < MAX_NUM_RULES)
                {
                    PRECTL pTmp2 = &pRules[dwRulesCount++];
                    *pTmp2 = *pTmp;
                    pTmp2->right = SrcRect.left;
                    pTmp->left = SrcRect.left;
                }
#ifdef DBGNEWRULES
                DbgPrint("Removed rule %u: L%u,R%u,T%u,B%u; L%u,R%u,T%u,B%u\n",
                    dwRulesCount,pTmp->left,pTmp->right,pTmp->top,pTmp->bottom,
                    SrcRect.left,SrcRect.right,SrcRect.top,SrcRect.bottom);
#endif
                CheckBitmapSurface(pPDev->pso,pTmp);
                EngBitBlt(pPDev->pso,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            pTmp,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            0x0000);    // rop4 = BLACKNESS = 0
                //
                // if we draw this in the bitmap instead of downloading we may need
                // to download a white rectangle to erase anything else already drawn
                //
                if ((COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL)) &&
                    (pPDev->fMode & PF_DOWNLOADED_TEXT))
                {
                    INT j;
                    BYTE bMask = BGetMask(pPDev, pTmp);
                    BOOL bSendRectFill = FALSE;
                    for (j = pTmp->top; j < pTmp->bottom ; j++)
                    {
                        if (pPDev->pbScanBuf[j] & bMask)
                        {
                            bSendRectFill = TRUE;
                            break;
                        }
                    }
                    //
                    // check if we overlap with downloaded text
                    //
                    if (bSendRectFill)
                    {
                        DRAWPATRECT PatRect;
                        PatRect.wStyle = 1;     // white rectangle
                        PatRect.wPattern = 0;   // pattern not used
                        PatRect.ptPosition.x = pTmp->left;
                        PatRect.ptPosition.y = pTmp->top;
                        PatRect.ptSize.x = pTmp->right - pTmp->left;
                        PatRect.ptSize.y = pTmp->bottom - pTmp->top;
                        DrawPatternRect(pPDev,&PatRect);
                    }
                }
                dwRulesCount--;
                *pTmp = pRules[dwRulesCount];
            }
            else
                i++;
        }
        pPDev->dwRulesCount = dwRulesCount;
        pPDev->pbRulesArray = pRules;
    }
#endif
    //
    // if entire surface hasn't been erased then
    // we need to erase the require section
    //
    if (!(pPDev->fMode & PF_SURFACE_ERASED))
    {
        int y1,y2;
        long iScan;
        long dwWidth = pso->lDelta;
        PBYTE pBits = (PBYTE)pso->pvBits;
        if (pRect == NULL)
        {
            pPDev->fMode |= PF_SURFACE_ERASED;
            y1 = 0;
            y2 = pPDev->szBand.cy - 1;
        }
        else
        {
            if (pRect->top > pRect->bottom)
            {
                y1 = max(0,pRect->bottom);
                y2 = min (pPDev->szBand.cy-1,pRect->top);
            }
            else
            {
                y1 = max(0,pRect->top);
                y2 = min(pPDev->szBand.cy-1,pRect->bottom);
            }
        }
        y1 = y1 / LINESPERBLOCK;
        y2 = y2 / LINESPERBLOCK;
        while ( y1 <= y2)
        {
            // test whether this block has already been erased
            //
            if (pPDev->pbRasterScanBuf[y1] == 0)
            {
                // specify block as erased
                pPDev->pbRasterScanBuf[y1] = 1;
                //
                // determined erase byte
                //
                if (pPDev->sBitsPixel == 4)
                    iWhiteIndex = 0x77;
                else if (pPDev->sBitsPixel == 8)
                    iWhiteIndex = ((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;
                else
                    iWhiteIndex = 0xff;
                //
                // determine block size and erase block
                //
                iScan = pPDev->szBand.cy - (y1 * LINESPERBLOCK);
                if (iScan > LINESPERBLOCK)
                    iScan = LINESPERBLOCK;
#ifndef WINNT_40
                FillMemory (&pBits[(ULONG_PTR )dwWidth*y1*LINESPERBLOCK],
                                (SIZE_T)dwWidth*iScan,(BYTE)iWhiteIndex);
#else
                FillMemory (&pBits[(ULONG_PTR )dwWidth*y1*LINESPERBLOCK],
                                dwWidth*iScan,(BYTE)iWhiteIndex);
#endif
            }
            y1++;
        }
    }
}
#ifndef DISABLE_NEWRULES

VOID AddRuleToList(
    PDEV *pPDev,
    PRECTL pRect,
    CLIPOBJ *pco
)
/*++

Routine Description:

    This function checks whether a potential black rule needs to be clipped.

Arguments:

    pPDev
    pRect       black rule
    pco         clip object

--*/
{
        //
        // if clip rectangle then clip the rule
        //
        if (pco && pco->iDComplexity == DC_RECT)
        {
            if (pRect->left < pco->rclBounds.left)
                pRect->left = pco->rclBounds.left;
            if (pRect->top < pco->rclBounds.top)
                pRect->top = pco->rclBounds.top;
            if (pRect->right > pco->rclBounds.right)
                pRect->right = pco->rclBounds.right;
            if (pRect->bottom > pco->rclBounds.bottom)
                pRect->bottom = pco->rclBounds.bottom;
        }
#ifdef DBGNEWRULES
        DbgPrint("New Rule %3d, L%d,R%d,T%d,B%d\n",pPDev->dwRulesCount,
            pRect->left,pRect->right,pRect->top,pRect->bottom);
#endif
        if (pRect->left < pRect->right && pRect->top < pRect->bottom)
        {
            pPDev->dwRulesCount++;
        }
}

BOOL TestStrokeRectangle(
    PDEV *pPDev,
    PATHOBJ *ppo,
    CLIPOBJ *pco,
    LONG width
    )
/*++

Routine Description:

    This function determines whether a StrokeFillPath is actually defining
    a rectangle that can be drawn with black rules instead.

Arguments:

    pPDev
    ppo         path object that might be rectangle
    pco         clip object
    width       line width

--*/
{
    POINTFIX* pptfx;
    PATHDATA  PathData;
    DWORD     dwPoints = 0;
    POINTL    pPoints[5];

    PATHOBJ_vEnumStart(ppo);

    // if there is more than one subpath then its not a rectangle
    //
    if (PATHOBJ_bEnum(ppo, &PathData))
    {
#ifdef DBGNEWRULES
        DbgPrint ("Unable to convert Rectangle3\n");
#endif
        return FALSE;
    }
    //
    // Begin new sub path
    //
    if ((PathData.count != 4 && (PathData.flags & PD_CLOSEFIGURE)) ||
        (PathData.count != 5 && !(PathData.flags & PD_CLOSEFIGURE)) ||
        !(PathData.flags & PD_BEGINSUBPATH) ||
        PathData.flags & PD_BEZIERS)
    {
#ifdef DBGNEWRULES
        DbgPrint("Unable to convert Rectangle4: flags=%x,Count=%d\n",
            PathData.flags,PathData.count);
#endif
        return FALSE;
    }   

    // Verify these are all vertical or horizontal lines only
    //
    pptfx   = PathData.pptfx;
    while (dwPoints <= 4)
    {
        if (dwPoints != 4 || PathData.count == 5)
        {       
            pPoints[dwPoints].x = FXTOL(pptfx->x);
            pPoints[dwPoints].y = FXTOL(pptfx->y);
            pptfx++;
        }
        else
        {
            pPoints[dwPoints].x = pPoints[0].x;
            pPoints[dwPoints].y = pPoints[0].y;
        }
        //
        // check for diagonal lines
        //
        if (dwPoints != 0)
        {
            if (pPoints[dwPoints].x != pPoints[dwPoints-1].x &&
                pPoints[dwPoints].y != pPoints[dwPoints-1].y)
            {
#ifdef DBGNEWRULES
                DbgPrint ("Unable to convert Rectangle5\n");
#endif
                return FALSE;
            }
        }
        dwPoints++;
    }
    //
    // make sure width is at least 1 pixel
    //
    if (width <= 0)
        width = 1;
    //
    // convert rectangle edges to rules
    //
    for (dwPoints = 0;dwPoints < 4;dwPoints++)
    {
        PRECTL pRect= &pPDev->pbRulesArray[pPDev->dwRulesCount];
        pRect->left = pPoints[dwPoints].x;
        pRect->top = pPoints[dwPoints].y;
        pRect->right = pPoints[dwPoints+1].x;
        pRect->bottom = pPoints[dwPoints+1].y;
        if (pRect->left > pRect->right)
        {
            LONG temp = pRect->left;
            pRect->left = pRect->right;
            pRect->right = temp;
        }
        pRect->left -= width >> 1;
        pRect->right += width - (width >> 1);
        if (pRect->top > pRect->bottom)
        {
            LONG temp = pRect->top;
            pRect->top = pRect->bottom;
            pRect->bottom = temp;
        }
        pRect->top -= width >> 1;
        pRect->bottom += width - (width >> 1);
        AddRuleToList(pPDev,pRect,pco);

    }
    return TRUE;
}
#endif

BOOL
DrvCopyBits(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    POINTL     *pptlSrc
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvCopyBits.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Points to the Dstination surface
    psoSrc  - Points to the source surface
    pxlo    - XLATEOBJ provided by the engine
    pco     - Defines a clipping region on the Dstination surface
    pxlo    - Defines the translation of color indices
            between the source and target surfaces
    prclDst - Defines the area to be modified
    pptlSrc - Defines the upper-left corner of the source rectangle

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV * pPDev = (PDEV *)psoDst->dhpdev;

    VERBOSE(("Entering DrvCopyBits...\n"));


    //
    // Sometimes GDI calls DrvCopyBits with the destination surface
    // as STYPE_BITMAP and the source surface as STYPE_DEVICE.
    // This means GDI wants the driver to copy whats on the device surface to the
    // Bitmap surface. For device managed surfaces, driver does not keep track of
    // what has already been drawn on the device. So either the driver can fail
    // this call, or assume that nothing was drawn on the device earlier and
    // therefore whiten the surface.
    // In most cases, the driver fails the call, except when
    // 1. It has been told to whiten the surface
    // 2. The destination surface is 24bpp (this condition was hit
    //    for 24bpp and thats how we can test it. We can make the solution more
    //    general for other color depths, but how do we test it...)
    // The drawback of whitening the surface is that
    // whatever is actually on the device surface
    // is overwritten. To prevent this, driver sets the flag PF2_RENDER_TRANSPARENT
    // in pPDev->fMode2. This is an indication to download the bitmap in
    // transparent mode, so that the white on the bitmap does not overwrite the
    // destination.
    // To hit this case, print grdfil06.emf using guiman using HP5si
    // (or any model using inbox HPGL driver).
    // NOTE: GDI is planning to change the behavior for Windows XP, but if you want to
    // see this happening, run this driver on Windows2000 machine.
    //
    if ( pPDev == NULL &&
         psoSrc && psoSrc->iType == STYPE_DEVICE  &&
         psoDst && psoDst->iType == STYPE_BITMAP )

    {
        PDEV * pPDevSrc = (PDEV *)psoSrc->dhpdev;
        if (  pPDevSrc                                &&
             (pPDevSrc->fMode2 & PF2_WHITEN_SURFACE) &&
             (psoSrc->iBitmapFormat == BMF_24BPP)  &&
              psoDst->pvBits                          &&
             (psoDst->cjBits > 0)
           )
        {
            //
            // Change the bits in the destination surface to white
            // and return TRUE.
            //
            memset(psoDst->pvBits, 0xff, psoDst->cjBits);
            pPDevSrc->fMode2     |= PF2_SURFACE_WHITENED;
            return TRUE;
        }
        return FALSE;
    }


    //
    // use driver managed surface
    //
    if (pPDev && pPDev->pso)
        psoDst = pPDev->pso;


    //
    // Unidrv does not allow OEM's to hook out DrvEnableSurface and it creates
    // only the bitmap surface itself.
    //
    if ( ((pPDev == 0) || (pPDev->ulID != PDEV_ID)) ||
        ((!DRIVER_DEVICEMANAGED (pPDev)) &&
         ((psoSrc->iType != STYPE_BITMAP) ||
          (psoDst->iType != STYPE_BITMAP))) )  // compatible bitmap case
    {
        return (EngCopyBits(psoDst,psoSrc,pco,pxlo,
                                prclDst,pptlSrc));
    }

    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMCopyBits,
                    PFN_OEMCopyBits,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMCopyBits,
                    VMCopyBits,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc));

    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);

        if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
        {
            if (pRasterProcs->RMCopyBits == NULL)
            {
                CheckBitmapSurface(psoDst,prclDst);
                return FALSE;
            }
            else
                return ( pRasterProcs->RMCopyBits(psoDst,
                                  psoSrc, pco, pxlo, prclDst, pptlSrc) );
        }
        else
        {
            ERR (("Device Managed Surface cannot call EngCopyBits\n"));
            return FALSE;
        }
    }
}



BOOL
DrvBitBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    POINTL     *pptlSrc,
    POINTL     *pptlMask,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrush,
    ROP4        rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvBitBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Describes the target surface
    psoSrc  - Describes the source surface
    psoMask - Describes the mask for rop4
    pco     - Limits the area to be modified
    pxlo    - Specifies how color indices are translated
              between the source and target surfaces
    prclDst - Defines the area to be modified
    pptlSrc - Defines the upper left corner of the source rectangle
    pptlMask - Defines which pixel in the mask corresponds to
               the upper left corner of the source rectangle
    pbo     - Defines the pattern for bitblt
    pptlBrush - Defines the origin of the brush in the Dstination surface
    rop4    - ROP code that defines how the mask, pattern, source, and
              Dstination pixels are combined to write to the Dstination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    PDEV * pPDev = (PDEV *)psoDst->dhpdev;

    VERBOSE(("Entering DrvBitBlt...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMBitBlt,
                    PFN_OEMBitBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc,
                     pptlMask,
                     pbo,
                     pptlBrush,
                     rop4));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMBitBlt,
                    VMBitBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     prclDst,
                     pptlSrc,
                     pptlMask,
                     pbo,
                     pptlBrush,
                     rop4));

    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
        if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
        {
            if (pRasterProcs->RMBitBlt == NULL)
            {
                CheckBitmapSurface(psoDst,prclDst);
                return FALSE;
            }
            else
                return ( pRasterProcs->RMBitBlt(psoDst,
                                        psoSrc, psoMask, pco, pxlo, prclDst,
                                        pptlSrc,pptlMask, pbo, pptlBrush, rop4));
        }
    }
    return FALSE;
}



BOOL
DrvStretchBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    SURFOBJ    *psoMask,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    COLORADJUSTMENT *pca,
    POINTL     *pptlHTOrg,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    POINTL     *pptlMask,
    ULONG       iMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Defines the surface on which to draw
    psoSrc  - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco     - Limits the area to be modified on the Dstination
    pxlo    - Specifies how color dwIndexes are to be translated
              between the source and target surfaces
    pca     - Defines color adjustment values to be applied to the source bitmap
    pptlHTOrg - Specifies the origin of the halftone brush
    prclDst - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
            the upper left pixel in the source rectangle
    iMode   - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV * pPDev = (PDEV *)psoDst->dhpdev;

    VERBOSE(("Entering DrvStretchBlt...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStretchBlt,
                    PFN_OEMStretchBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStretchBlt,
                    VMStretchBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode));


    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);

        if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
        {
            if (pRasterProcs->RMStretchBlt == NULL)
            {
                CheckBitmapSurface(psoDst,prclDst);
                return FALSE;
            }
            else
                return ( pRasterProcs->RMStretchBlt(psoDst, psoSrc,
                             psoMask, pco, pxlo, pca,
                             pptlHTOrg, prclDst, prclSrc, pptlMask, iMode) );
        }
        else
        {
            //
            // ERR (("Device Managed Surface cannot call EngStretchBlt\n"));
            // We make an exception for StretchBlt because OEM driver may not
            // be able to handle complex clipping. In that case it may wants
            // gdi to simply the call by breaking the StretchBlt into several
            // CopyBits. So call EngStretchBlt and hope for the best.
            //
            return ( EngStretchBlt(psoDst,
                    psoSrc,
                    psoMask,
                    pco,
                    pxlo,
                    pca,
                    pptlHTOrg,
                    prclDst,
                    prclSrc,
                    pptlMask,
                    iMode) );
        }
    }
}


ULONG
DrvDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )

/*++

Routine Description:

    This is the hooked brush creation function, it ask CreateHalftoneBrush()
    to do the actual work.

Arguments:

    dhpdev      - DHPDEV passed, it is our pDEV
    iMode       - Not used
    rgbColor    - Solid rgb color to be used
    pulDither   - buffer to put the halftone brush.

Return Value:

    returns halftone method, default is DCR_HALFTONE

--*/

{
    PDEV *pPDev = (PDEV *)dhpdev;

    VERBOSE(("Entering DrvDitherColor...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMDitherColor,
                    PFN_OEMDitherColor,
                    ULONG,
                    (dhpdev,
                     iMode,
                     rgbColor,
                     pulDither));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMDitherColor,
                    VMDitherColor,
                    ULONG,
                    (dhpdev,
                     iMode,
                     rgbColor,
                     pulDither));

    {
        PRMPROCS   pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
        if (pRasterProcs->RMDitherColor == NULL)
            return DCR_HALFTONE;
        else
           return ( pRasterProcs->RMDitherColor(pPDev,
                                            iMode,
                                            rgbColor,
                                            pulDither) );
    }
}

#ifndef WINNT_40

BOOL APIENTRY
DrvStretchBltROP(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDst,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStretchBltROP.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Specifies the target surface
    psoSrc - Specifies the source surface
    psoMask - Specifies the mask surface
    pco - Limits the area to be modified
    pxlo - Specifies how color indices are translated
        between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    prclHTOrg - Specifies the halftone origin
    prclDst - Area to be modified on the destination surface
    prclSrc - Rectangle area on the source surface
    prclMask - Rectangle area on the mask surface
    pptlMask - Defines which pixel in the mask corresponds to
        the upper left corner of the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels
    pbo - Defines the pattern for bitblt
    rop4 - ROP code that defines how the mask, pattern, source, and
        destination pixels are combined on the destination surface

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEV *pPDev = (PDEV *)psoDst->dhpdev;
    PRMPROCS   pRasterProcs;


    VERBOSE(("Entering DrvStretchBltROP...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStretchBltROP,
                    PFN_OEMStretchBltROP,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode,
                     pbo,
                     rop4));


    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStretchBltROP,
                    VMStretchBltROP,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlHTOrg,
                     prclDst,
                     prclSrc,
                     pptlMask,
                     iMode,
                     pbo,
                     rop4));

    pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);

    if (!DRIVER_DEVICEMANAGED (pPDev))   // a bitmap surface
    {
        if (pRasterProcs->RMStretchBltROP == NULL)
        {
            CheckBitmapSurface(psoDst,prclDst);
            return FALSE;
        }
        else
            return ( pRasterProcs->RMStretchBltROP(psoDst, psoSrc,
                         psoMask, pco, pxlo, pca,
                         pptlHTOrg, prclDst, prclSrc, pptlMask, iMode,
                         pbo, rop4) );
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngStretchBltROP\n"));
        return FALSE;
    }
}

#endif

#ifndef WINNT_40

BOOL APIENTRY
DrvPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode)
/*++

Routine Description:

    Implementation of DDI entry point DrvPlgBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst - Defines the surface on which to draw
    psoSrc - Defines the source for blt operation
    psoMask - Defines a surface that provides a mask for the source
    pco - Limits the area to be modified on the Dstination
    pxlo - Specifies how color dwIndexes are to be translated
        between the source and target surfaces
    pca - Defines color adjustment values to be applied to the source bitmap
    pptlBrushOrg - Specifies the origin of the halftone brush
    ppfxDest - Defines the area to be modified on the Dstination surface
    prclSrc - Defines the area to be copied from the source surface
    pptlMask - Specifies which pixel in the given mask corresponds to
        the upper left pixel in the source rectangle
    iMode - Specifies how source pixels are combined to get output pixels

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEV *pPDev;

    VERBOSE(("Entering DrvPlgBlt...\n"));
    ASSERT(psoDst != NULL);

    pPDev = (PDEV *)psoDst->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMPlgBlt,
                    PFN_OEMPlgBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlBrushOrg,
                     pptfixDest,
                     prclSrc,
                     pptlMask,
                     iMode));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMPlgBlt,
                    VMPlgBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     psoMask,
                     pco,
                     pxlo,
                     pca,
                     pptlBrushOrg,
                     pptfixDest,
                     prclSrc,
                     pptlMask,
                     iMode));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        PRMPROCS   pRasterProcs;
        pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
        if (pRasterProcs->RMPlgBlt != NULL)
        {
            return ( pRasterProcs->RMPlgBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlBrushOrg,
                         pptfixDest, prclSrc, pptlMask, iMode));
        }
        else
        {
            //
            // Check whether to erase surface
            //
            CheckBitmapSurface(psoDst,NULL);

            //
            // Unidrv does not handle this call itself.
            //
            return EngPlgBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlBrushOrg,
                         pptfixDest, prclSrc, pptlMask, iMode);
        }
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngPlgBlt\n"));
        return FALSE;
    }
}
#endif

BOOL APIENTRY
DrvPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix)
/*++

Routine Description:

    Implementation of DDI entry point DrvPaint.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface on which to draw
    pco - Limits the area to be modified on the Dstination
    pbo - Points to a BRUSHOBJ which defined the pattern and colors to fill with
    pptlBrushOrg - Specifies the origin of the halftone brush
    mix - Defines the foreground and background raster operations to use for
          the brush

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PDEV *pPDev = (PDEV *)pso->dhpdev;
    PRMPROCS   pRasterProcs;

    VERBOSE(("Entering DrvPaint...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMPaint,
                    PFN_OEMPaint,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMPaint,
                    VMPaint,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {

                pRasterProcs = (PRMPROCS)(pPDev->pRasterProcs);
                if (pRasterProcs->RMPaint != NULL)
                {
                        return ( pRasterProcs->RMPaint(pso, pco, pbo, pptlBrushOrg, mix));
                }
                else
                {
                        //
                        // Check whether to erase surface
                        //
                        CheckBitmapSurface(pso,&pco->rclBounds);
                        //
                        // Unidrv does not handle this call itself.
                        //
                        return EngPaint(pso, pco, pbo, pptlBrushOrg, mix);
                }
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngPaint"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvRealizeBrush.
    Please refer to DDK documentation for more details.

Arguments:

    pbo - BRUSHOBJ to be realized
    psoTarget - Defines the surface for which the brush is to be realized
    psoPattern - Defines the pattern for the brush
    psoMask - Transparency mask for the brush
    pxlo - Defines the interpretration of colors in the pattern
    iHatch - Specifies whether psoPattern is one of the hatch brushes

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV        *pPDev;
    PDEVBRUSH   pDB;


    VERBOSE(("Entering DrvRealizeBrush...\n"));
    ASSERT(psoTarget && pbo && pxlo);

    pPDev = (PDEV *) psoTarget->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoTarget = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMRealizeBrush,
                    PFN_OEMRealizeBrush,
                    BOOL,
                    (pbo,
                     psoTarget,
                     psoPattern,
                     psoMask,
                     pxlo,
                     iHatch));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMRealizeBrush,
                    VMRealizeBrush,
                    BOOL,
                    (pbo,
                     psoTarget,
                     psoPattern,
                     psoMask,
                     pxlo,
                     iHatch));

    //
    // BUG_BUG, if OEM hook out DrvRealizeBrush, how are we
    // handling dithering of solid color for pattern brush for text?
    //  Amanda says if OEM doesn't call this function or provide
    //  an equivalent when hooking out this function,  dithered text
    //  support will not work.   So maybe the OEM extensions guide
    //  should include such a warning in it.

    //
    // Handle realize brush for user defined pattern, dither solid color.
    //

    if ((iHatch >= HS_DDI_MAX)                                  &&
        (psoPattern)                                            &&
        (psoPattern->iType == STYPE_BITMAP)                     &&
        (psoTarget->iType == STYPE_BITMAP)                         &&
        (psoTarget->iBitmapFormat == psoPattern->iBitmapFormat)    &&
        (pDB = (PDEVBRUSH)BRUSHOBJ_pvAllocRbrush(pbo, sizeof(DEVBRUSH))))
    {

        WORD    wChecksum;
        LONG    lPatID;
        RECTW   rcw;

        rcw.l =
        rcw.t = 0;
        rcw.r = (WORD)psoPattern->sizlBitmap.cx;
        rcw.b = (WORD)psoPattern->sizlBitmap.cy;

        wChecksum = GetBMPChecksum(psoPattern, &rcw);

#ifndef WINNT_40
        VERBOSE (("\n\nRaddd:DrvRealizedBrush(%08lx) Checksum=%04lx, %ld x %ld [%ld]  ",
                BRUSHOBJ_ulGetBrushColor(pbo) & 0x00FFFFFF,
                wChecksum,  psoPattern->sizlBitmap.cx,
                psoPattern->sizlBitmap.cy, psoPattern->iBitmapFormat));
#endif
        if (lPatID = FindCachedHTPattern(pPDev, wChecksum))
        {
            //
            // Either need to download (<0) or already downloaded (>0)
            //

            if (lPatID < 0)
            {

                //
                // Need to download the ID now
                //

                lPatID = -lPatID;

                if (!Download1BPPHTPattern(pPDev, psoPattern, lPatID))
                {
                    return(FALSE);
                }
            }
            else if (lPatID == 0)   // Out of memory case
                return FALSE;

        }

        pDB->iColor   = lPatID;
        pbo->pvRbrush = (LPVOID)pDB;

        VERBOSE (("\nUnidrv:DrvRealizedBrush(PatID=%d)   ", pDB->iColor));

        return(TRUE);
    }

    return ( FALSE );


}


BOOL APIENTRY
DrvStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStrokePath.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Identifies the surface on which to draw
    ppo - Defines the path to be stroked
    pco - Defines the clipping path
    pbo - Specifies the brush to be used when drawing the path
    pptlBrushOrg - Defines the brush origin
    plineattrs - Defines the line attributes
    mix - Specifies how to combine the brush with the destination

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/

{
    PDEV *pPDev;

    VERBOSE(("Entering DrvStrokePath...\n"));
    ASSERT(pso);

    pPDev = (PDEV *)pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStrokePath,
                    PFN_OEMStrokePath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pbo,
                     pptlBrushOrg,
                     plineattrs,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStrokePath,
                    VMStrokePath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pbo,
                     pptlBrushOrg,
                     plineattrs,
                     mix));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
#ifndef DISABLE_NEWRULES
        //
        // check for black rectangle replacement
        //
        if (ppo->cCurves == 4 && ppo->fl == 0 &&
            pPDev->pbRulesArray && pPDev->dwRulesCount < (MAX_NUM_RULES-4) &&
            mix == (R2_COPYPEN | (R2_COPYPEN << 8)) && pbo &&
            (pco == NULL || pco->iDComplexity != DC_COMPLEX) &&
            ((pso->iBitmapFormat != BMF_24BPP &&
            pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) ||
             (pso->iBitmapFormat == BMF_24BPP &&
            pbo->iSolidColor == 0)))
        {
            // Make sure outline doesn't use line style
            //
            if (!(plineattrs->fl & (LA_GEOMETRIC | LA_STYLED | LA_ALTERNATE)))
            {
                if (TestStrokeRectangle(pPDev,ppo,pco,plineattrs->elWidth.l))
                {
                    return TRUE;
                }
            }
        }
#endif
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,pco? &pco->rclBounds : NULL);

        //
        // Unidrv does not handle this call itself.
        //
        return EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrushOrg, plineattrs,mix);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngStrokePath"));
        return FALSE;
    }

}


BOOL APIENTRY
DrvFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvFillPath.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface on which to draw.
    ppo - Defines the path to be filled
    pco - Defines the clipping path
    pbo - Defines the pattern and colors to fill with
    pptlBrushOrg - Defines the brush origin
    mix - Defines the foreground and background ROPs to use for the brush
    flOptions - Whether to use zero-winding or odd-even rule

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/

{
    PDEV *pPDev;

    VERBOSE(("Entering DrvFillPath...\n"));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMFillPath,
                    PFN_OEMFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix,
                     flOptions));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMFillPath,
                    VMFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pbo,
                     pptlBrushOrg,
                     mix,
                     flOptions));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&pco->rclBounds);

        //
        // Unidrv does not handle this call itself.
        //
        return EngFillPath(pso, ppo, pco, pbo, pptlBrushOrg, mix, flOptions);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngFillPath"));
        return FALSE;
    }


}


BOOL APIENTRY
DrvStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStrokeAndFillPath.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface on which to draw
    ppo - Describes the path to be filled
    pco - Defines the clipping path
    pxo - Specifies the world to device coordinate transformation
    pboStroke - Specifies the brush to use when stroking the path
    plineattrs - Specifies the line attributes
    pboFill - Specifies the brush to use when filling the path
    pptlBrushOrg - Specifies the brush origin for both brushes
    mixFill - Specifies the foreground and background ROPs to use
        for the fill brush

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvFillAndStrokePath...\n"));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStrokeAndFillPath,
                    PFN_OEMStrokeAndFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pboStroke,
                     plineattrs,
                     pboFill,
                     pptlBrushOrg,
                     mixFill,
                     flOptions));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStrokeAndFillPath,
                    VMStrokeAndFillPath,
                    BOOL,
                    (pso,
                     ppo,
                     pco,
                     pxo,
                     pboStroke,
                     plineattrs,
                     pboFill,
                     pptlBrushOrg,
                     mixFill,
                     flOptions));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&pco->rclBounds);

        //
        // Unidrv does not handle this call itself.
        //
        return EngStrokeAndFillPath(pso, ppo, pco, pxo, pboStroke, plineattrs,
                                    pboFill, pptlBrushOrg, mixFill, flOptions);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngStrokeAndFillPath"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvLineTo.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Describes the surface on which to draw
    pco - Defines the clipping path
    pbo - Defines the brush used to draw the line
    x1,y1 - Specifies the line's starting point
    x2,y2 - Specifies the line's ending point
    prclBounds - Defines a rectangle that bounds the unclipped line.
    mix - Specifies the foreground and background ROP

Return Value:

    TRUE if successful
    FALSE if driver cannot handle the path
    DDI_ERROR if there is an error

--*/
{
    PDEV         *pPDev;
    RECTL        DstRect;

    VERBOSE(("Entering DrvLineTo...\n"));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMLineTo,
                    PFN_OEMLineTo,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     x1,
                     y1,
                     x2,
                     y2,
                     prclBounds,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMLineTo,
                    VMLineTo,
                    BOOL,
                    (pso,
                     pco,
                     pbo,
                     x1,
                     y1,
                     x2,
                     y2,
                     prclBounds,
                     mix));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        DstRect.top = min(y1,y2);
        DstRect.bottom = max(y1,y2);
        DstRect.left = min(x1,x2);
        DstRect.right = max(x1,x2);
#ifndef DISABLE_NEWRULES
        //
        // check for black rectangle replacement
        //
        if (pPDev->pbRulesArray && (pPDev->dwRulesCount < MAX_NUM_RULES) &&
            (x1 == x2 || y1 == y2) &&
            mix == (R2_COPYPEN | (R2_COPYPEN << 8)) && pbo &&
            (pco == NULL || pco->iDComplexity != DC_COMPLEX) &&
            ((pso->iBitmapFormat != BMF_24BPP &&
            pbo->iSolidColor == (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) ||
            (pso->iBitmapFormat == BMF_24BPP &&
            pbo->iSolidColor == 0)))
        {
            PRECTL pRect = &pPDev->pbRulesArray[pPDev->dwRulesCount];
            *pRect = DstRect;
            if (x1 == x2)
                pRect->right++;
            else if (y1 == y2)
                pRect->bottom++;
            AddRuleToList(pPDev,pRect,pco);
            return TRUE;
        }
#endif
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(pso,&DstRect);

        //
        // Unidrv does not handle this call itself.
        //
        return EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngLineTo"));
        return FALSE;
    }
}

#ifndef WINNT_40

BOOL APIENTRY
DrvAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvAlphaBlend.
    Please refer to DDK documentation for more details.

Arguments:

    psoDest  - Defines the surface on which to draw
    psoSrc  - Defines the source
    pco     - Limits the area to be modified on the Destination
    pxlo    - Specifies how color dwIndexes are to be translated
              between the source and target surfaces
    prclDest - Defines the area to be modified on the Destination surface
    prclSrc - Defines the area to be copied from the source surface
    BlendFunction - Specifies the blend function to be used

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvAlphaBlend...\n"));

    pPDev = (PDEV *) psoDest->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDest = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMAlphaBlend,
                    PFN_OEMAlphaBlend,
                    BOOL,
                    (psoDest,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDest,
                     prclSrc,
                     pBlendObj));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMAlphaBlend,
                    VMAlphaBlend,
                    BOOL,
                    (psoDest,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDest,
                     prclSrc,
                     pBlendObj));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(psoDest,prclDest);

        //
        // Unidrv does not handle this call itself.
        //
        return EngAlphaBlend(psoDest,
                             psoSrc,
                             pco,
                             pxlo,
                             prclDest,
                             prclSrc,
                             pBlendObj);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngAlphaBlend"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvGradientFill(
    SURFOBJ    *psoDest,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    TRIVERTEX  *pVertex,
    ULONG       nVertex,
    PVOID       pMesh,
    ULONG       nMesh,
    RECTL      *prclExtents,
    POINTL     *pptlDitherOrg,
    ULONG       ulMode
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvGradientFill.
    Please refer to DDK documentation for more details.

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvGradientFill...\n"));

    pPDev = (PDEV *) psoDest->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDest = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMGradientFill,
                    PFN_OEMGradientFill,
                    BOOL,
                    (psoDest,
                     pco,
                     pxlo,
                     pVertex,
                     nVertex,
                     pMesh,
                     nMesh,
                     prclExtents,
                     pptlDitherOrg,
                     ulMode));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMGradientFill,
                    VMGradientFill,
                    BOOL,
                    (psoDest,
                     pco,
                     pxlo,
                     pVertex,
                     nVertex,
                     pMesh,
                     nMesh,
                     prclExtents,
                     pptlDitherOrg,
                     ulMode));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(psoDest,prclExtents);

        //
        // Unidrv does not handle this call itself.
        //
        return EngGradientFill(psoDest,
                               pco,
                               pxlo,
                               pVertex,
                               nVertex,
                               pMesh,
                               nMesh,
                               prclExtents,
                               pptlDitherOrg,
                               ulMode);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngGradientFill"));
        return FALSE;
    }
}

BOOL APIENTRY
DrvTransparentBlt(
    SURFOBJ    *psoDst,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDst,
    RECTL      *prclSrc,
    ULONG      iTransColor,
    ULONG      ulReserved
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvTransparentBlt.
    Please refer to DDK documentation for more details.

Arguments:

    psoDst  - Defines the surface on which to draw
    psoSrc  - Defines the source
    pco     - Limits the area to be modified on the Destination
    pxlo    - Specifies how color dwIndexes are to be translated
              between the source and target surfaces
    prclDst - Defines the area to be modified on the Destination surface
    prclSrc - Defines the area to be copied from the source surface
    iTransColor - Specifies the transparent color

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV         *pPDev;

    VERBOSE(("Entering DrvTransparentBlt...\n"));

    pPDev = (PDEV *) psoDst->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        psoDst = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMTransparentBlt,
                    PFN_OEMTransparentBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     prclSrc,
                     iTransColor,
                     ulReserved));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMTransparentBlt,
                    VMTransparentBlt,
                    BOOL,
                    (psoDst,
                     psoSrc,
                     pco,
                     pxlo,
                     prclDst,
                     prclSrc,
                     iTransColor,
                     ulReserved));

    if (!DRIVER_DEVICEMANAGED (pPDev))   // not a device surface
    {
        //
        // Check whether to erase surface
        //
        CheckBitmapSurface(psoDst,prclDst);

        //
        // Unidrv does not handle this call itself.
        //
        return EngTransparentBlt(psoDst,
                                 psoSrc,
                                 pco,
                                 pxlo,
                                 prclDst,
                                 prclSrc,
                                 iTransColor,
                                 ulReserved);
    }
    else
    {
        ERR (("Device Managed Surface cannot call EngTransparentBlt"));
        return FALSE;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\init.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Implemenation of the following initialization functions:
        BInitGDIInfo
        BInitDevInfo
        BInitPDEV

Environment:

    Windows NT Unidrv driver

Revision History:

    10/21/96 -amandan-
        Created

--*/

#include "unidrv.h"

INT  iHypot( INT, INT);
INT  iGCD(INT, INT);
VOID VInitFMode(PDEV *);
VOID VInitFYMove(PDEV *);
BOOL BInitOptions(PDEV *);
BOOL BInitCmdTable(PDEV *);
BOOL BInitStdTable(PDEV *);
BOOL BInitPaperFormat(PDEV *, RECTL *);
VOID VInitOutputCTL(PDEV *, PRESOLUTIONEX);
VOID VGetPaperMargins(PDEV *, PAGESIZE *, PAGESIZEEX *, SIZEL, RECTL *);
VOID  VOptionsToDevmodeFields(PDEV        *pPDev) ;



VOID VSwapL(
    long *pl1,
    long *pl2)
{
    long ltemp;

    ltemp = *pl1;
    *pl1 = *pl2;
    *pl2 = ltemp;
}

BOOL
BInitPDEV (
    PDEV        *pPDev,
    RECTL       *prcFormImageArea
    )
/*++

Routine Description:

    Initialize the PDEVICE

Arguments:

    pPDev - Points to the current PDEV structure
    pdm   - Points to the input devmode
    prcFormInageArea - pointer image area of form selected

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    pPDev->sCopies = pPDev->pdm->dmCopies;
    pPDev->pGlobals = &(pPDev->pDriverInfo->Globals);

    //
    // Initializes Options structs
    //

    if (BInitOptions(pPDev) == FALSE)
        return FALSE;


    //
    // Initializes pPDev->ptGrxRes and pPDev->ptTextRes based on the
    // current resolution selection
    //

    //
    // Initializes the graphics and text resolution of PDEV
    //

    ASSERT(pPDev->pResolution && pPDev->pResolutionEx);

    pPDev->ptGrxRes.x  =  pPDev->pResolutionEx->ptGrxDPI.x;
    pPDev->ptGrxRes.y  =  pPDev->pResolutionEx->ptGrxDPI.y;

    pPDev->ptTextRes.x =  pPDev->pResolutionEx->ptTextDPI.x;
    pPDev->ptTextRes.y =  pPDev->pResolutionEx->ptTextDPI.y;

    pPDev->ptGrxScale.x = pPDev->pGlobals->ptMasterUnits.x / pPDev->ptGrxRes.x;
    pPDev->ptGrxScale.y = pPDev->pGlobals->ptMasterUnits.y / pPDev->ptGrxRes.y;

    if (pPDev->pdm->dmOrientation == DMORIENT_LANDSCAPE)
    {
        VSwapL(&pPDev->ptGrxRes.x, &pPDev->ptGrxRes.y);
        VSwapL(&pPDev->ptTextRes.x, &pPDev->ptTextRes.y);
        VSwapL(&pPDev->ptGrxScale.x, &pPDev->ptGrxScale.y);
    }
    if (pPDev->pGlobals->ptDeviceUnits.x)
        pPDev->ptDeviceFac.x = pPDev->pGlobals->ptMasterUnits.x / pPDev->pGlobals->ptDeviceUnits.x;
    if (pPDev->pGlobals->ptDeviceUnits.y)
        pPDev->ptDeviceFac.y = pPDev->pGlobals->ptMasterUnits.y / pPDev->pGlobals->ptDeviceUnits.y;

    //
    // Init OUTPUTCTL
    //

    VInitOutputCTL(pPDev, pPDev->pResolutionEx);

    //
    // Initializes pPDev->sBitsPixel
    //

    if (pPDev->pColorModeEx != NULL)
        pPDev->sBitsPixel = (short)pPDev->pColorModeEx->dwDrvBPP;
    else
        pPDev->sBitsPixel = 1;

    //
    // Init PAPERFORMAT struct
    //

    ASSERT(pPDev->pPageSize != NULL);

    if (BInitPaperFormat(pPDev, prcFormImageArea) == FALSE)
        return FALSE;

    //
    // Initialize the amount of free memory in the device
    //

    if (pPDev->pMemOption)
    {
        pPDev->dwFreeMem = pPDev->pMemOption->dwFreeMem;
    }
    else
    {
        pPDev->dwFreeMem = 0;
    }

    //
    // Initialize the command table from the Unidrv predefined command index
    // as defined in GPD.H
    //

    if (BInitCmdTable(pPDev) == FALSE)
        return FALSE;

    //
    // Initialize the pPDev->fMode flag
    //

    VInitFMode(pPDev);

    //
    // Initialize the pPDev->fYMove flag
    //

    VInitFYMove(pPDev);

    //
    // Initialize the standard variable table in PDEVICE.
    // This table is used to access state variable controls by the driver
    //

    if (BInitStdTable(pPDev) == FALSE)
        return FALSE;

    //
    // Initialize misc. variables that need to be in pdev since
    // we unloads the binary data at DrvEnablePDEV and reloads it at
    // DrvEnableSurface
    //

    pPDev->dwMaxCopies = pPDev->pGlobals->dwMaxCopies;
    pPDev->dwMaxGrayFill = pPDev->pGlobals->dwMaxGrayFill;
    pPDev->dwMinGrayFill = pPDev->pGlobals->dwMinGrayFill;
    pPDev->cxafterfill = pPDev->pGlobals->cxafterfill;
    pPDev->cyafterfill = pPDev->pGlobals->cyafterfill;
    pPDev->dwCallingFuncID = INVALID_EP;

    return TRUE;

}

BOOL
BInitGdiInfo(
    PDEV    *pPDev,
    ULONG   *pGdiInfoBuffer,
    ULONG   ulBufferSize
    )

/*++

Routine Description:

    Initializes the GDIINFO struct

Arguments:

    pPDev - Points to the current PDEV structure
    pGdiInfoBuffer - Points to the output GDIINFO buffer passed in from GDI
    ulBufferSize - Size of the output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    GDIINFO gdiinfo;
    DEVHTINFO   DevHTInfo;

    // initialize GDIINFO structure
    //
    ZeroMemory(&gdiinfo, sizeof(GDIINFO));

    //
    //  Driver version
    //

    gdiinfo.ulVersion = UNIDRIVER_VERSION;

    if ( pPDev->pGlobals->printertype == PT_TTY)
    {
        pPDev->bTTY = TRUE;
        gdiinfo.ulTechnology = DT_CHARSTREAM;
    }
    else
    {
        pPDev->bTTY = FALSE;
        gdiinfo.ulTechnology = DT_RASPRINTER;
    }

    //
    // Width and Height of physical display in milimeters
    //

    //
    // Returning a negative number for ulHorzSize and ulVertSize means
    // the values are in micrometers. (25400 micrometer in 1 inch)
    //

    gdiinfo.ulHorzSize = (ULONG)MulDiv(-pPDev->sf.szImageAreaG.cx,
                                        25400, pPDev->ptGrxRes.x);

    gdiinfo.ulVertSize = (ULONG)MulDiv(-pPDev->sf.szImageAreaG.cy,
                                        25400, pPDev->ptGrxRes.y);

    //
    // Width and height of physical surface measured in device pixels
    //

    gdiinfo.ulHorzRes = pPDev->sf.szImageAreaG.cx;
    gdiinfo.ulVertRes = pPDev->sf.szImageAreaG.cy;

    gdiinfo.cBitsPixel = pPDev->sBitsPixel;
    gdiinfo.cPlanes = 1;
    gdiinfo.ulNumColors = (1 << gdiinfo.cBitsPixel);
#ifdef WINNT_40
    if (gdiinfo.ulNumColors > 0x7fff)
        gdiinfo.ulNumColors = 0x7fff;
#endif

    gdiinfo.flRaster = 0;

    gdiinfo.ulLogPixelsX = pPDev->ptGrxRes.x;
    gdiinfo.ulLogPixelsY  = pPDev->ptGrxRes.y;

    //
    // BUG_BUG, The FMInit() function fills out gdiinfo.flTextCaps field
    // gdiinfo.flTextCaps = pPDev->flTextCaps;
    //

    //
    //  The following are for Win 3.1 compatability.  The X and Y values
    //  are reversed.
    //

    gdiinfo.ulAspectX = pPDev->ptTextRes.y;
    gdiinfo.ulAspectY = pPDev->ptTextRes.x;
    gdiinfo.ulAspectXY = iHypot( gdiinfo.ulAspectX, gdiinfo.ulAspectY);


    //
    //   Set the styled line information for this printer
    //

    if(pPDev->ptGrxRes.x == pPDev->ptGrxRes.y)
    {
        //
        //  Special case: resolution is the same in both directions. This
        //  is typically true for laser and inkjet printers.
        //

        gdiinfo.xStyleStep = 1;
        gdiinfo.yStyleStep = 1;
        gdiinfo.denStyleStep = pPDev->ptGrxRes.x / 50;     // 50 elements per inch
        if ( gdiinfo.denStyleStep == 0 )
            gdiinfo.denStyleStep = 1;

    }
    else
    {
        //
        //  Resolutions differ,  so figure out lowest common multiple
        //

        INT   igcd;

        igcd = iGCD( pPDev->ptGrxRes.x, pPDev->ptGrxRes.y);

        gdiinfo.xStyleStep = pPDev->ptGrxRes.y / igcd;
        gdiinfo.yStyleStep = pPDev->ptGrxRes.x / igcd;
        gdiinfo.denStyleStep = gdiinfo.xStyleStep * gdiinfo.yStyleStep / 2;

    }

    //
    // Size and margins of physical surface measured in device pixels
    //

    gdiinfo.ptlPhysOffset.x = pPDev->sf.ptImageOriginG.x;
    gdiinfo.ptlPhysOffset.y = pPDev->sf.ptImageOriginG.y;

    gdiinfo.szlPhysSize.cx = pPDev->sf.szPhysPaperG.cx;
    gdiinfo.szlPhysSize.cy = pPDev->sf.szPhysPaperG.cy;


    //
    // BUG_BUG, RMInit should fill out the following fields in GDIINFO
    // gdiinfo.ciDevice
    // gdiinfo.ulDevicePelsDPI
    // gdiinfo.ulPrimaryOrder
    // gdiinfo.ulHTPatternSize
    // gdiinfo.ulHTOutputFormat
    // gdiinfo.flHTFlags
    //

    //
    // Copy ulBufferSize bytes of gdiinfo to pGdiInfoBuffer.
    //

    if (ulBufferSize != sizeof(gdiinfo))
        ERR(("Incorrect GDIINFO buffer size: %d != %d\n", ulBufferSize, sizeof(gdiinfo)));

    CopyMemory(pGdiInfoBuffer, &gdiinfo, min(ulBufferSize, sizeof(gdiinfo)));

    return TRUE;
}


BOOL
BInitDevInfo(
    PDEV        *pPDev,
    DEVINFO     *pDevInfoBuffer,
    ULONG       ulBufferSize
    )

/*++

Routine Description:

    Initialize the output DEVINFO buffer

Arguments:

    pPDev - Points to the current PDEV structure
    pDevInfoBuffer - Points to the output DEVINFO buffer passed in from GDI
    ulBufferSize - Size of the output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEVINFO devinfo;

    ZeroMemory(&devinfo, sizeof(devinfo));

    //
    // Fill in the graphics capabilities flags
    // BUBUG, RMInit() function should fill out devinfo.flGraphicsCaps
    // should fill this out later
    //

    //
    // Determine whether we should do metafile spooling or not
    //

    if( pPDev->pdmPrivate->dwFlags & DXF_NOEMFSPOOL )
        devinfo.flGraphicsCaps |= GCAPS_DONTJOURNAL;

#ifndef WINNT_40    // NT5
    if (pPDev->pdmPrivate->iLayout != ONE_UP)
        devinfo.flGraphicsCaps |= GCAPS_NUP;
#endif // !WINNT_40

    //
    // Get information about the default device font. Default size 10 point.
    //

    //
    // BUG_BUG, RMInit() should initialize the following DEVINFO fields
    //  flGraphicsCaps
    //  iDitherFormat
    //  cxDither
    //  cyDither
    //  hpalDefault
    //

    if (ulBufferSize != sizeof(devinfo))
        ERR(("Invalid DEVINFO buffer size: %d != %d\n", ulBufferSize, sizeof(devinfo)));

    CopyMemory(pDevInfoBuffer, &devinfo, min(ulBufferSize, sizeof(devinfo)));

    return TRUE;
}


BOOL
BInitCmdTable(
    PDEV        *pPDev
    )
/*++

Routine Description:

    The GPD specification defines a list of predefined command.  Each of these
    command has an enumration value as defined in CMDINDEX enumeration.
    This function will look up the indices of the predefined command and
    convert them to COMMAND pointers.

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    INT iCmd;

    for (iCmd = 0; iCmd < CMD_MAX; iCmd++)
    {
        //
        // CMDPOINTER will return NULL if the predefined command
        // is not supported by the device
        //

        pPDev->arCmdTable[iCmd] =  COMMANDPTR(pPDev->pDriverInfo, iCmd);
    }

    return TRUE;
}

BOOL
BInitStdTable(
    PDEV        *pPDev
    )
/*++

Routine Description:

    Initialize the array of pointers to the standard variables.  In the TOKENSTREAM
    struct, the parser will specify the actual parameter value or reference to one
    of the standard variable index defined in STDVARIABLE enumeration.  The
    driver use the pPDev->arStdPtrs to reference the actual values of the paramters,
    which are kept in various fields of the PDEVICE.

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // BUG_BUG, need to go back and fill this table out completely once
    // the FONT and RASTER PDEVICE are completely defined.
    //  note:  I could not find any uninitialized sv_fields.
    // perhaps this is too paranoid.
    //

    pPDev->arStdPtrs[SV_NUMDATABYTES]   = &pPDev->dwNumOfDataBytes;
    pPDev->arStdPtrs[SV_WIDTHINBYTES]   = &pPDev->dwWidthInBytes;
    pPDev->arStdPtrs[SV_HEIGHTINPIXELS] = &pPDev->dwHeightInPixels;
    pPDev->arStdPtrs[SV_COPIES]         = (PDWORD)&pPDev->sCopies;
    pPDev->arStdPtrs[SV_PRINTDIRECTION] = &pPDev->dwPrintDirection;
    pPDev->arStdPtrs[SV_DESTX]          = &pPDev->ctl.ptAbsolutePos.x;
    pPDev->arStdPtrs[SV_DESTY]          = &pPDev->ctl.ptAbsolutePos.y;
    pPDev->arStdPtrs[SV_DESTXREL]       = &pPDev->ctl.ptRelativePos.x;
    pPDev->arStdPtrs[SV_DESTYREL]       = &pPDev->ctl.ptRelativePos.y;
    pPDev->arStdPtrs[SV_LINEFEEDSPACING]= (PDWORD)&pPDev->ctl.lLineSpacing;
    pPDev->arStdPtrs[SV_RECTXSIZE]      = &pPDev->dwRectXSize;
    pPDev->arStdPtrs[SV_RECTYSIZE]      = &pPDev->dwRectYSize;
    pPDev->arStdPtrs[SV_GRAYPERCENT]    = &pPDev->dwGrayPercentage;
    pPDev->arStdPtrs[SV_NEXTFONTID]     = &pPDev->dwNextFontID;
    pPDev->arStdPtrs[SV_NEXTGLYPH]      = &pPDev->dwNextGlyph;
    pPDev->arStdPtrs[SV_PHYSPAPERLENGTH]= &pPDev->pf.szPhysSizeM.cy;
    pPDev->arStdPtrs[SV_PHYSPAPERWIDTH] = &pPDev->pf.szPhysSizeM.cx;
    pPDev->arStdPtrs[SV_FONTHEIGHT]     = &pPDev->dwFontHeight;
    pPDev->arStdPtrs[SV_FONTWIDTH]      = &pPDev->dwFontWidth;
    pPDev->arStdPtrs[SV_FONTMAXWIDTH]      = &pPDev->dwFontMaxWidth;
    pPDev->arStdPtrs[SV_FONTBOLD]       = &pPDev->dwFontBold;
    pPDev->arStdPtrs[SV_FONTITALIC]     = &pPDev->dwFontItalic;
    pPDev->arStdPtrs[SV_FONTUNDERLINE]  = &pPDev->dwFontUnderline;
    pPDev->arStdPtrs[SV_FONTSTRIKETHRU] = &pPDev->dwFontStrikeThru;
    pPDev->arStdPtrs[SV_CURRENTFONTID]  = &pPDev->dwCurrentFontID;
    pPDev->arStdPtrs[SV_TEXTYRES]       = &pPDev->ptTextRes.y;
    pPDev->arStdPtrs[SV_TEXTXRES]       = &pPDev->ptTextRes.x;
#ifdef BETA2
    pPDev->arStdPtrs[SV_GRAPHICSYRES]   = &pPDev->ptGrxRes.y;
    pPDev->arStdPtrs[SV_GRAPHICSXRES]   = &pPDev->ptGrxRes.x;
#endif
    pPDev->arStdPtrs[SV_ROP3]           = &pPDev->dwRop3;
    pPDev->arStdPtrs[SV_REDVALUE]               = &pPDev->dwRedValue             ;
    pPDev->arStdPtrs[SV_GREENVALUE]             = &pPDev->dwGreenValue           ;
    pPDev->arStdPtrs[SV_BLUEVALUE]              = &pPDev->dwBlueValue            ;
    pPDev->arStdPtrs[SV_PALETTEINDEXTOPROGRAM]  = &pPDev->dwPaletteIndexToProgram;
    pPDev->arStdPtrs[SV_CURRENTPALETTEINDEX]    = &pPDev->dwCurrentPaletteIndex  ;
    pPDev->arStdPtrs[SV_PATTERNBRUSH_TYPE]      = &pPDev->dwPatternBrushType;
    pPDev->arStdPtrs[SV_PATTERNBRUSH_ID]        = &pPDev->dwPatternBrushID;
    pPDev->arStdPtrs[SV_PATTERNBRUSH_SIZE]      = &pPDev->dwPatternBrushSize;
    pPDev->arStdPtrs[SV_CURSORORIGINX]  = &(pPDev->sf.ptPrintOffsetM.x);
    pPDev->arStdPtrs[SV_CURSORORIGINY]  = &(pPDev->sf.ptPrintOffsetM.y);
    pPDev->arStdPtrs[SV_PAGENUMBER]      = &pPDev->dwPageNumber;

    return TRUE;

}

BOOL
BMergeAndValidateDevmode(
    PDEV        *pPDev,
    PDEVMODE    pdmInput,
    PRECTL      prcFormImageArea
    )

/*++

Routine Description:

    Validate the input devmode and merge it with the defaults

Arguments:

    pPDev - Points to the current PDEV structure
    pdmInput - Points to the input devmode passed in from GDI
    prcImageArea - Returns the logical imageable area associated with the requested form

Return Value:

    TRUE if successful, FALSE if there is an error

--*/
{
    PPRINTER_INFO_2 pPrinterInfo2;

    //
    // Start with the driver default devmode
    //

    pPDev->pdm = PGetDefaultDevmodeWithOemPlugins(
                        NULL,
                        pPDev->pUIInfo,
                        pPDev->pRawData,
                        (pPDev->PrinterData.dwFlags & PFLAGS_METRIC),
                        pPDev->pOemPlugins,
                        pPDev->devobj.hPrinter);

    if (pPDev->pdm == NULL)
        return FALSE;

    //
    // Merge with system default devmode. In the case where the input devmode
    // is NULL, we want to use the system default devmode.
    //

    pPrinterInfo2 = MyGetPrinter(pPDev->devobj.hPrinter, 2);

    if (pPrinterInfo2 && pPrinterInfo2->pDevMode &&
        ! BValidateAndMergeDevmodeWithOemPlugins(
                pPDev->pdm,
                pPDev->pUIInfo,
                pPDev->pRawData,
                pPrinterInfo2->pDevMode,
                pPDev->pOemPlugins,
                pPDev->devobj.hPrinter))
    {
        MemFree(pPrinterInfo2);
        return FALSE;
    }

    MemFree(pPrinterInfo2);

    //
    // Merge it with the input devmode
    //

    if (pdmInput != NULL &&
        !BValidateAndMergeDevmodeWithOemPlugins(
                        pPDev->pdm,
                        pPDev->pUIInfo,
                        pPDev->pRawData,
                        pdmInput,
                        pPDev->pOemPlugins,
                        pPDev->devobj.hPrinter))
    {
        return FALSE;
    }

    pPDev->pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pPDev->pdm);

    //
    // Validate form-related devmode fields and convert information
    // in public devmode fields to feature option indices
    //

    //
    // ChangeOptionsViaID expects a combined option array
    //

    CombineOptionArray(pPDev->pRawData,
                       pPDev->pOptionsArray,
                       MAX_PRINTER_OPTIONS,
                       pPDev->pdmPrivate->aOptions,
                       pPDev->PrinterData.aOptions
                       );

    VFixOptionsArray(    pPDev,

    /*              pPDev->devobj.hPrinter,
                     pPDev->pInfoHeader,
                     pPDev->pOptionsArray,
                     pPDev->pdm,
                     pPDev->PrinterData.dwFlags & PFLAGS_METRIC,  */

                     prcFormImageArea
                     );


    VOptionsToDevmodeFields( pPDev) ;

    SeparateOptionArray(
              pPDev->pRawData,
              pPDev->pOptionsArray,
              pPDev->pdmPrivate->aOptions,
              MAX_PRINTER_OPTIONS,
              MODE_DOCUMENT_STICKY);

    pPDev->devobj.pPublicDM = pPDev->pdm;

    return TRUE;
}



VOID
VOptionsToDevmodeFields(
    PDEV        *pPDev
    )

/*++

Routine Description:

     Convert options in pPDev->pOptionsArray into public devmode fields

Arguments:

     pPDev - Points to UIDATA structure

Return Value:

     None

--*/
{
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwGID, dwFeatureIndex, dwOptionIndex;
    PUIINFO     pUIInfo;
    PDEVMODE    pdm;

    //
    // Go through all predefine IDs and propagate the option selection
    // into appropriate devmode fields
    //

    pUIInfo = pPDev->pUIInfo;
    pdm = pPDev->pdm;

    for (dwGID=0 ; dwGID < MAX_GID ; dwGID++)
    {
        //
        // Get the feature to get the options, and get the index
        // into the option array
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwGID)) == NULL)
        {
            switch(dwGID)
            {
            case GID_RESOLUTION:
                break;   //  can't happen

            case GID_DUPLEX:

                pdm->dmFields &= ~DM_DUPLEX;
                pdm->dmDuplex = DMDUP_SIMPLEX;
                break;

            case GID_INPUTSLOT:

                pdm->dmFields  &= ~DM_DEFAULTSOURCE;
                pdm->dmDefaultSource = DMBIN_ONLYONE;
                break;

            case GID_MEDIATYPE:

                pdm->dmFields  &= ~DM_MEDIATYPE;
                pdm->dmMediaType = DMMEDIA_STANDARD;
                break;

            case GID_ORIENTATION:

                pdm->dmFields  &= ~DM_ORIENTATION;
                pdm->dmOrientation = DMORIENT_PORTRAIT;
                break;

            case GID_PAGESIZE:      //   can't happen :  required feature
                break;
            case GID_COLLATE:
                pdm->dmFields  &= ~DM_COLLATE ;
                pdm->dmCollate = DMCOLLATE_FALSE ;

                break;
            }
            continue;
        }

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pPDev->pOptionsArray[dwFeatureIndex].ubCurOptIndex;

        //
        // Get the pointer to the option array for the feature
        //

        if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) == NULL)
            continue;

        switch(dwGID)
        {
        case GID_RESOLUTION:
        {
            PRESOLUTION pRes = (PRESOLUTION)pOption;

            //
            // Get to the option selected
            //

            pdm->dmFields |= (DM_PRINTQUALITY|DM_YRESOLUTION);
            pdm->dmPrintQuality = GETQUALITY_X(pRes);
            pdm->dmYResolution = GETQUALITY_Y(pRes);

        }
            break;

        case GID_DUPLEX:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DUPLEX;
            pdm->dmDuplex = (SHORT) ((PDUPLEX) pOption)->dwDuplexID;
            break;

        case GID_INPUTSLOT:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DEFAULTSOURCE;
            pdm->dmDefaultSource = (SHORT) ((PINPUTSLOT) pOption)->dwPaperSourceID;
            break;

        case GID_MEDIATYPE:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_MEDIATYPE;
            pdm->dmMediaType = (SHORT) ((PMEDIATYPE) pOption)->dwMediaTypeID;
            break;

        case GID_ORIENTATION:

            if (((PORIENTATION) pOption)->dwRotationAngle == ROTATE_NONE)
                pdm->dmOrientation = DMORIENT_PORTRAIT;
            else
                pdm->dmOrientation = DMORIENT_LANDSCAPE;

            pdm->dmFields |= DM_ORIENTATION;
            break;

        case GID_COLLATE:
            pdm->dmFields |=  DM_COLLATE ;
            pdm->dmCollate = (SHORT) ((PCOLLATE) pOption)->dwCollateID ;

            break;
        case GID_PAGESIZE:      // taken care of by BValidateDevmodeFormFields()
                    //  which is called from init.c:VFixOptionsArray()
            break;
        }
    }
}





VOID
VInitOutputCTL(
    PDEV    *pPDev,
    PRESOLUTIONEX pResEx
)
/*++

Routine Description:

    Initializes the OUTPUTCTL struct

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    None

--*/

{

    //
    // Init currrent cursor position, desired absolute and relative pos
    //

    pPDev->ctl.ptCursor.x = pPDev->ctl.ptCursor.y = 0;
    pPDev->ctl.dwMode |= MODE_CURSOR_UNINITIALIZED;
    pPDev->ctl.ptRelativePos.x = pPDev->ctl.ptRelativePos.y = 0;
    pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptAbsolutePos.y = 0;

    //
    // Init sColor which represent last grx and text color chosen
    //

    if (pPDev->pUIInfo->dwFlags & FLAG_COLOR_DEVICE)
    {
        //
        // Force sending the color command sequence before any output
        //

        pPDev->ctl.sColor = -1;

    }
    else
    {
        //
        // The device is monochrome, don't send color command sequence
        // before output
        //

        pPDev->ctl.sColor = 0;

    }

    //
    // Init lLineSpacing, which represents the last line spacing chosen
    // init to -1 to indicate unknown state
    //

    pPDev->ctl.lLineSpacing = -1;

    //
    // Init the sBytesPerPinPass which represents the physical number
    // of bytes per row of printhead
    //

    pPDev->ctl.sBytesPerPinPass = (SHORT)((pResEx->dwPinsPerPhysPass + 7) >> 3);

}

BOOL
BInitOptions(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This function looked at the currently selected UI options (stored in
    DEVMODE and merged into combined options array - pDevice->pOptionsArray)

    It stored the option structures for predefined features in the PDEVICE
    for later access.

Arguments:

    pPDev - Points to the current PDEV structure

Return Value:

    TRUE if successful and FALSE if not

--*/
{

    WORD     wGID;
    PFEATURE pFeature;
    DWORD    dwFeatureIndex;
    POPTSELECT pOptions;


    pOptions = pPDev->pOptionsArray;

    for ( wGID = 0 ; wGID < MAX_GID; wGID++)
    {

        switch (wGID)
        {
        case GID_RESOLUTION:
        {
            //
            // Required feature
            //

            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_RESOLUTION))
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);
            else
                return FALSE;

            pPDev->pResolution  = (PRESOLUTION)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);

            pPDev->pResolutionEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                         pPDev->pResolution->GenericOption.loRenderOffset);

            ASSERT(pPDev->pResolution && pPDev->pResolutionEx);

        }
            break;

        case GID_PAGESIZE:
        {
            //
            // Required feature
            //

            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_PAGESIZE))
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);
            else
                return FALSE;

            pPDev->pPageSize   = (PPAGESIZE)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);

            pPDev->pPageSizeEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                         pPDev->pPageSize->GenericOption.loRenderOffset);

            ASSERT(pPDev->pPageSize                   &&
                   pPDev->pPageSizeEx                 );

        }
            break;

        case GID_DUPLEX:
        {
            //
            // Optional
            //

            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_DUPLEX))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pDuplex     = (PDUPLEX)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pDuplex = NULL;

            }
        }
            break;

        case GID_INPUTSLOT:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_INPUTSLOT))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pInputSlot  = (PINPUTSLOT)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
                ASSERT(pPDev->pInputSlot);
#if 0
                //
                // InputSlotEx struct is deleted.
                //
                pPDev->pInputSlotEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                             pPDev->pInputSlot->GenericOption.loRenderOffset);
                ASSERT(pPDev->pInputSlotEx);
#endif

            }
            else
            {
                pPDev->pInputSlot = NULL;
//                pPDev->pInputSlotEx = NULL;

            }
        }
            break;


        case GID_MEMOPTION:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_MEMOPTION))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pMemOption   = (PMEMOPTION)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pMemOption = NULL;

            }

        }
            break;

        case GID_COLORMODE:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_COLORMODE))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pColorMode   = (PCOLORMODE)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
                pPDev->pColorModeEx = OFFSET_TO_POINTER(pPDev->pInfoHeader,
                            pPDev->pColorMode->GenericOption.loRenderOffset);

            }
            else
            {
                pPDev->pColorMode = NULL;

            }
         }
            break;

        case GID_ORIENTATION:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_ORIENTATION))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pOrientation   = (PORIENTATION)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pOrientation = NULL;

            }

        }
            break;

        case GID_PAGEPROTECTION:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_PAGEPROTECTION))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pPageProtect  = (PPAGEPROTECT)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pPageProtect = NULL;

            }
        }
            break;

        case GID_HALFTONING:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_HALFTONING))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pHalftone      = (PHALFTONING)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pHalftone = NULL;

            }

        }
            break;
#if 0

        case GID_MEDIATYPE:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_MEDIATYPE))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pMediaType  = (PMEDIATYPE)PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pMediaType = NULL;

            }

        }
            break;


        case GID_COLLATE:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_COLLATE))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pCollate        = PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pCollate = NULL;

            }

        }
            break;

        case GID_OUTPUTBIN:
        {
            if (pFeature = GET_PREDEFINED_FEATURE(pPDev->pUIInfo, GID_OUTPUTBIN))
            {
                dwFeatureIndex = GET_INDEX_FROM_FEATURE(pPDev->pUIInfo, pFeature);

                pPDev->pOutputBin   = PGetIndexedOption(
                                                   pPDev->pUIInfo,
                                                   pFeature,
                                                   pOptions[dwFeatureIndex].ubCurOptIndex);
            }
            else
            {
                pPDev->pOutputBin = NULL;

            }

        }
            break;
#endif
        default:
            break;
        }

    }
    return TRUE;
}


BOOL
BInitPaperFormat(
    PDEV    *pPDev,
    RECTL   *pFormImageArea
    )

/*++

Routine Description:

    Figure out the currently selected paper size and initialize
    the PAPERFORMAT & SURFACEFORMAT structs

Arguments:

    pPDev - Pointer to PDEVICE
    pFormImageArea - Pointer to Imageable area of the form

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    The followings are assumptions made by this function regarding information
    in the parser snapshot.

    - szPaperSize in PAGESIZE is always in portrait mode.
    - szImageArea in PAGESIZE is always in portrait mode.
    - ptImageOrigin in PAGESIZE is always in portrait mode.
    - Printer cursor offset calculation is dependent of pGlobals->bRotateCoordinate.
      If this is set to TRUE, must calculate it according to the rotation angle
      specified in ORIENATION.dwRotationAngle

--*/
{
    PPAGESIZE       pPaper;
    PPAGESIZEEX     pPaperEx;
    RECTL           rcMargins, rcImgArea, rcIntersectArea;
    SIZEL           szPaperSize, szImageArea;
    PFN_OEMTTYGetInfo   pfnOemTTYGetInfo;
    DWORD           cbcNeeded;
    BOOL  bOEMinfo = FALSE ;



    //
    // Get the current selected paper size and paper source
    //

    pPaper = pPDev->pPageSize;
    pPaperEx = pPDev->pPageSizeEx;

    ASSERT(pPaper && pPaperEx);

    //
    // Convert pFormImageArea from microns to master units
    //

    pFormImageArea->left  = MICRON_TO_MASTER(pFormImageArea->left,
                                               pPDev->pGlobals->ptMasterUnits.x);

    pFormImageArea->top   = MICRON_TO_MASTER(pFormImageArea->top ,
                                               pPDev->pGlobals->ptMasterUnits.y);

    pFormImageArea->right = MICRON_TO_MASTER(pFormImageArea->right ,
                                               pPDev->pGlobals->ptMasterUnits.x);

    pFormImageArea->bottom = MICRON_TO_MASTER(pFormImageArea->bottom ,
                                               pPDev->pGlobals->ptMasterUnits.y);

    //
    // If it's a user defined paper size, use the dimensions in devmode
    // otherwise get it from the pagesize option
    //

    if (pPaper->dwPaperSizeID == DMPAPER_USER)
    {
        //
        // Need to convert from 0.1mm to micrometer
        // .1mm * 100 gives micrometer. and convert to Master unit
        //

        szPaperSize.cx =  MICRON_TO_MASTER(
                                    pPDev->pdm->dmPaperWidth * 100,
                                    pPDev->pGlobals->ptMasterUnits.x);
        szPaperSize.cy =  MICRON_TO_MASTER(
                                    pPDev->pdm->dmPaperLength * 100,
                                    pPDev->pGlobals->ptMasterUnits.y);

        // calculate szImageArea after margins
    }
    else
    {
        CopyMemory(&szPaperSize, &pPaper->szPaperSize, sizeof(SIZEL));
        CopyMemory(&szImageArea, &pPaperEx->szImageArea, sizeof(SIZEL));

        //
        // Exchange X & Y dimensions: This is used only when the paper size( like
        // envelopes) does not suit the printer's paper feeding method.
        // equivalent to PS_ROTATE in GPC
        //

        if (pPaperEx->bRotateSize)
        {
            VSwapL(&szPaperSize.cx, &szPaperSize.cy);
            VSwapL(&pFormImageArea->right, &pFormImageArea->bottom);
        }
    }

    //
    // GetPaperMargins calculates the margins based on the paper size margins,
    // forms margins, and feed margins.
    // rcMargins returned is in portrait mode
    //

    bOEMinfo = FALSE ;

    if  (pPDev->pGlobals->printertype == PT_TTY)
    {
        if (!pPDev->pOemHookInfo  ||  !(pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pOemEntry))
            return(FALSE) ;  //  TTY driver must support this function.

        FIX_DEVOBJ(pPDev, EP_OEMTTYGetInfo);

        if(pPDev->pOemEntry)
        {
            if(  ((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                            (PDEVOBJ)pPDev, OEMTTY_INFO_MARGINS, &rcMargins, sizeof(RECTL), &cbcNeeded);
                if(!SUCCEEDED(hr))
                    bOEMinfo = FALSE ;
                else
                    bOEMinfo = TRUE ;

            }
            else  if(         (pfnOemTTYGetInfo = (PFN_OEMTTYGetInfo)pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pfnHook) &&
                 (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_MARGINS, &rcMargins, sizeof(RECTL), &cbcNeeded)))
                        bOEMinfo = TRUE ;
        }
    }

    if(bOEMinfo)
    {
        //
        // Need to convert .1mm to Master Units
        //

        rcMargins.left = MICRON_TO_MASTER(rcMargins.left * 100,
                                            pPDev->pGlobals->ptMasterUnits.x);

        rcMargins.top = MICRON_TO_MASTER(rcMargins.top * 100,
                                            pPDev->pGlobals->ptMasterUnits.y);

        rcMargins.right = MICRON_TO_MASTER(rcMargins.right * 100,
                                            pPDev->pGlobals->ptMasterUnits.x);

        rcMargins.bottom = MICRON_TO_MASTER(rcMargins.bottom * 100,
                                            pPDev->pGlobals->ptMasterUnits.y);
    }
    else
    {
        VGetPaperMargins(pPDev, pPaper, pPaperEx, szPaperSize, &rcMargins);
    }

    if (pPaper->dwPaperSizeID == DMPAPER_USER)
    {
        szImageArea.cx = szPaperSize.cx - rcMargins.left - rcMargins.right;
        szImageArea.cy = szPaperSize.cy - rcMargins.top - rcMargins.bottom;
    }

    //
    // Adjust margins and szImageArea to take into account the
    // form margins, just in case the form is not a built-in form
    //

    rcImgArea.left = rcMargins.left;
    rcImgArea.top = rcMargins.top;
    rcImgArea.right = rcMargins.left + szImageArea.cx;
    rcImgArea.bottom = rcMargins.top + szImageArea.cy;

    if (!BIntersectRect(&rcIntersectArea, &rcImgArea, pFormImageArea))
        return FALSE;

    rcMargins.left = rcIntersectArea.left;
    rcMargins.top = rcIntersectArea.top;
    rcMargins.right = szPaperSize.cx - rcIntersectArea.right;
    rcMargins.bottom = szPaperSize.cy - rcIntersectArea.bottom;
    szImageArea.cx  = rcIntersectArea.right - rcIntersectArea.left;
    szImageArea.cy = rcIntersectArea.bottom - rcIntersectArea.top;

    //
    // ready to initialize PAPERFORMAT struct now
    //

    pPDev->pf.szPhysSizeM.cx = szPaperSize.cx;
    pPDev->pf.szPhysSizeM.cy = szPaperSize.cy;
    pPDev->pf.szImageAreaM.cx = szImageArea.cx;
    pPDev->pf.szImageAreaM.cy = szImageArea.cy;
    pPDev->pf.ptImageOriginM.x = rcMargins.left;
    pPDev->pf.ptImageOriginM.y = rcMargins.top;

    //
    // Now, take current orientation into consideration and set up
    // SURFACEFORMAT struct.
    // Note that pPDev->ptGrxScale has alreay been rotated to suit the orientation.
    //
    if (pPDev->pdm->dmOrientation == DMORIENT_LANDSCAPE)
    {
        pPDev->sf.szPhysPaperG.cx = szPaperSize.cy / pPDev->ptGrxScale.x;
        pPDev->sf.szPhysPaperG.cy = szPaperSize.cx / pPDev->ptGrxScale.y;

        pPDev->sf.szImageAreaG.cx = szImageArea.cy / pPDev->ptGrxScale.x;
        pPDev->sf.szImageAreaG.cy = szImageArea.cx / pPDev->ptGrxScale.y;

        //
        // 2 scenarios for landscape mode
        // CC_90, rotate CC 90 degrees, for dot matrix style printers
        // CC_270, rotate CC 270 degrees, for Laser Jet style printers
        //

        if ( pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle == ROTATE_90)
        {
            pPDev->sf.ptImageOriginG.x = rcMargins.bottom / pPDev->ptGrxScale.x;
            pPDev->sf.ptImageOriginG.y = rcMargins.left / pPDev->ptGrxScale.y;
        }
        else
        {
            pPDev->sf.ptImageOriginG.x = rcMargins.top / pPDev->ptGrxScale.x;
            pPDev->sf.ptImageOriginG.y = rcMargins.right / pPDev->ptGrxScale.y;
        }

        if (!pPDev->pOrientation  ||  pPDev->pGlobals->bRotateCoordinate == FALSE)
        {
            pPDev->sf.ptPrintOffsetM.x = pPDev->pf.ptImageOriginM.x - pPaperEx->ptPrinterCursorOrig.x;
            pPDev->sf.ptPrintOffsetM.y = pPDev->pf.ptImageOriginM.y - pPaperEx->ptPrinterCursorOrig.y;

        }
        else
        {
            if ( pPDev->pOrientation->dwRotationAngle == ROTATE_90)
            {
                pPDev->sf.ptPrintOffsetM.x =
                    rcMargins.bottom + pPaperEx->ptPrinterCursorOrig.y - pPDev->pf.szPhysSizeM.cy;
                pPDev->sf.ptPrintOffsetM.y =
                    rcMargins.left - pPaperEx->ptPrinterCursorOrig.x;
            }
            else
            {
                pPDev->sf.ptPrintOffsetM.x =
                    rcMargins.top - pPaperEx->ptPrinterCursorOrig.y;
                pPDev->sf.ptPrintOffsetM.y =
                    rcMargins.right + pPaperEx->ptPrinterCursorOrig.x - pPDev->pf.szPhysSizeM.cx;
            }

        }
    }
    else
    {
        pPDev->sf.szPhysPaperG.cx = szPaperSize.cx / pPDev->ptGrxScale.x;
        pPDev->sf.szPhysPaperG.cy = szPaperSize.cy / pPDev->ptGrxScale.y;
        pPDev->sf.szImageAreaG.cx = szImageArea.cx / pPDev->ptGrxScale.x;
        pPDev->sf.szImageAreaG.cy = szImageArea.cy / pPDev->ptGrxScale.y;

        pPDev->sf.ptImageOriginG.x = rcMargins.left / pPDev->ptGrxScale.x;
        pPDev->sf.ptImageOriginG.y = rcMargins.top / pPDev->ptGrxScale.y;

        pPDev->sf.ptPrintOffsetM.x = pPDev->pf.ptImageOriginM.x - pPaperEx->ptPrinterCursorOrig.x;
        pPDev->sf.ptPrintOffsetM.y = pPDev->pf.ptImageOriginM.y - pPaperEx->ptPrinterCursorOrig.y;

    }

    return TRUE;
}

VOID
VGetPaperMargins(
    PDEV        *pPDev,
    PAGESIZE    *pPageSize,
    PAGESIZEEX  *pPageSizeEx,
    SIZEL       szPhysSize,
    PRECTL      prcMargins

    )

/*++

Routine Description:

    Calculate the margins based on paper margins and the input slot feed margins.

Arguments:

    pPDev - Pointer to PDEVICE
    pPageSize - pointer to PAGESIZE
    pPageSizeEx - Pointer to PAGESIZEEX
    szPhysSize - physical dimensions (after applying *RotateSize?)
    prcMargins - Pointer to RECTL to hold the margins calculated

Return Value:

    None

Note:

    All margins calculations are in Portrait mode.
    The margins returned in prcMargins are in portrait mode

    Assumed that physical paper size, image area, and image origin in binary
    data are in portrait mode.

--*/
{
    if (pPageSize->dwPaperSizeID == DMPAPER_USER)
    {
        if(pPageSizeEx->strCustCursorOriginX.dwCount == 5 &&
            pPageSizeEx->strCustCursorOriginY.dwCount == 5  &&
            pPageSizeEx->strCustPrintableOriginX.dwCount == 5 &&
            pPageSizeEx->strCustPrintableOriginY.dwCount == 5  &&
            pPageSizeEx->strCustPrintableSizeX.dwCount == 5  &&
            pPageSizeEx->strCustPrintableSizeY.dwCount == 5  )  // if all parameters present...
        {
            SIZEL       szImageArea;            // *PrintableArea, for CUSTOMSIZE options
            POINT       ptImageOrigin;          // *PrintableOrigin, for CUSTOMSIZE options
            BYTE    *pInvocationStr;         //  points to parameter reference:   "%dddd"
            PARAMETER *pParameter;          //  points to parameter structure  referenced by "%dddd"
            BOOL    bMaxRepeat = FALSE;     // dummy placeholder.


            //   init standard variable for papersize!  since these are not yet initialized at this time!
            //   this implies GPD writer may only reference  the standard vars "PhysPaperLength"
            //  and   "PhysPaperWidth"   in these parameters.

            pPDev->pf.szPhysSizeM.cx = szPhysSize.cx;
            pPDev->pf.szPhysSizeM.cy = szPhysSize.cy;
            pPDev->arStdPtrs[SV_PHYSPAPERLENGTH]= &pPDev->pf.szPhysSizeM.cy;
            pPDev->arStdPtrs[SV_PHYSPAPERWIDTH] = &pPDev->pf.szPhysSizeM.cx;

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustCursorOriginX.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            pPageSizeEx->ptPrinterCursorOrig.x = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustCursorOriginY.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            pPageSizeEx->ptPrinterCursorOrig.y = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableOriginX.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            ptImageOrigin.x = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableOriginY.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            ptImageOrigin.y = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableSizeX.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            szImageArea.cx = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pPageSizeEx->strCustPrintableSizeY.loOffset);
            //  pInvocationStr[0] == '%'
            pParameter = PGetParameter(pPDev, pInvocationStr + 1);
            szImageArea.cy = IProcessTokenStream(pPDev,  &pParameter->arTokens,  &bMaxRepeat);

            prcMargins->left = ptImageOrigin.x;
            prcMargins->top = ptImageOrigin.y;
            prcMargins->right = szPhysSize.cx - szImageArea.cx - ptImageOrigin.x;
            prcMargins->bottom = szPhysSize.cy - szImageArea.cy - ptImageOrigin.y;
        }
        else
        {
            DWORD dwHorMargin, dwLeftMargin;

            //
            // calculate the margins and printable area based on info in pPageSizeEx
            //
            prcMargins->top = pPageSizeEx->dwTopMargin;
            prcMargins->bottom = pPageSizeEx->dwBottomMargin;

            //
            // Calculate the horizontal margin and adjust it if the user specified
            // centering the printable area along the paper path
            //
            if((DWORD)szPhysSize.cx < pPageSizeEx->dwMaxPrintableWidth)
                 dwHorMargin = 0;
             else
                 dwHorMargin = szPhysSize.cx - pPageSizeEx->dwMaxPrintableWidth;
            //
            // Determine the horizontal margins.  If they are centered,  then the
            // Left margin is simply the overall divided in two.  But,  we need to
            // consider both the printer's and form's margins,  and choose the largest.
            //
            if( pPageSizeEx->bCenterPrintArea)
                dwLeftMargin = (dwHorMargin / 2);
            else
                dwLeftMargin = 0;

            prcMargins->left = dwLeftMargin < pPageSizeEx->dwMinLeftMargin ?
                                    pPageSizeEx->dwMinLeftMargin : dwLeftMargin;

            if( dwHorMargin > (DWORD)prcMargins->left ) // still have margin to distribute
                prcMargins->right = dwHorMargin - prcMargins->left;
            else
                prcMargins->right = 0;
        }

    }
    else
    {
        prcMargins->left = pPageSizeEx->ptImageOrigin.x;
        prcMargins->top = pPageSizeEx->ptImageOrigin.y;
        prcMargins->right = szPhysSize.cx - pPageSizeEx->szImageArea.cx
                                          - pPageSizeEx->ptImageOrigin.x;
        prcMargins->bottom = szPhysSize.cy - pPageSizeEx->szImageArea.cy
                                           - pPageSizeEx->ptImageOrigin.y;

    }

    //
    // All margins are positive or zero
    //

    if( prcMargins->top < 0 )
        prcMargins->top = 0;

    if( prcMargins->bottom < 0 )
        prcMargins->bottom = 0;

    if( prcMargins->left < 0 )
        prcMargins->left = 0;

    if( prcMargins->right < 0 )
        prcMargins->right = 0;

}

VOID
VInitFYMove(
    PDEV    *pPDev
)
/*++

Routine Description:

    Initialize the fYMove flag in PDEVICE from reading the
    YMoveAttributes keyword

Arguments:

    pPDEV - Pointer to PDEVICE

Return Value:

    None

--*/
{
    PLISTNODE pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                      pPDev->pGlobals->liYMoveAttributes);
    pPDev->fYMove = 0;

    while (pListNode)
    {

        if (pListNode->dwData == YMOVE_FAVOR_LINEFEEDSPACING)
            pPDev->fYMove |= FYMOVE_FAVOR_LINEFEEDSPACING;

        if (pListNode->dwData == YMOVE_SENDCR_FIRST)
            pPDev->fYMove |= FYMOVE_SEND_CR_FIRST;

        if (pListNode->dwNextItem == END_OF_LIST)
            break;
        else
            pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                    pListNode->dwNextItem);
    }
}

VOID
VInitFMode(
    PDEV    *pPDev
)
/*++

Routine Description:

    Initialize the fMode flag in PDEVICE to reflect the settings saved
    in Devmode.dmPrivate.dwFlags AND to reflect the device capabilities

Arguments:

    pPDEV - Pointer to PDEVICE

Return Value:

    None

--*/
{
    if (pPDev->pdmPrivate->dwFlags & DXF_NOEMFSPOOL)
        pPDev->fMode |= PF_NOEMFSPOOL;

    //
    // Adjust memory for page protection only if the user selects
    // to turn on page protection and this feature exists.
    //

    if ( (pPDev->PrinterData.dwFlags & PFLAGS_PAGE_PROTECTION) &&
            pPDev->pPageProtect  &&
         (pPDev->pPageProtect->dwPageProtectID == PAGEPRO_ON) )
    {
        //
        // Look up the page protection value in the PAGESIZE struct for the
        // paper size selected
        //

        DWORD   dwPageMem = pPDev->pPageSize->dwPageProtectionMemory;

        if (dwPageMem < pPDev->dwFreeMem)
        {
            pPDev->fMode |= PF_PAGEPROTECT;
            pPDev->dwFreeMem -= dwPageMem;
        }

        ASSERT(pPDev->dwFreeMem > 0);
    }

    //
    // Check whether the device can do landscape rotation
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateRasterData == FALSE)
    {
        //
        // bRotateRasterData is set to TRUE if the device can rotate
        // graphics data.  Otherwise, the driver will have to do it.
        // PF_ROTATE is set to indicate that the driver needs to rotate
        // the graphics data, for when we do banding.
        //

        pPDev->fMode |= PF_ROTATE;

        if (pPDev->pOrientation->dwRotationAngle == ROTATE_90)
            pPDev->fMode |= PF_CCW_ROTATE90;
    }

    //
    // Init X and Y move CMD capabilities
    //

    if (pPDev->arCmdTable[CMD_XMOVERELLEFT] == NULL &&
        pPDev->arCmdTable[CMD_XMOVERELRIGHT] == NULL)
    {
        pPDev->fMode |= PF_NO_RELX_MOVE;
    }

    if (pPDev->arCmdTable[CMD_YMOVERELUP] == NULL &&
        pPDev->arCmdTable[CMD_YMOVERELDOWN] == NULL)
    {
        pPDev->fMode |= PF_NO_RELY_MOVE;
    }

    if (pPDev->arCmdTable[CMD_XMOVEABSOLUTE] == NULL &&
        pPDev->arCmdTable[CMD_XMOVERELRIGHT] == NULL)
    {
        pPDev->fMode |= PF_NO_XMOVE_CMD;
    }

    if (pPDev->arCmdTable[CMD_YMOVEABSOLUTE] == NULL &&
        pPDev->arCmdTable[CMD_YMOVERELDOWN] == NULL)
    {
        pPDev->fMode |= PF_NO_YMOVE_CMD;
    }

    if (pPDev->arCmdTable[CMD_SETRECTWIDTH] != NULL &&
        pPDev->arCmdTable[CMD_SETRECTHEIGHT] != NULL)
    {
        pPDev->fMode |= PF_RECT_FILL;
    }

    if (pPDev->arCmdTable[CMD_RECTWHITEFILL] != NULL)
        pPDev->fMode |= PF_RECTWHITE_FILL;

    //
    // Init brush selection capabilities
    //

    if (pPDev->arCmdTable[CMD_DOWNLOAD_PATTERN] )
        pPDev->fMode |= PF_DOWNLOAD_PATTERN;

    if (pPDev->arCmdTable[CMD_SELECT_PATTERN])
        pPDev->fMode |= PF_SHADING_PATTERN;

    //
    // BUG_BUG, need to get rid of CMD_WHITETEXTON, CMD_WHITETEXTOFF once
    // all the GPD changes have completed for CMD_SELECT_WHITEBRUSH, CMD_SELECT_BLACKBRUSH
    //     no harm done either way.

    if ( (pPDev->arCmdTable[CMD_SELECT_WHITEBRUSH] &&
          pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH]) ||
         (pPDev->arCmdTable[CMD_WHITETEXTON] &&
          pPDev->arCmdTable[CMD_WHITETEXTOFF]) )
        pPDev->fMode |= PF_WHITEBLACK_BRUSH;

    // 
    // Init raster mirroring flag
    //
    if (pPDev->pGlobals->bMirrorRasterPage)
        pPDev->fMode2 |= PF2_MIRRORING_ENABLED;

}


INT
iHypot(
    INT iX,
    INT iY
    )
/*++

Routine Description:

    Calculates the length of the hypotenous of a right triangle whose
    sides are passed in as parameters

Arguments:

    iX, iY - Sides of a right triangle

Return Value:

    The hypotenous of the triangle

--*/
{
    register INT  iHypo;

    INT iDelta, iTarget;

    /*
     *     Finds the hypoteneous of a right triangle with legs equal to x
     *  and y.  Assumes x, y, hypo are integers.
     *  Use sq(x) + sq(y) = sq(hypo);
     *  Start with MAX(x, y),
     *  use sq(x + 1) = sq(x) + 2x + 1 to incrementally get to the
     *  target hypotenouse.
     */

    iHypo = max( iX, iY );
    iTarget = min( iX,iY );
    iTarget = iTarget * iTarget;

    for( iDelta = 0; iDelta < iTarget; iHypo++ )
        iDelta += (iHypo << 1) + 1;


    return   iHypo;
}


INT
iGCD(
    INT i0,
    INT i1
    )
/*++

Routine Description:

    Calculates the Greatest Common Divisor. Use Euclid's algorith.

Arguments:

    i0, i1  - the first and second number

Return Value:

    The greatest common divisor

--*/
{
    int   iRem;       /* Will be the remainder */


    if( i0 < i1 )
    {
        /*   Need to interchange them */
        iRem = i0;
        i0 = i1;
        i1 = iRem;
    }

    while( iRem = (i0 % i1) )
    {
        /*   Step along to the next value */
        i0 = i1;
        i1 = iRem;
    }

    return   i1;            /*  The answer! */
}

BOOL
BIntersectRect(
    OUT PRECTL   prcDest,
    IN  PRECTL   prcRect1,
    IN  PRECTL   prcRect2
    )

/*++

Routine Description:

    Intersect the Rec1 and Rect2
    and store the result in the destination rectangle

Arguments:

    prcDest - Points to the destination rectangle
    prcSrc - Points to the source rectangle

Return Value:

    FALSE if the intersected rectangle is empty
    TRUE otherwise

--*/

{
    ASSERT(prcDest != NULL && prcRect1 != NULL && prcRect2 != NULL);

    if (prcRect1->left < prcRect2->left)
        prcDest->left = prcRect2->left;
    else
        prcDest->left = prcRect1->left;


    if (prcRect1->top < prcRect2->top)
        prcDest->top = prcRect2->top;
    else
        prcDest->top = prcRect1->top;

    if (prcRect1->right > prcRect2->right)
        prcDest->right = prcRect2->right;
    else
        prcDest->right = prcRect1->right;

    if (prcRect1->bottom > prcRect2->bottom)
        prcDest->bottom = prcRect2->bottom;
    else
        prcDest->bottom = prcRect1->bottom;

    return (prcDest->right > prcDest->left) &&
           (prcDest->bottom > prcDest->top);
}


VOID
SetRop3(
    PDEV    *pPDev,
    DWORD   dwRop3
    )
/*++

Routine Description:

    This function set the Rop3 value for the Raster and Font module

Arguments:
    pPDev   Pointer to PDEVICE
    dwRop3  Rop3 value
Return Value:

    FALSE if the intersected rectangle is empty
    TRUE otherwise

--*/

{
    ASSERT(VALID_PDEV(pPDev));

    pPDev->dwRop3 = dwRop3;

}

VOID
VUnloadFreeBinaryData(
    IN  PDEV        *pPDev
)
/*++

Routine Description:

    This function frees the binary data

Arguments:

    pPDev - Pointer to PDEV

Return Value:

    None

Note:


--*/
{
    INT iCmd;

    //
    // Call parser to free memory allocated for binary data
    //

    if (pPDev->pRawData)
        UnloadRawBinaryData(pPDev->pRawData);

    if (pPDev->pInfoHeader)
        FreeBinaryData(pPDev->pInfoHeader);

    pPDev->pRawData = NULL;
    pPDev->pInfoHeader = NULL;
    pPDev->pUIInfo = NULL;
    //
    // pPDev->pUIInfo is reset so update the winresdata pUIInfo also.
    //
    pPDev->WinResData.pUIInfo = NULL;

    pPDev->pDriverInfo = NULL;
    pPDev->pGlobals = NULL;

    for (iCmd = 0; iCmd < CMD_MAX; iCmd++)
    {
        pPDev->arCmdTable[iCmd] =  NULL;
    }

    pPDev->pOrientation =  NULL;
    pPDev->pResolution =   NULL;
    pPDev->pResolutionEx = NULL;
    pPDev->pColorMode =    NULL;
    pPDev->pColorModeEx =  NULL;
    pPDev->pDuplex =       NULL;
    pPDev->pPageSize =     NULL;
    pPDev->pPageSizeEx =   NULL;
    pPDev->pInputSlot =    NULL;
    pPDev->pMemOption =    NULL;
    pPDev->pHalftone =     NULL;
    pPDev->pPageProtect =  NULL;

}

BOOL
BReloadBinaryData(
    IN  PDEV        *pPDev
)
/*++

Routine Description:

    This function reloads the binary data and reinitializes the
    offsets and pointers for access to snapshot data

Arguments:

    pPDev - Pointer to PDEV

Return Value:

    Returns TRUE if successful, otherwise FALSE

Note:


--*/
{
    //
    // Reloads binary data and reinit data pointers
    //

    if (! (pPDev->pRawData = LoadRawBinaryData(pPDev->pDriverInfo3->pDataFile)) ||
        ! (pPDev->pInfoHeader = InitBinaryData(pPDev->pRawData, NULL, pPDev->pOptionsArray)) ||
        ! (pPDev->pDriverInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loDriverOffset)) ||
        ! (pPDev->pUIInfo = OFFSET_TO_POINTER(pPDev->pInfoHeader, pPDev->pInfoHeader->loUIInfoOffset)) ||
        ! (pPDev->pGlobals = &(pPDev->pDriverInfo->Globals)) )
            return FALSE;

    //
    // pPDev->pUIInfo is reset so update the winresdata pUIInfo also.
    //
    pPDev->WinResData.pUIInfo = pPDev->pUIInfo;

    //
    // Rebuilds the command table
    //

    if (BInitCmdTable(pPDev) == FALSE)
        return FALSE;

    //
    // Rebuilds all the options pointers in PDEV
    //

    if (BInitOptions(pPDev) == FALSE)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\escape.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    escape.c

Abstract:

    Implementation of escape related DDI entry points:
        DrvEscape

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "unidrv.h"

// define DPRECT if you want to enable DRAWPATTERNRECT escape feature
#define DPRECT

typedef struct _POINTS {
    short   x;
    short   y;
} POINTs;

typedef struct _SHORTDRAWPATRECT {      // use 16-bit POINT structure
        POINTs ptPosition;
        POINTs ptSize;
        WORD   wStyle;
        WORD   wPattern;
} SHORTDRAWPATRECT, *PSHORTDRAWPATRECT;


ULONG
DrvEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID      *pvIn,
    ULONG       cjOut,
    PVOID      *pvOut
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEscape.
    Please refer to DDK documentation for more details.

Arguments:

    pso     - Describes the surface the call is directed to
    iEsc    - Specifies a query
    cjIn    - Specifies the size in bytes of the buffer pointed to by pvIn
    pvIn    - Points to input data buffer
    cjOut   - Specifies the size in bytes of the buffer pointed to by pvOut
    pvOut   -  Points to the output buffer

Return Value:

    Depends on the query specified by iEsc parameter

--*/

{

#define pbIn     ((BYTE *)pvIn)
#define pdwIn    ((DWORD *)pvIn)
#define pdwOut   ((DWORD *)pvOut)

    PDEV    *pPDev;
    ULONG   ulRes = 0;

    VERBOSE(("Entering DrvEscape: iEsc = %d...\n", iEsc));
    ASSERT(pso);

    pPDev = (PDEV *) pso->dhpdev;

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMEscape,
                    PFN_OEMEscape,
                    ULONG,
                    (pso,
                     iEsc,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMEscape,
                    VMEscape,
                    ULONG,
                    (pso,
                     iEsc,
                     cjIn,
                     pvIn,
                     cjOut,
                     pvOut));

    switch( iEsc )
    {
    case  QUERYESCSUPPORT:

        //
        // Check if the specified escape code is supported
        //

        if (pvIn != NULL || cjIn >= sizeof(DWORD))
        {
            switch( *pdwIn )
            {

            case  QUERYESCSUPPORT:
            case  PASSTHROUGH:
                //
                // Always support these escapes
                //

                ulRes = 1;
                break;

            case  SETCOPYCOUNT:
                ulRes = pPDev->dwMaxCopies > 1;
                break;

#ifndef WINNT_40    // NT5
            case DRAWPATTERNRECT:
                if ((pPDev->fMode & PF_RECT_FILL) &&
                    (pPDev->dwMinGrayFill < pPDev->dwMaxGrayFill) &&
                    (pPDev->pdmPrivate->iLayout == ONE_UP) &&
                    (!(pPDev->pdm->dmFields & DM_TTOPTION) ||
                     pPDev->pdm->dmTTOption != DMTT_BITMAP) &&
                    !(pPDev->fMode2 & PF2_MIRRORING_ENABLED) &&
                    !(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS)) // else, only black fill
                {
                    if (pPDev->fMode & PF_RECTWHITE_FILL)
                        ulRes = 2;
                    else
                        ulRes = 1;
                }
                break;
#endif // !WINNT_40
            }
        }
        break;


    case  PASSTHROUGH:
        //
        // QFE fix: NT4 TTY driver compatibility.
        // There is an application that sends FF by itself.
        // We don't want to send Form Feed if application calls DrvEscape.
        //
        if (pPDev->bTTY)
        {
            pPDev->fMode2 |= PF2_PASSTHROUGH_CALLED_FOR_TTY;
        }

        if( pvIn == NULL || cjIn < sizeof(WORD) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            ERR(("DrvEscape(PASSTHROUGH): Bad input parameters\n"));
        }
        else
        {

            //
            //  Win 3.1 actually uses the first 2 bytes as a count of the
            //  number of bytes following!!!!  So, the following union
            //  allows us to copy the data to an aligned field that
            //  we use.  And thus we ignore cjIn!
            //

            union
            {
                WORD   wCount;
                BYTE   bCount[ 2 ];
            } u;

            u.bCount[ 0 ] = pbIn[ 0 ];
            u.bCount[ 1 ] = pbIn[ 1 ];

            if( u.wCount && cjIn >= (ULONG)(u.wCount + sizeof(WORD)) )
            {

                ulRes = WriteSpoolBuf( pPDev, pbIn + 2, u.wCount );
            }
            else
            {
                SetLastError( ERROR_INVALID_DATA );
                ERR(("DrvEscape: Bad data in PASSTRHOUGH.\n"));
            }
        }
        break;


    case  SETCOPYCOUNT:

        if( pdwIn && *pdwIn > 0 )
        {
            pPDev->sCopies = (SHORT)*pdwIn;

            //
            // Check whether the copy count is in printer range
            //

            if( pPDev->sCopies > (SHORT)pPDev->dwMaxCopies )
                pPDev->sCopies = (SHORT)pPDev->dwMaxCopies;

            if( pdwOut )
                *pdwOut = pPDev->sCopies;

            ulRes = 1;
        }

        break;

    case DRAWPATTERNRECT:
    {
#ifndef WINNT_40
        typedef struct _DRAWPATRECTP {
            DRAWPATRECT DrawPatRect;
            XFORMOBJ *pXFormObj;
        } DRAWPATRECTP, *PDRAWPATRECTP;
        if (pvIn == NULL || (cjIn != sizeof(DRAWPATRECT) && cjIn != sizeof(DRAWPATRECTP)))
#else
        if( pvIn == NULL || cjIn != sizeof(DRAWPATRECT))
#endif
        {
            if (pvIn && cjIn == sizeof(SHORTDRAWPATRECT)) // check for Win3.1 DRAWPATRECT size
            {
                DRAWPATRECT dpr;
                PSHORTDRAWPATRECT   psdpr = (PSHORTDRAWPATRECT)pvIn;

                if (pPDev->fMode & PF_ENUM_GRXTXT)
                {
                    //
                    // Some apps (Access 2.0, AmiPro 3.1, etc.) do use the 16-bit
                    // POINT version of DRAWPATRECT structure. Have to be compatible
                    // with these apps.
                    //
                    dpr.ptPosition.x = (LONG)psdpr->ptPosition.x;
                    dpr.ptPosition.y = (LONG)psdpr->ptPosition.y;
                    dpr.ptSize.x = (LONG)psdpr->ptSize.x;
                    dpr.ptSize.y = (LONG)psdpr->ptSize.y;
                    dpr.wStyle  = psdpr->wStyle;
                    dpr.wPattern = psdpr->wPattern;

                    ulRes = DrawPatternRect(pPDev, &dpr);
                }
            }
            else
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                ERR(("DrvEscape(DRAWPATTERNRECT): Bad input parameters.\n"));
            }
        }
        else if (pPDev->fMode & PF_ENUM_GRXTXT)
        {
            DRAWPATRECT dpr = *(PDRAWPATRECT)pvIn;
#ifndef WINNT_40     // NT 5.0
            if (pPDev->pdmPrivate->iLayout != ONE_UP && cjIn == sizeof(DRAWPATRECTP))
            {
                XFORMOBJ *pXFormObj = ((PDRAWPATRECTP)pvIn)->pXFormObj;
                POINTL PTOut[2],PTIn[2];
                PTIn[0].x = dpr.ptPosition.x + pPDev->rcClipRgn.left;
                PTIn[0].y = dpr.ptPosition.y + pPDev->rcClipRgn.top;
                PTIn[1].x = PTIn[0].x + dpr.ptSize.x;
                PTIn[1].y = PTIn[0].y + dpr.ptSize.y;
                if (!XFORMOBJ_bApplyXform(pXFormObj,
                                      XF_LTOL,
                                      2,
                                      PTIn,
                                      PTOut))
                {
                    ERR (("DrvEscape(DRAWPATTERNRECT): XFORMOBJ_bApplyXform failed.\n"));
                    break;
                }
                dpr.ptPosition.x = PTOut[0].x;
                dpr.ptSize.x = PTOut[1].x - PTOut[0].x;
                if (dpr.ptSize.x < 0)
                {
                    dpr.ptPosition.x += dpr.ptSize.x;
                    dpr.ptSize.x = -dpr.ptSize.x;
                }
                else if (dpr.ptSize.x == 0)
                    dpr.ptSize.x = 1;

                dpr.ptPosition.y = PTOut[0].y;
                dpr.ptSize.y = PTOut[1].y - PTOut[0].y;
                if (dpr.ptSize.y < 0)
                {
                    dpr.ptPosition.y += dpr.ptSize.y;
                    dpr.ptSize.y = -dpr.ptSize.y;
                }
                else if (dpr.ptSize.y == 0)
                    dpr.ptSize.y = 1;
            }
#endif  // !WINNT_40
            // Test whether to force minimum size = 2 pixels
            //
            if (pPDev->fMode & PF_SINGLEDOT_FILTER)
            {
                if (dpr.ptSize.y < 2)
                    dpr.ptSize.y = 2;
                if (dpr.ptSize.x < 2)
                    dpr.ptSize.x = 2;
            }
            ulRes = DrawPatternRect(pPDev, &dpr);
        }
        else
            ulRes = 1;      // no need for GDI to take any action
        break;  // case DRAWPATTERNRECT
    }
    default:
        SetLastError( ERROR_INVALID_FUNCTION );
        break;

    }

    return   ulRes;
}

ULONG
DrawPatternRect(
    PDEV *pPDev,
    PDRAWPATRECT pPatRect)
/*++
Routine Description:
    Implementation of DRAWPATTERNECT escape. Note that it is PCL-specific.

Arguments:
    pPDev    - the driver's PDEV
    pPatRect - the DRAWPATRECT structure from the app

Return Value:
    1 if successful. Otherwise, 0.
--*/
{
    WORD    wPattern, wStyle;
    RECTL    rcClip;
    COMMAND *pCmd;
    ULONG   ulRes = 0;

    if (!(pPDev->fMode & PF_RECT_FILL))
        return 0;

    wStyle = pPatRect->wStyle;
    if (!((wStyle+1) & 3))  // same as (wStyle < 0 || wStyle > 2)
        return 0;   // we support only solid fill

    // Reset the brush, before downloading rule unless we are going to use
    // a white rectangle command

    if (wStyle != 1)
        GSResetBrush(pPDev);

    //
    // clip to printable region
    //
    rcClip.left = MAX(0, pPatRect->ptPosition.x);
    rcClip.top = MAX(0, pPatRect->ptPosition.y);
    rcClip.right = MIN(pPDev->szBand.cx,
                       pPatRect->ptPosition.x + pPatRect->ptSize.x);
    rcClip.bottom = MIN(pPDev->szBand.cy,
                        pPatRect->ptPosition.y + pPatRect->ptSize.y);
    //
    // check if we end up with an empty rect. If not, put down the rule.
    //
    if (rcClip.right > rcClip.left && rcClip.bottom > rcClip.top)
    {
        DWORD dwXSize,dwYSize;
        //
        //  Move to the starting position. rcClip is in device units to
        //  which we must add the offset of the band origin
        //
        XMoveTo(pPDev, rcClip.left+pPDev->rcClipRgn.left, MV_GRAPHICS);
        YMoveTo(pPDev, rcClip.top+pPDev->rcClipRgn.top, MV_GRAPHICS);

        //
        //  The RectFill commands expect master units.
        //
        dwXSize = pPDev->dwRectXSize;
        pPDev->dwRectXSize = (rcClip.right - rcClip.left) * pPDev->ptGrxScale.x;
        dwYSize = pPDev->dwRectYSize;
        pPDev->dwRectYSize = (rcClip.bottom - rcClip.top) * pPDev->ptGrxScale.y;

        //
        // check whether the rectangle size is different and update if necessary
        //
        if (dwXSize != pPDev->dwRectXSize ||
            (!(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)) &&
            !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL))))
        {
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTWIDTH));
        }
        if (dwYSize != pPDev->dwRectYSize ||
            (!(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)) &&
            !(COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL))))
        {
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SETRECTHEIGHT));
        }
        //
        // range-check the pattern based upon the kind of rule.
        //
        switch (wStyle)
        {
        case 0:
            //
            // black fill, which is max gray fill unless CmdRectBlackFill exists
            //
            if (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL))
                WriteChannel(pPDev, pCmd);
            else
            {
                pPDev->dwGrayPercentage = pPDev->dwMaxGrayFill;
                WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL));
            }
            ulRes = 1;
            break;

        case 1:
            //
            // White (erase) fill
            //
            if (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL))
            {
                WriteChannel(pPDev, pCmd);
                ulRes = 1;
            }
            break;

        case 2:
            //
            // Shaded gray fill.
            //
            // If 100% black use black rectangle fill anyway
            //
            if (pPatRect->wPattern == 100 &&
                    (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTBLACKFILL)))
            {
                WriteChannel(pPDev, pCmd);
            }
            // If 0% black use white rectangle fill
            //
            else if (pPatRect->wPattern == 0 &&
                    (pCmd = COMMANDPTR(pPDev->pDriverInfo,CMD_RECTWHITEFILL)))
            {
                WriteChannel(pPDev, pCmd);
            }
            //
            // Check for the gray range.
            //
            else
            {
                if ((wPattern = pPatRect->wPattern) < (WORD)pPDev->dwMinGrayFill)
                    wPattern = (WORD)pPDev->dwMinGrayFill;
                if (wPattern > (WORD)pPDev->dwMaxGrayFill)
                    wPattern = (WORD)pPDev->dwMaxGrayFill;
                pPDev->dwGrayPercentage = (DWORD)wPattern;
                WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_RECTGRAYFILL));
            }
            ulRes = 1;
            break;
        }

        //
        // update internal coordinates, if necessary. BUG_BUG, do we really need cx/cyafterfill in PDEV?
        //
        if (ulRes == 1)
        {
            if (pPDev->cxafterfill == CXARF_AT_RECT_X_END)
                XMoveTo(pPDev, pPatRect->ptSize.x,
                               MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);

            if (pPDev->cyafterfill == CYARF_AT_RECT_Y_END)
                YMoveTo(pPDev, pPatRect->ptSize.y,
                               MV_GRAPHICS | MV_UPDATE | MV_RELATIVE);
            if (wStyle != 1)
            {
                INT i;
                BYTE ubMask = BGetMask(pPDev,&rcClip);
                for (i = rcClip.top;i < rcClip.bottom;i++)
                    pPDev->pbScanBuf[i] |= ubMask;
            }
        }
    } // if (!IsRectEmpty(&rcClip))

    return ulRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\init.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Unidrv intialization related function header file

Environment:

    Windows NT Unidrv driver

Revision History:

    10/21/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _INIT_H_
#define _INIT_H_

#define MICRON_TO_PIXEL(micron, dpi) MulDiv(micron, dpi, 25400)
#define MICRON_TO_MASTER(size_in_micron, MU) MulDiv(size_in_micron, MU, 25400)
#define MASTER_TO_MICRON(size_in_master, MU) MulDiv(size_in_master, 25400, MU)

BOOL
BInitPDEV (
    PDEV        *pPDev,
    RECTL       *prcFormImageArea
    );


BOOL
BInitGdiInfo(
    PDEV    *pPDev,
    ULONG   *pGdiInfoBuffer,
    ULONG   ulBufferSize
    );

BOOL
BInitDevInfo(
    PDEV        *pPDev,
    DEVINFO     *pDevInfoBuffer,
    ULONG       ulBufferSize
    );

BOOL
BMergeAndValidateDevmode(
    PDEV        *pPDev,
    PDEVMODE    pdmInput,
    PRECTL      prcFormImageArea
    );

BOOL
BInitPalDevInfo(
    PDEV *pPDev,
    DEVINFO *pdevinfo,
    GDIINFO *pGDIInfo
    );

VOID
VLoadPal(
    PDEV   *pPDev
    );

VOID VInitPal8BPPMaskMode(
    PDEV   *pPDev,
    GDIINFO *pGDIInfo
    );

BOOL
BReloadBinaryData(
    PDEV   *pPDev
    );

VOID
VUnloadFreeBinaryData(
    PDEV   *pPDev
    );

#endif  // !_INIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\intfuni.cxx ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    intfuni.cpp

Abstract:

    Interface implementation of Windows NT unidriver OEM rendering plugins

Environment:

    Windows NT Unidriver.

Revision History:

    01/18/98 -ganeshp-
        Initial framework.

--*/

#define INITGUID
#include    "unidrv.h"

#ifdef WINNT_40


#include "cppfunc.h"
#undef InterlockedIncrement
#undef InterlockedDecrement

#define InterlockedIncrement(x) DrvInterlockedIncrement(x)
#define InterlockedDecrement(x) DrvInterlockedDecrement(x)

int __cdecl _purecall (void)
{
    return FALSE;
}
#endif // WINNT_40


#pragma     hdrstop("unidrv.h")
#include    "prcomoem.h"

//
// List all of the supported OEM plugin interface IIDs from the
// latest to the oldest, that's the order our driver will QI OEM
// plugin for its supported interface.
//
// DON"T remove the last NULL terminator.
//

static const GUID *PrintOemUni_IIDs[] = {
    &IID_IPrintOemUni2,
    &IID_IPrintOemUni,
    NULL
};

//
// Component
//

class CPrintOemDriver : public IPrintOemDriverUni
{
    //
    // IUnknown implementation
    //

    STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Interface IPrintOemDriverUni implementation
    //

    STDMETHODIMP DrvGetDriverSetting(PVOID   pdriverobj,
                                     PCSTR   Feature,
                                     PVOID   pOutput,
                                     DWORD   cbSize,
                                     PDWORD  pcbNeeded,
                                     PDWORD  pdwOptionsReturned);

    STDMETHODIMP DrvWriteSpoolBuf(PDEVOBJ     pdevobj,
                                  PVOID       pBuffer,
                                  DWORD       cbSize,
                                  OUT DWORD   *pdwResult);

    //
    // Cursor movement helper functions.
    //

    STDMETHODIMP DrvXMoveTo(PDEVOBJ    pdevobj,
                            INT        x,
                            DWORD      dwFlags,
                            OUT INT    *piResult);

    STDMETHODIMP DrvYMoveTo(PDEVOBJ    pdevobj,
                            INT        y,
                            DWORD      dwFlags,
                            OUT INT    *piResult);

    //
    // Unidrv specific. To get the standard variable value.
    //

    STDMETHODIMP DrvGetStandardVariable(PDEVOBJ     pdevobj,
                                        DWORD       dwIndex,
                                        PVOID       pBuffer,
                                        DWORD       cbSize,
                                        PDWORD      pcbNeeded);

    //
    // Unidrv specific.  To Provide OEM plugins access to GPD data.
    //

    STDMETHODIMP DrvGetGPDData(PDEVOBJ     pdevobj,
    DWORD       dwType,     // Type of the data
    PVOID       pInputData, // reserved. Should be set to 0
    PVOID       pBuffer,    // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    );

    //
    // Unidrv specific. To do the TextOut.
    //

    STDMETHODIMP DrvUniTextOut(SURFOBJ    *pso,
                               STROBJ     *pstro,
                               FONTOBJ    *pfo,
                               CLIPOBJ    *pco,
                               RECTL      *prclExtra,
                               RECTL      *prclOpaque,
                               BRUSHOBJ   *pboFore,
                               BRUSHOBJ   *pboOpaque,
                               POINTL     *pptlBrushOrg,
                               MIX         mix);

    STDMETHODIMP DrvWriteAbortBuf(PDEVOBJ     pdevobj,
                                  PVOID       pBuffer,
                                  DWORD       cbSize,
                                  DWORD       dwWait);

public:

    //
    // Constructor
    //

    CPrintOemDriver() : m_cRef(0) {}

private:

    long m_cRef;

};


STDMETHODIMP CPrintOemDriver::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPrintOemDriverUni)
    {
        *ppv = static_cast<IPrintOemDriverUni *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPrintOemDriver::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPrintOemDriver::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CPrintOemDriver::DrvGetDriverSetting(PVOID   pdriverobj,
                                                  PCSTR   Feature,
                                                  PVOID   pOutput,
                                                  DWORD   cbSize,
                                                  PDWORD  pcbNeeded,
                                                  PDWORD  pdwOptionsReturned)
{
    if (BGetDriverSettingForOEM((PDEV *)pdriverobj,
                                Feature,
                                pOutput,
                                cbSize,
                                pcbNeeded,
                                pdwOptionsReturned))
        return S_OK;

    return E_FAIL;
}

STDMETHODIMP CPrintOemDriver::DrvWriteSpoolBuf(PDEVOBJ     pdevobj,
                                               PVOID       pBuffer,
                                               DWORD       cbSize,
                                               OUT DWORD   *pdwResult)
{
    DWORD dwI;
    POEM_PLUGIN_ENTRY pOemEntry;

    //
    // OEM plug-ins may not call back to DrvWriteSpoolBuf during the
    // WritePrinter hook.
    //
    if (((PDEV*)pdevobj)->fMode2 & PF2_CALLING_OEM_WRITE_PRINTER)
        return E_FAIL;

    if (*pdwResult = WriteSpoolBuf((PDEV *)pdevobj, (PBYTE)pBuffer, cbSize))
    {
        return S_OK;
    }

    *pdwResult = 0;

    return E_FAIL;
}


STDMETHODIMP CPrintOemDriver::DrvWriteAbortBuf(PDEVOBJ     pdevobj,
                                               PVOID       pBuffer,
                                               DWORD       cbSize,
                                               DWORD       dwWait)
{
    DWORD dwI;
    POEM_PLUGIN_ENTRY pOemEntry;

    //
    // OEM Plug-ins may not call back to DrvWriteAbortBuf during the
    // WritePrinter hook.
    //
    if (((PDEV*)pdevobj)->fMode2 & PF2_CALLING_OEM_WRITE_PRINTER)
        return E_FAIL;

    WriteAbortBuf((PDEV *)pdevobj, (PBYTE)pBuffer, cbSize, dwWait) ;
    return S_OK;    // no failure condition
}

//
// Cursor movement helper functions.
//
STDMETHODIMP CPrintOemDriver::DrvXMoveTo(PDEVOBJ     pdevobj,
                                         INT         x,
                                         DWORD       dwFlags,
                                         OUT INT     *piResult)
{
    *piResult = XMoveTo((PDEV *)pdevobj, x, dwFlags);

    return S_OK;

}

STDMETHODIMP CPrintOemDriver::DrvYMoveTo(PDEVOBJ     pdevobj,
                                         INT         y,
                                         DWORD       dwFlags,
                                         OUT INT     *piResult)
{
    *piResult = YMoveTo((PDEV *)pdevobj, y, dwFlags);

    return S_OK;

}

//
// Unidrv specific. To get the standard variable value.
//

STDMETHODIMP CPrintOemDriver::DrvGetStandardVariable(PDEVOBJ     pdevobj,
                                                     DWORD       dwIndex,
                                                     PVOID       pBuffer,
                                                     DWORD       cbSize,
                                                     PDWORD      pcbNeeded)
{
    if (BGetStandardVariable((PDEV *)pdevobj, dwIndex, pBuffer,
                             cbSize, pcbNeeded))
        return S_OK;

    return E_FAIL;
}

//
// Unidrv specific.  To Provide OEM plugins access to GPD data.
//

STDMETHODIMP CPrintOemDriver::DrvGetGPDData(PDEVOBJ     pdevobj,
    DWORD       dwType,     // Type of the data
    PVOID       pInputData, // reserved. Should be set to 0
    PVOID       pBuffer,    // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    )

{
    if (BGetGPDData((PDEV *)pdevobj,     dwType,
                    pInputData,    pBuffer,    cbSize,  pcbNeeded  ))
        return S_OK;

    return E_FAIL;
}

//
// Unidrv specific. To do the TextOut.
//

STDMETHODIMP CPrintOemDriver::DrvUniTextOut(SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlBrushOrg,
                                            MIX         mix)
{

    if (FMTextOut(pso, pstro, pfo,pco, prclExtra, prclOpaque,
                  pboFore, pboOpaque, pptlBrushOrg, mix))
    {
        return S_OK;

    }

    return E_FAIL;
}

//
// Creation function
//

extern "C" IUnknown* DriverCreateInstance()
{
    IUnknown* pI = static_cast<IPrintOemDriverUni *>(new CPrintOemDriver);

    if (pI != NULL)
        pI->AddRef();

    return pI;
}

extern "C"   HRESULT  HDriver_CoCreateInstance(
    IN REFCLSID     rclsid,
    IN LPUNKNOWN    pUnknownOuter,
    IN DWORD        dwClsContext,
    IN REFIID       riid,
    IN LPVOID       *ppv,
    IN HANDLE       hInstance
    );

//
// Get OEM plugin interface and publish driver helper interface
//

extern "C" BOOL BGetOemInterface(POEM_PLUGIN_ENTRY   pOemEntry)
{
    IUnknown  *pIDriverHelper = NULL;
    HRESULT   hr;

    //
    // QI to retrieve the latest interface OEM plugin supports
    //

    if (!BQILatestOemInterface(pOemEntry->hInstance,
                               CLSID_OEMRENDER,
                               PrintOemUni_IIDs,
                               &(pOemEntry->pIntfOem),
                               &(pOemEntry->iidIntfOem)))
    {
        ERR(("BQILatestOemInterface failed\n"));
        return FALSE;
    }

    //
    // If QI succeeded, pOemEntry->pIntfOem will have the OEM plugin
    // interface pointer with ref count 1.
    //

    //
    // Publish driver's helper function interface
    //

    if ((pIDriverHelper = DriverCreateInstance()) == NULL)
    {
        ERR(("DriverCreateInstance failed\n"));
        goto fail_cleanup;
    }

    //
    // As long as we define new OEM plugin interface by inheriting old ones,
    // we can always cast pIntfOem into pointer of the oldest plugin interface
    // (the base class) and call PublishDriverInterface method.
    //
    // Otherwise, this code needs to be modified when new interface is added.
    //

    hr = ((IPrintOemUni *)(pOemEntry->pIntfOem))->PublishDriverInterface(pIDriverHelper);

    //
    // OEM plugin should do QI in their PublishDriverInterface, so we need to release
    // our ref count of pIDriverHelper.
    //

    pIDriverHelper->Release();

    if (FAILED(hr))
    {
        ERR(("PublishDriverInterface failed\n"));
        goto fail_cleanup;
    }

    return TRUE;

    fail_cleanup:

    //
    // If failed, we need to release the ref count we hold on pOemEntry->pIntfOem,
    // and set pIntfOem to NULL to indicate no COM interface is available.
    //

    ((IUnknown *)(pOemEntry->pIntfOem))->Release();
    pOemEntry->pIntfOem = NULL;

    return FALSE;
}

//
// CALL_INTRFACE macros
//
#define CALL_INTRFACE(MethodName, pOemEntry, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUni)) \
    { \
        return ((IPrintOemUni *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    else if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUni2)) \
    { \
        return ((IPrintOemUni2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

#define CALL_INTRFACE2(MethodName, pOemEntry, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUni2)) \
    { \
        return ((IPrintOemUni2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

//  add additional  else if (IsEqualGUID(&pOemEntry->iidIntfOem, &IID_IPrintOemUni2))\
//   sections as needed as more interfaces are defined to   CALL_INTRFACE macro.

extern "C" HRESULT HComOEMGetInfo(POEM_PLUGIN_ENTRY   pOemEntry,
                                  DWORD  dwMode,
                                  PVOID  pBuffer,
                                  DWORD  cbSize,
                                  PDWORD pcbNeeded)
{
    CALL_INTRFACE(GetInfo, pOemEntry, (dwMode, pBuffer, cbSize, pcbNeeded));
}

extern "C" HRESULT HComOEMDevMode(POEM_PLUGIN_ENTRY   pOemEntry,
                                  DWORD               dwMode,
                                  POEMDMPARAM         pOemDMParam)
{
    CALL_INTRFACE(DevMode, pOemEntry, (dwMode, pOemDMParam));
}

extern "C" HRESULT HComOEMEnableDriver(POEM_PLUGIN_ENTRY   pOemEntry,
                                       DWORD               DriverVersion,
                                       DWORD               cbSize,
                                       PDRVENABLEDATA      pded)
{
    CALL_INTRFACE(EnableDriver, pOemEntry, (DriverVersion, cbSize, pded));
}

extern "C" HRESULT HComOEMDisableDriver(POEM_PLUGIN_ENTRY   pOemEntry)
{
    CALL_INTRFACE(DisableDriver, pOemEntry, ());
}

extern "C" HRESULT HComOEMEnablePDEV(POEM_PLUGIN_ENTRY pOemEntry,
                                     PDEVOBJ           pdevobj,
                                     PWSTR             pPrinterName,
                                     ULONG             cPatterns,
                                     HSURF            *phsurfPatterns,
                                     ULONG             cjGdiInfo,
                                     GDIINFO          *pGdiInfo,
                                     ULONG             cjDevInfo,
                                     DEVINFO          *pDevInfo,
                                     DRVENABLEDATA    *pded,
                                     PDEVOEM          *pDevOem)
{
    CALL_INTRFACE(EnablePDEV, pOemEntry, (pdevobj,
                                          pPrinterName,
                                          cPatterns,
                                          phsurfPatterns,
                                          cjGdiInfo,
                                          pGdiInfo,
                                          cjDevInfo,
                                          pDevInfo,
                                          pded,
                                          pDevOem));
}

extern "C" HRESULT HComOEMDisablePDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj
    )
{
    CALL_INTRFACE(DisablePDEV, pOemEntry, (pdevobj));
}

extern "C" HRESULT HComOEMResetPDEV(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobjOld,
    PDEVOBJ               pdevobjNew
    )
{
    CALL_INTRFACE(ResetPDEV, pOemEntry, (pdevobjOld, pdevobjNew));
}


extern "C" HRESULT HComGetImplementedMethod(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PSTR                  pMethodName
    )
{
    CALL_INTRFACE(GetImplementedMethod, pOemEntry, (pMethodName));
}

//
// OEMDriverDMS - UNIDRV only,
//

extern "C" HRESULT HComDriverDMS(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PVOID                 pDevObj,
    PVOID                 pBuffer,
    WORD                  cbSize,
    PDWORD                pcbNeeded
    )
{
    CALL_INTRFACE(DriverDMS, pOemEntry, (pDevObj, pBuffer, cbSize, pcbNeeded));
}


//
// OEMCommandCallback - UNIDRV only,
//

extern "C" HRESULT HComCommandCallback(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    DWORD                 dwCallbackID,
    DWORD                 dwCount,
    PDWORD                pdwParams,
    OUT INT               *piResult
    )
{
    CALL_INTRFACE(CommandCallback, pOemEntry, (pdevobj,
                                               dwCallbackID, 
                                               dwCount,
                                               pdwParams,
                                               piResult));
}


//
// OEMImageProcessing - UNIDRV only,
//

extern "C" HRESULT HComImageProcessing(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pSrcBitmap,
    PBITMAPINFOHEADER       pBitmapInfoHeader,
    PBYTE                   pColorTable,
    DWORD                   dwCallbackID,
    PIPPARAMS               pIPParams,
    OUT PBYTE               *ppbResult
    )
{
    CALL_INTRFACE(ImageProcessing, pOemEntry,
                  (pdevobj,
                   pSrcBitmap,
                   pBitmapInfoHeader,
                   pColorTable,
                   dwCallbackID,
                   pIPParams,
                   ppbResult));


}

//
// OEMFilterGraphics - UNIDRV only,
//

extern "C" HRESULT HComFilterGraphics(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pBuf,
    DWORD                   dwLen
    )
{
    CALL_INTRFACE(FilterGraphics, pOemEntry,
                  (pdevobj,
                   pBuf,
                   dwLen));

}

//
// OEMCompression - UNIDRV only,
//

extern "C" HRESULT HComCompression(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pInBuf,
    PBYTE                   pOutBuf,
    DWORD                   dwInLen,
    DWORD                   dwOutLen,
    OUT INT                 *piResult
    )
{
    CALL_INTRFACE(Compression, pOemEntry,
                  (pdevobj,
                   pInBuf,
                   pOutBuf,
                   dwInLen,
                   dwOutLen,
                   piResult));

}


//
// OEMHalftone - UNIDRV only
//

extern "C" HRESULT HComHalftonePattern(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pHTPattern,
    DWORD                   dwHTPatternX,
    DWORD                   dwHTPatternY,
    DWORD                   dwHTNumPatterns,
    DWORD                   dwCallbackID,
    PBYTE                   pResource,
    DWORD                   dwResourceSize
    )
{
    CALL_INTRFACE(HalftonePattern, pOemEntry,
                  (pdevobj,
                   pHTPattern,
                   dwHTPatternX,
                   dwHTPatternY,
                   dwHTNumPatterns,
                   dwCallbackID,
                   pResource,
                   dwResourceSize));

}


//
// OEMMemoryUsage - UNIDRV only,
//

extern "C" HRESULT HComMemoryUsage(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    POEMMEMORYUSAGE         pMemoryUsage
    )
{
    CALL_INTRFACE(MemoryUsage, pOemEntry,
                  (pdevobj,
                   pMemoryUsage));

}

//
// OEMTTYGetInfo - UNIDRV only
//

extern "C" HRESULT HComTTYGetInfo(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    DWORD                   dwInfoIndex,
    PVOID                   pOutputBuf,
    DWORD                   dwSize,
    DWORD                   *pcbcNeeded
    )
{
    CALL_INTRFACE(TTYGetInfo, pOemEntry,
                  (pdevobj,
                   dwInfoIndex,
                   pOutputBuf,
                   dwSize,
                   pcbcNeeded));

}


//
// OEMDownloadFontheader - UNIDRV only
//

extern "C" HRESULT HComDownloadFontHeader(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    )
{
    CALL_INTRFACE(DownloadFontHeader, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   pdwResult));

}

//
// OEMDownloadCharGlyph - UNIDRV only
//

extern "C" HRESULT HComDownloadCharGlyph(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    HGLYPH                  hGlyph,
    PDWORD                  pdwWidth,
    OUT DWORD               *pdwResult
    )
{
    CALL_INTRFACE(DownloadCharGlyph, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   hGlyph,
                   pdwWidth,
                   pdwResult));

}


//
// OEMTTDownloadMethod - UNIDRV only
//

extern "C"HRESULT HComTTDownloadMethod(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    )
{
    CALL_INTRFACE(TTDownloadMethod, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   pdwResult));

}

//
// OEMOutputCharStr - UNIDRV only
//

extern "C" HRESULT HComOutputCharStr(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    DWORD                   dwType,
    DWORD                   dwCount,
    PVOID                   pGlyph
    )
{
    CALL_INTRFACE(OutputCharStr, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   dwType,
                   dwCount,
                   pGlyph));

}


//
// OEMSendFontCmd - UNIDRV only
//


extern "C" HRESULT HComSendFontCmd(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    PFINVOCATION            pFInv
    )
{
    CALL_INTRFACE(SendFontCmd, pOemEntry,
                  (pdevobj,
                   pUFObj,
                   pFInv));

}

//
// OEMTextOutAsBitmap - UNIDRV only
//

HRESULT HComTextOutAsBitmap(
    POEM_PLUGIN_ENTRY       pOemEntry,
    SURFOBJ                 *pso,
    STROBJ                  *pstro,
    FONTOBJ                 *pfo,
    CLIPOBJ                 *pco,
    RECTL                   *prclExtra,
    RECTL                   *prclOpaque,
    BRUSHOBJ                *pboFore,
    BRUSHOBJ                *pboOpaque,
    POINTL                  *pptlOrg,
    MIX                     mix
    )
{
    CALL_INTRFACE(TextOutAsBitmap, pOemEntry,
                  (pso,
                   pstro,
                   pfo,
                   pco,
                   prclExtra,
                   prclOpaque,
                   pboFore,
                   pboOpaque,
                   pptlOrg,
                   mix
                   ));

}

extern "C" HRESULT HComWritePrinter(POEM_PLUGIN_ENTRY pOemEntry,
                                    PDEVOBJ           pdevobj,
                                    PVOID             pBuf,
                                    DWORD             cbBuffer,
                                    PDWORD            pcbWritten)
{
    CALL_INTRFACE2(WritePrinter, pOemEntry,
                   (pdevobj,
                    pBuf,
                    cbBuffer,
                    pcbWritten));
}

extern "C" ULONG ReleaseOemInterface(POEM_PLUGIN_ENTRY   pOemEntry)
{


#ifdef WINNT_40

    HRESULT hr;

    if (IsEqualGUID(&pOemEntry->iidIntfOem, &IID_IPrintOemUni)) \
    {
        hr = ((IPrintOemUni *)(pOemEntry)->pIntfOem)->Release();
    }

#else // WINNT_40

    CALL_INTRFACE(Release, pOemEntry,
                    ());

#endif  // WINNT_40

    return 0;
}

#if CODE_COMPLETE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\physical.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    physical.h

Abstract:

    physical.c header file

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _PHYSICAL_H_
#define _PHYSICAL_H_


#define MAX_STACK_SIZE  100
#define CMDOFFSET_TO_PTR(pPDev, loOffset) \
        (pPDev->pDriverInfo->pubResourceData + loOffset)

typedef struct _CMDPARAM {
    DWORD           dwFormat;           // Specifies the format of the parameter
    DWORD           dwDigits;           // Specifies the number of digits to be
                                        // emmitted, this is only valid if the
                                        // format is "D" or "d" AND dwFlags has
                                        // PARAM_FLAG_FIELDWIDTH_USED
    DWORD           dwFlags;            // Flags for parameters, which action to carray out:
                                        // PARAM_FLAG_MIN_USED
                                        // PARAM_FLAG_MAX_USED
                                        // PARAM_FLAG_FIELDWIDTH_USED
    INT             iValue;             // Value calculated from arToken in PARAMETER struct

} CMDPARAM, * PCMDPARAM;


VOID
SendCmd(
    PDEV    *pPDev,
    COMMAND *pCmd,
    CMDPARAM *pParam
    );

INT
IProcessTokenStream(
    PDEV            *pPDev,
    ARRAYREF        *pToken ,
    PBOOL           pbMaxRepeat
    );

INT
FineXMoveTo(
    PDEV    *pPDev,
    INT     iX
    );

PPARAMETER
PGetParameter(
    PDEV    *pPDev,
    BYTE    *pInvocationStr
    );

#endif // _PHYSICAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\print.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Implementation of document and page related DDI entry points:
        DrvStartDoc
        DrvEndDoc
        DrvStartPage
        DrvSendPage
        DrvNextBand
        DrvStartBanding

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "unidrv.h"

//
// Forward declaration for local functions
//

VOID VEndPage ( PDEV *);
BOOL BEndDoc  ( PDEV *, SURFOBJ *, FLONG flags);
VOID VSendSequenceCmd(PDEV *, DWORD);


BOOL
DrvStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    pDocName - Specifies a Unicode document name
    jobId - Identifies the print job

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV *pPDev = (PDEV*)pso->dhpdev;

    VERBOSE(("Entering DrvStartDoc...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStartDoc,
                    PFN_OEMStartDoc,
                    BOOL,
                    (pso,
                     pDocName,
                     jobId));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStartDoc,
                    VMStartDoc,
                    BOOL,
                    (pso,
                     pDocName,
                     jobId));

    //
    // We might get a DrvResetPDEV before this and get another DrvStartDoc
    // without a DrvEndDoc so check for that condition and call BEndDoc
    // to clean up the previous instance before continuing.
    //

    if (pPDev->fMode & PF_DOC_SENT)
    {
        BEndDoc(pPDev, pso, 0);       // this flag also suppresses
                        // emission of EndDoc commands to the printer
                        // since they may cause a page ejection and
                        //  we are only interested in freeing memory and
                        //  performing pdev cleanup at this point.
        pPDev->fMode &= ~PF_DOC_SENT;
    }
    else
        pPDev->dwPageNumber = 1 ;  // first page of document


    //
    // Call Raster and Font module
    //

    if (!(((PRMPROCS)(pPDev->pRasterProcs))->RMStartDoc(pso, pDocName, jobId)) ||
        !(((PFMPROCS)(pPDev->pFontProcs))->FMStartDoc(pso, pDocName, jobId)) )
    {
        return FALSE;
    }

    //
    // Send JobSetup and DocSetup Sequence Cmds at DrvStartPage instead
    // of here since the driver can get a new DrvStartDoc after each
    // DrvResetPDEV
    //

    return  TRUE;

}

BOOL
DrvStartPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;
    PAL_DATA   *pPD = pPDev->pPalData;

    VERBOSE(("Entering DrvStartPage...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStartPage,
                    PFN_OEMStartPage,
                    BOOL,
                    (pso));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStartPage,
                    VMStartPage,
                    BOOL,
                    (pso));

    //
    // clear flags at start of page
    //
    pPDev->fMode &= ~(PF_SURFACE_USED | PF_SURFACE_ERASED);
    pPDev->fMode &= ~PF_DOWNLOADED_TEXT;

    //
    // only a bitmap surface driver needs to have a band
    //
    if (!DRIVER_DEVICEMANAGED (pPDev))
    {
        ZeroMemory(pPDev->pbScanBuf, pPDev->szBand.cy);
        ZeroMemory(pPDev->pbRasterScanBuf, (pPDev->szBand.cy / LINESPERBLOCK)+1);
#ifndef DISABLE_NEWRULES
        pPDev->dwRulesCount = 0;        
#endif
    }

    //
    // Send JobSetup, DocSetup cmd and Download the Palette if necessary.
    //


            if (!(pPDev->fMode & PF_JOB_SENT))
            {
                VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwJobSetupIndex);
                pPDev->fMode |= PF_JOB_SENT;
            }
            if (!(pPDev->fMode & PF_DOC_SENT))
            {
                VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwDocSetupIndex);
                pPDev->fMode |= PF_DOC_SENT;   // this flag is cleared
                                                                            //  by StartDoc
                //
                // PF_DOCSTARTED - Signify DrvStartDoc is called, for DrvResetPDEV
                //    this flag is cleared only at EndJob.

                pPDev->fMode |= PF_DOCSTARTED;

            }
            pPDev->fMode &= ~PF_SEND_ONLY_NOEJECT_CMDS ;

            if ( (pPD->fFlags & PDF_DL_PAL_EACH_DOC) &&
                 (!DRIVER_DEVICEMANAGED (pPDev)) )
            {
                VLoadPal(pPDev);
            }

    //
    // Set PF_ENUM_GRXTXT
    //

    pPDev->fMode |= PF_ENUM_GRXTXT;

    //
    // Call Raster and Font module.
    //

    if ( !( ((PRMPROCS)(pPDev->pRasterProcs))->RMStartPage(pso) ) ||
         !( ((PFMPROCS)(pPDev->pFontProcs))->FMStartPage(pso) ))
    {
        return FALSE;
    }

    //
    // BUG_BUG, should we check for PF_SEND_ONLY_NOEJECT_CMDS here?
    // Assumes that GPD writer does not put page ejection code
    // in PageSetup Cmds since we might get a ResetPDEV between pages.
    // This bit is set when we get DrvResetPDev where we are doing duplexing
    // and paper size and source, and orienation is the same.  Detecting this
    // condition allows us to skip page ejection cmds or any cmds that
    // could cause page ejection but if the GPD writer does not put page
    // ejection code in PageSetup cmd, we are OK.
    //   If pageSetup commands  caused pages to be ejected, we would
    //  always get one or more blank pages for every one that was printed.
    //  this is a needless concern.
    //

    // initialize the cursor position at the start of each page
    //
    pPDev->ctl.ptCursor.x = pPDev->ctl.ptCursor.y = 0;
    pPDev->ctl.dwMode |= MODE_CURSOR_UNINITIALIZED;    // both X & Y

    //
    // Send PageSetup sequence Cmds
    //

    VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwPageSetupIndex);


    //Download the Palette if necessary.
    if ( (pPD->fFlags & PDF_DL_PAL_EACH_PAGE) &&
         (!DRIVER_DEVICEMANAGED (pPDev)) )
    {
        VLoadPal(pPDev);
    }

    //
    // Set the current position to some illegal position, so that
    // we make no assumptions about where we are
    //

    //
    // Flush the spool buffer with the setup commands to give serial printers
    // a head start on loading paper and cleaning their jets.
    //
    if (pPDev->pGlobals->printertype == PT_SERIAL)
        FlushSpoolBuf (pPDev);

    return  TRUE;
}

BOOL
DrvSendPage(
    SURFOBJ *pso
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvSendPage.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    bRet = FALSE;
    PDEV *  pPDev = (PDEV *)pso->dhpdev;

    VERBOSE(("Entering DrvSendPage...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMSendPage,
                    PFN_OEMSendPage,
                    BOOL,
                    (pso));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMSendPage,
                    VMSendPage,
                    BOOL,
                    (pso));

    //Reset the brush, before calling render module.
    GSResetBrush(pPDev);

    switch( pso->iType )
    {

    case  STYPE_BITMAP:
        //
        // Engine managed bitmap
        //

        //
        // Call Raster and Font module
        //

        if ( !(((PRMPROCS)(pPDev->pRasterProcs))->RMSendPage(pso)) ||
             !(((PFMPROCS)(pPDev->pFontProcs))->FMSendPage(pso) ) )
        {
            return FALSE;
        }

        //
        // VEndPage should take care of sending PageFinish sequence Cmds
        //

        VEndPage( pPDev );

        bRet = TRUE;

        break;

    case STYPE_DEVICE:
        //
        // Device managed surface
        //

        VERBOSE(("DrvSendPage: pso->iType == STYPE_DEVICE \n" ));
        //
        // Call Raster and Font module if needed.
        //


        //
        // VEndPage should take care of sending PageFinish sequence Cmds
        //

        VEndPage( pPDev );

        bRet = TRUE;

        break;

    default:

        VERBOSE(("DrvSendPage: pso->iType is unknown \n"));
        break;

    }

    return  bRet;

}

BOOL
DrvEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvEndDoc.
    Please refer to DDK documentation for more details.

Arguments:

    pso - Defines the surface object
    flags - A set of flag bits

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;

    VERBOSE(("Entering DrvEndDoc...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // if we've detected an aborted job because WritePrinter has failed we will set the
    // ED_ABORTDOC flag for the OEM plugins since GDI only sets this for direct printing
    //
    if (pPDev->fMode & PF_ABORTED)
        flags |= ED_ABORTDOC;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMEndDoc,
                    PFN_OEMEndDoc,
                    BOOL,
                    (pso,
                     flags));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMEndDoc,
                    VMEndDoc,
                    BOOL,
                    (pso,
                     flags));

    pPDev->fMode &= ~PF_DOC_SENT;
    //  we are going to send the EndDoc commands to the printer.

    return ( BEndDoc(pPDev, pso, flags) );

}

BOOL
DrvNextBand(
        SURFOBJ *pso,
        POINTL *pptl
        )

/*++

Routine Description:

        Implementation of DDI entry point DrvNextBand.
        Please refer to DDK documentation for more details.

Arguments:

        pso - Defines the surface object
        pptl - Pointer to origin of next band (to return to GDI)

Return Value:

        TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;
    BOOL    bMore, bRet;

    VERBOSE(("Entering DrvNextBand...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMNextBand,
                    PFN_OEMNextBand,
                    BOOL,
                    (pso,
                     pptl));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMNextBand,
                    VMNextBand,
                    BOOL,
                    (pso,
                     pptl));

    //Reset the brush, before calling render module.

    GSResetBrush(pPDev);

    //
    // Call Raster and Font module
    //

    if (! (((PRMPROCS)(pPDev->pRasterProcs))->RMNextBand(pso, pptl)) ||
        ! (((PFMPROCS)(pPDev->pFontProcs))->FMNextBand(pso, pptl)) )
    {
        return FALSE;
    }

    //
    // Clear the band surface, szBand is in Graphic units
    //
    pPDev->fMode &= ~(PF_SURFACE_USED | PF_SURFACE_ERASED);
    pPDev->fMode &= ~PF_DOWNLOADED_TEXT;

    if (!DRIVER_DEVICEMANAGED (pPDev))   // bitmap surface
    {
        ZeroMemory(pPDev->pbScanBuf, pPDev->szBand.cy);
        ZeroMemory(pPDev->pbRasterScanBuf, (pPDev->szBand.cy / LINESPERBLOCK)+1);
#ifndef DISABLE_NEWRULES
        pPDev->dwRulesCount = 0;        
#endif
    }

    //
    // If PF_REPLAY_BAND is set, then replay the last band enumerate to
    // GDI
    //

    if (pPDev->fMode & PF_REPLAY_BAND)
    {

        pptl->x = pPDev->rcClipRgn.left;
        pptl->y = pPDev->rcClipRgn.top;

        VERBOSE(("DrvNextBand: Next Band is %d , %d \n", pptl->x, pptl->y));

        pPDev->fMode &= ~PF_REPLAY_BAND;

        return TRUE;

    }

    switch( pPDev->iBandDirection )
    {

    case  SW_DOWN:
        //
        // Moving down the page
        //

        pPDev->rcClipRgn.top += pPDev->szBand.cy;
        pPDev->rcClipRgn.bottom += pPDev->szBand.cy;

        //
        // Make sure we do not run off the bottom
        //

        bMore = pPDev->rcClipRgn.top < pPDev->sf.szImageAreaG.cy;

        if( pPDev->rcClipRgn.bottom > pPDev->sf.szImageAreaG.cy )
        {
            //
            // Partial band
            //

            pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;
        }

        break;

    case  SW_RTOL:
        //
        // LaserJet style, RTOL
        //

        pPDev->rcClipRgn.left -= pPDev->szBand.cx;
        pPDev->rcClipRgn.right -= pPDev->szBand.cx;

        bMore = pPDev->rcClipRgn.right > 0;
        //
        // if the left position is negative that is
        // what must be reported to GDI to render the
        // band correctly so we don't change the clip region.
        //
        break;

    case  SW_LTOR:
        //
        // Dot matrix, left to right
        //

        pPDev->rcClipRgn.left += pPDev->szBand.cx;
        pPDev->rcClipRgn.right += pPDev->szBand.cx;

        bMore = pPDev->rcClipRgn.left < pPDev->sf.szImageAreaG.cx;

        if( pPDev->rcClipRgn.right > pPDev->sf.szImageAreaG.cx )
        {
            //
            // Partial band
            //

            pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
        }

        break;

    case  SW_UP:
            //
            // Moving up the page
            //

            pPDev->rcClipRgn.top -= pPDev->szBand.cy;
            pPDev->rcClipRgn.bottom -= pPDev->szBand.cy;

            //
            // Make sure we do not run off the top
            //
            bMore = pPDev->rcClipRgn.bottom > 0 ;


            if( pPDev->rcClipRgn.top < 0 )
            {
                //
                // Partial band
                //

                pPDev->rcClipRgn.top = 0;
            }

            break;


    default:

        VERBOSE((" DrvNextBand, unknown banding direction \n"));
        return(FALSE);

    }

    if( bMore )
    {
        pptl->x = pPDev->rcClipRgn.left;
        pptl->y = pPDev->rcClipRgn.top;

        VERBOSE(("DrvNextBand: Next Band is %d , %d \n", pptl->x, pptl->y));
    }
    else
    {
        //
        // No more band for the page, send the page to printer
        //

        if ( !(((PRMPROCS)(pPDev->pRasterProcs))->RMSendPage(pso)) ||
             !(((PFMPROCS)(pPDev->pFontProcs))->FMSendPage(pso)) )
        {
            bRet = FALSE;

        }
        else
            bRet = TRUE;

        //
        // Send PageFinish sequence commands
        //

        VEndPage( pPDev );
        pptl->x = pptl->y = -1;

        return(bRet);
    }

    return(TRUE);

}

BOOL
DrvStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvStartBanding.
    Please refer to DDK documentation for more details.
    Note: DrvStartBanding is called to prepare the driver
    for banding, call only once per page (not at everyband!!)

Arguments:

    pso - Defines the surface object
    pptl - Pointer to origin of next band (to return to GDI)

Return Value:

    Fill out pptl to contain the origin of the first band

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV    *pPDev = (PDEV *)pso->dhpdev;

    VERBOSE(("Entering DrvStartBanding...\n"));

    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMStartBanding,
                    PFN_OEMStartBanding,
                    BOOL,
                    (pso,
                     pptl));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMStartBanding,
                    VMStartBanding,
                    BOOL,
                    (pso,
                     pptl));

    //
    // Set PF_ENUM_GRXTXT
    //

    pPDev->fMode |= PF_ENUM_GRXTXT;
    pPDev->fMode &= ~(PF_SURFACE_USED | PF_SURFACE_ERASED);
    pPDev->fMode &= ~PF_DOWNLOADED_TEXT;

    if (!DRIVER_DEVICEMANAGED (pPDev))   // bitmap surface
    {
        ZeroMemory(pPDev->pbScanBuf, pPDev->szBand.cy);
        ZeroMemory(pPDev->pbRasterScanBuf, (pPDev->szBand.cy / LINESPERBLOCK)+1);
#ifndef DISABLE_NEWRULES
        pPDev->dwRulesCount = 0;        
#endif
    }

    //
    //
    // Call Raster and Font module
    //

    if (! (((PRMPROCS)(pPDev->pRasterProcs))->RMStartBanding(pso, pptl)) ||
        ! (((PFMPROCS)(pPDev->pFontProcs))->FMStartBanding(pso, pptl)) )
    {
        return FALSE;
    }


    if( pPDev->fMode & PF_ROTATE )
    {
        pPDev->rcClipRgn.top = 0;
        pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy;

        if( pPDev->fMode & PF_CCW_ROTATE90 )
        {
            //
            //   LaserJet style rotation
            //


            if( //  if duplexing is enabled...
                (pPDev->pdm->dmFields & DM_DUPLEX) &&
                (pPDev->pdm->dmDuplex == DMDUP_VERTICAL)  &&

                    !(pPDev->dwPageNumber % 2)  &&
                pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER)
            {
                pPDev->rcClipRgn.left = 0;
                pPDev->rcClipRgn.right = pPDev->szBand.cx;
                pPDev->iBandDirection = SW_LTOR;
            }
            else
            {
                pPDev->rcClipRgn.left = pPDev->sf.szImageAreaG.cx - pPDev->szBand.cx;
                pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
                pPDev->iBandDirection = SW_RTOL;
            }
        }
        else
        {
            //
            //  Dot matrix style rotation
            //

            if( //  if duplexing is enabled...
                (pPDev->pdm->dmFields & DM_DUPLEX) &&
                (pPDev->pdm->dmDuplex == DMDUP_VERTICAL)  &&

                    !(pPDev->dwPageNumber % 2)  &&
                pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER)
            {
                pPDev->rcClipRgn.left = pPDev->sf.szImageAreaG.cx - pPDev->szBand.cx;
                pPDev->rcClipRgn.right = pPDev->sf.szImageAreaG.cx;
                pPDev->iBandDirection = SW_RTOL;
            }
            else
            {
                pPDev->rcClipRgn.left = 0;
                pPDev->rcClipRgn.right = pPDev->szBand.cx;
                pPDev->iBandDirection = SW_LTOR;
            }
        }
    }
    else
    {
        pPDev->rcClipRgn.left = 0;
        pPDev->rcClipRgn.right = pPDev->szBand.cx;

        if( //  if duplexing is enabled...
            (pPDev->pdm->dmFields & DM_DUPLEX) &&
            (pPDev->pdm->dmDuplex == DMDUP_VERTICAL)  &&

                !(pPDev->dwPageNumber % 2)  &&
            pPDev->pUIInfo->dwFlags  & FLAG_REVERSE_BAND_ORDER)
        {
            pPDev->rcClipRgn.top = pPDev->sf.szImageAreaG.cy - pPDev->szBand.cy;
            pPDev->rcClipRgn.bottom = pPDev->sf.szImageAreaG.cy ;
            pPDev->iBandDirection = SW_UP;
        }
        else
        {
            pPDev->rcClipRgn.top = 0;
            pPDev->rcClipRgn.bottom = pPDev->szBand.cy;
            pPDev->iBandDirection = SW_DOWN;
        }
    }

    pptl->x = pPDev->rcClipRgn.left;
    pptl->y = pPDev->rcClipRgn.top;

    return TRUE;
}

VOID
VEndPage (
    PDEV *pPDev
    )
/*++

Routine Description:

    This function is called when the page has been rendered.  Mainly used to
    complete the page printing process.  Called at DrvSendPage or at
    DrvNextBand and no more band to process for the page or at
    DrvEndDoc where the job is aborted.

Arguments:

    pPDev - Pointer to PDEVICE

Return Value:

    None

--*/
{

    //
    // Eject the page for device that use FF to eject a page, else
    // move the cursor to the bottom of the page.
    //

    if (pPDev->pGlobals->bEjectPageWithFF == TRUE)
    {
        if ( !(pPDev->bTTY) ||
              pPDev->fMode2 & PF2_DRVTEXTOUT_CALLED_FOR_TTY   ||
             !(pPDev->fMode2 & PF2_PASSTHROUGH_CALLED_FOR_TTY)  )
        {
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_FORMFEED));
            if (pPDev->fMode & PF_RESELECTFONT_AFTER_FF)
            {
                VResetFont(pPDev);
            }
        }
    }
    else
    {
        //
        // Note: sf.szImageAreaG.cx and sf.szImageAreaG.cy are swapped already
        // if the page is printed in landscape mode.  Need to unswap it
        // for moving the cursor to the end of the page
        //

        INT       iYEnd;                // Last scan line on page


        iYEnd = pPDev->pdm->dmOrientation == DMORIENT_LANDSCAPE ?
                    pPDev->sf.szImageAreaG.cx : pPDev->sf.szImageAreaG.cy;

        YMoveTo(pPDev, iYEnd, MV_GRAPHICS);
    }


    //
    // Send PageFinish sequence Cmds
    //

    VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwPageFinishIndex);

    //
    // Reset and and free up realized brush for this page
    //

    GSResetBrush(pPDev);
    GSUnRealizeBrush(pPDev);

    FlushSpoolBuf( pPDev );
    pPDev->dwPageNumber++ ;

    //
    // Clear PF2_XXX_TTY flags
    //
    pPDev->fMode2 &= ~( PF2_DRVTEXTOUT_CALLED_FOR_TTY |
                        PF2_PASSTHROUGH_CALLED_FOR_TTY );

}

BOOL
BEndDoc (
    PDEV *pPDev,
    SURFOBJ *pso,
    FLONG   flags
    )
/*++

Routine Description:

    This function can be called from two places - DrvEndDoc and DrvStartDoc.
    In the case of a DrvResetPDEV, the driver might get another DrvStartDoc
    without a DrvEndDoc.  So need to check for previous DrvStartDoc and call
    VEndDoc to clean up previous instance before initializing the new one.

Arguments:

    pPDev - Pointer to PDEVICE
    pso   - Pointer to surface object
    flags - EndDoc flags from DrvEndDoc, zero if called from DrvStartDoc

Return Value:

    TRUE for success and FALSE for failure

--*/
{

    //
    // Call Raster and Font module for cleaning up
    //

    if (! (((PRMPROCS)(pPDev->pRasterProcs))->RMEndDoc(pso, flags)) ||
        ! (((PFMPROCS)(pPDev->pFontProcs))->FMEndDoc(pso, flags)) )
    {
        return FALSE;
    }

    //
    // If the job is aborted, send the
    // PageFinish sequence Cmds (via. VEndPage)
    //

    if( flags & ED_ABORTDOC )
        VEndPage( pPDev);
    //
    // Send DocFinish, JobFinish sequence Cmds
    //

    // flag is cleared if called from  DrvEndDoc, this is the only time we
    //  should actually send the EndDoc commands to the printer.

    if (!(pPDev->fMode & PF_DOC_SENT))
    {
        if (pPDev->fMode & PF_DOCSTARTED)
        {
            VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwDocFinishIndex);
            //  print state has been forgotten, All start doc commands must be resent.
            pPDev->fMode &= ~PF_DOCSTARTED;
        }
        if (pPDev->fMode & PF_JOB_SENT)
        {
            VSendSequenceCmd(pPDev, pPDev->pDriverInfo->dwJobFinishIndex);
            pPDev->fMode &= ~PF_JOB_SENT;
        }
    }

    FlushSpoolBuf( pPDev );

    //
    // Clear the PF_DOCSTARTED, PF_FORCE_BANDING,
    // PF_ENUM_TEXT, PF_ENUM_GRXTXT, PF_REPLAY_BAND flags
    //


    pPDev->fMode &= ~PF_FORCE_BANDING;
    pPDev->fMode &= ~PF_ENUM_TEXT;
    pPDev->fMode &= ~PF_ENUM_GRXTXT;
    pPDev->fMode &= ~PF_REPLAY_BAND;

    return  TRUE;
}



VOID
VSendSequenceCmd(
    PDEV        *pPDev,
    DWORD       dwSectionIndex
    )
/*++

Routine Description:

    This function is called to send a sequence of commands to the printer.

Arguments:

    pPDev - Pointer to PDEVICE
    dwSectionIndex - specifies the index into the command array
                     for one of the following seq section.
        SS_JOBSETUP,
        SS_DOCSETUP,
        SS_PAGESETUP,
        SS_PAGEFINISH,
        SS_DOCFINISH,
        SS_JOBFINISH,

Return Value:

    None

Note:
    There are two types of command supported by the driver:
    - Predefined Commands, these commands are predefined in GPD specification
      and assigned an COMMAND ID (as enumerated in CMDINDEX).

    - Sequence Commands, these commands are not predefined.  They are
      commands that the GPD writer define to configure commands.

    - DT_LOCALLISTNODE is only used to hold a list of sequence commands

--*/
{

    LISTNODE   *pListNode;
    COMMAND    *pSeqCmd;

    //
    // Get the first node in the list
    //

    pListNode = LOCALLISTNODEPTR(pPDev->pDriverInfo, dwSectionIndex);

    while( pListNode )
    {
        //
        // Get pointer to command pointer using pListNode->dwData, which is
        // the index into the command array
        //

        pSeqCmd = INDEXTOCOMMANDPTR(pPDev->pDriverInfo, pListNode->dwData);


        //
        // Send the sequence command - but only if page ejection is
        //  not currently suppressed or this command does not
        //  cause a page to be ejected.
        //


        if(!(pPDev->fMode & PF_SEND_ONLY_NOEJECT_CMDS)  ||
                    (pSeqCmd->bNoPageEject))
                WriteChannel(pPDev, pSeqCmd);

        //
        // Get the next command in the list or exit if it's the end of list
        //

        if (pListNode->dwNextItem == END_OF_LIST)
            break;
        else
            pListNode = LOCALLISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);

    }
}

BYTE
BGetMask(
    PDEV *  pPDev,
    RECTL * pRect
    )
/*++

Routine Description:

    Given a rectangle, calculate the mask for determining the
    present of text, for z-ordering fix

Arguments:

    pPDev - Pointer to PDEVICE
    pRect - Pointer to rectangle defining the clip box for
            text or graphics

Return Value:

    None

Note:

    First mark all columm as dirty then work from the left and the right
    to figure out which one should be cleared.

--*/
{

    BYTE bMask = 0xFF;
    INT  i, iRight;

    iRight = MAX_COLUMM -1;

    if(! (pRect && pPDev->pbScanBuf && pRect->left <= pRect->right) )
        return 0;

    for (i = 0; i < MAX_COLUMM ; i++)
    {
        if (pRect->left >= (LONG)(pPDev->dwDelta * (i+1)) )
            bMask &= ~(1 << i);
        else
            break;
    }

    for (i = iRight; i >= 0; i--)
    {
        if (pRect->right < (LONG)(pPDev->dwDelta * i ))
            bMask &= ~(1 << i);
        else
            break;
    }

    return bMask;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\state.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    state.c

Abstract:

    Printer graphics state tracking.
    Implemenation of

    GSRealizeBrush
    GSUnRealizeBrush
    GSSelectBrush
    GSResetBrush

Environment:

    Windows NT Unidrv driver

Revision History:

    04/29/97 -amandan-
        Created

--*/

#include "unidrv.h"

#ifdef WINNT_40   // NT 4.0

extern HSEMAPHORE   hSemBrushColor;
LPDWORD      pBrushSolidColor = NULL;


DWORD
GetBRUSHOBJRealColor(
    PDEV        *pPDev,
    BRUSHOBJ    *pbo
    )

/*++

Routine Description:

    Given a BRUSHOBJ Gets the original color ofthe brush using DrvDitherColor.


Arguments:

    pPDev - Pointer to PDEV
    pbo - Pointer to BRUSHOBJ

Return Value:

    Original RGB color

Note:


--*/

{
    DWORD   SolidColor;


    if ((SolidColor = pbo->iSolidColor) == 0xFFFFFFFF)
    {

        SolidColor = 0;

        EngAcquireSemaphore(hSemBrushColor);

        pBrushSolidColor = &SolidColor;
        BRUSHOBJ_pvGetRbrush(pbo);

        EngReleaseSemaphore(hSemBrushColor);

    }
    else
    {
         ERR(( "GetBRUSHOBJRealColor: Should not be Called for mapped color\n" ));
         SolidColor = 0;
    }

    return(SolidColor);

}

#endif //WINNT_40

ULONG GetRGBColor(PDEV *, ULONG);


PDEVBRUSH
GSRealizeBrush(
    IN OUT  PDEV        *pPDev,
    IN      SURFOBJ     *pso,
    IN      BRUSHOBJ    *pbo
    )
/*++

Routine Description:

    Given a BRUSHOBJ perform one of the following:

    Color Printer:
    1. Programmable Palette
    2. Non-Programmable Palette

    Monochrome Printer:
    1. User defined pattern, only if brush is pattern brush
    2. Shading Patterns , only if brush is pattern brush
    3. Maps to black/white brush
    4. Maps to black

Arguments:

    pPDev - Pointer to PDEV
    pso - Pointer to SURFOBJ
    pbo - Pointer to BRUSHOBJ

Return Value:

    PDEVBRUSH if successful, otherwise NULL

Note:

    It's up to the caller to call GSUnRealizeBrush to free brushes

--*/

{

    ULONG ulColor = pbo->iSolidColor;
    PDEVBRUSH   pDevBrush;
    BOOL        bPatternBrush = FALSE;

    //
    // Allocate memory for Brush, deallocation is done in GSUnRealizeBrush
    //

    if ((pDevBrush = MemAllocZ(sizeof(DEVBRUSH))) == NULL)
        return NULL;

    if (pso->iBitmapFormat != BMF_24BPP &&
          pbo->iSolidColor != DITHERED_COLOR)
    {
        //
        // Index case
        // pbo->iSolidColor holds the Index, Map index to RGB color
        //

        ulColor = GetRGBColor(pPDev, pbo->iSolidColor);
    }
    //
    // TBD: BUG_BUG NT4 - needs to be fixed
    //   no NT4 bugs will be fixed unless necessary.
    //


    if (pbo->iSolidColor == DITHERED_COLOR)
    {
        //
        // Pattern Brush, get the color
        //

        #ifndef WINNT_40 //NT 5.0

        ulColor = BRUSHOBJ_ulGetBrushColor(pbo);
        
        // BUG_BUG: Unidrv currently doesn't handle the case where the brush is
        // a non-solid brush (return -1). The HPGL / PCL-XL implementations will require
        // this so we will merge that implementation when it is complete. 
        if (ulColor != -1)
            ulColor &= 0x00FFFFFF;

        #else // NT 4.0

        ulColor  = GetBRUSHOBJRealColor(pPDev, pbo);

        #endif //!WINNT_40


        bPatternBrush = TRUE;
    }



    //
    // ulColor should always be RGB color by the time we get here
    //

    if ((pso->iBitmapFormat == BMF_1BPP) )
    {
        //
        // Monochrome case
        // Download user define pattern or select intensity for
        // non-solid brush ONLY.  Otherwise, map it to black or white.
        //
        //
        if ((pPDev->fMode & PF_DOWNLOAD_PATTERN) && bPatternBrush)
        {
            PDEVBRUSH pDB;

            // Support user defined pattern, iColor will hold the pattern ID

            if ((pDB = (PDEVBRUSH)BRUSHOBJ_pvGetRbrush(pbo)) == NULL)
            {
                WARNING(("BRUSHOBJ_pvGetRBrush failed"));
                MemFree(pDevBrush);
                return NULL;
            }

            pDevBrush->dwBrushType = BRUSH_USERPATTERN;
            pDevBrush->iColor = pDB->iColor;

        }
        else if ((pPDev->fMode & PF_SHADING_PATTERN) && bPatternBrush)
        {
            // Support shading pattern, iColor holds %of gray

            pDevBrush->dwBrushType = BRUSH_SHADING;
            pDevBrush->iColor = GET_SHADING_PERCENT(ulColor);
        }
        else if (pPDev->fMode & PF_WHITEBLACK_BRUSH)
        {
            // Support black/white brush commands, iColor will hold RBG color
            // We are here means solid color brush, and for monochrome
            // it can be either black or white.  If it's indexed, we
            // have taken care of mapping index to RGB color already
            //

            pDevBrush->dwBrushType = BRUSH_BLKWHITE;
            pDevBrush->iColor = ulColor;

        }
        else
        {
            //
            // Map to black
            //

            pDevBrush->dwBrushType = BRUSH_BLKWHITE;
            pDevBrush->iColor = RGB_BLACK_COLOR;

        }

    }
    else if (pPDev->fMode & PF_ANYCOLOR_BRUSH )
    {
        //
        // Programmable
        //

        pDevBrush->dwBrushType = BRUSH_PROGCOLOR;
        pDevBrush->iColor = ulColor;

    }
    else
    {
        //
        // Non-Programmable
        //

        pDevBrush->dwBrushType = BRUSH_NONPROGCOLOR;

        //
        // Since ulColor is RGB color, need to map it to the nearest
        // color in the fixed palette.
        // iColor will hold the index of the color
        //
        if (pbo->iSolidColor == DITHERED_COLOR)
            pDevBrush->iColor = BestMatchDeviceColor(pPDev,(DWORD)ulColor);
        else
            pDevBrush->iColor = pbo->iSolidColor;
    }

    //
    // Save the brush to the Realized Brush linked list
    //

    if (pPDev->GState.pRealizedBrush == NULL)
    {
        pDevBrush->pNext = NULL;
        pPDev->GState.pRealizedBrush = pDevBrush;
    }
    else
    {
        pDevBrush->pNext = pPDev->GState.pRealizedBrush;
        pPDev->GState.pRealizedBrush = pDevBrush;
    }

    return pDevBrush;
}

VOID
GSUnRealizeBrush(
    IN      PDEV    *pPDev
    )
/*++

Routine Description:

    Deallocate memory for the realized brush

Arguments:

    pPDev   Pointer to PDEV

Return Value:

    None

--*/
{

    PDEVBRUSH pDevBrush = pPDev->GState.pRealizedBrush;

    VERBOSE(("GSUnRealizeBrush \n"));

    while(pPDev->GState.pRealizedBrush !=NULL)
    {
        pDevBrush = pPDev->GState.pRealizedBrush;
        pPDev->GState.pRealizedBrush = pDevBrush->pNext;
        MemFree(pDevBrush);
    }

    pPDev->GState.pRealizedBrush = NULL;
}

BOOL
GSSelectBrush(
    IN      PDEV        *pPDev,
    IN      PDEVBRUSH   pDevBrush
    )
/*++

Routine Description:

    Given a pDevBrush, select the brush.

Arguments:

    pPDev - Pointer to PDEV
    pDevBrush - Pointer to DEVBRUSH

Return Value:

    TRUE if sucessful, otherwise FALSE

--*/

{
    BOOL bIndexedColor = FALSE;

    //
    // Find Cached Brush, if the current selected brush matches
    // the caller request, do nothing.
    //

    if (BFoundCachedBrush(pPDev, pDevBrush))
        return TRUE;

    switch(pDevBrush->dwBrushType){

        case BRUSH_PROGCOLOR:
        {
            VERBOSE(("Using Programmable RGB Color \n"));

            if (((PAL_DATA *)pPDev->pPalData)->fFlags & PDF_PALETTE_FOR_8BPP_MONO)
                pDevBrush->iColor = ConvertRGBToGrey(pDevBrush->iColor);

            if ( !BSelectProgrammableBrushColor(pPDev, pDevBrush->iColor) )
            {
                WARNING(("\nCan't Select the brush color for RGB = 0x%x\n",pDevBrush->iColor));
                pDevBrush->iColor = BestMatchDeviceColor(pPDev, pDevBrush->iColor);
                bIndexedColor = TRUE;
            }
        }
            //
            // Let it fall thru to catch the indexed case
            //

        case BRUSH_NONPROGCOLOR:
        {
            if (bIndexedColor || pDevBrush->dwBrushType == BRUSH_NONPROGCOLOR)
            {
                INT iCmd;

                VERBOSE(("Using Non Programmable Indexed Color"));

                //
                // If this color is not supported, use the default color: black.
                //

                pDevBrush->iColor &= (MAX_COLOR_SELECTION - 1);   /* 16 entry palette wrap around */

                //
                // If there is no command to set the color, map to black.
                //
                if(COMMANDPTR(pPDev->pDriverInfo, CMD_COLORSELECTION_FIRST + pDevBrush->iColor) == NULL)
                    pDevBrush->iColor = BLACK_COLOR_CMD_INDEX;

                iCmd = CMD_COLORSELECTION_FIRST + pDevBrush->iColor;
                WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, iCmd));
            }

        }
            break;

        case BRUSH_USERPATTERN:
        {
            VERBOSE(("Selecting user defined pattern brush"));

            //
            // The pattern ID, is stored in pDevBrush->iColor
            //

            pPDev->dwPatternBrushType = BRUSH_USERPATTERN;
            pPDev->dwPatternBrushID = pDevBrush->iColor;

            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECT_PATTERN));
        }
            break;

        case BRUSH_SHADING:
        {

            VERBOSE(("Selecting shading pattern brush"));

            //
            // The gray level (expressed as intensity) is stored in
            // pDevBrush->iColor
            //

            //
            // Update standard variable for brush selection command
            //

            pPDev->dwPatternBrushType = BRUSH_SHADING;
            pPDev->dwPatternBrushID = pDevBrush->iColor;
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECT_PATTERN));

        }
            break;

        case BRUSH_BLKWHITE:
        {
            INT iCmd;


            if (pDevBrush->iColor == RGB_WHITE_COLOR)
            {
                VERBOSE(("Selecting white brush"));

                //
                // BUG_BUG, need to remove the CMD_WHITETEXTON and CMD_WHITETEXTOFF
                // once all GPD changes have been made for BLACKBRUSH, WHITEBRUSH
                //     doesn't hurt to leave it in.

                if (pPDev->arCmdTable[CMD_SELECT_WHITEBRUSH])
                    iCmd = CMD_SELECT_WHITEBRUSH;
                else
                    iCmd = CMD_WHITETEXTON;
            }
            else
            {
                //
                // Black - standard text color
                //

                VERBOSE(("Selecting black brush"));

                //
                // BUG_BUG, need to remove the CMD_WHITETEXT_ON and CMD_WHITETEXT_OFF
                // once all GPD changes have been made for BLACKBRUSH, WHITEBRUSH
                //     doesn't hurt to leave it in.
                //

                if (pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH])
                    iCmd = CMD_SELECT_BLACKBRUSH;
                else
                    iCmd = CMD_WHITETEXTOFF;
            }

            //
            //   Set the desired colour !
            //

            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, iCmd));
        }
            break;
    }

    //
    // Cached the brush
    //

    CACHE_CURRENT_BRUSH(pPDev, pDevBrush)

    return TRUE;
}


VOID
GSResetBrush(
    IN OUT  PDEV        *pPDev
    )
/*++

Routine Description:

    Select the default brush

Arguments:

    pPDev - Pointer to PDEV

Return Value:

    None

--*/

{

    DEVBRUSH DeviceBrush;
    PDEVBRUSH pDevBrush = &DeviceBrush;
    PAL_DATA    *pPD;
    pPD = pPDev->pPalData;


    if (pPD->fFlags & PDF_PALETTE_FOR_1BPP)
    {
        //
        // Monochrome case. Select black brush
        //

        pDevBrush->dwBrushType = BRUSH_BLKWHITE;
        pDevBrush->iColor = RGB_BLACK_COLOR;

        if (BFoundCachedBrush(pPDev, pDevBrush))
            return;

        //
        // BUG_BUG, need to remove the CMD_WHITETEXT_ON and CMD_WHITETEXT_OFF
        // once all GPD changes have been made
        //     doesn't hurt to leave it in.
        //
        if (pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH])
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECT_BLACKBRUSH));
        else
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_WHITETEXTOFF));

    }
    else if (pPDev->fMode & PF_ANYCOLOR_BRUSH )
    {
        //
        // Programmable
        //

        pDevBrush->dwBrushType = BRUSH_PROGCOLOR;
        pDevBrush->iColor = RGB_BLACK_COLOR;

        VResetProgrammableBrushColor(pPDev);

    }
    else
    {
        //
        // Non-Programmable
        //

        pDevBrush->dwBrushType = BRUSH_NONPROGCOLOR;
        pDevBrush->iColor = ((PAL_DATA*)(pPDev->pPalData))->iBlackIndex;

        if (BFoundCachedBrush(pPDev, pDevBrush))
            return;

        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo,CMD_SELECTBLACKCOLOR));

    }

    CACHE_CURRENT_BRUSH(pPDev, pDevBrush)

}


ULONG
GetRGBColor(
    IN      PDEV        *pPDev,
    IN      ULONG       ulIndex
    )
/*++

Routine Description:

    Given an Indexed color, map to an RGB color

Arguments:

    pPDev - Pointer to PDEV
    pDevBrush - Pointer to DEVBRUSH

Return Value:

    TRUE if sucessful, otherwise FALSE

--*/

{

    // If the index is invalid, map to Black.
    if (ulIndex > PALETTE_MAX)
    {
        ERR(( "GSSelectBrush: Bad input Color Index\n" ));
        ulIndex = ((PAL_DATA*)(pPDev->pPalData))->iBlackIndex;
    }

    return( ((PAL_DATA *)(pPDev->pPalData))->ulPalCol[ulIndex]);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\oemkm.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    oemkm.c

Abstract:

    Kernel mode support for OEM plugins

Environment:

    Windows NT Unidrv driver

Revision History:

    04/01/97 -zhanw-
        Adapted from Pscript source

--*/

#include "unidrv.h"

#ifdef WINNT_40

//
// The global link list of ref counts for currently loaded OEM render plugin DLLs
//

POEM_PLUGIN_REFCOUNT gpOEMPluginRefCount;

static const CHAR szDllInitialize[] = "DllInitialize";

#endif // WINNT_40

//
// Unidrv specific OEM entrypoints
//
// NOTE: Please keep this in sync with indices defined in printer5\inc\oemutil.h!!!
//

static CONST PSTR OEMUnidrvProcNames[MAX_UNIDRV_ONLY_HOOKS] = {
    "OEMCommandCallback",
    "OEMImageProcessing",
    "OEMFilterGraphics",
    "OEMCompression",
    "OEMHalftonePattern",
    "OEMMemoryUsage",
    "OEMDownloadFontHeader",
    "OEMDownloadCharGlyph",
    "OEMTTDownloadMethod",
    "OEMOutputCharStr",
    "OEMSendFontCmd",
    "OEMTTYGetInfo",
    "OEMTextOutAsBitmap",
    "OEMWritePrinter",
};


static CONST PSTR COMUnidrvProcNames[MAX_UNIDRV_ONLY_HOOKS] = {
    "CommandCallback",
    "ImageProcessing",
    "FilterGraphics",
    "Compression",
    "HalftonePattern",
    "MemoryUsage",
    "DownloadFontHeader",
    "DownloadCharGlyph",
    "TTDownloadMethod",
    "OutputCharStr",
    "SendFontCmd",
    "TTYGetInfo",
    "TextOutAsBitmap",
    "WritePrinter",

};

//
// OEM plugin helper function table
//

static const DRVPROCS OEMHelperFuncs = {
    (PFN_DrvWriteSpoolBuf)      WriteSpoolBuf,
    (PFN_DrvXMoveTo)            XMoveTo,
    (PFN_DrvYMoveTo)            YMoveTo,
    (PFN_DrvGetDriverSetting)   BGetDriverSettingForOEM,
    (PFN_DrvGetStandardVariable) BGetStandardVariable,
    (PFN_DrvUnidriverTextOut)   FMTextOut,
    (PFN_DrvWriteAbortBuf)      WriteAbortBuf,
};


INT
IMapDDIIndexToOEMIndex(
    ULONG ulDdiIndex
    )

/*++

Routine Description:

    Maps DDI entrypoint index to OEM entrypoint index

Arguments:

    ulDdiIndex - DDI entrypoint index

Return Value:

    OEM entrypoint index corresponding to the specified DDI entrypoint index
    -1 if the specified DDI entrypoint cannot be hooked out by OEM plugins

--*/

{
    static const struct {
        ULONG   ulDdiIndex;
        INT     iOemIndex;
    }
    OemToDdiMapping[] =
    {
        INDEX_DrvRealizeBrush,            EP_OEMRealizeBrush,
        INDEX_DrvDitherColor,             EP_OEMDitherColor,
        INDEX_DrvCopyBits,                EP_OEMCopyBits,
        INDEX_DrvBitBlt,                  EP_OEMBitBlt,
        INDEX_DrvStretchBlt,              EP_OEMStretchBlt,
#ifndef WINNT_40
        INDEX_DrvStretchBltROP,           EP_OEMStretchBltROP,
        INDEX_DrvPlgBlt,                  EP_OEMPlgBlt,
        INDEX_DrvTransparentBlt,          EP_OEMTransparentBlt,
        INDEX_DrvAlphaBlend,              EP_OEMAlphaBlend,
        INDEX_DrvGradientFill,            EP_OEMGradientFill,
#endif
        INDEX_DrvTextOut,                 EP_OEMTextOut,
        INDEX_DrvStrokePath,              EP_OEMStrokePath,
        INDEX_DrvFillPath,                EP_OEMFillPath,
        INDEX_DrvStrokeAndFillPath,       EP_OEMStrokeAndFillPath,
        INDEX_DrvPaint,                   EP_OEMPaint,
        INDEX_DrvLineTo,                  EP_OEMLineTo,
        INDEX_DrvStartPage,               EP_OEMStartPage,
        INDEX_DrvSendPage,                EP_OEMSendPage,
        INDEX_DrvEscape,                  EP_OEMEscape,
        INDEX_DrvStartDoc,                EP_OEMStartDoc,
        INDEX_DrvEndDoc,                  EP_OEMEndDoc,
        INDEX_DrvNextBand,                EP_OEMNextBand,
        INDEX_DrvStartBanding,            EP_OEMStartBanding,
        INDEX_DrvQueryFont,               EP_OEMQueryFont,
        INDEX_DrvQueryFontTree,           EP_OEMQueryFontTree,
        INDEX_DrvQueryFontData,           EP_OEMQueryFontData,
        INDEX_DrvQueryAdvanceWidths,      EP_OEMQueryAdvanceWidths,
        INDEX_DrvFontManagement,          EP_OEMFontManagement,
        INDEX_DrvGetGlyphMode,            EP_OEMGetGlyphMode,
    };

    INT iIndex;
    INT iLimit = sizeof(OemToDdiMapping) / (sizeof(INT) * 2);

    for (iIndex=0; iIndex < iLimit; iIndex++)
    {
        if (OemToDdiMapping[iIndex].ulDdiIndex == ulDdiIndex)
            return OemToDdiMapping[iIndex].iOemIndex;
    }

    return -1;
}



BOOL
BLoadAndInitOemPlugins(
    PDEV    *pPDev
    )

/*++

Routine Description:

    Get information about OEM plugins associated with the current device
    Load them into memory and call OEMEnableDriver for each of them

Arguments:

    pPDev - Points to our device data structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PFN_OEMEnableDriver pfnOEMEnableDriver;
    DRVENABLEDATA       ded;
    DWORD               dwCount;
    INT                 iIndex;
    PDRVFN              pdrvfn;
    OEMPROC             oemproc;

    //
    // Load OEM plugins into memory
    //

    pPDev->devobj.pDrvProcs = (PDRVPROCS) &OEMHelperFuncs;

    if (! (pPDev->pOemPlugins = PGetOemPluginInfo(pPDev->devobj.hPrinter,
                                                  pPDev->pDriverInfo3->pDriverPath,
                                                  pPDev->pDriverInfo3)) ||
        ! BLoadOEMPluginModules(pPDev->pOemPlugins))
    {
        return FALSE;
    }

    //
    // Init pdriverobj to point to devobj for OEM to access private setting
    //

    pPDev->pOemPlugins->pdriverobj = &pPDev->devobj;

    //
    // If there is no OEM plugin, return success
    //

    if (pPDev->pOemPlugins->dwCount == 0)
        return TRUE;

    //
    // Call OEM plugin's OEMEnableDriver entrypoint
    // and find out if any of them has hook out DDI entrypoints
    //

    pPDev->pOemHookInfo = MemAllocZ(sizeof(OEM_HOOK_INFO) * MAX_OEMHOOKS);

    if (pPDev->pOemHookInfo == NULL)
        return FALSE;

    START_OEMENTRYPOINT_LOOP(pPDev)
    // this macro defined in oemkm.h in conjunction with its partner  END_OEMENTRYPOINT_LOOP,
    // acts like a for() loop initializing and incrementing pOemEntry each pass through the
    //  loop.

        ZeroMemory(&ded, sizeof(ded));

        //
        // COM Plug-in case
        //
        if (pOemEntry->pIntfOem != NULL)
        {
            HRESULT hr;

            hr = HComOEMEnableDriver(pOemEntry,
                                     PRINTER_OEMINTF_VERSION,
                                     sizeof(ded),
                                     &ded);

            if (hr == E_NOTIMPL)
                goto UNIDRV_SPECIFIC;

            if (FAILED(hr))
            {
                ERR(("OEMEnableDriver failed for '%ws': %d\n",
                     pOemEntry->ptstrDriverFile,
                     GetLastError()));

                break;
            }
        }
        //
        // Non-COM Plug-in case
        //
        else
        {
            if (!(pfnOEMEnableDriver = GET_OEM_ENTRYPOINT(pOemEntry, OEMEnableDriver)))
                goto UNIDRV_SPECIFIC;

            //
            // Call OEM plugin's entrypoint
            //

            if (! pfnOEMEnableDriver(PRINTER_OEMINTF_VERSION, sizeof(ded), &ded))
            {
                ERR(("OEMEnableDriver failed for '%ws': %d\n",
                    pOemEntry->ptstrDriverFile,
                    GetLastError()));

                break;
            }
            //
            // Verify the driver version    (do this only if not COM)
            //

            if (ded.iDriverVersion != PRINTER_OEMINTF_VERSION)
            {
                ERR(("Invalid driver version for '%ws': 0x%x\n",
                    pOemEntry->ptstrDriverFile,
                    ded.iDriverVersion));

                break;
            }
        }

        pOemEntry->dwFlags |= OEMENABLEDRIVER_CALLED;


        //
        // Check if OEM plugin has hooked out any DDI entrypoints
        //

        for (dwCount=ded.c, pdrvfn=ded.pdrvfn; dwCount-- > 0; pdrvfn++)
        {
            if ((iIndex = IMapDDIIndexToOEMIndex(pdrvfn->iFunc)) >= 0)
            {
                if (pPDev->pOemHookInfo[iIndex].pfnHook != NULL)
                {
                    WARNING(("Multiple hooks for entrypoint: %d\n"
                            "    %ws\n"
                            "    %ws\n",
                            iIndex,
                            pOemEntry->ptstrDriverFile,
                            pPDev->pOemHookInfo[iIndex].pOemEntry->ptstrDriverFile));
                }
                else
                {
                    pPDev->pOemHookInfo[iIndex].pfnHook = (OEMPROC) pdrvfn->pfn;
                    pPDev->pOemHookInfo[iIndex].pOemEntry = pOemEntry;
                }
            }
        }

        //
        // check if OEM plugin has any Unidrv-specific callbacks exported
        //

UNIDRV_SPECIFIC:
    for (dwCount = 0; dwCount < MAX_UNIDRV_ONLY_HOOKS; dwCount++)
    {
        oemproc = NULL;

        if(pOemEntry->pIntfOem)   //  is this a COM component, do special processing
        {
            if(S_OK == HComGetImplementedMethod(pOemEntry, COMUnidrvProcNames[dwCount]) )
                oemproc  = (OEMPROC)pOemEntry;
                        //  note oemproc/pfnHook only used as a BOOLEAN in COM path code.
                        //  do not use pfnHook to call a COM function!  we will use
                        //   ganeshp's wrapper functions (declared in unidrv2\inc\oemkm.h)  to do this.
        }
        else if (pOemEntry->hInstance != NULL)
                oemproc = (OEMPROC) GetProcAddress(pOemEntry->hInstance,
                                        OEMUnidrvProcNames[dwCount])  ;

        if(oemproc)
        {
            //
            // check if another OEM has already hooked out this function.
            // If so, ignore this one.
            //
            iIndex = dwCount + EP_UNIDRV_ONLY_FIRST;
            if (pPDev->pOemHookInfo[iIndex].pfnHook != NULL)
            {
                WARNING(("Multiple hooks for entrypoint: %d\n"
                         "    %ws\n"
                         "    %ws\n",
                         iIndex,
                         pOemEntry->ptstrDriverFile,
                         pPDev->pOemHookInfo[iIndex].pOemEntry->ptstrDriverFile));
            }
            else
            {
                DWORD   dwSize;
                HRESULT hr;

                pPDev->pOemHookInfo[iIndex].pfnHook = oemproc;
                pPDev->pOemHookInfo[iIndex].pOemEntry = pOemEntry;

                //
                // Set WritePrinter flag (OEMWRITEPRINTER_HOOKED).
                // Plug-in DLL needs to return S_OK with pBuff = NULL, size = 0,
                // and pdevobj = NULL.
                //
                if (iIndex == EP_OEMWritePrinter)
                {
                    hr = HComWritePrinter(pOemEntry,
                                          NULL,
                                          NULL,
                                          0,
                                          &dwSize);

                    if (hr == S_OK)
                    {
                        //
                        // Set WritePrinter hook flag in plug-in info.
                        //
                        pOemEntry->dwFlags |= OEMWRITEPRINTER_HOOKED;

                        //
                        // Set WritePrinter hook flag in UNIDRV PDEV.
                        //
                        pPDev->fMode2 |= PF2_WRITE_PRINTER_HOOKED;
                    }
                }
            }
        }
    }

    END_OEMENTRYPOINT_LOOP

    //
    // cache callback function ptrs
    //
    pPDev->pfnOemCmdCallback =
        (PFN_OEMCommandCallback)pPDev->pOemHookInfo[EP_OEMCommandCallback].pfnHook;

    return TRUE;
}


VOID
VUnloadOemPlugins(
    PDEV    *pPDev
    )

/*++

Routine Description:

    Unload OEM plugins and free all relevant resources

Arguments:

    pPDev - Points to our device data structure

Return Value:

    NONE

--*/

{
    PFN_OEMDisableDriver pfnOEMDisableDriver;
    PFN_OEMDisablePDEV   pfnOEMDisablePDEV;

    if (pPDev->pOemPlugins == NULL)
        return;

    //
    // Call OEMDisablePDEV for all OEM plugins, if necessary
    //

    START_OEMENTRYPOINT_LOOP(pPDev)

        if (pOemEntry->dwFlags & OEMENABLEPDEV_CALLED)
        {
            if (pOemEntry->pIntfOem != NULL)
            {
                (VOID)HComOEMDisablePDEV(pOemEntry, (PDEVOBJ)pPDev);
            }
            else
            {
                if (pfnOEMDisablePDEV = GET_OEM_ENTRYPOINT(pOemEntry, OEMDisablePDEV))
                {
                    pfnOEMDisablePDEV((PDEVOBJ) pPDev);
                }
            }
        }

    END_OEMENTRYPOINT_LOOP

    //
    // Call OEMDisableDriver for all OEM plugins, if necessary
    //

    START_OEMENTRYPOINT_LOOP(pPDev)

        if (pOemEntry->dwFlags & OEMENABLEDRIVER_CALLED)
        {
            if (pOemEntry->pIntfOem != NULL)
            {
                (VOID)HComOEMDisableDriver(pOemEntry);
            }
            else
            {
                if ((pfnOEMDisableDriver = GET_OEM_ENTRYPOINT(pOemEntry, OEMDisableDriver)))
                {
                    pfnOEMDisableDriver();
                }
            }
        }

    END_OEMENTRYPOINT_LOOP

    MemFree(pPDev->pOemHookInfo);
    pPDev->pOemHookInfo = NULL;

    VFreeOemPluginInfo(pPDev->pOemPlugins);
    pPDev->pOemPlugins = NULL;
}



BOOL
BGetDriverSettingForOEM(
    PDEV    *pPDev,
    PCSTR   pFeatureKeyword,
    PVOID   pOutput,
    DWORD   cbSize,
    PDWORD  pcbNeeded,
    PDWORD  pdwOptionsReturned
    )

/*++

Routine Description:

    Provide OEM plugins access to driver private settings

Arguments:

    pDev - Points to our device data structure
    pFeatureKeyword - Specifies the keyword the caller is interested in
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Returns the expected size of output buffer
    pdwOptionsReturned - Returns the number of options selected

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ULONG_PTR    dwIndex;
    BOOL    bResult;

    ASSERT_VALID_PDEV(pPDev);

    //
    // This is not very portable: If the pointer value for pFeatureKeyword
    // is less than 0x10000, we assume that the pointer value actually
    // specifies a predefined index.
    //

    //  ASSERT(sizeof(pFeatureKeyword) == sizeof(DWORD));   changed for sundown

    dwIndex = (ULONG_PTR) pFeatureKeyword;

    if (dwIndex >= OEMGDS_MIN_DOCSTICKY && dwIndex < OEMGDS_MIN_PRINTERSTICKY)
    {
        bResult = BGetDevmodeSettingForOEM(
                        pPDev->pdm,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else if (dwIndex >= OEMGDS_MIN_PRINTERSTICKY && dwIndex < OEMGDS_MAX)
    {
        bResult = BGetPrinterDataSettingForOEM(
                        &pPDev->PrinterData,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else
    {
        bResult = BGetGenericOptionSettingForOEM(
                        pPDev->pUIInfo,
                        pPDev->pOptionsArray,
                        pFeatureKeyword,
                        pOutput,
                        cbSize,
                        pcbNeeded,
                        pdwOptionsReturned);
    }

    return bResult;
}


BOOL
BGetStandardVariable(
    PDEV    *pPDev,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    )

/*++

Routine Description:

    Provide OEM plugins access to driver private settings

Arguments:

    pDev - Points to our device data structure
    dwIndex - an index into the arStdPtr array defined in pdev.h and gpd.h
    pBuffer - the data is returned in this buffer
    cbSize - size of the pBuffer
    pcbNeeded - number of bytes actually written into pBuffer

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    bResult = FALSE;
    DWORD   dwData;

    if (dwIndex >= SVI_MAX)  // how could a DWORD be < 0?
    {
        ERR(("Index must be >= 0 or < SVI_MAX \n"));
        return( FALSE);
    }
    else
    {
        if(!pcbNeeded)
        {
            ERR(("pcbNeeded must not be NULL \n"));
            return( FALSE);
        }
        *pcbNeeded = sizeof(dwData);
        if(!pBuffer)
            return(TRUE);
        if(*pcbNeeded > cbSize)
            return(FALSE);

        dwData = *(pPDev->arStdPtrs[dwIndex]);
        memcpy( pBuffer, &dwData, *pcbNeeded );
        bResult = TRUE;
    }

    return bResult;
}





BOOL
BGetGPDData(
    PDEV    *pPDev,
    DWORD       dwType,     // Type of the data
    PVOID         pInputData,   // reserved. Should be set to 0
    PVOID          pBuffer,     // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    )

/*++

Routine Description:

    Provide OEM plugins access to GPD data.

Arguments:

    pDev - Points to our device data structure
    dwType,     // Type of the data
        at this time
        #define         GPD_OEMCUSTOMDATA       1
            pInputData will be ignored.

        In NT6, we will
        #define         GPD_OEMDATA 2
        at which time the caller will supply pInputData
        which points to a data specifier , catagory or label.
        (Specifics to be determined when we get there.)


    pInputData   -  reserved. Should be set to 0
    pBuffer - the data is returned in this buffer
    cbSize - size of the pBuffer
    pcbNeeded - number of bytes actually written into pBuffer

Return Value:

    TRUE if successful, FALSE if there is an error or dwType not
    supported

--*/

{
    BOOL    bResult = FALSE;
    DWORD   dwData;

    if(!pcbNeeded)
    {
        ERR(("pcbNeeded must not be NULL \n"));
        return( FALSE);
    }
    switch(dwType)
    {
        case    GPD_OEMCUSTOMDATA:
            *pcbNeeded = pPDev->pGlobals->dwOEMCustomData ;

            if( !pBuffer)
            {
               return TRUE;  //  all goes well.
            }

            if(*pcbNeeded > cbSize)
                return FALSE ;  // caller supplied buffer too small.

            CopyMemory(pBuffer,
                       pPDev->pGlobals->pOEMCustomData,
                       *pcbNeeded);


            return TRUE;  //  all goes well.

            break;
        default:
            break;
    }

    return  bResult  ;
}


#ifdef WINNT_40


PVOID
DrvMemAllocZ(
    ULONG   ulSize
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    return(MemAllocZ(ulSize));
}



VOID
DrvMemFree(
    PVOID   pMem
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
   MemFree(pMem);
}


LONG
DrvInterlockedIncrement(
    PLONG  pRef
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{


    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);

}


LONG
DrvInterlockedDecrement(
    PLONG  pRef
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();

    return (*pRef);

}


BOOL
BHandleOEMInitialize(
    POEM_PLUGIN_ENTRY   pOemEntry,
    ULONG               ulReason
    )

/*++

Routine Description:

    Manage reference counting for OEM render plugin DLLs to determine
    when plugin's DLLInitliaze() should be called.

    This function is supported only for NT4 kernel mode render plugin
    DLLs because only in that situation plugin needs to use kernel
    semaphore to implement COM's AddRef and Release.
    
    If the plugin DLL is loaded for the first time, call its
    DLLInitialize(DLL_PROCESS_ATTACH) so it can initialize its
    semaphore.
    
    If the plugin DLL is unloaded by its last client, call its
    DLLInitialize(DLL_PROCESS_DETACH) so it can delete its
    semaphore.

Arguments:

    pOemEntry - Points to information about the OEM plugin
    ulReason - either DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH

Return Value:

    TRUE is succeeded, FALSE otherwise.

--*/

{
    LPFNDLLINITIALIZE pfnDllInitialize;
    BOOL              bCallDllInitialize;
    BOOL              bRetVal = TRUE;

    if (pOemEntry->hInstance &&
        (pfnDllInitialize = (LPFNDLLINITIALIZE)GetProcAddress(
                                        (HMODULE) pOemEntry->hInstance,
                                        (CHAR *)  szDllInitialize)))
    {
        switch (ulReason) {

            case DLL_PROCESS_ATTACH:

                ENTER_CRITICAL_SECTION();

                //
                // Managing the global ref count link list must be done
                // inside critical section.
                //

                bCallDllInitialize = BOEMPluginFirstLoad(pOemEntry->ptstrDriverFile,
                                                         &gpOEMPluginRefCount);

                LEAVE_CRITICAL_SECTION();

                if (bCallDllInitialize)
                {
                    //
                    // The render plugin DLL is loaded for the first time.
                    //

                    bRetVal = pfnDllInitialize(ulReason);
                }

                break;

            case DLL_PROCESS_DETACH:

                ENTER_CRITICAL_SECTION();

                //
                // Managing the global ref count link list must be done
                // inside critical section.
                //

                bCallDllInitialize = BOEMPluginLastUnload(pOemEntry->ptstrDriverFile,
                                                          &gpOEMPluginRefCount);

                LEAVE_CRITICAL_SECTION();
              
                if (bCallDllInitialize)
                {
                    //
                    // The render plugin DLL is unloaded by its last client.
                    //

                    bRetVal = pfnDllInitialize(ulReason);
                }

                break;

            default:

                ERR(("BHandleOEMInitialize is called with an unknown ulReason.\n"));
                break;
        }
    }

    return bRetVal;
}

#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\palette.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    Palette.c

Abstract:

    Implementation of the Palette Management.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/03/97 -ganeshp-
        Created

--*/



#include "unidrv.h"
#pragma hdrstop("unidrv.h")

//Comment out this line to disable FTRACE and FVALUE.
//#define FILETRACE
#include "unidebug.h"

/* Local Function prototypes */
LONG
LSetupPalette (
    PDEV        *pPDev,
    PAL_DATA    *pPD,
    DEVINFO     *pdevinfo,
    GDIINFO     *pGDIInfo
    );


BOOL
BInitPalDevInfo(
    PDEV *pPDev,
    DEVINFO *pdevinfo,
    GDIINFO *pGDIInfo
    )
/*++

Routine Description:
    This function is called to setup the device caps, gdiinfo for
    the palette information for this printer.

Arguments:
    pPDev           Pointer to PDEV structure
    pDevInfo        Pointer to DEVINFO structure
    pGDIInfo        Pointer to GDIINFO structure

Return Value:

    TRUE for success and FALSE for failure

--*/
{
    PAL_DATA   *pPD;
    PCOLORMODEEX pColorModeEx = pPDev->pColorModeEx;
    LONG lRet = 0;      //Default is failure.
    PCOMMAND pCmd;
    DWORD    dwCommandIndex;

    //
    // allocate palette structure  and zero initialized, so that all the palette entires
    // default to Black.
    //
    if( !(pPD = (PAL_DATA *)MemAllocZ( sizeof( PAL_DATA ) )) )
    {
        ERR(("Unidrv!BInitPalDevInfo: Memory allocation for PALDATA Failed.\n"));
        goto ErrorExit;
    }

    pPDev->pPalData = pPD;

    if ( !pColorModeEx )       //If no colormode, assume Monochrome.
    {
        //
        // Hardcode PCL-XL palette
        //
        // We need to disable Color Management tab in Printer Properties.
        // With out ColorMode in GPD, we need to set palette size here for XL.
        //
        if ( pPDev->ePersonality == kPCLXL )
        {
            pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP | PDF_PALETTE_FOR_OEM_24BPP;
            pPD->wPalDev = 0;

            pdevinfo->cxDither = pdevinfo->cyDither = 0;
            pdevinfo->iDitherFormat = BMF_24BPP;
        }
        else
        {
            /*
             *   Monochrome printer,  so there are only 2 colours,  black
             *  and white.  It would be nice if the bitmap was set with
             *  black as 1 and white as 0.  HOWEVER,  there are presumptions
             *  all over the place that 0 is black.  SO,  we set them to
             *  the preferred way,  then invert before rendering.
             */

            pPD->fFlags   |=  PDF_PALETTE_FOR_1BPP;
            lRet = LSetupPalette(pPDev, pPD, pdevinfo, pGDIInfo);

            if( lRet < 1 )
            {
                ERR(("Unidrv!BInitPalDevInfo:LSetupPalette for monochrome failed, returns %ld\n", lRet ));
                goto ErrorExit;
            }
        }
    }
    else   //Explicit ColorMode  structure
    {
        if ((pColorModeEx->dwDrvBPP != pColorModeEx->dwPrinterBPP) &&
            (pColorModeEx->dwDrvBPP != 4 || pColorModeEx->dwPrinterBPP != 1 ||
             (pColorModeEx->dwPrinterNumOfPlanes != 3 &&
               pColorModeEx->dwPrinterNumOfPlanes != 4)))
        {
            //
            // OEM wants to do the dump themselves so just create
            // a palette based on the DrvBPP
            //
            pPD->wPalDev =  1;

            switch(pColorModeEx->dwDrvBPP)
            {
                case 1:
                    pPD->fFlags   |=  PDF_PALETTE_FOR_1BPP;
                    break;
                case 4:
                    pPD->fFlags   |=  PDF_PALETTE_FOR_4BPP;
                    break;
                case 8:
                    pPD->fFlags   |=  PDF_PALETTE_FOR_8BPP;
                    break;
                case 24:
                    if (pColorModeEx->bPaletteProgrammable)
                        pPD->wPalDev = min((WORD)pColorModeEx->dwPaletteSize,PALETTE_MAX-PALETTE_SIZE_24BIT);
                    pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP | PDF_PALETTE_FOR_OEM_24BPP;
                    break;
                default:
                    //
                    // BUG_BUG, do we need to handle the 16 and 32 bpp as well?
                    //  Alvin says no one has made such a request.
                    //
                    ERR(("Unidrv!BInitPalDevInfo:OEM dump, Format %d BPP not supporteds \n", pColorModeEx->dwDrvBPP));
                    goto ErrorExit;
            }

            //
            //     already opened and assigned to Ganeshp
            // BUG_BUG, Hack for Minidrivers with dump functionality.
            // This is a hack to fix the palette code for minidrivers, which
            // implement ImageProcessing. In this case we need a separate
            // Palette cache for device.In currunt implementation we have only
            // one palette cache which is also used for GDI palette. We need to
            // separate GDI palette and device palette. Because in case the
            // the OEM does the dump, we don't download the GDI palette to
            // the printer. But the cacheing code searches the common palette.
            // Because of this we don't select the colors correctly. For example
            // a input red color gets selects as index 1, even thoug index 1 is
            // not programmed to be read.
            // A complete solution at this point is risky, so we will use the
            // existing code for palettes smaller than GDI palette. For this we
            // create a device palette with just 1 entry, which will get
            // reprogrammed,if the input color is different. This is little
            // inefficeint but require much smaller change.
            //
            //


        }
        else
        {
            // Initialize to default palette size.
            if (pColorModeEx->bPaletteProgrammable)
                pPD->wPalDev =   (WORD)pColorModeEx->dwPaletteSize;
            else
                pPD->wPalDev =  PALETTE_SIZE_DEFAULT;

            // If rastermode is indexed we have to use GDI. Else a custom
            // (preferably VGA) palette will be downloaded. If the PaletteProgrammable
            // flag is set, the palette has to be downloaded. We already know which
            // palette has to be downloaded.

            if ( (pColorModeEx->dwRasterMode == RASTMODE_INDEXED) &&
                (pColorModeEx->bPaletteProgrammable) )
            {
                if (COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY) )
                {
                    pPD->fFlags   |=  PDF_DOWNLOAD_GDI_PALETTE;
                }
                else
                {
                    ERR(("Unidrv!BInitPalDevInfo:NO command to download Programmable Palette\n"));
                    goto ErrorExit;

                }

            }


            if (pColorModeEx->dwPrinterNumOfPlanes == 1)
            {
                //
                // If the Source Bitmap format is also  8 Bit, Then we have
                // to download the palette.So the PaletteSize has to atleast
                // PALETTE_SIZE_8BIT.
                //

                if ( (pColorModeEx->dwPrinterBPP == 8) &&
                    (pColorModeEx->dwDrvBPP == 8) )
                {
                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_8BIT)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_8BIT\n"));
                        goto ErrorExit;

                    }
                    else
                        pPD->fFlags   |=  PDF_PALETTE_FOR_8BPP;

                }
                else if ((pColorModeEx->dwPrinterBPP == 24) &&
                        (pColorModeEx->dwDrvBPP == 24))
                {

                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_24BIT &&
                        pColorModeEx->dwPaletteSize != 1)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_24BIT\n"));
                        goto ErrorExit;

                    }
                    else
                    {
                        pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP;
                    }

                    //
                    // Special case. The vector pseudo-plugins (i.e. unidrv's HPGL2 and PCLXL)
                    // want to get full color information
                    // even though their colormode structure may specify a bpp less than 24.
                    // For this special case, we set palette for 24bpp irrespective of what
                    // the ColorModeEx says.
                    //
                    if ( pPDev->ePersonality == kPCLXL ||
                         pPDev->ePersonality == kHPGL2 )
                    {
                        pPD->fFlags   |=  PDF_PALETTE_FOR_24BPP | PDF_PALETTE_FOR_OEM_24BPP;

                        pdevinfo->cxDither = pdevinfo->cyDither = 0;
                        pdevinfo->iDitherFormat = BMF_24BPP;
                    }

                }
                else if ((pColorModeEx->dwPrinterBPP == 1) &&
                        (pColorModeEx->dwDrvBPP == 1))
                {

                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_1BIT)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_1BIT\n"));
                        goto ErrorExit;

                    }
                    else
                        pPD->fFlags   |=  PDF_PALETTE_FOR_1BPP;
                }

            }
            else
            {
                if ( ((pColorModeEx->dwPrinterNumOfPlanes == 3) ||
                    (pColorModeEx->dwPrinterNumOfPlanes == 4)) &&
                    (pColorModeEx->dwDrvBPP > 1) )
                    pPD->fFlags   |=  PDF_PALETTE_FOR_4BPP;

                // Planer mode. Which may be indexed by Plane.In that case we need
                // to setup the Palette. So the PaletteSize must be atleast PALETTE_SIZE_4BIT.
                if (pPD->fFlags & PDF_DOWNLOAD_GDI_PALETTE)
                {
                    if (pColorModeEx->dwPaletteSize < PALETTE_SIZE_3BIT)
                    {
                        ERR(("Unidrv!BInitPalDevInfo: Size of Palette should be atleast PALETTE_SIZE_4BIT\n"));
                        goto ErrorExit;

                    }
                    else
                    {
                        // In planer mode we only provide programmable palette
                        // support for 3planes.

                        if (pColorModeEx->dwPrinterNumOfPlanes < 4 )
                        {
                            if( !(pPD->pulDevPalCol =
                                (ULONG *)MemAllocZ( pPD->wPalDev * sizeof( ULONG ))) )
                            {
                                ERR(("Unidrv!BInitPalDevInfo: Memory allocation for Device Palette Failed.\n"));
                                goto ErrorExit;
                            }

                        }
                        else
                        {
                            ERR(("Unidrv!BInitPalDevInfo:Can't download Palette for more that 3 Planes.\n"));
                            goto ErrorExit;
                        }

                    }
                }

            }
        }

        lRet = LSetupPalette(pPDev, pPD, pdevinfo, pGDIInfo);

        if( lRet < 1 )
        {
            ERR(("Unidrv!BInitPalDevInfo:LSetupPalette failed, returns %ld\n", lRet ));
            goto ErrorExit;
        }


        // If Palette is not programmable set it to the same as wPalGdi.

        if (pColorModeEx->bPaletteProgrammable)
        {
            if ( COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY))
                pPDev->fMode |= PF_ANYCOLOR_BRUSH;

            //
            // The Palette is divided in to two parts. One non programmable and other
            // programmable. The wPalGdi part of the palette is non programmable. The
            // palette indexes between wPalGdi and wPalDev is programable. If both are
            // same then we have to use the WHITE entry of the palette to program the
            // color.
            //

            if (pPD->wPalDev <= pPD->wPalGdi && !(pPD->fFlags & PDF_PALETTE_FOR_OEM_24BPP))
            {
                //Use the WHITE One to programme a color.
                pPD->wIndexToUse = INVALID_INDEX;
                pPD->fFlags |= PDF_USE_WHITE_ENTRY;
                FTRACE(White palatte entry will be used for programming color);

            }
            else
                pPD->wIndexToUse = (WORD)pPD->wPalGdi;

        }
        else
            pPD->wPalDev = pPD->wPalGdi;

        //Find out when to download the Palette.dwCount for Invocation has Comand Index.

        pPD->fFlags |= PDF_DL_PAL_EACH_PAGE; //Default for palette Download is each Page.

        if (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEDEF)) //If the Command exist check the order dependency.
        {
            if (pCmd->ordOrder.eSection == SS_PAGESETUP)
                goto  PALETTE_SEQUENCE_DETERMINED ;   //  default is ok.
            else if ((pCmd->ordOrder.eSection == SS_DOCSETUP)  ||
                (pCmd->ordOrder.eSection == SS_JOBSETUP))
            {
                pPD->fFlags |= PDF_DL_PAL_EACH_DOC;  //For SS_JOBSETUP or SS_DOCSETUP
                pPD->fFlags &= ~PDF_DL_PAL_EACH_PAGE;
                goto  PALETTE_SEQUENCE_DETERMINED ;
            }
            //  otherwise let ColorMode command determine when to init Palette.
        }

        // dwCount have index to the ColorMode Command. Get the command pointer.
        dwCommandIndex = pPDev->pColorMode->GenericOption.dwCmdIndex;
        pCmd = INDEXTOCOMMANDPTR(pPDev->pDriverInfo, dwCommandIndex) ;


        if (pCmd) //If the Command exist check the order dependency.
        {
            if ( (pCmd->ordOrder.eSection == SS_PAGEFINISH) ||
                      (pCmd->ordOrder.eSection == SS_DOCFINISH) ||
                      (pCmd->ordOrder.eSection == SS_JOBFINISH) )
            {
                ERR(("Unidrv!BInitPalDevInfo:Wrong Section for ColorMode Command, Verify GPD\n"));
                goto ErrorExit;

            }
            else if (pCmd->ordOrder.eSection != SS_PAGESETUP)
            {
                pPD->fFlags |= PDF_DL_PAL_EACH_DOC;  //For SS_JOBSETUP or SS_DOCSETUP
                pPD->fFlags &= ~PDF_DL_PAL_EACH_PAGE;
            }

        }
        else
        {
            //
            // No Command for colormode so assume to download palette on each
            // page. The exception is monochrome 1 bit mode, as most printers
            // default to this mode, so no command is needed.
            //
            if ( pPDev->pColorModeEx->bColor || pColorModeEx->dwDrvBPP != 1)
                WARNING(("Unidrv!BInitPalDevInfo:No Command to select the ColorMode\n" ));
        }

PALETTE_SEQUENCE_DETERMINED:

        // In Planer index mode, that device palette may not be same as GDI Palette.
        // So ask the raster module to fill the device paletter based upon the Plane
        // order.

        if (pPD->pulDevPalCol && !RMInitDevicePal(pPDev,pPD))
        {
            ERR(("Unidrv!BInitPalDevInfo:RMInitDevicePal Failed to init device palette\n"));
            goto ErrorExit;
        }

    }


    //Now Set various common fields in  devinfo and gdiinfo.
    if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
        pdevinfo->hpalDefault = EngCreatePalette( PAL_RGB,
                                                0, 0,   0, 0, 0 );
    else
        pdevinfo->hpalDefault = EngCreatePalette( PAL_INDEXED,
                                                pPD->wPalGdi, pPD->ulPalCol,
                                                                0, 0, 0 );

    //
    // Save the Palette Handle. We will need this to delete the palette.
    //
    pPD->hPalette = pdevinfo->hpalDefault;

    if (pdevinfo->hpalDefault == (HPALETTE) NULL)
    {
        ERR(("Unidrv!BInitPalDevInfo: NULL palette.\n"));
        goto ErrorExit;
    }
    pGDIInfo->ulNumPalReg = pPD->wPalGdi;

    //
    // For  Monochrome mode, enable dither text only on 600 higher resolution 
    // printer and in non N-UP mode.
    // For Color mode, enable dither text only on 300 higher resolution printer 
    // and in non N-UP mode.
    // The threshold values, 600 dpi for mono and 300 dpi for color,
    // were determined not theoritically, but through try-and-erro procedure.
    // We don't know for sure that these values are perfectly value in all
    // situations.
    //
    // Now new GPD keyword "TextHalftoneThreshold is available.
    // If GPD file sets a value for the new keyword and the current resolution
    // is the same as dwTextHalftoneThreshold or greater, set GCAPS_ARBRUSHTEXT 
    //
    if (pPDev->pGlobals->dwTextHalftoneThreshold)
    {
        if (pPDev->ptGrxRes.x >= (LONG)pPDev->pGlobals->dwTextHalftoneThreshold
#ifndef WINNT_40
                && ( pPDev->pdmPrivate->iLayout == ONE_UP ))
#endif
        {
            pdevinfo->flGraphicsCaps  |= GCAPS_ARBRUSHTEXT ;
        }
    }
    else
    {
        if (pPD->fFlags & PDF_PALETTE_FOR_1BPP)
        {
            //
            // Monochrome
            //
            if (( pPDev->ptGrxRes.x >= 600 &&
                  pPDev->ptGrxRes.y >= 600 )
#ifndef WINNT_40
                && ( pPDev->pdmPrivate->iLayout == ONE_UP )
#endif
               )
                pdevinfo->flGraphicsCaps  |= GCAPS_ARBRUSHTEXT ;
        }
        else
        {
            //
            // Color
            //
            if (( pPDev->ptGrxRes.x >= 300 &&
                  pPDev->ptGrxRes.y >= 300 )
#ifndef WINNT_40
                && ( pPDev->pdmPrivate->iLayout == ONE_UP )
#endif
               )
                pdevinfo->flGraphicsCaps  |= GCAPS_ARBRUSHTEXT ;
        }
    }



    return TRUE;

    ErrorExit:
    if (pPD)
    {
        if (pPD->pulDevPalCol)
            MemFree(pPD->pulDevPalCol);
        MemFree(pPD);
        pPDev->pPalData = NULL;
    }
    return FALSE;
}


LONG
LSetupPalette (
    PDEV        *pPDev,
    PAL_DATA    *pPD,
    DEVINFO     *pdevinfo,
    GDIINFO     *pGDIInfo
    )
 /*++
 Routine Description:
    LSetupPalette
        Function to read in the 256 color palette from GDI into the
        palette data structure in Dev Info.

 Arguments:
    pPD         : Pointer to PALDATA.
    pdevinfo    : DEVINFO  pointer.
    pGDIInfo    : GDIINFO Pointer.

Return Value:
    The number of colors in the palette. Returns 0 if the call fails.

Note:

    4/7/1997 -ganeshp-
        Created it.
--*/
{

    long    lRet = 0;
    int     _iI;


    if (pPD->fFlags & PDF_PALETTE_FOR_1BPP)
    {
        /*
         *   Monochrome printer,  so there are only 2 colours,  black
         *  and white.  It would be nice if the bitmap was set with
         *  black as 1 and white as 0.  HOWEVER,  there are presumptions
         *  all over the place that 0 is black.  SO,  we set them to
         *  the preferred way,  then invert before rendering.
         */

        lRet = pPD->wPalGdi        = 2;
        pPD->ulPalCol[ 0 ]         = RGB(0x00, 0x00, 0x00);
        pPD->ulPalCol[ 1 ]         = RGB(0xff, 0xff, 0xff);
        pPD->iWhiteIndex           = 1;
        pPD->iBlackIndex           = 0;

        pdevinfo->iDitherFormat    = BMF_1BPP;    /* Monochrome format */
        pdevinfo->flGraphicsCaps  |= GCAPS_FORCEDITHER;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_1BPP;

        if ( COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY))
        {
            pPDev->fMode |= PF_ANYCOLOR_BRUSH;
        }
        //Set the monochrome brush attributes.
        //CODE_COMPLETE VSetMonochromeBrushAttributes(pPDev);

    }
    else if (pPD->fFlags & PDF_PALETTE_FOR_4BPP)
    {
        /*
         *   We appear to GDI as an RGB surface, regardless of what
         *  the printer is.  CMY(K) printers have their pallete
         *  reversed at rendering time.  This is required for Win 3.1
         *  compatability and many things assume an RGB palette, and
         *  break if this is not the case.
         *
         *          DC_PRIMARY_RGB
         * ------------------------------------------
         * Index 0 = Black
         * Index 1 = Red
         * Index 2 = Green
         * Index 3 = Yellow
         * Index 4 = Blue
         * Index 5 = Magenta
         * Index 6 = Cyan
         * Index 7 = White
         *--------------------------------------------
         * Bit 0   = Red
         * Bit 1   = Green
         * Bit 2   = Blue
         *
         *   If a separate black dye is available,  this can be arranged
         * to fall out at transpose time - we have a slightly different
         * transpose table to do the work.
         */

        /*
         *    Many apps and the engine presume an RGB colour model, so
         *  we pretend to be one!  We invert the bits at render time.
         */

        pPD->iWhiteIndex = 7;
        pPD->iBlackIndex = 0;

        /*
         *      Set the palette colours.  Remember we are only RGB format.
         *  NOTE that gdisrv requires us to fill in all 16 entries,
         *  even though we have only 8.  So the second 8 are a duplicate
         *  of the first 8.
         */
        pPD->ulPalCol[ 0 ] = RGB( 0x00, 0x00, 0x00 );
        pPD->ulPalCol[ 1 ] = RGB( 0xff, 0x00, 0x00 );
        pPD->ulPalCol[ 2 ] = RGB( 0x00, 0xff, 0x00 );
        pPD->ulPalCol[ 3 ] = RGB( 0xff, 0xff, 0x00 );
        pPD->ulPalCol[ 4 ] = RGB( 0x00, 0x00, 0xff );
        pPD->ulPalCol[ 5 ] = RGB( 0xff, 0x00, 0xff );
        pPD->ulPalCol[ 6 ] = RGB( 0x00, 0xff, 0xff );
        pPD->ulPalCol[ 7 ] = RGB( 0xff, 0xff, 0xff );
        //
        // These palette entries will cause really light
        // colors to map to the correct color instead of white
        pPD->ulPalCol[ 8 ] = RGB( 0xef, 0xef, 0xef );
        pPD->ulPalCol[ 9 ] = RGB( 0xff, 0xe7, 0xe7 );
        pPD->ulPalCol[10 ] = RGB( 0xe7, 0xff, 0xe7 );
        pPD->ulPalCol[11 ] = RGB( 0xf7, 0xf7, 0xdf );
        pPD->ulPalCol[12 ] = RGB( 0xe7, 0xe7, 0xff );
        pPD->ulPalCol[13 ] = RGB( 0xf7, 0xdf, 0xf7 );
        pPD->ulPalCol[14 ] = RGB( 0xdf, 0xf7, 0xf7 );
        pPD->ulPalCol[15 ] = RGB( 0xff, 0xff, 0xff );

        lRet = pPD->wPalGdi        = 16;
        pdevinfo->iDitherFormat    = BMF_4BPP;
        pdevinfo->flGraphicsCaps  |= GCAPS_FORCEDITHER;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_4BPP;

    }
    else if (pPD->fFlags & PDF_PALETTE_FOR_8BPP)
    {

        // 8 Bit Mode.

        PALETTEENTRY  pe[ 256 ];      /* 8 bits per pel - all the way */
        FillMemory (pe, sizeof (pe), 0xff);
#ifndef WINNT_40
        if (pPDev->pColorModeEx->bColor == FALSE)
        {
            HT_SET_BITMASKPAL2RGB(pe);
            lRet = HT_Get8BPPMaskPalette(pe,TRUE,0x0,10000,10000,10000);
        }
        else
#endif
            lRet = HT_Get8BPPFormatPalette(pe,
                                      (USHORT)pGDIInfo->ciDevice.RedGamma,
                                      (USHORT)pGDIInfo->ciDevice.GreenGamma,
                                      (USHORT)pGDIInfo->ciDevice.BlueGamma );
    #if PRINT_INFO
        DbgPrint("RedGamma = %d, GreenGamma = %d, BlueGamma = %d\n",(USHORT)pGDIInfo->ciDevice.RedGamma, (USHORT)pGDIInfo->ciDevice.GreenGamma, (USHORT)pGDIInfo->ciDevice.BlueGamma);
    #endif

        if( lRet < 1 )
        {
            ERR(( "Unidrv!LSetupPalette:HT_Get8BPPFormatPalette returns %ld\n", lRet ));
            return(0);
        }
        /*
         *    Convert the HT derived palette to the engine's desired format.
         */

        for( _iI = 0; _iI < lRet; _iI++ )
        {
            pPD->ulPalCol[ _iI ] = RGB( pe[ _iI ].peRed,
                                        pe[ _iI ].peGreen,
                                        pe[ _iI ].peBlue );
        #if  PRINT_INFO
            DbgPrint("Palette entry %d= (r = %d, g = %d, b = %d)\n",_iI,pe[ _iI ].peRed, pe[ _iI ].peGreen, pe[ _iI ].peBlue);

        #endif

        }

        pPD->wPalGdi               = (WORD)lRet;
        pdevinfo->iDitherFormat    = BMF_8BPP;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_8BPP;

#ifndef WINNT_40
        if (pPDev->pColorModeEx->bColor == FALSE)
        {
            pGDIInfo->flHTFlags |= HT_FLAG_USE_8BPP_BITMASK;
            pPD->fFlags |= PDF_PALETTE_FOR_8BPP_MONO;
            if (HT_IS_BITMASKPALRGB(pe))
            {
#if DBGROP
                DbgPrint ("New 8BPP GDI monochrome mode\n");            
#endif                
                pGDIInfo->flHTFlags |= HT_FLAG_INVERT_8BPP_BITMASK_IDX;
                pPD->iBlackIndex = 0;
                pPD->iWhiteIndex = 255;
            }
            else
            {
#if DBGROP
                DbgPrint ("Old 8BPP GDI monochrome mode\n");
#endif                
                pPDev->fMode2 |= PF2_INVERTED_ROP_MODE;
                pPD->ulPalCol[255] = RGB (0x00, 0x00, 0x00);
                pPD->iBlackIndex = 255;
                pPD->ulPalCol[ 0 ] = RGB (0xff, 0xff, 0xff);
                pPD->iWhiteIndex = 0;
            }
        }
        else
#endif
        {
            // Make the 0 index white as most of the printers do ZERO_FILL.
            pPD->ulPalCol[ 7 ]      = RGB (0x00, 0x00, 0x00);
            pPD->iBlackIndex        = 7;
            pPD->ulPalCol[ 0 ]      = RGB (0xff, 0xff, 0xff);
            pPD->iWhiteIndex        = 0;
        }
    }
    else if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
    {
        // we fill the palette entries with -1, so that we know which
        // index is programmed.

        pPD->wPalGdi               = PALETTE_SIZE_24BIT;
        pPD->iWhiteIndex           = 0x00ffffff;
        pdevinfo->iDitherFormat    = BMF_24BPP;
        pGDIInfo->ulPrimaryOrder   = PRIMARY_ORDER_CBA;
        pGDIInfo->ulHTOutputFormat = HT_FORMAT_24BPP;
        FillMemory( pPD->ulPalCol, (PALETTE_MAX * sizeof(ULONG)), 0xff );

        //
        // Fix the first seven colors to primary colors. Render modules
        // assume that index 7 is black.
        //

        pPD->ulPalCol[ 0 ]      = RGB (0xff, 0xff, 0xff);
        pPD->ulPalCol[ 1 ]      = RGB( 0xff, 0x00, 0x00 );
        pPD->ulPalCol[ 2 ]      = RGB( 0x00, 0xff, 0x00 );
        pPD->ulPalCol[ 3 ]      = RGB( 0xff, 0xff, 0x00 );
        pPD->ulPalCol[ 4 ]      = RGB( 0x00, 0x00, 0xff );
        pPD->ulPalCol[ 5 ]      = RGB( 0xff, 0x00, 0xff );
        pPD->ulPalCol[ 6 ]      = RGB( 0x00, 0xff, 0xff );
        pPD->ulPalCol[ 7 ]      = RGB (0x00, 0x00, 0x00);

        lRet = 1;

    }
    else
        ERR(( "Unidrv!LSetupPalette:Unknown Palette Format\n"));

    return lRet;
}

VOID VInitPal8BPPMaskMode(
    PDEV   *pPDev,
    GDIINFO *pGdiInfo
    )
/*++
Routine Description:
    Updates the driver palette if an OEM has requested 8bpp color mask mode.

Arguments:
    pPDev    Pointer to PDEV
    pGDIInfo Pointer to GDIINFO

Return Value:
    Nothing

Note:

    10/23/2000 -alvins-
        Created it.
--*/

{
        ULONG i,lRet;
        PAL_DATA *pPD = (PAL_DATA *)pPDev->pPalData;
        PALETTEENTRY  pe[256];
            
        FillMemory (pe, sizeof (pe), 0xff);
        //
        // only request inverted palette if requested by OEM
        //
        if (pGdiInfo->flHTFlags & HT_FLAG_INVERT_8BPP_BITMASK_IDX)
        {
            HT_SET_BITMASKPAL2RGB(pe);
        } 
        //
        // Get color mask palette and map to internal format
        //   
        lRet = HT_Get8BPPMaskPalette(pe,TRUE,(BYTE)(pGdiInfo->flHTFlags >> 24),10000,10000,10000);
        for( i = 0; i < lRet; i++ )
        {
            pPD->ulPalCol[i] = RGB( pe[i].peRed,pe[i].peGreen,pe[i].peBlue );
        }
        //
        // test whether inverted palette is active
        //
        if (HT_IS_BITMASKPALRGB(pe))
        {
            pPD->iBlackIndex = 0;
            pPD->iWhiteIndex = 255;
        }
        else
        {
            pPDev->fMode2 |= PF2_INVERTED_ROP_MODE;
            pPD->iBlackIndex = 255;
            pPD->iWhiteIndex = 0;
        }                        
}

VOID
VLoadPal(
    PDEV   *pPDev
    )
/*++
Routine Description:
    Download the palette to the printer if the colormode has programmable
    palette. Takes the colors from PALDATA which was setup during DrvEnablePDEV.

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    Nothing

Note:

    4/7/1997 -ganeshp-
        Created it.
--*/

{
    /*
     *   Program the palette according to PCL5 spec.
     *   The syntax is Esc*v#a#b#c#I
     *      #a is the first color component
     *      #b is the second color component
     *      #c is the third color component
     *      #I assigns the color to the specified palette index number
     *   For example, Esc*v0a128b255c5I assigns the 5th index
     *   of the palette to the color 0, 128, 255
     *
     */


    PAL_DATA    *pPD;
    INT         iEntriesToProgram, iI;
    ULONG       *pPalette;

    pPD = pPDev->pPalData;

    if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
    {
        FillMemory( pPD->ulPalCol, (PALETTE_MAX * sizeof(ULONG)), 0xff );

        //
        // Fix the first seven colors to primary colors. Render modules
        // assume that index 7 is black.
        //

        pPD->ulPalCol[ 0 ]      = RGB (0xff, 0xff, 0xff);
        pPD->ulPalCol[ 1 ]      = RGB( 0xff, 0x00, 0x00 );
        pPD->ulPalCol[ 2 ]      = RGB( 0x00, 0xff, 0x00 );
        pPD->ulPalCol[ 3 ]      = RGB( 0xff, 0xff, 0x00 );
        pPD->ulPalCol[ 4 ]      = RGB( 0x00, 0x00, 0xff );
        pPD->ulPalCol[ 5 ]      = RGB( 0xff, 0x00, 0xff );
        pPD->ulPalCol[ 6 ]      = RGB( 0x00, 0xff, 0xff );
        pPD->ulPalCol[ 7 ]      = RGB (0x00, 0x00, 0x00);
    }

    if (pPD->fFlags & PDF_DOWNLOAD_GDI_PALETTE)
    {


        if (pPD->wPalDev > PALETTE_MAX)
        {
            WARNING(("Unidrv!vLoadPal: Invalid number of palette entries to program\n"));
            pPD->wPalDev = PALETTE_MAX;
        }
        if (pPD->pulDevPalCol)
            pPalette = pPD->pulDevPalCol;
        else if (pPD->fFlags & PDF_PALETTE_FOR_OEM_24BPP)
            pPalette = &pPD->ulPalCol[PALETTE_SIZE_24BIT];
        else
            pPalette = pPD->ulPalCol;


        if (pPD->fFlags & PDF_PALETTE_FOR_8BPP)
            iEntriesToProgram = min(256,pPD->wPalDev);
        else
            iEntriesToProgram = min(pPD->wPalDev,pPD->wPalGdi);

        // Start palette definition.

        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEDEF));

        // if only one entry, program it to black
        //
        if (iEntriesToProgram == 1)
        {
            pPDev->dwRedValue = RED_VALUE(RGB_BLACK_COLOR);
            pPDev->dwGreenValue = GREEN_VALUE(RGB_BLACK_COLOR);
            pPDev->dwBlueValue = BLUE_VALUE(RGB_BLACK_COLOR);
            pPDev->dwPaletteIndexToProgram = 0;
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY));
        }
        else
        {
            // Download each palette entry.
            for( iI = 0; iI < iEntriesToProgram; ++iI )
            {
                //pPDev->dwRedValue =RED_VALUE ((pPD->ulPalCol [iI] ^ 0x00FFFFFF));
                //pPDev->dwGreenValue = GREEN_VALUE ((pPD->ulPalCol [iI] ^ 0x00FFFFFF));
                //pPDev->dwBlueValue =  BLUE_VALUE ((pPD->ulPalCol [iI] ^ 0x00FFFFFF));

                pPDev->dwRedValue =RED_VALUE((pPalette[iI]));
                pPDev->dwGreenValue = GREEN_VALUE((pPalette[iI]));
                pPDev->dwBlueValue =  BLUE_VALUE((pPalette[iI]));
                pPDev->dwPaletteIndexToProgram = iI;

                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY));
            }

        }

        // Send End Palette definition command.
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_ENDPALETTEDEF));

    }


    return;
}

BOOL
BSelectProgrammableBrushColor(
    PDEV   *pPDev,
    ULONG   Color
    )
/*++
Routine Description:
    Sets the brush color to give color.
Arguments:
    pPDev   Pointer to PDEV
    Color   Input Color to select. If it's -1 that means restore the palette
            to original state.

Return Value:
    TRUE for success and FALSE for failure or if the palette can't be programmed.

Note:

    4/9/1997 -ganeshp-
        Created it.
--*/

{
    INT         iIndex;
    INT         iPaletteEntryToSelect;
    PAL_DATA    *pPD;
    BOOL        bProgramEntry = FALSE;
    BOOL        bSelectEntry  = TRUE;
    ULONG       *pPalette;
    INT         iWhiteIndex;


    FTRACE(TRACING  BSelectProgrammableBrushColor);
    FVALUE(Color,0x%x);

    if (pPDev->fMode & PF_ANYCOLOR_BRUSH)
    {
        pPD = pPDev->pPalData;

        if (pPD->pulDevPalCol)
            pPalette = pPD->pulDevPalCol;
        else if (pPD->fFlags & PDF_PALETTE_FOR_OEM_24BPP)
            pPalette = &pPD->ulPalCol[PALETTE_SIZE_24BIT];
        else
            pPalette = pPD->ulPalCol;

        //
        // iWhiteIndex in 24 bit mode is set to the real color (0x00FFFFFF) and
        // not the index. We need to take care of this case. In this mode
        // white is programmed in 0 index, so we will use this number instead
        // of pPD->iWhiteIndex.
        //

        if (pPD->fFlags & PDF_PALETTE_FOR_24BPP)
            iWhiteIndex = 0;
        else
            iWhiteIndex =  pPD->iWhiteIndex;
        FVALUE(iWhiteIndex,%d);

        // Check for Black or white color. As we can directly select the colors.
        // Also check if the White index has to be reprogrammed.
        // This should be done for non 24 bit mode.

        if (Color == INVALID_COLOR)
        {
            // Set the BrushColor to invalid,so that next time we always
            // program the input color.

            pPDev->ctl.ulBrushColor = Color;

            if ( pPDev->fMode & PF_RESTORE_WHITE_ENTRY )  //Special restore case.
            {
                iPaletteEntryToSelect = (pPD->pulDevPalCol) ?
                                        pPD->wIndexToUse : iWhiteIndex;
                bProgramEntry = TRUE;
                bSelectEntry  = FALSE;
                pPDev->fMode &= ~PF_RESTORE_WHITE_ENTRY; //Clear the Flag.
                Color = RGB_WHITE_COLOR;
                FTRACE(Restoring White Entry);
            }
            else
                return TRUE; //Don't do any thing if color is -1 and flag is not set.

        }

        if( (Color != INVALID_COLOR) && (ULONG)Color != pPDev->ctl.ulBrushColor )
        {
            iPaletteEntryToSelect = pPD->wIndexToUse;

            // Search the Palette for the color unless palette size is 1

            if (pPD->wPalDev == 1)
            {
                bProgramEntry = TRUE;
                pPD->wIndexToUse = iIndex = 0;
            }
            else
            {
                for (iIndex = 0; iIndex < pPD->wPalDev; iIndex++ )
                {
                    if (pPalette[iIndex] == Color) //Color is matched.
                    {
                        FTRACE(Color is found in palette.);
                        FVALUE(iIndex,%d);

                        break;
                    }
                }

            }

            //Check if there was a match in the palette. If there is no match
            //then programme a entry else use the matched one.

            if (iIndex == pPD->wPalDev) //No Match
            {
                FTRACE(Color is not found in palette.Programme the Palette.);

                bProgramEntry = TRUE;
                if (!(pPD->fFlags & PDF_USE_WHITE_ENTRY))
                {
                    FTRACE(Palette has spare entries to programme);

                    iPaletteEntryToSelect = (pPD->wIndexToUse < pPD->wPalDev) ?
                                            pPD->wIndexToUse :
                                            (pPD->wIndexToUse = pPD->wPalGdi );
                    pPD->wIndexToUse++;

                }
                else // Use White Entry to reprogramme the color
                {
                    FTRACE(Palette does not have spare entries to program.);
                    FTRACE(Using White entry to program.);

                    pPDev->fMode |= PF_RESTORE_WHITE_ENTRY;

                    //If initialized use it else find white.
                    if (pPD->wIndexToUse != INVALID_INDEX)
                        iPaletteEntryToSelect = pPD->wIndexToUse;
                    else if (pPD->pulDevPalCol) //If there is a separate device pal use it.
                    {
                        //Remember the White Index.
                        for (iIndex = 0; iIndex < pPD->wPalDev; iIndex++ )
                        {
                            if (pPalette[iIndex] == RGB_WHITE_COLOR)
                            {
                                pPD->wIndexToUse =
                                iPaletteEntryToSelect = iIndex;
                                break;
                            }
                        }
                        if (iIndex == pPD->wPalDev)  //No White Found,use the Last entry.
                        {
                            WARNING(("Unidrv!BSelectBrushColor: No White entry in device Palette.\n"));
                            pPD->wIndexToUse =
                            iPaletteEntryToSelect = iIndex -1;
                        }
                    }
                    else
                        pPD->wIndexToUse =
                        iPaletteEntryToSelect = min((PALETTE_MAX-1),iWhiteIndex);
                }

                FVALUE(pPD->wIndexToUse,%d);
            }
            else  //Color is Matched.
                iPaletteEntryToSelect = iIndex;

            FVALUE(iPaletteEntryToSelect,%d);
            ASSERTMSG((iPaletteEntryToSelect < PALETTE_MAX),("\n iPaletteEntryToSelect should always be less than PALETTE_MAX.\n"));
        }
        else
            bSelectEntry = FALSE; //The color is already selected.

        //If we have to program a palette entry, do it now.
        if (bProgramEntry)
        {
            //
            // Make sure that we don't overrun the palette.
            //
            if (iPaletteEntryToSelect >= PALETTE_MAX)
                iPaletteEntryToSelect = PALETTE_MAX-1;

            pPDev->dwRedValue = RED_VALUE (Color);
            pPDev->dwGreenValue = GREEN_VALUE (Color);
            pPDev->dwBlueValue =  BLUE_VALUE (Color);
            pPDev->dwPaletteIndexToProgram = iPaletteEntryToSelect;
            pPalette[iPaletteEntryToSelect] = Color;
            if(COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEREDEF))
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_BEGINPALETTEREDEF));
            if(COMMANDPTR(pPDev->pDriverInfo, CMD_REDEFINEPALETTEENTRY))
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_REDEFINEPALETTEENTRY));
            else
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_DEFINEPALETTEENTRY));
            if(COMMANDPTR(pPDev->pDriverInfo, CMD_ENDPALETTEREDEF))
                WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_ENDPALETTEREDEF));

        }

        //Now Select the color.
        if (bSelectEntry)
        {
            pPDev->dwCurrentPaletteIndex = iPaletteEntryToSelect;
            WriteChannel (pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTPALETTEENTRY));
            //Set the BrushColor to new color.
            pPDev->ctl.ulBrushColor = Color;

        }
        FTRACE(End Tracing BSelectProgrammableBrushColor\n);

        return TRUE;
    }
    return FALSE;

}


VOID
VResetProgrammableBrushColor(
    PDEV   *pPDev
    )
/*++
Routine Description:
    Reset the programmable palette and select the default color.
Arguments:
    pPDev   Pointer to PDEV

Return Value:
    None

Note:

    4/28/1997 -ganeshp-
        Created it.
--*/

{
    PAL_DATA    *pPD;

    pPD = pPDev->pPalData;
    if (pPDev->fMode & PF_ANYCOLOR_BRUSH)
    {
        // Special restore case.
        if ( pPDev->fMode & PF_RESTORE_WHITE_ENTRY )
            BSelectProgrammableBrushColor(pPDev, INVALID_COLOR);

        // Select the black. We should actualy select the default palette color.
        // But GPD doesn't have any entries for that.

        if ((INT)pPDev->ctl.ulBrushColor != RGB_BLACK_COLOR)
            BSelectProgrammableBrushColor(pPDev, RGB_BLACK_COLOR);

    }

}

DWORD
ConvertRGBToGrey(
    DWORD   Color
    )

/*++

Routine Description:

    This function converts an RGB value to grey

Arguments:

    Color       - Color to be checked

Return Value:

    DWORD       - grey scale RGB color

Revision History:


--*/

{
//
// convert RGB value to grey scale intensity using sRGB or NTSC values
#ifndef SRGB
    INT iIntensity = ((RED_VALUE(Color) * 54) +
                      (GREEN_VALUE(Color) * 183) +
                      (BLUE_VALUE(Color) * 19)) / 256;
#else
    INT iIntensity = ((RED_VALUE(Color) * 77) +
                      (GREEN_VALUE(Color) * 151) +
                      (BLUE_VALUE(Color) * 28)) / 256;
#endif
    return (RGB(iIntensity,iIntensity,iIntensity));
}


DWORD
BestMatchDeviceColor(
    PDEV    *pPDev,
    DWORD   Color
    )

/*++

Routine Description:

    This function find the best pen color index for the RGB color

Arguments:

    pPDev       - Pointer to our PDEV

    Color       - Color to be checked

Return Value:

    LONG        - Pen Index, this function assume 0 is always white and 1 up
                  to the max. pen is defined

Author:

    08-Feb-1994 Tue 00:23:36 created  -by-  Daniel Chou (danielc)

    23-Jun-1994 Thu 14:00:00 updated  -by-  Daniel Chou (danielc)
        Updated for non-white pen match

Revision History:


--*/

{
    UINT    Count;
    UINT    RetIdx;
    PAL_DATA    *pPD;

    pPD = pPDev->pPalData;
    RetIdx = pPD->iBlackIndex; //Default to black.

    if (Count = (UINT)(pPD->wPalGdi))
    {
        LONG    LeastDiff;
        LONG    R;
        LONG    G;
        LONG    B;
        UINT    i;
        LPDWORD pPal      = (LPDWORD)pPD->ulPalCol;
        //
        // find closest intensity match since this is monochrome mapping
        //
        if (pPD->fFlags & PDF_PALETTE_FOR_8BPP_MONO)
            Color = ConvertRGBToGrey(Color);
        //
        // find closest color using least square distance in RGB
        //

        LeastDiff = (3 * (256 * 256));
        R         = RED_VALUE(Color);
        G         = GREEN_VALUE(Color);
        B         = BLUE_VALUE(Color);

        for (i = 0; i < Count; i++, pPal++) {

            LONG    Temp;
            LONG    Diff;
            DWORD   Pal;

            Pal = *pPal;

            if (Color == 0x00FFFFFF) {

                //
                // White Color we want to exact match
                //

                if (Color == Pal) {
                    RetIdx = i;
                    break;
                }

            }
            else if (Pal != 0x00FFFFFF) {

                //
                // The Color is not white, so map to one of non-white color
                //

                Temp  = R - (LONG)RED_VALUE(Pal);
                Diff  = Temp * Temp;

                Temp  = G - (LONG)GREEN_VALUE(Pal);
                Diff += Temp * Temp;

                Temp  = B - (LONG)BLUE_VALUE(Pal);
                Diff += Temp * Temp;

                if (Diff < LeastDiff) {

                    RetIdx = i;

                    if (!(LeastDiff = Diff)) {

                        //
                        // We have exact match
                        //

                        break;
                    }
                }
            }
        }
    }

    return((DWORD)RetIdx);
}

#if CODE_COMPLETE
VOID
VSetMonochromeBrushAttributes(
    PDEV   *pPDev
    )
/*++
Routine Description:
    This routine sets the monochrome brush attributes.

Arguments:
    pPDev   Pointer to PDEV

Note:

    4/21/1997 -ganeshp-
        Created it.
--*/
{
    PAL_DATA    *pPD = pPDev->pPalData;

    if (pPD)
    {
        // Check if the printer supports Fill rectangle command or not. We also
        // check for min and max gray level. Min should be less than max.
        if ( COMMANDPTR(pPDev->pDriverInfo,CMD_SELECTGRAYPATTERN) &&
             (pPDev->pGlobals->dwMinPatternGrayLevel <
              pPDev->pGlobals->dwMaxPatternGrayLevel) )
        {
            pPDev->fMode |= PF_GRAY_BRUSH;

            // If White is not supported by gray level command, check if a
            // separate command for white text simulation or not.

            if ( (pPDev->pGlobals->dwMinPatternGrayLevel > 0)
            {
                //
                // If the device doesn't support white as grey level
                // then some other command has to be used for white.
                // check if there is CMD_WHITEPATTERN command or not.
                // If the device doesn't have this command, try for
                // font simulation WHITE_TEXT_ON command.
                //

                if (COMMANDPTR(pPDev->pDriverInfo,CMD_SELECTWHITEPATTERN))
                    pPD->fFlags |= PDF_USE_WHITE_PATTERN;

                /***TODEL****
                else if (COMMANDPTR(pPDev->pDriverInfo,CMD_WHITETEXTON))
                    pPD->fFlags |= PDF_USE_WHITE_TEXT_ON_SIM;
                ****TODEL****/
            }
            if ( (pPDev->pGlobals->dwMaxGrayFill < 100)
            {
                //
                // If the device doesn't support black as grey level
                // then some other command has to be used for black.
                // check if there is CMD_BLACKPATTERN command or not.
                // If the device doesn't have this command, try for
                // font simulation WHITE_TEXT_OFF command.
                //

                if (COMMANDPTR(pPDev->pDriverInfo,CMD_WHITEPATTERN))
                    pPD->fFlags |= PDF_USE_BLACK_PATTERN;
                /***TODEL****
                else if (COMMANDPTR(pPDev->pDriverInfo,CMD_WHITETEXTON))
                    pPD->fFlags |= PDF_USE_WHITE_TEXT_OFF_SIM;
                ****TODEL****/
            }
        }

    }
    else
    {
        ASSERTMSG(FALSE,("\n VSetMonochromeBrushAttributes pPDev->pPalData in NULL!!.\n"));
    }

}

BOOL
BInitPatternScope(
    PDEV   *pPDev
    )
/*++
Routine Description:
    Initialize the  scope of the pattern/brush. This is necessary
Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    4/22/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet = TRUE;
    PLISTNODE   pListNode;
    PAL_DATA    *pPD = pPDev->pPalData;


    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liPatternScopeList ) )
    {
        while (pListNode)
        {
            // Check the pattern scope and set the corresponding bit in fScope.
            switch (pListNode->dwData)
            {
            case PATTERN_SCOPE_TEXT:
                pPD->fScope |= PDS_TEXT;
                break;
            case PATTERN_SCOPE_VECTOR:
                pPD->fScope |= PDS_VECTOR;
                break;
            case PATTERN_SCOPE_RASTER:
                pPD->fScope |= PDS_RASTER;
                break;
            case PATTERN_SCOPE_RECTFILL:
                pPD->fScope |= PDS_RECTFILL;
                break;
            case PATTERN_SCOPE_LINE:
                pPD->fScope |= PDS_LINE;
                break;
            default:
                ERR(("Unidrv!BInitPatternScope: Wrong value in PatternScope List\n"));
                bRet = FALSE;
                break;

            }
            if (bRet)
                pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
            else
                break; //Error
        }
    }

    return bRet;
}

BOOL
BSelectMonochromeBrush(
    PDEV   *pPDev,
    ULONG   Color
    )
/*++
Routine Description:
    Sets the brush color to give color.
Arguments:
    pPDev   Pointer to PDEV
    Color   Input Color to select. If it's -1 that means restore the palette
            to original state.

Return Value:
    TRUE for success and FALSE for failure or if the palette can't be programmed.

Note:

    4/9/1997 -ganeshp-
        Created it.
--*/

{
    INT         iIndex;
    INT         iPaletteEntryToSelect;
    PAL_DATA    *pPD;
    BOOL        bProgramEntry = FALSE;
    BOOL        bSelectEntry  = TRUE;
    ULONG       *pPalette;
}
#endif //CODE_COMPLETE

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\physical.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    physical.c

Abstract:

    Support the following functions related to sending data to the printer
    and print head movements, cursor control.

        WriteSpoolBuf
        WriteAbortBuf
        FlushSpoolBuf
        WriteChannel
        WriteChannelEx
        XMoveTo
        YMoveTo

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

--*/
#include "unidrv.h"

static  int itoA(  LPSTR , int );
INT IGetNumParameter( BYTE *, INT);
BOOL BUniWritePrinter(
    IN PDEV*  pPDev,
    IN LPVOID pBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcbWritten);

#define  DELTA_X  (pPDev->dwFontWidth/2)
#define  DELTA_Y  (dwMaxLineSpacing /5)


WriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    )
/*++

Routine Description:

    This is an intermediate routine for Unidrv to send characters to
    the printer via the spooler.  All characters must be sent through
    the WriteSpool( ) call.  WriteSpoolBuf is internal so that Unidrv
    can buffer up short command streams before calling WriteSpool.
    This routine also checks for error flags returned from WriteSpool.

Arguments:

    pPDev - Pointer to PDEVICE struct
    pbBuf - Pointer to buffer containing data to be sent
    iCount - Count of number of bytes to send

Return Value:

    The number of bytes sent to the printer

--*/

{
    DWORD dw;

    //
    // Check for aborted output
    //

    if( pPDev->fMode & PF_ABORTED )
        return   0;

    //
    // If the output buffer cannot accomodate the current request,
    // flush the content of the buffer first.
    //

    if( (pPDev->iSpool)   &&  (pPDev->iSpool + iCount > CCHSPOOL ))
    {
        if( !FlushSpoolBuf( pPDev ) )
        {
            WriteAbortBuf(pPDev, pPDev->pbOBuf, pPDev->iSpool, 0) ;
            pPDev->iSpool = 0;
            return  0;   // at least send previously cached stuff.
        }
    }

    //
    // Check whether request is larger than output buffer, if so, skip buffering
    // and write directly to spooler.
    //

    if( iCount >= CCHSPOOL )
    {
        if( !BUniWritePrinter( pPDev, pbBuf, iCount, &dw ) )
        {
            pPDev->iSpool = 0;
            pPDev->fMode |= PF_ABORTED;
            iCount = 0;
        }
    }
    else
    {
        //
        // buffer up the output
        //

        if( pPDev->pbOBuf  == NULL)
                return  0;


        CopyMemory( pPDev->pbOBuf + pPDev->iSpool, pbBuf, iCount );
        pPDev->iSpool += iCount;
    }


    return iCount;
}

VOID  WriteAbortBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount,
    DWORD       dwWait
    )
{
    DWORD   dwCount = 0;
    HMODULE   hInst ;
    typedef   BOOL    (*PFNFLUSHPR)( HANDLE   hPrinter,
          LPVOID   pBuf,
          DWORD    cbBuf,
          LPDWORD pcWritten,
          DWORD    cSleep)  ;

    //
    // Call FlushPrinter only if there is no plugin hooking WritePrinter .
    // One of plug-ins hooks WritePrinter, the plug-in need to call FlushPrinter.
    // In that case, UNIDRV should not call FlushPrinter.
    //
    if( pPDev->fMode & PF_ABORTED &&
        !(pPDev->fMode2 & PF2_WRITE_PRINTER_HOOKED))
    {
#ifdef  WINNT_40
        ;   //  Pretend we flushed
#else

        BOOL bRet;
        do 
        {
            bRet = FlushPrinter(pPDev->devobj.hPrinter, pbBuf, iCount, &dwCount, dwWait);
            pbBuf += dwCount;
            iCount -= dwCount;
        } while (bRet && iCount > 0 && dwCount > 0);
#endif
    }
}

BOOL
FlushSpoolBuf(
    PDEV    *pPDev
    )
/*++

Routine Description:

    This function flush our internal buffer.

Arguments:

    pPDev - Pointer to PDEVICE struct

Return Value:

    TRUE if successful , otherwise FALSE

--*/
{

    DWORD   dwCount;
    //
    // Check for aborted output
    //

    if( pPDev->fMode & PF_ABORTED )
        return   0;


    //
    // Write the data out
    //

    if( pPDev->iSpool )
    {
        if ( !BUniWritePrinter(pPDev, pPDev->pbOBuf, pPDev->iSpool, &dwCount) )
        {
            pPDev->fMode |= PF_ABORTED;
            return  FALSE;
        }
        pPDev->iSpool = 0;
    }
    return  TRUE;
}


INT
XMoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the X position.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iXIn  - Number of units to move in X direction
    fFlag - Specifies the different X move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{
    int   iX, iFineValue, iDiff = 0;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    int iScale;

    //
    // If the position is given in graphics units, convert to master units
    //
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.y;
    else
        iScale = pPDev->ptGrxScale.x;

    if ( fFlag & MV_GRAPHICS )
    {
        iXIn = (iXIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iX = iXIn;

    //
    // Basically, only adjust if we are doing absolute move
    //

    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iX += pPDev->sf.ptPrintOffsetM.x;

    //
    // If it's a relative move, update iX (iX will be the absolute position)
    // to reflect the current cursor position
    //

    if ( fFlag & MV_RELATIVE )
        iX += pPDev->ctl.ptCursor.x;


    //By definition a negative absolute move relative to Imageable origin
    //is not allowed.   But the MV_FORCE_CR  flag bypasses this check.
    if(!(fFlag & MV_FORCE_CR)  &&  (iX - pPDev->sf.ptPrintOffsetM.x < 0))
        iX = pPDev->sf.ptPrintOffsetM.x ;


    //
    // Update, only update our current cursor position and return
    // Do nothing if the XMoveTo cmd is called to move to the current position.
    //

    if ( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x = iX;
        return 0;
    }

    if( fFlag & MV_SENDXMOVECMD )
        pPDev->ctl.dwMode |= MODE_CURSOR_X_UNINITIALIZED;

    if (!(pPDev->ctl.dwMode & MODE_CURSOR_X_UNINITIALIZED)   &&   pPDev->ctl.ptCursor.x == iX )
        return 0;


    //
    // If iX is zero and pGlobals->cxaftercr does not have
    // CXCR_AT_GRXDATA_ORIGIN set, then we send CR and reset our
    // cursor position to 0, which is the printable x origin
    //

    if (iX == 0 && (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN ||
            pPDev->sf.ptPrintOffsetM.x == 0))
    {
        pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x = 0;
        WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));
        pPDev->ctl.dwMode &= ~MODE_CURSOR_X_UNINITIALIZED;
        return 0;
    }

    //
    // Check whether we any X move cmd, PF_NO_XMOVE_CMD is set if we did
    // not see any relative or absolute x move cmds
    //

    if( pPDev->fMode & PF_NO_XMOVE_CMD)
    {
        //
        // There is no X move command(abs or relative), so we'll have to simulate
        // using blanks or null graphics data (0)
        //

        //
        // We assume that when XMoveto is called, the current font is always
        // the default font IF the printer has no X movement command.
        //

        int     iRelx = iX - pPDev->ctl.ptCursor.x ;
        int     iDefWidth;

        //
        // Convert to Master Units
        //

        //
        // BUG_BUG, Double check that we can use Default Font here when
        // we have a custom TTY driver
        //  seems to work so far.
        //


        if ( iRelx < 0   &&  (!pPDev->bTTY  ||  (DWORD)(-iRelx) > DELTA_X ))
        {
            if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                iRelx = iX;
            else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
            {
                //  printing offset is only available in the callers
                //  cooridinates so if the move is being performed
                //  in different coordinates, the offset will be wrong.
                ASSERT(!pPDev->pOrientation  ||  pPDev->pOrientation->dwRotationAngle == ROTATE_NONE  ||
                        pPDev->pGlobals->bRotateCoordinate == TRUE) ;

                iRelx = iX - pPDev->sf.ptPrintOffsetM.x;
            }

            WriteChannel( pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN ));
        }

        //
        // Simulate X Move, algorithm is that we always send a blank space
        // for every character width, and send graphics null data for
        // the remainder, in the case of TTY we skip the remaining graphics that
        // cannot be sent within a space character width.
        //

        iDefWidth = pPDev->dwFontWidth ;
        if (iDefWidth)
        {

            while(iRelx >= iDefWidth)
            {
                WriteSpoolBuf( pPDev, (LPSTR)" ", 1 );
                iRelx -= iDefWidth;
            }
        }
        else
            TERSE (("XMoveTo: iDefWidth = 0\n"));


        //
        // Send the remaining partial space  via FineXMoveTo.
        //

        if (!pPDev->bTTY)
        {
            iDiff = iRelx;
            fFlag |= MV_FINE;    // Use graphics mode to reach point
        }

    }
    else
    {
        DWORD dwTestValue  = abs(iX - pPDev->ctl.ptCursor.x);
        COMMAND *pCmd;

        //
        // X movement commmands are available,  so use them.
        // We need to decide here whether relative or absolute command
        // are favored

        //
        // General assumption: if dwTestValue > dwXMoveThreshold,
        // absolute command will be favored
        //

        //
        // BUG_BUG, if we are stripping blanks, we need to check whether
        // it's legal to move in Graphics mode.  If it's not, we have
        // to get out of graphics mode before moving.
        // Graphics module is responsible for keeping track
        // of these things, and appearently so far, things work, so
        // this is neither a bug  nor a feature request at this time.
        //

        if (((pPDev->ctl.dwMode & MODE_CURSOR_X_UNINITIALIZED) ||
            ((dwTestValue > pPDev->pGlobals->dwXMoveThreshold ) &&
             iX >= 0) ||
            !COMMANDPTR(pDrvInfo, CMD_XMOVERELRIGHT)) &&
            (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVEABSOLUTE)) != NULL)
        {
            //
            // if the move units are less than the master units then we need to
            // check whether the new position will end up being the same as the
            // original position. If so, no point in sending another command.
            //
            if (!(pPDev->ctl.dwMode & MODE_CURSOR_X_UNINITIALIZED) &&
                (pPDev->ptDeviceFac.x > 1) &&
                ((iX - (iX % pPDev->ptDeviceFac.x)) == pPDev->ctl.ptCursor.x))
            {
                iDiff = iX - pPDev->ctl.ptCursor.x;
            }
            else
            {
                // check whether the no absolute move left flag is set. If set we need
                // to send a CR before doing the absolute move.
                //
                if (iX < pPDev->ctl.ptCursor.x && pPDev->pGlobals->bAbsXMovesRightOnly)
                {
                    WriteChannel( pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN ));
                }
                pPDev->ctl.ptAbsolutePos.x = iX;
                //
                // 3/13/97 ZhanW
                // set up DestY as well in case it's needed (ex. FE printers).
                // In that case, truncation error (iDiff) is not a concern.
                // This is for backward compatibility with FE Win95 and FE NT4
                // minidrivers.
                //
                pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y;
                iDiff = WriteChannelEx(pPDev,
                                   pCmd,
                                   pPDev->ctl.ptAbsolutePos.x,
                                   pPDev->ptDeviceFac.x);

            }
        }
        else
        {
            //
            // Use relative command to send move request
            //

            INT iRelRightValue = 0;

            if( iX < pPDev->ctl.ptCursor.x )
            {
                //
                // Relative move left
                //

                if (pCmd = COMMANDPTR(pDrvInfo,CMD_XMOVERELLEFT))
                {
                    //
                    // Optimize to avoid sending 0-move cmd.
                    //
                    if ((pPDev->ctl.ptRelativePos.x =
                         pPDev->ctl.ptCursor.x - iX) < pPDev->ptDeviceFac.x)
                        iDiff = pPDev->ctl.ptRelativePos.x;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                    iDiff = -iDiff;
                }
                else
                {
                    //
                    // No Relative left move cmd, use <CR> to reach start
                    // Will try to use relative right move cmd to send later
                    //

                    WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));

                    if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                        iRelRightValue = iX;
                    else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
                    {
                        //  moveto code cannot handle case where printer cannot
                        //  rotate its coordinate system, and we are in landscape mode
                        //  and we are using relative move commands.
                        ASSERT(!pPDev->pOrientation  ||  pPDev->pOrientation->dwRotationAngle == ROTATE_NONE  ||
                                pPDev->pGlobals->bRotateCoordinate == TRUE) ;

                        iRelRightValue = iX - pPDev->sf.ptPrintOffsetM.x;
                    }
                }
            }
            else
            {
                //
                // Relative right move
                // UNIITIALZIED is an invalid position, set to zero
                //

                iRelRightValue = iX - pPDev->ctl.ptCursor.x;
            }

            if( iRelRightValue > 0 )
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVERELRIGHT))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.x = iRelRightValue) <
                        pPDev->ptDeviceFac.x)
                        iDiff = iRelRightValue;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                }
                else
                    iDiff = iRelRightValue;
            }
        }
    }


    //
    // Peform fine move command
    //

    if ( (fFlag & MV_FINE) && iDiff > 0 )
        iDiff = FineXMoveTo( pPDev, iDiff );

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x = iX -  iDiff ;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    if (pPDev->fMode & PF_RESELECTFONT_AFTER_XMOVE)
    {
        VResetFont(pPDev);
    }

    pPDev->ctl.dwMode &= ~MODE_CURSOR_X_UNINITIALIZED;
    return( iDiff);
}

INT
YMoveTo(
    PDEV    *pPDev,
    INT     iYIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the Y position.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iYIn  - Number of units to move in Y direction
    fFlag - Specifies the different Y move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{

    INT   iY, iDiff = 0;
    DWORD dwTestValue;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    COMMAND *pAbsCmd;
    INT iScale;

    //
    // Convert to Master Units if the given units is in Graphics Units
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.x;
    else
        iScale = pPDev->ptGrxScale.y;

    if ( fFlag & MV_GRAPHICS )
    {
        iYIn = (iYIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iY = iYIn;

    //
    // Basically, only adjust if we are doing absolute move
    //
    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iY += pPDev->sf.ptPrintOffsetM.y;

    //
    // Adjust iY to be the absolute position
    //

    if( fFlag & MV_RELATIVE )
        iY += pPDev->ctl.ptCursor.y;

    //
    // Update, only update our current cursor position and return
    // Do nothing if the YMoveTo cmd is called to move to the current position.
    //

    if( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y = iY;
        return 0;
    }


    if( fFlag & MV_SENDYMOVECMD )
        pPDev->ctl.dwMode |= MODE_CURSOR_Y_UNINITIALIZED;

    if(!(pPDev->ctl.dwMode  & MODE_CURSOR_Y_UNINITIALIZED)   &&  pPDev->ctl.ptCursor.y == iY )
        return 0;

    //
    // General assumption: if dwTestValue > dwYMoveThreshold,
    // absolute Y move command will be favored. Also, for iY < 0,
    // use relative command since some printers like old LaserJet have
    // printable area above y=0 accessable only through relative move cmds.
    //

    //
    // BUG_BUG, if we are stripping blanks, we need to check whether
    // it's legal to move in Graphics mode.  If it's not, we have
    // to get out of graphics mode before moving.
    // Graphics module is responsible for keeping track
    // of these things, and appearently so far, things work, so
    // this is neither a bug  nor a feature request at this time.
    //


    dwTestValue = abs(iY - pPDev->ctl.ptCursor.y);

    if (((pPDev->ctl.dwMode & MODE_CURSOR_Y_UNINITIALIZED) ||
        (dwTestValue > pPDev->pGlobals->dwYMoveThreshold &&
        iY >= 0)) &&
        (pAbsCmd = COMMANDPTR(pDrvInfo, CMD_YMOVEABSOLUTE)) != NULL)
    {
        //
        // if the move units are less than the master units then we need to
        // check whether the new position will end up being the same as the
        // original position. If so, no point in sending another command.
        //
        if (!(pPDev->ctl.dwMode & MODE_CURSOR_Y_UNINITIALIZED) &&
            (pPDev->ptDeviceFac.y > 1) &&
            ((iY - (iY % pPDev->ptDeviceFac.y)) == pPDev->ctl.ptCursor.y))
        {
            iDiff = iY - pPDev->ctl.ptCursor.y;
        }
        else
        {
            pPDev->ctl.ptAbsolutePos.y = iY;
            pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x;
            iDiff = WriteChannelEx(pPDev,
                               pAbsCmd,
                               pPDev->ctl.ptAbsolutePos.y,
                               pPDev->ptDeviceFac.y);
        }
    }
    else
    {
        DWORD dwSendCRFlags = 0;
        //
        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR 
        // before each line-spacing command
        //
        if (pPDev->fYMove & FYMOVE_SEND_CR_FIRST)
        {
            if ((pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN))
                dwSendCRFlags = MV_PHYSICAL | MV_FORCE_CR;
            else
                dwSendCRFlags = MV_PHYSICAL;
                //  in this case CR takes you to Printable origin so
                //  MV_PHYSICAL  flag should not appear.
                //  This is a bug, but we won't fix it till something
                //  breaks.  Too risky.  !!!! Bug_Bug !!!!
        }
        
        //
        // Use Relative Y-move commands
        //


        //
        //  Use line spacing if that is preferred
        //


        if ( ((pPDev->bTTY) ||
              (pPDev->fYMove & FYMOVE_FAVOR_LINEFEEDSPACING &&
               pPDev->arCmdTable[CMD_SETLINESPACING] != NULL) ) &&
             (iY - pPDev->ctl.ptCursor.y > 0)                   &&
             (pPDev->arCmdTable[CMD_LINEFEED] != NULL)
           )
        {
            INT      iLineSpacing;
            DWORD    dwMaxLineSpacing = pPDev->pGlobals->dwMaxLineSpacing;

            if (pPDev->bTTY  &&  (INT)dwTestValue > 0)
            {      //  [Peterwo] here's a  hack I tried that ensures that any request for a Y-move results
                   //  in at least one CR being sent. It  doesn't work, because bRealrender
                   //  code sends Y move commands of one scanline  each,  resulting in
                   //  one line feed per scanline.
                   //                if( (INT)dwTestValue < dwMaxLineSpacing)
                   //                     dwTestValue = dwMaxLineSpacing;
                   //
                   //  if you don't send anything, leave diff undisturbed
                   //  so the error can accumulate otherwise many small
                   //  cursor movements will not accumulate to cause one
                   //  occasional actual movement.

                    //
                    // For TTY driver we round up the input value one fifth of
                    // line spacing. This is required for not sending too many
                    // line feeds for small Y movements.
                    //
                    DWORD   dwTmpValue;

                     dwTmpValue = ((dwTestValue + DELTA_Y) / dwMaxLineSpacing) * dwMaxLineSpacing;
                     if (dwTmpValue)
                     {
                         dwTestValue = dwTmpValue ;
                     }
            }
            while ( (INT)dwTestValue > 0)
            {
                if (pPDev->bTTY)
                {
                    iLineSpacing = dwMaxLineSpacing;
                    if (dwTestValue < (DWORD)iLineSpacing)
                    {
                        iDiff = dwTestValue;
                        break;
                    }
                    if ( dwSendCRFlags )
                    {
                        XMoveTo( pPDev, 0, dwSendCRFlags );
                        dwSendCRFlags = 0;
                    }
                }
                else
                {
                    iLineSpacing =(INT)(dwTestValue > dwMaxLineSpacing ?
                                        dwMaxLineSpacing : dwTestValue);
                    //
                    // new code to handle positioning error when linespacingmoveunit doesn't
                    // equal master units
                    if (pPDev->pGlobals->dwLineSpacingMoveUnit > 0)
                    {
                        DWORD dwScale = pPDev->pGlobals->ptMasterUnits.y / pPDev->pGlobals->dwLineSpacingMoveUnit;
                        
                        // optimize to avoid 0-move cmd when move unit is less than master units
                        //
                        if (dwTestValue < dwScale)
                        {
                            iDiff = dwTestValue;
                            break;
                        }
                        // Modify line spacing to be multiple of moveunit
                        //
                        iLineSpacing -= (iLineSpacing % dwScale);
                    }
                    if ( dwSendCRFlags )
                    {
                        XMoveTo( pPDev, 0, dwSendCRFlags );
                        dwSendCRFlags = 0;
                    }
                        
                    if (pPDev->ctl.lLineSpacing == -1 ||
                            iLineSpacing != pPDev->ctl.lLineSpacing )
                    {
                        pPDev->ctl.lLineSpacing = iLineSpacing;
                        WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_SETLINESPACING));
                    }
                }

                //
                // Send the LF
                //

                WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_LINEFEED));
                dwTestValue -= (DWORD)iLineSpacing;
            }
        }
        else
        {
            //
            // Use relative command
            //

            PCOMMAND pCmd;

            if ( iY <= pPDev->ctl.ptCursor.y )
            {
                //
                // If there is no RELATIVE UP cmd, do nothing and return
                //

                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELUP))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.y =
                         pPDev->ctl.ptCursor.y - iY) < pPDev->ptDeviceFac.y)
                         iDiff = pPDev->ctl.ptRelativePos.y;
                    else
                    {
                        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR
                        // before each line-spacing command
                        //
                        if ( dwSendCRFlags )
                            XMoveTo( pPDev, 0, dwSendCRFlags );

                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                    }
                    iDiff = -iDiff;
                }
                else
                    // Do nothing since we can't simulate it
                    iDiff =  (iY - pPDev->ctl.ptCursor.y );

            }
            else
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELDOWN))
                {
                    pPDev->ctl.ptRelativePos.y = iY - pPDev->ctl.ptCursor.y;

                    //
                    // optimize to avoid 0-move cmd
                    //
                    if (pPDev->ctl.ptRelativePos.y < pPDev->ptDeviceFac.y)
                        iDiff = pPDev->ctl.ptRelativePos.y;
                    else 
                    {
                        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR
                        // before each line-spacing command
                        //
                        if ( dwSendCRFlags )
                            XMoveTo( pPDev, 0, dwSendCRFlags );

                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                    }
                }
                else
                    iDiff = (iY - pPDev->ctl.ptCursor.y );
            }
        }
    }

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y = iY - iDiff;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    pPDev->ctl.dwMode &= ~MODE_CURSOR_Y_UNINITIALIZED;
    return (iDiff);
}


INT
FineXMoveTo(
    PDEV    *pPDev,
    INT     iX
    )
/*++

Routine Description:

    This function is called to make microspace justification.
    It is only called when the normal x movement commands cannot
    move the cursor to the asking position.  For example,
    resolution is 180 DPI, x move command is 1/120".  To move
    by 4 pixels in 180 DPI, CM_XM_RIGHT is sent with parameter = 2
    (1/120") then one graphics pixel is sent (1/180).
    4/180 = 2/120 + 1/180.
    'iX' is always in MasterUnits.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iX    - Amount to move in Master Units

Return Value:

    The difference between the requested move and actual move

--*/

{
    INT iDiff;
    INT iScale;

    //
    // Don't do micro justification in graphics mode for device that
    // set x position at leftmost position on page after printing a
    // block of data OR Y position auto move to next Y row after priting
    // block of data.
    //

    if (pPDev->pGlobals->cxafterblock == CXSBD_AT_CURSOR_X_ORIGIN ||
        pPDev->pGlobals->cxafterblock == CXSBD_AT_GRXDATA_ORIGIN  ||
        pPDev->pGlobals->cyafterblock == CYSBD_AUTO_INCREMENT)
        return iX;

    //
    // Convert Master units to Graphic units
    //
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.y;
    else
        iScale = pPDev->ptGrxScale.x;

    iDiff = iX % iScale;
    iX /= iScale;

    if (iX > 0 )
    {
        INT iMaxBuf, iTmp;
        BYTE    rgch[ CCHMAXBUF ];

        //
        // Send the command, to send one block of data to the printer.
        // Init the state variable first.
        //

        //
        // BUG_BUG, how does this code work??
        // What should we send for CMD_SENDBLOCKDATA?
        //

        //
        // BUG_BUG, May be we should send BEGINGRAPHICS and ENDGRAPHICS later
        //

        pPDev->dwNumOfDataBytes = iX;
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SENDBLOCKDATA));

        iMaxBuf = CCHMAXBUF - (CCHMAXBUF % pPDev->ctl.sBytesPerPinPass);
        iX *= pPDev->ctl.sBytesPerPinPass;

        //
        // Send out null graphics data, zeroes.
        //

        ZeroMemory( rgch, iX > CCHMAXBUF ? iMaxBuf : iX );

        for ( ; iX > 0; iX -= iTmp)
        {
            iTmp = iX > iMaxBuf ? iMaxBuf : iX;

            //
            // BUG_BUG, OEMCustomization code might want to hook
            // out this graphics move.    Make this a bug when
            //  someone asks for it.
            //
            WriteSpoolBuf(pPDev, rgch, iTmp);

        }
        WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_ENDBLOCKDATA));

        return iDiff;
    }

    return iDiff;
}

INT
WriteChannel(
    PDEV    *pPDev,
    COMMAND *pCmd
    )
/*++

Routine Description:

    This routine performs the following tasks:
    - Parse through the cmd invocation str and build a CMDPARAM struct
      for every %dddd encountered.
    - Call IProcessTokenStream to calculate the arToken value of the parameter.
    - Check for lMin and lMax in PARAMETER struct and send the command
      multiple times, if necessary(MaxRepeat was seen).
    - Call SendCmd to send the command to the printer.

Arguments:

    pPDev - Pointer to PDEVICE struct
    pCmd  - Pointer to command struct to send, used for sending sequence section cmds
            and predefined Unidrv commands

Return Value:

    The last value send to the printer

--*/
#define MAX_NUM_PARAMS 16
{
    BYTE    *pInvocationStr;
    CMDPARAM *pCmdParam, *pCmdParamHead;
    INT     i, iParamCount, iStrCount, iLastValue = 0, iRet;
    PARAMETER *pParameter;
    BOOL    bMaxRepeat = FALSE;
    CMDPARAM arCmdParam[MAX_NUM_PARAMS];

    if (pCmd == NULL)
    {
        TERSE(("WriteChannel - Command PTR is NULL.\n"))
        return (NOOCD);
    }
    //
    // first check if this command requires callback
    //
    if (pCmd->dwCmdCallbackID != NO_CALLBACK_ID)
    {
        PLISTNODE   pListNode;
        DWORD       dwCount = 0;    // count of parameters used
        DWORD       adwParams[MAX_NUM_PARAMS];  // max 16 params for each callback

        if (!pPDev->pfnOemCmdCallback)
            return (NOOCD);
        //
        // check if this callback uses any parameters
        //
        pListNode = LISTNODEPTR(pPDev->pDriverInfo, pCmd->dwStandardVarsList);
        while (pListNode)
        {
            if (dwCount >= MAX_NUM_PARAMS)
            {
                ASSERTMSG(FALSE,("Command callback exceeds # of parameters limit.\n"));
                return (NOOCD);
            }

            adwParams[dwCount++] = *(pPDev->arStdPtrs[pListNode->dwData]);

            if (pListNode->dwNextItem == END_OF_LIST)
                break;
            else
                pListNode = LISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
        }

        FIX_DEVOBJ(pPDev, EP_OEMCommandCallback);

        iRet = 0;

        if(pPDev->pOemEntry)
        {
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                    HRESULT  hr ;
                    hr = HComCommandCallback((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                (PDEVOBJ)pPDev, pCmd->dwCmdCallbackID, dwCount, adwParams, &iRet);
                    if(SUCCEEDED(hr))
                        ;  //  cool !
            }
            else
            {
                iRet = (pPDev->pfnOemCmdCallback)((PDEVOBJ)pPDev, pCmd->dwCmdCallbackID,
                                        dwCount, adwParams);
            }
        }

        return iRet ;
    }

    //
    // no cmd callback. Process the string.
    //
    pInvocationStr = CMDOFFSET_TO_PTR(pPDev, pCmd->strInvocation.loOffset);
    iStrCount = pCmd->strInvocation.dwCount;

    pCmdParam = pCmdParamHead = arCmdParam;
    iParamCount = 0;
    //
    // Process the parameter from the invocation str.
    //

    for (i= 0; i < iStrCount; i++)
    {
        if (pInvocationStr[i] == '%')
        {
            if (pInvocationStr[i + 1] == '%')
            {
                //
                // Do nothing, just skip %%
                //

                i += 1;
            }
            else
            {
                //
                // Build a list of CMDPARAM, one for each %dddd encounter
                // in cmd invocation string.
                //

                BYTE  *pCurrent = pInvocationStr + i + 1;

                //
                // Increment the parameter count
                //

                iParamCount++;
                
                if (iParamCount > MAX_NUM_PARAMS)
                {
                    ASSERT (iParamCount <= MAX_NUM_PARAMS);
                    return (NOOCD);
                }

                //
                // Copy the 4 character that represent to parameter index from cmd str
                // pInvocationStr + i points to %, pInvocationStr + i + 1 points
                // to first digit of param index
                //

                pParameter = PGetParameter(pPDev, pCurrent);

                //
                // Initialize CMDPARAM for SendCmd
                //

                //
                // IProcessTokenStream calculate the integer value parameter
                // from the token stream in PARAMETER, bMaxRepeat is set
                // to TRUE if OP_MAX_REPEAT operator was encountered.
                //

                pCmdParam->iValue = IProcessTokenStream(pPDev,
                                                        &pParameter->arTokens,
                                                        &bMaxRepeat);

                //
                // Save the last value calculated (will only be used by XMoveTo and YMoveTo)
                // which assumes there is only one paramter per move command
                //

                iLastValue = pCmdParam->iValue;

                pCmdParam->dwFormat = pParameter->dwFormat;
                pCmdParam->dwDigits = pParameter->dwDigits;
                pCmdParam->dwFlags  = pParameter->dwFlags;

                //
                // Check for dwFlags PARAM_FLAG_MIN_USED and PARAM_FLAG_MAX_USED
                //

                if (pCmdParam->dwFlags & PARAM_FLAG_MIN_USED &&
                    pCmdParam->iValue < pParameter->lMin)
                {
                    pCmdParam->iValue = pParameter->lMin;
                }

                if (pCmdParam->dwFlags & PARAM_FLAG_MAX_USED &&
                    !bMaxRepeat &&
                    pCmdParam->iValue > pParameter->lMax)
                {
                    pCmdParam->iValue = pParameter->lMax;

                }

                //
                // Move to next paramter
                //
                pCmdParam++;
            }
        }
    }

    //
    // We are here means have a list of CMD parameter, pointed to by
    // pCmdParamHead, one for each
    // %dddd encountered, in the order they were encountered in invocation string

    //
    // MAJOR ASSUMPTION, GPD specification specifies that
    // only ONE parameter is valid for commands that use OP_MAX_REPEAT operator
    // So assume only one here (pCmdParamHead and pParameter are valid).
    //

    if (bMaxRepeat && pCmdParamHead->dwFlags & PARAM_FLAG_MAX_USED &&
                pCmdParamHead->iValue > pParameter->lMax)
    {
        INT iRemainder, iRepeat;

        ASSERT(iParamCount == 1);

        iRemainder = pCmdParamHead->iValue % pParameter->lMax;
        iRepeat = pCmdParamHead->iValue / pParameter->lMax;

        while (iRepeat--)
        {
            pCmdParamHead->iValue = pParameter->lMax;
            SendCmd(pPDev, pCmd, pCmdParamHead);
        }

        //
        // Send remainder
        //
        if (iRemainder > 0)
        {
            pCmdParamHead->iValue = iRemainder;
            SendCmd(pPDev, pCmd, pCmdParamHead);
        }
    }
    else
    {
        //
        // Send the command to the printer
        // SendCmd will process the command and format the parameters
        // in the order encounter in the invocation string
        //

        SendCmd(pPDev, pCmd, pCmdParamHead);
    }

    return (iLastValue);
}

INT
WriteChannelEx(
    PDEV    *pPDev,
    COMMAND *pCmd,
    INT     iRequestedValue,
    INT     iDeviceScaleFac
    )
/*++

Routine Description:

    This routine performs the following tasks:
    - Call WriteChannel to write the command and get the
      value of the last paramter calculated for the cmd.
    - Use device factor to convert device units returned from WriteChannel to
      master units
    - Take the difference between requested and actual value

Arguments:

    pPDev - Pointer to PDEVICE struct
    pCmd  - Pointer to command struct to send, used for sending sequence section cmds
            and predefined Unidrv commands
    iRequestedValue - Value of requested move command in Master units
    iDeviceScaleFac - Scale factor to convert Device units to Master units

Return Value:

    The difference between actual value and requested value in Master units

Note:

    This function is only called only by XMoveTo and YMoveTo and assumes
    that all move commands have only one parameter.

--*/

{
    INT iActualValue;

    //
    // Get the device unit returned from WriteChannel and convert it
    // to Master units based on the scale factor passed in
    // Scale = Master/Device.
    //

    iActualValue = WriteChannel(pPDev, pCmd);
    iActualValue *= iDeviceScaleFac;

    return (iRequestedValue - iActualValue);

}

PPARAMETER
PGetParameter(
    PDEV    *pPDev,
    BYTE    *pInvocationStr
    )
/*++

Routine Description:

    This routine get the parameter index from pInvocationStr passed in and
    return the PARAMETER struct associated with the index

Arguments:

    pPDev   - Pointer to PDEVICE struct
    pInvocationStr  - Pointer Invocation str containing the index

Return Value:

    Pointer to PARAMETER struct associated with the index specified in
    the invocation string.

Note:

    Parameter index is the 4 bytes pointed to by pInvocationStr

--*/
{

    BYTE  arTemp[5];
    INT   iParamIndex;
    PARAMETER   *pParameter;

    //
    // Copy the 4 character that represent to parameter index from cmd str
    // pInvocationStr
    //

    strncpy(arTemp, pInvocationStr, 4);
    arTemp[4] = '\0';
    iParamIndex = atoi(arTemp);
    pParameter = PARAMETERPTR(pPDev->pDriverInfo, iParamIndex);

    ASSERT(pParameter != NULL);

    return (pParameter);
}

VOID
SendCmd(
    PDEV    *pPDev,
    COMMAND *pCmd,
    CMDPARAM *pParam
    )
/*++

Routine Description:

    This routine is called by WriteChannel to write one command to the
    printer via. WriteSpoolBuf.  WriteChannel passes a pointer to an array
    of CMDPARAM.  Each CMDPARAM describes the parameter for each %dddd
    encounter in cmd invocation string (the CMDPARAM is sorted in the order
    encountered).

Arguments:

    pPDev   - Pointer to PDEVICE struct
    pCmd    - Pointer to COMMAND struct
    pParam  - Pointer to and array CMDPARAM struct, containing everything needed to format
              the parameter

Return Value:

    None

--*/
{
    INT     iInput, iOutput;            // Used to index through input and output buffers
    BYTE    arOutputCmd[CCHMAXBUF];     // Output buffer to send to printer
    PBYTE   pInputCmd;                  // Pointer to Cmd invocation str.

    //
    // Get the command invocation string
    //

    pInputCmd = CMDOFFSET_TO_PTR(pPDev, pCmd->strInvocation.loOffset);
    iOutput = 0;

    //
    // Go through all the bytes in the invocation string and transfer them
    // to the output buffer.  Replace %dddd with format value calculated
    // and %% with %.
    //

    for (iInput = 0; iInput < (INT)pCmd->strInvocation.dwCount; iInput++)
    {
        if (pInputCmd[iInput] == '%' )
        {

            if (pInputCmd[iInput + 1] == '%')
            {
                //
                // %% equals '%', skip over marker %%
                //

                arOutputCmd[iOutput++] = '%';
                iInput += 1;

            }
            else
            {
                INT     iValue;
                DWORD   dwFlags, dwDigits, dwFormat;

                //
                // Skip over the marker % and dddd for %dddd found in invocation str.
                // Skip 4 bytes (%dddd)
                //

                iInput += 4;

                dwDigits = pParam->dwDigits;
                dwFlags =  pParam->dwFlags;
                dwFormat = pParam->dwFormat;
                iValue = pParam->iValue;
                pParam++;

                //
                // Format the parameter according the the dwFormat specified in PARAMETER struct
                //

                switch (dwFormat)
                {

                //
                // case 'd':  parameter as decimal number
                // case 'D':  same as case 'd' with + sign if value > 0
                // case 'c':  parameter as a single character
                // case 'C':  parameter as character plus '0'
                // case 'f':  parameter as decinal number with decimal point inserted
                //            before the second digit from the right.
                // case 'l':  parameter as word LSB first
                // case 'm':  parameter as word MSB first
                // case 'q':  parameter as Qume method, 1/48" movements
                // case 'g':  parameter as 2 *abs(param) + is_negative(param)
                // case 'n':  Canon integer encoding
                // case 'v':  NEC VFU encoding
                // case '%':  print a %

                    case 'D':
                        if (iValue > 0)
                            arOutputCmd[iOutput++] = '+';
                        //
                        // Fall through
                        //

                    case 'd':
                        if (dwDigits > 0 && dwFlags & PARAM_FLAG_FIELDWIDTH_USED)
                        {
                            //
                            // Temp call to get the number of digits for the iValue
                            //

                            int iParamDigit = itoA(arOutputCmd + iOutput, iValue);

                            for ( ; iParamDigit < (INT)dwDigits; iParamDigit++)
                            {
                                //
                                // Zero pads
                                //
                                arOutputCmd[iOutput++] = '0';
                            }
                        }
                        iOutput += itoA( arOutputCmd + iOutput, iValue);
                        break;

                    case 'C':
                        iValue += '0';

                        //
                        // Fall through
                        //

                    case 'c':
                        arOutputCmd[iOutput++] = (BYTE)iValue;
                        break;

                    case 'f':
                    {
                        int x, y, i;
                        BYTE arTemp[CCHMAXBUF];
                        LPSTR  pCurrent = arOutputCmd + iOutput;
                        ULONG  cchpCurrentLen = 0;
                        if ( (LONG)CCHOF(arOutputCmd) - iOutput > 0 )
                        {
                            cchpCurrentLen = CCHOF(arOutputCmd) - iOutput;
                        }
                        else
                        {
                            break;
                        }

                        x = iValue /100;
                        y = iValue % 100;

                        iOutput += itoA(pCurrent, x);

                        StringCchCatA ( pCurrent, cchpCurrentLen, "."); //strcat(pCurrent, ".");

                        i = itoA(arTemp, y);

                        //
                        // Take care of the case where the mod yields 1 digit, pad a zero
                        //

                        if (i < 2 )
                        {
                            StringCchCatA ( pCurrent, cchpCurrentLen, "0"); //strcat(pCurrent, "0");
                        }
            
                        StringCchCatA(pCurrent, cchpCurrentLen, arTemp); //strcat(pCurrent, arTemp);

                        //
                        // Increment iOutput to include the 2 digits after the
                        // decimal and the "."
                        //

                        iOutput += 3;
                    }
                        break;

                    case 'l':
                        arOutputCmd[iOutput++] = (BYTE)iValue;
                        arOutputCmd[iOutput++] = (BYTE)(iValue >> 8);
                        break;

                    case 'm':
                        arOutputCmd[iOutput++] = (BYTE)(iValue >> 8);
                        arOutputCmd[iOutput++] = (BYTE)iValue;
                        break;


                    case 'q':
                        arOutputCmd[ iOutput++ ] = (BYTE)(((iValue >> 8) & 0xf) + '@');
                        arOutputCmd[ iOutput++ ] = (BYTE)(((iValue >> 4) & 0xf) + '@');
                        arOutputCmd[ iOutput++ ] = (BYTE)((iValue & 0xf) + '@');
                        break;

                    case 'g':
                    {
                        if (iValue >= 0)
                            iValue = iValue << 1;
                        else
                            iValue = ((-iValue) << 1) + 1;

                        while (iValue >= 64)
                        {
                            arOutputCmd[iOutput++] = (char)((iValue & 0x003f) + 63);
                            iValue >>= 6;
                        }
                        arOutputCmd[iOutput++] = (char)(iValue + 191);

                    }
                        break;

                    case 'n':
                    {
                        WORD absParam = (WORD)abs(iValue);
                        WORD absTmp;

                        if (absParam <= 15)
                        {
                            arOutputCmd[iOutput++] = 0x20
                                        | ((iValue >= 0)? 0x10:0)
                                        | (BYTE)absParam;
                        }
                        else if (absParam <= 1023)
                        {
                            arOutputCmd[iOutput++] = 0x40
                                        | (BYTE)(absParam/16);
                            arOutputCmd[iOutput++] = 0x20
                                        | ((iValue >= 0)? 0x10:0)
                                        | (BYTE)(absParam % 16);
                        }
                        else
                        {
                            arOutputCmd[iOutput++] = 0x40
                                        | (BYTE)(absParam / 1024);
                            absTmp        = absParam % 1024;
                            arOutputCmd[iOutput++] = 0x40
                                        | (BYTE)(absTmp / 16);
                            arOutputCmd[iOutput++] = 0x20
                                        | ((iValue >= 0)? 0x10:0)
                                        | (BYTE)(absTmp % 16);
                        }
                    }
                        break;

                    case 'v':
                        //
                        // NEC VFU(Vertical Format Unit)
                        //
                        // VFU is a command to specify a paper size
                        // (the length of form feed for the NEC 20PL dotmatrix
                        // printer.
                        //
                        // On NEC dotmatrix printer, 1 line is 1/6 inch.
                        // If you want to specify N line paper size,
                        // you need to send GS, N+1 Data and RS.
                        //
                        //  GS (0x1d)
                        //  TOF Data (0x41, 0x00)
                        //      Data (0x40, 0x00)
                        //      Data (0x40, 0x00)
                        //      Data (0x40, 0x00)
                        //      ..
                        //      ..
                        //      Data (0x40, 0x00)
                        //  TOF Data (0x41, 0x00)
                        //  RS (0x1e)
                        //
                        arOutputCmd[iOutput++] = 0x1D;
                        arOutputCmd[iOutput++] = 0x41;
                        arOutputCmd[iOutput++] = 0x00;
                        while(--iValue > 0)
                        {
                            if( iOutput >= CCHMAXBUF - 5)
                            {
                                WriteSpoolBuf( pPDev, arOutputCmd, iOutput  );
                                iOutput = 0;
                            }

                            arOutputCmd[iOutput++] = 0x40;
                            arOutputCmd[iOutput++] = 0x00;
                        }
                        arOutputCmd[iOutput++] = 0x41;
                        arOutputCmd[iOutput++] = 0x00;
                        arOutputCmd[iOutput++] = 0x1E;
                        break;

                    default:
                        break;

                }
            }
        }
        else
        {
            //
            // Copy the input to output and increment the output count
            //

            arOutputCmd[iOutput++] = pInputCmd[iInput];

        }

        //
        // Write output cmd buffer out to spool buffer in the case
        // where it full or nearly full (2/3 full)
        //

        if( iOutput >= (2 * sizeof( arOutputCmd )) / 3  )
        {
            WriteSpoolBuf( pPDev, arOutputCmd, iOutput  );
            iOutput = 0;
        }
    }

    //
    // Write the data to spool buffer
    //

    if ( iOutput > 0  )
        WriteSpoolBuf( pPDev, arOutputCmd, iOutput );


    return;
}

INT
IProcessTokenStream(
    PDEV            *pPDev,
    ARRAYREF        *pToken ,
    PBOOL           pbMaxRepeat
    )
/*++

Routine Description:

    This function process a given token stream and calculate the value
    for the command parameter.

Arguments:

    pPDev   - Pointer to PDEVICE
    pToken  - Pointer to an array of TOKENSTREAM representing the operands
              and operators for RPN calc.  pToken->dwCount is the number of
              TOKENSTREAM in the array.  pToken->loOffset is the index
              to the first TOKENSTREAM in the array.
    pbMaxRepeat - Indicates a max repeat operator was seen in token stream

Return Value:

    The calculated value, always an INT and set pbMaxRepeat TRUE if
    the OP_MAX_REPEAT operator was seen.

--*/

{
    INT     iRet = 0, sp = 0;
    INT     arStack[MAX_STACK_SIZE];
    DWORD   dwCount = pToken->dwCount;
    TOKENSTREAM * ptstrToken = TOKENSTREAMPTR(pPDev->pDriverInfo, pToken->loOffset);


    *pbMaxRepeat = FALSE;

    while (dwCount--)
    {
        switch(ptstrToken->eType)
        {
            case OP_INTEGER:
                if (sp >= MAX_STACK_SIZE)
                    goto ErrorExit;

                arStack[sp++] = (INT)ptstrToken->dwValue;
                break;

            case OP_VARI_INDEX:
                // dwValue is the index to standard variable list
                if (sp >= MAX_STACK_SIZE)
                    goto ErrorExit;

                arStack[sp++] = (INT)*(pPDev->arStdPtrs[ptstrToken->dwValue]);
                break;

            case OP_MIN:
                if (--sp <= 0)
                    goto ErrorExit;

                if (arStack[sp-1] > arStack[sp])
                    arStack[sp-1] = arStack[sp];
                break;

            case OP_MAX:
                if (--sp <= 0)
                    goto ErrorExit;

                if (arStack[sp-1] < arStack[sp])
                    arStack[sp-1] = arStack[sp];
                break;

            case OP_ADD:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] += arStack[sp];
                break;

            case OP_SUB:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] -= arStack[sp];
                break;

            case OP_MULT:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] *= arStack[sp];
                break;

            case OP_DIV:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] /= arStack[sp];
                break;

            case OP_MOD:
                if (--sp <= 0)
                    goto ErrorExit;

                arStack[sp-1] %= arStack[sp];
                break;

            case OP_MAX_REPEAT:
                //
                // If pbMaxRepeat is TRUE, can only send the parameters in
                // increment of lMax repeat value or smaller,  set in Parameter list until
                //

                *pbMaxRepeat = TRUE;
                break;

            case OP_HALT:
                if (sp == 0)
                    goto ErrorExit;

                iRet = arStack[--sp];
                break;

            default:
                VERBOSE (("IProcessTokenStream - unknown command!"));
                break;
        }
        ptstrToken++;
    }

    return (iRet);

ErrorExit:
    ERR(("IProcessTokenStream, invalid stack pointer"));
    return 0;
}

static  int
itoA( LPSTR buf, INT n )
{
    int     fNeg;
    int     i, j;

    if( fNeg = (n < 0) )
        n = -n;

    for( i = 0; n; i++ )
    {
        buf[i] = (char)(n % 10 + '0');
        n /= 10;
    }

    /* n was zero */
    if( i == 0 )
        buf[i++] = '0';

    if( fNeg )
        buf[i++] = '-';

    for( j = 0; j < i / 2; j++ )
    {
        int tmp;

        tmp = buf[j];
        buf[j] = buf[i - j - 1];
        buf[i - j - 1] = (char)tmp;
    }

    buf[i] = '\0';

    return i;
}

BOOL
BUniWritePrinter(
    IN PDEV*  pPDev,
    IN LPVOID pBuf,
    IN DWORD cbBuf,
    OUT LPDWORD pcbWritten)
{
    DWORD dwCount;
    BOOL bReturn = FALSE;

    //
    // Is there any plug-in that hooks WritePrinter?
    // If there is, the plug-in need to take care of all output.
    // Call plug-in's WritePrinter method.
    //
    if(pPDev->pOemEntry && pPDev->fMode2 & PF2_WRITE_PRINTER_HOOKED)
    {
        START_OEMENTRYPOINT_LOOP(pPDev);

            //
            //  OEM plug in uses COM and function is implemented.
            //
            if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )
            {
                //
                // Call only the first available WritePrinter method in
                // multiple plug-ins.
                //

                if (pOemEntry->dwFlags & OEMWRITEPRINTER_HOOKED)
                {
                    HRESULT  hr;

                    //
                    // WritePrinter is supported by this plug-in DLL.
                    // Plug-in's WritePrinter should not return E_NOTIMPL or
                    // E_NOTINTERFACE.
                    //
                    pPDev->fMode2 |= PF2_CALLING_OEM_WRITE_PRINTER;
                    hr = HComWritePrinter((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                          (PDEVOBJ)pPDev,
                                          pBuf,
                                          cbBuf,
                                          pcbWritten);
                    pPDev->fMode2 &= ~PF2_CALLING_OEM_WRITE_PRINTER;

                    //
                    // If Plug-in's WritePrinter succeeded, return TRUE.
                    //
                    if(SUCCEEDED(hr))
                    {
                        //
                        // If the method is called and succeeded, return TRUE.
                        //
                        bReturn = TRUE;
                        break;
                    }
                    else
                    {
                        //
                        // If WritePrinter method failed, break.
                        //
                        bReturn = FALSE;
                        break;
                    }
                }
            }

        END_OEMENTRYPOINT_LOOP;

        if (pPDev->pVectorProcs != NULL)
        {
            pPDev->devobj.pdevOEM = pPDev->pVectorPDEV;
        }
    }
    //
    // If there is no WritePrinter hook, call spooler API WritePrinter.
    //
    else
    {
       bReturn = WritePrinter(pPDev->devobj.hPrinter,
                              pBuf,
                              cbBuf,
                              pcbWritten)
               && cbBuf == *pcbWritten; 
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\unidrv.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    unidrv.h

Abstract:

    Unidrv driver main header file. All other header files should
    be included in this for precompiled headers to work.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

        dd-mm-yy -author-
                description

--*/


#ifndef _UNIDRV_H_
#define _UNIDRV_H_

#include "lib.h"
#include "unilib.h"
#include "gpd.h"
#include "mini.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "data.h"
#include "init.h"
#include "physical.h"
#include "common.h"
#include "fontif.h"
#include "rasterif.h"
#include "state.h"
#include "brush.h"
#include "vectorif.h"

#endif  // !_UNIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\move2.c ===
notes, comments on existing code and
outline of rewritten moveto commands
which are coordinate independent.


INT
MoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the X position along the logical (GDIs) X axis.
    This function will emit whatever command is needed to accomplish this
    regardless of the printer's coordinate system.

    I must recast the Xmoveto and Ymoveto commands into this new
    paradigm because I want to support font rotations using the
    PrintDirection command.

    Assumptions:


    when making an absolute move, set both standard variables for
    x and y.   don't know why, maybe for those printers that have
    only a moveXandY command.

     MV_PHYSICAL is not supported.   Only mv to cursor origin is supported.

    unidrv5 code assumes if no absolute moves exist, the
    default cursor position at StartPage time is the cursor origin.

    the supplied movement commands are sufficient to
    move the cursor anywhere within the specified imageable area.

    the default font is always currently selected.       So iDefWidth is correct.

    unless overridden explictly by GPD, abs x, y move cannot accept a negative value.

    rel x, y moves only accept a positive value, so if in reality they accept
    both positive and negative, the negative command must be
    treated as a separate  command in the opposite direction which prepends
    the negative sign in the specification of the command parameter.

    unidrv5 code assumes if there is no explicit relative left move command,
    you cannot move left.  Which means the rel right move command is assumed
    to accept only non-negative values.

    If only one relative move command direction exists, that direction
    is assumed to be right.

    Use linefeed spaceing only for positive movements along the y - direction.
    and then only if fYMove & FYMOVE_FAVOR_LINEFEEDSPACING


        the data tree is not fully populated.
        We only know the cursor and Imageable origin for
        the two major orientations (Portrait and Landscape).
        If we wander from that, using PrintDirection, we must
        restrict ourselves to relative moves.

        The input (requested move) coordinate system will be the
        current GDI coordinates.
        see  (pPDev->pOrientation->dwRotationAngle == ROTATE_90,
            ROTATE_NONE, etc)

        The working coordinate system will be the imageable
        area in Portrait orientation.   This is because there are
        values that are invariant in this system:
        Xmoveunits and Ymoveunits.   We will keep the errors
        during and beyond any temp rotations using PrintDirection.

        Making the transformation to the working CS:

        need the dimensions of the imageable area  in Portrait orientation

        the input cannot ever be specified wrt cursor origin, since
        that makes no sense when the driver is rotating.
        So why would the code ever what to do something different
        depending on who is rotating?   Why would the code
        ever care about where the cursor origin is?

        ok, the only time the driver cares is becuase the printer
        expects the cursor to be at x=0 or y=0 prior to doing something
        like emitting a line of graphics or selecting a font.
        So just define a special flag MV_CURSOR_ZERO  that causes this to happen.
        (if <cr> takes us to cursor origin, fine do that, else convert to
        logical coordinates and let rest of code handle it.)
        Is there such an entity as a cursor origin if there is no
        abs move command to get there?


        now need to know what commands are available, capabilities
        (can accept negative args?  move unit, move direction -
        up, down, right , left wrt a portrait page)
        and for absolute commands, where the location of their
        origin is.    Note this is dependent on pPDev->pGlobals->bRotateCoordinate,
        pPDev->pOrientation->dwRotationAngle   and PrintDirection.

        How to characterize a printers movement commands for each
        of the printers major orientations.

        For each supported orientation:
        (portrait is always supported,  others only if bRotateCoordinate == TRUE.)
        The current snapshot should supply cursor origin, imageable origin
        so I can compute the cursorOffset wrt imageable origin.
        Also look at imageable area, so we know if cursor move command
        is valid.

        List of absolute cursor move commands and allowed range (neg supported?)
          place in a table with directions.
        List of relative move commands and and allowed range (neg supported?)

        dir     abs     relative           last resort    (use only if printdir = 0)
        -----------------------------------------
        x                                            spaces
        -y
        -x                                       <cr>
        y                                           linefeed

        the array accepts either a command index or ptr,
        a NULL indicator for not supported
        and  USE_NEG  which means use the opposite directions move command
        with a negative argument.
        note the dir is wrt Portrait orientation.

        such a table exists for portrait (initialized directly from gpd)
        then one is synthesized for each supported orientation.
        then one is created on the fly starting from the current supported
        orientation  if PrintDirection is not zero.
        Just shift each relative cmd  entry up for each 90 deg change in the
        print direction.     Set all abs entries to NULL.

        The GPD will have a new keyword NEG_ALLOWED  for the abs and
        relative move commands.

        CR and other ways to move the cursor will be assumed to be available
        in all supported orientations.


        these values don't necessarily change as the print direction changes:

        *XMoveThreshold  (0 , * or inbetween)
        *YMoveThreshold  (0 , * or inbetween)    (when to use abs instead of relative)
        *X, YMoveUnit  always referenced to the portrait page.
            (should really be referred to as ScanDirMoveUnit, and FeedDirMoveUnit)


        I then choose the 'best' command to move the cursor
        to its requested position.

    flowchart please, are there bad combinations and hidden assumptions?
    how are quantization errors handled and physical and logical cursor
    positions updated?


     more special cases:

     MV_UPDATE:  at least quantize to moveUnits before storing new cursor
        position.
     MV_RELATIVE:  this means movement is relative to current logical cursor
        position,  doesn't mean use relative move commands.


      logic tree:

      convert imageable coordinates to cursor origin coordinates.
      determine direction we want to move
      check existence of abs and relative commands.


      initialization:

    if  we are in a non-zero PrintDirection and uninit flag is set, emit an assert.
    the print direction should never be changed before initializing
    the cursor's position. (what if there are no initialization commands?)

      if abs commands exist AND They can get us to the specified
      position just emit the abs command and clear the uninit flag.

      else emit abs command to set both X and Y axis to cursor 0. and
      clear the uninit flag.

      if no abs commands exist, emit <cr> and set cursor position
      to (cursor or image org , 0)  clear the uninit flag.
      even though not strictly correct.

      now drop into the relative move portion to attempt to finish the move.
      if no dedicated relative move command exists in the desired direction,
      check and see if sending <cr> causes a movment in that direction
      if so send <cr> and goto top of paragraph.
      check to see if sending filler (spaces, nulls) causes a movment in that direction.
      if so send them.



      cursor origin?   should a command be emitted to set the printer to
        this position?   or should we assume y = 0 (cursor position)
        and emit  <cr> and we know that will take us to either imageable
        origin or cursor origin.

      after the first move follow this formula:

      abs move  unless desired relative move exists
        and is favored.
      if abs move wasn't used, use relative move.
      as implemented above.


       logic for last resort moves:
        if <CR> needed:
            emit <cr>  calculate remaining move needed
        if  spaces needed (pos x direction and over the theshold)
            emit correct number of spaces
            calculate remaining move
        if nulls needed
            emit correct number of nulls
            update actual  and logical     cur position
            no need to calulate remaining move.  nothing else to be done.

        if(linefeed needed)

Arguments:

    pPDev - Pointer to PDEVICE struct
    iXIn  - Number of units to move in X direction
    fFlag - Specifies the different X move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/




/* -------  current code with comments  ------------ */

INT
XMoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the X position along the X axis.
    what is the definition of X axis?  it is the printer's
    logical x-axis.  If the printer has a Landscape or Printing Direction command
    these will change the logical x-axis.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iXIn  - Number of units to move in X direction
    fFlag - Specifies the different X move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{
    int   iX, iFineValue, iDiff = 0;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    int iScale;

    //
    // If the position is given in graphics units, convert to master units
    //
    // ptGrxScale has been adjusted to suit the current orientation.
    //

    //*\\  ok, this makes sense if X and Y moveto is swapped
    //  by caller if driver does the rotation.

    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
            //*\\  is driver performing the Landscape rotation?
        iScale = pPDev->ptGrxScale.y;  //*\\  driver is
    else
        iScale = pPDev->ptGrxScale.x;  //*\\  printer is

    if ( fFlag & MV_GRAPHICS )  //*\\  iXin  is in graphics units
    {
        iXIn = (iXIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iX = iXIn;

    //
    // Basically, only adjust if we are doing absolute move
    //


//*\\  MV_PHYSICAL  means iXIn is wrt to cursor origin not imageable origin.
//*\\  sometimes used by render code to go to cursor origin.

    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iX += pPDev->sf.ptPrintOffsetM.x;

//*\\  convert iX to cursor cooridinates.   note sf.ptPrintOffsetM
//*\\   is defined as  ImageableOrigin - CursorOrigin


    //
    // If it's a relative move, update iX (iX will be the absolute position)
    // to reflect the current cursor position

//*\\  note cursor position (ctl.ptCursor) is always wrt the cursor origin.

    if ( fFlag & MV_RELATIVE )
        iX += pPDev->ctl.ptCursor.x;

//*\\   iX represents the cursor position wrt the cursor origin after
//*\\   the specified move has been executed.

    //
    // Update, only update our current cursor position and return
    // Do nothing if the XMoveTo cmd is called to move to the current position.
    //

    if ( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptCursor.x = iX;
        return 0;
    }

    if ( pPDev->ctl.ptCursor.x == iX )
        return 0;


    //
    // If iX is zero and pGlobals->cxaftercr does not have
    // CXCR_AT_GRXDATA_ORIGIN set, then we send CR and reset our
    // cursor position to 0, which is the printable x origin
    //
    //*\\  ignore above comment there is no  CXCR_AT_GRXDATA_ORIGIN
    //*\\  only  at cursor origin or imageable origin.
    //  if cursor is requested to move to its origin and a <cr> will take it
    //  to the origin,  issue the <cr>.

    if (iX == 0 && (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN ||
            pPDev->sf.ptPrintOffsetM.x == 0))
    {
        pPDev->ctl.ptCursor.x = 0;
        WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));
        return 0;
    }

    //
    // Check whether we any X move cmd, PF_NO_XMOVE_CMD is set if we did
    // not see any relative or absolute x move cmds
    //

    if( pPDev->fMode & PF_NO_XMOVE_CMD)
    {
        //
        // There is no X move command(abs or relative), so we'll have to simulate
        // using blanks or null graphics data (0)
        //

        //
        // We *assume* that when XMoveto is called, the current font is always
        // the default font IF the printer has no X movement command.
        //

        int     iRelx = iX - pPDev->ctl.ptCursor.x ;
        int     iDefWidth;

        //
        // Convert to Master Units
        //

        //
        // BUG_BUG, Double check that we can use Default Font here when
        // we have a custom TTY driver
        //


        if ( iRelx < 0 )
        {
            if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                iRelx = iX;
            else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
            {
                ASSERT(pPDev->pGlobals->bRotateCoordinate==FALSE);
                //*\\  this means if the printer has no X move commands
                //  it had better not claim it can perform coordinate rotations.

                iRelx = iX - pPDev->pf.ptImageOriginM.x;     >>>wrong!!!!<<<
            }

            WriteChannel( pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN ));
        }

        //
        // Simulate X Move, algorithm is that we always send a blank space
        // for every character width, and send graphics null data for
        // the remainder.
        //

//*\\  potential bugs:  what if a different font is selected?
//*\\  font width wasn't originally specified in resolution units
//*\\  so ganesh does a rounding operation.  This may not agree
//*\\  with the printers idea of the font width. (x-advance)

//*\\  why isn't requested position tracked?  Imagine the cursor only moves
//*\\  in units of 2 master units, a series of 10 1 unit relative move to commands should
//*\\  result in the cursor moving 10 units using 5 actual moves of 2 units each.


//*\\ the assumption here is iRelx is always positive.
//  this should be ok, since if there are no dedicated
//  movement commands, and the makeshift commands used
//  can only move to the right, there is no way to access
//  any region to the left of the cursor origin (accessed via <cr>).


        iDefWidth = pPDev->ptDefaultFont.x * iScale;
        if (iDefWidth)
        {
            while( iRelx >= iDefWidth )
            {
                WriteSpoolBuf( pPDev, (LPSTR)" ", 1 );
                iRelx -= iDefWidth;
            }
        }
        else
            TERSE (("XMoveTo: iDefWidth = 0\n"));


        //
        // Send the remaining partial space  via FineXMoveTo.
        //

        iDiff = iRelx;
        fFlag |= MV_FINE;    // Use graphics mode to reach point

    }
    else
    {
        DWORD dwTestValue  = abs(iX - pPDev->ctl.ptCursor.x);
        COMMAND *pCmd;

        //
        // X movement commmands are available,  so use them.
        // We need to decide here whether relative or absolute command
        // are favored

        //
        // General assumption: if dwTestValue > dwXMoveThreshold,
        // absolute command will be favored
        //

        //
        // BUG_BUG, if we are stripping blanks, we need to check whether
        // it's legal to move in Graphics mode.  If it's not, we have
        // to get out of graphics mode before moving.
        //

        //   buggy!,  buggy!  buggy!
        //*\\  avoid using absolute moves for negative values?
        //  yet its ok to use negative values the first time?
        //  what happens if  negative abs move is the only way
        //  to reach that portion of the printable area?
        //  if you set dwXMoveThreshold to a non-zero value,
        //  you had better have relative movement commands
        //


        if (((pPDev->ctl.dwCursorMode & CURSOR_X_UNINITIALIZED) ||
            (dwTestValue > pPDev->pGlobals->dwXMoveThreshold &&
            iX > 0)) &&
            (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVEABSOLUTE)) != NULL)
        {
            //
            // if the move units are less (coarser) than the master units then we need to
            // check whether the new position will end up being the same as the
            // original position. If so, no point in sending another command.
            //

            //  I think ptDeviceFac is the number of master units covered
            //  by one move unit.

            if (!(pPDev->ctl.dwCursorMode & CURSOR_X_UNINITIALIZED) &&
                (pPDev->ptDeviceFac.x > 1) &&
                ((iX - (iX % pPDev->ptDeviceFac.x)) == pPDev->ctl.ptCursor.x))
                //*\\  I would have rewritten the last condition as:
                //  (iX / pPDev->ptDeviceFac.x == pPDev->ctl.ptCursor.x / pPDev->ptDeviceFac.x)
                //    ptCursor is the quantized cursor position in master units, not
                //  where the app expects the cursor to be.
            {
                iDiff = iX - pPDev->ctl.ptCursor.x;   //  having the caller keep track of
                // this is just plain wrong.  you know it will be dropped.  since one
                // caller cannot transfer the error to the next caller.
            }
            else
            {

                //*\\  what is this:   ctl.ptAbsolutePos  ?  this is the standard variable
                //*\\  why isn't ctl.ptCursor updated ?   it is at the very end of this function.

                pPDev->ctl.ptAbsolutePos.x = iX;
                //
                // 3/13/97 ZhanW
                // set up DestY as well in case it's needed (ex. FE printers).
                // In that case, truncation error (iDiff) is not a concern.
                // This is for backward compatibility with FE Win95 and FE NT4
                // minidrivers.
                //

                //*\\  note:  WriteChannel returns amount moved in
                //  device units which can be converted to master units
                //  by multiplying by      pPDev->ptDeviceFac.x

                pPDev->ctl.ptAbsolutePos.y = pPDev->ctl.ptCursor.y;
                iDiff = WriteChannelEx(pPDev,
                                   pCmd,
                                   pPDev->ctl.ptAbsolutePos.x,
                                   pPDev->ptDeviceFac.x);

                if (pPDev->ctl.dwCursorMode & CURSOR_X_UNINITIALIZED)
                    pPDev->ctl.dwCursorMode &= ~CURSOR_X_UNINITIALIZED;
            }
        }
        else   // code assumes relative moves exist if iX is negative
        {
            //
            // Use relative command to send move request
            //

            INT iRelRightValue = 0;

            if( iX < pPDev->ctl.ptCursor.x )      // when is ptCursor initialized?  to (0,0) at DrvStartPage().
                //  what command actually ensured the cursor was set to (0,0)?
                //  absolutely none - its should be part of the StartPage command.
                //  If the printer has no absolute movement command,
                //  the StartPage command should include a command to set
                //  the cursor to position (0,0).  If the cursor position cannot
                //  be set to (0,0), then this code is invalid.
            {
                //
                // Relative move left
                //

                if (pCmd = COMMANDPTR(pDrvInfo,CMD_XMOVERELLEFT))
                {
                    //
                    // Optimize to avoid sending 0-move cmd.
                    //

                    //  note all args for relative moves are positive.

                    if ((pPDev->ctl.ptRelativePos.x =
                         pPDev->ctl.ptCursor.x - iX) < pPDev->ptDeviceFac.x)
                        iDiff = pPDev->ctl.ptRelativePos.x;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                    iDiff = -iDiff;
                }
                else
                {
                    //
                    // No Relative left move cmd, use <CR> to reach start
                    // Will try to use relative right move cmd to send later
                    //  assumption is if no rel left move command exists,
                    //  printing in the negative quadrant is impossible.
                    //  because abs moves are never used even if they
                    //  accept  negative args.

                    WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_CARRIAGERETURN));

                    if (pPDev->pGlobals->cxaftercr == CXCR_AT_CURSOR_X_ORIGIN)
                        iRelRightValue = iX;  //*\\  what if this value is negative?
                    else if (pPDev->pGlobals->cxaftercr == CXCR_AT_PRINTABLE_X_ORIGIN)
                    {
                        ASSERT(pPDev->pGlobals->bRotateCoordinate==FALSE);
                        //  assumes printers that support relative right, but not left
                        //  move commands
                        //  do not rotate the cooridinate system.   Kind of strange?
                        //  this is regardless of whether they support abs move.

                        iRelRightValue = iX - pPDev->pf.ptImageOriginM.x;
                    }
                }
            }
            else
            {
                //
                // Relative right move
                // UNIITIALZIED is an invalid position, set to zero
                //

                iRelRightValue = iX - pPDev->ctl.ptCursor.x;
            }

            if( iRelRightValue > 0 )
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_XMOVERELRIGHT))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.x = iRelRightValue) <
                        pPDev->ptDeviceFac.x)
                        iDiff = iRelRightValue;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.x,
                                           pPDev->ptDeviceFac.x);
                }
                else
                    iDiff = iRelRightValue;  //*\\  that's it?  no attempt to move cursor?
            }
        }
    }


    //
    // Peform fine move command
    //

    if ( (fFlag & MV_FINE) && iDiff > 0 )
        iDiff = FineXMoveTo( pPDev, iDiff );

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptCursor.x = iX -  iDiff ;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    if (pPDev->fMode & PF_RESELECTFONT_AFTER_XMOVE)
    {
        VResetFont(pPDev);
    }

    return( iDiff);
}

INT
YMoveTo(
    PDEV    *pPDev,
    INT     iYIn,
    INT     fFlag
    )
/*++

Routine Description:

    This function is called to change the Y position.

Arguments:

    pPDev - Pointer to PDEVICE struct
    iYIn  - Number of units to move in Y direction
    fFlag - Specifies the different Y move operations

Return Value:

    The difference between requested and actual value sent to the device

--*/

{

    INT   iY, iDiff = 0;
    DWORD dwTestValue;
    GPDDRIVERINFO *pDrvInfo = pPDev->pDriverInfo;
    COMMAND *pAbsCmd;
    INT iScale;

    //
    // Convert to Master Units if the given units is in Graphics Units
    // ptGrxScale has been adjusted to suit the current orientation.
    //
    if (pPDev->pOrientation  &&  pPDev->pOrientation->dwRotationAngle != ROTATE_NONE &&
        pPDev->pGlobals->bRotateCoordinate == FALSE)
        iScale = pPDev->ptGrxScale.x;
    else
        iScale = pPDev->ptGrxScale.y;

    if ( fFlag & MV_GRAPHICS )
    {
        iYIn = (iYIn * iScale);
    }

    //
    // Since our print origin may not correspond with the printer's,
    // there are times when we need to adjust the value passed in to
    // match the desired location on the page.
    //

    iY = iYIn;

    //
    // Basically, only adjust if we are doing absolute move
    //
    if ( !(fFlag & (MV_RELATIVE | MV_PHYSICAL)) )
        iY += pPDev->sf.ptPrintOffsetM.y;

    //
    // Adjust iY to be the absolute position
    //

    if( fFlag & MV_RELATIVE )
        iY += pPDev->ctl.ptCursor.y;

    //
    // Update, only update our current cursor position and return
    // Do nothing if the YMoveTo cmd is called to move to the current position.
    //

    if( fFlag & MV_UPDATE )
    {
        pPDev->ctl.ptCursor.y = iY;
        return 0;
    }

    if( pPDev->ctl.ptCursor.y == iY )
        return 0;

    //
    // General assumption: if dwTestValue > dwYMoveThreshold,
    // absolute Y move command will be favored. Also, for iY < 0,
    // use relative command since some printers like old LaserJet have
    // printable area above y=0 accessable only through relative move cmds.
    //

    //
    // BUG_BUG, if we are stripping blanks, we need to check whether
    // it's legal to move in Graphics mode.  If it's not, we have
    // to get out of graphics mode before moving.
    //


    dwTestValue = abs(iY - pPDev->ctl.ptCursor.y);

    if (((pPDev->ctl.dwCursorMode & CURSOR_Y_UNINITIALIZED) ||
        (dwTestValue > pPDev->pGlobals->dwYMoveThreshold &&
        iY > 0)) &&
        (pAbsCmd = COMMANDPTR(pDrvInfo, CMD_YMOVEABSOLUTE)) != NULL)
    {

        //!  if  neg move is the first one, then an absolute move
        //  is issued even though the code explicitly says this is
        //  a Bad thing.
        //  if there are no relative commands and a negative move
        //  is specified, bad things will happen.

        //
        // if the move units are less than the master units then we need to
        // check whether the new position will end up being the same as the
        // original position. If so, no point in sending another command.
        //
        if (!(pPDev->ctl.dwCursorMode & CURSOR_Y_UNINITIALIZED) &&
            (pPDev->ptDeviceFac.y > 1) &&
            ((iY - (iY % pPDev->ptDeviceFac.y)) == pPDev->ctl.ptCursor.y))
        {
            iDiff = iY - pPDev->ctl.ptCursor.y;
        }
        else
        {
            pPDev->ctl.ptAbsolutePos.y = iY;
            pPDev->ctl.ptAbsolutePos.x = pPDev->ctl.ptCursor.x;
            iDiff = WriteChannelEx(pPDev,
                               pAbsCmd,
                               pPDev->ctl.ptAbsolutePos.y,
                               pPDev->ptDeviceFac.y);

            if (pPDev->ctl.dwCursorMode & CURSOR_Y_UNINITIALIZED)
                pPDev->ctl.dwCursorMode &= ~CURSOR_Y_UNINITIALIZED;
        }
    }
    else
    {
        //
        // Use Relavite Y-move commands
        //

        //
        // FYMOVE_SEND_CR_FIRST indicates that it's required to send a CR
        // before each line-spacing command
        //

        //  what does this mean?  that the cursor must be at x=0
        //  before doing a y-move?   or  a <cr> must be sent
        //  before doing a y-move?
        //  if the latter, calling XMoveTo does not ensure the <cr>
        //  is sent.   First, the x pos may already be 0 or
        //  an absolute X move command may be used  as would
        // be the case if the distance moved exceeded the threshold.

        if ( pPDev->fYMove & FYMOVE_SEND_CR_FIRST )
            XMoveTo( pPDev, 0, MV_PHYSICAL );

        //
        //  Use line spacing if that is preferred
        //


        if ( (pPDev->fYMove & FYMOVE_FAVOR_LINEFEEDSPACING) &&
             iY - pPDev->ctl.ptCursor.y > 0  &&
             pPDev->arCmdTable[CMD_SETLINESPACING] != NULL &&
             pPDev->arCmdTable[CMD_LINEFEED] != NULL )
        {
            INT      iLineSpacing;
            DWORD    dwMaxLineSpacing = pPDev->pGlobals->dwMaxLineSpacing;

            while ( dwTestValue )
            {
                iLineSpacing =(INT)(dwTestValue > dwMaxLineSpacing ?
                                        dwMaxLineSpacing : dwTestValue);

                if (pPDev->ctl.lLineSpacing == -1 ||       <== meaningless check.
                    iLineSpacing != pPDev->ctl.lLineSpacing )
                {
                    pPDev->ctl.lLineSpacing = iLineSpacing;
                    WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_SETLINESPACING));
                }

                //
                // Send the LF
                //

                WriteChannel(pPDev, COMMANDPTR(pDrvInfo, CMD_LINEFEED));
                dwTestValue -= (DWORD)iLineSpacing;
            }
        }
        else
        {
            //
            // Use relative command
            //

            PCOMMAND pCmd;

            if ( iY <= pPDev->ctl.ptCursor.y )
            {
                //
                // If there is no RELATIVE UP cmd, do nothing and return
                //

                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELUP))
                {
                    //
                    // optimize to avoid 0-move cmd
                    //
                    if ((pPDev->ctl.ptRelativePos.y =
                         pPDev->ctl.ptCursor.y - iY) < pPDev->ptDeviceFac.y)
                         iDiff = pPDev->ctl.ptRelativePos.y;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                    iDiff = -iDiff;
                }
                else
                    // Do nothing since we can't simulate it
                    iDiff =  (iY - pPDev->ctl.ptCursor.y );
                //  my interpretation of iDiff is you add iDiff to
                // the printers cursor position to get where
                // you really wanted to be.
            }
            else
            {
                if (pCmd = COMMANDPTR(pDrvInfo, CMD_YMOVERELDOWN))
                {
                    pPDev->ctl.ptRelativePos.y = iY - pPDev->ctl.ptCursor.y;

                    //
                    // optimize to avoid 0-move cmd
                    //
                    if (pPDev->ctl.ptRelativePos.y < pPDev->ptDeviceFac.y)
                        iDiff = pPDev->ctl.ptRelativePos.y;
                    else
                        iDiff = WriteChannelEx(pPDev,
                                           pCmd,
                                           pPDev->ctl.ptRelativePos.y,
                                           pPDev->ptDeviceFac.y);
                }
                else        // can't move at all.
                    iDiff = (iY - pPDev->ctl.ptCursor.y );
            }
        }
    }

    //
    // Update our current cursor position
    //

    pPDev->ctl.ptCursor.y = iY - iDiff;

    if( fFlag & MV_GRAPHICS )
    {
        iDiff = (iDiff / iScale);
    }

    return (iDiff);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\bmpdload.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    bmpdload.c

Abstract:

    Implementation of True Type Download as Bitmap routines.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/06/97 -ganeshp-
        Created

--*/

//
//This line should be before the line including font.h.
//Comment out this line to disable FTRC and FTST macroes.
//
//#define FILETRACE

#include "font.h"


BOOL
BFreeTrueTypeBMPPFM(
    PFONTMAP pfm
    )
/*++
Routine Description:
    Frees a downloded font's PFM.
Arguments:
    pfm   Pointer to Fontmap

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/6/1997 -ganeshp-
        Created it.
--*/
{
    if (pfm)
    {
        MemFree(pfm);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



DWORD
DwTrueTypeBMPGlyphOut(
    TO_DATA *pTod
)
 /*++
 Routine Description:
    This functions outputs the downloaded glyphs. All the information is stored
    in TOD

 Arguments:
     pTod   TextOut Data.

Return Value:
    Number of Glyph outputed. O for ERROR.

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    DWORD      dwNumGlyphsPrinted;     // Glyphs Printed
    DWORD      dwCurrGlyphIndex;       // Current Glyph to print.
    DWORD      dwGlyphsToPrint;        // Number of Glyphs to print.
    DWORD      dwCopyOfGlyphsToPrint;  // Copy of dwGlyphsToPrint
    GLYPHPOS   *pgp;                   // Glyph position array.
    PDEV       *pPDev;                 // Our PDEV.
    PDLGLYPH   pdlGlyph;               // Download Glyph information
    INT        iX,  iY;                // X and Y position of Glyphs.
    POINTL     ptlRem;                 // Remainder of XoveTo and YMoveTo.
    BOOL       bSetCursorForEachGlyph; // X and Y position should be set if TRUE

    //
    // Local Initialization.
    //
    dwCurrGlyphIndex        = pTod->dwCurrGlyph;
    dwCopyOfGlyphsToPrint   =
    dwGlyphsToPrint         = pTod->cGlyphsToPrint;
    dwNumGlyphsPrinted      = 0;
    pgp                     = pTod->pgp;
    pPDev                   = pTod->pPDev;
    iX                      = pTod->pgp->ptl.x;
    iY                      = pTod->pgp->ptl.y;

    FTRC(\n********TRACING DwTrueTypeBMPGlyphOut ***********\n);
    FTST(dwCurrGlyphIndex,%d);
    FTST(dwGlyphsToPrint,%d);

    //
    // Set the cursor to first glyph if not already set.
    //
    if ( !(pTod->flFlags & TODFL_FIRST_GLYPH_POS_SET) )
    {

        VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

        //
        // We need to handle the return value. Devices with resoloutions finer
        // than their movement capability (like LBP-8 IV) get into a knot here,
        // attempting to y-move on each glyph. We pretend we got where we
        // wanted to be.
        //

        pPDev->ctl.ptCursor.x += ptlRem.x;
        pPDev->ctl.ptCursor.y += ptlRem.y ;

        //
        // Now set the flag.
        //
        pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;
    }

    //
    // Now start printing. The printing should be optimised for default
    // placement. In this case we assume that GDI has placed the glyphs
    // based upon their width and we don't need to update our cursor pos
    // after every glyph. we print all the glyphs and then move the cursor
    // to the last glyph position. If we know the width of the downloaded
    // glyph then we will update position the cursor at the end of the
    // glyphs box else we will just move to the last glyph cursor position.
    //
    // If the default placement is not set then we print a glyph and move. If
    // we know the width we do some optimization. we find out the new cursor
    // position, by adding the glyph width. If the new position matches that of
    // the next glyph we just update our cursor position else we move to the
    // the next glyph position.
    //

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    while (dwGlyphsToPrint)
    {
        pdlGlyph    = pTod->apdlGlyph[dwCurrGlyphIndex];

        if (bSetCursorForEachGlyph)
        {

            //
            // If we are printing top to down or right to left we need to
            // set the position.
            //

            if( pTod->flAccel & SO_VERTICAL )
            {
                //
                // When we are printing veritcal, only Y changes.X position is
                // same for all glyphs.
                //

                iX  = pTod->ptlFirstGlyph.x;
                iY  = pgp[dwNumGlyphsPrinted].ptl.y;

            }
            else if ( (pTod->flAccel & SO_HORIZONTAL) &&
                      (pTod->flAccel & SO_REVERSED) )
            {
                //
                // This is the Horizental reversed case(Right to Left). In this
                // case only x position changes.Y is set to first glyph's Y.
                //

                iX  = pgp[dwNumGlyphsPrinted].ptl.x;
                iY  = pTod->ptlFirstGlyph.y;

            }
            else
            {
                //
                // The Glyphs are not placed at default positions.Each glyph has
                // explicit X and Y.So we need to move.
                //

                iX  = pgp[dwNumGlyphsPrinted].ptl.x;
                iY  = pgp[dwNumGlyphsPrinted].ptl.y;
            }
            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

        }


        //
        // Default placement or we have moved to the correct position. Now Just
        // print the Glyph.
        //

        if ( !BPrintADLGlyph(pPDev, pTod, pdlGlyph) )
        {
            ERR(("UniFont:DwTrueTypeBMPGlyphOut:BPrintADLGlyph Failed\n"));
            goto ErrorExit;
        }

        //
        // If for each glyph, cursor has to be set, then update cursor position.
        // This may result in fewer Movement command, because if the next
        // glyph's position is at the updated cursor, we will not send any
        // Movement command.
        //

        if( pTod->flAccel & SO_VERTICAL )
            iY += pdlGlyph->wWidth;
        else
            iX  += pdlGlyph->wWidth;

        if (bSetCursorForEachGlyph)
        {
            //
            // If for each glyph, the cursor position has to be set, then iX
            // and iY are already updated. So just use them.
            //

            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE | MOVE_UPDATE, &ptlRem);

        }
        else if (dwGlyphsToPrint == 1) //Last Glyph
        {
            //
            // Set the cursor to the end of the last glyph. Only the X position
            // has to be updated. This has to be done only for default
            // placement, as for non default placement case, we update cursor
            // position after printing the glyph.For default placement use the
            // cursor position of the last glyph.In TextOut Call, for default
            // placement, we have already computed the position for each glyph.
            //

            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE | MOVE_UPDATE, &ptlRem);
        }

        //
        // Update the counters.
        //
        dwGlyphsToPrint--;
        dwNumGlyphsPrinted++;
        dwCurrGlyphIndex++;
    }



    //
    // If no failure then we would have printed all the glyphs.
    //
    ASSERTMSG( (dwNumGlyphsPrinted   == dwCopyOfGlyphsToPrint),
                ("UniFont:DwTrueTypeBMPGlyphOut: All glyphs are not printed"));

    FTRC(After Printing The values are:\n);
    FTST(dwGlyphsToPrint,%d);
    FTST(dwNumGlyphsPrinted,%d);
    FTST(dwCopyOfGlyphsToPrint,%d);
    FTST(dwCurrGlyphIndex,%d);

    ErrorExit:

    FTRC(********END TRACING DwTrueTypeBMPGlyphOut ***********\n);

    return    dwNumGlyphsPrinted;

}

BOOL
BSelectTrueTypeBMP(
    PDEV        *pPDev,
    PFONTMAP    pFM,
    POINTL*     pptl
)
 /*++
 Routine Description:
    To Select a TrueType Downloaded as Bitmap Font.
 Arguments:
     pPDev   Pointer to PDEV
     pDM     fontmap pointer.
     pptl    Point Size of the font, Not used.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet;
    //
    // Local Initialization.
    //
    bRet = FALSE;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        /*
         *  Call BSendFont to download the installed softfont.
         */

        if( !BSendDLFont( pPDev, pFM ) )
            return  FALSE;

        /*
         * Can now select the font:  this is done using a specific
         * ID.  The ID is stored in the FONTMAP structure. The calling
         * function has updated the standard variable so just send
         * CMD_SELECTFONTID command.
         */

        BUpdateStandardVar(pPDev, pFM, 0, 0, STD_CFID );
        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTID));
        bRet = TRUE;
    }


    return bRet;
}

BOOL
BDeselectTrueTypeBMP(
    PDEV        *pPDev,
    PFONTMAP    pFM
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet;
    COMMAND     *pCmd;

    //
    // Local Initialization.
    //
    bRet = FALSE;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        /*
         * Can now select the font:  this is done using a specific
         * ID.  The ID is stored in the FONTMAP structure. The calling
         * function has updated the standard variable so just send
         * CMD_SELECTFONTID command.
         */

        pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_DESELECTFONTID);

        if (pCmd)
        {
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_CFID);
            WriteChannel(pPDev,pCmd );
        }

        bRet = TRUE;
    }


    return bRet;

}

DWORD
DwDLTrueTypeBMPHeader(
    PDEV *pPDev,
    PFONTMAP pFM
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pFM     FontMap for All Font information

Return Value:
    This function returns the memory used to download this font.
    If this function fails, this function has to return 0,

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    DWORD      dwMem;

    //
    // Local Initialization.
    //

    dwMem = DwDLPCLHeader(pPDev, pFM->pIFIMet, pFM->ulDLIndex );

    return    dwMem;

}


DWORD
DwDLTrueTypeBMPGlyph(
    PDEV            *pPDev,
    PFONTMAP        pFM,
    HGLYPH          hGlyph,
    WORD            wDLGlyphId,
    WORD            *pwWidth
    )
/*++
Routine Description:

Arguments:
    pPDev       Pointer to PDEV
    pFM         FontMap data
    hGlyph      Handle to the Glyph.
    wDLGlyphId  Downloaded Glyph Id.
    pwWidth     Width of the Glyph. Update this parameter.

Return Value:
    The memory used to download thsi glyph.

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    DWORD           dwMem;
    TO_DATA         *pTod;
    GLYPHDATA       *pgd;
    PFONTMAP_TTB    pFMTB;
    DL_MAP          *pdm;

    //
    // Initialize Local Variables
    //

    dwMem       = 0;
    pTod        = PFDV->ptod;
    pgd         = NULL;
    pFMTB       = pFM->pSubFM;
    pdm         = pFMTB->u.pvDLData;;

    //
    // Check the Set FontID flag. If this flag is set that means the
    // CMD_SETFONTID command is send and we don't  need to set it again.
    // Else we should send this command as PCL glyph downloding needs this
    // command to be sent, before we download any glyph.
    //

    if (!(PFDV->flFlags & FDV_SET_FONTID))
    {
        pFM->ulDLIndex = pdm->wCurrFontId;
        BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_NFID);
        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
        PFDV->flFlags  |= FDV_SET_FONTID;

    }

    BUpdateStandardVar(pPDev, pFM, wDLGlyphId, 0, STD_GL);

    if( !FONTOBJ_cGetGlyphs( pTod->pfo, FO_GLYPHBITS, (ULONG)1,
                                                &hGlyph, &pgd ) ||
        !(*pwWidth = (WORD)IDLGlyph( pPDev, wDLGlyphId, pgd, &dwMem )) )
    {

        ERR(("Unifont!DwDLTrueTypeBMPGlyph: Downloading Glyph Failed\n"));
        return  0;
    }

    //
    //  Update memory consumption usage
    //
    ((PFONTMAP_TTB)pFM->pSubFM)->dwDLSize += dwMem;

    return    dwMem;

}


BOOL
BCheckCondTrueTypeBMP(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pso,
    IFIMETRICS  *pifi
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     FONTOBJ to download
    pso     StringObj
    pifi    IFI mertics.


Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    INT         iFontIndex;
    DL_MAP      *pdm;
    PFONTPDEV   pFontPDev;
    INT         iGlyphsDL;
    DWORD       cjMemUsed;
    BOOL        bRet;

    //
    // Local variables initialization.
    //
    iFontIndex = PtrToLong(pfo->pvConsumer) - 1;
    pFontPDev = PFDV;
    bRet = FALSE;

    if (pdm = PGetDLMapFromIdx (pFontPDev, iFontIndex))
    {
        //
        // Trunction may have happened.We won't download if the number glyphs
        // or Glyph max size are == MAXWORD.
        //

        if ( (pdm->cTotalGlyphs != MAXWORD) &&
             (pdm->wMaxGlyphSize != MAXWORD) &&
             (pdm->wFirstDLGId != MAXWORD) &&
             (pdm->wLastDLGId != MAXWORD) )
        {
            /*
             * Must now decide whether to download this font or not. This is
             * a guess work. We should try to findout the memory consumption.
             * Check on memory usage.  Assume all glyphs are the largest size:
             * this is pessimistic for a proportional font, but safe, given
             * the vaguaries of tracking memory usage.
             */

            ASSERTMSG((pdm->cTotalGlyphs && pdm->wMaxGlyphSize),\
                      ("pdm->cTotalGlyphs = %d, pdm->wGlyphMaxSize = %d\n",\
                      pdm->cTotalGlyphs,pdm->wMaxGlyphSize));

            iGlyphsDL = min( (pdm->wLastDLGId - pdm->wFirstDLGId),
                             pdm->cTotalGlyphs );

            cjMemUsed = iGlyphsDL * pdm->wMaxGlyphSize;

            if( !(pifi->flInfo & FM_INFO_CONSTANT_WIDTH) )
            {
                /*
                 *   If this is a proportionally spaced font, we should reduce
                 *  the estimate of memory size for this font.  The reason is
                 *  that the above estimate is the size of the biggest glyph
                 *  in the font.  There will (for Latin fonts, anyway) be many
                 *  smaller glyphs,  some much smaller.
                 */

                cjMemUsed /= PCL_PITCH_ADJ;
            }

            /*
             * We only download if the memory used for this font is less than
             * available memory.
             */

            if( (pFontPDev->dwFontMemUsed + cjMemUsed) > pFontPDev->dwFontMem )
            {
                WARNING(("UniFont!BCheckCondTrueTypeBMP:Not Downloading the font:TOO BIG for download\n"));
            }
            else
                bRet = TRUE;

        }
    }
    return bRet;
}



FONTMAP *
InitPFMTTBitmap(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    )
/*++
Routine Description:
    This routine initializes the True Type downloaded(as bitmap) font's PFM.
Arguments:
    pPDev       Pointer to PDEV
    pFontObj    FontObj pointer.

Return Value:
    Pointer to FONTMAP for success and NULL for failure.

Note:

    6/6/1997 -ganeshp-
        Created it.
--*/

{
    PFONTMAP     pfm;
    DWORD        dwSize;

    dwSize = sizeof(FONTMAP) + sizeof(FONTMAP_TTB);

    if ( pfm = MemAlloc( dwSize ) )
    {
        ZeroMemory(pfm, dwSize);
        pfm->dwSignature = FONTMAP_ID;
        pfm->dwSize      = sizeof(FONTMAP);
        pfm->dwFontType  = FMTYPE_TTBITMAP;
        pfm->pSubFM      = (PVOID)(pfm+1);
        pfm->ulDLIndex   = (ULONG)-1;

        //
        // These two entries are meaningless.
        //
        pfm->wFirstChar  = 0;
        pfm->wLastChar   = 0xffff;

        pfm->pfnGlyphOut           = DwTrueTypeBMPGlyphOut;
        pfm->pfnSelectFont         = BSelectTrueTypeBMP;
        pfm->pfnDeSelectFont       = BDeselectTrueTypeBMP;
        pfm->pfnDownloadFontHeader = DwDLTrueTypeBMPHeader;
        pfm->pfnDownloadGlyph      = DwDLTrueTypeBMPGlyph;
        pfm->pfnCheckCondition     = BCheckCondTrueTypeBMP;
        pfm->pfnFreePFM            = BFreeTrueTypeBMPPFM;

    }

    return pfm;

}

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\control\textout.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    textout.c

Abstract:

    Implementation of text output related DDI entry points:
        DrvTextOut

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Initial framework.

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "unidrv.h"

BOOL
DrvTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )

/*++

Routine Description:

    Implementation of DDI entry point DrvTextOut.
    Please refer to DDK documentation for more details.

Arguments:

    pso     - Defines the surface on which to be written.
    pstro   - Defines the glyphs to be rendered and their positions
    pfo     - Specifies the font to be used
    pco     - Defines the clipping path
    prclExtra  - A NULL-terminated array of rectangles to be filled
    prclOpaque - Specifies an opaque rectangle
    pboFore    - Defines the foreground brush
    pboOpaque  - Defines the opaque brush
    pptlOrg    - Pointer to POINT struct , defining th origin
    mix        - Specifies the foreground and background ROPs for pboFore

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PDEV * pPDev;
    PFMPROCS    pFontProcs;

    VERBOSE(("Entering DrvTextOut...\n"));
    ASSERT(pso && pstro && pfo);

    pPDev = (PDEV *)pso->dhpdev;
    ASSERT_VALID_PDEV(pPDev);

    //
    // use driver managed surface
    //
    if (pPDev->pso)
        pso = pPDev->pso;

    //
    // QFE Fix for TTY driver.
    // Set flag if DrvTextOut DDI is called.
    //
    if (pPDev->bTTY)
    {
        pPDev->fMode2 |= PF2_DRVTEXTOUT_CALLED_FOR_TTY;
    }

    //
    // Handle OEM hooks
    //

    HANDLE_OEMHOOKS(pPDev,
                    EP_OEMTextOut,
                    PFN_OEMTextOut,
                    BOOL,
                    (pso,
                     pstro,
                     pfo,
                     pco,
                     prclExtra,
                     prclOpaque,
                     pboFore,
                     pboOpaque,
                     pptlOrg,
                     mix));

    HANDLE_VECTORHOOKS(pPDev,
                    EP_OEMTextOut,
                    VMTextOut,
                    BOOL,
                    (pso,
                     pstro,
                     pfo,
                     pco,
                     prclExtra,
                     prclOpaque,
                     pboFore,
                     pboOpaque,
                     pptlOrg,
                     mix));

    pFontProcs = (PFMPROCS)pPDev->pFontProcs;
    if ( pFontProcs->FMTextOut == NULL)
    {
        CheckBitmapSurface(pso,&pstro->rclBkGround);
        return FALSE;
    }
    else
        return (pFontProcs->FMTextOut(pso, pstro, pfo, pco, prclExtra,
                                        prclOpaque, pboFore, pboOpaque,
                                        pptlOrg, mix) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\ctt2rle.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    ctt2rle.c

Abstract:

     Convert Win 3.1 CTT CTT_WTYPE_DIRECT format tables to NT 4.0  RLE spec.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/10/97 -ganeshp-
        Created

--*/

#include "font.h"


/*
 *   Some useful definitions for memory sizes and masks.
 */


#define DW_MASK    (DWBITS - 1)
#define OVERFLOW_SZ   sizeof( WORD )

NT_RLE  *
PNTRLE1To1(
    IN BOOL  bSymbolCharSet,
    int      iFirst,
    int      iLast
    )
/*++
Routine Description:
    Generates a simple mapping format for the RLE stuff.  This is
    typically used for a printer with a 1:1 mapping to the Windows
    character set.

Arguments:
    iFirst  The lowest glyph in the range.
    iLast   The last glyph in the range (inclusive).

Return Value:
    Address of NT_RLE structure allocated from heap;  NULL on failure.

Note:

    2/10/1997 -ganeshp-
        Created it.
--*/

{

    /*
     *    Operation is simple.   We create a dummy CTT that is a 1:1 mapping,
     *  then call the conversion function to generate the correct values.
     */

    int      iI;        /* Loop index */
    int      iMax;      /* Find the longest data length for CTT_WTYPE_COMPOSE */
    int      cHandles;  /* The number of handles we need */
    int      cjExtra;   /* Extra storage needed for offset modes */
    int      cjTotal;   /* Total amount of storage to be requested */
    int      iIndex;    /* Index we install in the HGLYPH for widths etc */
    int      cRuns;     /* Number of runs we create */
    NT_RLE  *pntrle;    /* Allocated memory, and returned to caller */
    UHG    uhg;         /* Clearer (?) access to HGLYPH contents */

    HGLYPH  *phg;       /* For working through the array of HGLYPHS */

    BYTE    *pb;        /* Current address in overflow area */
    BYTE    *pbBase;    /* Start of overflow area containing data */

    WCRUN   *pwcr;      /* Scanning the run data */

    DWORD   *pdwBits;   /* For figuring out runs */
    DWORD    cdwBits;   /* Size of this area */
    DWORD    cbWch;

    BOOL     bInRun;    /* For processing run accumulations */

    BYTE     ajAnsi[ 256 ];

    WCHAR    wchMin;           /* Find the first unicode value */
    WCHAR    wchMax;           /* Find the last unicode value */
    WCHAR    awch[ 512 ];      /* Converted array of points */

    ASSERT(iFirst == 0x20 && iLast == 0xFF);

    cHandles = iLast - iFirst + 1;

    if( cHandles > 256 )
        return  NULL;      /* This code does not handle that situation */

    cjExtra = 0;           /* Presume no extra storage required */

    /*
     *   We need to figure out how many runs are required to describe
     *  this font.  First obtain the correct Unicode encoding of these
     *  values,  then examine them to find the number of runs, and
     *  hence much extra storage is required.
     */

    ZeroMemory(awch, sizeof(awch));

    for( iI = 0; iI < cHandles; ++iI )
        ajAnsi[ iI ] = (BYTE)(iI + iFirst);

    #ifndef WINNT_40 //NT 5.0

    //
    // force Windows ANSI codepage
    //
    if( -1 == (cbWch = EngMultiByteToWideChar(1252,
                                              awch,
                                              (ULONG)(cHandles * sizeof(WCHAR)),
                                              (PCH) ajAnsi,
                                              (ULONG) cHandles)))
    {
        #if DBG
        DbgPrint( "EngMultiByteToWideChar failed \n");
        #endif
        return NULL;
    }
    cHandles = cbWch;

    #else // NT 4.0
    EngMultiByteToUnicodeN(awch,cHandles * sizeof(WCHAR),NULL,ajAnsi,cHandles);
    #endif //!WINNT_40


    /*
     *  Find the largest Unicode value, then allocate storage to allow us
     *  to  create a bit array of valid unicode points.  Then we can
     *  examine this to determine the number of runs.
     */

    if (bSymbolCharSet)
    {
        for (iI = 0; iI < NUM_OF_SYMBOL; iI ++)
        {
            awch[cHandles + iI] = SYMBOL_START + iI;
        }

        cHandles += NUM_OF_SYMBOL;
    }

    for( wchMax = 0, wchMin = 0xffff, iI = 0; iI < cHandles; ++iI )
    {
        //
        // Bugfix: Euro currency symbol doesn't print.
        // Euro currency symbols Unicode is U+20AC. NLS Unicode to Multibyte
        // table converts 0x80 (Multi byte) to U+20AC. We have to exclude
        // 0x80 from ASCII table. So that we don't substitute U+20AC with
        // device font 0x80.
        //
        if (awch[ iI ] == 0x20ac)
            continue;

        if( awch[ iI ] > wchMax )
            wchMax = awch[ iI ];

        if( awch[ iI ] < wchMin )
            wchMin = awch[ iI ];
    }

    /*
     *    Note that the expression 1 + wchMax IS correct.   This comes about
     *  from using these values as indices into the bit array,  and that
     *  this is essentially 1 based.
     */

    cdwBits = (1 + wchMax + DWBITS - 1) / DWBITS * sizeof( DWORD );

    if( !(pdwBits = (DWORD *)MemAllocZ(cdwBits )) )
    {
        return  NULL;     /*  Nothing going */
    }

    /*
     * Set bits in this array corresponding to Unicode code points
     */

    for( iI = 0; iI < cHandles; ++iI )
    {
        if (awch[ iI ] == 0x20ac)
            continue;

        pdwBits[ awch[ iI ] / DWBITS ] |= (1 << (awch[ iI ] & DW_MASK));
    }

    /*
     *     Now we can examine the number of runs required.  For starters,
     *  we stop a run whenever a hole is discovered in the array of 1
     *  bits we just created.  Later we MIGHT consider being a little
     *  less pedantic.
     */

    bInRun = FALSE;
    cRuns = 0;                 /* None so far */

    for( iI = 1; iI <= (int)wchMax; ++iI )
    {
        if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
        {
            /*
             * Not in a run: is this the end of one?
             */
            if( !bInRun )
            {
                /*
                 * It's time to start one
                 */
                bInRun = TRUE;
                ++cRuns;
            }
        }
        else
        {
            if( bInRun )
            {
                /*   Not any more!  */
                bInRun = FALSE;
            }
        }
    }


    cjTotal = sizeof( NT_RLE ) +
              (cRuns - 1) * sizeof( WCRUN ) +
              cHandles * sizeof( HGLYPH ) +
              cjExtra;

    //
    // Allocate Real NTRLE
    //
    if( !(pntrle = (NT_RLE *)MemAllocZ( cjTotal )) )
    {
        MemFree((LPSTR)pdwBits );

        return  pntrle;
    }

    //
    // For calculating offsets, we need these addresses
    //

    pbBase = (BYTE *)pntrle;

    //
    // FD_GLYPHSET contains the first WCRUN data structure,
    // so that cRun - 1 is correct.
    //
    phg = (HGLYPH *)(pbBase + sizeof( NT_RLE ) + (cRuns - 1) * sizeof( WCRUN ));
    pb = (BYTE *)phg + cHandles * sizeof( HGLYPH );

    pntrle->wType    = RLE_DIRECT;
    pntrle->bMagic0  = RLE_MAGIC0;
    pntrle->bMagic1  = RLE_MAGIC1;
    pntrle->cjThis   = cjTotal;
    pntrle->wchFirst = wchMin;          /* Lowest unicode code point */
    pntrle->wchLast  = wchMax;           /* Highest unicode code point */

    pntrle->fdg.cjThis = sizeof( FD_GLYPHSET ) + (cRuns - 1) * sizeof( WCRUN );
    pntrle->fdg.cGlyphsSupported = cHandles;
    pntrle->fdg.cRuns = cRuns;

    pntrle->fdg.awcrun[ 0 ].wcLow = pntrle->wchFirst;
    pntrle->fdg.awcrun[ 0 ].cGlyphs = (WORD)cHandles;
    pntrle->fdg.awcrun[ 0 ].phg = (HGLYPH*)((BYTE *)phg - pbBase);

    /*
     *   We now wish to fill in the awcrun data.  Filling it in now
     *  simplifies operations later on.  Now we can scan the bit array
     *  data, and so easily figure out how large the runs are and
     *  where abouts a particular HGLYPH is located.
     */

    bInRun = FALSE;
    cRuns = 0;                 /* None so far */
    iMax = 0;                  /* Count glyphs for address arithmetic */

    for( iI = 1; iI <= (int)wchMax; ++iI )
    {
        if( pdwBits[ iI / DWBITS ] & (1 << (iI & DW_MASK)) )
        {
            /*
             * Not in a run: is this the end of one?
             */
            if( !bInRun )
            {
                /*
                 * It's time to start one
                 */
                bInRun = TRUE;
                pntrle->fdg.awcrun[ cRuns ].wcLow = (WCHAR)iI;
                pntrle->fdg.awcrun[ cRuns ].cGlyphs = 0;
                pntrle->fdg.awcrun[ cRuns ].phg = (HGLYPH*)((PBYTE)(phg + iMax) - pbBase);
            }
            pntrle->fdg.awcrun[ cRuns ].cGlyphs++;     /*  One more */
            ++iMax;
        }
        else
        {
            if( bInRun )
            {
                /*   Not any more!  */
                bInRun = FALSE;
                ++cRuns;             /* Onto the next structure */
            }
        }
    }

    if( bInRun )
        ++cRuns;                     /* It has finished now */

    /*
     *    Now go fill in the array of HGLYPHS.  The actual format varies
     *  depending upon the range of glyphs,  and upon the CTT format.
     */

    for( iIndex = 0, iI = iFirst;  iI <= iLast; ++iI, ++iIndex )
    {

        WCHAR  wchTemp;  /* For Unicode mapping */

        /*
         *    Need to map this BYTE value into the appropriate WCHAR
         *  value,  then look for the location of the phg that fits.
         */

        wchTemp = awch[ iIndex ];

        if (wchTemp == 0x20ac)
            continue;

        phg = NULL;                            /* Flag that we failed */
        pwcr = pntrle->fdg.awcrun;

        for( iMax = 0; iMax < cRuns; ++iMax )
        {
            if( pwcr->wcLow <= wchTemp &&
                (pwcr->wcLow + pwcr->cGlyphs) > wchTemp )
            {
                /*
                 * Found the range,  so now select the slot
                 */
                if (pwcr->phg)
                    phg = (HGLYPH*)((ULONG_PTR)pbBase + (ULONG_PTR)pwcr->phg) + wchTemp - pwcr->wcLow;
                else
                    phg = NULL;

                break;
            }
            ++pwcr;
        }

        if( phg == NULL )
            continue;             /* Should not happen */

        uhg.rd.b0     = *((PBYTE)&iI);
        uhg.rd.b1     = 0;
        uhg.rd.wIndex = (WORD)iIndex;
        *phg = uhg.hg;
    }

    if (bSymbolCharSet)
    {
        pwcr = pntrle->fdg.awcrun;

        phg = NULL;

        for ( iMax = 0; iMax < cRuns; ++iMax)
        {
            if (SYMBOL_START == pwcr->wcLow)
            {
                /*
                 * Found the range,  so now select the slot
                 */
                if (pwcr->phg)
                    phg = (HGLYPH*)((ULONG_PTR)pbBase + (ULONG_PTR)pwcr->phg);
                else
                    phg = NULL;

                break;
            }

            ++pwcr;
        }

        if (phg)
        {
            for (iI = SYMBOL_START; iI <= SYMBOL_END; iI ++, iIndex++, phg++)
            {
                uhg.rd.b0     = *((PBYTE)&iI);
                uhg.rd.b1     = 0;
                uhg.rd.wIndex = (WORD)iIndex;
                *phg = uhg.hg;
            }
        }
    }

    //
    // Error check
    //
    if( (pb - pbBase) > cjTotal )
    {
        ERR(( "Rasdd!ctt2rle: overflow of data area: alloc %ld, used %ld\n", cjTotal, pb - pbBase ));
    }

    MemFree( (LPSTR)pdwBits );

    return   pntrle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\dloadpcl.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:
       dloadpcl.c

Abstract:

   Functions associated with downloading fonts to printers.  This
   specifically applies to LaserJet style printers.  There are really
   two sets of functions here:  those for downloading fonts supplied
   by the user (and installed with the font installer), and those
   we generate internally to cache TT style fonts in the printer.


Environment:

    Windows NT Unidrv driver

Revision History:

    03/06/97 -ganeshp-
        Created

--*/

#include "font.h"

#define     PCL_MAX_FONT_HEADER_SIZE      32767
#define     PCL_MAX_CHAR_HEADER_SIZE      32767

#if PRINT_INFO
void vPrintPCLCharHeader(CH_HEADER);
void vPrintPCLFontHeader(SF_HEADER20);
void vPrintPCLChar(char *, WORD, WORD);
#endif


DWORD
DwDLPCLHeader(
    PDEV        *pPDev,
    IFIMETRICS  *pifi,
    INT         id
    )
/*++
Routine Description:
    Given the IFIMETRICS of the font,  and it's download ID,  create
    and send off the download font header.

Arguments:
    pPDev       Pointer to PDEV
    pifi;       IFIMETRICS of this font
    id;         Font Selection ID

Return Value:
    The memory used fo this font.

Note:

    3/6/1997 -ganeshp-
        Created it.
--*/

{
    INT             cjSend;       /* Number of bytes to send down */
    SF_HEADER20     sfh;              /* Structure to send down */
    BYTE            aPCLFontHdrCmd[20];
    INT             iFontHdrCmdLen = 0;
    WORD            wSymSet;
    BYTE            bFontType;
    PFONTPDEV       pFontPDev = pPDev->pFontPDev;


    /*
     *   No major brainwork here.  Basically need to map from IFIMETRICS
     *  to HP's font header structure, swap the bytes, then send it off.
     *  We should be consistent with the (inverse) mapping applied by
     *  the font installer.
     *    NOTE that we use the larger of the 2 headers.  Should this
     *  printer not use the additional resolution fields,  we ignore
     *  that part of the structure.
     */


#if PRINT_INFO
    WCHAR * pwch;
    pwch = (WCHAR *)((BYTE *)pifi + pifi->dpwszFaceName);
    DbgPrint("\nRasdd!iDLHeader:Dumping font,Name is %ws\n",pwch);
#endif


    ZeroMemory( &sfh, sizeof( sfh ) );          /* Safe default values */

    /*
     *   Fill in the structure:  easy to do, and many of the fields
     * are irrelevant anyway,  since the font is selected by ID, and
     * NOT on its attributes.
     */

    if( (pPDev->pGlobals->fontformat == FF_HPPCL))
    {
        sfh.wSize = cjSend = sizeof( SF_HEADER );
        sfh.bFormat = PCL_FM_ORIGINAL;
    }
    else
    {
        /*   Extended format:  allows for resolution */
        sfh.wSize = cjSend = sizeof( SF_HEADER20 );
        sfh.bFormat = PCL_FM_RESOLUTION;
        sfh.wXResn = (WORD)pPDev->ptGrxRes.x;
        sfh.wYResn = (WORD)pPDev->ptGrxRes.y;
    }


    if( pPDev->pGlobals->dlsymbolset == UNUSED_ITEM )
    {
        /*
         *  GPD file doesn't define a symbols set for downloaded fonts.
         *  Now we have a bit of a hack.  Early LaserJets are limited to
         *  the Roman 8 symbol set, which basically allows 0x20 - 0x7f,
         *  and 0xa0 to 0xfe.   We do not have any information which tells
         *  us the capability of this printer.  So we have a compromise:
         *  use the "Can rotate device fonts" flag as an indicator.  If
         *  this bit is set,  we assume the PC-8 symbol set is OK,  otherwise
         *  use Roman 8.  This is a slightly pessimistic assumption, since
         *  we use the LaserJet Series II in Roman 8 mode, when PC-8
         *  is just fine.
         */

        if( pFontPDev->flFlags & FDV_ROTATE_FONT_ABLE )
        {
            //
            // PC-8,  the large symbol set
            // PC-8: 10U -> 341 [ = 10 * 32 + 'U' - 64 ]
            // 8 bit font
            //

            bFontType = PCL_FT_PC8;
            wSymSet = 341;
        }
        else
        {
            //
            // The Roman 8 limited character set
            // Roman 8, 8U -> 277 [ = 8 * 32 + 'U' - 64]
            // Limited 8 bit font
            //

            bFontType = PCL_FT_8LIM;
            wSymSet = 277;
        }
    }
    else
    {
        //
        // Explicit Symbol Set defined in GPD, So use it.
        //

        if( pPDev->pGlobals->dlsymbolset == DLSS_ROMAN8 )
        {
            /*
             * The Roman 8 limited character set. Limited 8 bit font.
             *  Roman 8, 8U -> 277 [ = 8 * 32 + 'U' - 64]
             */

            bFontType = PCL_FT_8LIM;
            wSymSet = 277;       /* */
        }
        else
        {
            /*
             *  PC-8,  the large symbol set. 8 bit font
             *  PC-8: 10U -> 341 [ = 10 * 32 + 'U' - 64 ]
             */

            bFontType = PCL_FT_PC8;
            wSymSet = 341;
        }

    }

    sfh.bFontType = bFontType;
    sfh.wSymSet = wSymSet;


#if PRINT_INFO
    DbgPrint("\nRasdd!iDLHeader:pifi->rclFontBox.top = %d,pifi->fwdWinAscender = %d\n",
             pifi->rclFontBox.top, pifi->fwdWinAscender);

    DbgPrint("UniFont!iDLHeader:pifi->fwdWinDescender = %d, pifi->rclFontBox.bottom = %d\n",
             pifi->fwdWinDescender, pifi->rclFontBox.bottom);
#endif

    sfh.wBaseline = (WORD)max( pifi->rclFontBox.top, pifi->fwdWinAscender );
    sfh.wCellWide = (WORD)max( pifi->rclFontBox.right - pifi->rclFontBox.left + 1,
                                           pifi->fwdAveCharWidth );
    sfh.wCellHeight = (WORD)(1+ max(pifi->rclFontBox.top,pifi->fwdWinAscender) -
                        min( -pifi->fwdWinDescender, pifi->rclFontBox.bottom ));

    sfh.bOrientation = 0; //Set the Orientation to 0 always, else it won't work.

    sfh.bSpacing = (pifi->flInfo & FM_INFO_CONSTANT_WIDTH) ? 0 : 1;

    sfh.wPitch = 4 * pifi->fwdAveCharWidth;      // PCL quarter dots

    sfh.wHeight = 4 * sfh.wCellHeight;
    sfh.wXHeight = 4 * (pifi->fwdWinAscender / 2);

    sfh.sbWidthType = 0;                        // Normal weight
    sfh.bStyle = pifi->ptlCaret.x ? 0 : 1;      // Italic unless upright
    sfh.sbStrokeW = 0;
    sfh.bTypeface = 0;
    sfh.bSerifStyle = 0;
    sfh.sbUDist = -1;                           // Next 2 are not used by us
    sfh.bUHeight = 3;
    sfh.wTextHeight = 4 * (pifi->fwdWinAscender + pifi->fwdWinDescender);
    sfh.wTextWidth  = 4 * pifi->fwdAveCharWidth;

    sfh.bPitchExt = 0;
    sfh.bHeightExt = 0;

    if ( 0 > iDrvPrintfSafeA( sfh.chName, CCHOF(sfh.chName), "Cache %d", id ) )
    {
        // if iDrvPrintfSafeA returns negative, then return.
        return 0;
    }

#if PRINT_INFO
    vPrintPCLFontHeader(sfh);
#endif
    /*
     *   Do the switch:  little endian to 68k big endian.
     */

    SWAB( sfh.wSize );
    SWAB( sfh.wBaseline );
    SWAB( sfh.wCellWide );
    SWAB( sfh.wCellHeight );
    SWAB( sfh.wSymSet );
    SWAB( sfh.wPitch );
    SWAB( sfh.wHeight );
    SWAB( sfh.wXHeight );
    SWAB( sfh.wTextHeight );
    SWAB( sfh.wTextWidth );
    SWAB( sfh.wXResn );
    SWAB( sfh.wYResn );

    if (cjSend > PCL_MAX_FONT_HEADER_SIZE)
        return 0;
    else
    {
        ZeroMemory( aPCLFontHdrCmd, sizeof( aPCLFontHdrCmd ) );
        iFontHdrCmdLen = iDrvPrintfSafeA( aPCLFontHdrCmd, CCHOF(aPCLFontHdrCmd), "\x1B)s%dW", cjSend );
        if ( iFontHdrCmdLen < 0 )
        {
            return 0;
        }

        if( WriteSpoolBuf( pPDev, aPCLFontHdrCmd, iFontHdrCmdLen ) != iFontHdrCmdLen )
            return  0;

    }

    if( WriteSpoolBuf( pPDev, (BYTE *)&sfh, cjSend ) != cjSend )
        return  0;

    return  PCL_FONT_OH;
}

INT
IDLGlyph(
    PDEV        *pPDev,
    int         iIndex,
    GLYPHDATA   *pgd,
    DWORD       *pdwMem
    )
/*++
Routine Description:
   Download the Char bitmap etc. for the glyph passed to us.

Arguments:
    pPDev   Pointer to PDEV
    iIndex  Which glyph this is
    pgd     Details of the glyph
    pdwMem  Add the amount of memory used to this.

Return Value:
    Character width;  < 1 is an error.

Note:

    3/6/1997 -ganeshp-
        Created it.
--*/

{
    /*
     *    Two basic steps:   first is to generate the header structure
     *  and send that off,  then send the actual bitmap data.  The only
     *  complication happens if the download data exceeds 32,767 bytes
     *  of glyph image.  This is unlikely to happen, but we should
     *  be prepared for it.
     */

    int             cbLines;    /* Bytes per scan line (sent to printer) */
    int             cbTotal;    /* Total number of bytes to send */
    int             cbSend;     /* If size > 32767; send in chunks */
    GLYPHBITS       *pgb;       /* Speedier access */
    CH_HEADER       chh;        /* The initial, main header */
    BYTE            aPCLCharHdrCmd[20];
    INT             iCharHdrCmdLen = 0;

    PFONTPDEV       pFontPDev = pPDev->pFontPDev;

    ASSERTMSG(pgd, ("UniFont!IDLGlyph:pgd is NULL.\n"));

    ZeroMemory( &chh, sizeof( chh ) );           /* Safe initial values */

    chh.bFormat = CH_FM_RASTER;
    chh.bContinuation = 0;
    chh.bDescSize = sizeof( chh ) - sizeof( CH_CONT_HDR );
    chh.bClass = CH_CL_BITMAP;

    chh.bOrientation = 0; //Set the Orientation to 0 always, else it won't work.

    pgb = pgd->gdf.pgb;

    chh.sLOff = (short)pgb->ptlOrigin.x;
    chh.sTOff = (short)-pgb->ptlOrigin.y;
    chh.wChWidth = (WORD)pgb->sizlBitmap.cx;       /* Active pels */
    chh.wChHeight = (WORD)pgb->sizlBitmap.cy;      /* Scanlines in bitmap */
    chh.wDeltaX = (WORD)((pgd->ptqD.x.HighPart + 3) >> 2);     /* 28.4 ->14.2 */

    #if PRINT_INFO
       DbgPrint("UniFont!IDLGlyph:Value of (pgd->ptqD.x.HighPart ) is %d\n",
       (pgd->ptqD.x.HighPart ) );
       DbgPrint("UniFont!IDLGlyph:Value of pgb->sizlBitmap.cx is %d\n",
       pgb->sizlBitmap.cx );
       DbgPrint("UniFont!IDLGlyph:Value of pgb->sizlBitmap.cy is %d\n",
       pgb->sizlBitmap.cy );

       vPrintPCLCharHeader(chh);
       vPrintPCLChar((char*)pgb->aj,(WORD)pgb->sizlBitmap.cy,(WORD)pgb->sizlBitmap.cx);
    #endif

    /*
     *   Calculate some sizes of bitmaps:  coming from GDI, going to printer.
     */

    cbLines = (chh.wChWidth + BBITS - 1) / BBITS;
    cbTotal = sizeof( chh ) + cbLines * pgb->sizlBitmap.cy;

    /*   Do the big endian shuffle */
    SWAB( chh.sLOff );
    SWAB( chh.sTOff );
    SWAB( chh.wChWidth );
    SWAB( chh.wChHeight );
    SWAB( chh.wDeltaX );

    // If the char is a pseudo one don't download it.
    if ( !(pgd->ptqD.x.HighPart) )
    {

    #if PRINT_INFO
       DbgPrint("\nRasdd!IDLGlyph:Returning 0 for fake char\n");
    #endif
        return 0;
    }

    /*
     *    Presume that data is less than the maximum, and so can be
     *  sent in one hit.  Then loop on any remaining data.
     */

    cbSend = min( cbTotal, PCL_MAX_CHAR_HEADER_SIZE );

    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETCHARCODE));

    ASSERT(cbSend <= PCL_MAX_CHAR_HEADER_SIZE);

    ZeroMemory( aPCLCharHdrCmd, sizeof( aPCLCharHdrCmd ) );
    iCharHdrCmdLen = iDrvPrintfSafeA( aPCLCharHdrCmd, CCHOF(aPCLCharHdrCmd), "\x1B(s%dW", cbSend );
    PRINTVAL(iCharHdrCmdLen,%d);

    if ( iCharHdrCmdLen < 0 )
    {
        return  0;
    }

    if( WriteSpoolBuf( pPDev, aPCLCharHdrCmd, iCharHdrCmdLen ) != iCharHdrCmdLen )
        return  0;

    if( WriteSpoolBuf( pPDev, (BYTE *)&chh, sizeof( chh ) ) != sizeof( chh ))
        return  0;

    /*   Sent some,  so reduce byte count to compensate */
    cbSend -= sizeof( chh );
    cbTotal -= sizeof( chh );

    cbTotal -= cbSend;                   /* Adjust for about to send data */
    if( WriteSpoolBuf( pPDev, pgb->aj, cbSend ) != cbSend )
        return  0;

    if( cbTotal > 0 )
    {
#if  DBG
        DbgPrint( "UniFont!IDLGlyph: cbTotal != 0:  NEEDS SENDING LOOP\n" );
#endif
        return  0;
    }

    *pdwMem += cbLines * pgb->sizlBitmap.cy;        /* Bytes used, roughly */

    return   (SWAB( chh.wDeltaX ) + 3) >> 2;   /* PCL is in quarter dots! */
}

#if PRINT_INFO
void vPrintPCLCharHeader(chh)
CH_HEADER    chh;
{
    DbgPrint("\nDUMPING FONT PCL GLYPH DESCRIPTOR\n");
    if(chh.bFormat == CH_FM_RASTER)
        DbgPrint("Value of chh.bFormat is CH_FM_RASTER\n");
    DbgPrint("Value of chh.bContinuation is %d \n",chh.bContinuation);
    DbgPrint("Value of chh.bDescSize is %d \n",chh.bDescSize);
    if(chh.bClass == CH_CL_BITMAP)
        DbgPrint("Value of chh.bClass is CH_CL_BITMAP \n");
    DbgPrint("Value of chh.bOrientation is %d \n",chh.bOrientation);
    DbgPrint("Value of chh.sLOff is %u \n",chh.sLOff);
    DbgPrint("Value of chh.sTOff is %u \n",chh.sTOff);
    DbgPrint("Value of chh.wChWidth is %u \n",chh.wChWidth);
    DbgPrint("Value of chh.wChHeight is %u \n",chh.wChHeight);
    DbgPrint("Value of chh.wDeltaX is %u \n",chh.wDeltaX);
}

void vPrintPCLFontHeader(sfh)
SF_HEADER20  sfh;
{
    DbgPrint("\nDUMPING FONT PCL FONT DESCRIPTOR\n");
    DbgPrint("Value of sfh.wSize is %d \n",sfh.wSize);

    if(sfh.bFormat == PCL_FM_RESOLUTION)
        DbgPrint("Value of sfh.bFormat is PCL_FM_RESOLUTION\n");
    else if (sfh.bFormat == PCL_FM_ORIGINAL)
        DbgPrint("Value of sfh.bFormat is PCL_FM_ORIGINAL\n");

    DbgPrint("Value of sfh.wXResn is %d \n",sfh.wXResn);
    DbgPrint("Value of sfh.wYResn is %d \n",sfh.wYResn);

    if(sfh.bFontType == PCL_FT_PC8)
        DbgPrint("Value of sfh.bFontType is PCL_FT_PC8\n");
    else if (sfh.bFontType == PCL_FT_8LIM)
        DbgPrint("Value of sfh.bFontType is PCL_FT_8LIM\n");

    DbgPrint("Value of sfh.wSymSet is %d \n",sfh.wSymSet);
    DbgPrint("Value of sfh.wBaseline is %d \n",sfh.wBaseline);
    DbgPrint("Value of sfh.wCellWide is %d \n",sfh.wCellWide);
    DbgPrint("Value of sfh.wCellHeight is %d \n",sfh.wCellHeight);
    DbgPrint("Value of sfh.bOrientation is %d \n",sfh.bOrientation);
    DbgPrint("Value of sfh.bSpacing is %d \n",sfh.bSpacing);
    DbgPrint("Value of sfh.wPitch is %d \n",sfh.wPitch);

    DbgPrint("Value of sfh.wHeight is %d \n",sfh.wHeight);
    DbgPrint("Value of sfh.wXHeight is %d \n",sfh.wXHeight);

    DbgPrint("Value of sfh.sbWidthType is %d \n",sfh.sbWidthType);
    DbgPrint("Value of sfh.bStyle is %d \n",sfh.bStyle);
    DbgPrint("Value of sfh.sbStrokeW is %d \n",sfh.sbStrokeW);
    DbgPrint("Value of sfh.bTypeface is %d \n",sfh.bTypeface);
    DbgPrint("Value of sfh.bSerifStyle is %d \n",sfh.bSerifStyle);
    DbgPrint("Value of sfh.sbUDist is %d \n",sfh.sbUDist);
    DbgPrint("Value of sfh.bUHeight is %d \n",sfh.bUHeight);
    DbgPrint("Value of sfh.wTextHeight is %d \n",sfh.wTextHeight);
    DbgPrint("Value of sfh.wTextWidth  is %d \n",sfh.wTextWidth);

    DbgPrint("Value of sfh.bPitchExt  is %d \n",sfh.bPitchExt);
    DbgPrint("Value of sfh.bHeightExt is %d \n",sfh.bHeightExt);

}

void vPrintPCLChar(pGlyphBits,wHeight,wWidth)
char * pGlyphBits;
WORD wHeight;
WORD wWidth;
{
    int iIndex1, iIndex2;
    char cMaskBits[8] = {0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x01};
    unsigned char bBitON;

    DbgPrint("\nDUMPING THE GLYPH BITS\n");
    for(iIndex1 = 0;iIndex1 < wHeight; iIndex1++)
    {
        for(iIndex2 = 0;iIndex2 < wWidth; iIndex2++)
        {
            bBitON = (pGlyphBits[iIndex2 / 8] & cMaskBits[iIndex2 % 8]);

            if (bBitON)
                DbgPrint("*");
            else
                DbgPrint("0");

            //if(!(iIndex2%8))
                //DbgPrint("%x ",(unsigned char)(*(pGlyphBits+(iIndex2/8))) );
            //DbgPrint("%x ",(unsigned char)(bBitON >> (7-(iIndex2%8))) );

        }
        pGlyphBits+= (wWidth+7) / 8;
        DbgPrint("\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\download.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:
       download.c

Abstract:

   Functions associated with downloading fonts to printers.  This
   specifically applies to LaserJet style printers.  There are really
   two sets of functions here:  those for downloading fonts supplied
   by the user (and installed with the font installer), and those
   we generate internally to cache TT style fonts in the printer.


Environment:

    Windows NT Unidrv driver

Revision History:

    01/11/97 -ganeshp-
        Created

--*/

#include "font.h"

#define DL_BUF_SZ       4096          /* Size of data chunks for download */

//
//   Local function prototypes.
//


IFIMETRICS*
pGetIFI(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    BOOL    bScale
    );

BOOL
BDownLoadAsTT(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    );

BOOL
BDownLoadAsBmp(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    );

BOOL
BDownLoadOEM(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT       iMode
    );
//
// Macro Definition.
//
#ifdef WINNT_40

#else

#endif //WINNT_40
#define GETWIDTH(pPtqD) ((pPtqD->x.HighPart + 8) / 16)

//
// Main functions
//


BOOL
BDLSecondarySoftFont(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pstro,
    DL_MAP      *pdm
    )
/*++
Routine Description:
    This routine download the secondary soft font. If the True type font has
    more Glyphs that what we can download in soft font then we download a
    secondary font after we use all the glyphs in the current soft font. This
    function also sets the new soft font index(pFM->ulDLIndex) to be used.

Arguments:
    pPDev       Pointer to PDEV
    pfo         The font of interest.
    pdm         Individual download font map element

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet;
    FONTMAP     *pFM;

    //
    // Initialization of Locals .
    //
    bRet   = FALSE;
    pFM = pdm->pfm;


    //
    // PFM->ulDLIndex is used to download new soft font and is set in following
    // download functions.
    //
    if (pFM->dwFontType == FMTYPE_TTBITMAP)
    {
        if (!BDownLoadAsBmp(pPDev, pfo, pstro,pdm,DL_SECONDARY_SOFT_FONT) )
        {
            ERR(("UniFont!BDLSecondarySoftFont:BDownLoadAsBmp Failed\n"));
            goto ErrorExit;

        }

    }
    else if (pFM->dwFontType == FMTYPE_TTOUTLINE)
    {
        if (!BDownLoadAsTT(pPDev, pfo, pstro,pdm,DL_SECONDARY_SOFT_FONT) )
        {
            ERR(("UniFont!BDLSecondarySoftFont:BDownLoadAsTT Failed\n"));
            goto ErrorExit;

        }

    }

    else if (pFM->dwFontType == FMTYPE_TTOEM)
    {
        if (!BDownLoadOEM(pPDev, pfo, pstro,pdm,DL_SECONDARY_SOFT_FONT) )
        {
            ERR(("UniFont!BDLSecondarySoftFont:BDownLoadAsOEM Failed\n"));
            goto ErrorExit;

        }
    }
    //
    // Reset the iSoftfont to -1, so that we send select font command, before
    // outputting the Character.
    //
    PFDV->ctl.iSoftFont = -1;

    bRet = TRUE;

    ErrorExit:
    return bRet;
}


BOOL
BDownloadGlyphs(
    TO_DATA  *ptod,
    STROBJ   *pstro,
    DL_MAP   *pdm
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pdm     DL_MAP struct, all about downloading is in this structure.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{
    PDEV        *pPDev;             // Our PDevice
    FONTOBJ     *pfo;               // Font OBJ
    GLYPHPOS    *pgp;               // Value passed from gre
    FONTMAP     *pFM;               // Font's details
    ULONG       cGlyphs;            // Number of glyphs to process
    ULONG       cGlyphIndex;        // Index to the current glyph.
    WORD        wWidth;             // Width of the Glyph.
    BOOL        bMore;              // Getting glyphs from engine loop
    PDLGLYPH    *ppdlGlyph;         // array of DLGLYPHs pointers.
    DWORD       dwMem;              // Memory require to download the glyph.
    DWORD       dwTotalEnumGlyphs;
    POINTQF     *pPtqD;             // Advance Width Array.
    BOOL        bRet;               // Return Value
    PWCHAR      pwchUnicode;

    //
    // Initialize Local variables.
    //
    pPDev  = ptod->pPDev;
    pfo    = ptod->pfo;
    pFM    = ptod->pfm;
    dwTotalEnumGlyphs =
    cGlyphs           =
    cGlyphIndex       =
    dwMem             = 0;
    pPtqD             = NULL;

    ASSERTMSG((pPDev && pfo && pstro && pFM),\
              ("\nUniFont!BDownloadGlyphs: Wrong values in ptod.\n"));

    bRet   = FALSE;

    //
    // Allocate the array for DLGLYPHs.
    //
    if (!( ppdlGlyph = MemAllocZ( pstro->cGlyphs * sizeof(DLGLYPH *)) ))
    {
        ERR(("UniFont:BDownloadGlyphs: MemAlloc for ppdlGlyph failed\n"));
        goto ErrorExit;
    }

    ptod->apdlGlyph = ppdlGlyph;

    //
    // First Job is to do the enumeration of the glyphs. and then
    // start downloading.
    //

    #ifndef WINNT_40  // NT 5.0

    if (pPtqD = MemAllocZ( pstro->cGlyphs * sizeof(POINTQF)) )
    {
        //
        // Memory Allocation succeded for width array. So call GDI to get
        // the width.
        //
        if (!STROBJ_bGetAdvanceWidths(pstro, 0,  pstro->cGlyphs, pPtqD))
        {
            ERR(("UniFont:BDownloadGlyphs: STROBJ_bGetAdvanceWidths failed\n"));
            goto ErrorExit;
        }
    }
    else
    {
        ERR(("UniFont:BDownloadGlyphs:Memory allocation for width array failed\n"));
        goto ErrorExit;
    }

    #endif //!WINNT_40

    pwchUnicode = pstro->pwszOrg;
    STROBJ_vEnumStart(pstro);

    do
    {
        #ifndef WINNT_40  // NT 5.0

        bMore = STROBJ_bEnumPositionsOnly( pstro, &cGlyphs, &pgp );

        #else             // NT 4.0

        bMore = STROBJ_bEnum( pstro, &cGlyphs, &pgp );

        #endif //!WINNT_40

        dwTotalEnumGlyphs += cGlyphs;

        while ( cGlyphs )
        {

            PDLGLYPH pdlg;
            HGLYPH hTTGlyph;

            #ifdef WINNT_40    // NT 4.0

            GLYPHDATA *pgd;

            if( !FONTOBJ_cGetGlyphs( ptod->pfo, FO_GLYPHBITS, (ULONG)1,
                                                  &pgp->hg, &pgd ) )
            {
               ERR(( "UniFont:BDownloadGlyphs:FONTOBJ_cGetGlyphs fails\n" ))
               goto ErrorExit;
            }
            pPtqD = &(pgd->ptqD);

            #endif //WINNT_40

            hTTGlyph = pgp->hg;
            //
            // search the Glyph in hash table.
            //
            pdlg = *ppdlGlyph = PDLGHashGlyph (pdm,hTTGlyph );

            if (pdlg)
            {
                //
                // We have got a valid Glyph. Check if this is already
                // downloaded or not.
                //
                if (!GLYPHDOWNLOADED(pdlg))
                {
                    //
                    // If the glyph is not downloaded,then fill Glyph structure
                    // and download the Glyph.
                    //

                    if (pdm->wFlags & DLM_UNBOUNDED)
                    {
                        //
                        // Unbounded font. We just have to make sure that
                        // download glyphID is valid. If it's not valid then
                        // we fail the call.
                        //
                        if (pdm->wNextDLGId > pdm->wLastDLGId)
                        {
                            ERR(("UniFont:BDownloadGlyphs:Unbounded Font,no more Glyph Ids\n"));
                            goto ErrorExit;

                        }
                        //
                        // Fill in the Glyph structure. We only set wDLGlyphID.
                        // The new Glyph definition has FontId also. So set that
                        // one also.
                        //
                        pdlg->wDLGlyphID = pdm->wNextDLGId;
                        pdlg->wDLFontId = pdm->wBaseDLFontid;

                    }
                    else
                    {
                        //
                        // Bounded font. It's a bit tricky. We have to do the
                        // same test for avaiable Glyph IDs. If there is no more
                        // glyph Ids, then we have to download a secondary
                        // soft font and reset the cGlyphs and wNextDlGId.
                        //
                        if (pdm->wNextDLGId > pdm->wLastDLGId)
                        {
                            if ( BDLSecondarySoftFont(pPDev, pfo, pstro,pdm) )
                            {
                                //
                                // Reset the Glyph Ids values.
                                //
                                pdm->wNextDLGId =  pdm->wFirstDLGId;
                                pdm->wCurrFontId = (WORD)pdm->pfm->ulDLIndex;

                            }
                            else
                            {
                                //
                                // Failure case. Fail the Call.
                                //
                                ERR(("UniFont:BDownloadGlyphs:Bounded Font,Sec. Font DL failed\n"));
                                goto ErrorExit;
                            }
                        }
                        //
                        // Set the Glyph ID and Font ID in the DLGLYPH.
                        //
                        pdlg->wDLFontId  = pdm->wCurrFontId;
                        pdlg->wDLGlyphID = pdm->wNextDLGId;

                    }

                    //
                    // All error checkings are done, so download now. Set the
                    // width to zero and then pass the address to downloading
                    // function. The downloading function should fill a width
                    // value else it remains zero.
                    //

                    if (pFM->ulDLIndex == -1)
                    {
                        ASSERTMSG(FALSE, ("pFM->ulDLIndex == -1") );
                        goto ErrorExit;
                    }

                    pdlg->wWidth = 0;
                    pdlg->wchUnicode = *(pwchUnicode + cGlyphIndex);
                    wWidth = 0;

                    dwMem = pFM->pfnDownloadGlyph(pPDev, pFM, hTTGlyph,
                                                  pdlg->wDLGlyphID, &wWidth);
                    if (dwMem)
                    {
                        //
                        // All success in downloading the glyph.Mark it
                        // downloaded. This is done by setting the  hTTGlyph to
                        // True Type Glyph Handle.
                        //
                        pdlg->hTTGlyph = hTTGlyph;

                        //
                        // If the download function returns the width use it,
                        // else use the width from GDI.
                        //

                        if (wWidth)
                            pdlg->wWidth = wWidth;
                        else
                        {
                            #ifndef WINNT_40 //NT 5.0

                            pdlg->wWidth = (WORD)GETWIDTH((pPtqD + cGlyphIndex));

                            #else // NT 4.0

                            pdlg->wWidth = GETWIDTH(pPtqD);

                            #endif //!WINNT_40

                        }

                        pdm->cGlyphs++;
                        pdm->wNextDLGId++;

                        //
                        // Update memory consumption before return.
                        //
                        PFDV->dwFontMemUsed += dwMem;
                    }
                    else
                    {
                        //
                        // Failure case. Fail the Call.
                        //
                        ERR(("UniFont:BDownloadGlyphs:Glyph Download failed\n"));
                        goto ErrorExit;

                    }
                }
                else // Glyph is already downloaded.
                {
                    //
                    // If Glyph is already downloaded and we are downloading as
                    // TT outline we need to update the width to current point
                    // size.
                    //

                    if( (pFM->dwFontType == FMTYPE_TTOUTLINE) ||
                        ( (pFM->dwFontType == FMTYPE_TTOEM) &&
                          (((PFONTMAP_TTOEM)(pFM->pSubFM))->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
                        )
                      )
                    {
                        #ifndef WINNT_40 //NT 5.0

                        pdlg->wWidth = (WORD)GETWIDTH((pPtqD + cGlyphIndex));

                        #else // NT 4.0

                        pdlg->wWidth = GETWIDTH(pPtqD);

                        #endif //!WINNT_40

                    }

                }

                pgp++;
                ppdlGlyph++;
                cGlyphIndex++;
                cGlyphs --;
            }
            else
            {
                ERR(("UniFont:BDownloadGlyphs: PDLGHashGlyph failed\n"));
                goto ErrorExit;

            }
        }

    } while( bMore );

    if (dwTotalEnumGlyphs != pstro->cGlyphs)
    {
        ERR(("UniFont:BDownloadGlyphs: STROBJ_bEnum failed to enumurate all glyphs\n"));
        goto ErrorExit;
    }

    bRet = TRUE;
    //
    // ReSet the pFM->ulDLIndex to first Glyph's softfont ID.
    //
    pFM->ulDLIndex = (pdm->wFlags & DLM_UNBOUNDED)?
                     (pdm->wBaseDLFontid):
                     (ptod->apdlGlyph[0]->wDLFontId);

    ErrorExit:
    //
    // If there is a failure then free the DLGLYPH array.
    //
    if (!bRet && ptod->apdlGlyph)
    {
        MEMFREEANDRESET(ptod->apdlGlyph );

    }

    #ifndef WINNT_40   // NT 5.0

    MEMFREEANDRESET(pPtqD );

    #endif //!WINNT_40

    return bRet;
}

BOOL
BDownLoadOEM(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT       iMode
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     The font of interest.
    pstro   The "width" of fixed pitch font glyphs.
    pdm     Individual download font map element

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    PI_UNIFONTOBJ pUFObj;
    PFONTMAP_TTOEM  pfmTTOEM;        // Bitmap download fontmap.
    IFIMETRICS   *pIFI;
    PFONTPDEV     pFontPDev;
    PFONTMAP      pfm;

    DWORD  dwMem;

    //
    // Initialize local variables.
    //
    pFontPDev = pPDev->pFontPDev;
    pUFObj    = pFontPDev->pUFObj;
    dwMem     = 0;

    //
    // Get FONTMAP
    //

    if (iMode == DL_BASE_SOFT_FONT)
    {
        pdm->pfm =
        pfm      = PfmInitPFMOEMCallback(pPDev, pfo);
    }
    else
    {
        pfm = pdm->pfm;
        ASSERTMSG((pfm),("NULL pFM for Secondary Font"));
    }

    if (!pUFObj || !pfm)
    {
        return FALSE;
    }

    if (pfm)
    {
        if (iMode == DL_BASE_SOFT_FONT)
        {
            pfm->pIFIMet =
            pIFI         = pGetIFI(pPDev, pfo, TRUE);
        }
        else
        {
            pIFI = pfm->pIFIMet;
        }

        if (pUFObj->dwFlags & (UFOFLAG_TTDOWNLOAD_BITMAP|
                               UFOFLAG_TTDOWNLOAD_TTOUTLINE) &&
            pIFI)
        {
            if (iMode == DL_BASE_SOFT_FONT)
            {
                pdm->cGlyphs = -1;

                if (pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
                {
                    if (pstro->ulCharInc == 0)
                    {
                        return FALSE;
                    }

                    pIFI->fwdMaxCharInc   =
                    pIFI->fwdAveCharWidth = (FWORD)pstro->ulCharInc;
                }

                pfm->wFirstChar = 0;
                pfm->wLastChar  = 0xffff;

                pfm->wXRes = (WORD)pPDev->ptGrxRes.x;
                pfm->wYRes = (WORD)pPDev->ptGrxRes.y;

                if (!(pFontPDev->flFlags & FDV_ALIGN_BASELINE))
                    pfm->syAdj = pIFI->fwdWinAscender;

                pfm->flFlags = FM_SENT | FM_SOFTFONT | FM_GEN_SFONT;

                if (pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
                    pfm->flFlags |= FM_SCALABLE;

                pfm->ulDLIndex = pdm->wCurrFontId = pdm->wBaseDLFontid;
                pfmTTOEM = pfm->pSubFM;
                pfmTTOEM->u.pvDLData = pdm;

            }
            else
            {
                //
                // Things are different for Secondary Download.Get a new ID.
                //

                if( (pfm->ulDLIndex = IGetDL_ID( pPDev )) == -1 )
                {
                    ERR(( "UniFont!BDownLoadAsBmp:Out of Soft Font Limit,- FONT NOT DOWNLOADED\n"));
                    return FALSE;
                }


            }

            //
            // Send the SETFONTID command. This commands assigns the id to the
            // font being downloaded.
            //


            if( (dwMem = pfm->pfnDownloadFontHeader( pPDev, pfm)) == 0 )
            {
                //
                // Failed to download font header.
                //
                ERR(("UniFont!BDownloadAsOEM:pfnDownloadFontHeader failed.\n"));
                return FALSE;
            }
            else
            {
                //
                // Adjust the Memory
                //
                pFontPDev->dwFontMemUsed += dwMem;

                if (iMode == DL_BASE_SOFT_FONT)
                {
                    pfm->dwFontType = FMTYPE_TTOEM;
                    pdm->cGlyphs = 0;
                    pfmTTOEM->dwDLSize = dwMem;
                }
            }
        }
    }

    return TRUE;

}

BOOL
BDownLoadAsTT(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     The font of interest.
    pstro   The "width" of fixed pitch font glyphs.
    pdm     Individual download font map element
    iMode   Mode of downloading, primary or secondary.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    FONTMAP      *pFM;          // The FONTMAP structure we build up
    BOOL         bRet;          // The value we return
    PFONTPDEV    pFontPDev;     // Font Modules's PDEV
    IFIMETRICS   *pIFI;         // IFI metrics for this font.
    PFONTMAP_TTO pfmTTO;        // Bitmap download fontmap.
    DWORD         dwMem;        // For recording memory consumption

    //
    // Initialize the Local Variables.
    //

    pFontPDev = pPDev->pFontPDev;
    bRet = FALSE;
    dwMem = 0;

    //
    // First Initialize the FontMap.
    //
    if (iMode == DL_BASE_SOFT_FONT)
    {
        pFM = InitPFMTTOutline(pPDev,pfo);
        pdm->pfm = pFM;
    }
    else
    {
        pFM = pdm->pfm;
        ASSERTMSG((pFM),("\nUniFont!BDownLoadAsTT:NULL pFM for Secondary Font"));
    }

    if ( pFM )
    {

        //
        // Check if we can download the font or not, using the present available
        // memory.
        //

        if (iMode == DL_BASE_SOFT_FONT)
        {
            pFM->pIFIMet =
            pIFI         = pGetIFI( pPDev, pfo, FALSE );
        }
        else
        {
            pIFI = pFM->pIFIMet;
        }

        if ( pIFI && pFM->pfnCheckCondition(pPDev,pfo,pstro,pIFI) )
        {
            //
            // There is enough memory to download. So prepare to download.
            // The first step is to get the IFIMETRICS and validate it.
            //

            if (iMode == DL_BASE_SOFT_FONT)
            {

                //
                // Initialize to not download.After successful download we
                // set cGlyphs to 0.
                //
                pdm->cGlyphs = -1;

                if( pIFI->flInfo & FM_INFO_CONSTANT_WIDTH )
                {
                    //
                    // Fixed pitch fonts are not handled.Fixed
                    // pitch fonts should be downloaded as bitmap only.
                    // So return Error.
                    //

                    WARNING(( "UniFont!BDownLoadAsTT:Fixded Pitch Font are not downloaded as Outlie.\n"));
                    goto ErrorExit;

                }

                pFM->wFirstChar = 0;
                pFM->wLastChar = 0xffff;
                pFM->wXRes = (WORD)pPDev->ptGrxRes.x;
                pFM->wYRes = (WORD)pPDev->ptGrxRes.y;
                if( !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
                    pFM->syAdj = pIFI->fwdWinAscender;
                pFM->flFlags = FM_SENT | FM_SOFTFONT |
                               FM_GEN_SFONT | FM_SCALABLE;

                //
                //  wBaseDLFontid is already initialized by BInitDLMap function.
                //
                pFM->ulDLIndex  = pdm->wCurrFontId = pdm->wBaseDLFontid;

                //
                // Initialize the TT Outline specific fields.
                //

                pfmTTO = pFM->pSubFM;
                pfmTTO->pvDLData = pdm;
            }
            else
            {
                //
                // Things are different for Secondary Download. We have to get
                // a new fontID.
                //

                if( (pFM->ulDLIndex = IGetDL_ID( pPDev )) == -1 )
                {
                    ERR(( "UniFont!BDownLoadAsTT:Out of Soft Font Limit,- FONT NOT DOWNLOADED\n"));
                    goto ErrorExit;
                }


            }

            //
            // Send the SETFONTID command. This commands assigns the id to the
            // font being downloaded. And set the flag that this command is
            // already sent. We need to send this command while downloading
            // glyphs also. The download glyph code will check this flag, and
            // send the command only if not sent ( which will happen next time,
            // when same font is used).
            //

            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
            pFontPDev->flFlags  |= FDV_SET_FONTID;

            if( (dwMem = pFM->pfnDownloadFontHeader( pPDev, pFM)) == 0 )
            {
                //
                // Some sort of hiccup while downloading the header.So fail.
                //
                ERR(("UniFont!BDownLoadAsBmp:Err while downloading header,- FONT NOT DOWNLOADED\n"));
                goto ErrorExit;

            }
            //
            // Update memory consumption before return.
            //
            pFontPDev->dwFontMemUsed += dwMem;

            if (iMode == DL_BASE_SOFT_FONT)
            {
                //
                // Successful download.So mark it current.
                //
                pFM->dwFontType = FMTYPE_TTOUTLINE;

                //
                //  Set cGlyphs to 0 to mark that font is Downloaded OK.
                //

                pdm->cGlyphs = 0;

            }

        }
        else
        {
            ERR(( "UniFont!BDownLoadAsTT:NULL IFI or pfnCheckCondition failed.\n") );
            goto ErrorExit;
        }
    }
    else
    {
        //
        // The PFM could not be found or created for this truetype font.
        // Return FALSE to allow some other rendering method to occur.
        //
        WARNING(( "UniFont!BDownLoadAsTT:Fontmap couldn't be created or found.\n") );
        goto ErrorExit;
    }
    //
    // All success, so return TRUE;
    //
    bRet = TRUE;
    ErrorExit:
    return bRet;
}

BOOL
BDownLoadAsBmp(
    PDEV     *pPDev,
    FONTOBJ  *pfo,
    STROBJ   *pstro,
    DL_MAP   *pdm,
    INT      iMode
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV
    pfo     The font of interest.
    pstro   The "width" of fixed pitch font glyphs.
    pdm     Individual download font map element
    iMode   Mode of downloading, primary or secondary.

Return Value:
    TRUE for success and FALSE for failure

Note:

    6/11/1997 -ganeshp-
        Created it.
--*/
{
    FONTMAP      *pFM;          // The FONTMAP structure we build up
    BOOL         bRet;          // The value we return
    PFONTPDEV    pFontPDev;     // Font Modules's PDEV
    IFIMETRICS   *pIFI;         // IFI metrics for this font.
    PFONTMAP_TTB pfmTTB;        // Bitmap download fontmap.
    DWORD         dwMem;        // For recording memory consumption

    //
    // Initialize the Local Variables.
    //

    pFontPDev = pPDev->pFontPDev;
    bRet = FALSE;
    dwMem = 0;

    //
    // First Initialize the FontMap.
    //
    if (iMode == DL_BASE_SOFT_FONT)
    {
        pFM = InitPFMTTBitmap(pPDev,pfo);
        pdm->pfm = pFM;
    }
    else
    {
        pFM = pdm->pfm;
        ASSERTMSG((pFM),("\nUniFont!BDownLoadAsBmp:NULL pFM for Secondary Font"));
    }

    if ( pFM )
    {

        //
        // Check if we can download the font or not, using the present available
        // memory.
        //

        if (iMode == DL_BASE_SOFT_FONT)
        {
            pFM->pIFIMet =
            pIFI         = pGetIFI( pPDev, pfo, TRUE );
        }
        else
        {
            pIFI = pFM->pIFIMet;
        }

        if ( pIFI && pFM->pfnCheckCondition(pPDev,pfo,pstro,pIFI) )
        {
            //
            // There is enough memory to download. So prepare to download.
            // The first step is to get the IFIMETRICS and validate it.
            //

            if (iMode == DL_BASE_SOFT_FONT)
            {

                //
                // Initialize to not download.After successful download we
                // set cGlyphs to 0.
                //
                pdm->cGlyphs = -1;

                if( pIFI->flInfo & FM_INFO_CONSTANT_WIDTH )
                {
                    //
                    // Fixed pitch fonts are handled a little differently.Fixed
                    // pitch fonts should be downloaded as bitmap only.
                    //

                    if( pstro->ulCharInc == 0 )
                    {
                        ERR(( "UniFont!BDownLoadAsBmp:Fixed pitch font,ulCharInc == 0 - FONT NOT DOWNLOADED\n"));
                        goto ErrorExit;
                    }

                    pIFI->fwdMaxCharInc = (FWORD)pstro->ulCharInc;
                    pIFI->fwdAveCharWidth = (FWORD)pstro->ulCharInc;
                }

                pFM->wFirstChar = 0;
                pFM->wLastChar = 0xffff;
                pFM->wXRes = (WORD)pPDev->ptGrxRes.x;
                pFM->wYRes = (WORD)pPDev->ptGrxRes.y;
                if( !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
                    pFM->syAdj = pIFI->fwdWinAscender;
                pFM->flFlags = FM_SENT | FM_SOFTFONT | FM_GEN_SFONT;

                //
                //  wBaseDLFontid is already initialized by BInitDLMap function.
                //
                pFM->ulDLIndex  = pdm->wCurrFontId = pdm->wBaseDLFontid;

                //
                // Initialize the TT Bitmap specific fields.
                //

                pfmTTB = pFM->pSubFM;
                pfmTTB->u.pvDLData = pdm;
            }
            else
            {
                INT iID = IGetDL_ID( pPDev );

                //
                // Things are different for Secondary Download.Get a new ID.
                //

                if( iID < 0 )
                {
                    ERR(( "UniFont!BDownLoadAsBmp:Out of Soft Font Limit,- FONT NOT DOWNLOADED\n"));
                    goto ErrorExit;
                }
                pFM->ulDLIndex  = iID;


            }

            //
            // Send the SETFONTID command. This commands assigns the id to the
            // font being downloaded. And set the flag that this command is
            // already sent. We need to send this command while downloading
            // glyphs also. The download glyph code will check this flag, and
            // send the command only if not sent ( which will happen next time,
            // when same font is used).
            //

            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
            pFontPDev->flFlags  |= FDV_SET_FONTID;

            if( (dwMem = pFM->pfnDownloadFontHeader( pPDev, pFM)) == 0 )
            {
                //
                // Some sort of hiccup while downloading the header.So fail.
                //
                ERR(( "UniFont!BDownLoadAsBmp:Err while downloading header,- FONT NOT DOWNLOADED\n") );
                goto ErrorExit;

            }
            //
            // Update memory consumption before return.
            //
            pFontPDev->dwFontMemUsed += dwMem;

            if (iMode == DL_BASE_SOFT_FONT)
            {
                //
                // Successful download.So mark it current.
                //
                pFM->dwFontType = FMTYPE_TTBITMAP;

                //
                //  Set cGlyphs to 0 to mark that font is Downloaded OK.
                //

                pdm->cGlyphs = 0;

                pfmTTB->dwDLSize = dwMem;

            }

        }
        else
        {
            ERR(( "UniFont!BDownLoadAsBmp:NULL IFI or pfnCheckCondition failed.\n") );
            goto ErrorExit;
        }
    }
    //
    // All success. So return TRUE
    //
    bRet = TRUE;
    ErrorExit:
    return bRet;
}


INT
IDownloadFont(
    TO_DATA  *ptod,
    STROBJ   *pstro,
    INT      *piRot
    )
/*++
Routine Description:
    This function downloads the font and the glyphs. If the font is
    already downloaded, it uses that. It goes through all the glyphs
    and downloads the new one. This function also intializes pfm, iFace
    and apdlGlyph members of TO_DATA.

Arguments:
    ptod    TextOut Data pointer to fill the DLGLYPH array.
    pstro   The "width" of fixed pitch font glyphs.
    piRot   Rotation angle in multiple 90 degree.This is output param
            and used by textout call to set the text rotation.

Return Value:
    Download font index if font is/can be downloaded; else < 0.
    The index is 0 based, i.e first downloaded font has index 0.

Note:

    6/9/1997 -ganeshp-
        Created it.
--*/
{

    DL_MAP          *pdm;          // Individual download font map element
    INT             iRet;          // The value we return: # of entry
    PFONTPDEV       pFontPDev;     // Font Modules's PDEV
    BOOL            bError;        // Set if we have an error.
    PDEV            *pPDev;        // Pdev
    FONTOBJ         *pfo;          // FontOBJ to be used

    //
    // Initialization of Local Variables.
    // Default for iRet is Failure set to -1.
    //

    iRet = -1;
    bError = FALSE;
    pPDev  = ptod->pPDev;
    pfo    = ptod->pfo;

    pFontPDev = pPDev->pFontPDev;

    /*
     * FIRST test is to check for font rotations.  If there is any,
     * we do NOT download this font, as the complications of keeping
     * track with how (or if) the printer allows it are far too great,
     * and, in any event,  it is not likely to gain us much, given the
     * relative infrequency of this event. Also check to see if the
     * printer can rotate fonts or not.
     *
     */

    //
    // Use &pFontPDev->ctl to set correct font size. Also check the rotation.
    //
    *piRot = ISetScale( &pFontPDev->ctl, FONTOBJ_pxoGetXform( pfo ), FALSE , (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

    if(!(pFontPDev->dwSelBits & FDH_PORTRAIT) )
            return  -1;

    //
    // Printer can't rotate text
    //
    if ((!(pFontPDev->flText & (TC_CR_ANY|TC_CR_90)) ||
        (NULL == COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION) &&
         NULL == COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION)))
         && *piRot)
        return -1;
    
    //
    // Printer can rotate 90 rotation
    //
    if ((!(pFontPDev->flText & TC_CR_90) ||
         NULL == COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION))
        && *piRot / 5 != 0)
        return  -1;


    //
    // Get the DL_MAP for this FONTOBJ. The functions sets pvConsumer to
    // 1 based the font index.
    //

    if (pdm = PGetDLMap (pFontPDev,pfo))
    {
        //
        // Given a DL_MAP, Check if it is downloaded or not. If the
        // DL_MAP.cGlyphs > 0 and DL_MAP.pfm is not NULL then this
        // font is downloaded.
        // If This font is Downloaded, return the index. The index
        // is saved in pvConsumer, which is one based. We convert it
        // to zero based.
        //

        iRet = (INT)PtrToLong(pfo->pvConsumer) - 1;


        if (! (FONTDOWNLOADED(pdm)) )
        {
            //
            // Font is a not downloaded. So start the process of downloading.
            // The first job is to fill the DL_MAP structure.
            //
            if (BInitDLMap(pPDev,pfo,pdm))
            {
                //
                // Check what method is preferred to download the font. Try the
                // preferred method first and then the other method.If OEM
                // handles the download then call the OEM download routine.
                //

                if (pFontPDev->flFlags & FDV_DLTT_OEMCALLBACK)
                {
                    //
                    // OEM download.
                    //

                    if (!BDownLoadOEM(pPDev, pfo, pstro, pdm, DL_BASE_SOFT_FONT))
                    {
                        ERR(("UniFont!IDownloadFont:BDownLoadOEM Failed!!\n"));
                        bError = TRUE;
                        iRet = -1;
                        VFreeDLMAP(pdm);
                        pdm->cGlyphs = 0;

                    }

                }
                else
                {
                    if (pFontPDev->flFlags & FDV_DLTT_ASTT_PREF)
                    {
                        //
                        // Try downloading the Bitmap as True Type Outline.
                        //
                        //

                        if (!BDownLoadAsTT(pPDev,pfo,pstro,pdm,DL_BASE_SOFT_FONT))
                        {
                            //
                            // If download as TT fails, we should try to download as
                            // Bitmap. So we free the allocated buffers and then
                            // mark the DL_MAP as new, by setting cGlyphs to 0.
                            //

                            WARNING(("UniFont!IDownloadFont:BDownLoadAsTT Failed\n"));

                            iRet = -1;
                            VFreeDLMAP( pdm );
                            pdm->cGlyphs  = 0;

                            //
                            // Decrement the Font id as we haven't downloaded the
                            // font yet. So reuse it.
                            //

                            pFontPDev->iUsedSoftFonts--;
                            pFontPDev->iNextSFIndex--;

                        }

                    }
                    if ((pFontPDev->flFlags & FDV_DLTT_BITM_PREF) ||
                        ((pFontPDev->flFlags & FDV_DLTT_ASTT_PREF) && (iRet < 0)) )
                    {
                        //
                        // If Downlaod as TT Ouline failed, then try to download as
                        // bitmap. So initialize the DL_MAP again.
                        //
                        if (iRet == -1)
                        {
                            if (!BInitDLMap(pPDev,pfo,pdm))
                            {
    //
    // BInitDLMap Failed
    //
    ERR(("UniFont!IDownloadFont:BInitDLMap Failed for Bitmap Download\n"));
    bError = TRUE;
                            }

                        }

                        if (!bError)
                        {
                            //
                            // If the preffered format is Bitmap or we have incountered
                            // an error while downloading as TT outline; then we try to
                            // download as Bitmap. Reset iRet to Font Index.
                            //

                            iRet = (INT)PtrToLong(pfo->pvConsumer) - 1;
                            if (!BDownLoadAsBmp(pPDev,pfo,pstro,pdm,DL_BASE_SOFT_FONT))
                            {
    ERR(("UniFont!IDownloadFont:BDownLoadAsBmp Failed\n"));
    bError = TRUE;

                            }

                        }
                    }

                    //
                    // 300 dpi mode. We disabled TT downloading if text and graphics
                    // resolutions are not same in intrface.c.
                    //
                    if (!(pFontPDev->flFlags & FDV_DLTT_BITM_PREF) &&
                        !(pFontPDev->flFlags & FDV_DLTT_ASTT_PREF)  )
                        bError = TRUE;
                }

            }
            else
            {
                //
                // BInitDLMap Failed
                //
                ERR(("UniFont!IDownloadFont:BInitDLMap Failed\n"));
                bError = TRUE;
            }

        }

        if  ( pdm != NULL &&
              pdm->pfm != NULL &&
              pdm->pfm->dwFontType == FMTYPE_TTOUTLINE &&
              NONSQUARE_FONT(pFontPDev->pxform))
        {
            //
            // There could be one font, which is scaled differently.
            // PCL5e can't scale x and y independently.
            // Need to print as graphics.
            // So we only set iRet.
            //
            WARNING(("UniFont!IDownloadFont:Err in downloading Glyphs\n"));
            iRet = -1;
        }

        //
        // Now we are done with downloading. if iRet is >= 0 (successful
        // downloading), then try downloading all the glyphs.
        // bDownloadGlyphs will also set download glyph array, apdlGlyph.
        //

        if ((iRet >= 0)  && !bError )
        {
            VERBOSE(("\nUniFont!IDownloadFont:Font downloaded successfully\n"));
            ptod->pfm = pdm->pfm;
            //
            // iFace is -ve to identify that this is a TT SoftFont.
            //
            ptod->iFace = -iRet;

            //
            // OEM callback initialization
            //
            if (pFontPDev->pUFObj)
            {
                PFONTMAP_TTOEM pFMOEM;

                //
                // Make sure that this PFM is for OEM.
                //
                if (ptod->pfm->dwFontType == FMTYPE_TTOEM)
                {
                        pFMOEM = (PFONTMAP_TTOEM) ptod->pfm->pSubFM;
                            pFMOEM->flFontType = pfo->flFontType;
                }

                pFontPDev->pUFObj->ulFontID = ptod->pfm->ulDLIndex;

                //
                // Initialize UFOBJ TrueType font bold/italic simulation
                //
                if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
                {
                    if (pfo->flFontType & FO_SIM_BOLD)
                        pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_BOLD_SIM;


                    if (pfo->flFontType & FO_SIM_ITALIC)
                        pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_ITALIC_SIM;


                    if (NULL != pFontPDev->pIFI &&
                        '@' == *((PBYTE)pFontPDev->pIFI + pFontPDev->pIFI->dpwszFamilyName))

                    {
                        pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_VERTICAL;

                    }
                }
            }

            //
            // Now we are downloading the glyphs, So select the font. This is
            // done by calling BNewFont.
            //
            BNewFont(pPDev, ptod->iFace, ptod->pfm, 0);

            if ( !BDownloadGlyphs(ptod, pstro, pdm ))
            {
                //
                // There is some error in downloading Glyphcs. So don't
                // download. But this not an error. So we only set iRet.
                //
                WARNING(("UniFont!IDownloadFont:Err in downloading Glyphs\n"));
                iRet = -1;
            }
        }

    }

    if (bError)
    {
        //
        // There is some error. So free everything. If pvConsumer is positive
        // then make it negative, to mark it bad.
        //
        if (pfo->pvConsumer > 0)
        {
            pfo->pvConsumer = (PINT_PTR)(-(INT_PTR)pfo->pvConsumer);
        }

        VFreeDLMAP( pdm );
        iRet = -1;

    }
    //
    // Clear the Set Font ID flag. This flag is set per textout
    //
    pFontPDev->flFlags &= ~FDV_SET_FONTID;

    return iRet;

}


#define CONVERT_COUNT   7

IFIMETRICS  *
pGetIFI(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    BOOL    bScale
    )
/*++
Routine Description:
    Given a pointer to a FONTOBJ,  return a pointer to the IFIMETRICS
    of the font.  If this is a TT font,  the metrics will be converted
    with current scaling information.  The IFIMETRICS data is allocated
    on the heap,  and it is the caller's repsonsibility to free it.

Arguments:

    pPDev    pointer to PDEVICE
    pfo      FONTOBJ,The font of interest
    bScale   TRUE for scaling IFIMETRICS else FALSE

Return Value:
    address of IFIMETRICS,  else NULL for failure.

Note:

    3/5/1997 -ganeshp-
        Created it.
--*/

{
    IFIMETRICS  *pIFI;      /* Obtained from engine */
    IFIMETRICS  *pIFIRet;   /* Returned to caller */
    XFORMOBJ    *pxo;       /* For adjusting scalable font metrics */


    POINTL       aptlIn[ CONVERT_COUNT ];       /* Input values to xform */
    POINTL       aptlOut[ CONVERT_COUNT ];      /* Output values from xform */

    pIFI = ((FONTPDEV*)pPDev->pFontPDev)->pIFI;

    if( pIFI == NULL )
        return  NULL;       /* May happen when journalling is in progress */

    /*
     *   We need to make a copy of this,  since we are going to clobber it.
     * This may not be required if we are dealing with a bitmap font, but
     * it is presumed most likely to be a TrueType font.
     */

    if( pIFIRet = (IFIMETRICS *)MemAllocZ(pIFI->cjThis ) )
    {
        /*
         *   First copy the IFIMETRICS as is.  Then,  if a scalable font,
         * we need to adjust the various sizes with the appropriate
         * transform.
         */
        CopyMemory( pIFIRet, pIFI, pIFI->cjThis );


        if( bScale                                      &&
            (pIFIRet->flInfo &
            (FM_INFO_ISOTROPIC_SCALING_ONLY       |
             FM_INFO_ANISOTROPIC_SCALING_ONLY     |
             FM_INFO_ARB_XFORMS))                       &&
            (pxo = FONTOBJ_pxoGetXform( pfo )))
        {
            /*
             *   Scalable,  and transform available,  so go do the
             * transformations to get the font size in device pels.
             *
             ***********************************************************
             *   ONLY SOME FIELDS ARE TRANSFORMED, AS WE USE ONLY A FEW.
             ***********************************************************
             */

            ZeroMemory( aptlIn, sizeof( aptlIn ) );         /* Zero default */

            aptlIn[ 0 ].y = pIFI->fwdTypoAscender;
            aptlIn[ 1 ].y = pIFI->fwdTypoDescender;
            aptlIn[ 2 ].y = pIFI->fwdTypoLineGap;
            aptlIn[ 3 ].x = pIFI->fwdMaxCharInc;
            aptlIn[ 4 ].x = pIFI->rclFontBox.left;
            aptlIn[ 4 ].y = pIFI->rclFontBox.top;
            aptlIn[ 5 ].x = pIFI->rclFontBox.right;
            aptlIn[ 5 ].y = pIFI->rclFontBox.bottom;
            aptlIn[ 6 ].x = pIFI->fwdAveCharWidth;

            /*
             *    Perform the transform,  and verify that there is no
             *  rotation component.  Return NULL (failure) if any of
             *  this fails.
             */

            if( !XFORMOBJ_bApplyXform( pxo, XF_LTOL, CONVERT_COUNT,
                                                     aptlIn, aptlOut )
#if 0
                ||
                aptlOut[ 0 ].x || aptlOut[ 1 ].x ||
                aptlOut[ 2 ].x || aptlOut[ 3 ].y 
#endif
              )
            {
                MemFree((LPSTR)pIFIRet );

                return  NULL;
            }

            /*   Simply install the new values into the output IFIMETRICS */

            pIFIRet->fwdTypoAscender  = (FWORD) aptlOut[0].y;
            pIFIRet->fwdTypoDescender = (FWORD) aptlOut[1].y;
            pIFIRet->fwdTypoLineGap   = (FWORD) aptlOut[2].y;

            pIFIRet->fwdWinAscender   =  pIFIRet->fwdTypoAscender;
            pIFIRet->fwdWinDescender  = -pIFIRet->fwdTypoDescender;

            pIFIRet->fwdMacAscender   = pIFIRet->fwdTypoAscender;
            pIFIRet->fwdMacDescender  = pIFIRet->fwdTypoDescender;
            pIFIRet->fwdMacLineGap    = pIFIRet->fwdTypoLineGap;

            pIFIRet->fwdMaxCharInc = (FWORD)aptlOut[3].x;

            /*
             *    PCL is fussy about the limits of the character cell.
             *  We allow some slop here by expanding the rclFontBox by
             *  one pel on each corner.
             */
            pIFIRet->rclFontBox.left = aptlOut[ 4 ].x - 1;
            pIFIRet->rclFontBox.top = aptlOut[ 4 ].y + 1;
            pIFIRet->rclFontBox.right = aptlOut[ 5 ].x + 1;
            pIFIRet->rclFontBox.bottom = aptlOut[ 5 ].y - 1;
            pIFIRet->fwdAveCharWidth = (FWORD)aptlOut[ 6 ].x;

            VERBOSE(("\n UniFont!pGetIFI:pIFI->fwdTypoAscender = %d,pIFI->fwdTypoDescender = %d\n",pIFI->fwdTypoAscender,pIFI->fwdTypoDescender));
            VERBOSE(("UniFont!pGetIFI:pIFI->fwdWinAscender = %d, pIFI->fwdWinDescender = %d\n", pIFI->fwdWinAscender,pIFI->fwdWinDescender ));
            VERBOSE(("UniFont!pGetIFI:pIFI->rclFontBox.top = %d,pIFI->rclFontBox.bottom = %d\n", pIFI->rclFontBox.top, pIFI->rclFontBox.bottom));
            VERBOSE(("UniFont!pGetIFI: AFTER SCALING THE FONT\n"));
            VERBOSE(("UniFont!pGetIFI:pIFIRet->fwdTypoAscender = %d,pIFIRet->fwdTypoDescender = %d\n",pIFIRet->fwdTypoAscender,pIFIRet->fwdTypoDescender));
            VERBOSE(("UniFont!pGetIFI:pIFIRet->fwdWinAscender = %d, pIFIRet->fwdWinDescender = %d\n", pIFIRet->fwdWinAscender,pIFIRet->fwdWinDescender ));
            VERBOSE(("UniFont!pGetIFI:pIFIRet->rclFontBox.top = %d,pIFIRet->rclFontBox.bottom = %d\n", pIFIRet->rclFontBox.top, pIFIRet->rclFontBox.bottom));

        }
    }

    return  pIFIRet;

}

#undef    CONVERT_COUNT

BOOL
BSendDLFont(
    PDEV     *pPDev,
    FONTMAP  *pFM
    )
/*++
Routine Description:
    Called to download an existing softfont.  Checks to see if the
    font has been downloaded,  and if so,  does nothing.  Otherwise
    goes through the motions of downloading.

Arguments:
    pPDev   Pointer to PDEV
    pFM     The particular font of interest.

Return Value:
       TRUE/FALSE;  FALSE only if there is a problem during the load.

Note:

    3/4/1997 -ganeshp-
        Created it.
--*/

{

    FONTMAP_DEV *pFMDev;
    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    PDATA_HEADER pDataHeader;
    PBYTE        pDownloadData;
    DWORD        dwLeft;               // Bytes remaining to send
    /*
     *   First see if it has already been downloaded!
     */

    if( pFM->flFlags &  (FM_SENT | FM_GEN_SFONT) )
        return  TRUE;

    pFMDev = (PFONTMAP_DEV)pFM->pSubFM;

    if (!(pDataHeader = FIGetVarData( pFontPDev->hUFFFile, pFMDev->dwResID)) ||
        pDataHeader->dwSignature != DATA_VAR_SIG ||
        pDataHeader->dwDataSize == 0 )
        return FALSE;

    dwLeft = pDataHeader->dwDataSize;
    pDownloadData = ((PBYTE)pDataHeader + pDataHeader->wSize);

    /*
     *    Check if there is memory to fit this font.  These are all
     *  approximations,  but it is better than running out of memory
     *  in the printer.
     */

    if( (pFontPDev->dwFontMemUsed + PCL_FONT_OH + dwLeft) > pFontPDev->dwFontMem )
        return  FALSE;

    /*
     *    Time to be serious about downloading.  UniDrive provides some
     * of the control stuff we need.  As well, we need to select an ID.
     * The font itself is memory mapped,  so we need only to shuffle it
     * off to WriteSpoolBuf().
     */

    pFM->ulDLIndex = IGetDL_ID( pPDev );     /* Down load index to use */

    if( pFM->ulDLIndex == -1 )
        return   FALSE;                   /* Have run out of slots! */

    /*
     *   Downloading is quite simple.  First send an identifying command
     * (to label the font for future selection) and then copy the font
     * data (in the *.fi_ file) to the printer.
     */

    BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD|STD_NFID);
    WriteChannel( pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID) );

    while( dwLeft )
    {

        DWORD    cjSize;             /*  Number of bytes to send */

        cjSize = min( dwLeft, DL_BUF_SZ );

        if( WriteSpoolBuf( pPDev, pDownloadData, cjSize ) != (int)cjSize )
        {
            break;
        }

        if( pPDev->fMode & PF_ABORTED )
            break;

        dwLeft -= cjSize;
        pDownloadData += cjSize;
    }

    /*
     *   If dwLeft is 0,  then everything completed as expected.  Under these
     *  conditions, we flag the data as having been sent, and thus available
     *  for use.   Even if we failed,  we should assume we have consumed
     *  all the font's memory and adjust our records accordingly.
     */

    if( dwLeft == 0 )
        pFM->flFlags |= FM_SENT;             /* Now done */

    /*
     *   Account for memory used by this font.
     */

    pFontPDev->dwFontMemUsed += PCL_FONT_OH + pDataHeader->dwDataSize;

    return  dwLeft == 0;

}


DWORD
DwGetTTGlyphWidth(
    FONTPDEV *pFontPDev,
    FONTOBJ  *pfo,
    HGLYPH   hTTGlyph)
/*++
Routine Description:

Arguments:
    pFontPDev Font  PDevice
    pfo       Fontobj
    hTTGlyph  Glyph handle

Return Value:
    Character width

Note:

--*/
{
    DLGLYPH *pdlg;
    DL_MAP  *pdm;
    DWORD    dwRet;

    if (!pfo || !pFontPDev)
        return 0;

    if (!(pdm = PGetDLMap (pFontPDev,pfo)) ||
        !(pdlg = PDLGHashGlyph (pdm, hTTGlyph)))
    {
        dwRet = 0;
    }
    else
    {
        dwRet = pdlg->wWidth;
    }


    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\dlutils.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    dlutils.c

Abstract:

    Download Modules utilts functions.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/02/97 -ganeshp-
        Created

--*/

#include "font.h"

#define HASH(num,tablesize)     (num % tablesize)


PDLGLYPH
PDLGNewGlyph (
    DL_MAP     *pDL
    )
/*++

Routine Description:


Arguments:

    pDL     Pointer to DownloadMap for the downloaded font.

Return Value:

    Pointer to the new DLGLYPH for success and NULL for failure.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    GLYPHTAB    *pGlyphTab;
    PDLGLYPH    pDLGlyph = NULL;

    if (pGlyphTab = pDL->GlyphTab.pGLTNext)
    {
        //
        //Go to the end of the List.
        //
        while (pGlyphTab && !pGlyphTab->cEntries)
            pGlyphTab = pGlyphTab->pGLTNext;
    }
    //
    //Allocate a new Chunk, if we need a new one.
    //
    if (!pGlyphTab)
    {
        INT cEntries = pDL->cHashTableEntries / 2; // Half the size of hash table.

        if (pGlyphTab = (GLYPHTAB *)MemAllocZ( sizeof(GLYPHTAB) +
                                               cEntries * sizeof(DLGLYPH) ))
        {
            PVOID pTemp;

            //
            //Skip the header.
            //
            pGlyphTab->pGlyph = (PDLGLYPH)(pGlyphTab + 1);
            pGlyphTab->cEntries = cEntries;

            //
            //Add in the begining of the list.
            //
            pTemp = pDL->GlyphTab.pGLTNext;
            pDL->GlyphTab.pGLTNext = pGlyphTab;
            pGlyphTab->pGLTNext = pTemp;
        }
        else
            ERR(("Unifont!PDLGNewGlyph:Can't Allocate the Glyph Chunk.\n"));
    }

    //
    //If the chunk has available entries, return the new pointer.
    //
    if (pGlyphTab && pGlyphTab->cEntries)
    {
        pDLGlyph = pGlyphTab->pGlyph;
        pGlyphTab->pGlyph++;
        pGlyphTab->cEntries--;
    }
    //
    // Initialize the hTTGlyphs to Invalid.
    //
    if (NULL != pDLGlyph)
        pDLGlyph->hTTGlyph = HGLYPH_INVALID;

    return pDLGlyph;
}

PDLGLYPH
PDLGHashGlyph (
    DL_MAP     *pDL,
    HGLYPH      hTTGlyph
    )
/*++

Routine Description:
    This routine searches the Hash table for a given Glyph. If the
    Glyph is not found in the Has table it creats an entry and add
    that into the list. The new entry is not filled.

Arguments:

    pDL         Pointer to DownloadMap Structure for the downloaded font.
    hTTGlyph    True Type Glyph Handle.

Return Value:
    Pointer to the DLGLYPH for success and NULL for failure.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    INT         iHashedEntry;
    BOOL        bFound;
    PDLGLYPH    pDLHashedGlyph = NULL,
                pDLG           = NULL;

    if (pDL->cHashTableEntries)
    {
        //
        // Hashing is done on TT handle.
        //
        iHashedEntry  =  HASH(hTTGlyph,pDL->cHashTableEntries);
        pDLG = pDLHashedGlyph = pDL->GlyphTab.pGlyph + iHashedEntry;

        //
        //Proceed if the pointer is valid
        //
        if (pDLHashedGlyph)
        {
            //
            // Check if this is the Glyph we are interested in.
            //  We should test if this glyph is new glyph or not.
            //
            if (!GLYPHDOWNLOADED(pDLHashedGlyph) )
            {
                //
                // If this is a new glyph which is not downloaded then return
                // this pointer.
                //
                bFound = TRUE;


            }
            else if (pDLHashedGlyph->hTTGlyph != hTTGlyph)
            {
                pDLG = pDLHashedGlyph->pNext;
                bFound = FALSE;

                //
                // Not the same Glyph, It's a Collision. Search the Linked list.
                //
                while (pDLG)
                {
                    if (pDLG->hTTGlyph == hTTGlyph)
                    {
                        bFound = TRUE;
                        break;
                    }
                    else
                        pDLG = pDLG->pNext;

                }
                //
                // If the Glyph is found in the linked list, return the pointer;
                // else create a new Glyph and add at the linked list. We add in
                // the begining.
                //

                if (!bFound)
                {
                    if ( pDLG = PDLGNewGlyph(pDL) )
                    {
                        PDLGLYPH pTemp;

                        //
                        // Don't Fill  in the Glyph. All the fields are set
                        // by the DownLoad Glyph function.
                        //

                        //
                        // Add the New Glyph at the begining of the list.
                        //
                        pTemp = pDLHashedGlyph->pNext;
                        pDLHashedGlyph->pNext = pDLG;
                        pDLG->pNext = pTemp;

                    }
                    else
                    {
                        pDLG = NULL;
                        ERR(("Unifont!PDLGHashGlyph:Can't Create the Glyph.\n"));
                    }
                }

            }

        }
    }
    ASSERTMSG(pDLG,("Unifont!PDLGHashGlyph:ERROR Null Hashed Glyph.\n"));
    return pDLG;
}

DL_MAP_LIST *
PNewDLMapList()
/*++
Routine Description:
    Allocate and initialise a new DL_MAP_LIST structure.  These
    are placed in a linked list (by our caller).

Arguments: None

Return Value:
    The address of the structure,  or NULL on failure.

Note:

    3/5/1997 -ganeshp-
        Created it.
--*/
{

    DL_MAP_LIST   *pdml;


    /*
     *    Little to do:  if we can allocate the storage, then set it to 0.
     */

    if( pdml = (DL_MAP_LIST *)MemAllocZ(sizeof( DL_MAP_LIST ) ) )
        return  pdml;
    else
        return NULL;
}

DL_MAP *
PNewDLMap (
    PFONTPDEV     pFontPDev,
    INT           *iFontIndex
    )
/*++

Routine Description:
    This routine return a new DL_MAP pointer.

Arguments:

    pFontPDev           Font Modules's PDEV.
    iFontIndex          Index of the new DL_MAP. The index is used to
                        identify the downloaded font.Filled by this function.
                        Zero is first index.
Return Value:

    Pointer to DL_MAP for success and NULL for failure
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    DL_MAP_LIST  *pdml;          // The linked list of font information
    DL_MAP       *pdm;           // Individual map element

    pdml = pFontPDev->pvDLMap;
    *iFontIndex = 0;
    pdm         = NULL;

    //
    // If no DL List, create one.
    //
    if( pdml == NULL )
    {
        //
        // None there,  so create an initial one.
        //
        if( pdml = PNewDLMapList() )
        {
            pFontPDev->pvDLMap = pdml;
        }
        else
        {
            ERR(("Unifont!PNewDLMap(1):Can't Allocate the DL_MAP_LIST Chunk.\n"));
        }

    }
    //
    // The list should be not null. else return NULL.
    //
    if (pdml)
    {
        for( pdml = pFontPDev->pvDLMap; pdml->pDMLNext; pdml = pdml->pDMLNext )
        {
            //
            // While looking for the end,  also count the number we pass.
            //
            *iFontIndex += pdml->cEntries;
        }

        if( pdml->cEntries >= DL_MAP_CHUNK )
        {
            if( !(pdml->pDMLNext = PNewDLMapList()) )
            {
                ERR(("Unifont!PNewDLMap(2):Can't Allocate the DL_MAP_LIST Chunk.\n"));
                return  NULL;
            }
            //
            // The new current model.
            //
            pdml = pdml->pDMLNext;
            //
            // Add in the full one.
            //
            *iFontIndex += DL_MAP_CHUNK;
        }

        pdm = &pdml->adlm[ pdml->cEntries ];
        //
        // Increment the iFontIndex first as the it is 0 based.
        // For 1st entry the index will be 0.
        //
        *iFontIndex += pdml->cEntries;
        pdml->cEntries++;
    }
    return pdm;
}


VOID
VFreeDLMAP (
    DL_MAP   *pdm
    )
/*++

Routine Description:
    This function fress DL_MAP structure contents - but NOT the map.

Arguments:

    pdm  Pointer to  DL_MAP structure whose contents has to be freed.

Return Value:

    Nothing.

Note:

    01/15/97 -ganeshp-
        Created it.
--*/
{

    FONTMAP    *pFM;
    PVOID       pTemp;
    GLYPHTAB    *pGT;
    ULONG_PTR     iTTUniq;


    /*
     *   Simply free the storage contained within the FONTMAP structure.
     */

    if (pdm )
    {
        if (pFM = pdm->pfm)
        {
            //
            // Try to Free what we allocated.
            //
            MEMFREEANDRESET((LPSTR)pFM->pIFIMet );

            if (pFM->pfnFreePFM)
            {
                //
                // Free The pfm by calling the helper function.
                //
                pFM->pfnFreePFM(pFM);
            }
            else
            {
                ERR(("UniFont!VFreeDLMAP: NUll pfnFreePFM function pointer, Can't free pFM\n"));

                //
                // Try to Free what we know about.
                //
                MemFree( (LPSTR)pFM);
            }
        }


        //
        // Free the Glyph Table.
        //
        pGT = pdm->GlyphTab.pGLTNext;

        while (pGT)
        {
            pTemp = pGT->pGLTNext;
            MemFree((LPSTR)pGT);
            pGT = pTemp;

        }

        //
        // Now free the base hash table.
        //
        MEMFREEANDRESET( (LPSTR)pdm->GlyphTab.pGlyph );


        //
        // Zero the memory and make cGlyphs to -1 so that it's not used.
        // Save the iTTUniq for future reference.
        //
        iTTUniq     = pdm->iTTUniq;
        ZeroMemory(pdm, sizeof(DL_MAP));
        pdm->iTTUniq = iTTUniq;
        pdm->cGlyphs = -1;

    }

    return;
}

VOID
VFreeDL(
    PDEV  *pPDev
    )
/*++

Routine Description:
    Function to free up all the downloaded information.  Basically
    work through the list,  calling VFreeDLMAP for each entry.

Arguments:

    pPDev   Access to our data.

Return Value:

    Nothing.

Note:

    01/15/97 -ganeshp-
        Created it.
--*/
{

    DL_MAP_LIST     *pdml;                 /* The linked list of font information */
    PFONTPDEV       pFontPDev = PFDV;        /* It's used a few times */


    if( pdml = pFontPDev->pvDLMap )
    {
        /*
         *    There is downloaded data,  so off we go.
         */

        INT      iI;

        /*
         *    Scan through each of the arrays of header data.
         */

        while( pdml )
        {

            DL_MAP_LIST  *pdmlTmp = NULL;

            /*
             *    Scan through each entry in the array of header data.
             */

            for( iI = 0; iI < pdml->cEntries; ++iI )
                VFreeDLMAP( &pdml->adlm[ iI ] );

            pdmlTmp = pdml;
            //
            // Remember the next one
            //
            pdml = pdml->pDMLNext;

            MemFree((LPSTR)pdmlTmp);

        }
    }
    //
    //  Reset Download specific variables.
    //
    pFontPDev->pvDLMap = NULL;
    pFontPDev->iNextSFIndex = pFontPDev->iFirstSFIndex;
    pFontPDev->iUsedSoftFonts = 0;
    pFontPDev->ctl.iFont = INVALID_FONT;
    pFontPDev->ctl.iSoftFont = -1;

    return;

}

DL_MAP *
PGetDLMapFromIdx (
    PFONTPDEV   pFontPDev,
    INT         iFontIndex
    )
/*++

Routine Description:
    This routine return a  DL_MAP pointer, given it's index..

Arguments:
    pFontPDev           Font PDEV.
    iFontIndex          Index of the  DL_MAP. The index is used to
                        identify the downloaded font. Zero is first index.
Return Value:

    Pointer to DL_MAP for success and NULL for failure
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    DL_MAP_LIST  *pdml;          // The linked list of font information
    DL_MAP       *pdm;           // Individual map element

    pdml = pFontPDev->pvDLMap;
    pdm  = NULL;

    //
    // If the index is negative that means this is a new font. So we should
    // search sequentially.
    //
    if (iFontIndex < 0)
        return NULL;

    //
    // The list should be not null. else return NULL.
    //
    while( pdml )
    {
       //
       // Is this chunk the one containing the entry?
       //
       if( iFontIndex >= pdml->cEntries )
       {
           //
           // Not this one, so onto the next.
           //
           iFontIndex -= pdml->cEntries;

           pdml = pdml->pDMLNext;
       }
       else
       {
           //
           // We got it!
           //
           pdm = &pdml->adlm[ iFontIndex ];

           break;
       }
    }

    return pdm;
}


BOOL
BSameDLFont (
    PFONTPDEV       pFontPDev,
    FONTOBJ         *pfo,
    DL_MAP          *pdm
    )
/*++

Routine Description:
    This routine finds out if input DL_MAP represents the FONTOBJ or not.

Arguments:

    pFontPDev           Font Modules's PDEV.
    pfo                 FontObj.
    pdm                 Individual download map element.

Return Value:

    TRUE if DL_MAP represents FONTOBJ else FALSE.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    //
    // The checks are different for download TT as outline and download
    // as TT OutLine. For Download a Bitmap we check iUniq and for download
    // as TT Outline we have to use iTTUniq. If the same printer can support
    // both format we may download the font as any one of the format.
    //

    FONTMAP *pfm = pdm->pfm;

    if (pfm)
    {
        if (pfm->dwFontType == FMTYPE_TTBITMAP)
        {
            return ((pdm->iUniq == pfo->iUniq) && (pdm->iTTUniq == pfo->iTTUniq));
        }
        else if (pfm->dwFontType == FMTYPE_TTOUTLINE)
        {
            //
            // The truetype font is equivalent if the iTTUniq is the same *and*
            // the font-type field matches.
            //
            PFONTMAP_TTO pFMTTO = (PFONTMAP_TTO) pdm->pfm->pSubFM;
            return (pdm->iTTUniq == pfo->iTTUniq) &&
                   (pFMTTO->flFontType == pfo->flFontType);
        }
        else
        if (pfm->dwFontType == FMTYPE_TTOEM)
        {
            PFONTMAP_TTOEM  pTTOEM = pfm->pSubFM;
            ASSERT(pTTOEM);

            //
            // TrueType Outline for OEM
            //
            if (pTTOEM->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
            {
                return (pdm->iTTUniq == pfo->iTTUniq) &&
                       (pTTOEM->flFontType == pfo->flFontType);
            }
            else
            //
            // Bitmap for OEM
            //
            if (pTTOEM->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
            {
                return ((pdm->iUniq == pfo->iUniq) &&
                        (pdm->iTTUniq == pfo->iTTUniq));
            }
        
        }
    }

    return FALSE;

}

DL_MAP *
PGetDLMap (
    PFONTPDEV       pFontPDev,
    FONTOBJ         *pfo
    )
/*++

Routine Description:
    This routine searches a FontObj in DL_MAP_LIST.If the FONTOBJ is found
    (Means this font has been downloaded), then this function return the
    DL_MAP pointer. If FONTOBJ can't be found (New font which is not
    downloaded), a new DL_MAP * is returned. In Case of error we return
    NULL. In that case we shouldn't download. A Bad DL_MAP is marked  by
    having cGlyphs value to -1. This function will also set pvConsumer field
    of pfo, if a new DL_MAP is returned.
Arguments:

    pFontPDev           Font Modules's PDEV.
    pfo                 FontObj.

Return Value:

    Pointer to DL_MAP for success and NULL if no match.
Note:

    06/02/97 -ganeshp-
        Created it.
--*/
{
    DL_MAP      *pdm;           // Individual download map element.
    BOOL        bFound;         // The font is found or not in the list.
    INT         iFontIndex;     // Download Font Index in DL_MAP List.

    //
    // All we have to do is look into the DL_MAP list and find a DL_MAP with
    // same signature. For optimization purposes we tag the pvConsumer field
    // with the FontIndex, which is index into the list. For example for first
    // downloaded font pvConsumer is set to 1. As pvConsumer field is not
    // cached for each DC, we will use this field with caution. So if pvConsumer
    // is > 0, then we get the DL_MAP using pvConsumer and then check iUniq and
    // iTTUniq. We only use the DL_MAP if these fields also match. Else we do
    // an exausitive linear search in DL_MAP list. This approach will optimize
    // for normal printing, because most of the time only one job is getting
    // printed.
    //

    bFound  = FALSE;

    if( iFontIndex = PtrToLong(pfo->pvConsumer) )
    {
        /*
         *   As we control the pvConsumer field,  we have the choice
         *   of what to put in there.  SO,  we decide as follows:
         *    > 0 - index into our data structures for good DL_MAP.
         *      0 - virgin data,  so look to see what to do.
         *    < 0 - Index into our data str for Bad FONT. NO download.
         *          In this case cGlyphs field is -1.
         */

        if( iFontIndex < 0 )
        {
            //
            // This seems like a bad font. In that case verify.
            // Make the fontIndex +ve and 0 Based.
            //
            iFontIndex = (-iFontIndex);
            --iFontIndex;
        }
        else
        {
            //
            //  pvConsumer is 1 based.
            //
            --iFontIndex;

        }

        if ( pdm = PGetDLMapFromIdx (pFontPDev, iFontIndex))
        {
            //
            //  Do not process this one, if we had encountered problem in past.
            // Make sure that the we are dealing with same TT font.
            //
            if (pdm->cGlyphs == -1 && (pdm->iTTUniq == pfo->iTTUniq))
            {
                //
                // Set the pvConsumer to a -ve index. make it 1 based first.
                //
                pfo->pvConsumer = (PLONG_PTR)IntToPtr((-(iFontIndex +1)));
                return NULL;
            }

            //
            // We have found a DL_MAP for this font. So now verify it.
            //
            if ( BSameDLFont (pFontPDev, pfo, pdm ) )
            {
                //
                // This DL_MAP matches the font. So return the pointer.
                //

                bFound = TRUE;
            }

        }

    }

    //
    // If the font is not cached, search sequentially through the list.
    //
    if (!bFound)
    {
        DL_MAP_LIST     *pdml;   // The linked list of font information
        INT             iI;

        //
        // This case happens when the pvConsumer field is not correct
        // for this DC. The GDI doesn't gaurantee that the pvConsumer
        // will be reset for each job.So we need to do a linear search.
        //

        pdml = pFontPDev->pvDLMap;

        iFontIndex = 1;

        while (pdml)
        {

            for( iI = 0; iI < pdml->cEntries; ++iI )
            {
                pdm = &pdml->adlm[ iI ];
                if ( BSameDLFont (pFontPDev, pfo, pdm ) )
                {
                    //
                    // This DL_MAP matches the font. So return the pointer.
                    // we also need to reset pvConsumer. iFontIndex is
                    // one base same as pvConsumer.
                    //

                    bFound = TRUE;
                    pfo->pvConsumer = (PLONG_PTR)IntToPtr(iFontIndex);
                    break;
                }
                iFontIndex++;

            }
            //
            // Check if we have found the correct font or not.
            //
            if (bFound)
                break;
            else
                pdml = pdml->pDMLNext;
        }
    }

    //
    // Both cached and sequential search failed. So this is a new one.
    // Try downloading.
    //
    if (!bFound)
    {
        INT         iFontIndex;     // Download Font Index in DL_MAP List.

        //
        // The fontobj doesn't match the DL_MAP, or this is a new font.
        // So get a new one.
        //

        if (!(pdm =   PNewDLMap (pFontPDev,&(iFontIndex)) ))
        {
            ERR(("UniFont!PGetDLMap:Can't Create a new DL_MAP.\n"));
            iFontIndex = -1;
        }
        //
        // FontIndex returned by PNewDLMap is 0 based, but pvConsumer is one
        // base. So add one.
        //
        pfo->pvConsumer = (PLONG_PTR)IntToPtr((iFontIndex + 1));
    }

    return pdm;
}


BOOL
BInitDLMap (
    PDEV            *pPDev,
    FONTOBJ         *pfo,
    DL_MAP          *pdm
    )
/*++

Routine Description:
    Initializes a DL_MAP structure.

Arguments:
    pPDev               Pointer to PDEV.
    pfo                 FontObj.
    pdm                 DL_MPA to be initialized.

Return Value:

    TRUE  success and FALSE for failure.
Note:

    06/09/97 -ganeshp-
        Created it.
--*/
{
    BOOL        bRet = FALSE;
    DWORD       iGlyphPerSoftFont; // Total number of glyph per downloaded font.
    FONTINFO    fi;           // Details about this font.
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    INT         iDL_ID;

    pdm->iUniq              = pfo->iUniq;
    pdm->iTTUniq            = pfo->iTTUniq;

    FONTOBJ_vGetInfo( pfo, sizeof( fi ), &fi );
    //
    // Trunction may happen. But we are fine. We won't download if the number
    // glyphs or  max size are more than MAXWORD.
    //

    pdm->cTotalGlyphs = (WORD)fi.cGlyphsSupported;
    pdm->wMaxGlyphSize = (WORD)fi.cjMaxGlyph1;


    //
    // In GPD if the DLSymbolSet has valid value, then we have to set
    // the Min and Max Glyph IDs, using the Symbol Set, else we will use
    // the GPD entries,dwMinGlyphID and dwMaxGlyphID.
    //
    if (pPDev->pGlobals->dlsymbolset != UNUSED_ITEM)
    {
        if (pPDev->pGlobals->dlsymbolset == DLSS_PC8)
        {
            //
            // Symbol Set is DLSS_PC8.
            //

            pdm->wNextDLGId    =
            pdm->wFirstDLGId   =  32;
            pdm->wLastDLGId    =  255;

        }
        else
        {
            //
            // Symbol Set is DLSS_ROMAN8.
            //

            pdm->wNextDLGId    =
            pdm->wFirstDLGId   =  33;
            pdm->wLastDLGId    =  127;
        }
    }
    else
    {
        //
        // DLsymbolset Not defined. Use Min and Max Glyph Ids.
        //
        pdm->wFirstDLGId        = pdm->wNextDLGId
                                = (WORD)pPDev->pGlobals->dwMinGlyphID;
        pdm->wLastDLGId         = (WORD)pPDev->pGlobals->dwMaxGlyphID;

        if( !(pFontPDev->flFlags & FDV_ROTATE_FONT_ABLE ))
        {
            //
            // If the printer can't rotate font then we assume that it only
            // supports Roman 8 limited character set. This hack is needed for
            // old PCL printers.
            //
            pdm->wFirstDLGId        = pdm->wNextDLGId
                                    = 33;
            pdm->wLastDLGId         = 127;

        }


    }

    //
    // Find out that font is bounded or not. We do this by finding out
    // how many glyphs we can download per soft font. Add 1 as range is
    // inclusive.
    //

    iGlyphPerSoftFont =  (pdm->wLastDLGId - pdm->wFirstDLGId) +1;

    if (iGlyphPerSoftFont < MIN_GLYPHS_PER_SOFTFONT)
    {
        //
        // This is an error condition. Basically we don't want to download
        // if there are less than 64 glyphs per downloaded font.return FALSE.
        //
        ERR(("UniFont:BInitDLMap:Can't download any glyph,bad GPD values\n"));
        goto ErrorExit;;
    }
    else
    {
        //
        // There are more than  64 glyphs per downloded font. So find out
        // if it's bounded or unbounded. If the number of Glyphs is >255
        // then the font is unbounded else it's bounded.
        //
        if (iGlyphPerSoftFont > 255)
           pdm->wFlags             |=  DLM_UNBOUNDED;
        else
            pdm->wFlags            |=  DLM_BOUNDED;

    }

    if( (iDL_ID = IGetDL_ID( pPDev )) < 0 )
    {
        //
        //  We have run out of soft fonts - must not use any more.
        //
        ERR(("UniFont:BInitDLMap:Can't download Font, No IDs available\n"));
        goto ErrorExit;;
    }

    pdm->wBaseDLFontid = (WORD)iDL_ID;

    //
    // Hashtable is allocated based upon the number of Glyphs in the font.
    //
    if (pdm->cTotalGlyphs >= 1024)
        pdm->cHashTableEntries = HASHTABLESIZE_3;
    else if (pdm->cTotalGlyphs >= 512)
        pdm->cHashTableEntries = HASHTABLESIZE_2;
    else
        pdm->cHashTableEntries = HASHTABLESIZE_1;

    //
    // Now allocate the Glyph Table. We only allocate the hash table.
    //
    if (pdm->GlyphTab.pGlyph = (DLGLYPH *)MemAllocZ(
                               pdm->cHashTableEntries * sizeof(DLGLYPH)) )
    {
        INT     iIndex;
        PDLGLYPH pGlyph;

        //
        // Set the hTTGlyph to HGLYPH_INVALID as 0 is a valid handle for HGLYPH.
        // Also set the cGlyphs(Number of downloded Glyphs) to 0.
        //
        pGlyph = pdm->GlyphTab.pGlyph;
        for (iIndex = 0; iIndex < pdm->cHashTableEntries; iIndex++,pGlyph++)
            pGlyph->hTTGlyph = HGLYPH_INVALID;

        bRet = TRUE;
    }
    else
    {
        //
        // Error case. DL_MAP will be freeed by the caller, IDownloadFont.
        //
        ERR(("UniFont:BInitDLMap:Can't Allocate Glyph Hash table\n"));
    }


    ErrorExit:
    return bRet;
}


INT
IGetDL_ID(
    PDEV    *pPDev
    )
/*++
Routine Description:
     Returns the font index to use for the next download font.  Verifies
     that the number is within range.

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    Font index if OK,  else -1 on error (over limit).

Note:

    3/5/1997 -ganeshp-
        Created it.
--*/

{
    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    INT       iSFIndex;

    if( pFontPDev->iNextSFIndex > pFontPDev->iLastSFIndex ||
        pFontPDev->iUsedSoftFonts >= pFontPDev->iMaxSoftFonts )
    {
        ERR(( "softfont limit reached (%d/%d, %d/%d)\n",
                   pFontPDev->iNextSFIndex, pFontPDev->iLastSFIndex,
                   pFontPDev->iUsedSoftFonts, pFontPDev->iMaxSoftFonts ));
        return  -1;                     /*  Too many - stop now */
    }

    /*
     *   We'll definitely use this one,  so add to the used count.
     */

    pFontPDev->iUsedSoftFonts++;
    iSFIndex = pFontPDev->iNextSFIndex++;

    return   iSFIndex;
}

BOOL
BPrintADLGlyph(
    PDEV        *pPDev,
    TO_DATA     *pTod,
    PDLGLYPH    pdlGlyph
    )
/*++
Routine Description:
This functions output a single downloaded Glyph.

Arguments:
 pPDev      Unidriver PDEV
 pTod       Textout Data.
 pdlGlyph   Download Glyph information


Return Value:
TRUE for success and FALSE for failure.

Note:

8/12/1997 -ganeshp-
    Created it.
--*/
{
    FONTMAP         *pFM;       // FontMap of interest
    DL_MAP          *pdm;       // Details of this downloaded font.
    FONTPDEV        *pFontPDev; // Font PDev.
    BOOL            bRet;       // Return Value of this function.
    WORD            wDLGlyphID;  // Downloaded Glyph ID.

    //
    // Make sure that parameters are valid.
    //
    if (NULL == pPDev   ||
        NULL == pTod    ||
        NULL == pdlGlyph )
    {
        return FALSE;
    }

    //
    // Initialize locals
    //
    bRet        = TRUE;
    pFontPDev   = PFDV;
    pFM         = pTod->pfm;
    wDLGlyphID  = pdlGlyph->wDLGlyphID;

    //
    // Get pdm
    //
    if (pFM->dwFontType == FMTYPE_TTOUTLINE)
    {
        PFONTMAP_TTO pFMTO = (PFONTMAP_TTO) pFM->pSubFM;
        pdm = (DL_MAP*) pFMTO->pvDLData;
    }
    else if (pFM->dwFontType == FMTYPE_TTBITMAP)
    {
        PFONTMAP_TTB pFMTB = (PFONTMAP_TTB) pFM->pSubFM;
        pdm = pFMTB->u.pvDLData;
    }
    else if (pFM->dwFontType == FMTYPE_TTOEM)
    {
        PFONTMAP_TTOEM pFMTOEM = (PFONTMAP_TTOEM) pFM->pSubFM;
        pdm = pFMTOEM->u.pvDLData;
    }
    else
    {
        ASSERTMSG(FALSE, ("Incorrect font type %d in BPrintADLGlyph.\n",
            pFM->dwFontType));
        pdm = NULL;
        bRet = FALSE;
    }

    //
    // Before sending a glyph we have to make sure that this glyph is in
    // selected soft font. We have to do this only for segmented fonts, i.e
    // multiple softfonts for one system fonts. If BaseFontId is not same as
    // CurrFontId, that means the font has atleat two softfonts associated.
    // Then we need to check for currently selected SoftFont. If the fontid of
    // the glyph is different that the selected one, we need to select the new
    // softfontid.
    //
    // GLYPH_IN_NEW_SOFTFONT is defined as :
    // if ( (pdm->wFlags & DLM_BOUNDED) &&
    //     (pdm->wBaseDLFontid != pdm->wCurrFontId) &&
    //     (pdlGlyph->wDLFontId != (WORD)(pFontPDev->ctl.iSoftFont)) )
    //

    if (bRet && GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph))
    {
        //
        // Need to select the new softfont.We do this by setting pfm->ulDLIndex
        // to new softfontid.
        //

        pFM->ulDLIndex = pdlGlyph->wDLFontId;
        BNewFont(pPDev, pTod->iFace, pFM, 0);
    }

    //
    // The Soft font selection is done. So now sent the downloaded Glyph Id.
    // We have to be a bit careful about the size of the Glyph ID. If the
    // Glyphs ID is less than 256, then we need to send a BYTE else a WORD.
    //

    if (bRet)
    {
        if (wDLGlyphID > 0xFF)
        {
            //
            // Send as WORD.
            //

            SWAB (wDLGlyphID);

            bRet = WriteSpoolBuf( pPDev, (BYTE*)&wDLGlyphID, sizeof( wDLGlyphID ) )
	                    == sizeof( wDLGlyphID );

        }
        else
        {
            //
            // Send as Byte.
            //

            BYTE   bData;

            bData = (BYTE)wDLGlyphID;

            bRet = WriteSpoolBuf( pPDev, &bData, sizeof( bData ) ) ==
	                             sizeof( bData );
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\download.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    download.h

Abstract:

     Information required to download fonts to a printer:  either an
     existing softfont,  or cacheing of GDI fonts (esp. TT).

Environment:

    Windows NT Unidrv driver

Revision History:

    12/23/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _DOWNLOAD_H

#define _DOWNLOAD_H

//
//  GLYPHLIST structure. This structure hold the start and end glyph ids.
//
#define     INVALIDGLYPHID          0xffffffff
#define     HASHTABLESIZE_1         257        //Used if NumGlyphs is < 512
#define     HASHTABLESIZE_2         521        //Used if NmGlyhs is >= 512 && < 1024
#define     HASHTABLESIZE_3         1031       //Used if NmGlyhs is >= 1024

//
// Hash Table entry for glyphs. The entry has basically TT Glyph Handle and
// Downloaded FontIds and DL glyph ID. The hash table is an array of these
// entries. In the case of a Hit a new entry will be added as linked list
// off that entry.
//

typedef struct _DLGLYPH       //Size is 16 Bytes.
{
    HGLYPH              hTTGlyph;     // GDI glyph handle.
    WORD                wDLFontId;    // DL Font index. Bounded Fonts.
    WORD                wDLGlyphID;   // Download Glyph ID of unbounded fonts.
    WORD                wWidth;       // Width of the Glyph.
    WCHAR               wchUnicode;    // Reserved for padding.
    struct  _DLGLYPH    *pNext;       // Next Glyph
}DLGLYPH, *PDLGLYPH;

// The Glyphs are stored in Chunks, to optimize on allocation and
// deallocations.The first chunk is the base chunk and used as Hash table.
// The subsequent chunks are allocated when a collision occurs in the hash
// table. All the non base chunks has half the number of Glyphs as that of
// base chunk (cEntries is intialized to cHashTableEntries/2). The base hash
// table is dl_map.GlyphTab.pGlyph. we should free this pointer for base chunk.
// Base hash table is allocated in BInitDLMAP() function, which initialize the
// DL_MAP.

typedef  struct  _GLYPHTAB
{
    struct _GLYPHTAB   *pGLTNext;  // Next Chunk of Glyphs
    PDLGLYPH            pGlyph;    // Pointer to Next Glyph.
    INT                 cEntries;  // Number of Entries Remaining.
                                   // Not Used in Base Chunk.

}GLYPHTAB;

//
//   The DL_MAP structure provides a mapping between the iUniq value in
//  FONTOBJs and our internal information.  Basically, we need to decide
//  whether we have seen this font before,  and if so, whether it was
//  downloaded or left as a GDI font.
//

//
//  NOTE:  The cGlyphs field has another use.  It is used to mark a bad DL_MAP.
//  If it is -1, then this DL_MAP shouldn't be used. All other fields  will
//  be set to 0.
//


typedef  struct _DL_MAP
{
    ULONG       iUniq;              // FONTOBJ.iUniq
    ULONG_PTR    iTTUniq;            // FONTOBJ.iTTUniq
    SHORT       cGlyphs;            // Num of DL glyphs with current softfont
    WORD        cTotalGlyphs;       // Total Number of glyphs with this TT font
    WORD        wMaxGlyphSize;      // NumBytes in the bitmap for largest Glyph
    WORD        cHashTableEntries;  // Number of entries in the HASH table.
    WORD        wFirstDLGId;        // Start DL Glyph ID.
    WORD        wLastDLGId;         // End ID of the List. -1 if no END id
    WORD        wNextDLGId;         // Next DL Glyph ID to be downloaded.
    WORD        wBaseDLFontid;      // Downloaded Base font Id.
    WORD        wCurrFontId;        // Current Font ID to be used.
    WORD        wFlags;             // Different Flags.
    FONTMAP     *pfm;               // The real down load info
    GLYPHTAB    GlyphTab;           // Glyph Hash Table.It's Linked
                                    // list of Glyph Chunks.
}  DL_MAP;

//
// DL_MAP flags.
//
#define     DLM_BOUNDED         0x0001          // Soft font is bounded.
#define     DLM_UNBOUNDED       0x0002          // Soft font is unbounded.

//
//    The above is formed into an array of DL_MAP_CHUNK entries,  and this
//  group of storage is linked into a linked list of such entries. Typically,
//  there will be only one,  however we can cope with more.
//

#define  DL_MAP_CHUNK       8

typedef  struct  _DML
{

    struct _DML   *pDMLNext;                // An array of map information
    INT      cEntries;                      // Next in our chain, 0 in last
    DL_MAP   adlm[ DL_MAP_CHUNK ];          // Number of valid entries.

}  DL_MAP_LIST;



/*
 *   We need to map glyph handles to byte to send to printer.  We are given
 * the glyph handle, but need to send the byte instead.
 */

typedef  struct
{
    HGLYPH   hg;               /* The glyph to print */
    WCHAR    wchUnicode;
    int      iByte;            /* What to send to the printer */
} HGLYPH_MAP;


/*
 *   Random constants.
 */

#define PCL_FONT_OH      2048          /* Overhead bytes per download font */
#define PCL_PITCH_ADJ       2          /* Adjustment factor for proportional */

/*
 * macros
 */
#define     SWAPW(a)        (USHORT)(((BYTE)((a) >> 8)) | ((BYTE)(a) << 8))
#define     SWAPWINC(a)     SWAPW(*(a)); a++
#define     FONTDOWNLOADED(pdm) ( ((pdm)->pfm) && \
                               ((pdm)->pfm->flFlags &  \
                               (FM_SENT | FM_GEN_SFONT)) )
#define     GLYPHDOWNLOADED(pdlg) ( ((pdlg)->hTTGlyph != HGLYPH_INVALID) )

//
// Download Mode to identity base softfont or secondary soft font downloading.
//

#define     DL_BASE_SOFT_FONT           1
#define     DL_SECONDARY_SOFT_FONT      2

#define     MIN_GLYPHS_PER_SOFTFONT     64  // Minimum glyphs per softfont


#endif _DOWNLOAD_H //!_DOWNLOAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmcallbk.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmcallbk.c

Abstract:

    The font module callback helper functions

Environment:

    Windows NT Unidrv driver

Revision History:

    03/31/97 -eigos-
        Created

--*/

#include "font.h"

#define CALL_OEMOUTPUTCHARSTR(type, count, startpoint) \
    if(bCOMInterface) \
    { \
        HComOutputCharStr((POEM_PLUGIN_ENTRY)pPDev->pOemEntry, \
                        &pPDev->devobj, \
                        (PUNIFONTOBJ)pUFObj, \
                        (type), \
                        (count), \
                        (startpoint)); \
    } \
    else \
    { \
        if (pfnOEMOutputCharStr) \
        pfnOEMOutputCharStr(&pPDev->devobj, \
                            (PUNIFONTOBJ)pUFObj, \
                            (type), \
                            (count), \
                            (startpoint)); \
    }

#define GET_CHARWIDTH(width, pfontmap, hg) \
    if (pfontmap->flFlags & FM_WIDTHRES) \
    { \
        if (!(width = IGetUFMGlyphWidth(pPDev, pfontmap, hg))) \
            width = (INT)pIFIMet->fwdAveCharWidth; \
    } \
    else \
    { \
        if (pTrans[hg - 1].ubType & MTYPE_DOUBLE) \
            width = pIFIMet->fwdMaxCharInc; \
        else \
            width = pIFIMet->fwdAveCharWidth; \
    } \
    if (pfontmap->flFlags & FM_SCALABLE) \
    { \
        width = LMulFloatLong(&pFontPDev->ctl.eXScale,width); \
    }

//
// Local functions' prototype definition
//

WCHAR
WGHtoUnicode(
    DWORD     dwNumOfRuns,
    PGLYPHRUN pGlyphRun,
    HGLYPH    hg);

//
// UNIFONTOBJ callback interface
//

BOOL
UNIFONTOBJ_GetInfo(
    IN  PUNIFONTOBJ pUFObj,
    IN  DWORD       dwInfoID,
    IN  PVOID       pData,
    IN  DWORD       dwDataSize,
    OUT PDWORD      pcbNeeded)
/*++

Routine Description:

    Implementation of UNIFONTOBJ GetInfo function
    Please refer to DDK

Arguments:

    pUFOBj - a pointer to UNIFONTOBJ
    dwInfoID - Function ID
    pData - a pointer to data structure according to dwInfoID
    dwDataSize - size of pData
    pcbNeeded - DWORD buffer to return the necessary size of pData

Return Value:

    TRUE if successful, otherwise FALSE.

Note:


--*/
{
    PI_UNIFONTOBJ        pI_UFObj = (PI_UNIFONTOBJ)pUFObj;

    GETINFO_GLYPHSTRING* pGlyphString;
    GETINFO_GLYPHBITMAP* pGlyphBitmap;
    GETINFO_GLYPHWIDTH*  pGlyphWidth;
    GETINFO_STDVAR*      pStdVar;

    PFONTPDEV   pFontPDev;
    PUNI_GLYPHSETDATA  pGlyphData;
    PTRANSDATA  pTrans, pTransOut, pTransOutStart;
    PMAPTABLE   pMapTable;
    PGLYPHRUN   pGlyphRun;

    HGLYPH *pHGlyph;
    PDLGLYPH *apdlGlyph;
    PBYTE  pbString, pbOutput;
    LONG  *plWidth, lBuffSize;
    DWORD  *pGlyphID, dwI, dwJ;
    WCHAR  *pUnicode;
    DWORD   dwNumOfVar, dwCount, dwSVID, dwNumOfRuns, dwBuffSize;
    BOOL    bRet;

    static STDVARIABLE FontStdVariable[FNT_INFO_MAX] = {
        SV_PRINTDIRECTION,
        SV_GRAYPERCENT,
        SV_NEXTFONTID,
        SV_NEXTGLYPH,
        SV_FONTHEIGHT,
        SV_FONTWIDTH,
        SV_FONTBOLD,
        SV_FONTITALIC,
        SV_FONTUNDERLINE,
        SV_FONTSTRIKETHRU,
        SV_CURRENTFONTID,
        SV_TEXTYRES,
        SV_TEXTXRES,
        SV_FONTMAXWIDTH };

    //
    // Error check
    //
    if (!pI_UFObj )
    {
        ERR(("UNIFONTOBJ_GetInfo(): pUFObj is NULL.\n"));
        return FALSE;
    }

    if (!pData)
    //
    // pData == NULL case
    // Return the necessary buffer size
    //
    {
        bRet = TRUE;

        if (!pcbNeeded)
        {
            ERR(("UNIFONTOBJ_GetInfo(): pData and pcbNeed is NULL.\n"));
            bRet = FALSE;
        }
        else
        {
            switch (dwInfoID)
            {
            case UFO_GETINFO_FONTOBJ:
                *pcbNeeded = sizeof(GETINFO_FONTOBJ);
                break;
            case UFO_GETINFO_GLYPHSTRING:
                *pcbNeeded = sizeof(GETINFO_GLYPHSTRING);
                break;
            case UFO_GETINFO_GLYPHBITMAP:
                *pcbNeeded = sizeof(GETINFO_GLYPHBITMAP);
                break;
            case UFO_GETINFO_GLYPHWIDTH:
                *pcbNeeded = sizeof(GETINFO_GLYPHWIDTH);
                break;
            case UFO_GETINFO_MEMORY:
                *pcbNeeded = sizeof(GETINFO_MEMORY);
                break;
            case UFO_GETINFO_STDVARIABLE:
                *pcbNeeded = sizeof(GETINFO_STDVAR);
                break;
            default:
                *pcbNeeded = 0;
                bRet = FALSE;
                VERBOSE(("UNIFONTOBJ_GetInfo(): Invalid dwInfoID.\n"));
                break;
            }
        }
    }
    else
    {
        bRet = FALSE;

        //
        // ERROR CHECK LIST
        // (A) Data structure size check
        //     GETINFO_FONTOBJ
        //     GETINFO_GLYPHYSTRING
        //     GETINFO_GLYPHBITMAP
        //     GETINFO_GLYPHWIDTH
        //     GETINFO_MEORY
        //     GETNFO_STDVARIABLE
        // (B) Necessary data pointer check
        //     e.g. pI_UFObj->XXXX
        //
        switch (dwInfoID)
        {
        case UFO_GETINFO_FONTOBJ:

            //
            // Return FONTOBJ data in GETINFO_FONTOBJ
            //     typedef struct _GETINFO_FONTOBJ {
            //        DWORD    dwSize;   // Size of this structure
            //        FONTOBJ *pFontObj; // Pointer to the FONTOBJ
            //     } GETINFO_FONTOBJ, *PGETINFO_FONTOBJ;
            //
            // ERROR CHECK
            // (A) and (B)
            // (B) pI_UFObj->pFontObj
            //
            if (((GETINFO_FONTOBJ*)pData)->dwSize != sizeof(GETINFO_FONTOBJ) || !pI_UFObj->pFontObj)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pData or pUFObj is invalid.\n"));
                break;
            }

            ((GETINFO_FONTOBJ*)pData)->pFontObj = pI_UFObj->pFontObj;
            bRet = TRUE;
            break;

        case UFO_GETINFO_GLYPHSTRING:
            //
            // Return glyph string
            //
            //     typedef struct _GETINFO_GLYPHSTRING {
            //         DWORD dwSize;    // Size of this structure
            //         DWORD dwCount;   // Count of glyphs in pGlyphIn
            //         DWORD dwTypeIn;  // Glyph type of pGlyphIn, TYPE_GLYPHID/TYPE_HANDLE.
            //         PVOID pGlyphIn;  // Pointer to the input glyph string
            //         DWORD dwTypeOut; // Glyph type of pGlyphOut, TYPE_UNICODE/TYPE_TRANSDATA.
            //         PVOID pGlyphOut; // Pointer to the output glyph string
            //         DWORD dwGlyphOutSize; // The size of pGlyphOut buffer
            //     } GETINFO_GLYPHSTRING, *PGETINFO_GLYPHSTRING;
            //
            //
            //  OutputGlyph callback function receives
            //          1. GLYPH HANLDE for Device font
            //          2. GLYPH ID for TrueType font
            //
            //  In TYPE_GLYPHHANDLE (Device font)
            //      Out TYPE_UNICODE
            //          TYPE_TRANSDATA
            //
            //  In TYPE_GLYPHID (TrueType font)
            //      Out TYPE_UNICODE
            //      Out TYPE_GLYPHHANDLE
            //
            //  <Special case for TYPE_GLYPHHANDLE -> TYPE_TRANSDATA conversion>
            //  TRANSDATA could have MTYPE_COMPOSE so that UNIDRV doesn't know the size of output buffer.
            //  At the first call, a minidriver sets 0 to dwGlyphOutSize.
            //  Then UNIDRV returns necessary buffer size in dwGlyphOutSize.
            //  At the second call, a minidriver allocates memory, set the pointer of it to pGlyphOut,
            //  and set the size to dwGlyphOutSize.
            //
            //

            pGlyphString = pData;
            dwCount = pGlyphString->dwCount;

            if (!dwCount)
            {
                //
                // No operation is necessary.
                //
                break;
            }

            //
            // ERROR CHECK (A)
            // pGlyphString
            //
            if ( !pGlyphString->pGlyphIn                             ||
                    pGlyphString->dwTypeOut != TYPE_TRANSDATA &&
                    !pGlyphString->pGlyphOut                         )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pData is invalid.\n"));
                break;
            }

            //
            // Now we support type size of GETINFO_GLYPHSTRING.
            // This is a bug backward compatibility.
            // Before beta 3 GETINFO_GLYPHSTRING didn't have dwGlyphOutSize.
            // Now we have new data structure but don't change the name of
            // structure.
            //
            if (!(
                  (pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING)) ||
                  (pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING) - sizeof(DWORD))
                 )
               )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pData is invalid.\n"));
                break;
            }

            //
            // ERROR CHECK (B)
            // pI_UFObj->pFontMap
            // pI_UFObj->pPDev
            //
            if (!pI_UFObj->pFontMap || !pI_UFObj->pPDev)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_FONTOBJ): pUFObj is invalid.\n"));
                break;
            }

            switch(pGlyphString->dwTypeIn)
            {
            case TYPE_GLYPHHANDLE:

                //
                // Device font case
                //

                if ( pI_UFObj->pFontMap->dwFontType == FMTYPE_DEVICE )
                {
                    pHGlyph     = pGlyphString->pGlyphIn;
                    pGlyphData  = ((PFONTMAP_DEV)pI_UFObj->pFontMap->pSubFM)->pvNTGlyph;
                    dwNumOfRuns = pGlyphData->dwRunCount;

                    switch(pGlyphString->dwTypeOut)
                    {
                    case TYPE_UNICODE:
                        pUnicode = pGlyphString->pGlyphOut;
                        pGlyphRun = GET_GLYPHRUN(pGlyphData);

                        while (dwCount--)
                        {
                            *pUnicode++ = WGHtoUnicode(dwNumOfRuns,
                                                       pGlyphRun,
                                                       *pHGlyph++);
                        }
                        bRet = TRUE;
                        break;

                    case TYPE_TRANSDATA:
                        pTransOutStart = pTransOut = pGlyphString->pGlyphOut;
                        pMapTable = GET_MAPTABLE(pGlyphData);
                        pTrans    = pMapTable->Trans;
                        dwBuffSize = pGlyphString->dwGlyphOutSize;

                        //
                        // New version of GETINFO_GLYPYSTRING
                        //
                        if ( pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING) )
                        {
                            if (0 == dwBuffSize)
                            {
                                while (dwCount --)
                                {
                                    if (!(pTrans[*pHGlyph - 1].ubType & MTYPE_COMPOSE))
                                    {
                                        dwBuffSize += sizeof(TRANSDATA);
                                    }
                                    else
                                    {
                                        pbString =  (PBYTE)pMapTable + pTrans[*pHGlyph - 1].uCode.sCode;
                                        dwBuffSize += sizeof(TRANSDATA) + *(PWORD)pbString + sizeof(WORD);
                                    }

                                    pHGlyph++;
                                }
                                pGlyphString->dwGlyphOutSize = dwBuffSize;
                            }
                            else
                            {
                                //
                                // Initialize the MTYPE_COMPOSE buffer
                                //
                                pbOutput = (PBYTE)pTransOutStart + dwCount * sizeof(TRANSDATA);

                                lBuffSize = dwBuffSize - dwCount * sizeof(TRANSDATA);

                                if (lBuffSize < 0 || NULL == pTransOut)
                                {
                                    break;
                                }
                                else
                                {
                                    bRet = TRUE;
                                    while (dwCount --)
                                    {
                                        *pTransOut = pTrans[*pHGlyph - 1];

                                        if (pTrans[*pHGlyph - 1].ubType & MTYPE_COMPOSE)
                                        {
                                            pbString =  (PBYTE)pMapTable + pTrans[*pHGlyph - 1].uCode.sCode;
                                            if (lBuffSize >= *(PWORD)pbString)
                                            {
                                                pTransOut->uCode.sCode = (SHORT)(pbOutput - (PBYTE)pTransOutStart);
                                                CopyMemory(pbOutput, pbString, *(PWORD)pbString + sizeof(WORD));
                                                pbOutput += *(PWORD)pbString + sizeof(WORD);

                                                lBuffSize -= *(PWORD)pbString + sizeof(WORD);
                                            }
                                            else
                                            {
                                                bRet = FALSE;
                                                break;
                                            }
                                        }

                                        pTransOut ++;
                                        pHGlyph ++;
                                    }
                                }
                            }
                        }
                        //
                        // New version of GETINFO_GLYPYSTRING
                        //
                        else if ( pGlyphString->dwSize == sizeof(GETINFO_GLYPHSTRING) - sizeof(DWORD) )
                        {
                            pTransOut = pGlyphString->pGlyphOut;
                            pMapTable = GET_MAPTABLE(pGlyphData);
                            pTrans    = pMapTable->Trans;

                            while (dwCount --)
                            {
                                *pTransOut++ = pTrans[*pHGlyph++ - 1];
                            }
                            bRet = TRUE;
                        }
                        break;

                    default:
                        break;
                    }
                }
                break;

            case TYPE_GLYPHID:
                //
                // TrueType font case
                //

                pGlyphID = (PDWORD)pGlyphString->pGlyphIn;
                apdlGlyph = pI_UFObj->apdlGlyph;

                if (!apdlGlyph)
                {
                    ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHSTRING): pUFObj is not correct.\n"));
                    break;
                }

                if (pI_UFObj->pFontMap->dwFontType == FMTYPE_TTOEM)
                {
                    switch (pGlyphString->dwTypeOut)
                    {
                    case TYPE_UNICODE:
                        pUnicode = pGlyphString->pGlyphOut;
                        while (dwCount--)
                        {
                            *pUnicode = 0;
                            for (dwI = 0; dwI < pI_UFObj->dwNumInGlyphTbl; dwI++, apdlGlyph++)
                            {
                                if ((*apdlGlyph)->wDLGlyphID == (0x0ffff & *pGlyphID))
                                {
                                    *pUnicode = (*apdlGlyph)->wchUnicode;
                                    break;
                                }
                            }
                            pGlyphID ++;
                            pUnicode ++;
                        }
                        bRet = TRUE;
                        break;

                    case TYPE_GLYPHHANDLE:
                        pHGlyph = pGlyphString->pGlyphOut;
                        while (dwCount--)
                        {
                            *pHGlyph = 0;
                            for (dwI = 0; dwI < pI_UFObj->dwNumInGlyphTbl; dwI++, apdlGlyph++)
                            {
                                if ((*apdlGlyph)->wDLGlyphID == (0x0ffff & *pGlyphID))
                                {
                                    *pHGlyph = (*apdlGlyph)->hTTGlyph;
                                    break;
                                }
                            }
                            pGlyphID ++;
                            pHGlyph ++;
                        }
                        bRet = TRUE;
                        break;
                    }
                }
                break;
            }
            break;

        case UFO_GETINFO_GLYPHBITMAP:
            //
            // Return Glyph Bitmap
            //
            // typedef struct _GETINFO_GLYPHBITMAP {
            //     DWORD       dwSize;    // Size of this structure
            //     HGLYPH      hGlyph;    // Glyph hangle passed in OEMDownloadCharGlyph
            //     GLYPHDATA *pGlyphData; // Pointer to the GLYPHDATA data structure
            // } GETINFO_GLYPHBITMAP, *PGETINFO_GLYPHBITMAP;
            //

            pGlyphBitmap = pData;

            //
            // Error check (A) and (B)
            // (B) pI_UFObj->pFontObj
            //
            if (!pI_UFObj->pFontObj || pGlyphBitmap->dwSize != sizeof(GETINFO_GLYPHBITMAP))
                break;

            if (FONTOBJ_cGetGlyphs(pI_UFObj->pFontObj,
                               FO_GLYPHBITS,
                               1,
                               &pGlyphBitmap->hGlyph,
                               &pGlyphBitmap->pGlyphData)        )
            {
                bRet = TRUE;
            }
            break;

        case UFO_GETINFO_GLYPHWIDTH:
            //
            // Return glyph width.
            //
            // typedef struct _GETINFO_GLYPHWIDTH {
            //     DWORD dwSize;  // Size of this structure
            //     DWORD dwType;  // Type of glyph stirng in pGlyph, TYPE_GLYPHHANDLE/GLYPHID.
            //     DWORD dwCount; // Count of glyph in pGlyph
            //     PVOID pGlyph;  // Pointer to a glyph string
            //     PLONG plWidth; // Pointer to the buffer of width table.
            //                    // Minidriver has to prepare this.
            // } GETINFO_GLYPHWIDTH, *PGETINFO_GLYPHWIDTH;
            //
            pGlyphWidth = pData;

            //
            // Error check (A)
            //
            if ((pGlyphWidth->dwSize != sizeof(GETINFO_GLYPHWIDTH))||
                !(plWidth  = pGlyphWidth->plWidth)                 ||
                !(pGlyphID = pGlyphWidth->pGlyph)                   )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHWIDTH): pData is not correct.\n"));
                break;
            }

            //
            // Error check (B)
            // pI_UFObj->pPDev
            // pI_UFObj->pFontObj
            //
            if (!pI_UFObj->pPDev)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHWIDTH): pUFObj is not correct.\n"));
                break;
            }

            switch(pGlyphWidth->dwType)
            {
            case TYPE_GLYPHID:
                if (pUFObj->dwFlags & UFOFLAG_TTFONT)
                {
                    HGLYPH hGlyph;

                    if (!pI_UFObj->pFontObj)
                    {
                        ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_GLYPHWIDTH): UNIDRV needs FONTOBJ. This must be white text case!\n"));
                        break;
                    }

                    for (dwI = 0, pGlyphID = pGlyphWidth->pGlyph;
                         dwI < pGlyphWidth->dwCount;
                         dwI ++, pGlyphID ++, plWidth++)
                    {
                        apdlGlyph = pI_UFObj->apdlGlyph;

                        for (dwJ = 0;
                             dwJ < pI_UFObj->dwNumInGlyphTbl;
                             dwJ++ , apdlGlyph++)
                        {
                            if ((*apdlGlyph)->wDLGlyphID == (0x0ffff & *pGlyphID))
                            {
	hGlyph = (*apdlGlyph)->hTTGlyph;
	break;
                            }
                        }
                        *plWidth= DwGetTTGlyphWidth(pI_UFObj->pPDev->pFontPDev,
                                                    pI_UFObj->pFontObj,
                                                    hGlyph);
                    }
                    bRet = TRUE;
                }
                break;

            case TYPE_GLYPHHANDLE:
                if (!(pUFObj->dwFlags & UFOFLAG_TTFONT))
                {
                    for (dwI = 0,pHGlyph = pGlyphWidth->pGlyph;
                         dwI < pGlyphWidth->dwCount;
                         dwI ++, pHGlyph++, plWidth++)
                    {
                        *plWidth = IGetUFMGlyphWidthJr(&pI_UFObj->ptGrxRes,
                                                       pI_UFObj->pFontMap,
                                                       *pHGlyph);
                    }
                    bRet = TRUE;
                }
                break;

            }
            break;

        case UFO_GETINFO_MEMORY:
            //
            // Retuen available memory on the printer.
            //
            // typedef struct _GETINFO_MEMORY {
            //     DWORD dwSize;
            //     DWORD dwRemainingMemory;
            // } GETINFO_MEMORY, PGETINFO_MEMROY;

            //
            // Error check (A)
            //
            if (((GETINFO_MEMORY*)pData)->dwSize != sizeof(GETINFO_MEMORY))
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_MEMORY): pData is not correct.\n"));
                break;
            }

            //
            // Error check (B)
            // pI_UFObj->pPDev
            // pI_UFObj->pPDev->pFontPDev
            //
            if (!pI_UFObj->pPDev || !(pFontPDev = pI_UFObj->pPDev->pFontPDev))
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_MEMORY): pUFObj is not correct.\n"));
                break;
            }

            ((GETINFO_MEMORY*)pData)->dwRemainingMemory = pFontPDev->dwFontMem;
            bRet = TRUE;
            break;

        case UFO_GETINFO_STDVARIABLE:
            //
            // Return standard variables
            //
            //typedef struct _GETINFO_STDVAR {
            //    DWORD dwSize;
            //    DWORD dwNumOfVariable;
            //    struct {
            //        DWORD dwStdVarID;
            //        LONG  lStdVariable;
            //    } StdVar[1];
            //} GETINFO_STDVAR, *PGETINFO_STDVAR;
            //
            //
            // FNT_INFO_PRINTDIRINCCDEGREES  0 // PrintDirInCCDegrees
            // FNT_INFO_GRAYPERCENTAGE       1 // GrayPercentage
            // FNT_INFO_NEXTFONTID           2 // NextfontID
            // FNT_INFO_NEXTGLYPH            3 // NextGlyph
            // FNT_INFO_FONTHEIGHT           4 // FontHeight
            // FNT_INFO_FONTWIDTH            5 // FontWidth
            // FNT_INFO_FONTBOLD             6 // FontBold
            // FNT_INFO_FONTITALIC           7 // FontItalic
            // FNT_INFO_FONTUNDERLINE        8 // FontUnderline
            // FNT_INFO_FONTSTRIKETHRU       9 // FontStrikeThru
            // FNT_INFO_CURRENTFONTID       10 // Current
            // FNT_INFO_TEXTYRES            11 // TextYRes
            // FNT_INFO_TEXTXRES            12 // TextXRes
            // FNT_INFO_FONTMAXWIDTH        13 // FontMaxWidth
            //

            pStdVar = pData;


            //
            // Error check (A)
            //
            if (    (pStdVar->dwSize != sizeof(GETINFO_STDVAR) +
                     ((dwNumOfVar = pStdVar->dwNumOfVariable) - 1) * 2 * sizeof(DWORD))
               )
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETIFNO_STDVARIABLE): pData is incorrect.\n"));
                break;
            }

            //
            // Error check (B)
            // pI_UFObj->pPDev
            //
            if (!pI_UFObj->pPDev)
            {
                ERR(("UNIFONTOBJ_GetInfo(UFO_GETINFO_STDVARIABLE): pUFObj is not correct.\n"));
                break;
            }

            bRet = TRUE;
            while (dwNumOfVar--)
            {
                dwSVID =
                    FontStdVariable[pStdVar->StdVar[dwNumOfVar].dwStdVarID];

                if (dwSVID > SV_MAX)
                {
                    bRet = FALSE;
                    ERR(("UFONTOBJ_GetInfo(UFO_GETIFNO_STDVARIABLE): pData is incorrect.\n"));
                    break;
                }
                pStdVar->StdVar[dwNumOfVar].lStdVariable = *(pI_UFObj->pPDev->arStdPtrs[dwSVID]);
            }
            break;

        default:
            VERBOSE(("UNIFONTOBJ_GetInfo(): Invalid dwInfoID.\n"));
            break;
        }
    }

    return bRet;
}

//
// Font module FONTMAP functions
//

DWORD
DwOutputGlyphCallback(
    TO_DATA *pTod)
/*++

Routine Description:

    Implementation of OEM OutpuotGlyphCallback calling routine for FONTMAP dispatch routine

Arguments:

    pTod - a pointer to TO_DATA.

Return Value:

    The number of glyph printed.

Note:


--*/
{
    PFN_OEMOutputCharStr pfnOEMOutputCharStr;
    PI_UNIFONTOBJ pUFObj;
    IFIMETRICS   *pIFIMet;
    PFONTPDEV     pFontPDev;
    PDEV         *pPDev;
    PUNI_GLYPHSETDATA  pGlyphData;
    PTRANSDATA    pTrans;
    PMAPTABLE     pMapTable;
    COMMAND      *pCmd, *pCmdSingle, *pCmdDouble;
    FONTMAP      *pFontMap;
    GLYPHPOS     *pgp;
    PDLGLYPH      pdlGlyph;
    POINTL        ptlRem;
    DWORD         dwI, dwCount;
    PDWORD        pdwGlyph, pdwGlyphStart;
    INT           iXInc, iYInc;
    BOOL          bSetCursorForEachGlyph, bPrint, bNewFontSelect, bCOMInterface;

    bCOMInterface = FALSE;

    pPDev     = pTod->pPDev;
    ASSERT(pPDev)

    pFontPDev = pPDev->pFontPDev;
    ASSERT(pFontPDev)

    pFontMap  = pTod->pfm;
    pUFObj    = (PI_UNIFONTOBJ)pFontPDev->pUFObj;
    ASSERT(pFontMap && pUFObj)

    pIFIMet = pFontMap->pIFIMet;
    ASSERT(pIFIMet)

    pfnOEMOutputCharStr = NULL;

    if ( pPDev->pOemHookInfo &&
        (pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook))
    {
        FIX_DEVOBJ(pPDev, EP_OEMOutputCharStr);
        if( pPDev->pOemEntry && ((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )
        {
            bCOMInterface = TRUE;
        }
        else
        {
            pfnOEMOutputCharStr = (PFN_OEMOutputCharStr)pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook;
        }
    }
    else if (pPDev->ePersonality != kPCLXL)
    {
        ERR(("DwOutputGlyphCallback: OEMOutputCharStr callback is not supported by a minidriver."));
        return 0;
    }

    //
    // Error exit
    //
    if (pFontMap->flFlags & FM_IFIVER40 || pUFObj->pGlyph == NULL)
    {
        ERR(("DwOutputGlyphCallback: pUFObj->pGlyph is NULL."));
        return 0;
    }

    //
    // OEMOutputCharStr passes two type of glyph string.
    // TYPE_GLYPHID for TrueType font
    // TYPE_GLYPHHANDLE for Device font
    //

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    pdwGlyphStart =
    pdwGlyph = (PDWORD)pUFObj->pGlyph;
    pgp    = pTod->pgp;

    pUFObj->pFontMap = pFontMap;

    if (pUFObj->dwFlags & UFOFLAG_TTFONT)
    {
        DWORD    dwCurrGlyphIndex = pTod->dwCurrGlyph;
        PFONTMAP_TTOEM pFMOEM = (PFONTMAP_TTOEM) pFontMap->pSubFM;
        DL_MAP   *pdm = pFMOEM->u.pvDLData;

        ASSERT(pTod->apdlGlyph);

        if (bSetCursorForEachGlyph)
        {
            for (dwI = 0;
                 dwI < pTod->cGlyphsToPrint;
                 dwI++, pgp++, dwCurrGlyphIndex++)
            {
                pdlGlyph = pTod->apdlGlyph[dwCurrGlyphIndex];
                if (!pdlGlyph)
                {
                    //
                    // pFM->pfnDownloadGlyph could fail by some reason.
                    // Eventually apdlGlyph is not initialized by download.c
                    //
                    ERR(("DwOutputGlyphCallback: pTod->apdlGlyph[dwCurrGlyphIndex] is NULL."));
                    continue;
                }

                if (GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph))
                {
                    //
                    // Need to select the new softfont.
                    // We do this by setting pfm->ulDLIndex
                    // to new softfontid.
                    //

                    pUFObj->ulFontID =
                    pFontMap->ulDLIndex = pdlGlyph->wDLFontId;
                    BNewFont(pPDev, pTod->iFace, pFontMap, 0);
                }

                VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

                HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
                                                            (PUNIFONTOBJ)pUFObj,
                                                            TYPE_GLYPHID,
                                                            1,
                                                            &(pdlGlyph->wDLGlyphID)))
                else

                CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHID, 1, &(pdlGlyph->wDLGlyphID));

                //
                // Update position
                //
                VSetCursor( pPDev,
                            pdlGlyph->wWidth,
                            0,
                            MOVE_RELATIVE|MOVE_UPDATE,
                            &ptlRem);

            }
        }
        else
        {
            VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

            dwI = 0;
            dwCount = 0;
            bNewFontSelect = FALSE;

            do
            {
                for (; dwI < pTod->cGlyphsToPrint; pdwGlyph++, dwCount++, pgp++, dwI++, dwCurrGlyphIndex++)
                {
                    pdlGlyph = pTod->apdlGlyph[dwCurrGlyphIndex];

                    if (0 == pgp->hg)
                    {
                        //
                        // UNIDRV returns 1 for the first glyph handle
                        // in FD_GLYPHSET.
                        // However, GDI could pass zero in hg.
                        // We need to handle this GDI error properly.
                        continue;
                    }

                    if (!pdlGlyph)
                    {
                        //
                        // pFM->pfnDownloadGlyph could fail by some reason.
                        // Eventually apdlGlyph is not initialized by download.c
                        //
                        ERR(("DwOutputGlyphCallback: pTod->apdlGlyph[dwCurrGlyphIndex++] is NULL."));
                        continue;
                    }

                    *pdwGlyph = pdlGlyph->wDLGlyphID;

                    if (GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph))
                    {
                        //
                        // Need to select the new softfont.
                        // We do this by setting pfm->ulDLIndex
                        // to new softfontid.
                        //

                        pFontMap->ulDLIndex = pdlGlyph->wDLFontId;
                        bNewFontSelect = TRUE;
                        break;
                    }
                }

                if (dwCount > 0)
                {
                    HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
                                                                (PUNIFONTOBJ)pUFObj,
                                                                TYPE_GLYPHID,
                                                                dwCount,
                                                                pdwGlyphStart))
                    else
                    CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHID, dwCount, pdwGlyphStart);

                    //
                    // Update position
                    //
                    pgp --;
                    VSetCursor( pPDev,
                                pgp->ptl.x + pdlGlyph->wWidth,
                                pgp->ptl.y,
                                MOVE_ABSOLUTE|MOVE_UPDATE,
                                &ptlRem);
                    dwCount = 0;
                }

                if (bNewFontSelect)
                {
                    dwCount = 1;
                    *pdwGlyphStart = *pdwGlyph;
                    pdwGlyph = pdwGlyphStart + 1;
                    pUFObj->ulFontID = pFontMap->ulDLIndex;

                    BNewFont(pPDev, pTod->iFace, pFontMap, 0);
                    bNewFontSelect = FALSE;
                }

            } while (dwCount > 0);

        }

        pgp --;
        if (NULL != pdlGlyph)
        {
            iXInc = pdlGlyph->wWidth;
        }
        else
        {
            iXInc = 0;
        }
    }
    else // Device Font
    {
        pGlyphData  = ((PFONTMAP_DEV)pFontMap->pSubFM)->pvNTGlyph;
        pMapTable   = GET_MAPTABLE(pGlyphData);
        pTrans      = pMapTable->Trans;
        pCmdSingle  = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTSINGLEBYTEMODE);
        pCmdDouble  = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTDOUBLEBYTEMODE);

        if (bSetCursorForEachGlyph)
        {
            for (dwI = 0; dwI < pTod->cGlyphsToPrint; dwI ++, pgp ++)
            {
                //
                // UNIDRV returns 1 for the first glyph handle in FD_GLYPHSET.
                // However, GDI could pass zero in hg.
                // We need to handle this GDI error properly.
                // 
                if (0 == pgp->hg)
                {
                    continue;
                }

                VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

                if (
                    (pCmdSingle)                                &&
                    (pTrans[pgp->hg - 1].ubType & MTYPE_SINGLE) &&
                    !(pFontPDev->flFlags & FDV_SINGLE_BYTE)
                   )
                {
                    WriteChannel( pPDev, pCmdSingle );
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE;
                }
                else
                if (
                    (pCmdDouble)                                  &&
                    (pTrans[pgp->hg - 1].ubType & MTYPE_DOUBLE) &&
                    !(pFontPDev->flFlags & FDV_DOUBLE_BYTE)
                   )
                {
                    WriteChannel( pPDev, pCmdDouble );
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_SINGLE_BYTE;
                }


                HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
                                                            (PUNIFONTOBJ)pUFObj,
                                                            TYPE_GLYPHHANDLE,
                                                            1,
                                                            &(pgp->hg)))
                else
                CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHHANDLE, 1, &(pgp->hg));

                //
                // Update position
                //
                GET_CHARWIDTH(iXInc, pFontMap, pgp->hg);

                VSetCursor( pPDev,
                            iXInc,
                            0,
                            MOVE_RELATIVE|MOVE_UPDATE,
                            &ptlRem);
            }
        }
        else // Default Placement
        {
            bPrint  = FALSE;
            dwCount = 0;
            VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

            for (dwI = 0; dwI < pTod->cGlyphsToPrint; dwI ++, pgp ++, pdwGlyph ++, dwCount++)
            {
                *pdwGlyph = pgp->hg;

                //
                // Single/Double byte mode switch
                //

                if (pCmdSingle &&
                    (pTrans[*pdwGlyph - 1].ubType & MTYPE_SINGLE) &&
                    !(pFontPDev->flFlags & FDV_SINGLE_BYTE)  )
                {

                    pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
                    pCmd = pCmdSingle;
                    bPrint = TRUE;
                }
                else
                if (pCmdDouble &&
                    (pTrans[*pdwGlyph - 1].ubType & MTYPE_DOUBLE)   &&
                    !(pFontPDev->flFlags & FDV_DOUBLE_BYTE) )
                {
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_SINGLE_BYTE;
                    pCmd = pCmdDouble;
                    bPrint = TRUE;
                }


                if (bPrint)
                {
                    if (dwI != 0)
                    {
                        HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
		    (PUNIFONTOBJ)pUFObj,
		    TYPE_GLYPHHANDLE,
		    dwCount,
		    pdwGlyphStart))
                        else
                        CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHHANDLE, dwCount, pdwGlyphStart);

                        //
                        // Update position
                        //
                        GET_CHARWIDTH(iXInc, pFontMap, pgp->hg);
                        VSetCursor( pPDev,
                                    iXInc,
                                    0,
                                    MOVE_RELATIVE|MOVE_UPDATE,
                                    &ptlRem);

                        dwCount = 0;
                        pdwGlyphStart = pdwGlyph;
                    }

                    WriteChannel(pPDev, pCmd);
                    bPrint = FALSE;
                }
            }

            HANDLE_VECTORPROCS(pPDev, VMOutputCharStr, ((PDEVOBJ)pPDev,
	                        (PUNIFONTOBJ)pUFObj,
	                        TYPE_GLYPHHANDLE,
	                        dwCount,
	                        pdwGlyphStart))
            else
            CALL_OEMOUTPUTCHARSTR(TYPE_GLYPHHANDLE, dwCount, pdwGlyphStart);

        }


        //
        // Output may have successed, so update the position.
        //

        pgp --;

        GET_CHARWIDTH(iXInc, pFontMap, pgp->hg);

        VSetCursor( pPDev,
                    pgp->ptl.x + iXInc,
                    pgp->ptl.y,
                    MOVE_ABSOLUTE|MOVE_UPDATE,
                    &ptlRem);
    }


    return pTod->cGlyphsToPrint;

}

BOOL
BFontCmdCallback(
    PDEV     *pdev,
    PFONTMAP  pFM,
    POINTL   *pptl,
    BOOL      bSelect)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling sub routine for FONTMAP dispatch routine

Arguments:

    pdev - a pointer to PDEV
    pFM - a pointer to FONTMAP
    pptl - a pointer to POINTL which has the height and with of font
    bSelect - Boolean to send selection/deselection command

Return Value:

    TRUE if successful, otherwise FALSE.

Note:


--*/
{
    PFN_OEMSendFontCmd  pfnOEMSendFontCmd;
    FONTPDEV           *pFontPDev;
    PFONTMAP_DEV        pfmdev;
    FINVOCATION         FInv;

    ASSERT(pdev && pFM);

    if (pdev->pOemHookInfo &&
        (pfnOEMSendFontCmd = (PFN_OEMSendFontCmd)pdev->pOemHookInfo[EP_OEMSendFontCmd].pfnHook) ||
       (pdev->ePersonality == kPCLXL))
    {
        pFontPDev = pdev->pFontPDev;
        pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE | FDV_SINGLE_BYTE;

        if (pFM->dwFontType == FMTYPE_DEVICE)
        {
            pfmdev    = pFM->pSubFM;
            pfmdev->ulCodepageID = (ULONG)-1;
            pFontPDev->pUFObj->pFontMap = pFM;

            if (pFM->flFlags & FM_IFIVER40)
            {
                if (bSelect)
                {
                    FInv.dwCount    = pfmdev->cmdFontSel.pCD->wLength;
                    FInv.pubCommand = pfmdev->cmdFontSel.pCD->rgchCmd;
                }
                else
                {
                    FInv.dwCount    = pfmdev->cmdFontDesel.pCD->wLength;
                    FInv.pubCommand = pfmdev->cmdFontDesel.pCD->rgchCmd;
                }
            }
            else
            {
                if (bSelect)
                {
                    FInv.dwCount    = pfmdev->cmdFontSel.FInv.dwCount;
                    FInv.pubCommand = pfmdev->cmdFontSel.FInv.pubCommand;
                }
                else
                {
                    FInv.dwCount    = pfmdev->cmdFontDesel.FInv.dwCount;
                    FInv.pubCommand = pfmdev->cmdFontDesel.FInv.pubCommand;
                }
            }
        }
        else
        if (pFM->dwFontType == FMTYPE_TTOEM)
        {
            //
            // Initialize UNIFONTOBJ
            //
            pFontPDev->pUFObj->ulFontID = pFM->ulDLIndex;
            pFontPDev->pUFObj->pFontMap = pFM;

            //
            // Initialize FInv
            //
            FInv.dwCount = sizeof(ULONG);
            FInv.pubCommand = (PBYTE)&(pFontPDev->pUFObj->ulFontID);
        }



        HANDLE_VECTORPROCS(pdev, VMSendFontCmd, ((PDEVOBJ)pdev,
                                                 (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                 &FInv))
        else
        {
            FIX_DEVOBJ(pdev, EP_OEMSendFontCmd);
            if (pdev->pOemEntry)
            {
    
                if(((POEM_PLUGIN_ENTRY)pdev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                {
                        HRESULT  hr ;
                        hr = HComSendFontCmd((POEM_PLUGIN_ENTRY)pdev->pOemEntry,
                                      &pdev->devobj, (PUNIFONTOBJ)pFontPDev->pUFObj,
                                      &FInv);
                        if(SUCCEEDED(hr))
                            ;  //  cool !
                }
                else
                {
					if (NULL != pfnOEMSendFontCmd)
					{
						pfnOEMSendFontCmd(&pdev->devobj,
										  (PUNIFONTOBJ)pFontPDev->pUFObj,
										  &FInv);
					}
                }
            }
        }

    }

    return TRUE;
}

BOOL
BSelectFontCallback(
    PDEV   *pdev,
    PFONTMAP  pFM,
    POINTL *pptl)
/*++

Routine Description:

    Implementation of OEM SendFontCMd calling routine for FONTMAP dispatch routine

Arguments:

    pTod - a pointer to TO_DATA.

Return Value:

    The number of glyph printed.

Note:


--*/
{
    return BFontCmdCallback(pdev, pFM, pptl, TRUE);
}

BOOL
BDeselectFontCallback(
    PDEV     *pdev,
    PFONTMAP pFM)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling routine for FONTMAP dispatch routine

Arguments:

    pTod - a pointer to TO_DATA.

Return Value:

    The number of glyph printed.

Note:


--*/
{

    return BFontCmdCallback(pdev, pFM, NULL, FALSE);
}


DWORD
DwDLHeaderOEMCallback(
    PDEV *pPDev,
    PFONTMAP pFM)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling routine for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pFM - a pointer to FONTMAP

Return Value:


Note:


--*/
{
    PFN_OEMDownloadFontHeader pfnOEMDownloadFontHeader;
    PFONTPDEV pFontPDev;
    DWORD dwMem = 0;

    //
    // Should not be NULL
    //
    ASSERT(pPDev && pFM);

    pFontPDev = pPDev->pFontPDev;
    pfnOEMDownloadFontHeader = NULL;

    if ( pPDev->pOemHookInfo &&
        (pfnOEMDownloadFontHeader = (PFN_OEMDownloadFontHeader)
         pPDev->pOemHookInfo[EP_OEMDownloadFontHeader].pfnHook) ||
        (pPDev->ePersonality == kPCLXL))
    {
        HRESULT  hr ;

        if (pFontPDev->pUFObj == NULL)
        {
            //
            // This should not happen. pUFObj must be initialized.
            //
            ERR(("DwDLHeaderOEMCallback: pFontPDev->pUFObj is NULL"));
            return 0;
        }

        pFontPDev->pUFObj->pFontMap = pFM;
        pFontPDev->pUFObj->ulFontID = pFM->ulDLIndex;
        BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_NFID);
        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));

        HANDLE_VECTORPROCS(pPDev, VMDownloadFontHeader, ((PDEVOBJ)pPDev,
                                                         (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                         &dwMem))
        else
        {
            FIX_DEVOBJ(pPDev, EP_OEMDownloadFontHeader);
            if (pPDev->pOemEntry)
            {
    
                if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                {
                        hr = HComDownloadFontHeader((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                    &pPDev->devobj, (PUNIFONTOBJ)pFontPDev->pUFObj, &dwMem);
                        if(SUCCEEDED(hr))
                            ;  //  cool !
                }
                else if (pfnOEMDownloadFontHeader)
                {
                    dwMem = pfnOEMDownloadFontHeader(&pPDev->devobj,
                                                     (PUNIFONTOBJ)pFontPDev->pUFObj);
                }
            }
        }


    }

    return dwMem;
}

DWORD
DwDLGlyphOEMCallback(
    PDEV            *pPDev,
    PFONTMAP        pFM,
    HGLYPH          hGlyph,
    WORD            wDLGlyphId,
    WORD            *pwWidth)
/*++

Routine Description:

    Implementation of OEM SendFontCmd calling routine for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pFM - a pointer to FONTMAP

Return Value:


Note:


--*/
{
    PFN_OEMDownloadCharGlyph pfnOEMDownloadCharGlyph;
    PI_UNIFONTOBJ pUFObj;
    PFONTPDEV pFontPDev;
    DL_MAP   *pdm;
    DWORD     dwMem;
    INT       iWide;

    //
    // There values have to be non-NULL.
    //
    ASSERT(pPDev && pFM);

    dwMem     = 0;
    iWide     = 0;
    pFontPDev = pPDev->pFontPDev;
    pUFObj    = pFontPDev->pUFObj;
    pdm       =  ((PFONTMAP_TTOEM)pFM->pSubFM)->u.pvDLData;
    pfnOEMDownloadCharGlyph = NULL;

    //
    // There values have to be non-NULL.
    //
    ASSERT(pFontPDev && pUFObj && pdm);

    if ( pPDev->pOemHookInfo &&
        (pfnOEMDownloadCharGlyph = (PFN_OEMDownloadCharGlyph)
         pPDev->pOemHookInfo[EP_OEMDownloadCharGlyph].pfnHook) ||
        (pPDev->ePersonality == kPCLXL))
    {
        HRESULT  hr ;

        if (!(PFDV->flFlags & FDV_SET_FONTID))
        {
            pFM->ulDLIndex = pdm->wCurrFontId;
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_NFID);
            WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));
            PFDV->flFlags  |= FDV_SET_FONTID;

        }

        BUpdateStandardVar(pPDev, pFM, wDLGlyphId, 0, STD_GL);

        WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETCHARCODE));

        pUFObj->pFontMap = pFM;
        pUFObj->ulFontID = pFM->ulDLIndex;

        HANDLE_VECTORPROCS(pPDev, VMDownloadCharGlyph, ((PDEVOBJ)pPDev,
                                                        (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                        hGlyph,
                                                        (PDWORD)&iWide,
                                                        &dwMem))
        else
        {
            FIX_DEVOBJ(pPDev, EP_OEMDownloadCharGlyph);
            if (pPDev->pOemEntry)
            {
    
                if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                {
                        hr = HComDownloadCharGlyph((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                                    &pPDev->devobj,
                                                    (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                    hGlyph,
                                                    (PDWORD)&iWide, &dwMem);
                        if(SUCCEEDED(hr))
                            ;  //  cool !
                }
                else if (pfnOEMDownloadCharGlyph)
                {
                    dwMem = pfnOEMDownloadCharGlyph(&pPDev->devobj,
                                                    (PUNIFONTOBJ)pFontPDev->pUFObj,
                                                    hGlyph,
                                                    (PDWORD)&iWide);
                }
            }
        }


        ((PFONTMAP_TTOEM)pFM->pSubFM)->dwDLSize += dwMem;
        *pwWidth = (WORD)iWide;
    }

    return dwMem;
}

BOOL
BCheckCondOEMCallback(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pso,
    IFIMETRICS  *pifi
    )
/*++

Routine Description:

    Implementation of CheckConditon for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pfo - a pointer to FONTOBJ
    pso - a pointer to STROBJ
    pifi - a pointer to IFIMETRICS

Return Value:


Note:


--*/
{
    PFONTPDEV     pFontPDev;
    PI_UNIFONTOBJ pUFObj;

    ASSERT(pPDev);

    pFontPDev = pPDev->pFontPDev;
    pUFObj = pFontPDev->pUFObj;

    if (pUFObj->dwFlags & UFOFLAG_TTFONT)
        return TRUE;
    else
        return FALSE;
}

BOOL
BSelectTrueTypeOutline(
    PDEV     *pPDev,
    PFONTMAP pFM,
    POINTL  *pptl)
{
    BOOL bRet = FALSE;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        if (BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_CFID ) &&
            BFontCmdCallback(pPDev, pFM, pptl, TRUE)                   )
            bRet = TRUE;
    }

    return bRet;
}

BOOL
BDeselectTrueTypeOutline(
    PDEV     *pPDev,
    PFONTMAP pFM)
{
    BOOL bRet = FALSE;

    DWORD dwFlags;
    PFONTPDEV       pFontPDev = pPDev->pFontPDev;
    PFONTMAP_TTOEM pFMOEM = (PFONTMAP_TTOEM) pFM->pSubFM;

    //
    // Deselect case. We need to reinitialize UFObj
    // 
    dwFlags = ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags;
    ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags = pFMOEM->dwFlags;

    if( pFM->flFlags & FM_SOFTFONT )
    {
        if (BUpdateStandardVar(pPDev, pFM, 0, 0, STD_STD | STD_CFID ) &&
            BFontCmdCallback(pPDev, pFM, NULL, 0)                      )
            bRet = TRUE;
    }

    //
    // Restore the current dwFlags in UFOBJ
    //
    ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags = dwFlags;

    return bRet;
}


BOOL
BOEMFreePFMCallback(
    PFONTMAP pfm)
/*++

Routine Description:

    Implementation of PFM Free function for FONTMAP dispatch routine

Arguments:

    pFM - a pointer to FONTMAP

Return Value:


Note:


--*/

{
    ASSERT(pfm);

    if (pfm)
    {
        if (pfm->pIFIMet)
            MemFree(pfm->pIFIMet);

        MemFree(pfm);
        return TRUE;
    }
    else
        return FALSE;
}

PFONTMAP
PfmInitPFMOEMCallback(
    PDEV    *pPDev,
    FONTOBJ *pfo)
/*++

Routine Description:

    Implementation of PfmInit for FONTMAP dispatch routine

Arguments:

    pPDev - a pointer to PDEV
    pfo - a pointer to FONTOBJ

Return Value:

    A pointer to FONTMAP

Note:


--*/
{
    PFONTPDEV       pFontPDev;
    PFONTMAP        pfm;
    DWORD           dwSize;

    ASSERT(pPDev && pfo);

    pFontPDev = pPDev->pFontPDev;
    dwSize    = sizeof(FONTMAP) + sizeof(FONTMAP_TTOEM);

    if (pfm = MemAlloc(dwSize))
    {
        PFONTMAP_TTOEM pFMOEM;

        ZeroMemory(pfm, dwSize);
        pfm->dwSignature = FONTMAP_ID;
        pfm->dwSize      = sizeof(FONTMAP);
        pfm->dwFontType  = FMTYPE_TTOEM;
        pfm->pSubFM      = (PVOID)(pfm+1);

        pfm->wFirstChar  = 0;
        pfm->wLastChar   = 0xffff;

        pfm->wXRes = (WORD)pPDev->ptGrxRes.x;
        pfm->wYRes = (WORD)pPDev->ptGrxRes.y;

        pfm->pIFIMet    =   pFontPDev->pIFI;
        pfm->ulDLIndex  =   (ULONG)-1;

        if (!(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
        {
            pfm->syAdj = ((IFIMETRICS*)pfm->pIFIMet)->fwdWinAscender;
        }

        if (pPDev->pOemHookInfo &&
                pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook ||
            (pPDev->ePersonality == kPCLXL)
        )
            pfm->pfnGlyphOut           = DwOutputGlyphCallback;
        else
            pfm->pfnGlyphOut           = DwTrueTypeBMPGlyphOut;

        if (pPDev->ePersonality == kPCLXL)
        {
            pfm->pfnSelectFont         = BSelectTrueTypeOutline;
            pfm->pfnDeSelectFont       = BDeselectTrueTypeOutline;
        }
        else
        if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
        {
            pfm->pfnSelectFont         = BSelectTrueTypeOutline;
            pfm->pfnDeSelectFont       = BDeselectTrueTypeOutline;
        }
        else
        if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_BITMAP)
        {
            pfm->pfnSelectFont         = BSelectTrueTypeBMP;
            pfm->pfnDeSelectFont       = BDeselectTrueTypeBMP;
        }

        pfm->pfnDownloadFontHeader = DwDLHeaderOEMCallback;
        pfm->pfnDownloadGlyph      = DwDLGlyphOEMCallback;
        pfm->pfnCheckCondition     = BCheckCondOEMCallback;
        pfm->pfnFreePFM            = BOEMFreePFMCallback;

        pFMOEM = (PFONTMAP_TTOEM) pfm->pSubFM;
        pFMOEM->dwFlags = ((PI_UNIFONTOBJ)pFontPDev->pUFObj)->dwFlags;
        pFMOEM->flFontType = pfo->flFontType;
        if (pFontPDev->pUFObj->dwFlags & UFOFLAG_TTDOWNLOAD_TTOUTLINE)
        {
            if (pfo->flFontType & FO_SIM_BOLD)
                pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_BOLD_SIM;

            if (pfo->flFontType & FO_SIM_ITALIC)
                pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_ITALIC_SIM;

            if (NULL != pFontPDev->pIFI &&
                '@' == *((PBYTE)pFontPDev->pIFI + pFontPDev->pIFI->dpwszFamilyName))
            {
                pFontPDev->pUFObj->dwFlags |= UFOFLAG_TTOUTLINE_VERTICAL;
            }
        }
    }
    else
    {
        ERR(("PfmInitPFMOEMCallback: MemAlloc failed.\n"));
    }

    return pfm;

}

//
// Misc functions
//


VOID
VUFObjFree(
    IN FONTPDEV* pFontPDev)
/*++

Routine Description:

    UFObj(UNIFONTOBJ) memory free function

Arguments:

    pFontPDev - a pointer to FONTPDEV.

Return Value:


Note:

--*/
{
    PI_UNIFONTOBJ pUFObj = pFontPDev->pUFObj;

    ASSERT(pFontPDev);

    pUFObj = pFontPDev->pUFObj;

    if (pUFObj && pUFObj->pGlyph)
        MemFree(pUFObj->pGlyph);

    pFontPDev->pUFObj = NULL;
}

WCHAR
WGHtoUnicode(
    DWORD     dwNumOfRuns,
    PGLYPHRUN pGlyphRun,
    HGLYPH    hg)
/*++

Routine Description:

    Character coversion function from HGLYPH to Unicode.

Arguments:

    dwNumOfRuns - number of run in pGlyphRun
    pGlyphRun - a pointer to glyph run
    hd - HGLYPH

Return Value:

    Unicode character

Note:

--*/
{
    DWORD  dwI;
    HGLYPH hCurrent = 1;
    WCHAR  wchChar = 0;

    ASSERT(pGlyphRun);

    for( dwI = 0;  dwI < dwNumOfRuns; dwI ++, pGlyphRun ++)
    {
        if (hCurrent <= hg && hg < hCurrent + pGlyphRun->wGlyphCount)
        {
            wchChar = (WCHAR)(pGlyphRun->wcLow + hg - hCurrent);
            break;
        }
        hCurrent += pGlyphRun->wGlyphCount;
    }

    return  wchChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmcallbk.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmcallbk.h

Abstract:

    The font module callback helper functions

Environment:

    Windows NT Unidrv driver

Revision History:

    03/31/97 -eigos-
        Created

--*/


typedef struct _I_UNIFONTOBJ {
    ULONG       ulFontID;
    DWORD       dwFlags;
    IFIMETRICS *pIFIMetrics;
    PFNGETINFO  pfnGetInfo;

    FONTOBJ    *pFontObj;
    STROBJ     *pStrObj;
    struct _FONTMAP  *pFontMap;
    struct _PDEV *pPDev;
    POINT       ptGrxRes;
    VOID       *pGlyph;
    struct _DLGLYPH   **apdlGlyph;
    DWORD       dwNumInGlyphTbl;
} I_UNIFONTOBJ, *PI_UNIFONTOBJ;

BOOL
UNIFONTOBJ_GetInfo(
    IN  PUNIFONTOBJ pUFObj,
    IN  DWORD       dwInfoID,
    IN  PVOID       pData,
    IN  DWORD       dwDataSize,
    OUT PDWORD      pcNeeded);

VOID
VUFObjFree(
    IN struct _FONTPDEV  *pFontPDev);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fileio.h ===
/************************** Module Header ***********************************
 * fileio.h
 *      Function Prototypes for File I/O in Kernel mode.
 *
 * NOTE:  these functions perform File read, seek operations.
 *
 * Copyright (C) 1991 - 1999  Microsoft Corporation
 *
 ****************************************************************************/

#define         CURRENTFILEPTR(pFile)  (LPVOID)((LPBYTE)(pFile->pvFilePointer)\
                                                + pFile->dwCurrentByteOffset)

#define         ENDOFFILEPTR(pFile)       ( pFile->pvFilePointer + \
                                            pFile->dwTotalSize )

#define         STARTFILEPTR(pFile)     ( pFile->pvFilePointer )

#define         STARTFILEOFFSETPTR(pFile,offset) ( pFile->pvFilePointer + \
                                                    offset )

#define         NUMBYTESREMAINING(pFile) ( pFile->dwTotalSize - \
                                             pFile->dwCurrentByteOffset )

#define         UPDATECURROFFSET(pFile,offset) (pFile->dwCurrentByteOffset +=\
                                                offset )

#define         DRV_FILE_BEGIN       0

#define         DRV_FILE_CURRENT     1

#define         INVALID_HANDLE_VALUE (HANDLE)-1

typedef struct _MAPFILE
{
    HANDLE   hHandle;  /* Handle to the file, returned by EngLoadModule */
    DWORD    dwTotalSize;  /* Total Size of the file, as returned by
                            * EngMapModule.
                            */
    DWORD    dwCurrentByteOffset; /* Current Byte Offset in the file.
                                   * Updated after each read and DrvSetFile-
                                   * Pointer.
                                   */
    PVOID    pvFilePointer;       /* Start of the file pointer, as returned
                                   * EngMapModule
                                   */
    struct _MAPFILE *pNext;           /* Next File Pointer.*/

}MAPFILE, * PMAPFILE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmdebug.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    debug.c

Abstract:
    Routines For Font debugging support.This file should be the last in SOURCES.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

--*/
#if DBG

#ifndef PUBLIC_GDWDEBUGFONT
#define PUBLIC_GDWDEBUGFONT
#endif //PUBLIC_GDWDEBUGFONT

#include "font.h"

BYTE *gcstrflInfo[] = {"FM_INFO_TECH_TRUETYPE",
                       "FM_INFO_TECH_BITMAP",
                       "FM_INFO_TECH_STROKE",
                       "FM_INFO_TECH_OUTLINE_NOT_TRUETYPE",
                       "FM_INFO_ARB_XFORMS",
                       "FM_INFO_1BPP",
                       "FM_INFO_4BPP",
                       "FM_INFO_8BPP",
                       "FM_INFO_16BPP",
                       "FM_INFO_24BPP",
                       "FM_INFO_32BPP",
                       "FM_INFO_INTEGER_WIDTH",
                       "FM_INFO_CONSTANT_WIDTH",
                       "FM_INFO_NOT_CONTIGUOUS",
                       "FM_INFO_TECH_MM",
                       "FM_INFO_RETURNS_OUTLINES",
                       "FM_INFO_RETURNS_STROKES",
                       "FM_INFO_RETURNS_BITMAPS",
                       "FM_INFO_UNICODE_COMPLIANT",
                       "FM_INFO_RIGHT_HANDED",
                       "FM_INFO_INTEGRAL_SCALING",
                       "FM_INFO_90DEGREE_ROTATIONS",
                       "FM_INFO_OPTICALLY_FIXED_PITCH",
                       "FM_INFO_DO_NOT_ENUMERATE",
                       "FM_INFO_ISOTROPIC_SCALING_ONLY",
                       "FM_INFO_ANISOTROPIC_SCALING_ONLY",
                       "FM_INFO_MM_INSTANCE",
                       "FM_INFO_FAMILY_EQUIV",
                       "FM_INFO_DBCS_FIXED_PITCH",
                       "FM_INFO_NONNEGATIVE_AC",
                       "FM_INFO_IGNORE_TC_RA_ABLE",
                       "FM_INFO_TECH_TYPE1"};

VOID
VDbgDumpUCGlyphData(
    FONTMAP   *pFM
    )
/*++

Routine Description:
    Dumps the Font's Glyph Data.

Arguments:
    pFM             FONTMAP struct of the Font about for which information is
                    desired.

Return Value:
    None

Note:
    12-30-96: Created it -ganeshp-

--*/
{

    /*  Enable this code to print out your data array */

    HGLYPH      *phg;
    ULONG       cRuns;
    FD_GLYPHSET *pGLSet;       /* Base of returned data */
    PWSTR       pwszFaceName;
    IFIMETRICS  *pIFI;          /* For convenience */

    if ( gdwDebugFont & DBG_FD_GLYPHSET )
    {
        if (!pFM || !(pFM->pIFIMet) || !(((PFONTMAP_DEV)pFM->pSubFM)->pUCTree))
        {
            WARNING(("One of pFM/pFM->pIFIMet/pFM->pSubFM->pUCTree is NULL"));
            return;
        }

        pIFI = pFM->pIFIMet;
        pwszFaceName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName  );
        pGLSet = ((PFONTMAP_DEV)pFM->pSubFM)->pUCTree;

        DbgPrint( "UniFont!VDumpUCGlyphData: pwszFaceName = %ws: FD_GLYPHSET:\n", pwszFaceName );
        DbgPrint( " cjThis = %ld, flAccel = 0x%lx, Supp = %ld, cRuns = %ld\n",
            pGLSet->cjThis, pGLSet->flAccel, pGLSet->cGlyphsSupported,
            pGLSet->cRuns );

        /*  Loop through the WCRUN structures  */
        for( cRuns = 0; cRuns < pGLSet->cRuns; cRuns++ )
        {
            int   i;

            DbgPrint( "+Run %d:\n", cRuns );
            DbgPrint( " wcLow = %d, cGlyphs = %d, phg = 0x%lx\n",
                    pGLSet->awcrun[ cRuns ].wcLow, pGLSet->awcrun[ cRuns ].cGlyphs,
                    pGLSet->awcrun[ cRuns ].phg );

            phg = pGLSet->awcrun[ cRuns ].phg;

            /*    List the glyph handles for this run */

            for( i = 0; i < 256 && i < pGLSet->awcrun[ cRuns ].cGlyphs; i++ )
            {
                DbgPrint( "0x%4lx, ",  *phg++ );
                if( ((i + 1) % 8) == 0 )
                    DbgPrint( "\n" );
            }
            DbgPrint( "\n" );
        }

    }


}

VOID
VDbgDumpGTT(
     PUNI_GLYPHSETDATA pGly)
{
    if ( gdwDebugFont & DBG_UNI_GLYPHSETDATA )
    {
        PUNI_CODEPAGEINFO pCP;
        PGLYPHRUN         pGlyphRun;
        PMAPTABLE         pMapTable;
        TRANSDATA        *pTrans;
        DWORD             dwI;
        WORD              wSize, wJ;
        PBYTE             pCommand;

        pCP       = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);
        pGlyphRun = (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);
        pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
        pTrans    = pMapTable->Trans;

        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("G L Y P H S E T   D A T A   F I L E\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("GLYPHSETDATA\n");
        DbgPrint("GLYPHSETDATA.dwSize              : %d\n", pGly->dwSize);
        DbgPrint("             dwVersion           : %d.%d\n", (pGly->dwVersion) >>16,
                                                     0x0000ffff&pGly->dwVersion);
        DbgPrint("             dwFlags             : %d\n", pGly->dwFlags);
        DbgPrint("             lPredefinedID       : %d\n", pGly->lPredefinedID);
        DbgPrint("             dwGlyphCount        : %d\n", pGly->dwGlyphCount);
        DbgPrint("             dwRunCount          : %d\n", pGly->dwRunCount);
        DbgPrint("             loRunOffset         : 0x%x\n", pGly->loRunOffset);
        DbgPrint("             dwCodePageCount     : %d\n", pGly->dwCodePageCount);
        DbgPrint("             loCodePageOffset    : 0x%x\n", pGly->loCodePageOffset);
        DbgPrint("             loMapTableOffset    : 0x%x\n", pGly->loMapTableOffset);

        DbgPrint("\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("CODEPAGEINFO\n");
        for (dwI = 0; dwI < pGly->dwCodePageCount; dwI ++)
        {
            DbgPrint ("UNI_CODEPAGEINFO[%d].dwCodePage                = %d\n",
                dwI, pCP->dwCodePage);
            DbgPrint ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount   = %d\n",
                dwI, pCP->SelectSymbolSet.dwCount);
            if (pCP->SelectSymbolSet.dwCount &&
                pCP->SelectSymbolSet.loOffset  )
                DbgPrint ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command   = %s\n", dwI, (PBYTE)pCP+pCP->SelectSymbolSet.loOffset);
            DbgPrint ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount = %d\n",
                dwI, pCP->UnSelectSymbolSet.dwCount);
            if (pCP->UnSelectSymbolSet.dwCount &&
                pCP->UnSelectSymbolSet.loOffset  )
                DbgPrint ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command   = %s\n", dwI, (PBYTE)pCP+pCP->UnSelectSymbolSet.loOffset);
            pCP++;
        }

        pGlyphRun =
                (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);

        DbgPrint("\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("GLYPHRUN\n");
        for (dwI = 0; dwI < pGly->dwRunCount; dwI ++)
        {
             DbgPrint("GLYPHRUN[%2d].wcLow       = 0x%-4x ",
                 dwI, pGlyphRun->wcLow);
             DbgPrint("GLYPHRUN[%2d].wGlyphCount = %d\n",
                 dwI, pGlyphRun->wGlyphCount);
             pGlyphRun++;
        }

        pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
        pTrans    = pMapTable->Trans;

        DbgPrint("\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("MAPTABLE\n");
        DbgPrint("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
        DbgPrint("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

        #if 0
        for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
        {
            DbgPrint("MAPTABLE.pTrans[%5d].ubCodePageID = %d ",
                dwI, pTrans[dwI].ubCodePageID);
            DbgPrint("MAPTABLE.pTrans[%5d].ubType       = %d ",
                dwI, pTrans[dwI].ubType);
            switch(pTrans[dwI].ubType)
            {
            case MTYPE_DIRECT:
                DbgPrint("MAPTABLE.pTrans[%5d].ubCode       = 0x%02x\n",
                    dwI, pTrans[dwI].uCode.ubCode);
                break;
            case MTYPE_PAIRED:
                DbgPrint("MAPTABLE.pTrans[%5d].ubPairs[0]   = 0x%02x ",
                    dwI, pTrans[dwI].uCode.ubPairs[0]);
                DbgPrint("MAPTABLE.pTrans[%5d].ubPairs[1]   = 0x%02x ",
                    dwI, pTrans[dwI].uCode.ubPairs[1]);
                break;
            case MTYPE_COMPOSE:
                    DbgPrint("MAPTABLE.pTrans[%5d].sCode        = 0x%02x ",
                        dwI, pTrans[dwI].uCode.sCode);
                    pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                    wSize = *(WORD*)pCommand;
                    pCommand += 2;
                    DbgPrint("Size                                = 0x%d ", wSize);
                    DbgPrint("Command                             = 0x");
                    for (wJ = 0; wJ < wSize; wJ ++)
                    {
                        DbgPrint("%02x",pCommand[wJ]);
                    }
                    DbgPrint("\n");
                break;
            }
        }
        #endif
    }
}


VOID
VDbgDumpFONTMAP(
    FONTMAP *pFM)
{
}

VOID
VDbgDumpIFIMETRICS(
    IFIMETRICS *pIFI)
{
    PWSTR   pwszFamilyName;
    PWSTR   pwszStyleName;
    PWSTR   pwszFaceName;
    PWSTR   pwszUniqueName;
    DWORD   dwI;

    if ( gdwDebugFont & DBG_IFIMETRICS )
    {
        pwszFamilyName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFamilyName);
        pwszStyleName  = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszStyleName) ;
        pwszFaceName   = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName)  ;
        pwszUniqueName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszUniqueName);

        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("IFIMETRICS\n");
        DbgPrint("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        DbgPrint("IFIMETIRCS.cjThis               = %-#8lx\n" , pIFI->cjThis );
        DbgPrint("IFIMETIRCS.cjIfiExtra           = %-#8lx\n" , pIFI->cjIfiExtra);
        DbgPrint("IFIMETIRCS.pwszFamilyName       = \"%ws\"\n", pwszFamilyName );

        if( pIFI->flInfo & FM_INFO_FAMILY_EQUIV )
        {
            while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            {
                DbgPrint("                               \"%ws\"\n", pwszFamilyName );
            }
        }
        DbgPrint("IFIMETRICS.pwszStyleName        = \"%ws\"\n", pwszStyleName);
        DbgPrint("IFIMETRICS.pwszFaceName         = \"%ws\"\n", pwszFaceName);
        DbgPrint("IFIMETRICS.pwszUniqueName       = \"%ws\"\n", pwszUniqueName);
        DbgPrint("IFIMETRICS.dpFontSim            = %-#8lx\n" , pIFI->dpFontSim);
        DbgPrint("IFIMETRICS.lEmbedId             = %d\n", pIFI->lEmbedId);
        DbgPrint("IFIMETRICS.lItalicAngle         = %d\n", pIFI->lItalicAngle);
        DbgPrint("IFIMETRICS.lCharBias            = %d\n", pIFI->lCharBias);
        DbgPrint("IFIMETRICS.dpCharSets           = %d\n", pIFI->dpCharSets);
        DbgPrint("IFIMETRICS.jWinCharSet          = %04x\n", pIFI->jWinCharSet);
        DbgPrint("IFIMETRICS.jWinPitchAndFamily   = %04x\n", pIFI->jWinPitchAndFamily);
        DbgPrint("IFIMETRICS.usWinWeight          = %d\n", pIFI->usWinWeight);
        DbgPrint("IFIMETRICS.flInfo               = %-#8lx\n", pIFI->flInfo);

        for( dwI = 0; dwI < 32; dwI ++ )
        {
            if (pIFI->flInfo & (0x00000001 << dwI))
            {
                DbgPrint("                                  %s\n", gcstrflInfo[dwI]);
            }
        }
        DbgPrint("IFIMETRICS.fsSelection          = %-#6lx\n", pIFI->fsSelection);
        DbgPrint("IFIMETRICS.fsType               = %-#6lx\n", pIFI->fsType);
        DbgPrint("IFIMETRICS.fwdUnitsPerEm        = %d\n", pIFI->fwdUnitsPerEm);
        DbgPrint("IFIMETRICS.fwdLowestPPEm        = %d\n", pIFI->fwdLowestPPEm);
        DbgPrint("IFIMETRICS.fwdWinAscender       = %d\n", pIFI->fwdWinAscender);
        DbgPrint("IFIMETRICS.fwdWinDescender      = %d\n", pIFI->fwdWinDescender);
        DbgPrint("IFIMETRICS.fwdMacAscender       = %d\n", pIFI->fwdMacAscender);
        DbgPrint("IFIMETRICS.fwdMacDescender      = %d\n", pIFI->fwdMacDescender);
        DbgPrint("IFIMETRICS.fwdMacLineGap        = %d\n", pIFI->fwdMacLineGap);
        DbgPrint("IFIMETRICS.fwdTypoAscender      = %d\n", pIFI->fwdTypoAscender);
        DbgPrint("IFIMETRICS.fwdTypoDescender     = %d\n", pIFI->fwdTypoDescender);
        DbgPrint("IFIMETRICS.fwdTypoLineGap       = %d\n", pIFI->fwdTypoLineGap);
        DbgPrint("IFIMETRICS.fwdAveCharWidth      = %d\n", pIFI->fwdAveCharWidth);
        DbgPrint("IFIMETRICS.fwdMaxCharInc        = %d\n", pIFI->fwdMaxCharInc);
        DbgPrint("IFIMETRICS.fwdCapHeight         = %d\n", pIFI->fwdCapHeight);
        DbgPrint("IFIMETRICS.fwdXHeight           = %d\n", pIFI->fwdXHeight);
        DbgPrint("IFIMETRICS.fwdSubscriptXSize    = %d\n", pIFI->fwdSubscriptXSize);
        DbgPrint("IFIMETRICS.fwdSubscriptYSize    = %d\n", pIFI->fwdSubscriptYSize);
        DbgPrint("IFIMETRICS.fwdSubscriptXOffset  = %d\n", pIFI->fwdSubscriptXOffset);
        DbgPrint("IFIMETRICS.fwdSubscriptYOffset  = %d\n", pIFI->fwdSubscriptYOffset);
        DbgPrint("IFIMETRICS.fwdSuperscriptXSize  = %d\n", pIFI->fwdSuperscriptXSize);
        DbgPrint("IFIMETRICS.fwdSuperscriptYSize  = %d\n", pIFI->fwdSuperscriptYSize);
        DbgPrint("IFIMETRICS.fwdSuperscriptXOffset= %d\n", pIFI->fwdSuperscriptXOffset);
        DbgPrint("IFIMETRICS.fwdSuperscriptYOffset= %d\n", pIFI->fwdSuperscriptYOffset);
        DbgPrint("IFIMETRICS.fwdUnderscoreSize    = %d\n", pIFI->fwdUnderscoreSize);
        DbgPrint("IFIMETRICS.fwdUnderscorePosition= %d\n", pIFI->fwdUnderscorePosition);
        DbgPrint("IFIMETRICS.fwdStrikeoutSize     = %d\n", pIFI->fwdStrikeoutSize);
        DbgPrint("IFIMETRICS.fwdStrikeoutPosition = %d\n", pIFI->fwdStrikeoutPosition);
        DbgPrint("IFIMETRICS.chFirstChar          = %-#4x\n", (int) (BYTE) pIFI->chFirstChar);
        DbgPrint("IFIMETRICS.chLastChar           = %-#4x\n", (int) (BYTE) pIFI->chLastChar);
        DbgPrint("IFIMETRICS.chDefaultChar        = %-#4x\n", (int) (BYTE) pIFI->chDefaultChar);
        DbgPrint("IFIMETRICS.chBreakChar          = %-#4x\n", (int) (BYTE) pIFI->chBreakChar);
        DbgPrint("IFIMETRICS.wcFirsChar           = %-#6x\n", pIFI->wcFirstChar);
        DbgPrint("IFIMETRICS.wcLastChar           = %-#6x\n", pIFI->wcLastChar);
        DbgPrint("IFIMETRICS.wcDefaultChar        = %-#6x\n", pIFI->wcDefaultChar);
        DbgPrint("IFIMETRICS.wcBreakChar          = %-#6x\n", pIFI->wcBreakChar);
        DbgPrint("IFIMETRICS.ptlBaseline          = {%d,%d}\n", pIFI->ptlBaseline.x, pIFI->ptlBaseline.y);
        DbgPrint("IFIMETRICS.ptlAspect            = {%d,%d}\n", pIFI->ptlAspect.x,pIFI->ptlAspect.y );
        DbgPrint("IFIMETRICS.ptlCaret             = {%d,%d}\n", pIFI->ptlCaret.x,pIFI->ptlCaret.y );
        DbgPrint("IFIMETRICS.rclFontBox           = {%d,%d,%d,%d}\n",
                                                  pIFI->rclFontBox.left,
                                                  pIFI->rclFontBox.top,
                                                  pIFI->rclFontBox.right,
                                                  pIFI->rclFontBox.bottom);
        DbgPrint("IFIMETRICS.achVendId            = \"%c%c%c%c\"\n",
                                                   pIFI->achVendId[0] ,
                                                   pIFI->achVendId[1],
                                                   pIFI->achVendId[2],
                                                   pIFI->achVendId[3] );
        DbgPrint("IFIMETRICS.cKerningPairs        = %d\n", pIFI->cKerningPairs);
        DbgPrint("IFIMETRICS.ulPanoseCulture      = %-#8lx\n", pIFI->ulPanoseCulture);
        DbgPrint("\n");
    }

}


VOID
VPrintString(
    STROBJ     *pstro
    )
{
    if ( gdwDebugFont & DBG_TEXTSTRING )
    {
        #define MAXTXTBUFSIZE     81

        WCHAR       awchBuf[MAXTXTBUFSIZE];
        ULONG       cGlyphsPrinted;

        cGlyphsPrinted = min(pstro->cGlyphs,MAXTXTBUFSIZE-1);
        wcsncpy( awchBuf, pstro->pwszOrg,cGlyphsPrinted);
        awchBuf[cGlyphsPrinted] = NUL;
        DbgPrint("\nTextOut cGlyphs = %d. First %d chars are:\n",
                pstro->cGlyphs,cGlyphsPrinted);
        DbgPrint("%ws\n",awchBuf);

        #undef MAXTXTBUFSIZE
    }
}
#undef PUBLIC_GDWDEBUGFONT //Only in this file.
#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmfnprot.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmfnprot.h

Abstract:

    Font module main Function prototype header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    11/18/96 -ganeshp-
        Created it.

    dd-mm-yy -author-
        description

--*/


#ifndef _FMFNPROT_H
#define _FMFNPROT_H

//
// Interface functions
//

//
// Defined in fmtxtout.c
//

BOOL
FMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

BOOL
BPlayWhiteText(
    PDEV  *pPDev
    );

//
// GlyphOut function Prototype
//
typedef BOOL
(*pfnBOutputGlyph)(
    PDEV      *pPDev,
    HGLYPH    hg,
    FONTMAP   *pFM,
    INT       iXIn
    );


//
// Defined in fontddi.c
//
BOOL
FMResetPDEV(
    PDEV  *pPDevOld,
    PDEV  *pPDevNew
    );


VOID
FMDisablePDEV(
    PDEV *pPDev
    );

VOID
FMDisableSurface(
    PDEV *pPDev
    );

BOOL
FMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    );

BOOL
FMStartPage(
    SURFOBJ *pso
    );

BOOL
FMSendPage(
    SURFOBJ *pso
    );

BOOL
FMEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    );

BOOL
FMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL
FMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    );

BOOL
FMEnableSurface(
    PDEV *pPDev
    );


//
// Defined in intrface.c
//

BOOL
BInitDeviceFontsFromGPD(
    PDEV    *pPDev
    );

BOOL
BInitFontPDev(
    PDEV    *pPDev
    );

INT
IGetMaxFonts(
    PDEV    *pPDev
    );

BOOL
BBuildFontCartTable(
    PDEV    *pPDev
    );

BOOL
BRegReadFontCarts(
PDEV        *pPDev
    ) ;

BOOL
BBuildFontMapTable(
    PDEV     *pPDev
    ) ;

VOID
VSetFontID(
    DWORD   *pdwOut,
    PFONTLIST pFontList
    );


VOID
VLogFont(
    POINT    *pptGrxRes,
    LOGFONT  *pLF,
    FONTMAP  *pFM
);

BOOL
BInitTextFlags(
    PDEV    *pPDev
    );

BOOL
BInitGDIInfo(
    GDIINFO  *pGDIInfo,
    PDEV     *pPDev
    );

//
// Defined in fminit.c
//

INT
IInitDeviceFonts(
    PDEV    *pPDev
    );

BOOL
BFillinDeviceFM(
    PDEV       *pPDev,
    FONTMAP    *pfm,
    int         iIndex
    );


BOOL
BGetOldFontInfo(
    FONTMAP   *pfm,
    BYTE      *pRes
    );

BOOL
BFMSetupXF(
    FONTMAP   *pfm,
    PDEV      *pPDev,
    INT        iIndex
    );

BOOL
BIFIScale(
    FONTMAP   *pfm,
    INT       xdpi,
    INT       ydpi
    );

VOID
VFillinGlyphData(
    PDEV      *pPDev,
    FONTMAP   *pfm
    );

BOOL
BGetNewFontInfo(
    FONTMAP   *pfm,
    BYTE      *pRes
    );

PUNI_GLYPHSETDATA
PNTGTT1To1(
    IN DWORD dwCodepage,
    IN BOOL  bSymbolCharSet,
    IN INT   iFirst,
    IN INT   iLast
    );

NT_RLE  *
PNTRLE1To1(
    IN BOOL  bSymbolCharSet,
    int      iFirst,
    int      iLast
    );

//
// Defined in  fileio.c
//
HANDLE
DrvOpenFile
(
    PWSTR pwstrFileName,
    PDEV   *pPDEV
);

BOOL
DrvReadFile
(
    HANDLE   hFile,
    LPVOID   lpBuffer,
    DWORD    nNumBytesToRead,
    LPDWORD  lpNumBytesRead,
    PDEV     *pPDev
);

DWORD
DrvSetFilePointer
(
    HANDLE   hFile,
    LONG     iDistanceToMove,
    DWORD    dwMoveMethod,
    PDEV     *pPDev
);


BOOL
DrvCloseFile
(
    HANDLE   hFile,
    PDEV    *pPDEV
);

//
// Defined in fontread.c
//

INT
IFIOpenRead(
    FI_MEM  *pFIMem,
    PWSTR    pwstrName,
    PDEV    *pPDev
    );

BOOL
BFINextRead(
    FI_MEM   *pFIMem
    ) ;

int
IFIRewind(
    FI_MEM   *pFIMem
    );

BOOL
BFICloseRead(
    FI_MEM  *pFIMem,
    PDEV    *pPDev
    );

//
// Defined in xtrafont.c
//

int
IXtraFonts(
PDEV    *pPDev
    );

BOOL
BGetXFont(
    PDEV  *pPDev,
    int    iIndex
    );

void
VXFRewind(
    PDEV   *pPDev
    );


//
// Defined in FontFree.c
//

VOID
VFontFreeMem(
    PDEV   *pPDev
    );

//
// Defined in posnsort.c
//
BOOL
BCreatePS(
    PDEV  *pPDev
    );

VOID
VFreePS(
    PDEV  *pPDev
    );

BOOL
BAddPS(
    PSHEAD  *pPSH,
    PSGLYPH *pPSGIn,
    INT      iyVal,
    INT      iyMax
    );

INT
ISelYValPS(
    PSHEAD  *pPSH,
    int     iyVal
    );

PSGLYPH  *
PSGGetNextPSG(
    PSHEAD  *pPSH
    );

//
// Defined in download.c
//

BOOL
BSendDLFont(
    PDEV     *pPDev,
    FONTMAP  *pFM
    );

INT
IDownloadFont(
    TO_DATA  *ptod,
    STROBJ   *pstro,
    INT      *piRot
    );

INT
IHG2Index(
    TO_DATA   *pTOD
    );

DWORD
DwGetTTGlyphWidth(
    FONTPDEV *pFontPDev,
    FONTOBJ  *pfo,
    HGLYPH    hGlyph);

//
// Defined in dloadpcl.c
//
DWORD
DwDLPCLHeader(
    PDEV        *pPDev,
    IFIMETRICS  *pifi,
    int         id
    );

INT
IDLGlyph(
    PDEV        *pPDev,
    int         iIndex,
    GLYPHDATA   *pgd,
    DWORD       *pdwMem
    );

//
// Defined in qeryfont.c
//
PIFIMETRICS
FMQueryFont(
    PDEV    *pPDev,
    ULONG_PTR   iFile,
    ULONG   iFace,
    ULONG_PTR *pid
    );

ULONG
FMGetGlyphMode(
    PDEV    *pPDev,
    FONTOBJ *pfo
    );

LONG
FMQueryFontData(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA   *pgd,
    PVOID       pv,
    ULONG       cjSize
    );


//
// Defined in qfontdat.c
//
PVOID
FMQueryFontTree(
    PDEV    *pPDev,
    ULONG_PTR iFile,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    );

VOID  *
PVGetUCGlyphSetData(
    PDEV   *pPDev,
    UINT    iFace
    );

VOID  *
PVGetUCRLE(
    PDEV   *pPDev,
    FONTMAP   *pFM
    );

VOID  *
PVGetUCFD_GLYPHSET(
    PDEV   *pPDev,
    FONTMAP   *pFM
    );

VOID  *
PVGetUCKernPairData(
    PDEV   *pPDev,
    UINT    iFace
    );

VOID  *
PVUCKernPair(
    PDEV   *pPDev,
    FONTMAP   *pFM
    );

//
// Defined in fntmanag.c
//
ULONG
FMFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    );

//
// Defined in qadvwdth.c
//
BOOL
FMQueryAdvanceWidths(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH *phg,
    PVOID  *pvWidths,
    ULONG   cGlyphs
    );

//
// Defined in fonts.c
//
FONTMAP *
PfmGetIt(
    PDEV *pPDev,
    INT   iIndex);

FONTMAP *
PfmGetDevicePFM(
    PDEV *pPDev,
    INT   iIndex);

FONTMAP *
PfmGetDevicePFM(
    PDEV   *pPDev,
    INT     iIndex
    );

BOOL
BNewFont(
    PDEV    *pPDev,
    INT      iNewFont,
    PFONTMAP pfm,
    DWORD    dwFontAttrib
    );

BOOL
BGetPSize(
    FONTPDEV    *pFontPDev,
    POINTL      *pptl,
    FWORD        fwdUnitsPerEm,
    FWORD        fwdAveCharWidth
    );


BOOL
BSelectFont(
    PDEV     *pPDev,
    FONTMAP  *pFM,
    POINTL   *pptl
    );

BOOL BSelScalableFont(
    PDEV    *pPDev,
    POINTL  *pptl,
    FONTMAP *pFM
    );

INT
IFont100toStr(
    BYTE   *pjOut,
    int     iBufSize,
    int     iVal
    );

INT
ISetScale(
    FONTCTL     *pctl,
    XFORMOBJ    *pxo,
    BOOL        bIntellifont,
    BOOL        bAnyRotation
);

VOID
VSetRotation(
    FONTPDEV    *pFontPDev,
    int        iRot
    );

INT
IGetGlyphWidth(
    PDEV    *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    );

LONG
LMulFloatLong(
    PFLOATOBJ pfo,
    LONG l);

INT
IGetUFMGlyphWidth(
    PDEV     *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    );

INT
IGetUFMGlyphWidthJr(
    POINT    *pptGrxRes,
    FONTMAP  *pFM,
    HGLYPH     hg
    );

VOID
VSetCursor(
    IN  PDEV   *pPDev,
    IN  INT     iX,
    IN  INT     iY,
    IN  WORD    wMoveType,
    OUT POINTL *pptlRem
    );

//
// ttdload.c  !!!TODO
//

BOOL BGetTTPointSize(
    PDEV    *pPDev,
    POINTL  *pptl,
    FONTMAP *pfm
    );

BOOL BTTSelScalableFont(
    PDEV    *pPDev,
    POINTL  *pptl,
    FONTMAP *pfm
    );

BOOL
BSetFontAttrib(
    PDEV  *pPDev,
    DWORD  dwPrevAttrib,
    DWORD  dwAttrib,
    BOOL   bReset);

BOOL
BGetStockGlyphset(
    IN  PDEV    *pPDev,
    OUT VOID  **ppvFDGlyphset,
    IN  SHORT   sResID);


HGLYPH
HDefaultGH(
    PFONTMAP pfm);

BOOL
BUpdateStandardVar(
    PDEV    *pPDev,
    PFONTMAP pFontMap,
    INT      iGlyphIndex,
    DWORD    dwFontAtt,
    DWORD    dwFlags);

#define STD_ALL         0x00000FFF
#define STD_STD         0x0000007F
#define STD_TT          0x00000380
#define STD_GL          0x00000001
#define STD_FH          0x00000002
#define STD_FW          0x00000004
#define STD_FB          0x00000008
#define STD_FI          0x00000010
#define STD_FU          0x00000020
#define STD_FS          0x00000040
#define STD_NFID        0x00000080
#define STD_CFID        0x00000100
#define STD_PRND        0x00000200

//
// oldfonts.c
//

BOOL
BRLEOutputGlyph(
    TO_DATA *pTod
    );

BOOL
BRLESelectFont(
    PDEV     *pPDev,
    PFONTMAP  pFM,
    POINTL   *pptl);

BOOL
BRLEDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM);


INT
IGetIFIGlyphWidth(
    PDEV    *pPDev,
    FONTMAP *pFM,
    HGLYPH   hg);

BOOL
BSelectNonScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

BOOL
BSelectPCLScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

BOOL
BSelectCapslScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

BOOL
BSelectPPDSScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl);

//
// newfonts.c
//
BOOL
BGTTOutputGlyph(
    TO_DATA *pTod);

BOOL
BGTTSelectFont(
    PDEV     *pPDev,
    PFONTMAP  pFM,
    POINTL   *pptl);

BOOL
BGTTDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM);

//
// fmcallbk.c
//
DWORD
DwOutputGlyphCallback(
    TO_DATA *pTod);

BOOL
BSelectFontCallback(
    PDEV     *pdev,
    PFONTMAP  pFM,
    POINTL   *pptl);

BOOL
BDeselectFontCallback(
    PDEV     *pdev,
    PFONTMAP pFM);

PFONTMAP
PfmInitPFMOEMCallback(
    PDEV    *pPDev,
    FONTOBJ *pfo);

//
// Inerface functions for FontMap initialization.
//

//
// Defined in bmpdload.c
//
FONTMAP *
InitPFMTTBitmap(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    );

//
// Defined in truetype.c
//
FONTMAP *
InitPFMTTOutline(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    );

BOOL
bTTSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
        IN POINTL *pptl
        );

BOOL
bTTDeSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
        );

DWORD
dwTTDownloadFontHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    );

DWORD
dwTTDownloadGlyph(
    IN PDEV     *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH   hGlyph,
    WORD        wDLGlyphId,
    WORD        *pwWidth
    );

DWORD
dwTTGlyphOut(
    TO_DATA *pTod
    );

BOOL
bTTCheckCondition(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pstro,
    IFIMETRICS  *pifi
    );

BOOL
bTTFreeMem(
    IN OUT PFONTMAP pFM
    );

//
// dlutils.c
//

PDLGLYPH
PDLGHashGlyph (
    DL_MAP     *pDL,
    HGLYPH      hTTGlyph
    );
VOID
VFreeDLMAP (
    DL_MAP   *pdm
    );

VOID
VFreeDL(
    PDEV  *pPDev
    );

DL_MAP *
PGetDLMap (
    PFONTPDEV       pFontPDev,
    FONTOBJ         *pfo
    );

BOOL
BInitDLMap (
    PDEV            *pPDev,
    FONTOBJ         *pfo,
    DL_MAP          *pdm
    );

INT
IGetDL_ID(
    PDEV * );

DL_MAP *
PGetDLMapFromIdx (
    PFONTPDEV   pFontPDev,
    INT         iFontIndex
    ) ;

BOOL
BPrintADLGlyph(
    PDEV        *pPDev,
    TO_DATA     *pTod,
    PDLGLYPH    pdlGlyph
    );

//
// TrueTypeBMP module interface prototype. bmpdload.c
//

BOOL
BFreeTrueTypeBMPPFM(
    PFONTMAP pfm
    );

BOOL
BCheckCondTrueTypeBMP(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pso,
    IFIMETRICS  *pifi
    );

BOOL
BSelectTrueTypeBMP(
    PDEV        *pPDev,
    PFONTMAP    pFM,
    POINTL*     pptl
    );

BOOL
BDeselectTrueTypeBMP(
    PDEV            *pPDev,
    FONTMAP         *pfm
    );

DWORD
DwTrueTypeBMPGlyphOut(
    TO_DATA *pTod
    );

DWORD
DwDLTrueTypeBMPHeader(
    PDEV     *pPDev,
    PFONTMAP pFM
    );

DWORD
DwDLTrueTypeBMPGlyph(
    PDEV            *pPDev,
    PFONTMAP        pFM,
    HGLYPH          hGlyph,
    WORD            wDLGlyphId,
    WORD            *pwWidth
    );
#endif  // !_FMFNPROT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmdebug.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmdebug.h

Abstract:

    Font module Debugging header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _FMDEBUG_H
#define _FMDEBUG_H

#if DBG

#ifdef PUBLIC_GDWDEBUGFONT
    DWORD gdwDebugFont;
#else
    extern DWORD gdwDebugFont;

#endif //PUBLIC_GDWDEBUGFONT

/* Debugging Macroes */
#define IFTRACE(b, xxx)          {if((b)) {VERBOSE((xxx));}}
#define PRINTVAL( Val, format)   {\
            if (gdwDebugFont == DBG_TRACE) \
                DbgPrint("Value of "#Val " is "#format "\n",Val );\
            }

#define TRACE( Val )             {\
            if (gdwDebugFont == DBG_TRACE) \
                DbgPrint(#Val"\n");\
            }

#define DBGP(x)             DbgPrint x

/* Debugging Flags */
#define DBG_FD_GLYPHSET      0x00000001 /* To Dump the FD_GLYPHSET of a font */
#define DBG_UNI_GLYPHSETDATA 0x00000002 /* To Dump the UNI_GLYPHSET of a font */
#define DBG_FONTMAP          0x00000004 /* To Dump the FONTMAP of a font */
#define DBG_TRACE            0x00000008 /* To TRACE */
#define DBG_IFIMETRICS       0x00000010 /* To Dump the IFIMETRICS of a font */
#define DBG_TEXTSTRING       0x00000020 /* To Dump the Input Text string */

/* Debugging Helper Function prototypes. Always use the Macro version of
 * the Call.This will make sure that no extra code is compiled in retail build.
 */

VOID
VDbgDumpUCGlyphData(
    FONTMAP   *pFM
    );

VOID
VDbgDumpGTT(
     PUNI_GLYPHSETDATA pGly);

VOID
VDbgDumpFONTMAP(
    FONTMAP *pFM);

VOID
VDbgDumpIFIMETRICS(
    IFIMETRICS *pFM);

VOID
VPrintString(
    STROBJ     *pstro
    );

/* Function Macroes */
#define VDBGDUMPUCGLYPHDATA(pFM)    VDbgDumpUCGlyphData(pFM)
#define VDBGDUMPGTT(pGly)           VDbgDumpGTT(pGly)
#define VDBGDUMPFONTMAP(pFM)        VDbgDumpFONTMAP(pFM)
#define VDBGDUMPIFIMETRICS(pIFI)    VDbgDumpIFIMETRICS(pIFI)
#define VPRINTSTRING(pstro)         VPrintString(pstro)



#else  //!DBG Retail Build

/* Debugging Macroes */
#define IFTRACE(b, xxx)
#define PRINTVAL( Val, format)
#define TRACE( Val )
#define DBGP(x)            DBGP

/* Function Macroes */
#define VDBGDUMPUCGLYPHDATA(pFM)
#define VDBGDUMPGTT(pGly)
#define VDBGDUMPFONTMAP(pFM)
#define VDBGDUMPIFIMETRICS(pIFI)
#define VPRINTSTRING(pstro)

#endif //DBG

// Macroes for file lavel tracing. Define FILETRACE at the of the file
// before including font.h.

#if DBG

#ifdef FILETRACE

#define FTST( Val, format)  DbgPrint("[UniFont!FTST] Value of "#Val " is "#format "\n",Val );
#define FTRC( Val )         DbgPrint("[UniFont!FTRC] "#Val);\

#else  //FILETRACE

#define FTST( Val, format)
#define FTRC( Val )

#endif //FILETRACE

#else //DBG

#define FTST( Val, format)
#define FTRC( Val )

#endif //DBG

#endif  // !_FMDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmmacro.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

     fmmacro.h

Abstract:

    Font module main macro header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    11/18/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _FMMACRO_H
#define _FMMACRO_H

/* Debugging macroes specific to Font Module */

#if DBG    // Check Build

/* Error handling macroes */
#define ERREXIT(ErrString)       { ERR((ErrString));goto ErrorExit;}

#else  // Free Build

/* Error handling macroes */
#define ERREXIT(ErrString)     { goto ErrorExit;}

#endif // if DBG


/* Macroes */
#define ARF_IS_NULLSTRING(String)   ((String).dwCount == 0)
#define BUFFSIZE                    1024
#define PFDV                       ((PFONTPDEV)(pPDev->pFontPDev))
#define POINTEQUAL(pt1,pt2)         ((pt1.x == pt2.x) && (pt1.y == pt2.y))

#define VALID_FONTPDEV(pfontpdev) \
        ( (pfontpdev) && ((pfontpdev)->dwSignature == FONTPDEV_ID) )

#define MEMFREEANDRESET(ptr)  { if (ptr) MemFree( (LPSTR)ptr ); ptr = NULL; }
#define  SIZEOFDEVPFM()        (sizeof( FONTMAP ) + sizeof(FONTMAP_DEV))

#if 0
#define NO_ROTATION(xform)      (                                        \
                                  (FLOATOBJ_EqualLong(&(xform.eM12), 0) && \
                                   FLOATOBJ_EqualLong(&(xform.eM21), 0) ) || \
                                  (FLOATOBJ_EqualLong(&(xform.eM11), 0) && \
                                   FLOATOBJ_EqualLong(&(xform.eM22), 0) )\
                                )
#else
#define NO_ROTATION(xform)   ( \
        FLOATOBJ_EqualLong(&(xform.eM12), 0) && \
        FLOATOBJ_EqualLong(&(xform.eM21), 0)  && \
        FLOATOBJ_GreaterThanLong(&(xform.eM11),0) && \
        FLOATOBJ_GreaterThanLong(&(xform.eM22),0) \
                                )
#endif

#define GLYPH_IN_NEW_SOFTFONT(pFontPDev, pdm, pdlGlyph) \
                        (                              \
                        (pdm->wFlags & DLM_BOUNDED) && \
                        (pdm->wBaseDLFontid != pdm->wCurrFontId) && \
                        (pdlGlyph->wDLFontId != (WORD)(pFontPDev->ctl.iSoftFont)) \
                        )

#define     SET_CURSOR_FOR_EACH_GLYPH(flAccel)    \
                        (                       \
                        (!(flAccel & SO_FLAG_DEFAULT_PLACEMENT)) ||  \
                        ( flAccel & SO_VERTICAL )                ||  \
                        ( flAccel & SO_REVERSED )                    \
                        )

#define     SET_CURSOR_POS(pPDev,pgp,flAccel) \
                        if (!(flAccel & SO_FLAG_DEFAULT_PLACEMENT)) \
                           XMoveTo(pPDev, pgp->ptl.x, MV_GRAPHICS|MV_FINE)

//
// Cursor Move type
//

#define     MOVE_RELATIVE       0x0001
#define     MOVE_ABSOLUTE       0x0002
#define     MOVE_UPDATE         0x0004


/* Defines for Floating point numbers */

#if defined(_X86_) && !defined(USERMODE_DRIVER)

#define FLOATL_0_0      0               // 0.0 in IEEE floating point format
#define FLOATL_00_001M  0xAE000000      // -00.000976625f
#define FLOATL_00_001   0x2E000000      // 00.000976625f
#define FLOATL_00_005   0x3ba3d70a      // 00.005f
#define FLOATL_00_005M  0xbba3d70a      // -00.005f
#define FLOATL_00_50    0x3F000000      // 00.50f in IEEE floating point format
#define FLOATL_00_90    0x3f666666      // 00.90f in IEEE floating point format
#define FLOATL_1_0      0x3F800000      // 1.0f in IEEE floating point format
#define FLOATL_1_0M     0xBF800000      // -1.0f in IEEE floating point format
#define FLOATL_72_00    0x42900000      // 72.00f in IEEE floating point format
#define FLOATL_72_31    0x42909EB8      // 72.31f in IEEE floating point format

#define FLOATL_PI      0x40490fdb      // 3.14159265358979f

#else //RISC

#define FLOATL_0_0      0.0f
#define FLOATL_00_001M  -0.001f
#define FLOATL_00_001   0.001f
#define FLOATL_00_005M  -0.005f
#define FLOATL_00_005   0.005f
#define FLOATL_00_50    0.5f
#define FLOATL_00_90    0.9f
#define FLOATL_1_0      1.0f
#define FLOATL_1_0M     -1.0f
#define FLOATL_72_00    72.00f
#define FLOATL_72_31    72.31f

#define FLOATL_PI      3.14159265358979f
#endif _X86_

#define SYMBOL_START 0xf020
#define SYMBOL_END   0xf0ff
#define NUM_OF_SYMBOL SYMBOL_END - SYMBOL_START + 1

#define EURO_CUR_SYMBOL 0x20ac

#define IS_SYMBOL_CHARSET(pfm) (pfm->pIFIMet->jWinCharSet == 0x02)

BOOL
NONSQUARE_FONT(
    PXFORML pxform);

#endif  // !_FMMACRO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmtxtout.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    textout.c

Abstract:

    The FMTextOut() function - the call used to output Text.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/16/97 -ganeshp-
        Created

--*/

//
//This line should be before the line including font.h.
//Comment out this line to disable FTRC and FTST macroes.
//
//#define FILETRACE

#include "font.h"

/*
 *   Some clipping constants.  With a complex clip region,  it is desirable
 *  to avoid enumerating the clip rectangles more than once.  To do so,
 *  we have a bit array, with each bit being set if the glyph is inside
 *  the clipping region,  cleared if not.  This allows us to obtain a
 *  set of glyphs,  then determine whether they are printed when the clip
 *  rectangles are enumerated.   Finally,  use the bit array to stop
 *  printing any glyphs outside the clip region.  This is slightly heavy
 *  handed for the simple case.
 */

#define RECT_LIMIT        100    // Clipping rectangle max

#define DC_TC_BLACK     0       /* Fixed Text Colors in 4 bit mode */
#define DC_TC_MAX       8       /* used for 16 colour palette wrap around */

#define CMD_TC_FIRST    CMD_SELECTBLACKCOLOR

// For Dithered Color BRUSHOBJ.iSolidColor is -1.
#define DITHERED_COLOR   -1

//Various TextOut specific flags.
#define    TXTOUT_CACHED        0x00000001 // Text is cached and printed after graphics.
#define    TXTOUT_SETPOS        0x00000002 // True if cursor position to be set.
#define    TXTOUT_FGCOLOR       0x00000004 // Device can paint the text.
#define    TXTOUT_COLORBK       0x00000008 // For z-ordering fixes
#define    TXTOUT_NOTROTATED    0x00000010 // Set if Text is not rotated.
#define    TXTOUT_PRINTASGRX    0x00000020 // Set if Text should be printed as
                                           // Graphics.
#define    TXTOUT_DMS           0x00000040 // Set if Device Managed surface
#define    TXTOUT_90_ROTATION   0x00000080 // Set if font is 90-rotated.

#define     DEVICE_FONT(pfo, tod) ( (pfo->flFontType & DEVICE_FONTTYPE) || \
                                    (tod.iSubstFace) )

#define ERROR_PER_GLYPH_POS     3
#define ERROR_PER_ENUMERATION   15
#define EROOR_PER_GLYPHRECT     5  // For Adjusting height of the glyph rect.


/*  NOTE:  this must be the same as the winddi.h ENUMRECT */
typedef  struct
{
   ULONG    c;                  /* Number of rectangles returned */
   RECTL    arcl[ RECT_LIMIT ]; /* Rectangles supplied */
} MY_ENUMRECTS;

/*
 *   Local function prototypes.
 */
VOID
SelectTextColor(
    PDEV      *pPDev,
    PVOID     pvColor
    );

VOID
VClipIt(
    BYTE     *pbClipBits,
    TO_DATA  *ptod,
    CLIPOBJ  *pco,
    STROBJ   *pstro,
    int       cGlyphs,
    int       iRot,
    BOOL      bPartialClipOn
    );

BOOL
BPSGlyphOut(
    register  TO_DATA  *pTOD
    );

BOOL
BRealGlyphOut(
    register  TO_DATA  *pTOD
    );

BOOL
BWhiteText(
    TO_DATA  *pTOD
    );

BOOL
BDLGlyphOut(
    TO_DATA   *pTOD
    );

VOID
VCopyAlign(
    BYTE  *pjDest,
    BYTE  *pjSrc,
    int    cx,
    int    cy
    );

INT
ISubstituteFace(
    PDEV    *pPDev,
    FONTOBJ *pfo);

HGLYPH
HWideCharToGlyphHandle(
    PDEV    *pPDev,
    FONTMAP *pFM,
    WCHAR    wchOrg);

PHGLYPH
PhAllCharsPrintable(
    PDEV  *pPDev,
    INT    iSubst,
    ULONG  ulGlyphs,
    PWCHAR pwchUnicode);

BOOL
BGetStartGlyphandCount(
    BYTE  *pbClipBits,
    DWORD dwEndIndex,
    DWORD *pdwStartIndex,
    DWORD *pdwGlyphToPrint);

BOOL
BPrintTextAsGraphics(
    PDEV        *pPDev,
    ULONG       iSolidColor,
    DWORD       dwForeColor,
    DWORD       dwFlags,
    INT         iSubstFace
    );


BOOL
FMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    )
/*++
Routine Description:

    The call to use for output of text.  Our behaviour depends
    upon the type of printer.  Page printers (e.g. LaserJets) do
    whatever is required to send the relevant commands to the printer
    during this call.  Otherwise (typified by dot matrix printers),
    we store the data about the glyph so that we can output the
    characters as we are rendering the bitmap.  This allows the output
    to be printed unidirectionally DOWN the page.

Arguments:

    pso;            Surface to be drawn on
    pstro;          The "string" to be produced
    pfo;            The font to use
    pco;            Clipping region to limit output
    prclExtra;      Underline/strikethrough rectangles
    prclOpaque;     Opaquing rectangle
    pboFore;        Foreground brush object
    pboOpaque;      Opaqueing brush
    pptlBrushOrg;   Brush origin for both above brushes
    mix;            The mix mode


Return Value:

    TRUE for success and FALSE for failure.FALSE logs the error.

Note:

    1/16/1997 -ganeshp-
        Created it.
--*/

{
    PDEV        *pPDev;            // Our main PDEV
    FONTPDEV    *pFontPDev;        // FONTMODULE based PDEV
    FONTMAP     *pfm;              // Font's details
    GLYPHPOS    *pgp, *pgpTmp;     // Value passed from gre
    XFORMOBJ    *pxo;              // The transform of interest
    FLOATOBJ_XFORM xform;
    TO_DATA      tod;              // Our convenience
    RECTL        rclRegion;        // For z-ordering fixes
    HGLYPH      *phSubstGlyphOrg, *phSubstGlyph;
    POINTL       ptlRem;

    BOOL       (*pfnDrawGlyph)( TO_DATA * );  // How to produce the glyph
    PFN_OEMTextOutAsBitmap pfnOEMTextOutAsBitmap = NULL;

    I_UNIFONTOBJ UFObj;

    ULONG      iSolidColor;

    DWORD      dwGlyphToPrint, dwTotalGlyph, dwPGPStartIndex, dwFlags;
    DWORD      dwForeColor;

    INT        iyAdjust;           // Adjust for printing position WRT baseline
    INT        iXInc, iYInc;       // Glyph to glyph movement, if needed
    INT        iRot;               // The rotation factor
    INT        iI, iJ, iStartIndex;

    WCHAR     *pwchUnicode;

    BYTE      *pbClipBits;         // For clip limits
    BYTE       ubMask;

    BOOL       bMore;              // Getting glyphs from engine loop
    BOOL       bRet = FALSE;       // Return Value.

    //
    // First step is to extract the PDEV address from the surface.
    // Then we can get to all the other bits & pieces that we need.
    // We should also initialize the TO_DATA as much as possible.
    //

    pPDev = (PDEV *) pso->dhpdev;
    if( !(VALID_PDEV(pPDev)) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ERR(( "Invalid or NULL PDEV\n" ))

        return  FALSE;
    }

    //
    //  Quick check on abort - should we return failure NOW
    //
    if( pPDev->fMode & PF_ABORTED )
        return  FALSE;

    //
    // Misc initialization
    //

    dwFlags             = 0;
    iRot                = 0;
    pgp                 =
    pgpTmp              = NULL;
    pfm                 = NULL;
    pbClipBits          = NULL;
    phSubstGlyphOrg     = NULL;

    //
    // Initialize TO_DATA
    //
    ZeroMemory(&tod, sizeof(TO_DATA));
    tod.pPDev  = pPDev;
    tod.pfo    = pfo;
    tod.flAccel= pstro->flAccel;

    pFontPDev = pPDev->pFontPDev;           // The important stuff

    //
    // Initialize TT file pointer to NULL to avoid caching. TT File pointer
    // should be initialized per DrvTextOut. Also initialize the TOD pointer.
    // This is needed by download routines, which have access to PDEV only.
    //

    pFontPDev->pTTFile = NULL;
    pFontPDev->pcjTTFile = 0;
    pFontPDev->ptod = &tod;

    pFontPDev->pso = pso;  // SURFOBJ changes every call - so reset
    pFontPDev->pIFI = FONTOBJ_pifi(pfo);

    if( pPDev->dwFreeMem && (pFontPDev->flFlags & FDV_TRACK_FONT_MEM) )
        pFontPDev->dwFontMem = pPDev->dwFreeMem;

    iSolidColor = pboFore->iSolidColor;     // Local Copy.
    dwForeColor = BRUSHOBJ_ulGetBrushColor(pboFore);

    //
    //
    // Flag Initialization
    //
    //
    // Check if the printer can set the foreground color.This is necessary
    // to support grey or dithered device fonts.
    //
    if (pFontPDev->flFlags & FDV_SUPPORTS_FGCOLOR)
        dwFlags |= TXTOUT_FGCOLOR;

    if (DRIVER_DEVICEMANAGED (pPDev))
        dwFlags |= TXTOUT_DMS;

    //
    // Device managed surface has to send White text when it's received.Also
    // we don't need to do any Z-order specific checking.
    //

    if (!(dwFlags & TXTOUT_DMS))
    {
        BOOL bIsRegionW;

        //
        // Get rectangle for background checking - z-ordering fix
        //

        if ( !BIntersectRect(&rclRegion, &(pstro->rclBkGround),&(pco->rclBounds)))
            return TRUE;

        bIsRegionW = bIsRegionWhite(pso, &rclRegion);
        
#ifndef DISABLE_NEWRULES        
        // 
        // if there is an opaque background or the text color is not black, we
        // need to test whether the text overlaps the rules array
        //
        if (bIsRegionW && pPDev->pbRulesArray && pPDev->dwRulesCount > 0)
        {
                PRECTL pTmpR = prclOpaque;
                if (!pTmpR && 
                    ((pso->iBitmapFormat == BMF_24BPP ||
                      iSolidColor != (ULONG)((PAL_DATA*)(pPDev->pPalData))->iBlackIndex) &&
                     (pso->iBitmapFormat != BMF_24BPP ||
                      iSolidColor != 0)))
                {
                    pTmpR = &rclRegion;
                }
                if (pTmpR)
                {
                    DWORD i;
                    for (i = 0;i < pPDev->dwRulesCount;i++)
                    {
                        PRECTL pTmp = &pPDev->pbRulesArray[i];
                        if (pTmp->right > pTmpR->left &&
                            pTmp->left < pTmpR->right &&
                            pTmp->bottom > pTmpR->top &&
                            pTmp->top < pTmpR->bottom)
                        {
                            bIsRegionW = FALSE;
                            break;
                        }
                    }
                }
        }
#endif        
        if (((ULONG)pFontPDev->iWhiteIndex == iSolidColor) && !bIsRegionW)
            dwFlags |= TXTOUT_CACHED;

        //
        // Z-ordering fix, check if we are not printing Text as graphics.
        //

        if (pFontPDev->flFlags & FDV_DLTT || pfo->flFontType & DEVICE_FONTTYPE)
        {
            //
            // If we are banding and this isn't a device font we want to
            // use EngTextOut if the textbox crosses a band boundary. This
            // is because the bIsRegionWhite test can't test the entire
            // region so it is invalid.
            //
            if ((pPDev->bBanding && !(pfo->flFontType & DEVICE_FONTTYPE) &&
                   (rclRegion.left != pstro->rclBkGround.left            ||
                    rclRegion.right != pstro->rclBkGround.right          ||
                    rclRegion.bottom != pstro->rclBkGround.bottom        ||
                    (rclRegion.top != pstro->rclBkGround.top             &&
                     pPDev->rcClipRgn.top != 0)))                        ||
                   !bIsRegionW)
            {
                dwFlags |= TXTOUT_COLORBK;
            }
        }
    }

    //
    // This is necessary because we map low intensity color to black
    // in palette management,
    // However, if we detect text and graphic overlapping, we map
    // low intensity color to white so it's visible over graphics
    //
    if ( pso->iBitmapFormat == BMF_4BPP &&
         dwFlags & TXTOUT_COLORBK)
    {
        if (pboFore->iSolidColor == 8)
        {
            iSolidColor = pFontPDev->iWhiteIndex;
            dwFlags |= TXTOUT_CACHED;
        }
    }

    //
    // Font substitution initialization
    //
    // Get iFace to substitute TrueType font with.
    // Note: pwszOrg is available only when SO_GLYPHINDEX_TEXTOUT is set
    //       in  pstro->flAccel.
    //       SO_DO_NOT_SUBSTITUTE_DEVICE_FONT also has to be checked for BI-DI
    //       fonts.
    //
    //  We should now get the transform.  This is only really needed
    //  for a scalable font OR a printer which can do font rotations
    //  relative to the graphics orientation (i.e. PCL5 printers!).
    //  It is easier just to get the transform all the time.
    //

    pxo = FONTOBJ_pxoGetXform( pfo );
    XFORMOBJ_iGetFloatObjXform(pxo, &xform);
    pFontPDev->pxform = &xform;


    if (NO_ROTATION(xform))
        dwFlags |= TXTOUT_NOTROTATED;

    if (pFontPDev->pIFI->flInfo & FM_INFO_90DEGREE_ROTATIONS)
        dwFlags |= TXTOUT_90_ROTATION;

    tod.iSubstFace = 0;
    tod.phGlyph    = NULL;
    pwchUnicode    = NULL;
    tod.cGlyphsToPrint = pstro->cGlyphs;

    if (!(pstro->flAccel & SO_GLYPHINDEX_TEXTOUT))
    {
        pwchUnicode = pstro->pwszOrg;
    }

    //
    // Conditions to substitute:
    // The Text is not supposed to be printed as graphics and
    // Device can substitute font and
    // Font is True Type   and
    // STROBJ flags have no conflict with substitution.
    //

    if ( (pfo->flFontType & TRUETYPE_FONTTYPE)      &&
         !(pstro->flAccel & ( SO_GLYPHINDEX_TEXTOUT  |
                             SO_DO_NOT_SUBSTITUTE_DEVICE_FONT)) )
    {
        INT iSubstFace;

        if ((iSubstFace = ISubstituteFace(pPDev, pfo)) &&
            (phSubstGlyphOrg = PhAllCharsPrintable(pPDev,
                                                iSubstFace,
                                                pstro->cGlyphs,
                                                pwchUnicode)))
        {
            tod.iSubstFace = iSubstFace;
        }
    }

    //
    // Check if Text should be printed as graphics or not.
    //
    if( BPrintTextAsGraphics(pPDev, iSolidColor, dwForeColor, dwFlags, tod.iSubstFace) )
    {
        dwFlags |= TXTOUT_PRINTASGRX;
        tod.iSubstFace = 0;
    }

    //
    // Initialize for OEM Callback function
    // ulFontID
    // dwFlags
    // pIFIMetrics
    // pfnGetInfo
    // pFontObj
    // pStrObj
    // pFontMap
    // pFontPDev
    // ptGrxRes
    // pGlyph
    //

    if(pPDev->pOemHookInfo || (pPDev->ePersonality == kPCLXL))
    {
        ZeroMemory(&UFObj, sizeof(I_UNIFONTOBJ));
        UFObj.pfnGetInfo  = UNIFONTOBJ_GetInfo;
        UFObj.pPDev       = pPDev;
        UFObj.pFontObj    = pfo;
        UFObj.pStrObj     = pstro;
        UFObj.ptGrxRes    = pPDev->ptGrxRes;
        UFObj.pIFIMetrics = pFontPDev->pIFI;

        if (tod.cGlyphsToPrint)
            UFObj.pGlyph  = MemAlloc(sizeof(DWORD) * tod.cGlyphsToPrint);

        if (pfo &&
            !(pfo->flFontType & DEVICE_FONTTYPE) )
        {
            PFN_OEMTTDownloadMethod pfnOEMTTDownloadMethod;


            if (tod.iSubstFace == 0 && 
                ( (pPDev->pOemHookInfo &&
                   (pfnOEMTTDownloadMethod = (PFN_OEMTTDownloadMethod)pPDev->pOemHookInfo[EP_OEMTTDownloadMethod].pfnHook))
                || (pPDev->ePersonality == kPCLXL))
               )
            {
                DWORD    dwRet = TTDOWNLOAD_DONTCARE;

                HANDLE_VECTORPROCS(pPDev, VMTTDownloadMethod, ((PDEVOBJ)pPDev,
                                                            (PUNIFONTOBJ)&UFObj,
                                                            &dwRet))
                else
                if(pPDev->pOemEntry)
                {
                    FIX_DEVOBJ(pPDev, EP_OEMTTDownloadMethod);

                    if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                    {
                            HRESULT  hr ;
                            hr = HComTTDownloadMethod((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                        &pPDev->devobj, (PUNIFONTOBJ)&UFObj, &dwRet);
                            if(SUCCEEDED(hr))
                                ;  //  cool !
                    }
                    else
                    {
                        dwRet = pfnOEMTTDownloadMethod(&pPDev->devobj,
                                               (PUNIFONTOBJ)&UFObj);
                    }
                }

                switch (dwRet)
                {
                case TTDOWNLOAD_GRAPHICS:
                case TTDOWNLOAD_DONTCARE:
                    dwFlags |= TXTOUT_PRINTASGRX;
                    break;
                    //
                    // A default is to download as bitmap.
                    //
                case TTDOWNLOAD_BITMAP:
                    UFObj.dwFlags |= UFOFLAG_TTDOWNLOAD_BITMAP | UFOFLAG_TTFONT;
                    break;
                case TTDOWNLOAD_TTOUTLINE:
                    UFObj.dwFlags |= UFOFLAG_TTDOWNLOAD_TTOUTLINE | UFOFLAG_TTFONT;
                    break;
                }
            }
        }

        pFontPDev->pUFObj = &UFObj;
    }
    else
    {
        pFontPDev->pUFObj = NULL;
    }

    pPDev->fMode |= PF_DOWNLOADED_TEXT;

    //
    // Get FONTMAP
    //

    //
    // Conditions to download:
    // Text should not be printed as graphics and
    // Font should be TRUETYPE and
    // It is not getting substituted.
    //

    if ( !(dwFlags & TXTOUT_PRINTASGRX)             &&
         (pfo->flFontType & TRUETYPE_FONTTYPE)      &&
         !tod.iSubstFace  )
    {

        //
        // This function sets pfm pointer and iFace in TO_DATA.
        //     tod.iFace
        //     tod.pfm
        //
        if (IDownloadFont(&tod, pstro, &iRot) >= 0)
        {
            pfm = tod.pfm;

            //
            // yAdj has to be added to tod.pgp->ptl.y
            //
            iyAdjust = pfm ? (int)(pfm->syAdj) : 0;
        }
        else
        {
            //
            // If the call fails call engine to draw.
            //

            pfm = NULL;
        }

    }

    if ( DEVICE_FONT(pfo, tod) ) // Device Font
    {
        if( pfo->iFace < 1 || (int)pfo->iFace > pPDev->iFonts )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            ERR(( "Invalid iFace (%ld) in DrvTextOut",pfo->iFace ));
            goto ErrorExit;
        }

        //
        //  Get the stuff we really need for this font
        //

        tod.iFace = pfo->iFace;

        pfm = PfmGetDevicePFM(pPDev, tod.iSubstFace?tod.iSubstFace:tod.iFace);

        if (tod.iSubstFace)
        {
            UFObj.dwFlags |= UFOFLAG_TTSUBSTITUTED;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOAveCharWidth = pFontPDev->pIFI->fwdAveCharWidth;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOMaxCharInc = pFontPDev->pIFI->fwdMaxCharInc;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOUnitsPerEm = pFontPDev->pIFI->fwdUnitsPerEm;
            ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOWinAscender = pFontPDev->pIFI->fwdWinAscender;
        }

        //
        // Deivce font PFM must be returned.
        //
        if (pfm == NULL)
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            ERR(( "Invalid iFace (%ld) in DrvTextOut",pfo->iFace ));
            goto ErrorExit;
        }

	//
	// Set the transform for Device fonts.For downloaded fonts we have already
	// set the transform in download code. Check also for HP Intellifont
	//
	if ( DEVICE_FONT(pfo, tod) )
	{
	    iRot = ISetScale( &pFontPDev->ctl,
			      pxo,
			      (( pfm->flFlags & FM_SCALABLE) &&
				 (((PFONTMAP_DEV)pfm->pSubFM)->wDevFontType ==
				 DF_TYPE_HPINTELLIFONT)),
			      (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

	}
    }

    tod.iRot = iRot;

    UFObj.pFontMap = pfm;
    UFObj.apdlGlyph = tod.apdlGlyph;
    UFObj.dwNumInGlyphTbl = pstro->cGlyphs;

    //
    // TO_DATA initialization
    //
    tod.pfm = pfm;
    if (tod.iSubstFace)
    {
        BOOL bT2Bold, bT2Italic;
        BOOL bDevBold, bDevItalic, bUnderline;

        bT2Bold = (pFontPDev->pIFI->fsSelection & FM_SEL_BOLD) ||
                  (pfo->flFontType & FO_SIM_BOLD);
        bT2Italic = (pFontPDev->pIFI->fsSelection & FM_SEL_ITALIC) ||
                    (pfo->flFontType & FO_SIM_ITALIC);

        bDevBold = (pfm->pIFIMet->fsSelection & FM_SEL_BOLD) ||
                   (pfm->pIFIMet->usWinWeight > FW_NORMAL);
        bDevItalic = (pfm->pIFIMet->fsSelection & FM_SEL_ITALIC) ||
                   (pfm->pIFIMet->lItalicAngle != 0);

        bUnderline = ((pFontPDev->flFlags & FDV_UNDERLINE) && prclExtra)?FONTATTR_UNDERLINE:0;

        tod.dwAttrFlags =
            ((bT2Bold && !bDevBold)?FONTATTR_BOLD:0) |
            ((bT2Italic && !bDevItalic)?FONTATTR_ITALIC:0) |
            (bUnderline?FONTATTR_UNDERLINE:0) |
            FONTATTR_SUBSTFONT;
    }
    else
        tod.dwAttrFlags =
            ( ((pfo->flFontType & FO_SIM_BOLD)?FONTATTR_BOLD:0)|
              ((pfo->flFontType & FO_SIM_ITALIC)?FONTATTR_ITALIC:0)|
              (((pFontPDev->flFlags & FDV_UNDERLINE) && prclExtra)?FONTATTR_UNDERLINE:0)
            );

    //
    // If DEVICE_FONTTYPE not set,  we are dealing with a GDI font.  If
    // the printer can handle it,  we should consider downloading the font
    // to make it a pseudo device font.  If this is a heavily used font,
    // then printing will be MUCH faster.
    //
    // However there are some points to consider.  Firstly, we need to
    // consider the available memory in the printer; little will be gained
    // by downloading a 72 point font,  since there can only be a few
    // glyphs per page.  Also,  if the font is not black (or at least a
    // solid colour), then it cannot be treated as a downloaded font.
    //
    // If the font is TT and we are not doing font substitution,
    // then check for Conditions for not downloading, which are:
    //
    // GDI Font with no cache (DDI spec, iUniq == 0) or
    // Text should be printed as graphics or
    // The Text is white, Assume that there is some merged graphics or
    // iDownLoadFont fails and returns an invalid download index or
    // OEM font download callback doesn't support correct formats.
    //

    if ( !(DEVICE_FONT(pfo, tod))                  &&
         (   (pfo->iUniq == 0)                                          ||
             (dwFlags & TXTOUT_PRINTASGRX)                              ||
             ( pfm == NULL )                                            ||
             ( pPDev->pOemHookInfo &&
               pPDev->pOemHookInfo[EP_OEMTTDownloadMethod].pfnHook &&
               (UFObj.dwFlags & (UFOFLAG_TTDOWNLOAD_BITMAP |
                                 UFOFLAG_TTDOWNLOAD_TTOUTLINE)) == 0)
         )
      )
    {

        /*
         *   GDI font,  and either cannot or do not wish to download.
         *  So,  let the engine handle it!
         */
        PrintAsBitmap:

        if (!(dwFlags & TXTOUT_DMS))   // bitmap surface
        {
        CheckBitmapSurface(pso,&pstro->rclBkGround);
#ifdef WINNT_40 //NT 4.0
        STROBJ_vEnumStart(pstro);
#endif
        bRet = EngTextOut( pso,
                           pstro,
                           pfo,
                           pco,
                           prclExtra,
                           prclOpaque,
                           pboFore,
                           pboOpaque,
                           pptlBrushOrg,
                           mix );

        }
        else
        HANDLE_VECTORPROCS_RET(pPDev, VMTextOutAsBitmap, bRet, (pso, pstro, pfo, pco, prclExtra, prclOpaque, pboFore, pboOpaque, pptlBrushOrg, mix))
        else
        {
            if ( pPDev->pOemHookInfo &&
               (pfnOEMTextOutAsBitmap = (PFN_OEMTextOutAsBitmap)
                pPDev->pOemHookInfo[EP_OEMTextOutAsBitmap].pfnHook))
            {

                bRet = FALSE;
                FIX_DEVOBJ(pPDev, EP_OEMTextOutAsBitmap);

                if(pPDev->pOemEntry)
                {
                    if(((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
                    {
                            HRESULT  hr ;
                            hr = HComTextOutAsBitmap((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                        pso,
                                                         pstro,
                                                         pfo,
                                                         pco,
                                                         prclExtra,
                                                         prclOpaque,
                                                         pboFore,
                                                         pboOpaque,
                                                         pptlBrushOrg,
                                                         mix );
                            if(SUCCEEDED(hr))
                                bRet = TRUE ;  //  cool !
                    }
                    else
                    {
                        bRet = pfnOEMTextOutAsBitmap (pso,
                                                         pstro,
                                                         pfo,
                                                         pco,
                                                         prclExtra,
                                                         prclOpaque,
                                                         pboFore,
                                                         pboOpaque,
                                                         pptlBrushOrg,
                                                         mix );
                    }
                }
            }
            else
                 bRet = FALSE;
        }

        goto ErrorExit;
    }

    //
    // Mark the scanlines to indicate the present of text, z-ordering fix
    //
    // returns BYTE
    //

    if (!(dwFlags & TXTOUT_DMS))   // bitmap surface
    {
        //
        // Mark the scanlines to indicate the present of text, z-ordering fix
        //

        ubMask = BGetMask(pPDev, &rclRegion);
        for (iI = rclRegion.top; iI < rclRegion.bottom ; iI++)
        {
            pPDev->pbScanBuf[iI] |= ubMask;
        }
    }

    /*
     *  Serial printers (those requiring the text be fed out at the same
     *  time as the raster data) are processed by storing all the text
     *  at this time,  then playing it back while rendering the bitamp.
     *  THIS ALSO HAPPENS FOR WHITE TEXT,  on those printers capable
     *  of doing this.  The difference is that the white text is played
     *  back in one hit AFTER RENDERING THE BITMAP.
     */

    //
    // Realize the Color
    //

    if ((!(dwFlags & TXTOUT_DMS)) &&
        !(tod.pvColor = GSRealizeBrush(pPDev, pso, pboFore)) )
    {
        ERR(( "GSRealizeBrush Failed;Can't Realize the Color\n" ));
        goto ErrorExit;
    }

    //
    // Font selection
    //
    // Initialize pfnDrwaGlyph function pointer
    // pfnDrwaGlyph cound be
    //     BPSGlyphOut     -- Dot matrics
    //     BWhiteText      -- White character
    //     BRealGlyphOut   -- Device font output
    //     BDLGlyphOut     -- TrueType download font output
    //

    if( pFontPDev->flFlags & FDV_MD_SERIAL )
    {
        //
        // yAdj has to be added to tod.pgp->ptl.y
        // Device font could be scalable font so that iyAdjust calculation
        // has to be done after BNewFont.
        //
        iyAdjust = (int)pfm->syAdj + (int)((PFONTMAP_DEV)pfm->pSubFM)->sYAdjust;

        //
        //  Dot matrix or white text on an LJ style printer
        //
        pfnDrawGlyph =  BPSGlyphOut;

        //
        //For Serial printer White text is also interlaced.
        //
        dwFlags &= ~(TXTOUT_CACHED|TXTOUT_SETPOS);      /* Assume position is set elsewhere */
    }
    else
    {

        /*
         *     Page printer - e.g. LaserJet.   If this is a font that we
         *  have downloaded,  then there is a specific output routine
         *  to use.  Using a downloaded font is rather tricky, as we need
         *  to translate HGLYPHs to char index, or possibly bitblt the
         *  bitmap to the page bitmap.
         */

        if( DEVICE_FONT(pfo, tod) )
        {
            if (dwFlags & TXTOUT_COLORBK)
            {
                /* Z-ordering fix, delay device font to the end */
                dwFlags |= TXTOUT_CACHED;
            }

            UFObj.ulFontID = ((PFONTMAP_DEV)pfm->pSubFM)->dwResID;

            pfnDrawGlyph = BRealGlyphOut;
            BNewFont(pPDev,
                     tod.iSubstFace?tod.iSubstFace:tod.iFace,
                     pfm,
                     tod.dwAttrFlags);

            //
            // yAdj has to be added to tod.pgp->ptl.y
            // Device font could be scalable font so that iyAdjust calculation
            // has to be done after BNewFont.
            //
            iyAdjust = (int)pfm->syAdj + (int)((PFONTMAP_DEV)pfm->pSubFM)->sYAdjust;

        }
        else
        {
            //
            // GDI font (TrueType), so we will want print it. All the glyphs
            // are already downloaded. The font has already been selected by
            // IDownloadFont
            //
            pfnDrawGlyph = BDLGlyphOut;
            UFObj.ulFontID = pfm->ulDLIndex;
        }

        //
        // For DMS we don't want to not cache the text. So turn off
        // TXTOUT_CACHED flag.
        //
        if (dwFlags & TXTOUT_DMS)
            dwFlags &= ~TXTOUT_CACHED;

        //
        // For cached text always use BWhiteText as we need to send cached text
        // after the graphics.
        //
        if (dwFlags & TXTOUT_CACHED)
        {
            pfnDrawGlyph = BWhiteText;
        }

        dwFlags |= TXTOUT_SETPOS;

    }

    /*
     * Also set the colour - ignored if already set or irrelevant
     * We want to select the color only if we are not caching the text.
     * Cache text when we have white text or it's a serial printer
     */

    if (!((dwFlags & TXTOUT_DMS) || (dwFlags & TXTOUT_CACHED) ||
          (pFontPDev->flFlags & FDV_MD_SERIAL)))
        SelectTextColor( pPDev, tod.pvColor );

    //
    // Initialize iXInc and iYInc for SO_FLAG_DEFAULT_PLACEMENT
    //

    iXInc = iYInc = 0;                  /* We do nothing case */

    if( (pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT) && pstro->ulCharInc )
    {
        /*
         *     We need to calculate the positions ourselves, as GDI has
         *  become lazy to gain some speed - I guess.
         */

        if( pstro->flAccel & SO_HORIZONTAL )
            iXInc = pstro->ulCharInc;

        if( pstro->flAccel & SO_VERTICAL )
            iYInc =  pstro->ulCharInc;

        if( pstro->flAccel & SO_REVERSED )
        {
            /*   Going the other way! */
            iXInc = -iXInc;
            iYInc = -iYInc;
        }
    }

    //
    // Allocate GLYPHPOS structure.
    //

    pgp    = MemAlloc(sizeof(GLYPHPOS) * pstro->cGlyphs);

    if (!pgp)
    {
        ERR(("pgp memory allocation failed\r\n"));
        goto ErrorExit;
    }

    //
    //
    // Allocate pbClipBits. size = cMaxGlyphs / BBITS
    //

    if (!(pbClipBits = MemAlloc((pstro->cGlyphs + BBITS - 1)/ BBITS)))
    {
        ERR(("pbClipBits memory allocation failed\r\n"));
        goto ErrorExit;
    }

    //
    // Start Glyph Enumuration
    //
    //
    // Enumuration
    //
    // (a) iStartIndex        - phSubstGlyphOrg
    // (b) dwPGPStartIndex    - pgp, pbClipBits, tod
    //
    //                 (pgp, pbClipBits)
    //                       |
    //                       |   dwPGPStartIndex
    //                       |   |
    //                       |   v   +Current point in the string.
    //                       |       |
    //                       |<----->|
    //                       |       |<----dwGlyphToPrint--->|       |
    //                       v       |                       v       |
    // |-----------------------------+-------------------------------|
    // ^                     |
    // |<-----iStartIndex--->|<------------dwTotalGlyph------------->|
    // |
    // phSubstGlyphOrg
    //

    iStartIndex  = 0;
    tod.dwCurrGlyph = 0;
    tod.flFlags |= TODFL_FIRST_ENUMRATION;

    STROBJ_vEnumStart(pstro);
    do
    {
        #ifndef WINNT_40 //NT 5.0

        bMore = STROBJ_bEnumPositionsOnly( pstro, &dwTotalGlyph, &pgpTmp );

        #else // NT 4.0

        bMore = STROBJ_bEnum( pstro, &dwTotalGlyph, &pgpTmp );

        #endif //!WINNT_40

        CopyMemory(pgp, pgpTmp, sizeof(GLYPHPOS) * dwTotalGlyph);

        //
        // Set the first Glyph position in the TextOut data. This can be used
        // by Glyph Output functions to optimize.
        //
        tod.ptlFirstGlyph = pgp[0].ptl;

        //
        // Evaluate the position of the chars if this is needed.
        // SO_FLAG_DEFAULT_PLACEMENT case
        //

        if( iXInc || iYInc )
        {
            //
            // NT4.0 font support or GDI soft font
            //
            if ( !(pfo->flFontType & DEVICE_FONTTYPE) ||
                 (pfm->flFlags & FM_IFIVER40) )
            {
                for( iI = 1; iI < (int)dwTotalGlyph; ++iI )
                {
                    pgp[ iI ].ptl.x = pgp[ iI - 1 ].ptl.x + iXInc;
                    pgp[ iI ].ptl.y = pgp[ iI - 1 ].ptl.y + iYInc;
                }
            }
            else
            //
            // NT5.0 device font support
            //
            {
                PMAPTABLE pMapTable;
                PTRANSDATA pTrans;

                pMapTable = GET_MAPTABLE(((PFONTMAP_DEV)pfm->pSubFM)->pvNTGlyph);
                pTrans = pMapTable->Trans;

                //
                // iXInc and iYInc are DBCS width when Far East charset.
                //
                for( iI = 1; iI < (int)dwTotalGlyph; ++iI )
                {
                    if (pTrans[pgp[iI].hg - 1].ubType & MTYPE_SINGLE)
                    {
                        pgp[ iI ].ptl.x = pgp[ iI - 1 ].ptl.x + iXInc/2;
                        pgp[ iI ].ptl.y = pgp[ iI - 1 ].ptl.y + iYInc;
                    }
                    else
                    {
                        pgp[ iI ].ptl.x = pgp[ iI - 1 ].ptl.x + iXInc;
                        pgp[ iI ].ptl.y = pgp[ iI - 1 ].ptl.y + iYInc;
                    }
                }
            }
        }


        //
        // Initialize the pgp in TextOut Data for Clipping.
        //
        tod.pgp         = pgp;
        dwPGPStartIndex  = 0;

        //
        // Check to see if there is any character at the boundary of clipping
        // rectangle.
        //
        VClipIt( pbClipBits, &tod, pco, pstro, dwTotalGlyph, iRot, pFontPDev->flFlags & FDV_ENABLE_PARTIALCLIP);

        //
        // If partial clipping has happend for TT font, call EngTextOut.
        //
        if (tod.flFlags & TODFL_TTF_PARTIAL_CLIPPING )
        {
            //
            // We have to use goto, but no other better way.
            //
            goto PrintAsBitmap;
        }

        //
        // Replace pgp's hg with Device font glyph handle
        //
        if (tod.iSubstFace)
        {
            tod.phGlyph     =
            phSubstGlyph    = phSubstGlyphOrg + iStartIndex;

            pgpTmp = pgp;

            for (iJ = 0; iJ < (INT)(int)dwTotalGlyph; iJ++, pgpTmp++)
            {
                pgpTmp->hg = *phSubstGlyph++;
            }
        }

        while ( dwTotalGlyph > dwPGPStartIndex )
        {
            //
            // Got the glyph data, so onto the real work!
            //

            if (BGetStartGlyphandCount(pbClipBits,
                                       dwTotalGlyph,
                                       &dwPGPStartIndex,
                                       &dwGlyphToPrint))
            {
                //VERBOSE(("dwTotalGlyph        = %d\n", dwTotalGlyph));
                //VERBOSE(("dwGlyphToPrint      = %d\n", dwGlyphToPrint));
                //VERBOSE(("dwPGPStartIndex     = %d\n", dwPGPStartIndex));

                ASSERT((dwTotalGlyph > dwPGPStartIndex));

                tod.dwCurrGlyph  = iStartIndex + dwPGPStartIndex;

                //
                // DCR: Add the Glyph position optimization call here.
                // If we are drawing Underline or strike through then disable
                // default placement optimization.
                //
                // if( prclExtra )
                //    tod.flFlags &= ~TODFL_DEFAULT_PLACEMENT;

                if (dwFlags & TXTOUT_SETPOS)
                {

                    //
                    // Set initial position so that LaserJets can
                    // use relative position.   This is deferred until
                    // here because applications (e.g. Excel) start
                    // printing right off the edge of the page, and
                    // our position tracking code then needs to
                    // understand what the printer does about moving
                    // out of the printable area. This is too risky
                    // to be safe,  so we save setting the position
                    // until we are in the printable region. Note
                    // that this assumes that the clipping data we
                    // have is limited to the printable region.
                    // I believe this to be true (16 June 1993).
                    //
                    //
                    // We need to handle the return value. Devices with
                    // resoloutions finer than their movement capability
                    // (like LBP-8 IV) get into a knot here , attempting
                    // to y-move on each glyph. We pretend we got where
                    // we wanted to be.
                    //

                    VSetCursor( pPDev,
                                pgp[dwPGPStartIndex].ptl.x,
                                pgp[dwPGPStartIndex].ptl.y+(iyAdjust?iyAdjust:0),
                                MOVE_ABSOLUTE,
                                &ptlRem);

                    pPDev->ctl.ptCursor.y += ptlRem.y;


                    VSetRotation( pFontPDev, iRot );    /* It's safe now */

                    //
                    // If the default placement is not set then we need to set
                    // the cursor for each enumration. So we clear the SETPOS
                    // flag only for default placement.
                    //

                    if ((pstro->flAccel & SO_FLAG_DEFAULT_PLACEMENT))
                        dwFlags &= ~TXTOUT_SETPOS;

                    //
                    // we set the cursor to forst glyph position. So set
                    // the TODFL_FIRST_GLYPH_POS_SET flag. Output function
                    // don't need to do a explicit move to this position.
                    //
                    tod.flFlags |= TODFL_FIRST_GLYPH_POS_SET;
                }


                tod.pgp              = pgp + dwPGPStartIndex;
                tod.cGlyphsToPrint   = dwGlyphToPrint;

                if ( iyAdjust )
                {
                    for ( iI = 0; iI < (int)dwGlyphToPrint; iI ++)
                        tod.pgp[iI].ptl.y += iyAdjust;
                }

                if( !pfnDrawGlyph( &tod ) )
                {
                    ERR(( "Glyph Drawing Failed;Can't draw the glyph\n" ));
                    goto ErrorExit;
                }
            }
            else // None of the Glyphs are printable.
            {
                //
                // If none of the glyphs are printable that update the counters
                // to point to next run.
                //

                dwGlyphToPrint = dwTotalGlyph;
            }

            dwPGPStartIndex += dwGlyphToPrint;
        }

        iStartIndex += dwTotalGlyph;

        //
        // Clear the first enumartion flag, if more glyphs has to be enumerated.
        //
        if (bMore)
        {
            tod.flFlags &= ~TODFL_FIRST_ENUMRATION;

        }

    } while( bMore );

    //
    // Actual character printing. We may have enumurated once for downloading.
    // So call STROBJ_vEnumStart here.
    //

    //
    //   Restore the normal graphics orientation by setting rotation to 0.
    //

    VSetRotation( pFontPDev, 0 );

    /*
     *   Do the rectangles.  If present,  these are defined by prclExtra.
     *  Typically these are used for strikethrough and underline.
     */

    if( prclExtra )
    {
        if (!DRIVER_DEVICEMANAGED (pPDev) &&   // If not device managed surface
            !(pFontPDev->flFlags & FDV_UNDERLINE))
        {
            /* prclExtra is an array of rectangles;  we loop through them
             * until we find one where all 4 points are 0.engine does not
             * follow the spec - only sets x coords to 0.
             */

            while( prclExtra->left != prclExtra->right &&
                       prclExtra->bottom != prclExtra->top )
            {

                /* Use the engine's Bitblt function to draw the rectangles.
                 * last parameter is 0 for black!!
                 */
                 
                CheckBitmapSurface(pso,prclExtra);
                if( !EngBitBlt( pso, NULL, NULL, pco, NULL, prclExtra, NULL, NULL,
                                        pboFore, pptlBrushOrg, 0 ) )
                {
                    ERR(( "EngBitBlt Failed;Can't draw rectangle simulations\n" ));
                    goto ErrorExit;
                }

                ++prclExtra;
            }
        }
    }

    //
    // Set the dwFreeMem in PDEV
    //
    if( pPDev->dwFreeMem && (pFontPDev->flFlags & FDV_TRACK_FONT_MEM) )
    {
        pPDev->dwFreeMem = pFontPDev->dwFontMem - pFontPDev->dwFontMemUsed;
        pFontPDev->dwFontMemUsed = 0;
    }

    bRet = TRUE;

    //
    // Free pbClipBits
    //
    ErrorExit:

    //
    // In case of white text, BPlayWhite text must free the pgp.
    //

    if (pgp)
        MemFree(pgp);
    if (pbClipBits)
        MemFree(pbClipBits);
    if (phSubstGlyphOrg)
        MemFree(phSubstGlyphOrg);
    MEMFREEANDRESET(tod.apdlGlyph );
    VUFObjFree(pFontPDev);
    pFontPDev->ptod = NULL;
    pFontPDev->pIFI = NULL;
    pFontPDev->pUFObj = NULL;

    return  bRet;
}

BOOL
BPrintTextAsGraphics(
    PDEV        *pPDev,
    ULONG       iSolidColor,
    DWORD       dwForeColor,
    DWORD       dwFlags,
    INT         iSubstFace
    )
/*++
Routine Description:
    This routine checks the textout flag for printing text as graphics.

Arguments:
    pPDev     PDEV struct.
    dwFlags   TextOut Flags

Return Value:
    TRUE if text should be printed as graphics else FALSE

Note:

    10/9/1997 -ganeshp-
        Created it.
--*/

{
    FONTPDEV    *pFontPDev;        // FONTMODULE based PDEV


    //
    // Local initialization.
    //
    pFontPDev = pPDev->pFontPDev;

    //
    // DMS
    //
    if (pPDev->ePersonality == kPCLXL)
    {
        return FALSE;
    }


    //
    // Condition to print as graphics:
    // No substitution and Download option is FALSE in bitmap mode .
    //
    if ( (!iSubstFace && !(pFontPDev->flFlags & FDV_DLTT))              ||
        //
        // Font is rotated.
        //
        !(dwFlags & TXTOUT_NOTROTATED)                                  ||
        //
        // TXTOUT_COLORBK says that there is a color background. Merging with
        // Graphics. For non DMS case.
        //
        (dwFlags &  TXTOUT_COLORBK)                                     ||

        //
        // Color is non Primary color or Model doesn't supports programmable
        // foreground Color
        //
        // Print text as graphics, if device doesn't support programable
        // foreground color and the color of text is dithered and not black.
        //
        (!(dwFlags & TXTOUT_FGCOLOR) &&
         iSolidColor == DITHERED_COLOR &&
         (0x00FFFFFF & dwForeColor) !=  0x00000000)                     ||

        //
        // Disable substitution of device font for TrueType, if device does't
        // support programable foreground color and color is not black.
        //
        (iSubstFace &&
         !(dwFlags & TXTOUT_FGCOLOR) &&
         (0x00FFFFFF & dwForeColor) !=  0x00000000)                     
         )
   {
       return TRUE;

   }
    else
        return FALSE;

}

//
// pfnDrawGlyph functions
//     BDLGlyphOut
//     BWhiteText
//     BRealGlyphOut
//     BDLGGlyphOut
//

BOOL
BDLGlyphOut(
    TO_DATA   *pTOD
    )
/*++
Routine Description:
      Function to process a glyph for a GDI font we have downloaded.  We
      either treat this as a normal character if this glyph has been
      downloaded,  or BitBlt it to the page bitmap if it is one we did
      not download.

Arguments:

    pTOD    Textout Data. Holds all necessary information.

Return Value:

    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{
    BOOL        bRet;
    FONTMAP     *pFM;

    bRet = FALSE;

    if ( pFM = pTOD->pfm)
    {
        //
        // Check if the glyphout fucntions pointer is not null and then call
        // the function. We also have to check the return value. The fmtxtout
        // function assumes that the Glyphout fucntion will print all the
        // glyphs it requested to print i.e pTOD->cGlyphsToPrint should be
        // equal to return value of pFM->pfnGlyphOut.
        //

        if ( pFM->pfnGlyphOut )
        {
            DWORD dwGlyphPrinted;

            dwGlyphPrinted = pFM->pfnGlyphOut(pTOD);

            if (dwGlyphPrinted != pTOD->cGlyphsToPrint)
            {
                ERR(("UniFont!BDLGlyphOut:pfnGlyphOut didn't print all glyphs\n"));
            }
            else
                bRet = TRUE;
        }
        else
        {
            ERR(("UniFont!BDLGlyphOut:pFM->pfnGlyphOut is NULL\n"));
        }
    }
    else
    {
        ERR(("UniFont!BDLGlyphOut:pTOD->pfm is NULL, Can't do glyphout\n"));
    }

    return  bRet;

}


BOOL
BRealGlyphOut(
    register  TO_DATA  *pTOD
    )
/*++
Routine Description:
    Print this glyph on the printer,  at the given position.  Unlike
    bPSGlyphOut,  the data is actually spooled for output now,  since this
    function is used for things like LaserJets, i.e. page printers.

Arguments:
    pTOD    Textout Data. Holds all necessary information.

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{
    //
    //    All we need to do is set the Y position,  then call bOutputGlyph
    //  to do the actual work.
    //

    PDEV      *pPDev;
    PGLYPHPOS  pgp;   // Glyph positioning info
    DWORD      dwGlyph;
    INT        iX,iY; // Calculate real position
    BOOL       bRet;

    ASSERTMSG(pTOD->pfm->pfnGlyphOut, ("NULL GlyphOut Funtion Ptr\n"));

    pPDev   = pTOD->pPDev;
    pgp     = pTOD->pgp;
    dwGlyph = pTOD->cGlyphsToPrint;

    if (pTOD->pfm->pfnGlyphOut)
    {
        pTOD->pfm->pfnGlyphOut( pTOD );
        bRet = TRUE;
    }
    else
    {
        ASSERTMSG(FALSE,("NULL GlyphOut function pointer\n"));
        bRet = FALSE;
    }

    return bRet;
}


BOOL
BWhiteText(
    TO_DATA  *pTOD
    )
/*++
Routine Description:
    Called to store details of the white text.  Basically the data is
    stored away until it is time to send it to the printer.  That time
    is AFTER the graphics data has been sent.

Arguments:
    pTOD    Textout Data. Holds all necessary information.

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{
    WHITETEXT *pWT, *pWTLast;
    FONTCTL    FontCtl;
    FONTPDEV*  pFontPDev;
    DWORD      dwWhiteTextAlign;
    DWORD      dwIFIAlign;
    BOOL       bRet;

    pFontPDev = pTOD->pPDev->pFontPDev;           // The important stuff

    //
    // Note that we allocate a new one of these for each
    // iteration of this loop - that would be slightly wasteful
    // if we ever executed this loop more than once, but that
    // is unlikely.
    //

    pWT = NULL;
    //
    // 64 bit align.
    //
    dwWhiteTextAlign = (sizeof(WHITETEXT) + 7) / 8 * 8;
    dwIFIAlign = (pFontPDev->pIFI->cjThis + 7) / 8 * 8;

    if ( (pWT = (WHITETEXT *)MemAllocZ(dwWhiteTextAlign + dwIFIAlign + 
                                      pTOD->cGlyphsToPrint * sizeof(GLYPHPOS))))
    {
        pWT->next    = NULL;
        pWT->sCount  = (SHORT)pTOD->cGlyphsToPrint;
        pWT->iFontId = pTOD->iSubstFace?pTOD->iSubstFace:pTOD->iFace;
        pWT->pvColor = pTOD->pvColor;
        pWT->dwAttrFlags = pTOD->dwAttrFlags;
        pWT->flAccel    = pTOD->flAccel;
        pWT->rcClipRgn  = pTOD->pPDev->rcClipRgn;
        pWT->iRot    = pTOD->iRot;
        pWT->eXScale = pFontPDev->ctl.eXScale;
        pWT->eYScale = pFontPDev->ctl.eYScale;
        pWT->pIFI = (IFIMETRICS*)((PBYTE)pWT + dwWhiteTextAlign);
        CopyMemory(pWT->pIFI, pFontPDev->pIFI, pFontPDev->pIFI->cjThis);
        pWT->pgp = (GLYPHPOS *)((PBYTE)pWT->pIFI + dwIFIAlign);
        CopyMemory(pWT->pgp, pTOD->pgp, pWT->sCount * sizeof(GLYPHPOS));

        //
        // True Type Font download case
        //
        if ( (pTOD->pfo->flFontType & TRUETYPE_FONTTYPE) &&
            (pTOD->iSubstFace == 0) )
        {
            //
            // We need to copy the download glyph array.Allocate the array
            // for DLGLYPHs.
            //

            if (!(pWT->apdlGlyph = MemAllocZ( pWT->sCount * sizeof(DLGLYPH *))))
            {
                ERR(("UniFont:BWhiteText: MemAlloc for pWT->apdlGlyph failed\n"));
                goto ErrorExit;
            }
            CopyMemory( pWT->apdlGlyph, &(pTOD->apdlGlyph[pTOD->dwCurrGlyph]),
                        pWT->sCount * sizeof(DLGLYPH *) );

        }

        //
        // Put new text at the end of the list
        //
        if (!(pFontPDev->pvWhiteTextFirst))
            pFontPDev->pvWhiteTextFirst = pWT;

        if (pWTLast = (WHITETEXT *)pFontPDev->pvWhiteTextLast)
            pWTLast->next = pWT;

        pFontPDev->pvWhiteTextLast = pWT;

        bRet = TRUE;

    }
    else
    {
        ErrorExit:
        ERR(( "MemAlloc failed for white text.\n" ));
        bRet = FALSE;
    }

    return  bRet;
}


BOOL
BPSGlyphOut(
    register TO_DATA  *pTOD
    )
/*++
Routine Description:
    Places glyphs for dot matrix type printers.  These actually store
    the position and glyph data for later printing.  This is because
    dot matrix printers cannot or should not reverse line feed -
    for positioning accuracy.  Hence, play the data back when the
    bitmap is being rendered to the printer.  Output occurs in the
    following function, bDelayGlyphOut.

Arguments:
    pTOD    Textout Data. Holds all necessary information.

Return Value:
    TRUE/FALSE.  FALSE if the glyph storage fails.
Note:

    1/21/1997 -ganeshp-
        Created it.
--*/
{
    PGLYPHPOS  pgp;        // Glyph positioning info
    PSGLYPH    psg;        // Data to store away
    PFONTPDEV  pFontPDev;

    DWORD      dwGlyph;
    SHORT      sFontIndex;

    INT        iyVal;

    pFontPDev = (PFONTPDEV)pTOD->pPDev->pFontPDev;

    pgp     = pTOD->pgp;
    dwGlyph = pTOD->cGlyphsToPrint;

    /*
     *   About all that is needed is to take the parameters,  store in
     *  a PSGLYPH structure,  and call bAddPS to add this glyph to the list.
     */

    sFontIndex = pTOD->iSubstFace?pTOD->iSubstFace:pTOD->iFace;

    //
    // Scalable font support
    //
    psg.eXScale     = pFontPDev->ctl.eXScale;
    psg.eYScale     = pFontPDev->ctl.eYScale;

    while (dwGlyph--)
    {
        //
        // Transform the input X and Y from band corrdnate to page coordinate.
        //
        if (pTOD->pPDev->bBanding)
        {
            psg.ixVal = pgp->ptl.x + pTOD->pPDev->rcClipRgn.left;
            iyVal = pgp->ptl.y + pTOD->pPDev->rcClipRgn.top;
        }
        else
        {
            psg.ixVal = pgp->ptl.x;
            iyVal = pgp->ptl.y;
        }

        psg.hg          = pgp->hg;
        psg.sFontIndex  = sFontIndex;
        psg.pvColor     = pTOD->pvColor;       // Which colour
        psg.dwAttrFlags = pTOD->dwAttrFlags;
        psg.flAccel     = pTOD->flAccel;

        if ( BAddPS( ((PFONTPDEV)(pTOD->pPDev->pFontPDev))->pPSHeader,
                     &psg,
                     iyVal,
                     ((FONTMAP_DEV *)(pTOD->pfm->pSubFM))->fwdFOWinAscender) )
        {
            pgp ++;

        }
        else // Failure, So fail the call.
        {
            ERR(( "\nUniFont!BPSGlyphOut: BAddPS Failed.\n" ))
            return  FALSE;
        }

    }

    return TRUE;
}

//
// Delay and White test printing entry points
//

BOOL
BPlayWhiteText(
    PDEV  *pPDev
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/
{
    I_UNIFONTOBJ    UFObj;
    FONTPDEV        *pFontPDev;               /* Miscellaneous uses */
    WHITETEXT       *pwt;
    TO_DATA         Tod;
    GLYPHPOS        *pgp;
    RECTL           rcClipRgnOld;
    DWORD           dwGlyphCount;

    BOOL bRet = TRUE;

    //
    // Save the Clip rectangle.
    //
    rcClipRgnOld = pPDev->rcClipRgn;

    /*
     *    Loop through the linked list of these hanging off the PDEV.
     *  Mostly, of course, there will be none.
     */

    pFontPDev = pPDev->pFontPDev;
    pFontPDev->ptod = &Tod;
    ZeroMemory(&Tod, sizeof(TO_DATA));
    ZeroMemory(&UFObj, sizeof(I_UNIFONTOBJ));
    dwGlyphCount = 0;

    pPDev->ctl.dwMode |= MODE_BRUSH_RESET_COLOR;
    GSResetBrush(pPDev);

    for( pwt = pFontPDev->pvWhiteTextFirst; pwt && bRet; pwt = pwt->next )
    {
        int        iI;              /* Loop index */
        int        iRot;            /* Rotation amount */
        FONTMAP   *pfm;

        /*
         *    Not too hard - we know we are dealing with device fonts,
         *  and that this is NOT a serial printer,  although we could
         *  probably handle that too.  Hence,  all we need do is fill in
         *  a TO_DATA structure,  and loop through the glyphs we have.
         */


        if( pwt->sCount < 1 )
            continue;               /* No data, so skip it */

        Tod.pPDev = pPDev;
        Tod.flAccel = pwt->flAccel;
        Tod.dwAttrFlags = pwt->dwAttrFlags;
        pgp = Tod.pgp   = pwt->pgp;
        Tod.cGlyphsToPrint = pwt->sCount;

        if (pwt->dwAttrFlags & FONTATTR_SUBSTFONT)
        {
            Tod.iSubstFace = pwt->iFontId;
            UFObj.dwFlags |= UFOFLAG_TTSUBSTITUTED;
        }
        else
        {
            Tod.iSubstFace = 0;
            UFObj.dwFlags &= ~UFOFLAG_TTSUBSTITUTED;
        }

        Tod.pfm =
        pfm     = PfmGetIt( pPDev, pwt->iFontId );

        if (NULL == pfm)
        {
            //
            // Fatal error, PFM is not available.
            //
            continue;
        }

        //
        // The glyph positions are wrt banding rect, so set the PDEV clip region
        // to the recorded clip region.
        //
        pPDev->rcClipRgn = pwt->rcClipRgn;

        //
        // Set the download glyph array for True type downloaded fonts.
        //
        if (pwt->apdlGlyph)
        {
            Tod.apdlGlyph = pwt->apdlGlyph;
            Tod.dwCurrGlyph = 0;
        }

        /*
         *   Before switching fonts,  and ESPECIALLY before setting the
         *  font rotation,  we should move to the starting position of
         *  the string.  Then we can set the rotation and use relative
         *  moves to position the characters.
         */


        if(pPDev->pOemHookInfo)
        {
            // ulFontID
            // dwFlags
            // pIFIMetrics
            // pfnGetInfo
            // pFontObj X (set to NULL)
            // pStrObj X (set to NULL)
            // pFontPDev
            // pFontMap
            // ptGrxRes
            // pGlyph

            if (pfm->dwFontType == FMTYPE_DEVICE)
            {
                UFObj.ulFontID = ((PFONTMAP_DEV)pfm->pSubFM)->dwResID;
            }
            else
            {
                UFObj.dwFlags = UFOFLAG_TTFONT;
                UFObj.ulFontID = pfm->ulDLIndex;
            }

            if (Tod.cGlyphsToPrint)
            {
                if (UFObj.pGlyph != NULL && dwGlyphCount < Tod.cGlyphsToPrint)
                {
                    MemFree(UFObj.pGlyph);
                    UFObj.pGlyph = NULL;
                    dwGlyphCount = 0;
                }

                if (UFObj.pGlyph == NULL)
                {
                    UFObj.pGlyph  = MemAlloc(sizeof(DWORD) * Tod.cGlyphsToPrint);
                    dwGlyphCount = Tod.cGlyphsToPrint;
                }
            }

            if (pwt->dwAttrFlags & FONTATTR_SUBSTFONT)
            {
                //
                // In the substitution case, UNIDRV needs to pass TrueType font
                // IFIMETRICS to minidriver.
                //
                UFObj.pIFIMetrics = pwt->pIFI;
            }
            else
            {
                UFObj.pIFIMetrics = pfm->pIFIMet;
            }

            UFObj.pfnGetInfo  = UNIFONTOBJ_GetInfo;
            UFObj.pPDev       = pPDev;
            UFObj.pFontMap    = pfm;
            UFObj.ptGrxRes    = pPDev->ptGrxRes;
            if (pwt->apdlGlyph)
            {
                UFObj.apdlGlyph       = Tod.apdlGlyph;
                UFObj.dwNumInGlyphTbl = pwt->sCount;
            }
            else
            {
                UFObj.apdlGlyph       = NULL;
                UFObj.dwNumInGlyphTbl = 0;
            }

            pFontPDev->pUFObj = &UFObj;
        }
        else
            pFontPDev->pUFObj = NULL;

        //
        // If this is a new font, it's time to change it now.
        // BNewFont() checkes to see if a new font is needed.
        //
        pFontPDev->ctl.eXScale = pwt->eXScale;
        pFontPDev->ctl.eYScale = pwt->eYScale;

        BNewFont(pPDev, pwt->iFontId, pfm, pwt->dwAttrFlags);
        VSetRotation( pFontPDev, pwt->iRot );

        /*  Also set the colour - ignored if already set or irrelevant */
        SelectTextColor( pPDev, pwt->pvColor );
        ASSERTMSG(pfm->pfnGlyphOut, ("NULL GlyphOut Funtion Ptr\n"));
        if( !pfm->pfnGlyphOut( &Tod))
        {
            bRet = FALSE;
            break;
        }

        VSetRotation( pFontPDev, 0 );          /* For MoveTo calls */
        //
        // Reset TODFL_FIRST_GLYPH_POS_SET so that the cursor is set next time.
        //
        Tod.flFlags &= ~TODFL_FIRST_GLYPH_POS_SET;
    }

    VSetRotation( pFontPDev, 0 );        /* Back to normal */

    //
    // Cleanup everything.
    //

    {
        WHITETEXT  *pwt0,  *pwt1;

        for( pwt0 = pFontPDev->pvWhiteTextFirst; pwt0; pwt0 = pwt1 )
        {
            pwt1 = pwt0->next;

            //Free the download glyph array.
            if (pwt0->apdlGlyph)
                MemFree( pwt0->apdlGlyph );
            MemFree( pwt0 );
        }

        pFontPDev->pvWhiteTextFirst =
        pFontPDev->pvWhiteTextLast  = NULL;

        VUFObjFree(pFontPDev);
    }

    //
    // Restore the Clip rectangle.
    //
    pPDev->rcClipRgn = rcClipRgnOld;

    return  TRUE;
}

BOOL
BDelayGlyphOut(
    PDEV  *pPDev,
    INT    yPos
    )
/*++
Routine Description:
    Called during output to a dot matrix printer.  We are passed the
    PSGLYPH data stored above,  and go about placing the characters
    on the line.


Arguments:
    pPDev   Pointer to PDEV
    yPos    Y coordinate of interest

Return Value:
    TRUE for success and FALSE for failure

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/
{
    BOOL      bRet;             /* Return value */
    PSHEAD   *pPSH;             /* Base data for glyph info */
    PSGLYPH  *ppsg;             /* Details of the GLYPH to print */
    FONTMAP  *pFM;              /* Base address of FONTMAP array */
    FONTPDEV *pFontPDev;          /* FM's PDEV - for our convenience */
    I_UNIFONTOBJ UFObj;
    TO_DATA   Tod;
    GLYPHPOS  gp;

    ASSERT(pPDev);

    /*
     *    Check to see if there are any glyphs for this Y position.  If so,
     *  loop through each glyph,  calling the appropriate output function
     *  as we go.
     */

    pFontPDev = PFDV;               /* UNIDRV data */
    pFontPDev->ptod = &Tod;
    pPSH = pFontPDev->pPSHeader;
    bRet = TRUE;                /* Until proven otherwise */

    /* No Glyph Queue, so return. Check if there are device fonts? */
    if(pPDev->iFonts && !pPSH)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    Tod.pPDev          = pPDev;
    Tod.pgp            = &gp;
    Tod.iSubstFace     = 0;
    Tod.cGlyphsToPrint = 1;

    //
    // Check if a minidriver supports OEM plugin.
    //
    if(pPDev->pOemHookInfo)
    {
        ZeroMemory(&UFObj, sizeof(I_UNIFONTOBJ));
        UFObj.pfnGetInfo  = UNIFONTOBJ_GetInfo;
        UFObj.pPDev       = pPDev;
        UFObj.dwFlags     = 0;
        UFObj.ptGrxRes    = pPDev->ptGrxRes;
        UFObj.pGlyph      = MemAlloc(sizeof(DWORD) * Tod.cGlyphsToPrint);
        UFObj.apdlGlyph   = NULL;
        UFObj.dwNumInGlyphTbl = 0;
        pFontPDev->pUFObj = &UFObj;
    }
    else
        pFontPDev->pUFObj = NULL;


    //
    // Actual print out
    //
    if( pPSH && ISelYValPS( pPSH, yPos ) > 0 )
    {
        /*
         *    Got some,  so first set the Y position,  so that the glyphs
         *  will appear on the correct line!
         */

        gp.ptl.y = yPos - pPDev->rcClipRgn.top;

        //
        // Reset Brush, since Raster Module might send color selection
        // commnd.Set MODE_BRUSH_RESET_COLOR flag so that  the brush
        // color selection command is sent. This will change the current
        // brush color to be default brush color. We need to reset the
        // brush color as on some printers sending a color plane of
        // raster date cahnges the brush color also.
        //
        pPDev->ctl.dwMode |= MODE_BRUSH_RESET_COLOR;
        GSResetBrush(pPDev);

        while( bRet && (ppsg = PSGGetNextPSG( pPSH )) )
        {
            /*
             *   Check for the correct font!  Since the glyphs are now
             *  in an indeterminate order,  we need to check EACH one for
             *  the font,  since each one can be different, as we have
             *  no idea of how the glyphs arrived in this order.
             */

            if (pFM = PfmGetIt( pPDev, ppsg->sFontIndex))
            {
                //
                // Error check.
                // BDelayGlyphOut can only handle printer device fonts.
                //
                if (pFM->dwFontType != FMTYPE_DEVICE)
                {
                    bRet = FALSE;
                    break;
                }

                Tod.flAccel = ppsg->flAccel;
                Tod.dwAttrFlags = ppsg->dwAttrFlags;
                Tod.iFace = ppsg->sFontIndex;

                pFontPDev->ctl.eXScale = ppsg->eXScale;
                pFontPDev->ctl.eYScale = ppsg->eYScale;

                UFObj.pFontMap = Tod.pfm = pFM;
                UFObj.pIFIMetrics = pFM->pIFIMet;

                //
                // Reselect new font
                //
                BNewFont(pPDev, ppsg->sFontIndex, pFM, ppsg->dwAttrFlags);
                SelectTextColor( pPDev, ppsg->pvColor );

                ASSERTMSG(pFM->pfnGlyphOut, ("NULL GlyphOut Funtion Ptr\n"));

                gp.hg    = (HGLYPH)(ppsg->hg);
                gp.ptl.x = ppsg->ixVal - pPDev->rcClipRgn.left;

                //
                // Send character string
                //
                bRet = pFM->pfnGlyphOut(&Tod);
            }
            else
                bRet = FALSE;
        }
    }

    VUFObjFree(pFontPDev);
    return  bRet;
}

//
// Mics. functions
//

VOID
SelectTextColor(
    PDEV      *pPDev,
    PVOID     pvColor
    )
/*++
Routine Description:
    Select a text color.

Arguments:

    pPDev   Pointer to PDEV
    color   Color of the Text.

Return Value:

    Nothing.

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{

    //Select the Brush and then unrealize it.
    if (!GSSelectBrush( pPDev, pvColor))
    {
        ERR(( "GSSelectBrush Failed;Can't Select the Color\n" ));

    }

    return;

}


BCheckForDefaultPlacement(
    GLYPHPOS  *pgp,
    SHORT     sWidth,
    INT       *piTolalError
    )
/*++
Routine Description:

Arguments:
    pgp             Current Glyph
    sWidth          Width of the previous glyph.
    piTolalError    Comulative Error

Return Value:
    TRUE if the current glyph is at default placement else FALSE.

Note:

    11/11/1997 -ganeshp-
        Created it.
--*/
{
    GLYPHPOS    *pgpPrevious;
    INT         iError;

    pgpPrevious = pgp -1;

    iError = (pgpPrevious->ptl.x + sWidth) - pgp->ptl.x;
    *piTolalError += iError;

    //DbgPrint("\nTODEL!BCheckForDefaultPlacement:pgpPrevious->ptl.x = %d, Previous Glyph sWidth = %d,\n\t\tCurrpgp->ptl.x = %d, iError = %d, *piTolalError = %d\n",
    //pgpPrevious->ptl.x, sWidth, pgp->ptl.x, iError, *piTolalError );

    if ( (abs(iError) <= ERROR_PER_GLYPH_POS) /*&& (*piTolalError <= ERROR_PER_ENUMERATION)*/ )
    {
        //DbgPrint("TODEL!BCheckForDefaultPlacement: The Glyph is at Default Placement.\n");
        return TRUE;

    }
    else
    {
        //DbgPrint("TODEL!BCheckForDefaultPlacement: Non Default Placement Glyph Found.\n");
        //DbgPrint("\nTODEL!BCheckForDefaultPlacement:pgpPrevious->ptl.x = %d, Previous Glyph sWidth = %d,\n\t\tCurrpgp->ptl.x = %d, iError = %d, *piTolalError = %d\n",
        //pgpPrevious->ptl.x, sWidth, pgp->ptl.x, iError, *piTolalError );
        return FALSE;
    }

}


VOID
VClipIt(
    BYTE     *pbClipBits,
    TO_DATA  *ptod,
    CLIPOBJ  *pco,
    STROBJ   *pstro,
    int      cGlyphs,
    int      iRot,
    BOOL     bPartialClipOn
    )
/*++
Routine Description:
    Applies clipping to the glyphos array passed in,  and sets bits in
    bClipBits to signify that the corresponding glyph should be printed.
    NOTE:   the clipping algorithm is that the glyph is displayed if
    the top, left corner of the character cell is within the clipping
    region.  This is the formula of Win 3.1, so it is important for
    us to follow it.


Arguments:
    pbClipBits      Output data is placed here
    ptod            Much information
    cGlyphs         Number of glyphs in following array
    iRot            90 degree rotation amount (0-3)

Return Value:
    Nothing

Note:

    1/21/1997 -ganeshp-
        Created it.
--*/

{


    int       iIndex;             /* Classic loop variable!  */
    ULONG     iClipIndex;         /* For clipping rectangle */
    int       iYTop;              /* Font's ascender, scaled if relevant */
    int       iYBot;              /* Descender, scaled if required */
    BYTE      bVal;               /* Determine how to set the bits */
    FONTMAP  *pFM;                /* Speedier access to data */
    FONTPDEV  *pFontPDev;           /* Ditto */
    GLYPHPOS *pgp;                /* Ditto */
    short    *asWidth;


    /*
     *  Behaviour depends upon the complexity of the clipping region.
     *  If it is non-existent (I doubt that this happens,  but play it safe)
     *  or of complexity DC_TRIVIAL,  then set all the relevant bits and
     *  return.
     *  If DC_RECT is set,  the CLIPOBJ contains the clipping rectangle,
     *  so clip using that information.
     *  Otherwise,  it is DC_COMPLEX,  and so we need to enumerate clipping
     *  rectangles.
     *  If we do not need to do anything,  then set the bits and return.
     *  Otherwise,  we have either of the two cases requiring evaluation.
     *  For those we want to set the bits to 0 and set the 1 bits as needed.
     *
     *  Disable clipping for PCL-XL.
     */

    if( pco &&
        (pco->iDComplexity == DC_RECT || pco->iDComplexity == DC_COMPLEX) &&
        !(ptod->pPDev->ePersonality == kPCLXL))
        bVal = 0;               /*  Requires us to evaluate it */
    else
        bVal = 0xff;            /*  Do it all */

    FillMemory( pbClipBits, (cGlyphs + BBITS - 1) / BBITS, bVal );

    if( bVal == 0xff )
        return;                 /* All done */

    if (!(asWidth = MemAlloc(cGlyphs * sizeof(short))))
    {
        return;
    }

    pFM = ptod->pfm;
    pFontPDev = ptod->pPDev->pFontPDev;

    /*
     *    We now calculate the widths of the glpyhs.  We need these to
     *  correctly clip the data.  However,  calculating widths can be
     *  expensive,  and since we need the data later on,  we save
     *  the values in the width array that ptod points to.  This can
     *  then be used in the bottom level function, rather than calculating
     *  the width again.
     */

    pgp = ptod->pgp;

    //
    // pgp may be NULL causing problems below. So don't clip, just return.
    //

    if (pgp == NULL)
    {
        if (asWidth)
        {
            MemFree(asWidth);
        }
        ASSERTMSG((FALSE),("\nCan't Clip the text.Null pgp in VClipIt. \n"));
        return;
    }

    if (!(ptod->pfo->flFontType & TRUETYPE_FONTTYPE))
    {
        /*   The normal case - a standard device font */

        int   iWide;                     /* Calculate the width */

        for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
        {

            iWide = IGetGlyphWidth( ptod->pPDev, pFM, pgp->hg);

            if( pFM->flFlags & FM_SCALABLE )
            {
                /*   Need to transform the value to current size */
                iWide = LMulFloatLong(&pFontPDev->ctl.eXScale,iWide);
            }

            asWidth[ iIndex ] = iWide - 1;       /* Will be used later */
        }


    }
    else  //GDI Font
    {

        GLYPHDATA *pgd;

        /*
         *    SPECIAL CASE:  DOWNLOADED GDI font.  The width is
         *  obtained by calling back to GDI to get the data on it.
         */

        for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
        {
            pgd = NULL;

            if( !FONTOBJ_cGetGlyphs( ptod->pfo, FO_GLYPHBITS, (ULONG)1,
                                                   &pgp->hg, &pgd ) )
            {
                if (asWidth)
                {
                   MemFree(asWidth);
                }

                ERR(( "FONTOBJ_cGetGlyphs fails\n" ))
                return;
            }

            /*
             *   Note about rotations:  we do NOT download rotated fonts,
             *  so the following piece of code is quite correct.
             */

            if (pgd)
            {
                asWidth[ iIndex ] = (short)(pgd->ptqD.x.HighPart + 15) / 16 - 1;

            }
            else
            {
                ASSERTMSG(FALSE,("UniFont!VClipIt:GLYPHDATA pointer is NULL\n"));
                if (asWidth)
                {
                   MemFree(asWidth);
                }

                return;

            }


        }
    }

    /*
     * We also want the Ascender and Descender fields, as these are
     * used to check the Y component. While calculationg these values we have
     * to do special case for Font substitution. In font substitution case
     * True Type font's IFIMERTICS should be used rather than substituted
     * device font's IFIMETRICS.
     */

    //
    // Initialize itTop and iyBot to fontmap values. Then based on what font we
    // are using these values will change.
    //

    iYTop = (INT)((IFIMETRICS *)(pFM->pIFIMet))->fwdWinAscender;
    iYBot = (INT)((IFIMETRICS *)(pFM->pIFIMet))->fwdWinDescender;

    if (ptod->pfo->flFontType & TRUETYPE_FONTTYPE)
    {
        //
        // True Type Font case. Get the values from FONTOBJ ifimetrics.
        //

        ASSERTMSG((pFontPDev->pIFI),("NULL pFontPDev->pIFI, TT Font IFIMETRICS\n"));

        if (pFontPDev->pIFI)
        {
            iYTop = (INT)((IFIMETRICS *)(pFontPDev->pIFI))->fwdWinAscender;
            iYBot = (INT)((IFIMETRICS *)(pFontPDev->pIFI))->fwdWinDescender;

        }
        //
        // We always need to do the sacling as TT font metrics values
        // are in notional space.
        //
        iYTop = LMulFloatLong(&pFontPDev->ctl.eYScale,iYTop);
        iYBot = LMulFloatLong(&pFontPDev->ctl.eYScale,iYBot);


    }
    else
    {
        //
        // Device Font  case. We just need to scale for scalable fonts.
        //

        if( pFM->flFlags & FM_SCALABLE )
        {
            iYTop = LMulFloatLong(&pFontPDev->ctl.eYScale,iYTop);
            iYBot = LMulFloatLong(&pFontPDev->ctl.eYScale,iYBot);
        }
    }



    /*
     *    Down here means we are serious!  Need to determine which (if any)
     *  glyphs are within the clip region.
     */

    pgp = ptod->pgp;

    if( pco->iDComplexity == DC_RECT )
    {
        /*   The simpler case - one clipping rectangle.  */
        RECTL   rclClip;
        LONG    lFirstGlyphX;

        /* Local access -> speedier access */
        rclClip = pco->rclBounds;
        lFirstGlyphX = 0;

        /*
         *    Nothing especially exciting.  The clipping is checked for
         *  each particular type of rotation,  as this is probably faster
         *  than having the loop go through the switch statement.  The
         *  selection criteria are that all the character must be within
         *  the clip region in the X direction,  while any part of it must
         *  be within the clip region in the Y direction.  Then we print.
         *  Failing either means it is clipped out.
         *
         *    NOTE that we fiddle with the clipping rectangle coordinates
         *  before the loop,  as this saves some computation within the loop.
         */

        switch( iRot )
        {
        case  0:                 /*  Normal direction */
            //
            // Save the x position to restore after clipping calculation.
            //
            lFirstGlyphX = pgp->ptl.x;

            // Check the First Glyph position. If it's just OFF by one or two
            // pixels, print it.
            if ( (pgp->ptl.x != rclClip.left) &&
                (abs(pgp->ptl.x - rclClip.left) <= 2) )
            {
                pgp->ptl.x = rclClip.left;
            }

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
#ifndef OLDWAY
                //
                // We want to draw the character in the first band
                // in which a portion of it appears. This means that
                // if the character starts in the current band we will
                // draw it. We also draw the character if it starts before
                // the first band but some of it exists within the band.
                // The x and y points are relative to the lower left of the
                // character cell so we calculate a upper left value for
                // our testing purposes.
                //
                INT     iyTopLeft;
                INT     iyBottomLeft, ixRight;

                iyTopLeft    = pgp->ptl.y - iYTop;
                iyBottomLeft = pgp->ptl.y + iYBot;
                ixRight      = pgp->ptl.x + asWidth[ iIndex ];


                if ((ptod->pfo->flFontType & TRUETYPE_FONTTYPE) &&
                    (ptod->flFlags & TODFL_FIRST_ENUMRATION)    &&
                    bPartialClipOn)
                {
                    BOOL    bGlyphVisible; // Set if glyph is totally visible.
                    BOOL    bLeftVisible, bRightVisible,
                            bTopVisible, bBottomVisible;
                    INT     iError, iYdpi;

                    //
                    // Fix iyTopLeft to be maximum of STROBJ background rectangle's
                    // top and current calculated value of the top using asender of
                    // the font.This is needed because we want to clip using
                    // smallest bounding rectangle for the glyph. We also need to
                    // fix iyBottomLeft to be smaller of current value and STROBJ
                    // background rectangle's bottom.
                    //

                    iyTopLeft     = max(iyTopLeft, pstro->rclBkGround.top);
                    iyBottomLeft  = min(iyBottomLeft, pstro->rclBkGround.bottom);

                    //
                    // If the glyph rectangle's top or bottom is outside the
                    // clipping rectangle, we may need adjust the glyph
                    // rectangle. This is needed as the glyph rectangle's top and
                    // bottom is calculated using ascender and decender. This
                    // gives us a bigger rectangle height(worst case) than needed.
                    // Adjust the rectangle height by the Error factor. The
                    // error factor value is based upon the graphics dpi. For a
                    // 600 or 300 dpi printer it's set to 5 pixels and will
                    // scale based upon the graphics resolution.This number
                    // makes the glyph bounding rectangle small enough to catch
                    // the normal non partial clipping case and still catches
                    // the partial clipping of the glyphs.This adjustment should
                    // be done only if error factor is smaller than ascender or
                    // decender. Finally we must check if ptl.y is between
                    // topleft and bottomleft.
                    //

                    if ( (iyTopLeft < rclClip.top) ||
                         (iyBottomLeft > rclClip.bottom) )
                    {
                        iYdpi = ptod->pPDev->ptGrxRes.y;
                        if (iYdpi == 300)
                            iYdpi = 600;
                        iError = (EROOR_PER_GLYPHRECT * iYdpi) / 600;

                        if (iYTop > iError)
                            iyTopLeft += iError;

                        if (iYBot > iError)
                            iyBottomLeft  -= iError;

                    }

                    if (iyTopLeft > pgp->ptl.y)
                        iyTopLeft = pgp->ptl.y;

                    if (iyBottomLeft < pgp->ptl.y)
                        iyBottomLeft = pgp->ptl.y;

                    //
                    // Now test for partial clipping. If the charecter is
                    // partially clippeed and the font is truetype, then we need
                    // to call EngTextOut.
                    //
                    // We can only call EngTextOut if we are clipping the first
                    // enumaration of the glyphs. EngTextOut doesn't support
                    // partial glyph printing.
                    //

                    //
                    // Glyph is fully visible if all the four corners of the
                    // glyph rectangle are visible.
                    //


                    bLeftVisible = (pgp->ptl.x >= rclClip.left);
                    bRightVisible = (ixRight <= rclClip.right);
                    bTopVisible    = (iyTopLeft >= rclClip.top);
                    bBottomVisible = (iyBottomLeft <= rclClip.bottom);


                    bGlyphVisible = ( bLeftVisible && bRightVisible &&
                                      bTopVisible && bBottomVisible );


                    if (!bGlyphVisible)
                    {

                        ptod->flFlags |= TODFL_TTF_PARTIAL_CLIPPING;

                        //
                        // No need to test rest of the glyphs for clipping.
                        //
                        break;
                    }

                }
                else
                {

                    if ( (iyTopLeft < rclClip.top) ||
                         (iyBottomLeft > rclClip.bottom) )
                    {
                        INT iError;
                        INT iYdpi = ptod->pPDev->ptGrxRes.y;
                        if (iYdpi <= 600)
                            iYdpi = 600;
                        iError = (EROOR_PER_GLYPHRECT * iYdpi) / 600;

                        if (iYTop > iError)
                            iyTopLeft += iError;

                        if (iYBot > iError)
                            iyBottomLeft  -= iError;

                    }
                }

                if( pgp->ptl.x >= rclClip.left &&
                    pgp->ptl.x <= rclClip.right &&
                    iyTopLeft <= rclClip.bottom &&
                    (iyTopLeft >= rclClip.top ||
                     (pgp->ptl.y >= rclClip.top &&
                      ptod->pPDev->rcClipRgn.top == 0)))
#else
                if( pgp->ptl.x >= rclClip.left &&
                    pgp->ptl.x <= rclClip.right &&
                    pgp->ptl.y <= rclClip.bottom &&
                    pgp->ptl.y >= rclClip.top )
#endif
                {


                    /*   Got it!  So set the bit to print it  */

                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);

                }

                //
                // Restore the position of the first glyph. It may have been
                // changed.
                //
                if ( iIndex == 0 )
                    pgp->ptl.x = lFirstGlyphX;
            }

            break;

        case  1:                /* 90 degrees counter clockwise */

            rclClip.left += iYTop;
            rclClip.right -= iYBot;

            /* Check the First Glyph. If it's just OFF by One, print it.*/
            if (abs(pgp->ptl.y - rclClip.bottom) == 1)
                pgp->ptl.y = rclClip.bottom;

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
                if( (pgp->ptl.y <= rclClip.bottom)                    &&
                    ((pgp->ptl.y - asWidth[ iIndex ]) >= rclClip.top) &&
                    (pgp->ptl.x >= rclClip.left)                      &&
                    (pgp->ptl.x <= rclClip.right) )
                {
                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);
                }
            }

            break;

        case  2:                /* 180 degrees, CCW (aka right to left) */

            rclClip.bottom += iYBot;
            rclClip.top -= iYTop;

            /* Check the First Glyph. If it's just OFF by One, print it.*/
            if (abs(pgp->ptl.x - rclClip.right) == 1)
                pgp->ptl.x = rclClip.right;

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
                if( pgp->ptl.x <= rclClip.right &&
                    (pgp->ptl.x - asWidth[ iIndex ]) >= rclClip.left &&
                    pgp->ptl.y <= rclClip.bottom &&
                    pgp->ptl.y >= rclClip.top )
                {
                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);
                }
            }

            break;

        case 3:                 /* 270 degrees CCW */

            rclClip.right += iYBot;
            rclClip.left -= iYTop;

            /* Check the First Glyph. If it's just OFF by One, print it.*/
            if (abs(pgp->ptl.y - rclClip.top) == 1)
                pgp->ptl.y = rclClip.top;

            for( iIndex = 0; iIndex < cGlyphs; ++iIndex, ++pgp )
            {
                if( pgp->ptl.y >= rclClip.top &&
                    (pgp->ptl.y + asWidth[ iIndex ]) <= rclClip.bottom &&
                    pgp->ptl.x <= rclClip.right &&
                    pgp->ptl.x >= rclClip.left )
                {
                    *(pbClipBits + (iIndex >> 3) ) |= 1 << (iIndex & 0x7);
                }
            }

            break;
        }


    }
    else // Complex Clipping.
    {
        //
        // For True type font call engine to draw the text.
        //
        if ( (ptod->pfo->flFontType & TRUETYPE_FONTTYPE) && bPartialClipOn)
        {

            ptod->flFlags |= TODFL_TTF_PARTIAL_CLIPPING;

        }
        else  // Device font case. We have to clip anyway.
        {
            /*  enumerate the rectangles and see  */

            int        cGLeft;
            BOOL       bMore;
            MY_ENUMRECTS  erClip;

            /*
             *    Let the engine know how we want this handled.  All we want
             *  to set is the use of rectangles rather than trapezoids for
             *  the clipping info.  Direction of enumeration is of no great
             *  interest,  and I don't care how many rectangles are involved.
             *  I also see no reason to enumerate the whole region.
             */

            CLIPOBJ_cEnumStart( pco, FALSE, CT_RECTANGLES, CD_ANY, 0 );

            cGLeft = cGlyphs;

            do
            {
                bMore = CLIPOBJ_bEnum( pco, sizeof( erClip ), &erClip.c );

                for( iIndex = 0; iIndex < cGlyphs; ++iIndex )
                {
                    RECTL   rclGlyph;

                    if( pbClipBits[ iIndex >> 3 ] & (1 << (iIndex & 0x7)) )
                        continue;           /*  Already done!  */

                    /*
                     *   Compute the RECTL describing this char, then see
                     *  how this maps to the clipping data.
                     */

                    switch( iRot )
                    {
                    case  0:
                        rclGlyph.left = (pgp + iIndex)->ptl.x;
                        rclGlyph.right = rclGlyph.left + asWidth[ iIndex ];
                        rclGlyph.top = (pgp + iIndex)->ptl.y - iYTop;
                        rclGlyph.bottom = rclGlyph.top + iYTop + iYBot;

                        break;

                    case  1:
                        rclGlyph.left = (pgp + iIndex)->ptl.x - iYTop;
                        rclGlyph.right = rclGlyph.left + iYTop + iYBot;
                        rclGlyph.bottom = (pgp + iIndex)->ptl.y;
                        rclGlyph.top = rclGlyph.bottom - asWidth[ iIndex ];

                        break;

                    case  2:
                        rclGlyph.right = (pgp + iIndex)->ptl.x;
                        rclGlyph.left = rclGlyph.right - asWidth[ iIndex ];
                        rclGlyph.bottom = (pgp + iIndex)->ptl.y + iYTop;
                        rclGlyph.top = rclGlyph.bottom - iYTop - iYBot;

                        break;

                    case  3:
                        rclGlyph.left = (pgp + iIndex)->ptl.x - iYBot;
                        rclGlyph.right = rclGlyph.left + iYTop + iYBot;
                        rclGlyph.top = (pgp + iIndex)->ptl.y;
                        rclGlyph.bottom = rclGlyph.top + asWidth[ iIndex ];

                        break;

                    }


                    /*
                     *    Define the char as being printed if any part of it
                     *  is visible in the Y direction,  and all of it in the X
                     *  direction.  This is not really what we want for
                     *  rotated text,  but it is hard to do it correctly,
                     *  and of dubious benefit.
                     */

                    for( iClipIndex = 0; iClipIndex < erClip.c; ++iClipIndex )
                    {
                        if( rclGlyph.right <= erClip.arcl[ iClipIndex ].right  &&
                            rclGlyph.left >= erClip.arcl[ iClipIndex ].right &&
                            rclGlyph.bottom >= erClip.arcl[ iClipIndex ].top &&
                            rclGlyph.top <= erClip.arcl[ iClipIndex ].bottom )
                        {
                            /*
                             *   Got one,  so set the bit to print,  and also
                             *  decrement the count of those remaining.
                             */

                            pbClipBits[ iIndex >> 3 ] |= (1 << (iIndex & 0x7));
                            --cGLeft;

                            break;
                        }
                    }
                }

            }  while( bMore && cGLeft > 0 );

        }
    }

    if (asWidth)
    {
       MemFree(asWidth);
    }

    return;

}

VOID
VCopyAlign(
    BYTE  *pjDest,
    BYTE  *pjSrc,
    int    cx,
    int    cy
    )
/*++
Routine Description:
   Copy the source area to the destination area,  aligning the scan lines
   as they are processed.

Arguments:
    pjDest      Output area,  DWORD aligned
    pjSrc       Input area,   BYTE aligned
    cx          Number of pixels per scan line
    cy          Number of scan lines

Return Value:
    Nothing.

Note:

    1/22/1997 -ganeshp-
        Created it.
--*/

{
    /*
     *    Basically a trivial function.
     */


    int    iX,  iY;                 /* For looping through the bytes */
    int    cjFill;                  /* Extra bytes per output scan line */
    int    cjWidth;                 /* Number of bytes per input scan line */



    cjWidth = (cx + BBITS - 1) / BBITS;       /* Input scan line bytes */
    cjFill = ((cjWidth + 3) & ~0x3) - cjWidth;


    for( iY = 0; iY < cy; ++iY )
    {
        /*   Copy the scan line bytes, then fill in the trailing bits */
        for( iX = 0; iX < cjWidth; ++iX )
        {
            *pjDest++ = *pjSrc++;
        }

        pjDest += cjFill;             /* Output alignment */
    }

    return;
}


INT
ISubstituteFace(
    PDEV    *pPDev,
    FONTOBJ *pfo)
/*++
Routine Description:

    Return a device font id to substitute TrueType font with.

Arguments:

    pPDev   a pointer to PDEV
    pfo     a pointer to FONTOBJ

Return Value:

    font id

Note:

--*/
{
    PTTFONTSUBTABLE pTTFontSubDefault;
    PIFIMETRICS     pIFITT;
    FONTPDEV       *pFontPDev;
    PFONTMAP        pfm;
    WCHAR           awstrFaceName[256];

    PWSTR pwstrTTFaceName, pwstrTTFaceNameRes, pwstrDevFont, pwstrIFIFace;
    DWORD dwCountOfTTSubTable, dwSize;
    PBYTE pubResourceData;
    BOOL  bFound, bNonsquare;
    INT   iFace, iFaceSim, iI, iCountOfTTSubTable;

    iFace     = 0;
    iFaceSim  = 0;
    pFontPDev = pPDev->pFontPDev;

    //
    // if dwTTOption is DMTT_DOWNLOAD or DMTT_GRAPHICS,
    // UNIDRV doesn't substitute TrueType font.
    //
    if  (pPDev->pdm->dmTTOption != DMTT_SUBDEV)
    {
        //VERBOSE(( "ISubstituteFace: Don't substitute.\n"));
        return 0;
    }

    //
    // If TrueType font is scaled X and Y differently (non-square font),
    // we should not download.
    // Since current UNIDRV can't scale device font x and y independently.
    //

    bNonsquare = NONSQUARE_FONT(pFontPDev->pxform);
    if (bNonsquare && !(pFontPDev->flText & TC_SF_X_YINDEP))
    {
        //VERBOSE(( "ISubstituteFace: Don't substitute non-square TrueType font.\n"));
        return 0;
    }

    //
    // Get TrueType font's facename from IFIMETRICS structure.
    //

    if (!(pIFITT = pFontPDev->pIFI))
    {
        ERR(( "ISubstituteFace: Invalid pFontPDev->pIFI\n"));
        return 0;
    }

    //
    // Get TrueType font face name.
    // In substitution table, there are a list of T2 face name and Device
    // font face name.
    //

    pwstrTTFaceName = (PWSTR)((BYTE *) pIFITT + pIFITT->dpwszFamilyName);

    pTTFontSubDefault = NULL;

    if (!pFontPDev->pTTFontSubReg)
    {
        //
        // Use a default font substitution table, if there no info in registry.
        //

        bFound      = FALSE;

        pubResourceData   = pPDev->pDriverInfo->pubResourceData;
        pTTFontSubDefault  = GETTTFONTSUBTABLE(pPDev->pDriverInfo);
        iCountOfTTSubTable = (INT)pPDev->pDriverInfo->DataType[DT_FONTSUBST].dwCount;

        for (iI = 0; iI < iCountOfTTSubTable; iI++, pTTFontSubDefault++)
        {
            if (!pTTFontSubDefault->arTTFontName.dwCount)
            {
                dwSize = ILoadStringW(&pPDev->WinResData, pTTFontSubDefault->dwRcTTFontNameID, awstrFaceName, 256);
                pwstrTTFaceNameRes = awstrFaceName;
            }
            else
            {
                //
                // dwCount is supposed be the number of characters according to
                // a GPD parser.
                // However, the size is actually the size in byte.
                // We need the number of characters.
                //

                dwSize = pTTFontSubDefault->arTTFontName.dwCount/sizeof(WCHAR);
                pwstrTTFaceNameRes = (PWSTR)(pubResourceData +
                                     pTTFontSubDefault->arTTFontName.loOffset);
            }

            if (dwSize > 0 &&
                dwSize == wcslen(pwstrTTFaceName) &&
                NULL  != pwstrTTFaceNameRes)
            {
                if (!wcsncmp(pwstrTTFaceNameRes, pwstrTTFaceName, dwSize))
                {
                    bFound = TRUE;
                    break;
                }
            }

        }

        if (!bFound)
        {
            return 0;
        }

        if (pTTFontSubDefault->arDevFontName.dwCount)
        {
            pwstrDevFont = (PWSTR)(pubResourceData +
           pTTFontSubDefault->arDevFontName.loOffset);
            dwSize = pTTFontSubDefault->arDevFontName.dwCount;
        }
        else
        {
            dwSize = ILoadStringW(&pPDev->WinResData, pTTFontSubDefault->dwRcDevFontNameID, awstrFaceName, 256);
            pwstrDevFont = awstrFaceName;
        }

    }
    else
    {
        pwstrDevFont = (PWSTR)PtstrSearchTTSubstTable(pFontPDev->pTTFontSubReg,
                                                      pwstrTTFaceName);
    }

    if (!pwstrDevFont)
    {
        return 0;
    }

    //
    // Get iFace of the font name.
    //

    pfm = pFontPDev->pFontMap;

    for (iI = 1;
         iI <= pPDev->iFonts;
         iI ++, (PBYTE)pfm += SIZEOFDEVPFM() )
    {
        if( pfm->pIFIMet == NULL )
        {
            if (!BFillinDeviceFM( pPDev, pfm, iI - 1 ) )
            {
                continue;
            }
        }

        if (pfm->pIFIMet)
        {
            PIFIMETRICS pDevIFI = pfm->pIFIMet;
            BOOL        bT2Bold, bT2Italic;

            bT2Bold = (pIFITT->fsSelection & FM_SEL_BOLD) ||
                      (pfo->flFontType & FO_SIM_BOLD);
            bT2Italic = (pIFITT->fsSelection & FM_SEL_ITALIC) ||
                        (pfo->flFontType & FO_SIM_ITALIC);

            pwstrIFIFace = (WCHAR*)((BYTE *)pDevIFI + pDevIFI->dpwszFamilyName);

            //
            // (1) FaceName match.
            // (2) Character sets match.
            //      -> Set iFaceSim.
            // (3) Bold attributes match.  !(bT2Bold xor bDevBold)
            // (4) Italic attributes match. !(bT2Italic xor bDevItalic)
            //      -> Set iFace.
            //

            #if 0
            VERBOSE(( "bT2Bold=%d, bT2Italic=%d, IFIFace=%ws, DevFace=%ws\n",
                       bT2Bold, bT2Italic, pwstrIFIFace, pwstrDevFont));
            #endif
            if(!wcscmp(pwstrDevFont, pwstrIFIFace) &&
               (pIFITT->jWinCharSet == pDevIFI->jWinCharSet) &&
               ((bNonsquare && (pDevIFI->flInfo & FM_INFO_ANISOTROPIC_SCALING_ONLY)) || !bNonsquare)
              )
            {

                //
                // Substitute TrueType font with simulated device font.
                //
                if( !(((pDevIFI->fsSelection & FM_SEL_BOLD)?TRUE:FALSE) ^ bT2Bold) &&
                    !(((pDevIFI->fsSelection & FM_SEL_ITALIC)?TRUE:FALSE) ^ bT2Italic))
                {
                    //
                    // Attribute match
                    // Substitute with bold or italic face device font.
                    //
                    iFace = iI;
                    break;
                }
                else
                if (pfm->pIFIMet->dpFontSim)
                {
                    //
                    // Attribute doesn't match.
                    // Check if this device font can be simulated as bold
                    // or italic.
                    //
                    FONTSIM *pFontSim = (FONTSIM*)((PBYTE)pfm->pIFIMet +
                                        pfm->pIFIMet->dpFontSim);

                    if (! (pFontPDev->flFlags & FDV_INIT_ATTRIB_CMD))
                    {
                        pFontPDev->pCmdBoldOn = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDON);
                        pFontPDev->pCmdBoldOff = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDOFF);
                        pFontPDev->pCmdItalicOn = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICON);
                        pFontPDev->pCmdItalicOff = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICOFF);
                        pFontPDev->pCmdUnderlineOn = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEON);
                        pFontPDev->pCmdUnderlineOff = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEOFF);
                        pFontPDev->pCmdClearAllFontAttribs = COMMANDPTR(pPDev->pDriverInfo, CMD_CLEARALLFONTATTRIBS);
                        pFontPDev->flFlags |= FDV_INIT_ATTRIB_CMD;
                    }
                    if (bT2Bold && bT2Italic)
                    {
                        if( pFontSim->dpBoldItalic &&
                            pFontPDev->pCmdBoldOn  &&
                            pFontPDev->pCmdItalicOn )
                        {
                            iFaceSim = iI;
                            break;
                        }
                    }
                    else
                    if (bT2Bold)
                    {
                        if( pFontSim->dpBold &&
                            pFontPDev->pCmdBoldOn)
                        {
                            iFaceSim = iI;
                            break;
                        }
                    }
                    else
                    if (bT2Italic)
                    {
                        if (pFontSim->dpItalic &&
                            pFontPDev->pCmdItalicOn)
                        {
                            iFaceSim = iI;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (iFace)
        return iFace;
    else
        return iFaceSim;
}



PHGLYPH
PhAllCharsPrintable(
    PDEV  *pPDev,
    INT    iSubst,
    ULONG  ulGlyphs,
    PWCHAR pwchUnicode)
{
    PHGLYPH  phGlyph;
    PFONTMAP pfm;
    ULONG    ulI;
    BOOL     bRet;

    //
    // Error check
    //
    if (!pwchUnicode)
        return NULL;

    if (!(PVGetUCGlyphSetData( pPDev, iSubst)) ||
        !(pfm = PfmGetIt( pPDev, iSubst)) ||
        !(phGlyph = MemAlloc(sizeof(HGLYPH) * ulGlyphs)))
    {
        return NULL;
    }

    for (ulI = 0; ulI < ulGlyphs; ulI ++)
    {
        if (!(*(phGlyph+ulI) = HWideCharToGlyphHandle(pPDev,
                                                      pfm,
                                                      *(pwchUnicode+ulI))))
        {
            MemFree(phGlyph);
            phGlyph = NULL;
            break;
        }
    }

    return phGlyph;
}

HGLYPH
HWideCharToGlyphHandle(
    PDEV    *pPDev,
    FONTMAP *pFM,
    WCHAR    wchOrg)
/*++
Routine Description:

    Select a text color.

Arguments:

    pPDev   a pointer to PDEV
    ptod    a pointer to TO_DATA
    wchOrg  Unidrv character

Return Value:

    Glyph handle.

Note:

--*/
{
    PFONTMAP_DEV       pFMDev;
    HGLYPH             hRet;
    DWORD              dwI;
    BOOL               bFound;

    if (wchOrg < pFM->wFirstChar || pFM->wLastChar < wchOrg)
    {
        return (HGLYPH)0;
    }

    hRet   = 1;
    pFMDev = pFM->pSubFM;
    bFound = FALSE;

    if (pFM->flFlags & FM_GLYVER40)
    {
        WCRUN *pWCRuns;
        DWORD dwCRuns;

        if (!pFMDev->pUCTree)
            return (HGLYPH)0;

        dwCRuns = ((FD_GLYPHSET*)pFMDev->pUCTree)->cRuns;
        pWCRuns = ((FD_GLYPHSET*)pFMDev->pUCTree)->awcrun;

        for (dwI = 0; dwI < dwCRuns; dwI ++, pWCRuns ++)
        {
            if (pWCRuns->wcLow <= wchOrg                    &&
                wchOrg < pWCRuns->wcLow + pWCRuns->cGlyphs  )
            {
                hRet = *(pWCRuns->phg + (wchOrg - pWCRuns->wcLow));
                bFound = TRUE;
                break;
            }
        }

    }
    else
    {
        PUNI_GLYPHSETDATA  pGlyphSetData;
        PGLYPHRUN          pGlyphRun;

        if (pFMDev && pFMDev->pvNTGlyph)
        {
            pGlyphSetData = (PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph;
            pGlyphRun  = GET_GLYPHRUN(pFMDev->pvNTGlyph);
        }
        else
        {
            return (HGLYPH)0;
        }

        for (dwI = 0; dwI < pGlyphSetData->dwRunCount; dwI ++, pGlyphRun ++)
        {
            if (pGlyphRun->wcLow <= wchOrg                        &&
                wchOrg < pGlyphRun->wcLow + pGlyphRun->wGlyphCount )
            {
                hRet += wchOrg - pGlyphRun->wcLow;
                bFound = TRUE;
                break;
            }

            hRet += pGlyphRun->wGlyphCount;
        }
    }

    if (bFound)
    {
        return hRet;
    }
    else
    {
        return (HGLYPH)0;
    }
}

BOOL
BGetStartGlyphandCount(
    BYTE  *pbClipBits,
    DWORD dwEndIndex,
    DWORD *pdwStartIndex,
    DWORD *pdwGlyphToPrint)
/*++
Routine Description:

    Select a text color.

Arguments:

    pbClipBits  bit flags for character clipping
    dwTotalGlyph a total count of glyph
    pdwStartIndex a pointer to the index of starting glyph
    pdwGlyphtoPrint a pointer to the the number of glyphs to print

Return Value:

    True if there is any character to print. Otherwise False.

Note:

    Caller passes the number of characters to print in pdwGlyphCount.
    And the ID of the first character to print.

--*/
{
    DWORD  dwI;
    BOOL bRet;

    dwI = *pdwStartIndex;

    *pdwStartIndex = *pdwGlyphToPrint = 0;
    bRet = FALSE;

    for (; dwI < dwEndIndex; dwI ++)
    {
        if (pbClipBits[dwI >> 3] & (1 << (dwI & 0x07)))
        {
            if (bRet)
            {
                (*pdwGlyphToPrint)++;
            }
            else
            {
                bRet           = TRUE;
                *pdwStartIndex  = dwI;
                *pdwGlyphToPrint = 1;
            }
        }
        else
        {
            if (bRet)
            {
                break;
            }
        }
    }

    return bRet;

}

//
// If the difference between width and height is not within +-0.5%,
// returns  TRUE.
//

BOOL
NONSQUARE_FONT(
    PXFORML pxform)
{
    BOOL     bRet;
    FLOATOBJ eMa, eMb, eMc;
    FLOATOBJ Round, RoundM;

    //
    // PCL5e printers can not scale with and height of fonts idependently.
    // This function checks if font is squarely scaled.
    // It means width and height is same.
    // Also this function is functional in 0, 90, 180, and 270 degree rotation.
    // PCL5e printer can't not scale arbitrary degree, but only on 0, 90, 180,
    // and 270 degree. So this function works fine.
    //
    if (FLOATOBJ_EqualLong(&pxform->eM11, (LONG)0))
    {
        eMa = eMc = pxform->eM21;
        eMb = pxform->eM12;
    }
    else
    {
        eMa = eMc = pxform->eM11;
        eMb = pxform->eM22;
    }

    //
    // Set 0.005 (0.5%) round values.
    //
#ifndef WINNT_40 //NT 5.0
    FLOATOBJ_SetFloat(&Round, (FLOAT)0.005);
    FLOATOBJ_SetFloat(&RoundM, (FLOAT)-0.005);
#else
    FLOATOBJ_SetFloat(&Round, FLOATL_00_005);
    FLOATOBJ_SetFloat(&RoundM, FLOATL_00_005M);
#endif //!WINNT_40
    //
    // eM11 = (eM11 - eM22) / eM11
    //
    FLOATOBJ_Sub(&eMa, &eMb);
    FLOATOBJ_Div(&eMa, &eMc);

    //
    // (eM11 - eM22) / eM11 < 0.5%
    //
    bRet = FLOATOBJ_LessThan(&(eMa), &(Round)) &&
           FLOATOBJ_GreaterThan(&(eMa), &(RoundM));


    eMa = eMc;
    FLOATOBJ_Add(&eMa, &eMb);
    FLOATOBJ_Div(&eMa, &eMc);
    bRet = bRet
        || (  FLOATOBJ_LessThan(&eMa, &Round)
           && FLOATOBJ_GreaterThan(&(eMa), &(RoundM)));

    return !bRet;
}

#undef FILETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fminit.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fminit.c

Abstract:

    Font Module: device font intialization modules.

Environment:

    Windows NT Unidrv driver

Revision History:

    11/28/96 -ganeshp-
        Created

--*/

#include "font.h"

//
// Forward declarations
//

INT
IFontID2Index( FONTPDEV   *pFontPDev,
    int        iID
    );

VOID
VLoadDeviceFontsResDLLs(
    PDEV        *pPDev
    );

DWORD
CopyMemoryRLE(
    PVOID pvData,
    PBYTE pubSrc,
    DWORD dwSize
    );

//
// Functions
//

INT
IInitDeviceFonts (
    PDEV    *pPDev
    )
/*++

Routine Description:

    Doing the actual grovelling around for font data.  We have a bit
    array of available fonts (created above),  so we use that as the
    basis of filling in the rest of the information.


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    The number of fonts available.
Note:
    11-27-96: Created it -ganeshp-

--*/
{
    INT         iIndex;      // Loop index
    INT         cBIFonts;    // Fonts built in to mini-driver
    INT         cXFonts = 0; // Non-minidriver font count
    INT         cFonts;      // Total number of fonts

    //TODEL BOOL bExpand; Set when font derivatives are available.

    FONTMAP     *pfm;        // Create this data

    PFONTPDEV    pFontPDev = pPDev->pFontPDev;

    //
    //    So how many fonts do we have?   Count them so that we can allocate
    //  storage for the array of FONTMAPs.
    //

    cBIFonts = pFontPDev->iDevFontsCt;

    if (!pFontPDev->hUFFFile)
#ifdef KERNEL_MODE
        pFontPDev->hUFFFile = FIOpenFontFile(pPDev->devobj.hPrinter, pPDev->devobj.hEngine, NULL);
#else
        pFontPDev->hUFFFile = FIOpenFontFile(pPDev->devobj.hPrinter, NULL);
#endif

    if (pFontPDev->hUFFFile)
        cXFonts = FIGetNumFonts(pFontPDev->hUFFFile);
    else
        cXFonts = 0;

    pFontPDev->iSoftFontsCt = cXFonts;

    //
    // Allocate enough memory to hold font map table.
    //

    cFonts = cBIFonts + cXFonts;

    pfm = (FONTMAP *)MemAllocZ( cFonts * SIZEOFDEVPFM() );
    if( pfm == 0 )
    {
        //
        // Failed to allocate memory
        //

        cFonts = cBIFonts = cXFonts = 0;
        ERR(("Failed to allocate memory"));
    }
    else
    {
        pFontPDev->pFontMap = pfm;

        //
        //  Select the first font as the default font,  just in case the
        // value is not initialised in the loop below.
        //

        pFontPDev->pFMDefault = pfm;

        //
        //   Continue only if there are device fonts.
        //
        if( cFonts )
        {

            //
            //   Initialize the default font:  we always do this now, as it is
            //  required to return the default font at DrvEnablePDEV time,
            //  and it is also simpler for us.
            //

            iIndex = IFontID2Index( pFontPDev, pFontPDev->dwDefaultFont );

            if( iIndex >= 0 && iIndex < cFonts )
            {
                // Found the default font ID,  so now set up details

                pfm = (PFONTMAP)( (PBYTE)pFontPDev->pFontMap
                    + SIZEOFDEVPFM() * iIndex);


                //
                // Index returned by IFontID2Index is 0 based. So no need to
                // Convert it to 0 based.
                // BFillinDeviceFM assumes it to be 0 based.
                //
                if( BFillinDeviceFM( pPDev, pfm, iIndex) )
                {
                    pFontPDev->pFMDefault = pfm;
                }
                else
                {
                    WARNING(("BFillinDeviceFM Fails\n"));
                    cFonts = cBIFonts = cXFonts = 0;
                }

            }
            else
                WARNING(("No Default Font Using first as default\n"));

            //
            //   Fill in some default font sensitive numbers!
            //

            pfm->flFlags |= FM_DEFAULT;

            //
            //  Set the size of the default font
            //
            if (pfm->pIFIMet)
            {
                pPDev->ptDefaultFont.y = ((IFIMETRICS *)pfm->pIFIMet)->fwdWinAscender/2;
                pPDev->ptDefaultFont.x = ((IFIMETRICS *)pfm->pIFIMet)->fwdAveCharWidth;
            }
            else
            {
                ERR(("Bad IFI Metrics Pointer\n"));
                cFonts = cBIFonts = cXFonts = 0;
            }
        }
    }

    //
    // Check for error condition. If an error has occured set devfont to 0
    //
    if (!cFonts)
    {
        pFontPDev->iDevFontsCt    =
        pFontPDev->iDevResFontsCt =
        pFontPDev->iSoftFontsCt   = 0;
    }

    //
    // Now load any alternate resource DLLs from where device font has to be
    // loaded. This is necessary now because snapshot will be unloaded after
    // DrvEnablePDev and WinResData.pUIInfo will be invalid. Because of this
    // DLL load will fail.
    //
    VLoadDeviceFontsResDLLs(pPDev);

    pPDev->iFonts = cFonts;               /* As many as we got */

    return    cFonts;

}


BOOL
BFillinDeviceFM(
    PDEV        *pPDev,
    FONTMAP     *pfm,
    int          iIndex
    )
/*++

Routine Description:

     Fill in (most) of the FONTMAP structure passed in.   The data is
     obtained from either the minidriver resources or from from the
     font installer file.  The only part we do not set is the NTRLE
     data,  as that is a little more complex.

Arguments:

    pPDev  -    Pointer to PDEV.
    pfm    -    The FONTMAP structure to fill in
    iIndex -    The 0 based index of the font to fill in

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-04-96: Created it -ganeshp-
--*/
{

    PFONTPDEV    pFontPDev;           /* More specific data */
    PFONTMAP_DEV pfmdev;
    RES_ELEM     ResElem;             /* For manipulating resource data */

    pFontPDev = pPDev->pFontPDev;

    pfm->dwSignature = FONTMAP_ID;
    pfm->dwSize      = sizeof(FONTMAP);
    pfm->dwFontType  = FMTYPE_DEVICE;
    pfm->pSubFM      = (PFONTMAP_DEV)(pfm+1);
    pfmdev           = pfm->pSubFM;

    /*
     *   Activity depends upon whether we have an internal or
     * external font. Externals are softfonts,  other than GDI downloaded.
     */

    if( iIndex < pFontPDev->iDevFontsCt )
    {
        DWORD  dwFont;                 /* Convert index to resource number */

        /*  Get the font ID for this index  */

        dwFont = pFontPDev->FontList.pdwList[iIndex];

        //
        // Check the Font Format of the resource. The new font IFI is stored
        // with RC_UFM tag. The old one was stored using RC_FONT.
        //
        if( BGetWinRes( &(pPDev->WinResData), (PQUALNAMEEX)&dwFont, RC_FONT, &ResElem ) )
        {
            pfm->flFlags |= FM_IFIVER40;

            if( !BGetOldFontInfo( pfm, ResElem.pvResData ) )
                return   FALSE;
        }
        else
        if(BGetWinRes( &(pPDev->WinResData),(PQUALNAMEEX)&dwFont,RC_UFM,&ResElem) )
        {
            if ( !BGetNewFontInfo(pfm, ResElem.pvResData) )
                return FALSE;

            if (pPDev->bTTY)
                ((FONTMAP_DEV*)pfm->pSubFM)->ulCodepage = pFontPDev->dwTTYCodePage;
        }
        else
        {
            ERR(("Can't Load the font data for res_id= %d\n", dwFont));
            return   FALSE;
        }

        //
        // Create the data we need. Unidrv5 only supports NT specific data.
        //


        pfmdev->dwResID = dwFont;

    }
    else
    {
        INT iFont = iIndex - pFontPDev->iDevFontsCt;

        /*
         * This must be an external font,  so we need to call the
         * code that understands how external font files are built.
         */

        if( !BFMSetupXF( pfm, pPDev, iFont ) )
            return   FALSE;

        pfmdev->dwResID = iFont;
    }

    /*
     *   If needed, scale the numbers to fit the desired resolution.
     */
    if( !BIFIScale( pfm, pPDev->ptGrxRes.x, pPDev->ptGrxRes.y ) )
        return   FALSE;

    /*
     *   Miscellaneous FM fields that can now be filled in.
     */

    pfm->wFirstChar = ((IFIMETRICS *)pfm->pIFIMet)->wcFirstChar;
    pfm->wLastChar  = ((IFIMETRICS *)pfm->pIFIMet)->wcLastChar;

    /*
     *   If this is an outline font,  then mark it as scalable. This
     *  piece of information is required at font selection time.
     */

    if (((IFIMETRICS *)pfm->pIFIMet)->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
        pfm->flFlags |= FM_SCALABLE;

    /*
     *    Select the translation table for this font.  If it is zero,
     * then use the default translation table,  contained in ModelData.
     */

    if( pfmdev->sCTTid == 0 )
        pfmdev->sCTTid = (SHORT)pFontPDev->sDefCTT;

    /*
     *   Some printers output the character with the cursor positioned
     * at the baseline,  others with it located at the top of the
     * character cell.  We store the needed offset in the FONTMAP
     * data,  to simplify life during output.  The data returned by
     * DrvQueryFontData is relative to the baseline.  For baseline
     * based fonts,  we need do nothing.  For top of cell fonts,
     * the fwdWinAscender value needs to be SUBTRACTED from the Y position
     * to determine the glyph's location on the page.
     */

    //
    // Set for non-scalable font
    // This value has to be scaled for scalable device font.
    //
    if( !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
        pfm->syAdj = -((IFIMETRICS *)(pfm->pIFIMet))->fwdWinAscender;
    else
        pfm->syAdj = 0;             /* There is none */


    /*
     *   Dot matrix printers also do funny things with double high
     * characters.  To handle this, the GPC spec contains a move
     * amount to add to the Y position before printing with these
     * characters.  There is also the adjustment for position
     * movement after printing.
     */

    pfmdev->sYAdjust = (SHORT)(pfmdev->sYAdjust * pPDev->ptGrxRes.y / pfm->wYRes);
    pfmdev->sYMoved  = (SHORT)(pfmdev->sYMoved  * pPDev->ptGrxRes.y / pfm->wYRes);

    //
    // Funciton pointer initialization.
    //
    pfm->pfnDownloadFontHeader = NULL;
    pfm->pfnDownloadGlyph      = NULL;
    pfm->pfnCheckCondition     = NULL;


    //
    // PCL-XL hack
    //
    if (pPDev->ePersonality == kPCLXL)
    {
        pfm->pfnGlyphOut     = DwOutputGlyphCallback;
        pfm->pfnSelectFont   = BSelectFontCallback;
        pfm->pfnDeSelectFont = BDeselectFontCallback;
    }
    else
    if( pfm->flFlags & FM_IFIVER40 )
    {
        pfm->pfnGlyphOut     = BRLEOutputGlyph;
        pfm->pfnSelectFont   = BRLESelectFont;
        pfm->pfnDeSelectFont = BRLEDeselectFont;
    }
    else
    {
        pfm->pfnGlyphOut     = BGTTOutputGlyph;
        pfm->pfnSelectFont   = BGTTSelectFont;
        pfm->pfnDeSelectFont = BGTTDeselectFont;
    }

    if (pfm->flFlags & FM_SOFTFONT)
    {
        pfm->pfnSelectFont   = BSelectTrueTypeBMP;
    }

    if (pPDev->pOemHookInfo)
    {
        if (pPDev->pOemHookInfo[EP_OEMOutputCharStr].pfnHook)
        {
            pfm->pfnGlyphOut     = DwOutputGlyphCallback;
        }

        if (pPDev->pOemHookInfo[EP_OEMSendFontCmd].pfnHook)
        {
            pfm->pfnSelectFont   = BSelectFontCallback;
            pfm->pfnDeSelectFont = BDeselectFontCallback;
        }
    }

    if (pfm->flFlags & FM_SCALABLE)
    {
        switch (pfmdev->wDevFontType)
        {
        case DF_TYPE_HPINTELLIFONT:
        case DF_TYPE_TRUETYPE:
            pfmdev->pfnDevSelFont =  BSelectPCLScalableFont;
            break;

        case DF_TYPE_PST1:
            pfmdev->pfnDevSelFont =  BSelectPPDSScalableFont;
            break;

        case DF_TYPE_CAPSL:
            pfmdev->pfnDevSelFont =  BSelectCapslScalableFont;
            break;
        }
    }
    else
    {
        pfmdev->pfnDevSelFont = BSelectNonScalableFont;
    }

    //
    // Get Glyph data (RLE/GTT)
    //

    VFillinGlyphData( pPDev, pfm );

    return   TRUE;
}


BOOL
BFMSetupXF(
    FONTMAP   *pfm,
    PDEV      *pPDev,
    INT        iIndex
    )
/*++

Routine Description:

       Function to setup the FONTMAP data for an external font.  We take the
       next entry in the file, which is presumed to have been rewound
       before we start being called.


Arguments:

    pfm   - Pointer to FONTMAP.
    pPDev - Pointer to PDEV.
    iIndex - Index of the font.

    Return Value:

    TRUE  - for success
    FALSE - for EOF

Note:
    12-05-96: Created it -ganeshp-
--*/
{
    FONTPDEV     *pFontPDev = pPDev->pFontPDev;
    UFF_FONTDIRECTORY *pFontDir;
    DATA_HEADER  *pDataHeader;
    FONTMAP_DEV  *pFMSub;
    BOOL          bRet;

    //
    //   Not much to do.  We basically need to convert the offsets in
    // the FONTMAP in the file (mapped into memory) into absolute
    // addresses so that the remainder of the driver is ignorant of
    //  We also set some flags to make it clear
    // what type of font and memory we are.
    //

    if (!(pDataHeader = FIGetFontData(pFontPDev->hUFFFile, iIndex)))
    {
        ERR(( "FIGetFontData returns FALSE!!\n" ));
        return  FALSE;
    }

    pFMSub = pfm->pSubFM;
    if (pFontDir = FIGetFontDir(pFontPDev->hUFFFile))
    {
        pFMSub->pFontDir = pFontDir + iIndex;
    }

    //
    // Check if this is a cartridge font and set flag
    //
    if (!pFMSub->pFontDir->offCartridgeName)
        pfm->flFlags |= FM_SOFTFONT;

    pfm->flFlags |= FM_EXTERNAL;

    switch (pDataHeader->dwSignature)
    {
    case DATA_IFI_SIG:
        pfm->flFlags |= FM_GLYVER40 | FM_IFIVER40;
        BGetOldFontInfo(pfm, (PBYTE)pDataHeader + pDataHeader->wSize);
        bRet = TRUE;
        break;

    case DATA_UFM_SIG:
        BGetNewFontInfo(pfm, (PBYTE)pDataHeader + pDataHeader->wSize);
        bRet = TRUE;
        break;

    default:
        bRet = FALSE;
        break;
    }

    return  bRet;
}

//
// Misc functions
//

#define XSCALE( x )     (x) = (FWORD)((( x ) * xdpi + iXDiv / 2) / iXDiv)
#define YSCALE( y )     (y) = (FWORD)((( y ) * ydpi + iYDiv / 2) / iYDiv)
#define YSCALENEG( y )     (y) = (FWORD)((( y ) * ydpi - iYDiv / 2) / iYDiv)

BOOL
BIFIScale(
    FONTMAP   *pfm,
    INT       xdpi,
    INT       ydpi
    )
/*++

Routine Description:

    Scale the IFIMETRICS fields to match the device resolution.  The
    IFIMETRICS are created using the device's master units,  which
    may not correspond with the resolution desired this time around.
    If they are different,  then we adjust.  May also need to allocate
    memory,  because resource data cannot be written to.


Arguments:

    pfm - Pointer to FONTMAP.
    xdpi - Selcted X Graphics Resolution.
    ydpi - Selcted Y Graphics Resolution.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-05-96: Created it -ganeshp-
--*/
{
    IFIMETRICS   *pIFI;

    int     iXDiv,  iYDiv;              /* Used in scaling */

    pIFI = pfm->pIFIMet;

    if (NULL == pIFI)
    {
        return FALSE;
    }

    if( (int)pfm->wXRes != xdpi || (int)pfm->wYRes != ydpi )
    {
        /*  Need to scale,  so need memory to create writeable version */
        BYTE  *pbMem;           /* For convenience */


        if( pfm->flFlags & FM_IFIRES )
        {
            /*
             *   The data is in a resource,  so we need to do something
             * civilised: copy the data to memory that can be written.
             */

            if( pbMem = MemAllocZ( pIFI->cjThis ) )
            {
                /*   Got the memory,  so copy it and off we go  */

                CopyMemory( pbMem, (BYTE *)pIFI, pIFI->cjThis );

                pIFI = (IFIMETRICS *)pbMem;

                pfm->pIFIMet = pIFI;
                pfm->flFlags &= ~FM_IFIRES;              /* No longer */
            }
            else
                return   FALSE;
        }

        if( (int)pfm->wXRes != xdpi )
        {
            /*  Adjust the X values,  as required */

            if( !(iXDiv = pfm->wXRes) )
                iXDiv = xdpi;           /* Better than div by 0 */

            XSCALE( pIFI->fwdMaxCharInc );
            XSCALE( pIFI->fwdAveCharWidth );
            XSCALE( pIFI->fwdSubscriptXSize );
            XSCALE( pIFI->fwdSubscriptXOffset );
            XSCALE( pIFI->fwdSuperscriptXSize );
            XSCALE( pIFI->fwdSuperscriptXOffset );
            XSCALE( pIFI->ptlAspect.x );
            XSCALE( pIFI->rclFontBox.left );
            XSCALE( pIFI->rclFontBox.right );

            if (pIFI->dpFontSim)
            {
                PTRDIFF    dpTmp;
                FONTDIFF* pFontDiff;
                FONTSIM*  pFontSim;

                pFontSim = (FONTSIM*) ((PBYTE) pIFI + pIFI->dpFontSim);

                if (dpTmp = pFontSim->dpBold)
                {
                    pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);

                    XSCALE( pFontDiff->fwdMaxCharInc );
                    XSCALE( pFontDiff->fwdAveCharWidth );
                }
                if (dpTmp = pFontSim->dpItalic)
                {
                    pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);

                    XSCALE( pFontDiff->fwdMaxCharInc );
                    XSCALE( pFontDiff->fwdAveCharWidth );
                }
                if (dpTmp = pFontSim->dpBoldItalic)
                {
                    pFontDiff = (FONTDIFF*)((PBYTE)pFontSim + dpTmp);

                    XSCALE( pFontDiff->fwdMaxCharInc );
                    XSCALE( pFontDiff->fwdAveCharWidth );
                }
            }
        }

        if( (int)pfm->wYRes != ydpi )
        {
            /*
             *    Note that some of these numbers are negative,  and so
             *  we need to round them correctly - i.e. subtract the rounding
             *  factor to move the value further from 0.
             */

            int   iPixHeight;



            if( !(iYDiv = pfm->wYRes) )
                iYDiv = ydpi;

            /*  Adjust the Y values,  as required */

            /*
             *     NOTE:   simply scaling will NOT produce the same values
             *  as Win 3.1  This is because of what gets rounded.  Win 3.1
             *  does not have the WinDescender field,  but calculates it
             *  from dfPixHeight and dfAscent AFTER THESE HAVE BEEN SCALED
             *  (INCLUDING ROUNDING!!).   To emulate that,  we calculate
             *  the  dfPixHeight value,  then scale that and dfAscent to
             *  allow us to "properly" calculate WinDescender.  This stuff
             *  is needed for Win 3.1 compatability!
             */

            YSCALE( pIFI->fwdUnitsPerEm );

            iPixHeight = pIFI->fwdWinAscender + pIFI->fwdWinDescender;
            YSCALE( iPixHeight );
            YSCALE( pIFI->fwdWinAscender );

            pIFI->fwdWinDescender = iPixHeight - pIFI->fwdWinAscender;

            YSCALE( pIFI->fwdMacAscender );
            pIFI->fwdMacDescender  = -pIFI->fwdWinDescender;

            YSCALE( pIFI->fwdMacLineGap );

            YSCALE( pIFI->fwdTypoAscender );
            YSCALE( pIFI->fwdTypoDescender );
            YSCALE( pIFI->fwdTypoLineGap);

            YSCALE( pIFI->fwdCapHeight );
            YSCALE( pIFI->fwdXHeight );

            YSCALE( pIFI->fwdSubscriptYSize );
            YSCALENEG( pIFI->fwdSubscriptYOffset );
            YSCALE( pIFI->fwdSuperscriptYSize );
            YSCALE( pIFI->fwdSuperscriptYOffset );

            YSCALE( pIFI->fwdUnderscoreSize );
            if( pIFI->fwdUnderscoreSize == 0 )
                pIFI->fwdUnderscoreSize = 1;    /* In case it vanishes */

            YSCALENEG( pIFI->fwdUnderscorePosition );
            if( pIFI->fwdUnderscorePosition == 0 )
                pIFI->fwdUnderscorePosition = -1;

            YSCALE( pIFI->fwdStrikeoutSize );
            if( pIFI->fwdStrikeoutSize == 0 )
                pIFI->fwdStrikeoutSize = 1;     /* In case it vanishes */

            YSCALE( pIFI->fwdStrikeoutPosition );

            YSCALE( pIFI->ptlAspect.y );
            YSCALE( pIFI->rclFontBox.top );
            YSCALE( pIFI->rclFontBox.bottom );

#undef  XSCALE
#undef  YSCALE
#undef  YSCALENEG

        }
    }

    return  TRUE;
}

HANDLE
HLoadUniResDll(PDEV *pPDev)
{
    PWSTR  pwstrTmp, pwstrResFileName, pwstrDrvName;
    HANDLE hHandle = NULL;
    HRESULT hr = S_FALSE;

    SIZE_T cchBuf = 0;



    if (pPDev->pDriverInfo3)
        pwstrDrvName = pPDev->pDriverInfo3->pDriverPath;
    else
        return NULL;

    cchBuf = 1 + wcslen(pwstrDrvName);
    pwstrResFileName = MemAlloc( cchBuf * sizeof(WCHAR));

    if (pwstrResFileName == NULL)
        return NULL;

    hr = StringCchCopy ( pwstrResFileName, cchBuf, pwstrDrvName);
    if ( SUCCEEDED (hr) )
    {

    #ifdef WINNT_40
        if (!(pwstrTmp = wcsstr(pwstrResFileName, TEXT("UNIDRV4.DLL"))))
    #else
        if (!(pwstrTmp = wcsstr(pwstrResFileName, TEXT("UNIDRV.DLL"))))
    #endif
        {
            MemFree(pwstrResFileName);
            return NULL;
        }

        *pwstrTmp = UNICODE_NULL;

        hr = StringCchCat ( pwstrResFileName, cchBuf, TEXT("unires.dll"));

        if ( SUCCEEDED (hr) )
        {
            hHandle = EngLoadModule(pwstrResFileName);
        #ifdef DBG
            if (!hHandle)
            {
                ERR(("UNIDRV: Failed to load UNIRES.DLL\n"));
            }
        #endif
        }

    } // if StringCchCopy succeeds.

    MemFree(pwstrResFileName);

    return hHandle;

}


VOID
VFillinGlyphData(
    PDEV      *pPDev,
    FONTMAP   *pfm
    )
/*++

Routine Description:

    Provide the RLE data required for this font.  Basically look to see
    if some other font has this RLE data already loaded; if so,  then
    point to that and return.    Otherwise,  load the resource etc.


Arguments:

    pPDev - Pointer to PDEV.
    pfm   - The FONTMAP whose Gyphy Translation data is required

    Return Value:

    Nothing

Note:
    12-05-96: Created it -ganeshp-
--*/
{
    int      iIndex;         /* Scan the existing array */
    short    sCurVal;        /* Speedier access */
    BOOL     bSymbol;
    DWORD     dwCurVal;
    PQUALNAMEEX pQualName = (PQUALNAMEEX)&dwCurVal;

    PVOID     pvData;        /* The FD_GLYPHSET format we want */
    FONTMAP  *pfmIndex;      /* Speedy scanning of existing list */
    FONTMAP_DEV *pfmdev, *pfmdevIndex;

    FONTPDEV  *pFontPDev;       /* More specialised data */

    TRACE(\nUniFont!VFillinGlyphData:START);

    pvData = NULL;           /* In case Nothing we can do!  */
    pfmdev = pfm->pSubFM;
    bSymbol = IS_SYMBOL_CHARSET(pfm);

    /*
     *  First step is to look through the existing FONTMAP array,  and
     *  if we find one with the same sCTTid and same format as us,  use it!
     *  Otherwise,we need to load the resource and do it the hard way!
     */

    pFontPDev = pPDev->pFontPDev;

    if (pfm->flFlags & FM_EXTERNAL)
    {
        sCurVal = pfmdev->pFontDir->sGlyphID;
    }
    else
    {
        //
        // Minidriver Resource case.
        // RLE/GTT file must be in the same DLL as IFI/UFM is.
        //
        //
        // Convert the resource ID to fully qualied ID. The format is
        // OptionID.ResFeatureID.ResourceID. Get the option and feature ID from
        // fontmap dwRes
        //
        pQualName->wResourceID  = sCurVal = pfmdev->sCTTid;
        pQualName->bFeatureID   = pfmdev->QualName.bFeatureID;
        pQualName->bOptionID    = pfmdev->QualName.bOptionID;
    }

    pfmIndex = pFontPDev->pFontMap;

    for( iIndex = 0;
         iIndex < pPDev->iFonts;
         ++iIndex, pfmIndex = (PFONTMAP)((PBYTE)pfmIndex + SIZEOFDEVPFM()) )
    {
        pfmdevIndex = (PFONTMAP_DEV) pfmIndex->pSubFM;

        if( (pfmdevIndex                   &&
             pfmdevIndex->pvNTGlyph)       &&
             pfmIndex->pIFIMet             &&
             (pfmdevIndex->sCTTid == sCurVal)  &&
             ((pfmIndex->flFlags & FM_IFIVER40) ==
                            (pfm->flFlags & FM_IFIVER40)) &&
             ((pfmIndex->flFlags & FM_EXTERNAL) ==
                            (pfm->flFlags & FM_EXTERNAL)) &&
             pfm->pIFIMet->jWinCharSet ==
                 pfmIndex->pIFIMet->jWinCharSet )
        {
            //
            // Found it, so use that address!!
            //
            pfmdev->pvNTGlyph = pfmdevIndex->pvNTGlyph;

            //
            //Mark the flag for Glyph Data Format.
            //
            if (pfmIndex->flFlags & FM_GLYVER40)
                pfm->flFlags |= FM_GLYVER40;

            if (bSymbol)
            {
                pfm->wLastChar  = SYMBOL_END;

                if (!(pfm->flFlags & FM_IFIRES))
                    pfm->pIFIMet->wcLastChar = SYMBOL_END;
            }

            TRACE(Using a Already Loaded Translation Table.)
            PRINTVAL((pfm->flFlags & FM_GLYVER40), 0X%x);
            PRINTVAL((pfm->flFlags & FM_IFIVER40), 0X%x);
            TRACE(UniFont!VFillinGlyphData:END\n);

            return;
        }
    }


    /*
     *    Do it the hard way - load the resource, convert as needed etc.
     */


    if( sCurVal < 0 )
    {
        /* Use Predefined resource */

        DWORD  dwSize;                         /* Data size of resource */
        int    iRCType;
        HMODULE hUniResDLL;
        BYTE  *pb;

        if (!pPDev->hUniResDLL)
            pPDev->hUniResDLL = HLoadUniResDll(pPDev);

        hUniResDLL = pPDev->hUniResDLL;

        /*
         *   These are resources we have,  so we need to use
         *  the normal resource mechanism to get the data.
         */

        ASSERTMSG( hUniResDLL,("UNIDRV!vFillinGlyphData - Null Module handle \n"));
        //VERBOSE(("Using prdefined Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));
        PRINTVAL( (LONG)sCurVal, %ld );

        //
        // Load the old format RLE if the font format is NT40.
        // Otherwise, New Format PreDefined Glyph Data.
        //
        if ( hUniResDLL )
        {
            if (pfm->flFlags & FM_IFIVER40)
            {
                iRCType = RC_TRANSTAB;
            }
            else
            {
                iRCType = RC_GTT;
            }

            pb = EngFindResource( hUniResDLL, (-sCurVal), iRCType, &dwSize );

            if( pb )
            {
                if (pfm->flFlags & FM_IFIVER40)
                {
                    NT_RLE_res *pntrle_res = (NT_RLE_res*)pb;
                    dwSize = sizeof(NT_RLE) +
                             (pntrle_res->fdg_cRuns - 1) * sizeof(WCRUN) +
                             pntrle_res->cjThis - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;

                    if( !(pvData = (VOID *)MemAllocZ( dwSize )) ||
                        dwSize != CopyMemoryRLE( pvData, pb, dwSize )   )
                    {
                        MemFree(pvData);
                        pvData = NULL;
                        ERR(("\n!!!UniFont!VFillinGlyphData:MemAllocZ Failed.\
                             \nFontID = %d,Name = %ws,CTTid = %d\n\n",pfmdev->dwResID,\
                             (PBYTE)pfm->pIFIMet + pfm->pIFIMet->dpwszFaceName,(-sCurVal)));
                    }

                    pfm->flFlags |= FM_GLYVER40;
                }
                else
                {
                    if( pvData = (VOID *)MemAllocZ( dwSize ) )
                        CopyMemory( pvData, pb, dwSize );
                    else
                    {
                        ERR(("\n!!!UniFont!VFillinGlyphData:MemAllocZ Failed.\
                             \nFontID = %d,Name = %ws,CTTid = %d\n\n",pfmdev->dwResID,\
                             (PBYTE)pfm->pIFIMet + pfm->pIFIMet->dpwszFaceName,(-sCurVal)));
                    }
                }

                /* This One wil be freed when done */
                pfm->flFlags |= FM_FREE_GLYDATA;

            }
            else
            {
                ERR(("\n!!!UniFont!VFillinGlyphData:EngFindResource Failed\n"));
            }
        }

    }
    else if( pfm->flFlags & FM_EXTERNAL)
    {
        PDATA_HEADER pDataHeader;

        pDataHeader = FIGetGlyphData(pFontPDev->hUFFFile, sCurVal);
        if (pDataHeader)
            pvData = (PBYTE)pDataHeader + pDataHeader->wSize;
    }
    else
    {
        /* Use Minidriver Resources */

        RES_ELEM  re;           /* Resource summary */

        /*
         *   First step:  locate the resource,  then grab some
         *  memory for it,  copy data across.The minidriver trans
         *  table can be in two formats. NT 4.0 resource uses
         *  RC_TRANSTAB tag and the new one uses RC_GTT tag. So
         *  try using both of the and set the flFlag accordingly.
         *  If FM_GLYVER40 is off that means the resource is new
         *  format and On means old format.
         */

        if ( BGetWinRes( &(pPDev->WinResData), pQualName, RC_GTT, &re ) )
        {
            pvData = re.pvResData;
            //VERBOSE(("Using New Format Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));

        }
        else if( BGetWinRes( &(pPDev->WinResData), pQualName, RC_TRANSTAB, &re ) )
        {
            NT_RLE_res *pntrle_res = (NT_RLE_res*)re.pvResData;
            DWORD dwSize = sizeof(NT_RLE) +
                     (pntrle_res->fdg_cRuns - 1) * sizeof(WCRUN) +
                     pntrle_res->cjThis - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;

            if( !(pvData = (VOID *)MemAllocZ( dwSize )) ||
                dwSize != CopyMemoryRLE( pvData, (PBYTE)pntrle_res, dwSize )   )
            {
                MemFree(pvData);
                pvData = NULL;
                ERR(("\n!!!UniFont!VFillinGlyphData:MemAllocZ Failed.\
                     \nFontID = %d,Name = %ws,CTTid = %d\n\n",pfmdev->dwResID,\
                     (PBYTE)pfm->pIFIMet + pfm->pIFIMet->dpwszFaceName,(-sCurVal)));
            }

            if (pvData)
            {
                pfm->flFlags |= FM_FREE_GLYDATA;
            }

            pfm->flFlags |= FM_GLYVER40;
            //VERBOSE(("Using Old Format Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));
        }
        else
            pvData = NULL;           /* No translation data! */

    }

    if( pvData == NULL )
    {
        /*
         *   Presume this to mean that no translation is required.
         *  We build a special RLE table for this,  to make life
         *  easier for us.
         */
        //VERBOSE(("No specific Glyph Data for Font res_id = %d!!!\n",pfmdev->dwResID));

        if (pfm->flFlags & FM_IFIVER40)
        {
            pvData = PNTRLE1To1(bSymbol, 0x20, 0xff );
            pfm->flFlags |= FM_GLYVER40;
            TRACE(\tUsing OLD Format default Translation);
        }
        else //New Format
        {
            pvData = PNTGTT1To1(pfmdev->ulCodepage, bSymbol, 0x20, 0xff);
            TRACE(\tUsing NEW Format default Translation);
        }

        if (pvData)
        {
            pfm->flFlags |= FM_FREE_GLYDATA; /* This one will be freed when done */
            if (bSymbol)
            {
                pfm->wLastChar  = SYMBOL_END;
                if (!(pfm->flFlags & FM_IFIRES))
                    pfm->pIFIMet->wcLastChar = SYMBOL_END;
            }
        }
        else
            WARNING(("vFillInRLE - pvData was NULL\n"));
    }

    PRINTVAL((pfm->flFlags & FM_GLYVER40), 0X%x);
    PRINTVAL((pfm->flFlags & FM_IFIVER40), 0X%x);

    pfmdev->pvNTGlyph = pvData;          /* Save it for posterity */

    TRACE(UniFont!VFillinGlyphData:END\n);

    return ;
}

INT
IFontID2Index(
    FONTPDEV   *pFontPDev,
    int        iID
    )
/*++

Routine Description:

    Turns the given font ID into an index into the resource data.  The
    Font ID is a sequential number,  starting at 1, which the engine
    uses to reference our fonts.


Arguments:

    pFontPDev               For Access to device font resID list.
    iID                     The font resource ID whose index is required

Return Value:

    0 based font index,  else -1 on error.

    Note:
    11-27-96: Created it -ganeshp-

--*/
{


    int      iFontIndex;



    /*
     *  Just go through the font list. When a match is found return the index.
     */


    for( iFontIndex = 0; iFontIndex < pFontPDev->iDevFontsCt; iFontIndex++)
    {
        if( pFontPDev->FontList.pdwList[iFontIndex] == (DWORD)iID)
        {
            //
            // This function returns 0 based font index.
            //
            return iFontIndex;
        }
    }

    /*
     *    We get here when we fail to match the desired ID.  This should
     *  never happen!
     */
    return  -1;


}

VOID
VLoadDeviceFontsResDLLs(
    PDEV        *pPDev
    )
/*++

Routine Description:
      This routine loads all the DLLs which has device fonts. This is needed as
      snapshot is unloaded after DrvEnablePDEV. So in Drv Calls for font query
      pPDev->UIInfo will be NULL and BGetWinRes will fail.


Arguments:

    pPDev  - Pointer to PDEV.

Return Value:

    None

    Note:
    11-06-98: Created it -ganeshp-

--*/
{


    INT         iFontIndex;
    DWORD       dwFontResID;
    PQUALNAMEEX pQualifiedID;
    FONTPDEV    *pFontPDev;
    RES_ELEM    ResElem;

    pFontPDev    = pPDev->pFontPDev;
    pQualifiedID = (PQUALNAMEEX)&dwFontResID;

    /*
     * Just go through the font list and load each one of them if they are
     * from other resource DLL.
     */


    for( iFontIndex = 0; iFontIndex < pFontPDev->iDevFontsCt; iFontIndex++)
    {
        dwFontResID = pFontPDev->FontList.pdwList[iFontIndex];

        //
        // Check if this font is from root resource DLL. If yes then goto
        // next one.
        //
        if (pQualifiedID->bFeatureID == 0 && (pQualifiedID->bOptionID & 0x7f) == 0)
            continue;
        else
        {
            //
            // This font is not from root resource DLL so load it. We don't need
            // to look for error as we are only interested in loading the DLL.
            //
            BGetWinRes( &(pPDev->WinResData), (PQUALNAMEEX)&dwFontResID, RC_FONT, &ResElem );
        }
    }



}

DWORD
CopyMemoryRLE(
    PVOID pvData,
    PBYTE pubSrc,
    DWORD dwSize)
{
    NT_RLE_res *pntrle_res;
    NT_RLE     *pntrle;
    HGLYPH     *pHGlyph;     
    DWORD       dwOutSize = 0;
    DWORD       dwRestOfData;
    DWORD       dwSubtractNT_RLE_Header;

    ULONG ulI;

    if (pvData == NULL ||
        pubSrc == NULL  )
        return 0;

    pntrle_res = (NT_RLE_res*)pubSrc;
    pntrle     = (NT_RLE*)pvData;

    //
    // Copy first 12 bytes.
    // struct {
    //     WORD wType;
    //     BYTE bMagic0;
    //     BYTE bMagic1;
    //     DWORD cjThis;
    //     WORD wchFirst;
    //     WORD wchLast;
    //
    if (dwSize < dwOutSize + 12)
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < 12\n"));
        return 0;
    }

    CopyMemory(pntrle, pntrle_res, 12);
    dwOutSize += offsetof(NT_RLE, fdg);

    //
    // FD_GLYPHSET
    // On IA64 machine, a padding DWORD is inserted before FD_GLYPHSET.
    // 
    if (dwSize < dwOutSize + sizeof(FD_GLYPHSET) - sizeof(WCRUN))
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < sizeof(NT_RLE)\n"));
        return 0;
    }

    pntrle->fdg.cjThis           = offsetof(FD_GLYPHSET, awcrun) +
                                   pntrle_res->fdg_cRuns * sizeof(WCRUN);
    pntrle->fdg.flAccel          = pntrle_res->fdg_flAccel;
    pntrle->fdg.cGlyphsSupported = pntrle_res->fdg_cGlyphSupported;
    pntrle->fdg.cRuns            = pntrle_res->fdg_cRuns;
    dwOutSize += sizeof(FD_GLYPHSET) - sizeof(WCRUN);

    pHGlyph                      = (HGLYPH*)((PBYTE)pntrle + sizeof(NT_RLE) +
                                  (pntrle_res->fdg_cRuns - 1) * sizeof(WCRUN));

    //
    // WCRUN
    //
    if (dwSize < dwOutSize + sizeof(WCRUN) * pntrle_res->fdg_cRuns)
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < sizeof(WCRUN)\n"));
        return 0;
    }

    dwOutSize += sizeof(WCRUN) * pntrle_res->fdg_cRuns;

    //
    // NT_RLE bug workaround.
    // Some of *.RLE files have an offset from the top of NT_RLE to HGLYPH array in FD_GLYPHSET.WCRUN.phg.
    // phg needs to have an offset from the top of FD_GLYPHSET to HGLYPH array.
    //
    // Check if the offset to the last HGLYPH is larger than the whole size of memory allocation.
    // If it is, it means the offset is from the top of NT_RLE. We need to subtract offsetof(NT_RLE< fdg),
    // the size of NT_RLE header.
    //
    if (pntrle_res->fdg_wcrun_awcrun[pntrle_res->fdg_cRuns - 1].dwOffset_phg +
        sizeof(HGLYPH) * (pntrle_res->fdg_wcrun_awcrun[pntrle_res->fdg_cRuns - 1].cGlyphs - 1)
         >= dwSize - offsetof(NT_RLE, fdg))
    {
        dwSubtractNT_RLE_Header = offsetof(NT_RLE, fdg);
    }
    else
    {
        dwSubtractNT_RLE_Header = 0;
    }
 
    //
    // IA64 fix. WCRUN has the pointer to HGLYPH. The size of pointer is 8 on IA64 or 4 on X86.
    // We need to adjust phg, depending on the platform.
    // The padding DWORD before FD_GLYPHSET don't have to be considered. phg has an offset from top of FD_GLYPHSET
    // to the HGLYPH array.
    //
    for (ulI = 0; ulI < pntrle_res->fdg_cRuns; ulI ++)
    {
        pntrle->fdg.awcrun[ulI].wcLow   = pntrle_res->fdg_wcrun_awcrun[ulI].wcLow;
        pntrle->fdg.awcrun[ulI].cGlyphs = pntrle_res->fdg_wcrun_awcrun[ulI].cGlyphs;
        pntrle->fdg.awcrun[ulI].phg     = (HGLYPH*)IntToPtr(pntrle_res->fdg_wcrun_awcrun[ulI].dwOffset_phg +
                                          pntrle_res->fdg_cRuns * (sizeof(HGLYPH*) - sizeof(DWORD)) - dwSubtractNT_RLE_Header);
    }

    //
    // HGLYPH and offset data
    //
    if (dwSize < dwOutSize + sizeof(HGLYPH) * pntrle_res->fdg_cGlyphSupported)
    {
        ERR(("UNIDRV!CopyMemoryRLE: dwSize < HGLYLH array\n"));
        return 0;
    }

    if (dwSubtractNT_RLE_Header)
    {
        dwRestOfData = pntrle_res->cjThis - offsetof(NT_RLE_res, fdg_wcrun_awcrun) - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;
    }
    else
    {
        dwRestOfData = pntrle_res->cjThis - pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg;
    }
    dwOutSize += dwRestOfData;

    CopyMemory(pHGlyph, (PBYTE)pntrle_res + pntrle_res->fdg_wcrun_awcrun[0].dwOffset_phg, dwRestOfData);

    if (pntrle_res->wType == RLE_LI_OFFSET)
    {
        WORD wDiff = (WORD)(pntrle_res->fdg_cRuns * (sizeof(HGLYPH*) - sizeof(DWORD)));
        for (ulI = 0; ulI < pntrle_res->fdg_cGlyphSupported; ulI++, pHGlyph++)
        {
            ((RLI*)pHGlyph)->wOffset += wDiff;
        }
    }

    return dwOutSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmtxtout.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fmtxtout.h

Abstract:

    Unidrv Textout related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05-28-97 -eigos-
        Created

    dd-mm-yy -author-
        description

--*/

#ifndef _FMTXTOUT_
#define _FMTXTOUT_

// This is a forward declaration to build.
// Actual definition of FONTMAP is in fontmap.h
// PDLGLYPH is in download.h
//
typedef struct _FONTMAP FONTMAP;
typedef struct _DLGLYPH *PDLGLYPH;

/*
 *   WHITE TEXT:  on LJ III and later printers,  it is possible to
 *  print white text.  Doing this requires sending the white text
 *  after the graphics.  TO do this,  we store the white text details
 *  in the following structures,  then replay them after sending
 *  all the graphics.
 */

/*
 *   First is a structure to determine which glyph and where to put it.
 */

typedef  struct
{
    HGLYPH     hg;               /* The glyph's handle -> the glyph */
    POINTL     ptl;              /* It's position */
} GLYPH;


/*
 *   When some white text appears in DrvTextOut(),  we create one of these
 *  structures,  and add it to the list of such.  At the end of rendering,
 *  these are then processed using the normal sort of code in DrvTextOut().
 *
 *  NOTE that the xfo field is appropriate to scalable fonts or fonts on a
 *  printer that can do font rotations relative to the graphics.
 */

typedef  struct  _WHITETEXT
{
    struct  _WHITETEXT  *next;  // Next in list,  NULL on last
    short     sCount;           // Number of entries
    PVOID     pvColor;          // Color info - For convenience
    int       iFontId;          // Which font
    DWORD     dwAttrFlags;      // Font attribute flags, italic/bold
    FLONG     flAccel;          // STROBJ.flAccel
    GLYPHPOS  *pgp;              // Pointer to a PGLYPHPOS
    PDLGLYPH  *apdlGlyph;     // Download Glyph array. Free in BPlayWhiteText.
    INT       iRot;             // Text Rotation Angle
    FLOATOBJ  eXScale;          // X Scale factor
    FLOATOBJ  eYScale;          // Y Scale factor
    RECTL     rcClipRgn;        // Clipping region of the text(for banding)
    IFIMETRICS *pIFI;
}  WHITETEXT;

//
// Processing textout calls requires access to a considerable number
// of parameters.  To simplify function calls,  this data is accumulated
// in one structure which is then passed around.  Here is that structure.
//
//

typedef  struct _TO_DATA
{
    PDEV        *pPDev;           // The PDEV of interes
    FONTMAP     *pfm;             // Relevant font data
    FONTOBJ     *pfo;             // FONTOBJ
    FLONG       flAccel;          // STROBJ.flAccel
    GLYPHPOS    *pgp;             // Glyph data returned from the engine.
    PDLGLYPH    *apdlGlyph;       // Download Glyph array. Free
                                  // this at the end of Drvtxtout.
    PHGLYPH     phGlyph;          // For font substitution.
    WHITETEXT   *pwt;             // Current WHITETEXT
    PVOID       pvColor;          // Color of the Brush to use

    DWORD       cGlyphsToPrint;   // Number of glyph stored in pgp
    DWORD       dwCurrGlyph;      // Index of the current Glyph to print.
                                  // This is wrt all glyphs in Textout.
    INT         iFace;            // The font index to use
    INT         iSubstFace;       // The font index to substutite.
    INT         iRot;             // 90 deg multiple of font rotation.
    DWORD       dwAttrFlags;      // Font attribute
    DWORD       flFlags;          // Various Flags.
    POINTL      ptlFirstGlyph;    // Position of the first Glyph in pgp.

} TO_DATA;


#define  TODFL_FIRST_GLYPH_POS_SET  0x00000001 // Cursor is set to first glyph
#define  TODFL_DEFAULT_PLACEMENT    0x00000002 // For Default placement
#define  TODFL_TTF_PARTIAL_CLIPPING 0x00000004 // For partial clipping
#define  TODFL_FIRST_ENUMRATION     0x00000008 // For first enum of glyphs


#endif // !_FMTXTOUT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fmdevice.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontmap.h

Abstract:

    Unidrv FONTMAP and related infor header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05-19-97 -eigos-
        Created

    dd-mm-yy -author-
        description

--*/

#ifndef _FMDEVICE_
#define _FMDEVICE_

PFNGLYPHOUT  PfnDevGlyphOut;
PFNSELFONT   PfnDevSelFont;
PFNDESELFONT PfnDevDeSelFont;

#endif // !_FMDEVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\font.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    font.h

Abstract:

    Font module main header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

        dd-mm-yy -author-
                description

--*/


#ifndef _FONT_H_
#define _FONT_H_

#include "lib.h"
#include "winnls.h"
#include "unilib.h"

//
// UNIDRV resource ID
//

#include "unirc.h"

//
// Font resource format
//
#include <prntfont.h>
#include "fmoldfm.h"
#include "fmoldrle.h"

//
// GPC and GPD header
//

#include "gpd.h"
#include "uni16res.h"
#include "mini.h"

//
// Internal resource data format
//

#include "fontinst.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "common.h"
#include "fontif.h"
#include "fmcallbk.h"
#include "fmtxtout.h"
#include "fontmap.h"
#include "fontpdev.h"
#include "download.h"
#include "posnsort.h"
#include "sf_pcl.h"
#include "sfinst.h"

#include "fmfnprot.h"
#include "fmdevice.h"
#include "sfttpcl.h"

//
// Misc
//

#include "fmmacro.h"
#include "fmdebug.h"

//
// Vector plugins (HPGL2, PCLXL)
//
#include "vectorif.h"

#endif  // !_FONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fntmanag.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fntmanag.c

Abstract:

    Routine  to handle EXTENDEDTEXTMETRICS.

Environment:

    Windows NT Unidrv driver.

Revision History:

    12/30/96 -ganeshp-
        Created

--*/

#include "font.h"

ULONG
FMFontManagement(
    SURFOBJ *pso,
    FONTOBJ *pfo,
    ULONG   iMode,
    ULONG   cjIn,
    PVOID   pvIn,
    ULONG   cjOut,
    PVOID   pvOut
    )
/*++

Routine Description:
    This routine is here to provide support for EXTTEXTMETRICS.

Arguments:

   pso      SURFOBJ of interest.
   pfo      FONTOBJ whose EXTTEXTMETRICS is required.
   iMode    Specifies the escape number to be perfomed. This must either
            be equal to QUERYESCSUPPORT, or in the range 0x100 through 0x3FE.

   cjIn     Specifies the size, in bytes, of the buffer pointed to by pvIn.
   pvIn     Points to an input buffer. If the iMode parameter is
            QUERYESCSUPPORT, pvIn points to a ULONG value in the range 0x100
            through 0x3FE.

   cjOut    Specifies the size, in bytes, of the output buffer.
   pvOut    Points to the output data buffer.


Return Value:

    The return value is a value in the range 0x00000001, if the function is
    successful. If the escape is not implemented, the return value is zero.
    If the function fails, the return value is  0xFFFFFFFF.

Note:
    12-30-96: Created it -ganeshp-

--*/
{

    EXTTEXTMETRIC *pETM;

    // unlike the PSCRIPT equivilent this routine only handles GETEXTENDEDTEXTMETRICS


    if( iMode == QUERYESCSUPPORT )
    {
        return ( *((PULONG)pvIn) == GETEXTENDEDTEXTMETRICS ) ? 1 : 0;

    }
    else
    if( iMode == GETEXTENDEDTEXTMETRICS )
    {
        PDEV        *pPDev = ((PDEV  *)pso->dhpdev);
        INT         iFace = pfo->iFace;
        FONTMAP     *pFM;             /* Details of the particular font */

        if( !VALID_PDEV(pPDev) && !VALID_FONTPDEV(PFDV) )
        {
            ERR(( "UniFont!DrvFntManagement: Invalid PDEV\n" ));

            SetLastError( ERROR_INVALID_PARAMETER );
            return  (ULONG)-1;
        }

        if( iFace < 1 || ((int)iFace > pPDev->iFonts) )
        {
            ERR(( "UniFont!DrvFntManagement:  Illegal value for iFace (%ld)", iFace ));

            SetLastError( ERROR_INVALID_PARAMETER );

            return  (ULONG)-1;
        }

        if (NULL == (pFM = PfmGetDevicePFM( pPDev, iFace )))
        {
            ERR(( "UniFont!DrvFntManagement:  PfmGetDevicePFM failed.\n" ));
            return -1;
        }

        //
        // Get pETM pointer.
        // Make sure that pFM is a device font's and pSubFM is valid.
        //
        if (FMTYPE_DEVICE == pFM->dwFontType  &&
            NULL != pFM->pSubFM                )
        {
            pETM = ((PFONTMAP_DEV)pFM->pSubFM)->pETM;
        }
        else
        {
            pETM = NULL;
        }


        if( ( pFM == NULL ) || ( pETM == NULL ) )
        {
            return  0;
        }

        *((EXTTEXTMETRIC *)pvOut) = *pETM;

        return 1;

    }

    return(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fontpdev.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    FontPdev.h

Abstract:

    Unidrv FONTPDEV and related infor header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    11/06/96 -ganeshp-
        Created

        dd-mm-yy -author-
                description

--*/

#ifndef _FONTPDEV_H_
#define _FONTPDEV_H_

//
//  FONTCTL is included in FONTPDEV for controlling the state device.
//

typedef struct _FONTCTL
{
    DWORD       dwAttrFlags;  // Font attribute flags, italic/bold.
    INT         iFont;        // Font index; -ve for downloaded GDI font
    INT         iSoftFont;    // Soft Font index;
    INT         iRotate;      // Font Rotation Angle
    POINTL      ptlScale;     // Printer sizes for scalable fonts
    FLOATOBJ    eXScale;      // Font scaling in baseline direction
    FLOATOBJ    eYScale;      // Font scaling in the ascender direction
    PFONTMAP    pfm;
} FONTCTL;

//
// dwAttrFlags
//

#define FONTATTR_BOLD      0x00000001
#define FONTATTR_ITALIC    0x00000002
#define FONTATTR_UNDERLINE 0x00000004
#define FONTATTR_STRIKEOUT 0x00000008
#define FONTATTR_SUBSTFONT 0x10000000

#define INVALID_FONT       0x7FFFFFFF  // for iFont.

//
// Font Cartridges definitions.
//

#define MAXCARTNAMELEN          64

//
// Font cart mapping table. This table is a list of names and correponding
// FONTCAT structure which is filled by the parser. The actual font list
// is in the FONTCART structure.
//

typedef struct _FONTCARTMAP
{
    PFONTCART   pFontCart;         //Pointer to fontcart in GPD.
    WCHAR       awchFontCartName[MAXCARTNAMELEN]; /* Name of the Font Cart*/
    BOOL        bInstalled;         //This Font Cartridges is installed or not
} FONTCARTMAP, *PFONTCARTMAP;

//
// This structure is stored in the FontPDEV and has all the information about
// Font cartridges.
//

typedef struct _FONTCARTINFO
{
    PFONTCARTMAP    pFontCartMap;       // Font Cartridge Mapping Table.
    INT             iNumAllFontCarts;   // Number of all supported font carts.
    INT             iNumInstalledCarts;  // Number of installed cartridges.
    DWORD           dwFontCartSlots;    // Number of Font Cartridge Slots.
}FONTCARTINFO, *PFONTCARTINFO;


//
// This structe stores the Font resource ids of all the preinstalled fonts.
// This include Resident fonts plus installed Cartridge specific fonts.
//

typedef  struct  _FONTLIST_
{
    PDWORD    pdwList;               // An array of device font resource Ids.
    INT       iEntriesCt;            // Number of valid entries.
    INT       iMaxEntriesCt;         // Max number of Entries in this list
}  FONTLIST, *PFONTLIST;

//
// FONTPDEV structure
//

typedef struct _FONTPDEV {

    DWORD       dwSignature;       // FONTPDEV Signature
    DWORD       dwSize;            // FONTPDEV Size.

    PDEV        *pPDev;            // Pointer to PDEV.
    DWORD       flFlags;           // General Flags.
    DWORD       flText;            // Text Capabilities.

    DWORD       dwFontMem;         // Bytes of allocated printer memory
                                   // for font download
    DWORD       dwFontMemUsed;     // Bytes of printer memory used for
                                   // downloaded fonts
    DWORD       dwSelBits;         // Font selection bits
    POINT       ptTextScale;       // relationship between master units
                                   // and text units.
    INT         iUsedSoftFonts;    // Number of soft fonts used
    INT         iNextSFIndex;      // Index ID to use for next softfont
    INT         iFirstSFIndex;     // Value used to reset the above
    INT         iLastSFIndex;      // Largest value available
    INT         iMaxSoftFonts;     // Maximum number of Soft font per page

    INT         iDevResFontsCt;    // Num of device resident fonts.
                                   // No cartridge fonts: No soft fonts.
    INT         iDevFontsCt;       // Num of device fonts including cartridge
                                   // fonts: no soft fonts.'cBIFonts' in Rasdd
    INT         iSoftFontsCt;      // Number of SoftFonts installed.
    INT         iCurXFont;         // Index of currently selected softfont
    INT         iWhiteIndex;       // White index of the device palette
    INT         iBlackIndex;       // Black index of the device palette
    DWORD       dwDefaultFont;     // Default font
    SHORT       sDefCTT;           // Default translation table
    WORD        wReserved;         // Padding
    DWORD       dwTTYCodePage;     // Default codepage for TTY
    SURFOBJ     *pso;              // SurfObj access
    PVOID       pPSHeader;         // Position sorting header (posnsort.[hc])
    PVOID       pvWhiteTextFirst;  // Pointer to first in the White text list, if needed
    PVOID       pvWhiteTextLast;   // Pointer to the last in the White text list
    PVOID       pTTFile;           // True Type File pointer
    ULONG       pcjTTFile;         // size of True Type File
    PVOID       ptod;              // For access to TextOut Data.

    FONTMAP     *pFontMap;         // Array of FONTMAPS describing fonts.
    FONTMAP     *pFMDefault;       // Default font FONTMAP,  if != 0

    PVOID       pvDLMap;           // Mapping of GDI to downloaded info

    FONTLIST    FontList;          // This is array of font resource ids of
                                   // Device and precompiled Cartridges fonts.
    FONTCARTINFO FontCartInfo;     // This is array of font Cartridges.

    FONTCTL      ctl;              // Font state of the printer.

    IFIMETRICS  *pIFI;             // Current font IFIMETRICS cache.
    PFLOATOBJ_XFORM pxform;        // Current font XFORM

    HANDLE       hUFFFile;

    //
    // Font attribute command cache

    PCOMMAND pCmdBoldOn;
    PCOMMAND pCmdBoldOff;
    PCOMMAND pCmdItalicOn;
    PCOMMAND pCmdItalicOff;
    PCOMMAND pCmdUnderlineOn;
    PCOMMAND pCmdUnderlineOff;
    PCOMMAND pCmdClearAllFontAttribs;

    //
    // Font substitution table in registry.
    //
    TTSUBST_TABLE pTTFontSubReg;   // Font substitution table.

    //
    // Font module callback interface object
    //
    PI_UNIFONTOBJ pUFObj;

} FONTPDEV, *PFONTPDEV;

//
//General MACROes
//
#define     FONTPDEV_ID     'VDPF'      //"FPDV" in ASCII.
#define     FONTMAP_ID      'PAMF'      //"FMAP" in ASCII.
#define     MAXDEVFONT      255         // Maximum number of font entris in a
                                        // List. There may be more than one
                                        // LIST to repesent all the fonts.
//
// FONTPDEV.flflags Values
//

#define  FDV_ROTATE_FONT_ABLE       0x00000001 // Font can be rotated
#define  FDV_ALIGN_BASELINE         0x00000002 // Text is Base Line aligned
#define  FDV_TT_FS_ENABLED          0x00000004 // Text is Base Line aligned
#define  FDV_DL_INCREMENTAL         0x00000008 // always TRUE
#define  FDV_TRACK_FONT_MEM         0x00000010 // Track Memory for font DL
#define  FDV_WHITE_TEXT             0x00000020 // Can print white text
#define  FDV_DLTT                   0x00000040 // Download True Type
#define  FDV_DLTT_ASTT_PREF         0x00000080 // True Type as outline
#define  FDV_DLTT_BITM_PREF         0x00000100 // True Type as Bitmap
#define  FDV_DLTT_OEMCALLBACK       0x00000200 // True Type as Bitmap
#define  FDV_MD_SERIAL              0x00000400 // Printer is a serial printer
#define  FDV_GRX_ON_TXT_BAND        0x00000800 // Grx is drawn on Text Band
#define  FDV_GRX_UNDER_TEXT         0x00001000 // Grx is drawn under Text
#define  FDV_BKSP_OK                0x00002000 // use BkSpace to overstrike
#define  FDV_90DEG_ROTATION         0x00004000 // Supports 90 Deg Rot.
#define  FDV_ANYDEG_ROTATION        0x00008000 // Supports Any Deg Rot.
#define  FDV_SUPPORTS_FGCOLOR       0x00010000 // Supports Foreground color.
#define  FDV_SUBSTITUTE_TT          0x00020000 // Substitute TT font.
#define  FDV_SET_FONTID             0x00040000 // Soft font ID command is sent
#define  FDV_UNDERLINE              0x00080000 // Device can simlulate underline
#define  FDV_INIT_ATTRIB_CMD        0x00100000 // Initalized font attribute cmd
#define  FDV_SINGLE_BYTE            0x00200000  // ESC/P Single/Double byte mode flag
#define  FDV_DOUBLE_BYTE            0x00400000  // ESC/P Single/Double byte mode flag
#define  FDV_DISABLE_POS_OPTIMIZE   0x00800000  // Disable X position optimization
#define  FDV_ENABLE_PARTIALCLIP     0x01000000  // Enable partial clipping

//
// Misc macros
//   A macro to swap bytes in words.  Needed as PCL structures are in
// 68k big endian format.
//

#define SWAB( x )   ((WORD)(x) = (WORD)((((x) >> 8) & 0xff) | (((x) << 8) & 0xff00)))

#endif  // !_FONTPDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fontddi.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontddi.c

Abstract:

    Implementation of the DDI interface functions specific to font module.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/11/96 -ganeshp-
        Created

--*/

#include "font.h"


BOOL
FMResetPDEV(
    PDEV  *pPDevOld,
    PDEV  *pPDevNew
    )
/*++

Routine Description:
    This callback is provided to do cacheing incase of ResetPDev.

Arguments:

    pPDevOld            Pointer to Old PDEV.
    pPDevNew            Pointer to new PDEV.

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    BOOL bRet = FALSE;
    PFONTPDEV   pFontPDevNew = pPDevOld->pFontPDev,
                pFontPDevOld = pPDevOld->pFontPDev;

    /* Check the FontPdev Signature */
    if( (pFontPDevNew->dwSignature != FONTPDEV_ID) ||
        (pFontPDevOld->dwSignature != FONTPDEV_ID) )
    {
        ERR(("\nUniFont!FMResetPDEV; Bad Input PDEV\n"));
        goto ErrorExit;
    }

    bRet = TRUE;
    ErrorExit:
    /* Check for Errors */
    if (!bRet)
    {

    }

    return bRet;


}

VOID
FMDisablePDEV(
    PDEV *pPDev
    )
/*++

Routine Description:
    DrvDisablePDEV entry in Font Module. This routine frees up all the font
    module related memory.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    /* Free the Memory allocated by the font module */
    VFontFreeMem(pPDev);

}


VOID
FMDisableSurface(
    PDEV *pPDev
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{

    /*
     *    If appropriate,  free the position sorting memory. PFMPDV is macro
     *    defined in fmmacro.h. This assumes that 'pPDev' is defined.
     */

    if( PFDV->pPSHeader )
    {

        /*   Memory has been allocated,  so free it now.  */
        VFreePS( pPDev );

        /* Only once, in case */
        PFDV->pPSHeader = 0;
    }

}

BOOL
FMEnableSurface(
    PDEV *pPDev
    )
/*++

Routine Description:
    Font Module DrvEnableSurface entry. We don't do any snything.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    12-18-96: Created it -ganeshp-

--*/
{
    return TRUE;
}


BOOL
FMStartDoc(
    SURFOBJ *pso,
    PWSTR   pDocName,
    DWORD   jobId
    )
/*++

Routine Description:
    Font Module DrvStartDoc interface. No need to do any specific job.

Arguments:

    pso              Pointer to SurfOBJ
    pDocName         Document Name
    jobId            Job Id

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-18-96: Created it -ganeshp-

--*/
{
    return TRUE;

}

BOOL
FMStartPage(
    SURFOBJ *pso
    )
/*++

Routine Description:
    DrvStartPage interface. All the font specific data structures needed on
    per page basis will be created.

Arguments:

    pso              Pointer to SurfOBJ

Return Value:

    TRUE for success and FALSE for failure
Note:
    12-18-96: Created it -ganeshp-

--*/
{
    BOOL        bRet = FALSE;
    PDEV        *pPDev;
    FONTPDEV    *pFontPDev;             /* Font pdev */

    pPDev = (PDEV *)pso->dhpdev;

    pFontPDev = (FONTPDEV *)pPDev->pFontPDev;


    /*
     *  If this is NOT a page printer,  we need to initialise the position
     * sorting functions,  so that we print the page unidirectionally.
     */

    if( ((pFontPDev->flFlags & FDV_MD_SERIAL) && pPDev->iFonts) &&
        !BCreatePS( pPDev) )
    {
        ERREXIT(( "Rasdd!DrvStartPage: Cannot create text sorting areas\n" ));

    }

    bRet = TRUE;
    ErrorExit:
    return bRet;

}

BOOL
FMSendPage(
    SURFOBJ *pso
    )
/*++

Routine Description:
    This routine is called on page boundries. we play back the
    white text and free up the memory used by Text Queue.

Arguments:

    pso              Pointer to SurfOBJ

Return Value:

    TRUE for success and FALSE for failure
Note:
    12-18-96: Created it -ganeshp-

--*/
{
    PDEV  *pPDev;                       /* Access to all that is important */
    BOOL   bRet = TRUE;

    pPDev = (PDEV *) pso->dhpdev;

    if( PFDV->pvWhiteTextFirst )
    {
        /*
         *   This page contains white text.  This is stored away in a
         * separate buffer.  Now is the time to play it back.   This is
         * required because the LJ III etc require this data be sent
         * after the graphics.
         */

        bRet = BPlayWhiteText( pPDev );
    }
    if( PFDV->pPSHeader )
        VFreePS( pPDev );               /* Done with this page */

    return bRet;
}

BOOL
FMEndDoc(
    SURFOBJ *pso,
    FLONG   flags
    )
/*++

Routine Description:
    Font Module DrvEndDoc interface. We reset font module specif flags.
    Download specific data structure is also freed, so that for new document
    we download again.

Arguments:

    pso              Pointer to SurfOBJ
    flags            DrvEndDoc Flags

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-18-96: Created it -ganeshp-

--*/
{
    PDEV * pPDev = ((PDEV *)(pso->dhpdev));

    //
    // Clear Out the Text Flags based on per document.
    //
    pPDev->fMode  &= ~PF_ENUM_TEXT;
    PFDV->flFlags &= ~FDV_GRX_ON_TXT_BAND;
    PFDV->flFlags &= ~FDV_GRX_UNDER_TEXT;

     /* Free The download specific data */

    VFreeDL( (PDEV *)pso->dhpdev );
    return TRUE;
}

BOOL
FMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
/*++

Routine Description:
    Font Module StartBanding interface.
Arguments:

    pso              Pointer to SurfOBJ
    pptl             Origin of the first Band

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-19-96: Created it -ganeshp-

--*/
{
    PDEV    *pPDev;      /* Access to all that is important */

    pPDev = (PDEV *) pso->dhpdev;

    /* Mark the surface as Graphics */
    pPDev->fMode &= ~PF_ENUM_TEXT;
    pPDev->fMode &= ~PF_REPLAY_BAND;
    pPDev->fMode |= PF_ENUM_GRXTXT;
    PFDV->flFlags &= ~FDV_GRX_ON_TXT_BAND;
    PFDV->flFlags &= ~FDV_GRX_UNDER_TEXT;

    return TRUE;
}

BOOL
FMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )

/*++

Routine Description:
    Font Module StartBanding interface.
Arguments:

    pso              Pointer to SurfOBJ
    pptl             Origin of the Next Band

Return Value:

    TRUE for success and FALSE for failure
Note:
    121-19-96: Created it -ganeshp-

--*/
{
    PDEV    *pPDev;                       /* Access to all that is important */

    pPDev = (PDEV *) pso->dhpdev;


    /* Check if we need separate text band. We need a separate text band if
     * during any TextOut we fond that there is graphics data on the surface
     * under the text clipping rectangle.
     */
    if ( (pPDev->fMode & PF_FORCE_BANDING) &&
         (pPDev->fMode & PF_ENUM_GRXTXT) &&
         (PFDV->flFlags & FDV_GRX_UNDER_TEXT))
    {
        /* Mark the surface as Text */
        pPDev->fMode |= PF_ENUM_TEXT;
        pPDev->fMode |= PF_REPLAY_BAND;
        pPDev->fMode &= ~PF_ENUM_GRXTXT;
    }
    else if (pPDev->fMode & PF_ENUM_TEXT) /* If This is a Text Band */
    {
        /* Mark the surface as Graphics */
        pPDev->fMode &= ~PF_ENUM_TEXT;
        pPDev->fMode &= ~PF_REPLAY_BAND;
        pPDev->fMode |= PF_ENUM_GRXTXT;
        PFDV->flFlags &= ~FDV_GRX_ON_TXT_BAND;
        PFDV->flFlags &= ~FDV_GRX_UNDER_TEXT;
    }

    if( PFDV->pPSHeader )
    {
        if (((PSHEAD*)(PFDV->pPSHeader))->ppPSGSort)
        {
            MemFree(((PSHEAD*)(PFDV->pPSHeader))->ppPSGSort);
            ((PSHEAD*)PFDV->pPSHeader)->ppPSGSort = NULL;
        }
    }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fontfree.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontfree.c

Abstract:

Frees any font memory,  no matter where allocated.  This should be
called from DrvDisableSurface to free any memory allocated for
holding font information.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/03/97 -ganeshp-
        Created

--*/

#include "font.h"



VOID
VFontFreeMem(
    PDEV   *pPDev
    )
/*++

Routine Description:

    Called to free all memory allocated for font information.
    Basically we track through all the font data contained in
    FONTPDEV,  freeing as we come across it.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value: None.


Note:
    01-03-97: Created it -ganeshp-
--*/
{

    /*
     *   The PDEV contains only one thing of interest to us - a pointer
     * to the FONTPDEV,  which contains all the font memory.
     */

    register  FONTMAP   *pFM;           /* Working through per font data */
    int                 iIndex;
    FONTPDEV            *pFontPDev;
    FONTMAP_DEV         *pFMDev;


    pFontPDev = pPDev->pFontPDev;

    if (pFontPDev)
        pFM = pFontPDev->pFontMap;    /* The per font type data */
    else
    {
        WARNING(("\nUnifont!VFontFreeMem: NULL pFontPDev\n"));
        return;
    }

    /*
     *   If there is font stuff,  free it up now.
     */

    if( pFM )
    {
        /*   Loop through per font */
        for( iIndex = 0;
             iIndex < pPDev->iFonts;
             ++iIndex, (PBYTE)pFM += SIZEOFDEVPFM() )
        {
            pFMDev = pFM->pSubFM;

            if (pFM->dwSignature != FONTMAP_ID)
                continue;

            /*   The UNICODE tree data */
            if( pFMDev->pUCTree )
                MEMFREEANDRESET(pFMDev->pUCTree );

            /*   May also need to free the translation table */
            if( pFM->flFlags & FM_FREE_GLYDATA && pFMDev->pvNTGlyph)
            {
                pFM->flFlags &= ~FM_FREE_GLYDATA;
                MEMFREEANDRESET(pFMDev->pvNTGlyph );

            }


            /*   The IFIMETRICS data */
            if( pFM->pIFIMet )
            {
                if (pFM->flFlags & FM_IFIRES)
                {
                    /*  Data is a resource,  so No need to free. */
                }
                else
                {
                    MEMFREEANDRESET(pFM->pIFIMet);
                }
            }

            if( !(pFM->flFlags & FM_FONTCMD) )
            {
                /*   The font select/deselect commands - if present */
                if( pFMDev->cmdFontSel.pCD)
                    MEMFREEANDRESET(pFMDev->cmdFontSel.pCD);

                if( pFMDev->cmdFontDesel.pCD)
                    MEMFREEANDRESET(pFMDev->cmdFontDesel.pCD);
            }

            /*   Free the width table,  if one is allocated */
            if( pFMDev->W.psWidth )
            {
                if( !(pFM->flFlags & FM_WIDTHRES) )
                    MEMFREEANDRESET(pFMDev->W.psWidth );
            }
        }

        /*   Finally - free the FONTMAP array!  */
        MEMFREEANDRESET(pFontPDev->pFontMap );
    }

    pPDev->iFonts = 0;


    /*
     *   There may also be font installer information to free up.
     */


    /*
     *   Free the downloaded font information.  This MUST be done whenever
     *  the printer is reset (and thus looses fonts), which typically
     *  is an event that happens during DrvRestartPDEV.
     */

    VFreeDL( pPDev );

    /* Free the Text sorting array, if allocated */
    if (pFontPDev->pPSHeader)
    {

        VFreePS( pPDev );
    }

    if (pFontPDev)
    {
        /* Free different structuress */
        if (pFontPDev->FontList.pdwList)
            MEMFREEANDRESET(pFontPDev->FontList.pdwList);

        if (pFontPDev->FontCartInfo.pFontCartMap)
            MEMFREEANDRESET(pFontPDev->FontCartInfo.pFontCartMap);

        if (pFontPDev->pTTFontSubReg)
            MEMFREEANDRESET(pFontPDev->pTTFontSubReg);

        if (pFontPDev->hUFFFile)
            FICloseFontFile(pFontPDev->hUFFFile);

        MEMFREEANDRESET(pFontPDev);
        pPDev->pFontPDev = NULL;

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fonts.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    font.c

Abstract:

    Functions associated with fonts - switching between, downloading etc.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/19/96 -ganeshp-
        Created

--*/

#include "font.h"
#include "math.h"

//
// Local Function Prototypes.
//

BOOL
BDeselectFont(
    PDEV        *pPDev,
    FONTMAP     *pfm,
    INT         iFont
    );





VOID
VResetFont(
    PDEV   *pPDev
    )
/*++
Routine Description:

Arguments:
    pPDev   Pointer to PDEV

Return Value:
    TRUE for success and FALSE for failure

Note:

    8/7/1997 -ganeshp-
        Created it.
--*/
{
    FONTPDEV  *pFontPDev;            /* UNIDRVs PDEV */

    //
    // All we have to do is to set the iFont to INVALID_FONT.
    //
    pFontPDev = PFDV;
    pFontPDev->ctl.iFont = INVALID_FONT;
    FTRC(\nUniFont!VResetFont:Reselecting Current Font\n);
    return;
}


BOOL
BNewFont(
    PDEV    *pPDev,
    int      iNewFont,
    PFONTMAP pfm,
    DWORD    dwFontAttrib)
/*++

Routine Description:
    Switch to a new font.   This involves optionally deselecting
    the old font,  selecting the new font,  then recording the new
    font as active AND setting the font's attributes.

Arguments:

    pPDev           Pointer to PDEV
    iNewFont        The font we want, 1 BASED!!!!!
    pfm             Pointer to FONTMAP
    dwFontAttr      Font attribute

Return Value:

     TRUE/FALSE - TRUE if font changed,  else FALSE.

Note:
    12-19-96: Created it -ganeshp-

--*/
{
    FONTPDEV    *pFontPDev;
    POINTL    ptl;  // For size comparisons in scalable fonts
    FWORD     fwdUnitsPerEm, fwdAveCharWidth, fwdMaxCharInc, fwdWinAscender;
    BOOL      bRet; // What we return

    bRet = TRUE;
    pFontPDev = PFDV;
    fwdAveCharWidth = 0;
    fwdUnitsPerEm   = 0;
    fwdWinAscender  = 0;

    //
    // First check to see if a new font is needed.   Compare the
    // font index first,  then check if it is a scalable font, and
    // if so,  whether the transform has changed.
    //

    if ( !pfm && !(pfm = PfmGetIt( pPDev, iNewFont )) )
    {
        ASSERTMSG(FALSE,("\nUniFont!BNewFont:Null pfm passed in and PfmGetIt failed\n"));
        return FALSE;
    }

    if( pfm->flFlags & FM_SCALABLE )
    {
        // Device Scalable or TrueType outline download
        //
        // Calculate the new height/width.  If we have the same font AND
        // and the same point size,  we return as all is now done.
        // Otherwise, go through the works.
        //

        if (dwFontAttrib & FONTATTR_SUBSTFONT)
        {
            fwdAveCharWidth = ((FONTMAP_DEV*)(pfm->pSubFM))->fwdFOAveCharWidth;
            fwdUnitsPerEm   = ((FONTMAP_DEV*)(pfm->pSubFM))->fwdFOUnitsPerEm;
            fwdWinAscender  = ((FONTMAP_DEV*)(pfm->pSubFM))->fwdFOWinAscender;
        }
        else // Device font or TT Outline download case
        {
            fwdAveCharWidth = ((IFIMETRICS*)(pfm->pIFIMet))->fwdAveCharWidth;
            fwdUnitsPerEm   = ((IFIMETRICS*)(pfm->pIFIMet))->fwdUnitsPerEm;
            fwdWinAscender  = ((IFIMETRICS*)(pfm->pIFIMet))->fwdWinAscender;
        }

        bRet = BGetPSize( pFontPDev, &ptl, fwdUnitsPerEm, fwdAveCharWidth);

        if( !bRet ||
            pFontPDev->ctl.iFont == iNewFont &&
            pFontPDev->ctl.iSoftFont == (INT)pfm->ulDLIndex &&
            pFontPDev->ctl.ptlScale.x == ptl.x &&
            pFontPDev->ctl.ptlScale.y == ptl.y  )
        {
            bRet = FALSE;
        }
    }
    else
    {
        //
        // Bitmap font. only check indices
        //

        if( (iNewFont == pFontPDev->ctl.iFont) &&
            (pFontPDev->ctl.iSoftFont == (INT)pfm->ulDLIndex  ||
            (INT)pfm->ulDLIndex == -1))
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    //
    // Need to change a font.
    //
    {
#if 0
        VERBOSE(("\n---------Previous font\n"));
        VERBOSE(("iFont        =%d\n", pFontPDev->ctl.iFont));
        VERBOSE(("ulDLIndex    =%d\n", pFontPDev->ctl.iSoftFont));
        VERBOSE(("ptlScale.x   =%d\n", pFontPDev->ctl.ptlScale.x));
        VERBOSE(("ptlScale.y   =%d\n", pFontPDev->ctl.ptlScale.y));

        VERBOSE(("\n         New font\n"));
        if (pfm->flFlags & FM_SCALABLE)
        {
            VERBOSE((" Scalable font\n"));
        }
        else
        {
            VERBOSE((" NonScalable font\n"));
        }
        VERBOSE(("iFont        =%d\n", iNewFont));
        VERBOSE(("ulDLIndex    =%d\n", pfm->ulDLIndex));
        VERBOSE(("ptlScale.x   =%d\n", ptl.x));
        VERBOSE(("ptlScale.y   =%d\n\n", ptl.y));
#endif

        if (BDeselectFont( pPDev, pFontPDev->ctl.pfm, pFontPDev->ctl.iFont) &&
            BUpdateStandardVar(pPDev, pfm, 0, dwFontAttrib, STD_FH|
                                                            STD_FW|
                                                            STD_FB|
                                                            STD_FI|
                                                            STD_FU|
                                                            STD_FS) &&
            pfm->pfnSelectFont( pPDev, pfm, &ptl)      )
        {
            //
            // New font available - so update the red tape
            //

            pFontPDev->ctl.iFont     = (short)iNewFont;
            pFontPDev->ctl.iSoftFont = (INT)pfm->ulDLIndex;
            pFontPDev->ctl.ptlScale  = ptl;
            pFontPDev->ctl.pfm       = pfm;

            //
            // Need to scale syAdj for UPPERLEFT character position fonts.
            //

            if( pfm->flFlags & FM_SCALABLE)
            {
                if ( (pfm->dwFontType == FMTYPE_DEVICE) &&
                     !(pFontPDev->flFlags & FDV_ALIGN_BASELINE) )
                    {
                        FLOATOBJ fo;
                        int   iTmp;           /* Temporary holding variable */

                        fo = pFontPDev->ctl.eYScale;
                        FLOATOBJ_MulLong(&fo,
                                fwdWinAscender);
                        pfm->syAdj = -(SHORT)FLOATOBJ_GetLong(&fo);
                    }
             }


            //
            //  Set the desired mode info into the FONTPDEV
            //

            if( pfm->dwFontType == FMTYPE_DEVICE &&
                 ((FONTMAP_DEV*)pfm->pSubFM)->fCaps & DF_BKSP_OK )
                pFontPDev->flFlags |= FDV_BKSP_OK;
            else
                pFontPDev->flFlags &= ~FDV_BKSP_OK;

            bRet = BSetFontAttrib( pPDev, 0, dwFontAttrib, TRUE);
        }
        else
            bRet = FALSE;
    }
    else
    //
    // Just change the font attribute
    //
    {
        if (pFontPDev->ctl.dwAttrFlags != dwFontAttrib)
        {
            BUpdateStandardVar(pPDev, pfm, 0, dwFontAttrib, STD_FH|
                                                            STD_FW|
                                                            STD_FB|
                                                            STD_FI|
                                                            STD_FU|
                                                            STD_FS);
            if (!(pfm->dwFontType == FMTYPE_TTOUTLINE) &&
                !(pfm->dwFontType == FMTYPE_TTOEM)      )
            {
                bRet = BSetFontAttrib( pPDev,
                                       pFontPDev->ctl.dwAttrFlags,
                                       dwFontAttrib, FALSE);
            }
        }
    }

    return  bRet;

}


BOOL
BDeselectFont(
    PDEV        *pPDev,
    FONTMAP     *pfm,
    INT         iFont
    )
/*++

Routine Description:
    Issues a deselect command for the given font.

Arguments:

    pPDev           Pointer to PDEV.
    iFont           Font index to be unselected,  1 based

Return Value:

     TRUE/FALSE - FALSE if the command write fails.

Note:
    12-23-96: Created it -ganeshp-

--*/
{
    //
    // iFont < 1: TrueType font case
    // iFont == 0: This is a first call of SelectFont
    //
    // In these cases, just return TRUE;
    //
    if( iFont == INVALID_FONT)
            return  TRUE;

    if( !pfm )
    {
        ASSERTMSG((FALSE),("\nUniFont!BDeselectFont: NULL pfm\n"));
        return   FALSE;
    }

    return  pfm->pfnDeSelectFont(pPDev, pfm);
}


FONTMAP *
PfmGetIt(
    PDEV *pPDev,
    INT   iIndex)
{
    FONTMAP *pfm;

    //
    // Font indexes Less than equal to 0 are for downloaded fonts and greater
    // than 0 ( from 1 ) are for device fonts.
    //

    if (iIndex <= 0)
    {
        DL_MAP  *pdm;

        //
        // Assume +ve from here on.
        //
        iIndex = -iIndex;

        if (NULL != (pdm = PGetDLMapFromIdx ((PFONTPDEV)(pPDev->pFontPDev),iIndex)))
        {
            pfm = pdm->pfm;
        }
        else
        {
            ERR(("PfmGetIf failed\n"));
            pfm = NULL;
        }
    }
    else
    {
        pfm = PfmGetDevicePFM(pPDev, iIndex);
    }

    return pfm;
}

FONTMAP *
PfmGetDevicePFM(
    PDEV   *pPDev,
    INT     iIndex
    )
/*++

Routine Description:
    Returns the address of the FONTMAP structure corresponding to the
    iDLIndex entry of the downloaded GDI fonts.

Arguments:

    pPDev           Pointer to PDEV.
    iFont           Font index to be unselected,  1 based

Return Value:

     The address of the FONTMAP structure; 0 on error.

Note:
    12-23-96: Created it -ganeshp-

--*/
{
    FONTPDEV   *pFontPDev;       /* FM PDEV */
    FONTMAP   *pfm;           /* What we return */
    DL_MAP_LIST  *pdml;       /* The linked list of chunks */


    pFontPDev = pPDev->pFontPDev;
    pfm = NULL;               /* Serious error return value */

    if( iIndex > 0 )
    {
        /*
         *   With lazy fonts,  first check that the font count has
         *  been initialised.  This means that the font infrastructure
         *  has been created,  and so we can then go on to the more
         *  detailed data.
         */

        if( iIndex >= 1 && iIndex <= pPDev->iFonts )
        {
            pfm = (PFONTMAP)((PBYTE)pFontPDev->pFontMap
                     + (SIZEOFDEVPFM() * (iIndex - 1)) );

            if( pfm->pIFIMet == NULL )
            {
                /*  Initialise this particular font  */
                if( !BFillinDeviceFM( pPDev, pfm, iIndex - 1) )
                {
                    pfm = NULL;             /* Bad news */
                }
            }
        }
    }

    return pfm;
}


BOOL
BGetPSize(
    FONTPDEV    *pFontPDev,
    POINTL      *pptl,
    FWORD        fwdUnitsPerEm,
    FWORD        fwdAveCharWidth
    )
/*++

Routine Description:
    Apply the font transform to obtain the point size for this font.

Arguments:

     pFontPDev      Access to font stuff
     pptl               Where to place the results
     pfm                Gross font details

Return Value:

    TRUE/FALSE,   TRUE for success.

Note:
    12-26-96: Created it -ganeshp-

--*/
{


    int   iTmp;           /* Temporary holding variable */
    FLOATOBJ fo;
    PIFIMETRICS   pIFI;   /* Ifimetrics of interest */

    /*
     *   The XFORM gives us the scaling factor from notional
     * to device space.  Notional is based on the fwdEmHeight
     * field in the IFIMETRICS,  so we use that to convert this
     * font height to scan lines.  Then divide by device
     * font resolution gives us the height in inches, which
     * then needs to be converted to point size (multiplication
     * by 72 gives us that).   We actually calculate to
     * hundredths of points, as PCL has this resolution. We
     * also need to round to the nearest quarter point.
     *
     *   Also adjust the scale factors to reflect the rounding of the
     * point size which is applied.
     */

#ifdef   USEFLOATS

    /*   Typically only the height is important: width for fixed pitch */
    iTmp = (int)(0.5 + pFontPDev->ctl.eYScale * fwdUnitsPerEm * 7200) /
                                                pFontPDev->pPDev->ptGrxRes.y;

    /* if the tranform is very small (Less than a quarter of point size)
    * then make it atleast a quarter point. This was causing AV in certain
    * cases.
    */
    if (iTmp < 25)
    {
        WARNING((UniFont!BGetPSize: Too Small Font Size));
        iTmp = 25;
    }

    pptl->y = ((iTmp + 12) / 25) * 25;

    pFontPDev->ctl.eYScale = (pFontPDev->ctl.eYScale * pptl->y) /iTmp;
    pFontPDev->ctl.eXScale = (pFontPDev->ctl.eXScale * pptl->y) /iTmp;

    iTmp = (int)(pFontPDev->ctl.eXScale * fwdAveCharWidth)

   /* if the tranform is very small, so that the width is Less than a 1 pixel,
    * then make it atleast a 1 pixel point. This was causing AV in certain
    * cases.
    */

    if (iTmp < 1)
    {
        iTmp = 1;
    }

    /*   Width factor chars per inch:  fixed pitch fonts only */
    iTmp = (100 *  pFontPDev->pPDev->ptGrxRes.x) / iTmp;

    pptl->x = ((iTmp + 12) / 25) * 25;
#else

    /*   Typically only the height is important: width for fixed pitch */

    fo = pFontPDev->ctl.eYScale;
    FLOATOBJ_MulLong(&fo,fwdUnitsPerEm);
    FLOATOBJ_MulLong(&fo,7200);
    #ifndef WINNT_40 //NT 5.0

    FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

    #else // NT 4.0


    FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

    #endif //!WINNT_40

    iTmp = FLOATOBJ_GetLong(&fo);
    iTmp /= pFontPDev->pPDev->ptGrxRes.y;
    /* if the tranform is very small (Less than a quarter of point size)
     * then make it atleast a quarter point. This was causing AV in certain
     * cases.
     */
    if (iTmp < 25)
    {
        WARNING(("UniFont!BGetPSize: Too Small Font Height, iTmp = %d\n",iTmp));
        iTmp = 25;

    }

    pptl->y = ((iTmp + 12) / 25) * 25;

    
    //
    // If there is any arounding error, disable x position optimization.
    // The optimization code introduces positioning problem on TrueType font.
    //
    if (iTmp != pptl->y)
    {
        pFontPDev->flFlags |= FDV_DISABLE_POS_OPTIMIZE;
    }
    else
    {
        pFontPDev->flFlags &= ~FDV_DISABLE_POS_OPTIMIZE;
    }

    FLOATOBJ_MulLong(&pFontPDev->ctl.eYScale,pptl->y);
    FLOATOBJ_DivLong(&pFontPDev->ctl.eYScale,iTmp);

    FLOATOBJ_MulLong(&pFontPDev->ctl.eXScale,pptl->y);
    FLOATOBJ_DivLong(&pFontPDev->ctl.eXScale,iTmp);

    /*   Width factor:  fixed pitch fonts only */
    fo = pFontPDev->ctl.eXScale;
    FLOATOBJ_MulLong(&fo,fwdAveCharWidth);

    iTmp = FLOATOBJ_GetLong(&fo);

   /* if the tranform is very small, so that the width is Less than a 1 pixel,
    * then make it atleast a 1 pixel point. This was causing AV in certain
    * cases.
    */

    if (iTmp < 1)
    {
        iTmp = 1;

    }

    /*   Width factor chars per inch in 100s:  fixed pitch fonts only */
    iTmp = (100 * pFontPDev->pPDev->ptGrxRes.x) / iTmp;

    pptl->x = ((iTmp + 12) / 25) * 25;      /* To nearest quarter point */

#endif

    return  TRUE;

}




INT
ISetScale(
    FONTCTL    *pctl,
    XFORMOBJ   *pxo,
    BOOL       bIntellifont,
    BOOL       bAnyRotation
)
/*++

Routine Description:
    Looks at the XFORM to determine the nearest right angle direction.
    This function is useful for scalable fonts on LaserJet printers,
    where the device can rotate fonts in multiples of 90 degrees only.
    We select the nearest 90 degree multiple.

Arguments:

    pctl            Where the output is placed.
    pxo             The transform of interest
    bIntellifont    TRUE for Intellifont width adjustment

Return Value:

    Printer is able rotate any rotation (bAnyRotation is TRUE)
        Degress (0 - 359)

    Printer is not able rotate any rotation (bAnyRotation is FALSE)
        Multiple of 90 degress,  i.e.  0 - 3, 3 being 270 degrees.

Note:
    12-26-96: Created it -ganeshp-

--*/
{

    /*
     *    The technique is quite simple.  Take a vector and apply the
     *  transform.  Look at the output and compare the (x, y) components.
     *  The vector to transform is (100 000,  0), so any rotations, shears
     *  etc are very obvious.
     */

    int      iRet;                /* Value to return */

#ifdef USEFLOATS

    XFORM xform;         /* Obtain the full XFORM then select */

    XFORMOBJ_iGetXform( pxo, &xform );


    /*
     *     This logic is based on the following data:-
     *
     *   Angle    eM11     eM12     eM21      eM22
     *      0       S        0        0         S
     *     90       0       -S        S         0
     *    180      -S        0        0        -S
     *    270       0        S       -S         0
     *
     *  The value S is some non-zero value,  being the scaling
     *  factor from notional to device.
     */



    /*
     *   Further notes on the eXScale and eYScale values.  The eXScale field
     *  is hereby defined as being the value by which x values in font metrics
     *  are scaled to produce the desired value.  IF the font is rotated
     *  by either 90 or 270 degrees,  then this x value ultimately ends up
     *  in the y direction,  but this is not important.
     */

    if( xform.eM11 )
    {
        /*   Either 0 or 180 rotation  */

        if( xform.eM11 > 0 )
        {
            /*   Normal case,  0 degree rotation */
            iRet = 0;
            pctl->eXScale = xform.eM11;
            pctl->eYScale = xform.eM22;
        }
        else
        {
            /*   Reverse case,  180 degree rotation */
            iRet = 2;
            pctl->eXScale = -xform.eM11;
            pctl->eYScale = -xform.eM22;
        }
    }
    else
    {
        /*  Must be 90 or 270 degree rotation */

        if( xform.eM12 < 0 )
        {
            /*   The 90 degree case  */
            iRet = 1;
            pctl->eXScale = xform.eM21;
            pctl->eYScale = -xform.eM12;
        }
        else
        {
            /*   The 270 degree case  */
            iRet = 3;
            pctl->eXScale = -xform.eM21;
            pctl->eYScale = xform.eM12;
        }
    }

    /*
     *    Width tables are based on Intellifont's 72.31 points to the inch.
     */

    if( bIntellifont )
        pctl->eXScale = pctl->eXScale * (FLOAT)72.0 / (FLOAT)72.31;

    return  iRet;

#else

    FLOATOBJ_XFORM xform;         /* Obtain the full XFORM then select */

    XFORMOBJ_iGetFloatObjXform( pxo, &xform );


    /*
     *     This logic is based on the following data:-
     *
     *   Angle    eM11     eM12     eM21      eM22
     *      0       S        0        0         S
     *     90       0       -S        S         0
     *    180      -S        0        0        -S
     *    270       0        S       -S         0
     *
     *  The value S is some non-zero value,  being the scaling
     *  factor from notional to device.
     */



    /*
     *   Further notes on the eXScale and eYScale values.  The eXScale field
     *  is hereby defined as being the value by which x values in font metrics
     *  are scaled to produce the desired value.  IF the font is rotated
     *  by either 90 or 270 degrees,  then this x value ultimately ends up
     *  in the y direction,  but this is not important.
     */

    if(!FLOATOBJ_EqualLong(&xform.eM11,0) )
    {
        double rotate;

        //
        // R != 90 & R != 270
        // 

        if( FLOATOBJ_GreaterThanLong(&xform.eM11,0) )
        {
            //
            // 0 <= R  < 90 or 270 < R <= 360
            //
            if (FLOATOBJ_EqualLong(&xform.eM21, 0))
            {
                //
                // R = 0
                //
                iRet = 0;
            }
            else
            if (FLOATOBJ_GreaterThanLong(&xform.eM21, 0))
            {
                //
                // 0 < R < 90
                //
                    iRet = 0;
            }
            else
            {
                //
                // 270 < R < 360
                //
                if (bAnyRotation)
                    iRet = 270;
                else
                    iRet = 3;
            }

#ifndef WINNT_40 // NT 5.0
            if (bAnyRotation)
            {
#pragma warning( disable: 4244)
                        rotate = atan2(xform.eM21, xform.eM11);
                        rotate *= 180;
                        rotate /= FLOATL_PI;
                        if (rotate < 0)
                            rotate += 360;
                        iRet = rotate;
#pragma warning( default: 4244)
            }
#endif

        }
        else
        {
            //
            // 90 < R < 270
            //

            if ( FLOATOBJ_EqualLong(&xform.eM21, 0))
            {
                //
                // R = 180
                //
                if (bAnyRotation)
                    iRet = 180;
                else
                    iRet = 2;
            }
            else
            if ( FLOATOBJ_GreaterThanLong(&xform.eM21, 0))
            {
                //
                // 90 < R < 180
                // 
                if (bAnyRotation)
                    iRet = 90;
                else
                    iRet = 1;
            }
            else
            {
                //
                // 180 < R < 270
                //
                if (bAnyRotation)
                    iRet = 180;
                else
                    iRet = 2;
            }

#ifndef WINNT_40 // NT 5.0
            if (bAnyRotation)
            {
#pragma warning( disable: 4244)
                        rotate = atan2(xform.eM21, xform.eM11);
                        rotate *= 180;
                        rotate /= FLOATL_PI;
                        if (rotate < 0)
                            rotate += 360;
                        iRet = rotate;
#pragma warning( default: 4244)
            }
#endif

            FLOATOBJ_Neg(&xform.eM11);
            FLOATOBJ_Neg(&xform.eM22);

        }

#ifndef WINNT_40 // NT 5.0
        if (bAnyRotation)
        {
#pragma warning( disable: 4244)
            pctl->eXScale = sqrt(xform.eM11 * xform.eM11 + xform.eM12 * xform.eM12);
            pctl->eYScale = sqrt(xform.eM22 * xform.eM22 + xform.eM21 * xform.eM21);
#pragma warning( default: 4244)
        }
        else
#endif
        {
            pctl->eXScale = xform.eM11;
            pctl->eYScale = xform.eM22;
        }
    }
    else
    {
        //
        // 90 or 270
        //

        if( FLOATOBJ_GreaterThanLong(&xform.eM21,0) )
        {
            //
            // 90
            //
            if (bAnyRotation)
                iRet = 90;
            else
                iRet = 1;

            FLOATOBJ_Neg(&xform.eM12);
        }
        else
        {
            //
            // 270
            //
            if (bAnyRotation)
                iRet = 270;
            else
                iRet = 3;

            FLOATOBJ_Neg(&xform.eM21);
        }

        pctl->eXScale = xform.eM12;
        pctl->eYScale = xform.eM21;
    }

    /*
     *    Width tables are based on Intellifont's 72.31 points to the inch.
     */

    if( bIntellifont )
    {
        FLOATOBJ_MulLong(&pctl->eXScale,72);

        #ifndef WINNT_40 //NT 5.0

        FLOATOBJ_DivFloat(&pctl->eXScale,(FLOATL)FLOATL_72_31);

        #else // NT 4.0

        FLOATOBJ_DivFloat(&pctl->eXScale,(FLOAT)72.31);

        #endif //!WINNT_40

    }

    return  iRet;

#endif //USEFLOATS
}


VOID
VSetRotation(
    FONTPDEV *pFontPDev,
    int       iRot
    )
/*++

Routine Description:
    Function to set the angular rotation for PCL 5 printers.  These allow
    fonts to be rotated in multiples of 90 degrees relative to graphics.

Arguments:

    pFontPDev       Pointer to FONTPDEV.
    iRot            Rotation amount, range 0 to 3.

Return Value:

    TRUE/FALSE,   TRUE being that the data was queued to be sent OK.

Note:
    12-26-96: Created it -ganeshp-

--*/
{
    PDEV   *pPDev = pFontPDev->pPDev;

    if( iRot != pFontPDev->ctl.iRotate )
    {
        /*  Rotation angle is different,  so change it now */
        COMMAND *pCmd = NULL;

        if (pFontPDev->flFlags & FDV_90DEG_ROTATION)
        {
            pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION);
        }
        else if ((pFontPDev->flFlags & FDV_ANYDEG_ROTATION))
        {
            pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION);
        }


        if (pCmd)
        {
            pFontPDev->ctl.iRotate = iRot;
            BUpdateStandardVar(pPDev, NULL, 0, 0, STD_PRND);
            WriteChannel(pPDev, pCmd);
        }
    }
}

BOOL
BSetFontAttrib(
    PDEV  *pPDev,
    DWORD  dwPrevAttrib,
    DWORD  dwAttrib,
    BOOL   bReset)
{
    PFONTPDEV pFontPDev = pPDev->pFontPDev;
    PCOMMAND pBoldCmd      = NULL,
             pItalicCmd    = NULL,
             pUnderlineCmd = NULL;

    if (! (pFontPDev->flFlags & FDV_INIT_ATTRIB_CMD))
    {
        pFontPDev->pCmdBoldOn = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDON);
        pFontPDev->pCmdBoldOff = COMMANDPTR(pPDev->pDriverInfo, CMD_BOLDOFF);
        pFontPDev->pCmdItalicOn = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICON);
        pFontPDev->pCmdItalicOff = COMMANDPTR(pPDev->pDriverInfo, CMD_ITALICOFF);
        pFontPDev->pCmdUnderlineOn = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEON);
        pFontPDev->pCmdUnderlineOff = COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEOFF);
        pFontPDev->pCmdClearAllFontAttribs = COMMANDPTR(pPDev->pDriverInfo, CMD_CLEARALLFONTATTRIBS);
        pFontPDev->flFlags |= FDV_INIT_ATTRIB_CMD;
    }

    //
    // pCmdBoldOn,Off, pCmdItalicOn,Off, pCmdUnderlineOn,Off
    // and pCmdClearAllFont Attribs are initialized in PDEV initialization.
    //
    if (!pFontPDev->pCmdBoldOn &&
        !pFontPDev->pCmdItalicOn &&
        !pFontPDev->pCmdUnderlineOn)
    {
        //
        // This printer doesn't support font attributes.
        //
        return TRUE;
    }

    if (bReset || (dwAttrib & FONTATTR_BOLD) != (dwPrevAttrib & FONTATTR_BOLD))
    {
        if(dwAttrib & FONTATTR_BOLD)
            pBoldCmd = pFontPDev->pCmdBoldOn;
        else
            pBoldCmd = pFontPDev->pCmdBoldOff;
    }

    if (bReset || (dwAttrib & FONTATTR_ITALIC) != (dwPrevAttrib & FONTATTR_ITALIC))
    {
        if(dwAttrib & FONTATTR_ITALIC)
            pItalicCmd = pFontPDev->pCmdItalicOn;
        else
            pItalicCmd = pFontPDev->pCmdItalicOff;
    }

    if (bReset || (dwAttrib & FONTATTR_UNDERLINE) != (dwPrevAttrib & FONTATTR_UNDERLINE))
    {
        if (dwAttrib & FONTATTR_UNDERLINE)
            pUnderlineCmd = pFontPDev->pCmdUnderlineOn;
        else
            pUnderlineCmd = pFontPDev->pCmdUnderlineOff;
    }

    if (
        pFontPDev->pCmdClearAllFontAttribs
            &&
        (bReset ||
         (pFontPDev->pCmdBoldOn && !pFontPDev->pCmdBoldOff)           ||
         (pFontPDev->pCmdItalicOn && !pFontPDev->pCmdItalicOff)       ||
         (pFontPDev->pCmdUnderlineOn && !pFontPDev->pCmdUnderlineOff)
        )
       )
    {
        WriteChannel(pPDev, pFontPDev->pCmdClearAllFontAttribs);
        //
        // Reset all font attributes
        //
        if (dwAttrib & FONTATTR_BOLD)
            pBoldCmd = pFontPDev->pCmdBoldOn;
        if (dwAttrib & FONTATTR_ITALIC)
            pItalicCmd = pFontPDev->pCmdItalicOn;
        if (dwAttrib & FONTATTR_UNDERLINE)
            pBoldCmd = pFontPDev->pCmdUnderlineOn;
    }

    if (pBoldCmd)
        WriteChannel(pPDev, pBoldCmd);
    if (pItalicCmd)
        WriteChannel(pPDev, pItalicCmd);
    if (pUnderlineCmd)
        WriteChannel(pPDev, pUnderlineCmd);

    ((FONTPDEV*)pPDev->pFontPDev)->ctl.dwAttrFlags = dwAttrib;

    return TRUE;
}

INT
IGetGlyphWidth(
    PDEV    *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    )
/*++

Routine Description:
    Function to get the width of a given Glyph.

    Arguments:
    pFM,              Font data .
    hg                Handle to glyph.

Return Value:

    Scaled width wrt the current graphics resolution of a glyph.
    This width is in notional space and must be transformed to
    device space.

Note:
    12-26-96: Created it -ganeshp-

--*/
{
    if( pFM->flFlags & FM_GLYVER40 )
    {
        //
        // Old Format
        // This function return scaled width for fixed-pitch and proportioanl
        // pitch font.
        //

        return IGetIFIGlyphWidth(pPDev, pFM, hg);

    }
    else
    {
        //
        // New Format
        // This function return scaled width for fixed-pitch and proportioanl
        // pitch font.
        //

        return IGetUFMGlyphWidth(pPDev, pFM, hg);

    }

}

LONG LMulFloatLong(
    PFLOATOBJ pfo,
    LONG l)
/*++

Routine Description:
    Helper Function to multiply a Float with a long.

    Arguments:
    pfo,              Float data .
    l                 Long data.

Return Value:

    Returns a long data.

Note:
    12-29-96: Created it -ganeshp-

--*/
{
    FLOATOBJ fo;
    fo = *pfo;
    FLOATOBJ_MulLong(&fo,l);

    #ifndef WINNT_40 //NT 5.0

    FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

    #else // NT 4.0

    FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

    #endif //!WINNT_40

    return(FLOATOBJ_GetLong(&fo));
}


BOOL
BUpdateStandardVar(
    PDEV       *pPDev,
    PFONTMAP    pfm,
    INT         iGlyphIndex,
    DWORD       dwFontAtt,
    DWORD       dwFlags)
/*++

Routine Description:

    Updates GPD standard variable according to the pFontMap passed.

Arguments:
    pPDev       - a pointer to the physical device
    pfm         - a pointer to the FONTMAP data structure
    iGlyphIndex - an index of glyph
    dwFontAtt   - a font attribute
    dwFlags     - a type of standard variable

Return Value:
    TRUE if suceeded. Otheriwse FALSE;

--*/

{
    FONTPDEV *pFontPDev;
    IFIMETRICS *pIFIMet;
    FLOATOBJ  fo;

    //VERBOSE(("BUpdateStandardVar dwFlags=%x\n",dwFlags));

    pFontPDev = pPDev->pFontPDev;

    //
    // Update standard variables
    //
    // Font related variables
    // ---------------------------------------------------
    // NextGlyph         TT Download        STD_GL
    // FontHeight        TT/Device font     STD_FH
    // FontWidth         TT/Device font     STD_FW
    // FontBold          TT/Device font     STD_FB
    // FontItalic        TT/Device font     STD_FI
    // FontUnderline     TT/Device font     STD_FU
    // FontStrikeThru    TT/Device font     STD_FS
    // NextFontID        TT Download        STD_NFID
    // CurrentFontID     TT Download        STD_CFID
    // PrintDirection    TT/Device font     STD_PRND
    //
    // STD_STD = STD_GL| STD_FH| STD_FW| STD_FB| STD_FI| STD_FU| STD_FS
    // STD_TT  = STD_NFID| STD_CFID| STD_PRND
    //

    if (pfm)
    {
        pIFIMet = (IFIMETRICS *) pfm->pIFIMet;

        //
        // TT Outline has to be scaled as well as device font.
        //if (pfm->dwFontType == FMTYPE_TTBITMAP)
        //
        if (pIFIMet->flInfo & FM_INFO_TECH_TRUETYPE)
        {
            //
            // FontHeight
            //
            if (dwFlags & STD_FH)
            {
                pPDev->dwFontHeight = (WORD)( max(pIFIMet->rclFontBox.top,
                    pIFIMet->fwdWinAscender) -
                    min(-pIFIMet->fwdWinDescender,
                    pIFIMet->rclFontBox.bottom ) +
                    1);
                pPDev->dwFontHeight *= pPDev->ptGrxScale.y;
            }

            //
            // FontWidth
            //
            if (dwFlags & STD_FW)
            {
                //
                // FontMaxWidth update
                //
                pPDev->dwFontMaxWidth = pIFIMet->fwdMaxCharInc;
                pPDev->dwFontMaxWidth *= pPDev->ptGrxScale.x;

                //
                // FontWidth update
                //
                pPDev->dwFontWidth = max(pIFIMet->rclFontBox.right -
                  pIFIMet->rclFontBox.left + 1,
                  pIFIMet->fwdAveCharWidth );
                pPDev->dwFontWidth *= pPDev->ptGrxScale.x;
            }
        }
        else
        {
            //
            // FontHeight
            //
            if (dwFlags & STD_FH)
            {
                fo = pFontPDev->ctl.eYScale;
                if (dwFontAtt & FONTATTR_SUBSTFONT)
                {
                    FLOATOBJ_MulLong(&fo, ((FONTMAP_DEV*)pfm->pSubFM)->fwdFOUnitsPerEm);
                }
                else
                    FLOATOBJ_MulLong(&fo, pIFIMet->fwdUnitsPerEm);

                FLOATOBJ_MulLong(&fo, pPDev->ptGrxScale.y);
                pPDev->dwFontHeight = FLOATOBJ_GetLong(&fo);
            }

            //
            // FontWidth
            //
            if (dwFlags & STD_FW)
            {
                //
                // FontWidth update
                //
                fo = pFontPDev->ctl.eXScale;
                if (dwFontAtt & FONTATTR_SUBSTFONT)
                {
                    FLOATOBJ_MulLong(&fo,((FONTMAP_DEV*)pfm->pSubFM)->fwdFOAveCharWidth);
                }
                else
                    FLOATOBJ_MulLong(&fo, pIFIMet->fwdAveCharWidth);
                FLOATOBJ_MulLong(&fo, pPDev->ptGrxScale.x);
                pPDev->dwFontWidth  = FLOATOBJ_GetLong(&fo);

                //
                // FontMaxWidth update
                //
                fo = pFontPDev->ctl.eXScale;
                if (dwFontAtt & FONTATTR_SUBSTFONT)
                {
                    FLOATOBJ_MulLong(&fo,((FONTMAP_DEV*)pfm->pSubFM)->fwdFOMaxCharInc);
                }
                else
                    FLOATOBJ_MulLong(&fo, pIFIMet->fwdMaxCharInc);
                FLOATOBJ_MulLong(&fo, pPDev->ptGrxScale.x);
                pPDev->dwFontMaxWidth  = FLOATOBJ_GetLong(&fo);
            }
        }
    }
    //
    //
    // Font attributes, dwFontBold
    //                  dwFontItalic
    //
    if (dwFlags & STD_FB)
        pPDev->dwFontBold       = dwFontAtt & FONTATTR_BOLD;

    if (dwFlags & STD_FI)
        pPDev->dwFontItalic     = dwFontAtt & FONTATTR_ITALIC;

    //
    // TrueType font font ID/glyph ID
    //
    if (dwFlags & STD_NFID && NULL != pfm)
        pPDev->dwNextFontID = pfm->ulDLIndex;
    else
        pPDev->dwNextFontID = 0;

    //
    // Glyph ID
    //
    if (dwFlags & STD_GL)
        pPDev->dwNextGlyph = iGlyphIndex;

    //
    // String rotation
    //
    if (dwFlags & STD_PRND)
    {
        if (!(pFontPDev->flText & TC_CR_ANY))
            pPDev->dwPrintDirection = pFontPDev->ctl.iRotate * 90;
        else
            pPDev->dwPrintDirection = pFontPDev->ctl.iRotate;
    }

    //
    // Font ID
    //
    if (dwFlags & STD_CFID)
        pPDev->dwCurrentFontID = pfm->ulDLIndex;

    return TRUE;
}

INT
IFont100toStr(
    BYTE   *pjOut,
    INT     iBufSize, //Size of buffer(in bytes) pointed to by pjOut.
    int     iVal
    )
/*++

Routine Description:
     Convert a font size parameter to ASCII.  Note that the value is
     100 times its actual value,  and we need to include the decimal
     point and trailing zeroes should these be significant.

Arguments:

    BYTE    pjOut     Output area
    int     iVal      Value to convert

Return Value:

     Number of bytes added to output buffer.
     -1 if some error occurs.

Note:
    12-26-96: Created it -ganeshp-

--*/
{

    int    iSize;          /* Count bytes placed in output area */
    int    cDigits;        /* Count number of digits processed */
    BYTE  *pjConv;         /* For stepping through local array */
    BYTE   ajConv[ 16 ];   /* Local conversion buffer */

    /*
     *   Convert the value into ASCII,  remembering that there are
     *  two digits following the decimal point; these need not be
     *  sent if they are zero.
     */

    pjConv = ajConv;
    cDigits = 0;

    while( iVal > 0 || cDigits < 3 )
    {
        *pjConv++ = (iVal % 10) + '0';
        iVal /= 10;
        ++cDigits;

    }

    iSize = 0;

    if ( iBufSize < cDigits - 2 )
    {
        ERR(( "fonts!IFont100toStr(): Too many digits in command\n"));
        return -1;
    }

    while( cDigits > 2 )
    {
        pjOut[ iSize++ ] = *--pjConv; /* Backwards from MSD */
        --cDigits;
    }

    /*   Test for digits following the decimal point */
    if( ajConv[ 1 ] != '0' || ajConv[ 0 ] != '0' )
    {
        if ( iBufSize - iSize >= 2 ) //test if pjOut has enough space to hold 2 bytes
        {
            pjOut[ iSize++ ] = '.';
            pjOut[ iSize++ ] = ajConv[ 1 ];
        }
        else
        {
            return -1;
        }

        /*  Test for the least significant digit */
        if( ajConv[ 0 ] != '0' )
        {
            if ( iBufSize - iSize >= 1 )
            {
                 pjOut[ iSize++ ] = ajConv[ 0 ];
            }
            else
            {
                return -1;
            }
        }
 
   }


    return    iSize;
}

VOID
VSetCursor(
    IN  PDEV   *pPDev,
    IN  INT     iX,
    IN  INT     iY,
    IN  WORD    wMoveType,
    OUT POINTL *pptlRem
    )
/*++
Routine Description:
    This routine set the absolute cursor position.
Arguments:
    pPDev       Pointer to PDEV
    iX, iY      Input cursor position to move
    wMoveType   Type of the input Value, MOVE_RELATIVE, MOVE_ABSOLUTE or
                MOVE_UPDATE
    pptlRem     Remainder part which couldn't be moved. Return values from XMoveTo
                and YMoveTo.

Return Value:
    None
Note:

    8/12/1997 -ganeshp-
        Created it.
--*/
{
    FONTPDEV *pFontPDev;
    TO_DATA  *pTod;
#if defined(_M_IA64) // NTBUG #206444 (203236)
    volatile
#endif
    WORD      wUpdate = 0;

    pFontPDev = pPDev->pFontPDev;
    pTod = pFontPDev->ptod;

    if (wMoveType & MOVE_UPDATE)
    {
        wUpdate = MV_UPDATE;
    }


    if (wMoveType & MOVE_ABSOLUTE)
    {
        //
        //Transform the input X and Y from band coordinates to page coordinates.
        //
        iX += pPDev->rcClipRgn.left;
        iY += pPDev->rcClipRgn.top;


        pptlRem->y = YMoveTo( pPDev, iY, MV_GRAPHICS | wUpdate );

        if (pPDev->fMode & PF_ROTATE)
            pptlRem->x = XMoveTo( pPDev, iX, MV_GRAPHICS | wUpdate);
        else
            pptlRem->x = XMoveTo( pPDev, iX, MV_GRAPHICS | MV_FINE | wUpdate);

    }
    else if (wMoveType & MOVE_RELATIVE)
    {

        //
        // if we are moving relative then no need to do the transform. Just
        // call XMoveTo and YMoveTo
        //

        pptlRem->x = XMoveTo( pPDev, iX, MV_GRAPHICS | MV_RELATIVE | wUpdate);
        pptlRem->y = YMoveTo( pPDev, iY, MV_GRAPHICS | MV_RELATIVE | wUpdate);

    }

    //
    // If PF_RESELECTFONT_AFTER_XMOVE is set, UNIDRV has to reset font after
    // XMoveTo command.
    //
    if (pFontPDev->ctl.iFont == INVALID_FONT)
    {
        BNewFont(pPDev,
                 (pTod->iSubstFace?pTod->iSubstFace:pTod->iFace),
                 pTod->pfm,
                 pTod->dwAttrFlags);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\fontmap.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    fontmap.h

Abstract:

    Unidrv FONTMAP and related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05-19-97 -eigos-
        Created

    dd-mm-yy -author-
        description

--*/

#ifndef  _FONTMAP_
#define _FONMTAP_

//
//  CD - Command Descriptor is used in many of the following structures to
//  reference a particular set of printer command/escape codes
//  used to select paper sizes, graphics resolutions, character attributes,
//  etc. If CD.wType = CMD_FTYPE_EXTENDED, the CD is followed by CD.sCount
//  EXTCD structures.
//

#define NOOCD                     -1    // command does not exist

typedef struct _CD
{
    BYTE    fType;          // type of command
    BYTE    bCmdCbId;       // command callback ID, as in 95
    short   sCount;
    WORD    wLength;        // length of the command
    char    rgchCmd[2];     // Actual Command String, variable length
} CD, *PCD;

//
// FINVOCATION data structure is in printoem.h at public\oak\inc
//

//
// FONTMAP structure for NT 5.0
//

typedef struct _FONTMAP *PFONTMAP;

//
//           _________________
//          |                 |
//          |   Font Main     |
//          |     module      |
//           -----------------
//           |       |        |
//       ____|__  ___|___   __|_____
//      |Device ||TT     | |TT      |
//      | font  || Bitmap| | Outline|
//      | sub   || sub   | | sub    |
//      | module|| Module| | Module |
//       -------  --------  --------
//
//
//

//
// Glyph output function
//
// TO_DATA structure is in fmtxtout.h
//
typedef DWORD (*PFNGLYPHOUT)  (TO_DATA *pTod);

//
// Font selection/deselection function
// UNIDRV
//

typedef BOOL  (*PFNSELFONT)   (PDEV *pdev, PFONTMAP pFM, POINTL* pptl);
typedef BOOL  (*PFNDESELFONT) (PDEV *pdev, PFONTMAP pFM);
typedef BOOL  (*PFNFREEPFM)   (PFONTMAP pFM);

//
// font download functions
//
// Header download function
// This function returns the memory used to download this font.
// If this function fails, this function has to return 0,
//
typedef DWORD (*PFNDLHEADER)  (PDEV *pdev, PFONTMAP pFM);

//
// Character glyph download function
// This function returns the memory used to download this character.
// If this function fails, this function has to return 0. The optional
// parameter is width. This function should fill in the width of the
// Glyph downloaded. This value is save in DLGLYPH.wWidth field.
//
typedef DWORD (*PFNDLGLYPH)   ( PDEV *pdev, PFONTMAP pFM,
                                HGLYPH hGlyph, WORD wDLGlyphId, WORD *pwWidth);
//
// Before downnloading this font a font main calls this function
// to determine if this font can be downloaded with this font and the current
// condition.
// Sub module checks if this font is appropriate to download with  FONTMAP.
// And checks if the remaining memory is enough to download this font.
//
typedef BOOL (*PFNCHECKCOND) (  PDEV *pdev, FONTOBJ *pfo,
                                STROBJ *pstro, IFIMETRICS  *pifi);

typedef struct _FONTMAP
{
    DWORD  dwSignature;         // FONTMAP Signature
    DWORD  dwSize;              // FONTMAP Size.
    DWORD  dwFontType;          // Device/TTBitmap//TTOutline/..
    LONG   flFlags;             // Flags listed below
    IFIMETRICS   *pIFIMet;      // The IFIMETRICS for this font

    WCHAR  wFirstChar;          // First char available
    WCHAR  wLastChar;           // Last one available - inclusive
    ULONG  ulDLIndex;           // Currently selected DL index.

    WORD        wXRes;          // X Res used for font metrics numbers
    WORD        wYRes;          // Ditto for the y coordinates
    SHORT       syAdj;          // Y position adjustment during printing

    //
    // Font specific data structure
    //
    PVOID pSubFM;               // Pointer to the font specific data structure
                                // dwFontType represents this FONTMAP font type.
                                // FMTYPE_DEVICE
                                // FMTYPE_TTBITMAP
                                // FMTYPE_TTOUTLINE
                                // FMTYPE_TTOEM

    //
    // Font specific drawing functions' pointers
    // These pointers varies according to the dwFontType.
    //
    PFNGLYPHOUT  pfnGlyphOut;           // Glyph drawing function
    PFNSELFONT   pfnSelectFont;         // Font selection function
    PFNDESELFONT pfnDeSelectFont;       // Font deselection function
    PFNDLHEADER  pfnDownloadFontHeader; // Download font header
    PFNDLGLYPH   pfnDownloadGlyph;      // Download glyph
    PFNCHECKCOND pfnCheckCondition;     // Condition check function
    PFNFREEPFM   pfnFreePFM;            // To Free the pfm
} FONTMAP, *PFONTMAP;

//
// Values for dwFontType
//
#define FMTYPE_DEVICE       1    // Set for Device font.
#define FMTYPE_TTBITMAP     2    // Set for True Type Bitmap font.
#define FMTYPE_TTOUTLINE    3    // Set for True Type Outline font.
#define FMTYPE_TTOEM        4    // Set for True Type download OEM callback.

//
// FONTMAP_DEV
// Device font sub part of FONTMAP
//

typedef BOOL  (*PFNDEVSELFONT) (PDEV *pdev, BYTE *pbCmd, INT iCmdLength, POINTL *pptl);

typedef struct _FONTMAP_DEV
{
    WORD        wDevFontType;        // Type of Device font
    SHORT       sCTTid;              // It's value as ID in resource data
                                     // Assume that RLE/GTT must be in the same
         // DLL as IFI/UFM is in.
    SHORT       fCaps;               // Capabilities flags
    SHORT       sYAdjust;            // Position adjustment amount before print
    SHORT       sYMoved;             // Position adjustment amount after print
    SHORT       sPadding;            // For Padding
    union
    {
        DWORD      dwResID;          // Resource ID for this font
        QUALNAMEEX QualName;         // Fully qualified resource ID.
    };

    EXTTEXTMETRIC *pETM;             // Pointer to ETM for this font
    FWORD       fwdFOAveCharWidth;   // TrueType IFI Average char width
    FWORD       fwdFOMaxCharInc  ;   // TrueType IFI Max char width.
    FWORD       fwdFOUnitsPerEm;     // TrueType IFI units per em
    FWORD       fwdFOWinAscender;    // TrueType IFI Win Ascender

    ULONG       ulCodepage;          // default codepage
    ULONG       ulCodepageID;        // current codepage

    VOID        *pUCTree;            // UNICODE glyph handle tree
    VOID        *pUCKernTree;        // UNICODE Kernpair table
    VOID        *pvMapTable;         // Allocated MAPTABLE. This is a merged
                                     // MAPTABLE from predefined and mini def.
    PUFF_FONTDIRECTORY pFontDir;    // UFF font directory of this font.
    //
    // Font selection function pointer
    //
    PFNDEVSELFONT pfnDevSelFont;     // Device font selection command

    //
    // File resource pointer
    //
    VOID        *pvNTGlyph;          // The GLYPH TRANS data for this font
    VOID        *pvFontRes;          // Font Matrics(IFI) Resource Pointer
    VOID        *pvPredefGTT;        // This is used for lPredefinedID

    union
    {
        SHORT       *psWidth;        // Width vector (proportional font) else 0
        PWIDTHTABLE pWidthTable;     // pointer to WIDTHTABLE
    } W;

    //
    // Font command
    // If FM_IFIVER40 is set, pCDSelect and pCDDeselect are set.
    // Otherwise, FInvSelect/FinvDeselect are set.
    //
    union
    {
        CD          *pCD;      // How to select/deselect this font
        FINVOCATION  FInv;
    }cmdFontSel;
    union
    {
        CD          *pCD;
        FINVOCATION  FInv;
    }cmdFontDesel;

} FONTMAP_DEV, *PFONTMAP_DEV;

//
//   Values for device font flFlags
//
#define FM_SCALABLE     0x00000001  // Scalable font
#define FM_DEFAULT      0x00000002  // Set for the device's default font
#define FM_EXTCART      0x00000004  // Cartridge, in external font file
#define FM_FREE_GLYDATA 0x00000008  // we need to free GTT or CTT data
#define FM_FONTCMD      0x00000010  // Font select/deselect command in resource
#define FM_WIDTHRES     0x00000020  // Width tables are in a resource
#define FM_IFIRES       0x00000040  // IFIMETRICS are in a resource
#define FM_KERNRES      0x00000080  // FD_KERNINGPAIR is in a resource
#define FM_IFIVER40     0x00000100  // Old IFIMETRICS(NT 4.0) resource
#define FM_GLYVER40     0x00000200  // Old RLE(NT 4.0) resource
#define FM_FINVOC       0x00000400  // FINVOCATION is filled out
#define FM_SOFTFONT     0x00000800  // Soft font, downloaded or installed
#define FM_GEN_SFONT    0x00001000  // Internally generated soft font
#define FM_SENT         0x00002000  // Set if downloaded font downloaded
#define FM_TT_BOUND     0x00004000  // Bound TrueType font
#define FM_TO_PROP      0x00008000  // PROPORTIONAL font
#define FM_EXTERNAL     0x00010000  // External font

//
// FONTMAP_TTB
// TrueType as Bitmap font sub part of FONTMAP
//
typedef struct _FONTMAP_TTB
{
    DWORD dwDLSize;

    union
    {
        VOID  *pvDLData;        // Pointer to DL_MAP
        ULONG  ulOffset;
    } u;
} FONTMAP_TTB, *PFONTMAP_TTB;

//
// FONTMAP_TTO
// TrueType as TrueType Outline font sub part of FONTMAP
//
typedef struct _FONTMAP_TTO
{
    VOID  *pvDLData;        // Pointer to DL_MAP
    LONG   lCurrentPointSize;
    DWORD  dwCurrentTextParseMode;
    //VOID  *pTTFile;
    ULONG  ulGlyphTable;
    ULONG  ulGlyphTabLength;
    USHORT usNumGlyphs;
    SHORT  sIndexToLoc;      // head.indexToLocFormat
    ULONG  ulLocaTable;
    PVOID  pvGlyphData;
    //GLYPH_DATA GlyphData;      // TT GlyphData
    FLONG  flFontType;         // Font Type (bold/italic)
} FONTMAP_TTO, *PFONTMAP_TTO;

typedef struct _FONTMAP_TTOEM
{
    DWORD dwDLSize;
    DWORD dwFlags;
    FLONG flFontType;

    union
    {
        VOID  *pvDLData;        // Pointer to DL_MAP
        ULONG  ulOffset;
    } u;
} FONTMAP_TTOEM, *PFONTMAP_TTOEM;
#endif  // !_FONTMAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\intrface.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    intrface.c

Abstract:

    Implementation of the interface between Control module and Font module

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    11/18/96 -ganeshp-
        FMInit implementation.
--*/

#include "font.h"

static FMPROCS UniFMFuncs =
{
    FMStartDoc,
    FMStartPage,
    FMSendPage,
    FMEndDoc,
    FMNextBand,
    FMStartBanding,
    FMResetPDEV,
    FMEnableSurface,
    FMDisableSurface,
    FMDisablePDEV,
    FMTextOut,
    FMQueryFont,
    FMQueryFontTree,
    FMQueryFontData,
    FMFontManagement,
    FMQueryAdvanceWidths,
    FMGetGlyphMode
};

//
// Local functions Prototype
//

BOOL
BFMInitDevInfo(
    DEVINFO *pDevInfo,
    PDEV    *pPDev
    );

BOOL
BInitStandardVariable(
    PDEV *pPDev);

BOOL
BCheckFontMemUsage(
    PDEV    *pPDev);

INT
iMaxFontID(
    IN INT      iMax,
    OUT DWORD   *pFontIndex);

VOID
VGetFromBuffer(
    IN PWSTR pwstrDest,
    IN size_t cchDestStr,
    IN OUT PWSTR *ppwstrSrc,
    IN OUT PINT  piRemBuffSize);

VOID
VSetReselectFontFlags(
    PDEV    *pPDev
    );

LRESULT
PartialClipOn(
    PDEV *pPDev);

//
//
// Main initialization function
//
//

BOOL
FMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO  *pGDIInfo
    )
/*++

Routine Description:

    This function is called to initialize font related information in
    pPDev, pDevInfo pGDIInfo and FontPDEV. This module will initialize
    various dat structures needed for other modules. For example all
    all the font specific resources will be loaded.

    The following fields of PDev are intialized:

    iFonts :    Number of Device Fonts including Cartridge and SoftFonts.
    ptDefaultFont: Default Font Width and Height in Device Units.
    pFontPDEV:  Font Module PDevice.
    pFontProcs: Font Module specific DDI callback functions pointers.
                Control Module uses this table to call different DDI
                entry points specific to Font Module.
    fHooks:     Set to  HOOK_TEXTOUT if the printer has device fonts.
    Also standard variables specific to font module will be initialized.

    The following fields of pDevInfo are intialized.

    lfDefaultFont : Default logical Device Font.
    lfAnsiVarFont: Default Logical Variable pitch Device font.
    lfAnsiFixFont: Default Logical Fixed pitch Device font.
    cFonts: Number of Device Fonts.

    The following fields of pGDIInfo will be initialized:

    flTextCaps : Text Capability Flags.

Arguments:

    pPDev           Pointer to PDEV
    pDevInfo        Pointer to DEVINFO
    pGDIInfo        Pointer to GDIINFO

Return Value:

    TRUE for success and FALSE for failure
Note:

--*/
{
    PFONTPDEV   pFontPDev;
    //
    // Validate Input Parameters and ASSERT.
    //

    ASSERT(pPDev);
    ASSERT(pDevInfo);
    ASSERT(pGDIInfo);

    //
    // Allocate and initialize FONTPDEV.
    //
    // Initialize FONTPDEV
    //
    // Build the Device Module specific data structures. This involves going
    // through Device and cartrige font list building the FONTMAP structure for
    // each of them. We also go through the soft font list and add them to the
    // list.
    //
    // Initialize FONTMAP
    //
    // Build the font map table.The font cartridges are stored as DT_FONTSCART.
    // The installed cartrides are stored in Registry. So we need a mapping
    // table of font cartridges names to translate the registry information
    // into a list of fonts. After buildind the font mapping table we read the
    // registry and mark the corresponding Font Cartridges as installed.
    //
    // Initialize Device font list from GPD.
    // Read the GPD data about Device Fonts. The font information is in PDEV.
    // The Device fonts are stored as LIST of resource IDs.
    //
    // Initialize DEVINFO specific fields.
    //
    // Initialize the GDIINFO specific fileds.
    //
    // This include text capability flag and other font specific information.
    //

    if ( !(pFontPDev = MemAllocZ(sizeof(FONTPDEV))) )
    {
        ERR(("UniFont!FMInit:Can't Allocate FONTPDEV"));
        return FALSE;

    }

    pPDev->pFontPDev = pFontPDev;

    //
    //Initialize various fields.
    //

    pFontPDev->dwSignature = FONTPDEV_ID;
    pFontPDev->dwSize = sizeof(FONTPDEV);
    pFontPDev->pPDev = pPDev;

    if (!BBuildFontCartTable(pPDev)     ||
        !BRegReadFontCarts(pPDev)       ||
        !BInitFontPDev(pPDev)           ||
        !BInitDeviceFontsFromGPD(pPDev) ||
        !BBuildFontMapTable(pPDev)      ||
        !BFMInitDevInfo(pDevInfo,pPDev) ||
        !BInitGDIInfo(pGDIInfo,pPDev)   ||
        !BInitStandardVariable(pPDev)    )
    {
        VFontFreeMem(pPDev);
        ERR(("Can't Initialize the Font specific data in PDEV"));
        return FALSE;
    }

    //
    // Initialze PDEV specific fields.
    //

    pPDev->pFontProcs = &UniFMFuncs;

    #if DO_LATER

    //
    // if the printer is not a serial printer.
    //

    if (pPDev->pGlobals->printertype != PT_SERIAL)
    {
        pPDev->fMode |= PF_FORCE_BANDING;
    }
    else
    {
        pPDev->fMode &= ~PF_FORCE_BANDING;
    }

    #endif //DO_LATER

    return TRUE;

}

//
//
// Initialization sub functions
//
// BInitFontPDev
// BBuildFontCartTable
// BRegReadFontCarts
// BInitDeviceFontsFromGPD
// BBuildFontMapTable
// BFMInitDevInfo
// BInitGDIInfo
// BInitStandardVariable
//


BOOL
BInitFontPDev(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine allocates the FONTPDEV and initializes various fileds.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    11-18-96: Created it -ganeshp-
--*/

{
    PFONTPDEV   pFontPDev  = PFDV;
    GLOBALS     *pGlobals = pPDev->pGlobals;
    DWORD       dwSize;
    INT         iMaxDeviceFonts;
    SHORT       sOrient;
    BOOL        bRet = FALSE;

    iMaxDeviceFonts   = IGetMaxFonts(pPDev);

    //
    // Allocate the font list buffer.
    //

    if ( iMaxDeviceFonts  &&
         !(pFontPDev->FontList.pdwList =
                        MemAllocZ(iMaxDeviceFonts * sizeof(DWORD))) )
    {
        ERREXIT("UniFont!BInitFontPDev:Can't Allocate Device Font List");
    }

    //
    // Set the number of entries
    //

    pFontPDev->FontList.iEntriesCt = 0;
    pFontPDev->FontList.iMaxEntriesCt = iMaxDeviceFonts;

    //
    // Set differnt General Flags
    //

    if ( pGlobals->bRotateFont)
        pFontPDev->flFlags |= FDV_ROTATE_FONT_ABLE;

    if ( pGlobals->charpos == CP_BASELINE)
        pFontPDev->flFlags |= FDV_ALIGN_BASELINE;

    if ( pGlobals->bTTFSEnabled)
        pFontPDev->flFlags |= FDV_TT_FS_ENABLED;

    //
    // Check if Memory should be tracked for font downloading
    //
    if ( BCheckFontMemUsage(pPDev) )
        pFontPDev->flFlags |= FDV_TRACK_FONT_MEM;

    //
    // Set the Reselect font Flags.
    //
    VSetReselectFontFlags(pPDev);


    if ( pGlobals->printertype == PT_SERIAL ||
         pGlobals->printertype == PT_TTY  )
        pFontPDev->flFlags |= FDV_MD_SERIAL;

    //
    // The code assumes that COMMANDPTR macro returns NULL if the
    // command doesn't exist.
    //

    if ( COMMANDPTR(pPDev->pDriverInfo, CMD_WHITETEXTON))
        pFontPDev->flFlags |= FDV_WHITE_TEXT;

    if ( COMMANDPTR(pPDev->pDriverInfo,CMD_SETSIMPLEROTATION ))
        pFontPDev->flFlags |= FDV_90DEG_ROTATION;

    if ( COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION))
        pFontPDev->flFlags |= FDV_ANYDEG_ROTATION;

    if (pPDev->fMode & PF_ANYCOLOR_BRUSH)
        pFontPDev->flFlags |= FDV_SUPPORTS_FGCOLOR;
    else // Monochrome case
    {
        //
        // PF_ANYCOLOR_BRUSH is set only for color printers with explicit
        // colormode. But Monochrome printers can also support dither color
        // using downloadable pattern brush. This is a good optimization because
        // we will do substitution or download instead of sending the text as
        // graphics. For enabling this mode the printer must support
        // CmdSelectBlackBrush so that Resetbrush  can rest the color to black
        // befroe sending raster. So for a monochrome printer if
        // CmdSelectBlackBrush, CmdDownloadPattern and CmdSelectPattern
        // are supported then we will set FDV_SUPPORTS_FGCOLOR.
        //
        if ( (pPDev->arCmdTable[CMD_DOWNLOAD_PATTERN] ) &&
             (pPDev->arCmdTable[CMD_SELECT_PATTERN])    &&
             (pPDev->arCmdTable[CMD_SELECT_BLACKBRUSH])
           )
            pFontPDev->flFlags |= FDV_SUPPORTS_FGCOLOR;
    }

    if ( COMMANDPTR(pPDev->pDriverInfo, CMD_UNDERLINEON))
        pFontPDev->flFlags |= FDV_UNDERLINE;

    //
    // Set dwSelection bits
    //

    sOrient = (pPDev->pdm->dmFields & DM_ORIENTATION) ?
              pPDev->pdm->dmOrientation : (SHORT)DMORIENT_PORTRAIT;

    if ( sOrient == DMORIENT_LANDSCAPE )
        pFontPDev->dwSelBits |= FDH_LANDSCAPE;
    else
        pFontPDev->dwSelBits |= FDH_PORTRAIT;

    //
    //  If the printer can rotate fonts, then we don't care about
    //  the orientation of fonts.  Hence,  set both selection bits.
    //

    if( pFontPDev->flFlags & FDV_ROTATE_FONT_ABLE )
        pFontPDev->dwSelBits |= FDH_PORTRAIT | FDH_LANDSCAPE;

    //
    // Presume we can always print bitmap fonts,  so now add that
    // capability.
    //

    pFontPDev->dwSelBits |= FDH_BITMAP;

    //
    // Set the Text Scale Fasctor.
    //

    pFontPDev->ptTextScale.x = pGlobals->ptMasterUnits.x / pPDev->ptTextRes.x;
    pFontPDev->ptTextScale.y = pGlobals->ptMasterUnits.y / pPDev->ptTextRes.y;

    if ( pGlobals->dwLookaheadRegion  )
    {
        // !!!TODO pFontPDev->flFlags |=  FDV_FONT_PERMUTE;
        pPDev->dwLookAhead =  pGlobals->dwLookaheadRegion /
                              pFontPDev->ptTextScale.y;
    }

    //
    // Initialize the Text Flag.
    //

    if (!BInitTextFlags(pPDev) )
    {
        ERREXIT(("UniFont!BInitFontPDev:Can't initialize Text Flags\n"));

    }

    //
    // Initalize memory to be used by Font Module. If no memory tracking
    // has to be done the set the dwFontMem to a big value.

    if( (pFontPDev->flFlags & FDV_TRACK_FONT_MEM) )
       pFontPDev->dwFontMem = pPDev->dwFreeMem;

    //
    // If it is set to zero initialize this item to a big value. */
    //

    if (pFontPDev->dwFontMem == 0)
        pFontPDev->dwFontMem = MAXLONG;

    //
    // No DL font memory used */
    //

    pFontPDev->dwFontMemUsed = 0;

    //
    // Set Download specific information, if printer supports it */
    //

    if (pGlobals->fontformat != UNUSED_ITEM)
    {
        BOOL bValidFontIDRange;
        BOOL bValidGlyphIDRange;

        /* Start index */
        pFontPDev->iFirstSFIndex = pFontPDev->iNextSFIndex
                                 = pGlobals->dwMinFontID;

        pFontPDev->iLastSFIndex  = pGlobals->dwMaxFontID;

        /*
         *  There may also be a limit on the number of softfonts that the
         *  printer can support.  If not,  the limit is < 0, so when
         *  we see this,  set the value to a large number.
         */

        if ((pFontPDev->iMaxSoftFonts = (INT)pGlobals->dwMaxFontUsePerPage) < 0)
            pFontPDev->iMaxSoftFonts = pFontPDev->iLastSFIndex + 100;

        pFontPDev->flFlags       |= FDV_DL_INCREMENTAL;   //Always incremental.

        /*
         * Now varify that the font ID range is less that MAXWORD. This is
         * necessary, otherwise trunction will happen. We don't download
         * if the values are more than MAXWORD.
         */

        bValidFontIDRange = ((pFontPDev->iFirstSFIndex <= MAXWORD) &&
                             (pFontPDev->iLastSFIndex <= MAXWORD));

        //
        // If the downloaded font in not bound to a symbols set(i.e. dlsymbolset
        // is not defined), We don't want to download, if there are less than
        // 64 glyphs per downloaded font.
        //

        bValidGlyphIDRange = (pPDev->pGlobals->dlsymbolset != UNUSED_ITEM) ||
                             ( (pPDev->pGlobals->dlsymbolset == UNUSED_ITEM) &&
                               ( pPDev->pGlobals->dwMaxGlyphID -
                                 pPDev->pGlobals->dwMinGlyphID) >=
                                                   MIN_GLYPHS_PER_SOFTFONT );

        /*
         *   Consider enabling downloading of TT fonts. This is done only
         * if text and graphics resolutions are the same - otherwise
         * the TT fonts will come out smaller than expected, since they
         * will be generated for the lower graphics resolution yet
         * printed at the higher text resolution!  LaserJet 4 printers
         * can also download fonts digitised at 300dpi when operating
         * at 600 dpi,  so we also accept that as a valid mode.
         *
         *   Also check if the user wants this: if the no cache flag
         * is set in the driver extra part of the DEVMODE structure,
         * then we also do not set this flag.
         */

        VERBOSE(("pPDev->pdm->dmTTOption is %d\n",pPDev->pdm->dmTTOption));

        if( ( POINTEQUAL(pPDev->ptGrxRes,pPDev->ptTextRes) ||
              (pPDev->ptGrxRes.x >= 300 && pPDev->ptGrxRes.y >= 300))
            && (bValidFontIDRange)
            && (bValidGlyphIDRange)
            && (!(pPDev->fMode2 & PF2_MIRRORING_ENABLED))
            && (!(pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS )) 
          )
        {
            //
            // Conditions have been met,  so set the flag
            // Check the application preference.
            //

            if( (pPDev->pdm->dmFields & DM_TTOPTION) &&
                (pPDev->pdm->dmTTOption != DMTT_BITMAP)
              )
            {
                pFontPDev->flFlags |= FDV_DLTT;

                //
                // Find Out if Download TT as TT is available or not. We only
                // want to do this if text and graphics resolutions are same.
                //

                if ( POINTEQUAL(pPDev->ptGrxRes,pPDev->ptTextRes) )
                {
                    if (pPDev->ePersonality == kPCLXL)
                        pFontPDev->flFlags |= FDV_DLTT_OEMCALLBACK;
                    else
                    if ( (pGlobals->fontformat ==  FF_HPPCL_OUTLINE) )
                        /*!!!TODO Enable after parser add this command &&
                         (COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTHEIGHT))*/
                    {
                        //
                        // We assume that if the printer support TT as outline,
                        // then TT as Bitmap format is also supported. We only
                        // support TrueType outline if font height selection
                        // command is present, else we assume download as
                        // bitmap.
                        //

                        pFontPDev->flFlags |= FDV_DLTT_ASTT_PREF;
                    }
                    else if ( pGlobals->fontformat == FF_OEM_CALLBACK)
                        pFontPDev->flFlags |= FDV_DLTT_OEMCALLBACK;
                    else //OEM CallBack
                        pFontPDev->flFlags |= FDV_DLTT_BITM_PREF;

                    //
                    // We also need to check the memory. For printers with
                    // less than 2MB of free memory, download as TT outline
                    // will be disabled.
                    //
                    if (pFontPDev->flFlags & FDV_DLTT_ASTT_PREF)
                    {
                        if (pPDev->dwFreeMem < (2L * ONE_MBYTE))
                        {
                            pFontPDev->flFlags &= ~FDV_DLTT_ASTT_PREF;
                            pFontPDev->flFlags |= FDV_DLTT_BITM_PREF;
                        }
                    }
                }
            }
        }
    }

    //
    // Initialize the Font state control structure */
    //

    pFontPDev->ctl.iSoftFont = -1;
    pFontPDev->ctl.iFont = INVALID_FONT;
    pFontPDev->ctl.dwAttrFlags = 0;
    pFontPDev->ctl.iRotate = 0;
    pFontPDev->ctl.pfm = NULL;

    //
    // Set the White and Black Ref Color
    //

    pFontPDev->iWhiteIndex = ((PAL_DATA*)(pPDev->pPalData))->iWhiteIndex;
    pFontPDev->iBlackIndex = ((PAL_DATA*)(pPDev->pPalData))->iBlackIndex;

    //
    // Initialize font substitution table from a registry.
    //
    pFontPDev->pTTFontSubReg = PGetTTSubstTable(pPDev->devobj.hPrinter, &dwSize);

    if (pPDev->pGlobals->bTTFSEnabled &&

            ( (pFontPDev->pTTFontSubReg &&
               *((PDWORD)pFontPDev->pTTFontSubReg) != 0) ||

              (!pFontPDev->pTTFontSubReg &&
               (INT)pPDev->pDriverInfo->DataType[DT_FONTSUBST].dwCount )
            )
       )
    //
    // Check if GPD supports "*TTFSEnableD?: TRUE"
    //       if there is a substitution table in registry
    //       if there is a default substitution table in GPD.
    //
    {
        pFontPDev->flFlags |= FDV_SUBSTITUTE_TT;
    }
    else
    {
        pFontPDev->flFlags &= ~FDV_SUBSTITUTE_TT;
    }

    //
    // Enable/Disable partial clipping
    //
    if (S_FALSE != PartialClipOn(pPDev))
        pFontPDev->flFlags |= FDV_ENABLE_PARTIALCLIP;
    else
        pFontPDev->flFlags &= ~FDV_ENABLE_PARTIALCLIP;

    //
    // store some members of pGlobals to save the memory allocation
    //

    pFontPDev->sDefCTT = (SHORT)pPDev->pGlobals->dwDefaultCTT;
    pFontPDev->dwDefaultFont = pPDev->pGlobals->dwDefaultFont;

    //
    // For TTY driver ask the minidriver for user selection of code page.
    //
    if ( pPDev->bTTY )
    {
        BOOL  bOEMinfo;
        INT   iTTYCodePageInfo;
        DWORD cbcNeeded;
        PFN_OEMTTYGetInfo   pfnOemTTYGetInfo;

        iTTYCodePageInfo = 0;
        bOEMinfo = FALSE ;

        FIX_DEVOBJ(pPDev, EP_OEMTTYGetInfo);

        if(pPDev->pOemEntry)
        {
            if(  ((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem )   //  OEM plug in uses COM and function is implemented.
            {
                HRESULT  hr ;
                hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                            (PDEVOBJ)pPDev, OEMTTY_INFO_CODEPAGE, &iTTYCodePageInfo, sizeof(INT), &cbcNeeded);
                if( SUCCEEDED(hr))
                    bOEMinfo = TRUE ;
            }
            else  if((pfnOemTTYGetInfo = (PFN_OEMTTYGetInfo)pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pfnHook) &&
                 (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_CODEPAGE, &iTTYCodePageInfo, sizeof(INT), &cbcNeeded)))
                        bOEMinfo = TRUE ;
        }


        if(bOEMinfo)
        {
            //
            // predefined GTT ID case
            //
            if (iTTYCodePageInfo < 0)
            {
                pFontPDev->sDefCTT = (SHORT)iTTYCodePageInfo;
                switch (iTTYCodePageInfo)
                {
                    case CC_CP437:
                        pFontPDev->dwTTYCodePage = 437;
                        break;

                    case CC_CP850:
                        pFontPDev->dwTTYCodePage = 850;
                        break;

                    case CC_CP863:
                        pFontPDev->dwTTYCodePage = 863;
                        break;
                }
            }
            else
            {
                pFontPDev->dwTTYCodePage = iTTYCodePageInfo;
                switch (iTTYCodePageInfo)
                {
                case 936:
                    pFontPDev->sDefCTT = CC_GB2312;
                    break;

                case 950:
                    pFontPDev->sDefCTT = CC_BIG5;
                    break;

                case 949:
                    pFontPDev->sDefCTT = CC_WANSUNG;
                    break;

                case 932:
                    pFontPDev->sDefCTT = CC_SJIS;
                    break;

                default:
                    pFontPDev->sDefCTT = 0;
                    break;
                }
            }
        }

    }
    //
    // All Success
    //

    bRet = TRUE;

    ErrorExit:

    return bRet;

}

BOOL
BBuildFontCartTable(
    PDEV    *pPDev
    )

/*++

Routine Description:

    Builds the Fontcart Table. It reads the minidriver and get the
    FontCart string and the corresponding indexes and put them in the
    FontCart Table.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    11-18-96: Created it -ganeshp-
--*/

{


    PFONTPDEV       pFontPDev           = pPDev->pFontPDev;
    INT             iNumAllCartridges;
    INT             iIndex;
    PFONTCARTMAP    *ppFontCartMap      = &(pFontPDev->FontCartInfo.pFontCartMap);
    WINRESDATA      *pWinResData        = &(pPDev->WinResData);
    GPDDRIVERINFO   *pDriverInfo       = pPDev->pDriverInfo; // GPDDRVINFO
    FONTCART        *pFontCart ;

    /* Read the total number of Font Cartridges supported */
    iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts
                      = (INT)(pDriverInfo->DataType[DT_FONTSCART].dwCount);

    pFontPDev->FontCartInfo.dwFontCartSlots = pPDev->pGlobals->dwFontCartSlots;

    /* FONTCARTS are stored as arrayref and are contiguous. Get to the start
     * start of the array.
     */
    pFontCart = GETFONTCARTARRAY(pDriverInfo);


    if (iNumAllCartridges)
        *ppFontCartMap = MemAllocZ(iNumAllCartridges * sizeof(FONTCARTMAP) );
    else
        *ppFontCartMap = NULL;

    if(*ppFontCartMap)
    {
        PFONTCARTMAP pTmpFontCartMap = *ppFontCartMap; /* Temp Pointer */

        for( iIndex = 0; iIndex < iNumAllCartridges ;
                                    pTmpFontCartMap++, pFontCart++, iIndex++ )
        {
            if ( !ARF_IS_NULLSTRING(pFontCart->strCartName) )
            {
                wcsncpy( (PWSTR)(&(pTmpFontCartMap->awchFontCartName)),
                        GETSTRING(pDriverInfo, (pFontCart->strCartName)),
                        MAXCARTNAMELEN - 1);
            }
            else if ((ILoadStringW( pWinResData, pFontCart->dwRCCartNameID,
                        (PWSTR)(&(pTmpFontCartMap->awchFontCartName)),
                        (MAXCARTNAMELEN )))  == 0)
            {

                ERR(("\n UniFont!bBuildFontCartTable:FontCart Name not found\n") );
                continue;
            }

            pTmpFontCartMap->pFontCart = pFontCart;

            VERBOSE(("\n UniFont!bBuildFontCartTable:(pTmpFontCartMap->awchFontCartName)= %ws\n", (pTmpFontCartMap->awchFontCartName)));
            VERBOSE(("UniFont!bBuildFontCartTable:pTmpFontCartMap->pFontCart= %p\n", (pTmpFontCartMap->pFontCart)));

        }
    }
    else if (iNumAllCartridges)
    {
        ERR(("UniFont!bBuildFontCartTable:HeapAlloc for FONTCARTMAP table failed!!\n") );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE ;
    }

    return TRUE ;
}



BOOL
BInitDeviceFontsFromGPD(
    PDEV    *pPDev
    )

/*++

Routine Description:

    This routine builds the device font list. The list include device resident
    fonts and the fonts specific to installed cartridges.

Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    11-18-96: Created it -ganeshp-
--*/

{
    BOOL        bRet = FALSE;
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    PDWORD      pdwList = pFontPDev->FontList.pdwList;
    PLISTNODE   pListNode;
    PINT        piFontCt = &(pFontPDev->FontList.iEntriesCt);

    //
    // The List of Fonts is stored in PDEV. GLOBALS.dwDeviceFontList is
    // Offset to the ListNode. Macro LISTNODEPTR will return a pointer
    // to the ListNode. Then we have to traverse the list and build the
    // font list. Font module stores the font list as an array of WORDS.
    // Each of these is a resource Id of the font. The array is NULL
    // terminated.
    //

    if (pPDev->bTTY)
    {
        PFN_OEMTTYGetInfo   pfnOemTTYGetInfo;
        DWORD               cbcNeeded, dwNumOfFonts;

        //
        // TTY driver case
        // TTY driver supports 3 fonts. According to the current selected
        // codepage, TTY driver returns appropriate font resource IDs.
        // UNIDRV stores these IDs in pdwList.
        //

        if (pPDev->pOemEntry)
        {
            ASSERT(pdwList);

            if (((POEM_PLUGIN_ENTRY)pPDev->pOemEntry)->pIntfOem)
            {
                HRESULT hr;

                hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                    (PDEVOBJ)pPDev,
                                    OEMTTY_INFO_NUM_UFMS,
                                    &dwNumOfFonts,
                                    sizeof(DWORD),
                                    &cbcNeeded);

                if( SUCCEEDED(hr) && dwNumOfFonts <= MAXDEVFONT)
                {
                     hr = HComTTYGetInfo((POEM_PLUGIN_ENTRY)pPDev->pOemEntry,
                                          (PDEVOBJ)pPDev,
                                          OEMTTY_INFO_UFM_IDS,
                                          pdwList,
                                          sizeof(DWORD) * dwNumOfFonts,
                                          &cbcNeeded);

                    if( SUCCEEDED(hr))
                    {
                        *piFontCt += dwNumOfFonts;
                        pFontPDev->dwDefaultFont = *pdwList;
                    }
                }
            }
            else
            {
                if((pfnOemTTYGetInfo = (PFN_OEMTTYGetInfo)pPDev->pOemHookInfo[EP_OEMTTYGetInfo].pfnHook) &&
                   (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_NUM_UFMS, &dwNumOfFonts, sizeof(DWORD), &cbcNeeded)) &&
                   (dwNumOfFonts <= MAXDEVFONT) &&
                   (pfnOemTTYGetInfo((PDEVOBJ)pPDev, OEMTTY_INFO_UFM_IDS, pdwList, sizeof(DWORD) * dwNumOfFonts, &cbcNeeded)))
                {
                    *piFontCt += dwNumOfFonts;
                    pFontPDev->dwDefaultFont = *pdwList;
                }
            }
        }
    }
    else
    {
        if (pListNode = LISTNODEPTR(pPDev->pDriverInfo , pPDev->pGlobals->liDeviceFontList ) )
        {
            ASSERT(pdwList);

            while (pListNode)
            {
                //
                // Check the Font Resource ID. It shouldn't be NULL.
                //

                if (!pListNode->dwData)
                {
                    ERREXIT("Bad Font Resource Id");
                }

                //
                // Store the Font Resource ID in the List Array.
                //

                *pdwList++ = pListNode->dwData;

                (*piFontCt)++;

                pListNode = LISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
            }

        }
    }

    pFontPDev->iDevResFontsCt  = *piFontCt;

    //
    // Add Cartridge Fonts. By this time we have scanned the regitry and know
    //
    // which fontcartridges has been installed. All we have have to do is
    // go through each font cartriges font list and add them to our list.
    //

    if (pFontPDev->FontCartInfo.iNumInstalledCarts)
    {
        INT         iNumAllCartridges, iI;
        FONTCARTMAP *pFontCartMap;  /* FontCart Map Pointer */
        SHORT       sOrient;

        pFontCartMap = (pFontPDev->FontCartInfo.pFontCartMap);
        iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts;
        sOrient = (pPDev->pdm->dmFields & DM_ORIENTATION) ?
                  pPDev->pdm->dmOrientation : (SHORT)DMORIENT_PORTRAIT;

        //
        // The logic is very simple. Installed font Cartridges are marked in
        // the Font Cartridge mapping table. We go through the mapping table
        // and for each installed cartridges we get the font list and add them
        // to our list.
        //

        for( iI = 0; iI < iNumAllCartridges ; iI++,pFontCartMap++ )
        {
            if (pFontCartMap->bInstalled == TRUE )
            {
                //
                // Check for Orientation, as there can be different font list
                // for different orientation.
                //

                if ( sOrient == DMORIENT_LANDSCAPE )
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwLandFontLst );

                }
                else
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwPortFontLst );
                }

                while (pListNode)
                {
                    //
                    // Check the Font Resource ID. It shouldn't be NULL.
                    //

                    if (!pListNode->dwData)
                    {
                        ERREXIT("Bad Font Resource Id");
                    }

                    //
                    //Store the Font Resource ID in the List Array.
                    //

                    *pdwList++ = pListNode->dwData;
                    (*piFontCt)++;
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                pListNode->dwNextItem);
                }

            }

        }
    }

    //
    // Update the count of all device fonts
    //

    pFontPDev->iDevFontsCt += *piFontCt;

    //
    // All Success
    //
    if (pFontPDev->FontCartInfo.pFontCartMap)
        MEMFREEANDRESET(pFontPDev->FontCartInfo.pFontCartMap);
    bRet = TRUE;

    ErrorExit:

    return bRet;

}


BOOL
BBuildFontMapTable(
    PDEV     *pPDev
    )
/*++

Routine Description:

   Build a table of fonts available on this model.
   Each entry in this table is an atom for the facename followed
   by TEXTMETRIC structure.  This table will accelerate font
   enumeration and font realization.  This routine is responsible
   for allocating the global memory needed to store the table.
   It also has 2 OCD's to select/unselect each font

Arguments:

    pPDev - Pointer to PDEV.

    Return Value: None

Note:
    11-18-96: Created it -ganeshp-
--*/
{
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    PDWORD      pdwFontList = pFontPDev->FontList.pdwList;

    //
    // Basic idea here is to generate a bit array indicating which of
    // the minidriver fonts are available for this printer in it's
    // current mode.  This is saved in the UD_PDEV,  and will be filled in
    // as required later,  during DrvQueryFont,  if this is required.
    //

    //
    // If no hardware font is available,  give up now!
    //

    if( !(pFontPDev->flText & ~TC_RA_ABLE) )
        return TRUE;

    // At this point we check for reasons why not to use device fonts.
    // We disable device fonts for n-up printing on serial devices because they
    // typically can't scale their fonts
    //
    if( ( !pPDev->bTTY ) &&
        ( (pPDev->pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS ) ||
#ifndef WINNT_40
          (pPDev->pdmPrivate->iLayout != ONE_UP && 
           pPDev->pGlobals->printertype == PT_SERIAL &&
           pPDev->pGlobals->bRotateRasterData == FALSE) ||
#endif
          (pPDev->fMode2 & PF2_MIRRORING_ENABLED) ||
          ((pPDev->pdm->dmFields & DM_TTOPTION) &&
          (pPDev->pdm->dmTTOption == DMTT_BITMAP)) ) )
    {
        return TRUE;
    }


    /*
     *    That's all we need do during DrvEnablePDEV time.  We now know
     *  which fonts are available, and there was little effort involved.
     *  This data is now saved away,  and will be acted upon as and when
     *  GDI comes and asks us about fonts.
     */

    pPDev->iFonts = (UINT)(-1);          /* Tells GDI about lazy evaluation */

    IInitDeviceFonts( pPDev );

    //
    // Initialize font substitution flag.
    // Check if this printer supports any device font.
    //

    if (pPDev->iFonts <= 0 &&
        pFontPDev->flFlags & FDV_SUBSTITUTE_TT)
    {
        pFontPDev->flFlags &= ~FDV_SUBSTITUTE_TT;
    }

    return TRUE;
}


BOOL
BFMInitDevInfo(
    DEVINFO *pDevInfo,
    PDEV    *pPDev
    )
/*++

Routine Description:

    This routine intializes the font specific fileds of DevInfo.

Arguments:
    pDevInfo - Pointer to DEVINFO to be initialized.
    pPDev - Pointer to PDEV.

    Return Value:
    TRUE  - for success
    FALSE - for failure

Note:
    12-11-96: Created it -ganeshp-
--*/
{
    CHARSETINFO ci;
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    FONTMAP    *pFMDefault;
    BOOL        bSetTrueType;

    bSetTrueType = TRUE;
    pFMDefault = pFontPDev->pFMDefault;
    pDevInfo->flGraphicsCaps |= GCAPS_SCREENPRECISION | GCAPS_FONT_RASTERIZER;

    if (!PrdTranslateCharsetInfo(PrdGetACP(), &ci, TCI_SRCCODEPAGE))
        ci.ciCharset = ANSI_CHARSET;

    if( pDevInfo->cFonts = pPDev->iFonts )
    {
        //
        // Device fonts are available,  so set the default font data
        //

        if( pFMDefault &&
            ((IFIMETRICS*)pFMDefault->pIFIMet)->jWinCharSet == ci.ciCharset)
        {
            VLogFont(&pPDev->ptTextRes, &(pDevInfo->lfDefaultFont), pFontPDev->pFMDefault );
            bSetTrueType = FALSE;
        }

        //
        //Initialize the Hooks flag.
        //

        pPDev->fHooks |= HOOK_TEXTOUT;
    }

    //
    // Always switch off TC_RA_ABLE flag
    //
    pFontPDev->flText &= ~TC_RA_ABLE;


    if (bSetTrueType)
    {
        pDevInfo->lfDefaultFont.lfCharSet = (BYTE)ci.ciCharset;
        ZeroMemory( pDevInfo->lfDefaultFont.lfFaceName,
                    sizeof ( pDevInfo->lfDefaultFont.lfFaceName ));
    }

    ZeroMemory( &pDevInfo->lfAnsiVarFont, sizeof( LOGFONT ) );
    ZeroMemory( &pDevInfo->lfAnsiFixFont, sizeof( LOGFONT ) );

    return TRUE ;
}

BOOL
BInitGDIInfo(
    GDIINFO  *pGDIInfo,
    PDEV     *pPDev
    )
/*++

Routine Description:

    This routine intializes the font specific fileds of GdiInfo.

Arguments:
    pGDIInfo - Pointer to GDIINFO to be initialized.
    pPDev    - Pointer to PDEV.

    Return Value:
    TRUE  - for success
    FALSE - for failure

Note:
    12-11-96: Created it -ganeshp-
--*/
{
    pGDIInfo->flTextCaps = PFDV->flText;
    return TRUE;
}


BOOL
BInitStandardVariable(
    PDEV *pPDev)
{

    //
    // Initialize the Standard Variable, Just for sanity
    //
    pPDev->dwPrintDirection   =
    pPDev->dwNextFontID       =
    pPDev->dwNextGlyph        =
    pPDev->dwFontHeight       =
    pPDev->dwFontWidth        =
    pPDev->dwFontBold         =
    pPDev->dwFontItalic       =
    pPDev->dwFontUnderline    =
    pPDev->dwFontStrikeThru   =
    pPDev->dwCurrentFontID    = 0;

    return TRUE;
}

//
//
// Misc functions
//
//

VOID
VLogFont(
    POINT    *pptTextRes,
    LOGFONT  *pLF,
    FONTMAP  *pFM
)
/*++

Routine Description:

    Turn an IFIMETRICS structure into a LOGFONT structure,  for whatever
    reason this is needed.

Arguments:

    pLF - Output is a LOGFONT.
    pFM - Input is a FONTMAP.

    Return Value: None

Note:
    12-11-96: Created it -ganeshp-
--*/
{
    /*
     *    Convert from IFIMETRICS to LOGFONT type structure.
     */

    int           iLen;            /* Loop variable */

    IFIMETRICS   *pIFI;
    WCHAR        *pwch;            /* Address of face name */



    pIFI = pFM->pIFIMet;                /* The BIG metrics */

    pLF->lfHeight = pIFI->fwdWinAscender + pIFI->fwdWinDescender;
    pLF->lfWidth  = pIFI->fwdAveCharWidth;

    /*
     *   Note that this may be a scalable font, in which case we pick a
     *  reasonable number!
     */
    if( pIFI->flInfo & (FM_INFO_ISOTROPIC_SCALING_ONLY|FM_INFO_ANISOTROPIC_SCALING_ONLY|FM_INFO_ARB_XFORMS))
    {
        /*
         *    Invent an arbitrary size.  We choose an approximately 10 point
         *  font.  The height is achieved easily, as we simply set the
         *  height based on the device resolution!  For the width, adjust
         *  it using the same factor as we used on the height.  This
         *  assumes that the resolution is the same in both directions,
         *  but this is reasonable given laser printers are the most
         *  common with scalable fonts.
         */


        //
        // Needs to reflect a current resolution.
        //

        pLF->lfHeight = pptTextRes->x / 7; /* This is about 10 points */
        pLF->lfWidth = (2 * pLF->lfHeight * pptTextRes->y) /
                       (3 * pptTextRes->y);

    }

    pLF->lfEscapement  = 0;
    pLF->lfOrientation = 0;

    pLF->lfWeight = pIFI->usWinWeight;

    pLF->lfItalic    = (BYTE)((pIFI->fsSelection & FM_SEL_ITALIC) ? 1 : 0);
    pLF->lfUnderline = (BYTE)((pIFI->fsSelection & FM_SEL_UNDERSCORE) ? 1 : 0);
    pLF->lfStrikeOut = (BYTE)((pIFI->fsSelection & FM_SEL_STRIKEOUT) ? 1 : 0);

    pLF->lfCharSet = pIFI->jWinCharSet;

    pLF->lfOutPrecision = OUT_DEFAULT_PRECIS;
    pLF->lfClipPrecision = CLIP_DEFAULT_PRECIS;
    pLF->lfQuality = DEFAULT_QUALITY;

    pLF->lfPitchAndFamily = pIFI->jWinPitchAndFamily;

    /*
     *    Copy the face name,  after figuring out it's address!
     */

    pwch = (WCHAR *)((BYTE *)pIFI + pIFI->dpwszFaceName);
    iLen = min( wcslen( pwch ), LF_FACESIZE - 1 );

    wcsncpy( pLF->lfFaceName, pwch, iLen );

    pLF->lfFaceName[ iLen ] = (WCHAR)0;


    return;
}

BOOL
BInitTextFlags(
    PDEV    *pPDev
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    BOOL        bRet = FALSE;
    PLISTNODE   pListNode;
    DWORD       flText = 0;

    TRACE(UniFont!BInitTextFlags:START);

    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liTextCaps ) )
    {
        while (pListNode)
        {
            // Check the Text Flag. It shouldn't be < 0 or greater than 32.
            if ( ((INT)pListNode->dwData < 0) ||
                 (pListNode->dwData > DWBITS) )
                ERREXIT("UniFont!BInitTextFlags:Bad FText Flag Value\n");

            //Set the corresponding bit in fText
            flText |= 1 << pListNode->dwData;

            pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
        }
    }

    PRINTVAL(flText,0x%x);

    // If there is a TextCAP List, Modify the text flags as needed.
    if (flText)
    {
        /* Switch off TC_RA_ABLE if text resolution is different than graphics
         * resolution. Rasdd code does this.
         */

        if (!POINTEQUAL(pPDev->ptGrxRes,pPDev->ptTextRes))
            flText &= ~TC_RA_ABLE;


        /*   NOTE:  IF WE DO NOT HAVE RELATIVE MOVE COMMANDS,  TURN OF THE
         *  TC_CR_90 BIT IN fTextCaps.  THE ROTATED TEXT CODE ASSUMES THIS
         *  FUNCTIONALITY IS AVAILABLE,  SO DISABLE IT IF NOT THERE.  This does
         *  not usually happen,  as the only printers with the TC_CR_90
         *  bit set are LJ III and 4 models,  which have the relative move
         *  commands available.
         */
        if ( (COMMANDPTR(pPDev->pDriverInfo, CMD_XMOVERELLEFT) == NULL)  ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_XMOVERELRIGHT) == NULL) ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_YMOVERELUP) == NULL)    ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_YMOVERELDOWN) == NULL)  ||
             (COMMANDPTR(pPDev->pDriverInfo, CMD_SETSIMPLEROTATION) == NULL)  )
        {
            flText &= ~TC_CR_90;
            flText &= ~TC_CR_ANY;

        }
        else if ((COMMANDPTR(pPDev->pDriverInfo, CMD_SETANYROTATION) == NULL))
        {
            flText &= ~TC_CR_ANY;

        }

        //
        // Text rotation hack
        // Disable text rotation except PCL XL driver
        //
        if (pPDev->ePersonality != kPCLXL)
        {
            flText &= ~(TC_CR_ANY|TC_CR_90);
        }
    }

    PFDV->flText = flText;

    bRet = TRUE;

    ErrorExit:

    TRACE(UniFont!BInitTextFlags:END);
    return bRet;

}


BOOL
BRegReadFontCarts(
    PDEV        *pPDev                  /* PDEV to fill in */
    )
/*++

Routine Description:

    Read FontCart data form registry and Update the
    it in the in incoming devmode,
Arguments:

    pPDev - Pointer to PDEV.

    Return Value:
    TRUE  - for success
    FALSE - for failure

Note:
    11-25-96: Created it -ganeshp-
--*/
{

    FONTCARTMAP *pFontCartMap, *pTmpFontCartMap;          /* FontCart Map Pointer */
    PFONTPDEV   pFontPDev;              /* FONTPDEV access */
    int         iNumAllCartridges;      /* Total Number of Font Carts */
    HANDLE      hPrinter;               /* Printer Handle */

    int         iI;                     /* Loop index */
    DWORD       dwType;                 /* Registry access information */
    DWORD       cbNeeded;               /* Extra parameter to GetPrinterData */
    DWORD       dwErrCode = 0;          /* Error Code from GetPrinterData */
    int         iRemBuffSize = 0 ;      /* Used size of the Buffer */
    WCHAR       *pwchBuffPtr = NULL;    /* buffer Pointer */
    WCHAR       *pwchCurrBuffPtr = NULL;/* Current position buffer Pointer */


    //Initialize the variables.
    hPrinter    = pPDev->devobj.hPrinter;
    pFontPDev   = pPDev->pFontPDev;
    pFontCartMap = (pFontPDev->FontCartInfo.pFontCartMap);
    iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts;
    pFontPDev->FontCartInfo.iNumInstalledCarts = 0;

    /* If No FontCartriges are supported return TRUE */
    if (!iNumAllCartridges)
    {
        //
        // This is a valid case. Only external cartridges may be supported.
        //
        return(TRUE);
    }

    dwType = REG_MULTI_SZ;

    if( ( dwErrCode = EngGetPrinterData( hPrinter, REGVAL_FONTCART, &dwType,
                                     NULL, 0, &cbNeeded ) ) != ERROR_SUCCESS )
    {

       if( (dwErrCode != ERROR_INSUFFICIENT_BUFFER) &&
           (dwErrCode != ERROR_MORE_DATA) )
       {

          //
          // Check for the ERROR_FILE_NOT_FOUND. It's OK not to have the key.
          //
          if (dwErrCode != ERROR_FILE_NOT_FOUND)
          {
               WARNING(( "UniFont!bRegReadFontCarts:GetPrinterData(FontCart First Call) fails: Errcode = %ld\n",dwErrCode) );

               EngSetLastError(dwErrCode);
          }
          return(TRUE);
       }
       else
       {
           if( !cbNeeded     ||
               !(pwchCurrBuffPtr = pwchBuffPtr =(WCHAR *)MemAllocZ(cbNeeded)) )
           {

               ERR(( "UniFont!MemAllocZ(FontCart) failed, cbNeeded = %d:\n", cbNeeded));
               return(FALSE);
           }
       }

       VERBOSE(("\n UniFont!bRegReadFontCarts:Size of buffer needed (1) = %d\n",cbNeeded));

       if( ( dwErrCode = EngGetPrinterData( hPrinter, REGVAL_FONTCART, &dwType,
                                      (BYTE *)pwchBuffPtr, cbNeeded,
                                       &cbNeeded) ) != ERROR_SUCCESS )
       {


           ERR(( "UniFont!bRegReadFontCarts:GetPrinterData(FontCart Second Call) fails: errcode = %ld\n",dwErrCode) );
           ERR(( "                         :Size of buffer needed (2) = %d\n",cbNeeded));

           /* Free the Heap */
           if( pwchBuffPtr )
               MEMFREEANDRESET( pwchBuffPtr );

           EngSetLastError(dwErrCode);
           return(FALSE);
       }

    }
    else
    {
        //
        // We could not get the FONTCART path.
        //
        return FALSE;
    }

    VERBOSE(("UniFont!bRegReadFontCarts:Size of buffer read = %d\n",cbNeeded));

    /* iRemBuffSize is number of WCHAR */
    iRemBuffSize = cbNeeded / sizeof(WCHAR);

    /* Buffer ends with two consequtive Nulls */

    while( ( pwchCurrBuffPtr[ 0 ] != UNICODE_NULL )  )
    {
       WCHAR   achFontCartName[ MAXCARTNAMELEN ];  /* Font Cart Name */

       ZeroMemory(achFontCartName,sizeof(achFontCartName) );

       if( iRemBuffSize)
       {

          VERBOSE(("\nRasdd!bRegReadFontCarts:FontCartName in buffer = %ws\n",pwchCurrBuffPtr));
          VERBOSE(("UniFont!bRegReadFontCarts:iRemBuffSize of buffer (before) = %d\n",iRemBuffSize));

          VGetFromBuffer(achFontCartName, CCHOF(achFontCartName), &pwchCurrBuffPtr,&iRemBuffSize);

          VERBOSE(("UniFont!bRegReadFontCarts:Retrieved FontCartName = %ws\n",achFontCartName));
          VERBOSE(("UniFont!bRegReadFontCarts:iRemBuffSize of buffer (after) = %d\n",iRemBuffSize));
       }
       else
       {
           ERR(("UniFont!bRegReadTrayFormTable: Unexpected End of FontCartTable\n"));

          /* Free the Heap */
          if( pwchBuffPtr )
              MEMFREEANDRESET( pwchBuffPtr );

           return(FALSE);
       }

       pTmpFontCartMap = pFontCartMap;

       for( iI = 0; iI < iNumAllCartridges ; iI++,pTmpFontCartMap++ )
       {

           if (pTmpFontCartMap != NULL)
           {
               if ((wcscmp((PCWSTR)(&(pTmpFontCartMap->awchFontCartName)), (PCWSTR)achFontCartName ) == 0))
               {
                  pTmpFontCartMap->bInstalled = TRUE;
                  pFontPDev->FontCartInfo.iNumInstalledCarts++;
                  break;
               }
           }
       }
    }


    /* Free the Heap */
    if( pwchBuffPtr )
        MEMFREEANDRESET( pwchBuffPtr );

    return(TRUE);
}

#ifdef DELETE

VOID
VSetFontID(
    DWORD   *pdwOut,           /* The output area */
    PFONTLIST pFontList
    )
/*++

Routine Description:

    Set the bits in the available fonts bit array.  We use the 1 based
    values stored in various minidriver structures.

Arguments:

    pdwOut - Pointer to output Bit Array.
    pFontList - Pointer to FONTLIST structure.

    Return Value: None

Note:
    11-27-96: Created it -ganeshp-
--*/
{
    int     iStart;             /* Current value, or start of range */
    int     iI;                 /* Index variable */
    DWORD   *pdwList;           /* Address  font list */

    pdwList = pFontList->pdwList;

    /*
     *    The values are all singles.
     */

    for ( iI = 0; iI < pFontList->iEntriesCt; iI++ )
    {
        iStart = *pdwList++;
        pdwOut[ iStart / DWBITS ] |= 1 << (iStart  & (DWBITS - 1));

        //VERBOSE(("UniFont!VSetFontID:Setting single font indexes,index is %d\n",iStart));
        //VERBOSE(("UniFont!VSetFontID:Setting Bit number %d in Word num %d\n",\
        //(iStart  & (DWBITS - 1)),(iStart / DWBITS)) );
     }

    return;
}
#endif //DELETE


BOOL
BCheckFontMemUsage(
    PDEV    *pPDev
    )
/*++

Routine Description:
    This routine goes through the list of MemoryUsage and returns true if
    MEMORY_FONT is found.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    01-16-97: Created it -ganeshp-

--*/
{
    BOOL        bRet = FALSE;
    PLISTNODE   pListNode;


    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liMemoryUsage ) )
    {
        while (pListNode)
        {
            // Check the MEMORY_FONT value;
            if ( pListNode->dwData == MEMORY_FONT )
            {
                bRet = TRUE;
                break;
            }
            pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
        }
    }

    return bRet;

}

VOID
VSetReselectFontFlags(
    PDEV    *pPDev
    )
/*++

Routine Description:
    This routine goes through the list of Reselect Font flags and sets
    corresponding PDEV PF_ flags.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

    None
Note:
    08-07-97: Created it -ganeshp-

--*/
{
    PLISTNODE   pListNode;


    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                            pPDev->pGlobals->liReselectFont ) )
    {
        while (pListNode)
        {
            //
            // Check the ReselectFont value;
            //
            FTRC(\nUniFont!VSetReselectFontFlags:ReselectFont Flags Found\n);

            if ( pListNode->dwData == RESELECTFONT_AFTER_GRXDATA )
            {
                pPDev->fMode |= PF_RESELECTFONT_AFTER_GRXDATA;
                FTRC(UniFont!VSetReselectFontFlags:Setting PF_RESELECTFONT_AFTER_GRXDATA\n);
            }
            else if ( pListNode->dwData == RESELECTFONT_AFTER_XMOVE )
            {
                pPDev->fMode |= PF_RESELECTFONT_AFTER_XMOVE;
                FTRC(UniFont!VSetReselectFontFlags:Setting RESELECTFONT_AFTER_XMOVE\n);
            }
            else if ( pListNode->dwData == RESELECTFONT_AFTER_FF )
            {
                pPDev->fMode |= PF_RESELECTFONT_AFTER_FF;
                FTRC(UniFont!VSetReselectFontFlags:Setting RESELECTFONT_AFTER_FF\n);
            }

            pListNode = LISTNODEPTR(pPDev->pDriverInfo,pListNode->dwNextItem);
        }
    }
    else
    {
        FTRC(\nUniFont!VSetReselectFontFlags:ReselectFont Flags Not Found\n);
    }


    return;

}

INT
IGetMaxFonts(
    PDEV    *pPDev
    )

/*++

Routine Description:
    This routine returns Maximum number of fonts supported. Assumes each
    Font Cartridges and device has not more than MAXDEVFONTS.
Arguments:

    pPDev - Pointer to PDEV.

    Return Value:

    Maximum number of device fonts  - for success
    Zero  - for failure or Device fonts.

Note:
    11-18-96: Created it -ganeshp-
--*/

{
    PFONTPDEV   pFontPDev = pPDev->pFontPDev;
    PLISTNODE   pListNode;
    INT         iFontCt = 0;

    //
    // Count Device resident fonts.
    //
    if (pListNode = LISTNODEPTR(pPDev->pDriverInfo , pPDev->pGlobals->liDeviceFontList ) )
    {
        while (pListNode)
        {
            iFontCt++;

            pListNode = LISTNODEPTR(pPDev->pDriverInfo, pListNode->dwNextItem);
        }

    }


    //
    // Add Cartridge Fonts. By this time we have scanned the regitry and know
    // which fontcartridges has been installed. All we have have to do is
    // go through each font cartriges font list and add them to our list.
    //

    if (pFontPDev->FontCartInfo.iNumInstalledCarts)
    {
        INT         iNumAllCartridges, iI;
        FONTCARTMAP *pFontCartMap;  /* FontCart Map Pointer */
        SHORT       sOrient;

        pFontCartMap = (pFontPDev->FontCartInfo.pFontCartMap);
        iNumAllCartridges = pFontPDev->FontCartInfo.iNumAllFontCarts;
        sOrient = (pPDev->pdm->dmFields & DM_ORIENTATION) ?
                  pPDev->pdm->dmOrientation : (SHORT)DMORIENT_PORTRAIT;

        //
        // The logic is very simple. Installed font Cartridges are marked in
        // the Font Cartridge mapping table. We go through the mapping table
        // and for each installed cartridges we get the font list and add them
        // to our list.
        //

        for( iI = 0; iI < iNumAllCartridges ; iI++,pFontCartMap++ )
        {
            if (pFontCartMap->bInstalled == TRUE )
            {
                //
                // Check for Orientation, as there can be different font list
                // for different orientation.
                //

                if ( sOrient == DMORIENT_LANDSCAPE )
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwLandFontLst );

                }
                else
                {
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo ,
                                   pFontCartMap->pFontCart->dwPortFontLst );
                }

                while (pListNode)
                {
                    iFontCt++;
                    pListNode = LISTNODEPTR(pPDev->pDriverInfo,
                                pListNode->dwNextItem);
                }

            }

        }
    }

    return max(MAXDEVFONT,iFontCt);
    //
    // return iFontCt;
    //
}


#define MAXBUFFLEN (MAXCARTNAMELEN - 1)

VOID
VGetFromBuffer(
    IN PWSTR      pwstrDest,        /* Destination */
    IN size_t     cchDestStr,       /* How many Characters can pwstrDest hold*/
    IN OUT PWSTR *ppwstrSrc,        /* Source */
    IN OUT PINT   piRemBuffSize     /*Remaining Buffer size in WCHAR */
    )
/*++

Routine Description:

Reads a string from Multi string buffer.
Arguments:

    pwstrDest    - Pointer to Destination Buffer.
    cchDestStr   - Size of Destination Buffer (in characters).
    ppwstrSrc    - Pointer Sourc Buffer, Updated by the function.
    piRemBuffSize - Pointer to remaining buffer size. Also updated. Number of characters.

    Return Value:
    None

Note:
    11-25-96: Created it -ganeshp-
--*/
{
    if ( wcslen(*ppwstrSrc) > MAXBUFFLEN )
    {

        ERR(("Rasddlib!vGetFromBuffer:Bad Value read from registry !!\n") );
        ERR(("String Length = %d is too Big, String is %ws !!\n",wcslen(*ppwstrSrc), *ppwstrSrc) );

        *piRemBuffSize = 0;
        *ppwstrSrc[ 0 ] = UNICODE_NULL;
    }

    if ( *piRemBuffSize > 0 ) //piRemBuffSize is integer, so it can be negative.
    {
        size_t cchIncr;
        HRESULT hr;

        hr = StringCchCopy ( (LPWSTR)pwstrDest, cchDestStr, *ppwstrSrc);

        if ( SUCCEEDED (hr) )
        {
            StringCchLength ( pwstrDest, cchDestStr, &cchIncr );

            /* The return Count Doesn't include '/0'.It is number of chars copied */
            cchIncr++;  

            *ppwstrSrc   += cchIncr;
            *piRemBuffSize -= cchIncr;
        }
        else
        {
            *piRemBuffSize  = 0;
            *ppwstrSrc[ 0 ] = UNICODE_NULL;
        }

    }

}

LRESULT
PartialClipOn(
    PDEV *pPDev)
{
    DWORD dwData, dwType, dwSize;
    PVOID pvData;
    LRESULT Ret;

    Ret = E_NOTIMPL;
    pvData = &dwData;
    dwSize = sizeof(dwData);

    //
    // If there is not registry value set, returns E_NOTIMPL.
    // If there is and it is TRUE,, return S_OK
    // If there is and it is FALSE,  return S_FALSE;
    //
    if ((GetPrinterData(pPDev->devobj.hPrinter, REGVAL_PARTIALCLIP, &dwType, pvData, dwSize, &dwSize) == ERROR_SUCCESS))
    {
        if (dwData)
            Ret = S_OK;
        else
            Ret = S_FALSE;
    }

    return Ret;
}

#ifdef DELETE
INT
iMaxFontID(
    IN INT      iMax,                   /* Highest found so far */
    OUT DWORD   *pFontIndex             /* Address of start of list */
    )


/*++

Routine Description:

    Returns the index number (1 based) of the highest numbered font
    in the list supplied.

Arguments:

    iMax - Highest Font resource id foundso far.
    pFontMax - Start of the font list.

    Return Value:

    Highest font index encountered, or passed in.

Note:
    11-26-96: Created it -ganeshp-
--*/
{

    /*
     *    All we need do is scan along,  remembering the largest we find.
     */


    while( *pFontIndex )
    {
        if( (INT)*pFontIndex > iMax )
            iMax = (INT)*pFontIndex;

        ++pFontIndex;

    }


    return  iMax;
}
#endif //DELETE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\newfonts.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    newfont.c

Abstract:

    Implementation of the functions to use new font format.

Environment:

    Windows NT Unidrv driver

Revision History:

    02/21/97 -eigos-
        Support Double byte font

    01/24/97 -eigos-
        Filled in functionality

    01/14/97 -ganeshp-
        Created

--*/

#include "font.h"

//
//
//

const BYTE aubAnsi[256] =
{
 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

//
// Macro definition
//

#define DW_MASK    (DWBITS - 1)


//
// Internal function prototype
//

BOOL
BExtractGTT(
    PUNI_GLYPHSETDATA  pGTT,
    WCHAR              wchFirst,
    WCHAR              wchLast,
    FD_GLYPHSET       *pFD_GLYPHSET,
    PDWORD             pdwFD_GLYPHSETSize);

BOOL
BExtractGTTwithPredefGTT(
    IN  PUNI_GLYPHSETDATA pPreDefGTT,
    IN  PUNI_GLYPHSETDATA pMiniDefGTT,
    IN  WCHAR             wchFirst,
    IN  WCHAR             wchLast,
    OUT FD_GLYPHSET     **ppFD_GLYPHSET,
    OUT PMAPTABLE        *pMapTable,
    IN  PDWORD            pdwFD_GLYPHSETSize);

SHORT
SGetWidth(
    PWIDTHTABLE pWidthTable,
    HGLYPH      hg);


BYTE ubGetAnsi(
    WCHAR,
    INT,
    PWCHAR,
    PBYTE);

DWORD
DwCheckTrans(
    PGLYPHRUN pMiniGlyphRun,
    PMAPTABLE pMiniMapTable,
    DWORD     dwMiniGlyphRunCount,
    WORD      wUnicode);

WCHAR
WchGetNextUnicode(
    PWCHAR pwchUnicode,
    PDWORD pdwUnicodeBits,
    INT    iNumOfHandle);

int __cdecl Comp(const void *elem1, const void *elem2);

//
//
// Functions
//
//

VOID*
PVGetUCFD_GLYPHSET(
    PDEV    *pPDev,
    FONTMAP *pFM
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    PFONTMAP_DEV pFMDev;
    PVOID        pvFD_GLYPHSET = NULL;
    DWORD        dwFD_GLYPHSETSize;

    //
    // Paremeter validation
    //

    ASSERT(pFM != NULL);

    pFMDev = pFM->pSubFM;
    pvFD_GLYPHSET = NULL;

    if (pFMDev->pvNTGlyph)
    {

#if ENABLE_GTT_COMBINE
    RES_ELEM     ResElem;

        if (((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph)->lPredefinedID !=
            CC_NOPRECNV)
        {
            if (BGetWinRes( &(pPDev->WinResData),
                            ((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph)->lPredefinedID,
                            RC_GTT,
                            &ResElem))
            {
                pFMDev->pvPredefGTT = ResElem.pvResData;

        BExtractGTTwithPredefGTT(pFMDev->pvPredefGTT,
                     pFMDev->pvNTGlyph,
                     pFM->wFirstChar,
                     pFM->wLastChar,
                     pvFD_GLYPHSET,
                     (PMAPTABLE*)&pFMDev->pvMapTable,
                     &dwFD_GLYPHSETSize);

            }
            else
            {
                pFMDev->pvPredefGTT = NULL;
                ERR(("UniFont!PVGetUCFD_GLYPHSET: pvNTGTT is no loaded.\n"));
            }


        }
#endif

        //
        // First, try to get Far East Stock FD_GLYPHSET.
        //

#if ENABLE_STOCKGLYPHSET
        if (!BGetStockGlyphset( pPDev, &pvFD_GLYPHSET, (SHORT)pFMDev->sCTTid))
        {
            if (!BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                             pFM->wFirstChar,
                             pFM->wLastChar,
                             (FD_GLYPHSET*)NULL,
                             (PDWORD)&dwFD_GLYPHSETSize) ||

                !(pvFD_GLYPHSET = MemAlloc(dwFD_GLYPHSETSize)) ||

                !BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                             pFM->wFirstChar,
                             pFM->wLastChar,
                             (FD_GLYPHSET*)pvFD_GLYPHSET,
                             (PDWORD)&dwFD_GLYPHSETSize))
            {
                if (pvFD_GLYPHSET)
                {
                    MemFree(pvFD_GLYPHSET);
                    pvFD_GLYPHSET = NULL;
                    ERR(("UniFont!PVGetUCFD_GLYPHSET failed\n"));
                }
            }
        }
#else

        if (!BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                         pFM->wFirstChar,
                         pFM->wLastChar,
                         (FD_GLYPHSET*)NULL,
                         (PDWORD)&dwFD_GLYPHSETSize) ||

            !(pvFD_GLYPHSET = MemAlloc(dwFD_GLYPHSETSize)) ||

            !BExtractGTT((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph,
                         pFM->wFirstChar,
                         pFM->wLastChar,
                         (FD_GLYPHSET*)pvFD_GLYPHSET,
                         (PDWORD)&dwFD_GLYPHSETSize))
        {
            if (pvFD_GLYPHSET)
            {
                MemFree(pvFD_GLYPHSET);
                pvFD_GLYPHSET = NULL;
                ERR(("UniFont!PVGetUCFD_GLYPHSET failed\n"));
            }
        }
#endif
    }
    else
    {
        ERR(("UniFont!PVGetUCFD_GLYPHSET: pvNTGTT is no loaded.\n"));
    }

    pFMDev->pUCTree = pvFD_GLYPHSET;

    return pvFD_GLYPHSET;

}

VOID  *
PVUCKernPair(
    PDEV   *pPDev,
    FONTMAP   *pFM
    )
/*++

Routine Description:


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    PFONTMAP_DEV pFMDev;
    PKERNDATA    pKerningData;
    PUNIFM_HDR   pUFM;
    PVOID        pvKernPair = NULL;

    //
    // Paremeter validation
    //

    ASSERT(pFM != NULL);

    pFMDev = pFM->pSubFM;
    pUFM = pFMDev->pvFontRes;

    if (pFM->flFlags & FM_KERNRES)
    {
        pvKernPair = pFMDev->pUCKernTree;
    }
    else
    if (pUFM && pUFM->loKernPair)
    {
        pKerningData     = GET_KERNDATA(pUFM);
        pFMDev->pUCKernTree = pKerningData->KernPair;
        pFM->flFlags    |= FM_KERNRES;
    }

    return pvKernPair;

}

BOOL
BGetNewFontInfo(
    FONTMAP   *pFM,
    BYTE      *pRes)
/*++

Routine Description:


Arguments:

    pfm           Pointer to FONTMAP
    pRes          Pointer to UFM resource

Return Value:

    TRUE for success and FALSE for failure
Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    PUNIFM_HDR      pUFM;
    PUNIDRVINFO     pUnidrvInfo;
    PIFIMETRICS     pIFI;
    PKERNDATA       pKerningData;
    PFONTMAP_DEV    pFMDev;

    //
    // Paremeter validation
    //

    ASSERT(pFM != NULL || pRes != NULL);

    //
    // Get UFM data
    //

    pFMDev = pFM->pSubFM;
    pFMDev->pvFontRes = pRes;
    pUFM           = (PUNIFM_HDR)pRes;


    if (pUFM == NULL ||
        pUFM->loIFIMetrics == 0)
    {
        ERR(("UniFont!BGetNewFontInfo failed: Invalid FONTMAP.pUFMFontRes\n"));
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    // Get data pointer of UFM
    //

    pUnidrvInfo = GET_UNIDRVINFO(pUFM);

    //
    // Fill out FONTMAP members
    //
    if (0 != pUFM->loIFIMetrics % sizeof(PVOID))
    {
        DWORD dwSize;

        pIFI = GET_IFIMETRICS(pUFM);

        if (NULL == pIFI)
        {
            return FALSE;
        }

        dwSize = ((IFIMETRICS UNALIGNED *)(pIFI))->cjThis;

        if (pFM->pIFIMet = MemAlloc(dwSize))
        {
            CopyMemory(pFM->pIFIMet, pIFI, dwSize);
            pIFI = pFM->pIFIMet;
            pFM->flFlags &= ~FM_IFIRES;
        }
        else
            return FALSE;
    }
    else
    {
        pIFI         = GET_IFIMETRICS(pUFM);
        pFM->pIFIMet = pIFI;
        pFM->flFlags = FM_IFIRES;
    }


    if (pUnidrvInfo->SelectFont.dwCount && pUnidrvInfo->SelectFont.loOffset)
    {
        pFMDev->cmdFontSel.FInv.dwCount =
                pUnidrvInfo->SelectFont.dwCount;

        pFMDev->cmdFontSel.FInv.pubCommand =
                GET_SELECT_CMD(pUnidrvInfo);

        pFM->flFlags    |= FM_FINVOC | FM_FONTCMD;
    }

    if (pUnidrvInfo->UnSelectFont.dwCount && pUnidrvInfo->UnSelectFont.loOffset)
    {
        pFMDev->cmdFontDesel.FInv.dwCount =
                pUnidrvInfo->UnSelectFont.dwCount;

        pFMDev->cmdFontDesel.FInv.pubCommand =
                GET_UNSELECT_CMD(pUnidrvInfo);

        pFM->flFlags    |= FM_FINVOC | FM_FONTCMD;
    }

    if (pUFM->loExtTextMetric)
    {
        pFMDev->pETM = GET_EXTTEXTMETRIC(pUFM);
    }

    if (pUFM->loWidthTable)
    {
        pFMDev->W.pWidthTable = GET_WIDTHTABLE(pUFM);
        pFM->flFlags |= FM_WIDTHRES;
    }

    if (pUFM->loKernPair)
    {
        pKerningData     = GET_KERNDATA(pUFM);
        pFMDev->pUCKernTree = pKerningData->KernPair;
        pFM->flFlags    |= FM_KERNRES;
    }

    pFMDev->wDevFontType = pUnidrvInfo->wType;
    pFMDev->ulCodepage   = pUFM->ulDefaultCodepage;
    pFM->wFirstChar      = pIFI->wcFirstChar;
    pFM->wLastChar       = pIFI->wcLastChar;
    pFM->wXRes           = pUnidrvInfo->wXRes;
    pFM->wYRes           = pUnidrvInfo->wYRes;
    pFMDev->sYAdjust     = pUnidrvInfo->sYAdjust;
    pFMDev->sYMoved      = pUnidrvInfo->sYMoved;
    pFMDev->sCTTid       = (SHORT)pUFM->lGlyphSetDataRCID;
    pFMDev->fCaps        = pUnidrvInfo->fCaps;

    return TRUE;

}


INT
IGetUFMGlyphWidth(
    PDEV     *pPDev,
    FONTMAP  *pFM,
    HGLYPH     hg
    )
/*++

Routine Description:


Arguments:

    pFM           Pointer to FONTMAP

Return Value:

    Width

Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{

    return IGetUFMGlyphWidthJr(&(pPDev->ptGrxRes), pFM, hg);
}


INT
IGetUFMGlyphWidthJr(
    POINT    *pptGrxRes,
    FONTMAP  *pFM,
    HGLYPH     hg
    )
/*++

Routine Description:


Arguments:

    pFM           Pointer to FONTMAP

Return Value:

    Width

Note:

    01/14/97 -ganeshp-
        Created it.
--*/
{
    TRANSDATA      *pTrans;
    MAPTABLE       *pMapTable;
    FONTMAP_DEV    *pFMDev;
    INT             iGlyphWidth;

    //
    // UNIDRV returns 1 for the first glyph handle in FD_GLYPHSET.
    // However, GDI could pass zero in hg.
    // We need to handle this GDI error properly.
    // 
    if (NULL == pFM || NULL == pptGrxRes || 0 == hg)
    {
        return  0;
    }

    pFMDev    = pFM->pSubFM;

    if ((pFM->flFlags & FM_WIDTHRES) &&
        (iGlyphWidth = SGetWidth(pFMDev->W.pWidthTable, hg)))
    {
        iGlyphWidth = iGlyphWidth * pptGrxRes->x / pFM->wXRes;
    }
    else
    {
        pMapTable = GET_MAPTABLE(pFMDev->pvNTGlyph);
        pTrans = pMapTable->Trans;
        if (IS_DBCSCHARSET(((IFIMETRICS*)pFM->pIFIMet)->jWinCharSet))
        {
            if (pTrans[hg - 1].ubType & MTYPE_DOUBLE)
            {
                iGlyphWidth = (INT)((PIFIMETRICS)pFM->pIFIMet)->fwdMaxCharInc;
                //VERBOSE(("(2)MTYPE_DOUBLE:Char=0x%x%x, ",
                //                 pTrans[hg-1].uCode.ubPairs[0],
                //                 pTrans[hg-1].uCode.ubPairs[1]));
            }
            else
            {
                iGlyphWidth = (INT)((PIFIMETRICS)pFM->pIFIMet)->fwdAveCharWidth;
                //VERBOSE(("(2)MTYPE_SINGLE:Char=%d, ",
                //                   pTrans[hg-1].uCode.ubCode));
            }
        }
        else
        {
            iGlyphWidth = (INT)((PIFIMETRICS)pFM->pIFIMet)->fwdMaxCharInc;
        }
    }

    //VERBOSE(("Width=%d\n",iGlyphWidth));
    return iGlyphWidth;
}

BOOL
BGTTOutputGlyph(
    TO_DATA *pTod)

/*++

Routine Description:
    Same as BRLEOutputGlyph in textout.c. Should use GTT data instead of
    RLE.

Arguments:

    pTod - a pointer to TEXTOUT DATA (TO_DATA) structure

Return Value:

    TRUE for success and FALSE for failure
Note:

    02/14/97 -eigos-
        Created it.
--*/
{
    FONTPDEV          *pFontPDev;
    IFIMETRICS        *pIFIMetrics;
    PUNI_GLYPHSETDATA  pGlyphSetData;
    PUNI_CODEPAGEINFO  pCodePageInfo;
    PMAPTABLE          pMapTable;
    COMMAND           *pCmd;
    PTRANSDATA         pTrans;
    PFONTMAP_DEV       pFMDev;
    PDEV              *pPDev;
    HGLYPH             hg;
    FONTMAP           *pFM;
    PGLYPHPOS          pgp;
    POINTL             ptlRem;


    PBYTE              pString;
    DWORD              dwSize, cGlyphs;
    INT                iX, iY, iXInc, iYInc;
    BOOL               bRet;
    BOOL               bSetCursorForEachGlyph;

    pPDev         = pTod->pPDev;
    pFontPDev     = pPDev->pFontPDev;
    pFM           = pTod->pfm;
    pIFIMetrics   = (IFIMETRICS*)pFM->pIFIMet;
    pFMDev        = pFM->pSubFM;
    pGlyphSetData = (PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph;
    cGlyphs       = pTod->cGlyphsToPrint;
    pgp           = pTod->pgp;

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    if (!bSetCursorForEachGlyph ||
        pFontPDev->flFlags & FDV_DISABLE_POS_OPTIMIZE)
    {
	//
        // If bSetCursorForEachGlyph is not set, send the first character's
        // position.
        //
        // FDV_DISABLE_POS_OPTIMIZE
	// If there is rounding error, when scaling width,
	// disable x position optimization
	//

        VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);
    }

    pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;

    //
    // Set the cursor to the desired X position for this glyph.  NOTE
    // that we should only use RELATIVE move commands in here,  since
    // the LaserJet family rotates the COORDINATE AXES when text is
    // being rotated by multiples of 90 degrees.  Using relative moves
    // means we can avoid trying to figure out where the printer thinks
    // the print positiion is located.  It's almost guaranteed to be
    // different to what we think it is!
    //
    // DCR - should reorganise the move command code to do a better
    // job here.  Problem is that if we are rotating the bitmap, then MV_FINE
    // is NOT a good idea,  since it almost undoubtedly move the cursor in
    // the WRONG dimension!   When we are rotating the bitmap,  it is most
    // probable that the MV_FINE will move in the Y direction!!!
    //

    bRet = TRUE;
    iX = iY = 0;

    if (pGlyphSetData != NULL)
    {
        while (cGlyphs --)
        {
            //
            // Do nothing. GDI could pass ZERO HGLYPH.
            // GTT glyph handle starts from 1. GDI is not supposed to pass 0 in
            // HGLYPH.
            //
            if (0 == pgp->hg)
                continue;

            hg = pgp->hg;
            iX = pgp->ptl.x;
            iY = pgp->ptl.y;

            //
            // Move to the next character's position
            //
            if (bSetCursorForEachGlyph)
                VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

            //
            // Minidriver defined glyph conversion
            //

            pMapTable     = GET_MAPTABLE((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph);
            pTrans        = pMapTable->Trans;

            //
            // Send symbol set selection command
            //

            if ( pFMDev->ulCodepageID != pTrans[hg - 1].ubCodePageID )
            {
                if (pFMDev->ulCodepageID != -1)
                {
                    pCodePageInfo = GET_CODEPAGEINFO((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph);
                    pCodePageInfo += pFMDev->ulCodepageID;
                    pString = (PBYTE)pCodePageInfo +
                              pCodePageInfo->UnSelectSymbolSet.loOffset;
                    dwSize = pCodePageInfo->UnSelectSymbolSet.dwCount;

                    if (dwSize)
                    {
                        WriteSpoolBuf(pPDev, pString, dwSize);
                    }
                }

                pFMDev->ulCodepageID = pTrans[hg - 1].ubCodePageID;
                pCodePageInfo = GET_CODEPAGEINFO((PUNI_GLYPHSETDATA)pFMDev->pvNTGlyph);
                pCodePageInfo += pFMDev->ulCodepageID;
                pString = (PBYTE)pCodePageInfo +
                          pCodePageInfo->SelectSymbolSet.loOffset;
                dwSize = pCodePageInfo->SelectSymbolSet.dwCount;

                if (dwSize)
                {
                    WriteSpoolBuf(pPDev, pString, dwSize);
                }
            }

            //
            // Single/Double byte mode switch
            //

            if ((pTrans[hg - 1].ubType & MTYPE_SINGLE) &&
                !(pFontPDev->flFlags & FDV_SINGLE_BYTE)  )
            {
                if(pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTSINGLEBYTEMODE))
                {
                    pFontPDev->flFlags &= ~FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
                    WriteChannel( pPDev, pCmd );
                }
                else
                    pFontPDev->flFlags |= FDV_SINGLE_BYTE;
            }
            else
            if ((pTrans[hg - 1].ubType & MTYPE_DOUBLE)   &&
                !(pFontPDev->flFlags & FDV_DOUBLE_BYTE) )
            {
                if (pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTDOUBLEBYTEMODE))
                {
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;
                    pFontPDev->flFlags &= ~FDV_SINGLE_BYTE;
                    WriteChannel( pPDev, pCmd );
                }
                else
                    pFontPDev->flFlags |= FDV_DOUBLE_BYTE;

            }

            //
            // Send string
            //

            switch(MTYPE_FORMAT_MASK & pTrans[hg - 1].ubType)
            {
            case MTYPE_DIRECT:
                bRet = WriteSpoolBuf(pPDev, &(pTrans[hg - 1].uCode.ubCode), 1) == 1;
                break;

            case MTYPE_PAIRED:
                //
                //   First, try to use cursor push/pop escapes to
                // overlay the 2 characters. If they are not
                // available, try the backspace. If it doesn't exist
                // either, ignore the second character.
                //

                pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_PUSHCURSOR);

                pString = pTrans[hg - 1].uCode.ubPairs;

                if (pTrans[hg - 1].ubType & (MTYPE_SINGLE|MTYPE_DOUBLE))
                {
                    bRet = WriteSpoolBuf( pPDev, pString, 2 ) == 2;
                }
                else
                {
                    if ( *(pString + 1) && (pCmd != NULL) )
                    {
                        //
                        // Pushed the position; output ch1, pop position, ch2
                        //

                        bRet = WriteSpoolBuf( pPDev, pString, 1 ) == 1;
                        WriteChannel( pPDev, pCmd );
                        bRet = WriteSpoolBuf( pPDev, pString + 1, 1 ) == 1;
                    }
                    else
                    {
                        pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_BACKSPACE);

                        bRet = WriteSpoolBuf( pPDev, pString, 1 ) == 1;
                        if( (*(pString + 1)) && (pFontPDev->flFlags & FDV_BKSP_OK) )
                        {
                            WriteChannel( pPDev, pCmd );
                            bRet = WriteSpoolBuf( pPDev, pString + 1, 1 ) == 1;
                        }
                    }
                }
                break;

            case MTYPE_COMPOSE:
                pString = (PBYTE)pMapTable + pTrans[hg - 1].uCode.sCode;
                bRet = (WriteSpoolBuf(pPDev, pString + 2, *(WORD UNALIGNED *)pString) ==
                        *(WORD UNALIGNED *)pString);

                break;

            }

            pgp++;


            //
            // After drawing the character, in the printer, the cursor position
            // moves. Update the UNIDRV internal value to reduce the amount of
            // command to send.
            //
            if (bSetCursorForEachGlyph)
            {
                if( pFM->flFlags & FM_WIDTHRES)
                {
                    if ((iXInc = SGetWidth(pFMDev->W.pWidthTable, hg)))
                        iXInc = iXInc * pPDev->ptGrxRes.x / pFM->wXRes;
                    else
                        iXInc = pIFIMetrics->fwdAveCharWidth;
                }
                else
                {
                    if (pTrans[hg - 1].ubType & MTYPE_DOUBLE)
                        iXInc = pIFIMetrics->fwdMaxCharInc;
                    else
                        iXInc = pIFIMetrics->fwdAveCharWidth;
                }

                if (pFM->flFlags & FM_SCALABLE)
                {
                    iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
                }

                if (pTod->flAccel & SO_VERTICAL)
                {
                    iYInc = iXInc;
                    iXInc = 0;
                }
                else
                {
                    iYInc = 0;
                }

                VSetCursor( pPDev,
                            iXInc,
                            iYInc,
                            MOVE_RELATIVE|MOVE_UPDATE,
                            &ptlRem);
            }
        }
    }
    else
    {
        bRet = FALSE;
    }

    if (bRet && pFM)
    {
        if (!bSetCursorForEachGlyph)
        {
            //
            // Output may have successed, so update the position.
            //

            if (pFM->flFlags & FM_WIDTHRES)
            {
                if (!(iXInc = SGetWidth(pFMDev->W.pWidthTable, hg)))
                    iXInc = pIFIMetrics->fwdAveCharWidth;
            }
            else
            {
                if (pTrans[hg - 1].ubType & MTYPE_DOUBLE)
                {
                    iXInc = pIFIMetrics->fwdMaxCharInc;
                }
                else
                {
                    iXInc = pIFIMetrics->fwdAveCharWidth;
                }
            }

            if (pFM->flFlags & FM_SCALABLE)
            {
                //
                // Need to transform the value to current size
                //
                iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
            }

            if (pTod->flAccel & SO_VERTICAL)
            {
                iYInc = iXInc;
                iXInc = 0;
            }
            else
            {
                iYInc = 0;
            }
            VSetCursor( pPDev,
                        (iX + iXInc) - pTod->pgp->ptl.x,
                        (iY + iYInc) - pTod->pgp->ptl.y,
                        MOVE_RELATIVE | MOVE_UPDATE,
                        &ptlRem);
        }
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}

BOOL
BGTTSelectFont(
    PDEV     *pPDev,
    PFONTMAP pFM,
    POINTL  *pptl)
{
    PFONTMAP_DEV pfmdev;
    INT          iCmdLength;
    PBYTE        pbCmd;

    pfmdev = pFM->pSubFM;

    if ((iCmdLength = (INT)pfmdev->cmdFontSel.FInv.dwCount) &&
        (pbCmd = pfmdev->cmdFontSel.FInv.pubCommand))
    {
        pfmdev->pfnDevSelFont( pPDev, pbCmd, iCmdLength, pptl);
    }

    //
    // Reset uLCodepageID to send codepage selection command.
    //
    pfmdev->ulCodepageID = (ULONG)-1;
    ((PFONTPDEV)pPDev->pFontPDev)->flFlags &= ~FDV_DOUBLE_BYTE | FDV_SINGLE_BYTE;

    return TRUE;
}


BOOL
BGTTDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM)
{
    PFONTMAP_DEV pfmdev;
    INT          iCmdLength;
    PBYTE        pbCmd;

    pfmdev = pFM->pSubFM;

    if ((iCmdLength = (INT)pfmdev->cmdFontDesel.FInv.dwCount) &&
        (pbCmd = pfmdev->cmdFontDesel.FInv.pubCommand)        &&
        iCmdLength != WriteSpoolBuf( pPDev, pbCmd, iCmdLength)     )
    {
        return FALSE;
    }

    return TRUE;
}

//
//
// Internal functions
//
//

BOOL
BExtractGTT(
    PUNI_GLYPHSETDATA  pGTT,
    WCHAR              wchFirst,
    WCHAR              wchLast,
    FD_GLYPHSET       *pFD_GLYPHSET,
    PDWORD             pdwFD_GLYPHSETSize)
/*++

Routine Description:

    Create FD_GLYPHSET from GLYPHRUN in GTT.

Arguments:

    pGTT - GTT file resource
    pFD_GLYPHSET - a buffer to be filled out
    pdwFD_GLYPHSETSize - a pointer to the size of FD_GLYPHSET

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/
{
    PGLYPHRUN pGlyphRun;
    HGLYPH    GlyphHandle, *pGlyphHandle;
    DWORD     dwI, dwGlyphNum;
    WORD      wJ;

    //
    // parameter validation
    //

    ASSERT(pGTT != NULL);

    if (pFD_GLYPHSET == NULL)
    {
        //
        // pFD_GLYPHSET == NULL case
        // return the necessary amount of memory
        //

        pGlyphRun  = GET_GLYPHRUN(pGTT);
        dwGlyphNum = 0;

        for (dwI = 0; dwI < pGTT->dwRunCount; dwI ++, pGlyphRun ++)
        {
            dwGlyphNum += pGlyphRun->wGlyphCount;
        }

        *pdwFD_GLYPHSETSize = sizeof(FD_GLYPHSET) +
                              (pGTT->dwRunCount - 1) * sizeof(WCRUN) +
                              dwGlyphNum * sizeof(HGLYPH);
    }
    else
    {
        //
        // pFD_GLYPHSET != NULL case
        // Fill out pFD_GLYPHSET
        //

        pFD_GLYPHSET->cjThis           = *pdwFD_GLYPHSETSize;
        pFD_GLYPHSET->flAccel          = 0;
        pFD_GLYPHSET->cGlyphsSupported = 0;
        pFD_GLYPHSET->cRuns            = pGTT->dwRunCount;

        pGlyphHandle                   = (HGLYPH*)( (PBYTE)pFD_GLYPHSET +
                                         sizeof(FD_GLYPHSET) +
                                         sizeof(WCRUN) * (pGTT->dwRunCount-1) );

        pGlyphRun                      = GET_GLYPHRUN(pGTT);
        dwGlyphNum                     = 0;

        //
        // IMPORTANT!!!: Glyph handle in FD_GLYPHSET starts from 1 for GTT.
        //
        GlyphHandle                    = 1;

        for (dwI = 0; dwI < pGTT->dwRunCount; dwI ++, pGlyphRun ++)
        {
            dwGlyphNum += pGlyphRun->wGlyphCount;

            pFD_GLYPHSET->awcrun[dwI].cGlyphs = pGlyphRun->wGlyphCount;
            pFD_GLYPHSET->awcrun[dwI].wcLow = pGlyphRun->wcLow;
            pFD_GLYPHSET->awcrun[dwI].phg = pGlyphHandle;

            for (wJ = 0; wJ < pGlyphRun->wGlyphCount; wJ ++,
                                                      pGlyphHandle ++,
                                                      GlyphHandle ++)
            {
                *pGlyphHandle = GlyphHandle;
            }
        }

        pFD_GLYPHSET->cGlyphsSupported = dwGlyphNum;
    }

    return TRUE;

}


SHORT
SGetWidth(
    PWIDTHTABLE pWidthTable,
    HGLYPH      hg)
{
    // Because of a problem in at least one very common font resource DLL (HPCFONT.DLL)
    // already out and about, it's safer and easier to access this table in an unaligned
    // memory location than to try move it to align it.
    
    PWIDTHRUN pWidthRun = pWidthTable->WidthRun;
    SHORT UNALIGNED *psWidth;
    DWORD     dwRunCount = 0;

    while ( ( hg < (ULONG)(*((SHORT UNALIGNED *)&(pWidthRun->wStartGlyph)) ) ||
              (ULONG)( *((SHORT UNALIGNED *)&(pWidthRun->wStartGlyph)) )
              + ( *((SHORT UNALIGNED *)&(pWidthRun->wGlyphCount)) ) <= hg  ) &&
            dwRunCount < ( *((DWORD UNALIGNED *)&(pWidthTable->dwRunNum)) ) )
    {
        pWidthRun ++;
        dwRunCount ++;
    }

    if (dwRunCount == ( *((SHORT UNALIGNED *)&(pWidthTable->dwRunNum)) ))
    {
        return 0;
    }
    else
    {
        DWORD dwOffset = *( (DWORD UNALIGNED *) (&(pWidthRun->loCharWidthOffset)) );

        psWidth = ((SHORT UNALIGNED *)( (PBYTE)pWidthTable + dwOffset ));
        
        return psWidth[hg - ( *((SHORT UNALIGNED *)&(pWidthRun->wStartGlyph)) )];
    }
}

PUNI_GLYPHSETDATA
PNTGTT1To1(
    IN  DWORD dwCodePage,
    IN  BOOL  bSymbolCharSet,
    IN  INT   iFirstChar,
    IN  INT   iLastChar)
/*++

Routine Description:

    Generates a simple mapping format for the GTT stuff.  This is
    typically used for a printer with a 1:1 mapping to the Windows
    character set.

Arguments:

    iFirst:     The lowest glyph in the range.
    iLast:      The last glyph in the range (inclusive)


    Return Value:

    Address of GTT structure allocated from heap;  NULL on failure.


Note:
    11-27-96: Created it -ganeshp-
--*/
{

    PUNI_CODEPAGEINFO  pCodePageInfo;
    PGLYPHRUN         pGlyphRun, pGlyphRunOrg;

    TRANSDATA        *pTrans;
    PMAPTABLE         pMapTable;

    USHORT usAnsiCodePage, usOEMCodePage;

    INT  iNumOfHandle, iNumOfRuns, iTotalGlyphSetDataSize, iNumOfUnsupportChar;
    INT  iI, iJ, iK, iIndex;

    WCHAR awchUnicode[256];
    struct {
        WORD  wID;
        WCHAR Unicode;
    } UnicodeDst[256];
    WCHAR wchChar, wchCurrent, wchTemp;
    PBYTE pbBase;

    ASSERT(iFirstChar == 0x20 && iLastChar == 0xFF);

    iNumOfUnsupportChar = 0;
    iNumOfHandle =  iLastChar - iFirstChar + 1;

    if (iNumOfHandle > 256)
    {
        ERR(("UniFont!NTGTT1To1 failed:iNumOfHandle > 256.\n"));
        return NULL;
    }

    if (dwCodePage == 0)
    {
        dwCodePage = 1252;
    }

#ifndef WINNT_40 // NT 5.0
    if( -1 == (iNumOfHandle = EngMultiByteToWideChar(dwCodePage,
                                         awchUnicode,
                                         (INT)(iNumOfHandle * sizeof(WCHAR)),
                                         (PCH)aubAnsi+iFirstChar,
                                         (INT)iNumOfHandle)))
    {
        ERR(("UniFont!NTGTT1To1:EngMultiByteToWideChar failed\n"));
        return NULL;
    }
#else
    EngMultiByteToUnicodeN(awchUnicode, iNumOfHandle * sizeof(WCHAR), NULL, (PBYTE)aubAnsi+iFirstChar, iNumOfHandle);

    //
    // Disable new symbol set character range on NT4 (F020 to F0FF)
    //
    bSymbolCharSet = FALSE;
#endif // WINNT_40

    wchCurrent = 0;
    iNumOfRuns = 0;

    for (iI = 0; iI < iNumOfHandle; iI ++)
    {
        UnicodeDst[iI].wID = iI+iFirstChar;
        UnicodeDst[iI].Unicode = awchUnicode[iI];
    }

    qsort(UnicodeDst, iNumOfHandle, sizeof(WCHAR)+sizeof(WORD), Comp);

    for( iI = 0; iI < iNumOfHandle; iI ++ )
    {
        wchTemp = UnicodeDst[iI].Unicode;

        if (wchTemp == EURO_CUR_SYMBOL || wchTemp == 0xFFFF)
        {
            iNumOfUnsupportChar ++;
            UnicodeDst[iI].Unicode = 0;
            continue;
        }
        else
        if (wchTemp == wchCurrent + 1)
        {
            wchCurrent ++;
            continue;
        }

        wchCurrent = wchTemp;
        iNumOfRuns ++;
    }

    //
    // Create GLYPHRUN
    //

    if (bSymbolCharSet)
    {
        iNumOfRuns ++;
    }

    if( !(pGlyphRunOrg = pGlyphRun =
         (PGLYPHRUN)MemAlloc( iNumOfRuns * sizeof(GLYPHRUN) )) )
    {
        ERR(("UniFont!NTGTT1To1:MemAlloc failed\n"));
        return  NULL;
    }

    wchCurrent = 0;

    for (iI = 0; iI < iNumOfHandle; iI ++)
    {
        wchTemp = UnicodeDst[iI].Unicode;

        if (wchTemp == 0)
        {
            continue;
        }
        else
        if (wchTemp == wchCurrent + 1)
        {
            pGlyphRun->wGlyphCount++;
            wchCurrent ++;
        }
        else
        {
            if (wchCurrent != 0)
                pGlyphRun ++;

            wchCurrent             =
            pGlyphRun->wcLow       = wchTemp;
            pGlyphRun->wGlyphCount = 1;
        }
    }

    if (bSymbolCharSet)
    {
        pGlyphRun++;
        pGlyphRun->wcLow       = SYMBOL_START;
        pGlyphRun->wGlyphCount = NUM_OF_SYMBOL;
    }

    //
    // Calculate total size of this file.
    //

    iNumOfHandle -= iNumOfUnsupportChar;
    iTotalGlyphSetDataSize = sizeof(UNI_GLYPHSETDATA) +
                             sizeof(UNI_CODEPAGEINFO) +
                             iNumOfRuns * sizeof( GLYPHRUN ) +
                             sizeof(MAPTABLE) +
                             (iNumOfHandle - 1) * sizeof(TRANSDATA);
    if (bSymbolCharSet)
    {
        iTotalGlyphSetDataSize += sizeof(TRANSDATA) * NUM_OF_SYMBOL;
    }

    //
    // Allocate memory and set header, copy GLYPHRUN, CODEPAGEINFO
    //

    if( !(pbBase = MemAlloc( iTotalGlyphSetDataSize )) )
    {
        MemFree(pGlyphRunOrg);
        return  NULL;
    }

    ((PUNI_GLYPHSETDATA)pbBase)->dwVersion       = UNI_GLYPHSETDATA_VERSION_1_0;
    ((PUNI_GLYPHSETDATA)pbBase)->dwFlags         = 0;
    ((PUNI_GLYPHSETDATA)pbBase)->lPredefinedID   = CC_NOPRECNV;
    ((PUNI_GLYPHSETDATA)pbBase)->dwGlyphCount    = 0;
    ((PUNI_GLYPHSETDATA)pbBase)->dwCodePageCount = 1;
    ((PUNI_GLYPHSETDATA)pbBase)->dwRunCount      = iNumOfRuns;
    ((PUNI_GLYPHSETDATA)pbBase)->dwSize          = iTotalGlyphSetDataSize;
    ((PUNI_GLYPHSETDATA)pbBase)->loRunOffset     = sizeof(UNI_GLYPHSETDATA);
    ((PUNI_GLYPHSETDATA)pbBase)->loCodePageOffset =
                                    sizeof(UNI_GLYPHSETDATA) +
                                    sizeof(GLYPHRUN) * iNumOfRuns;
    ((PUNI_GLYPHSETDATA)pbBase)->loMapTableOffset =
                                    sizeof(UNI_GLYPHSETDATA) +
                                    sizeof(GLYPHRUN) * iNumOfRuns +
                                    sizeof(UNI_CODEPAGEINFO);

    CopyMemory(pbBase + sizeof(UNI_GLYPHSETDATA),
               pGlyphRunOrg,
               sizeof(GLYPHRUN) * iNumOfRuns);

    //
    // CodePageInfo
    //

    pCodePageInfo = (PUNI_CODEPAGEINFO)(pbBase + ((PUNI_GLYPHSETDATA)pbBase)->loCodePageOffset);

    pCodePageInfo->dwCodePage                 = dwCodePage;
    pCodePageInfo->SelectSymbolSet.dwCount    = 0;
    pCodePageInfo->UnSelectSymbolSet.dwCount  = 0;
    pCodePageInfo->SelectSymbolSet.loOffset   = 0;
    pCodePageInfo->UnSelectSymbolSet.loOffset = 0;

    //
    // MapTable
    //

    pMapTable = (PMAPTABLE)(pbBase +
                            ((PUNI_GLYPHSETDATA)pbBase)->loMapTableOffset);

    pMapTable->dwSize = sizeof(MAPTABLE) +
                        (iNumOfHandle - 1) * sizeof(TRANSDATA);

    pMapTable->dwGlyphNum =  iNumOfHandle;

    pTrans = pMapTable->Trans;

    iIndex = 0;
    iK = 0;

    pGlyphRun = pGlyphRunOrg;

    if (bSymbolCharSet)
    {
        for( iI = 0;  iI < iNumOfRuns; iI ++, pGlyphRun ++)
        {
            if (pGlyphRun->wcLow == SYMBOL_START)
            {
                for (iJ = SYMBOL_START; iJ <= SYMBOL_END; iJ ++)
                {
                    pTrans[iIndex].ubCodePageID = 0;
                    pTrans[iIndex].ubType       = MTYPE_DIRECT;
                    pTrans[iIndex].uCode.ubCode = (BYTE)iJ;

                    iIndex++;
                }
            }
            else
            {
                for( iJ = 0;  iJ < pGlyphRun->wGlyphCount; iJ ++)
                {
                    while (iK < 256 && UnicodeDst[iK].Unicode == 0)
                    {
                        iK++;
                    }

                    if (iK < 256)
                    {
                        pTrans[iIndex].ubCodePageID = 0;
                        pTrans[iIndex].ubType       = MTYPE_DIRECT;
                        pTrans[iIndex].uCode.ubCode = (BYTE)UnicodeDst[iK++].wID;
                        iIndex++;
                    }
                }
            }
        }
    }
    else
    {
        for( iI = 0;  iI < iNumOfHandle; iI ++)
        {
            while (iK < 256 && UnicodeDst[iK].Unicode == 0)
            {
                iK++;
            }

            if (iK < 256)
            {
                pTrans[iIndex].ubCodePageID = 0;
                pTrans[iIndex].ubType       = MTYPE_DIRECT;
                pTrans[iIndex].uCode.ubCode = (BYTE)UnicodeDst[iK++].wID;
                iIndex++;
            }
        }
    }

    MemFree(pGlyphRunOrg);

    VDBGDUMPGTT((PUNI_GLYPHSETDATA)pbBase);

    return (PUNI_GLYPHSETDATA)pbBase;
}

BOOL
BExtractGTTwithPredefGTT(
    IN PUNI_GLYPHSETDATA pPreDefGTT,
    IN PUNI_GLYPHSETDATA pMiniDefGTT,
    IN WCHAR             wchFirst,
    IN WCHAR             wchLast,
    OUT FD_GLYPHSET     **ppFD_GLYPHSET,
    OUT MAPTABLE        **ppMapTable,
    IN PDWORD            pdwFD_GLYPHSETSize)
{
    PGLYPHRUN  pPreDefGlyphRun, pMiniDefGlyphRun;
    PMAPTABLE  pMiniMapTable;
    PTRANSDATA pMiniDefTrans, pPreDefTrans;
    PTRANSDATA pSrcTrans, pDstTrans, pNewTrans, pTrans;
    WCRUN*     pWCRun;
    HGLYPH     *pHGlyph;

    DWORD      dwGlyphNum, dwMapTableSize, dwRunCount, dwIndex, dwI;
    DWORD      dwAddGlyphNum, dwSubGlyphNum, dwType;
    WORD       wJ;
    WCHAR      wcLow, wcHigh;
    BOOL       bInRun;

    //
    // FD_GLYPHSET creation.
    //
    // Additonal case:
    //     case 1: the begining of predef run
    //             Change wcLow and add cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 2: the end of predef run
    //             Change add cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 3: not in the predef run
    //             Add new WCRUN
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //
    // Disable case:
    //     case 1: the begining of predef run
    //             Change wcLow and cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 2: in the middle of predef run
    //             Divide this run into two different run.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //     case 3: the end of predef run
    //             Change cGlyphs in WCRUN.
    //             Change cGlyphsSupported in FD_GLYPHSET.
    //
    // Replace case:
    //     Do nothing.
    //

    ASSERT(pPreDefGTT != NULL && pMiniDefGTT);

    //
    // Count glyph number in predefined GTT.
    //

    dwGlyphNum = 0;
    pPreDefGlyphRun = GET_GLYPHRUN(pPreDefGTT);

    for (dwI = 0; dwI < pPreDefGTT->dwRunCount; dwI ++, pPreDefGlyphRun ++)
    {
        dwGlyphNum += pPreDefGlyphRun->wGlyphCount;
    }

    pPreDefGlyphRun  = GET_GLYPHRUN(pPreDefGTT);
    pMiniDefGlyphRun = GET_GLYPHRUN(pMiniDefGTT);
    pMiniMapTable    = GET_MAPTABLE(pMiniDefGTT);

    dwIndex = 0;

    dwAddGlyphNum = 0;
    dwSubGlyphNum = 0;

    //
    // Count a total glyph number and glyph run number.
    //

    for (dwI = 0; dwI < pMiniDefGTT->dwRunCount; dwI ++, pMiniDefGlyphRun ++)
    {
        wcHigh = pMiniDefGlyphRun->wcLow + pMiniDefGlyphRun->wGlyphCount;

        for (wJ = pMiniDefGlyphRun->wcLow; wJ < wcHigh; wJ ++, dwIndex ++)
        {
            switch (pMiniMapTable->Trans[dwIndex].ubType & MTYPE_PREDEFIN_MASK)
            {
            case MTYPE_ADD:
                dwAddGlyphNum ++;
                break;

            case MTYPE_DISABLE:
                dwSubGlyphNum ++;
                break;

            case MTYPE_REPLACE:
            default:
                break;
            }
        }
    }

    dwGlyphNum += dwAddGlyphNum - dwSubGlyphNum;

    //
    // Create MAPTABLE
    //
    // Memory allocation
    // Creation
    //
    // ----------------
    //  Predefined MAPPTABLE (1 -> n glyph handle)
    //  Minidriver's MTYPE_DISABLE is already removed.
    // ----------------
    //  Minidriver additional MAPTABLE
    //  (n + 1  -> n + m) glyph handle
    //  Even if some glyphs could be merged into Predefined MAPTABLE, we
    //  separate them with minidriver's additional glyphs for a convenience.
    // ----------------
    //

    dwMapTableSize = sizeof(MAPTABLE) + sizeof(TRANSDATA) * (dwGlyphNum - 1);

    if((*ppMapTable = MemAlloc(dwMapTableSize)) == NULL)
    {
        return FALSE;
    }

    //
    // Fill in MAPTABLE
    //

    (*ppMapTable)->dwSize     = dwMapTableSize;
    (*ppMapTable)->dwGlyphNum = dwGlyphNum;

    pPreDefGlyphRun  = GET_GLYPHRUN(pPreDefGTT);
    pMiniDefGlyphRun = GET_GLYPHRUN(pMiniDefGTT);
    pMiniMapTable    = GET_MAPTABLE(pMiniDefGTT);
    pPreDefTrans     = (GET_MAPTABLE(pPreDefGTT))->Trans;
    pMiniDefTrans    = pMiniMapTable->Trans;
    pTrans           = (*ppMapTable)->Trans;
    pNewTrans        = (*ppMapTable)->Trans + dwGlyphNum - dwAddGlyphNum;

    dwIndex      = 0;
    dwRunCount   = 0;

    for (dwI = 0; dwI < pPreDefGlyphRun->wGlyphCount; dwI ++)
    {
        wcHigh = pPreDefGlyphRun->wcLow + pPreDefGlyphRun->wGlyphCount;
        bInRun = FALSE;

        for (wJ = pPreDefGlyphRun->wcLow; wJ < wcHigh; wJ ++)
        {
            dwType = DwCheckTrans(pMiniDefGlyphRun,
                                  pMiniMapTable,
                                  pMiniDefGTT->dwRunCount,
                                  wJ);

            if ( (dwType == 0) || (dwType == MTYPE_REPLACE) )
            {
                if (!bInRun)
                {
                    dwRunCount ++;
                    bInRun = TRUE;
                }

                if (!dwType )
                {
                    pSrcTrans = pPreDefTrans;
                    pDstTrans = pTrans;
                }
                else
                if (dwType == MTYPE_REPLACE)
                {
                    pSrcTrans = pMiniDefTrans;
                    pDstTrans = pTrans;
                }

                pDstTrans->ubCodePageID = pSrcTrans->ubCodePageID;
                pDstTrans->ubType       = pSrcTrans->ubType;

                switch(pSrcTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_COMPOSE:
                    pDstTrans->uCode.ubCode = pSrcTrans->uCode.ubCode;
                    break;

                case MTYPE_DIRECT:
                    pDstTrans->uCode.ubPairs[0] = pSrcTrans->uCode.ubPairs[0];
                    pDstTrans->uCode.ubPairs[1] = pSrcTrans->uCode.ubPairs[1];
                    break;

                case MTYPE_PAIRED:
                    pDstTrans->uCode.sCode = pSrcTrans->uCode.sCode;
                    break;
                }

                pSrcTrans ++;
                pDstTrans ++;
            }
            else
            if (dwType == MTYPE_DISABLE)
            {
                pPreDefTrans ++;

                if (bInRun && wJ != wcHigh - 1)
                {
                    dwRunCount ++;
                    bInRun = FALSE;
                }
            }
        }
    }


    for (dwI = 0; dwI < pMiniDefGlyphRun->wGlyphCount; dwI ++)
    {
        wcHigh = pMiniDefGlyphRun->wcLow + pMiniDefGlyphRun->wGlyphCount;
        bInRun = FALSE;

        for (wJ = pMiniDefGlyphRun->wcLow; wJ < wcHigh; wJ ++, pMiniDefTrans ++)
        {
            if (pMiniDefTrans->ubType & MTYPE_ADD)
            {
                pNewTrans->ubCodePageID = pMiniDefTrans->ubCodePageID;
                pNewTrans->ubType       = pMiniDefTrans->ubType;

                switch (pNewTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_COMPOSE:
                    pNewTrans->uCode.ubCode = pMiniDefTrans->uCode.ubCode;
                    break;

                case MTYPE_DIRECT:
                    pNewTrans->uCode.ubPairs[0] = pMiniDefTrans->uCode.ubPairs[0];
                    pNewTrans->uCode.ubPairs[1] = pMiniDefTrans->uCode.ubPairs[1];
                    break;

                case MTYPE_PAIRED:
                    pNewTrans->uCode.sCode = pMiniDefTrans->uCode.sCode;
                    break;
                }

                pNewTrans ++;

                if (!bInRun)
                {
                    dwRunCount ++;
                    bInRun = TRUE;
                }
            }
            else
            {
                if (bInRun)
                {
                    bInRun = FALSE;
                }
            }
        }
    }

    //
    // Crate FD_GLYPHSET
    //
    // Memory allocation with dwGlyphNum and dwRunCount.
    //
    // -----------------
    // Predefined FD_GLYPHSET
    // -----------------
    // Minidriver additional glyph run
    // ----------------
    //

    //
    // Now we know the number of run. Allocate memory for FD_GLYPHSET.
    //

    *pdwFD_GLYPHSETSize = sizeof(FD_GLYPHSET) +
                          sizeof(WCRUN) * dwRunCount +
                          sizeof(HGLYPH) * dwGlyphNum;

    if((*ppFD_GLYPHSET = (FD_GLYPHSET*)MemAlloc(*pdwFD_GLYPHSETSize)) == NULL)
    {
        MemFree(*ppMapTable);
        return FALSE;
    }

    (*ppFD_GLYPHSET)->cjThis           = *pdwFD_GLYPHSETSize;
    (*ppFD_GLYPHSET)->cGlyphsSupported = *pdwFD_GLYPHSETSize;
    (*ppFD_GLYPHSET)->cRuns            = dwRunCount;

    pWCRun           = (*ppFD_GLYPHSET)->awcrun;
    pHGlyph          = (HGLYPH*)((PBYTE)*ppFD_GLYPHSET +
                                  sizeof(FD_GLYPHSET) +
                                  sizeof(WCRUN) * dwRunCount);

    pPreDefGlyphRun  = GET_GLYPHRUN(pPreDefGTT);
    pMiniDefGlyphRun = GET_GLYPHRUN(pMiniDefGTT);
    pMiniDefTrans    = pMiniMapTable->Trans;

    for (dwI = 1; dwI <= dwGlyphNum; dwI ++, *pHGlyph)
    {
        *pHGlyph = dwI;
    }

    pHGlyph = (HGLYPH*)((PBYTE)*ppFD_GLYPHSET +
                        sizeof(FD_GLYPHSET) +
                        sizeof(WCRUN) * dwRunCount);

    for (dwI = 0; dwI < pPreDefGlyphRun->wGlyphCount; dwI ++)
    {
        pWCRun->wcLow = wcLow
                      = pPreDefGlyphRun->wcLow;
        wcHigh        = wcLow + pPreDefGlyphRun->wGlyphCount;
        bInRun        = FALSE;

        for (wJ = pPreDefGlyphRun->wcLow; wJ < wcHigh; wJ ++)
        {
            if (MTYPE_DISABLE == DwCheckTrans(pMiniDefGlyphRun,
                                              pMiniMapTable,
                                              pMiniDefGTT->dwRunCount,
                                              wJ))
            {
                if (bInRun)
                {
                    pWCRun->cGlyphs = wJ - wcLow + 1;
                    pWCRun->phg     = pHGlyph;
                    pHGlyph        += pWCRun->cGlyphs;

                    pWCRun ++;
                    bInRun = FALSE;
                }
            }
            else
            {
                if (!bInRun)
                {
                    pWCRun->wcLow = wcLow
                                  = wJ;
                    wcHigh        = wcLow + pPreDefGlyphRun->wGlyphCount;
                    bInRun        = TRUE;
                }
            }
        }
        pWCRun->cGlyphs = wcHigh - wcLow;
        pWCRun->phg = pHGlyph;

        pWCRun ++;
    }

    bInRun = FALSE;

    for (dwI = 0; dwI < pMiniDefGlyphRun->wGlyphCount; dwI ++)
    {
        for (wJ = pMiniDefGlyphRun->wcLow; wJ < wcHigh; wJ ++, pMiniDefTrans ++)
        {
            if (pMiniDefTrans->ubType & MTYPE_ADD)
            {
                if (!bInRun)
                {
                    pWCRun->wcLow  = wcLow = wJ;
                    bInRun         = TRUE;
                }
            }
            else
            {
                if (bInRun)
                {
                    pWCRun->cGlyphs = wJ - wcLow + 1;
                    pWCRun->phg     = pHGlyph;
                    pHGlyph        += pWCRun->cGlyphs;

                    bInRun          = FALSE;
                }
            }
        }
    }

    return TRUE;
}

DWORD
DwCheckTrans(
    PGLYPHRUN pMiniGlyphRun,
    PMAPTABLE pMiniMapTable,
    DWORD     dwMiniGlyphRunCount,
    WORD      wUnicode)
{
    DWORD dwI;
    WORD  wIndex;

    for (dwI = 0; dwI < dwMiniGlyphRunCount; dwI ++, pMiniGlyphRun ++)
    {
        if (wUnicode < pMiniGlyphRun->wcLow)
        {
            continue;
        }

        if (wUnicode < pMiniGlyphRun->wcLow + pMiniGlyphRun->wGlyphCount)
        {
            wIndex = wUnicode - pMiniGlyphRun->wcLow;

            return pMiniMapTable->Trans[wIndex].ubType & MTYPE_PREDEFIN_MASK;
        }
        else
        {
            return 0;
        }
    }

    return 0;
}

int __cdecl Comp(const void *elem1, const void *elem2)
{
    //struct {
    //    WORD  wID;
    //    WCHAR Unicode;
    //} UnicodeDst[256];
    //
    // Compare Unicode in this data structure
    //
    return *((PWORD)elem1+1) - *((PWORD)elem2+1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\oldfonts.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    oldfont.c

Abstract:

    Implementation of the functions to use NT4.0 font format.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/02/97 -eigos-
        Created

--*/

#include "font.h"

//
// Macro
//

#define ADDR_CONV(x)    ((BYTE *)pFDH + pFDH->x)

ULONG UlCharsetToCodepage(
        BYTE ubCharSet)
{
    CHARSETINFO CharsetInfo;
    
    //
    // Initialize CharsetInfo
    // 
    CharsetInfo.ciCharset = 0;
    CharsetInfo.ciACP = 1252;
    CharsetInfo.fs.fsUsb[0] = 0x01;
    CharsetInfo.fs.fsUsb[1] = CharsetInfo.fs.fsUsb[2] = CharsetInfo.fs.fsUsb[3] = 0;
    CharsetInfo.fs.fsCsb[0] = 0x01;
    CharsetInfo.fs.fsCsb[1] = 0;

    PrdTranslateCharsetInfo((UINT)ubCharSet, &CharsetInfo, TCI_SRCCHARSET);
    return CharsetInfo.ciACP;
}

BOOL
BGetOldFontInfo(
    FONTMAP   *pfm,
    BYTE      *pRes
    )
/*++

Routine Description:

    Fill in the FONTMAP data using the NT format data passed to us.
    There is not too much for us to do,  since the NT data is
    all in the desired format.  However,  we do have to update some
    addresses.

Arguments:

    pfm - Pointer to FONTMAP.

    pRes - Pointer to Font Resource.

    Return Value:

    TRUE  - for success
    FALSE - for failure

Note:
    12-05-96: Created it -ganeshp-
--*/
{

    FI_DATA_HEADER  *pFDH;
    FONTMAP_DEV     *pfmdev;

    ASSERT(pfm != NULL &&
           pRes != NULL &&
           pfm->dwFontType == FMTYPE_DEVICE &&
           pfm->flFlags & FM_IFIVER40);

    pfmdev = pfm->pSubFM;

    pfmdev->pvFontRes = pRes;

    //
    // Old Format Data
    //
    pFDH = (FI_DATA_HEADER *)pRes;

    //
    //   Verify that there is some semblance of correctness
    //
    if( pFDH->cjThis != sizeof( FI_DATA_HEADER ) )
    {
        ERR(( "BGetOldFontInfo: invalid FI_DATA_HEADER\n" ));
        return  FALSE;
    }

    //
    //  Mark this data as being in a resource
    //
    pfm->flFlags |= (FM_IFIRES | FM_FONTCMD);


    pfm->pIFIMet = (IFIMETRICS *)ADDR_CONV( dwIFIMet );

    if (!(pfm->flFlags & FM_SOFTFONT))
    {
        if( pFDH->dwCDSelect )
        {
            pfmdev->cmdFontSel.pCD = (CD *)ADDR_CONV( dwCDSelect );
            ASSERT(pfmdev->cmdFontSel.pCD);
        }

        if( pFDH->dwCDDeselect )
        {
            pfmdev->cmdFontDesel.pCD = (CD *)ADDR_CONV( dwCDDeselect );
            ASSERT(pfmdev->cmdFontDesel.pCD);
        }

    }

    if( pFDH->dwETM )
    {
        pfmdev->pETM = (EXTTEXTMETRIC *)ADDR_CONV( dwETM );
    }

    if( pFDH->dwWidthTab )
    {
        pfmdev->W.psWidth = (short *)ADDR_CONV( dwWidthTab );
        pfm->flFlags |= FM_WIDTHRES;             /* Width vector too! */
    }

    /*
     *    Miscellaneous odds & ends.
     */

    pfmdev->ulCodepage = UlCharsetToCodepage(pfm->pIFIMet->jWinCharSet);

    pfmdev->sCTTid    = pFDH->u.sCTTid;
    pfmdev->fCaps     = pFDH->fCaps;
    pfmdev->wDevFontType = pFDH->wFontType;
    pfm->wXRes        = pFDH->wXRes;
    pfm->wYRes        = pFDH->wYRes;
    pfmdev->sYAdjust  = pFDH->sYAdjust;
    pfmdev->sYMoved   = pFDH->sYMoved;

    return  TRUE;
}


BOOL
BRLEOutputGlyph(
    TO_DATA *pTod
    )
/*++

Routine Description:
    Send printer commands to print the glyph passed in.  Basically
    we do the translation from ANSI to the printer's representation,

Arguments:
    hg      HGLYPH of interest

Return Value:
    TRUE for success and FALSE for failure.FALSE being a failure of Spool

Note:

    1/22/1997 -ganeshp-
        Created it.
--*/

{
    PDEV        *pPDev;         // UNIDRV PDEV
    FONTPDEV    *pFontPDev;     // Font PDEV
    FONTMAP_DEV *pFMDev;        // Device font PDEV
    FONTMAP     *pFM;           // Fontmap data structure
    NT_RLE      *pntrle;        // Access to data to send to printer
    COMMAND     *pCmd;          // Command Pointer
    PGLYPHPOS    pgp;
    POINTL       ptlRem;

    HGLYPH       hg;
    UHG          uhg;           // Various flavours of HGLYPH contents
    INT          iLen;          // Length of string
    INT          iIndex;        // Index from glyph to width table
    INT          cGlyphs;
    INT          iX, iY, iXInc, iYInc;
    BYTE        *pb;            // Determining length for above
    BOOL         bRet;          // Returned to caller
    BOOL         bSetCursorForEachGlyph;

    ASSERT(pTod);

    pPDev     = pTod->pPDev;
    pFontPDev = pPDev->pFontPDev;
    pFM       = pTod->pfm;
    pFMDev    = pFM->pSubFM;
    pntrle    = pFMDev->pvNTGlyph;
    cGlyphs   = pTod->cGlyphsToPrint;
    pgp       = pTod->pgp;

    ASSERT(pPDev && pFontPDev && pFM && pFMDev && pntrle && pgp);

    bSetCursorForEachGlyph = SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel);

    if (!bSetCursorForEachGlyph)
        VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &ptlRem);

    pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;

    bRet = FALSE;               /* Default case */
    iX = iY = 0;

    while (cGlyphs --)
    {
        hg = uhg.hg = pgp->hg;     /* Lets us look at it however we want */
        iX = pgp->ptl.x;
        iY = pgp->ptl.y;

        //
        // Move to the next character's position
        //
        if (bSetCursorForEachGlyph)
            VSetCursor( pPDev, iX, iY, MOVE_ABSOLUTE, &ptlRem);

        if( pntrle )
        {
            /*   The normal case - a standard device font */

            switch( pntrle->wType )
            {
            case RLE_DIRECT:            /*  Up to 2 bytes of data */
                iLen = uhg.rd.b1 ? 2 : 1;
                iIndex = uhg.rd.wIndex;

                bRet = WriteSpoolBuf( pPDev, &uhg.rd.b0, iLen ) == iLen;

                break;

            case  RLE_PAIRED:           /* Two glyphs (1 byte), overstruck */
                /*
                 *   First, try to use cursor push/pop escapes to
                 * overlay the 2 characters. If they are not
                 * available, try the backspace. If it doesn't exist
                 * either, ignore the second character.
                 */

                pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_PUSHCURSOR);

                if ( uhg.rd.b1 && (pCmd != NULL) )
                {
                    /* Pushed the position; output ch1, pop position, ch2 */
                    bRet = WriteSpoolBuf( pPDev, &uhg.rd.b0, 1 ) == 1;
                    WriteChannel( pPDev, pCmd );
                    bRet = WriteSpoolBuf( pPDev, &uhg.rd.b1, 1 ) == 1;
                }
                else
                {
                    pCmd = COMMANDPTR(pPDev->pDriverInfo, CMD_BACKSPACE);

                    bRet = WriteSpoolBuf( pPDev, &uhg.rd.b0, 1 ) == 1;
                    if( uhg.rd.b1 && (pFontPDev->flFlags & FDV_BKSP_OK) )
                    {
                        WriteChannel( pPDev, pCmd );
                        bRet = WriteSpoolBuf( pPDev, &uhg.rd.b1, 1 ) == 1;
                    }
                }
                iIndex = uhg.rd.wIndex;

                break;

            case  RLE_LI_OFFSET:               /* Compact format of offset mode */
                if( uhg.rli.bLength <= 2 )
                {
                    /*   Compact format:  the data is in the offset field */
                    pb = &uhg.rlic.b0;
                }
                else
                {
                    /*  Standard format:  the offset points to the data */
                    pb = (BYTE *)pntrle + uhg.rli.wOffset;
                }
                iLen = uhg.rli.bLength;
                iIndex = uhg.rli.bIndex;

                bRet = WriteSpoolBuf(pPDev, pb, iLen ) == iLen;
                break;


            case  RLE_L_OFFSET:                /* Arbitrary length strings */
                /*
                 *    The HGLYPH contains a 3 byte offset from the beginning of
                 *  the memory area,  and a 1 byte length field.
                 */
                pb = (BYTE *)pntrle + (hg & 0xffffff);
                iLen = (hg >> 24) & 0xff;

                iIndex = *((WORD *)pb);
                pb += sizeof( WORD );

                bRet = WriteSpoolBuf(pPDev, pb, iLen ) == iLen;

                break;

            default:
                ERR(( "Rasdd!bOutputGlyph: Unknown HGLYPH format %d\n",
                                                                  pntrle->wType ));
                SetLastError( ERROR_INVALID_DATA );
                break;
            }
        }

        //
        // After drawing the character, in the printer, the cursor position
        // moves. Update the UNIDRV internal value to reduce the amount of
        // command to send.
        //
        if (bSetCursorForEachGlyph)
        {
            if( pFMDev->W.psWidth)
            {
                iXInc = pFMDev->W.psWidth[iIndex];
                iXInc = iXInc * pPDev->ptGrxRes.x / pFM->wXRes;
            }
            else
                iXInc = ((IFIMETRICS *)(pFM->pIFIMet))->fwdMaxCharInc;

            if( pFM->flFlags & FM_SCALABLE )
            {
                iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
            }

            if (pTod->flAccel & SO_VERTICAL)
            {
                iYInc = iXInc;
                iXInc = 0;
            }
            else
            {
                iYInc = 0;
            }

            VSetCursor( pPDev,
                        iXInc,
                        iYInc,
                        MOVE_RELATIVE|MOVE_UPDATE,
                        &ptlRem);
        }

        pgp ++;
    }

    /*
     *    If the output succeeded,  update our view of the printer's
     *  cursor position.  Typically,  this will be to move along the
     *  width of the glyph just printed.
     */

    if( bRet && pFM)
    {
        //
        // Output may have succeeded,  so update the position for default
        // placement.
        //

        if( !bSetCursorForEachGlyph)
        {
            if( pFMDev->W.psWidth )
            {
                /*
                 *    Proportional font - so use the width table.  Note that
                 *  it will also need scaling,  since the fontwidths are stored
                 *  in the text resolution units.
                 */
                /*  This also scales correctly for downloaded fonts */

                iXInc =  pFMDev->W.psWidth[iIndex];
                iXInc = iXInc * pPDev->ptGrxRes.x / pFM->wXRes;
            }
            else
            {
                /*
                 *   Fixed pitch font - metrics contains the information. NOTE
                 * that scaling is NOT required here,  since the metrics data
                 * has already been scaled.
                 */
                iXInc = ((IFIMETRICS *)(pFM->pIFIMet))->fwdMaxCharInc;
            }

            if( pFM->flFlags & FM_SCALABLE )
            {
                iXInc = LMulFloatLong(&pFontPDev->ctl.eXScale,iXInc);
            }

            if (pTod->flAccel & SO_VERTICAL)
            {
                iYInc = iXInc;
                iXInc = 0;
            }
            else
            {
                iYInc = 0;
            }

            VSetCursor( pPDev,
                        (iX + iXInc) - pTod->pgp->ptl.x,
                        (iY + iYInc) - pTod->pgp->ptl.y,
                        MOVE_RELATIVE | MOVE_UPDATE,
                        &ptlRem);
        }
    }
    else
        bRet = FALSE;

    return   bRet;
}

BOOL
BRLESelectFont(
    PDEV     *pPDev,
    PFONTMAP  pFM,
    POINTL   *pptl)
{
    FONTMAP_DEV *pfmdev = pFM->pSubFM;
    CD          *pCD;

    ASSERT(pPDev && pfmdev);

    if (!(pCD = pfmdev->cmdFontSel.pCD))
        return FALSE;

    pfmdev->pfnDevSelFont(pPDev,
                          pCD->rgchCmd,
                          pCD->wLength,
                          pptl);

    return TRUE;
}

BOOL
BSelectNonScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    if( iCmdLength > 0 && pbCmd &&
        WriteSpoolBuf( pPDev, pbCmd, iCmdLength ) != iCmdLength)
    {
        return  FALSE;
    }

    return TRUE;
}

BOOL
BSelectPCLScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    INT  iIn, iConv, iOut, iLen;
    BYTE aubLocal[80];

    ASSERT(pPDev && pbCmd && pptl);

    iOut = 0;

    for( iIn = 0; (iIn < iCmdLength) && (iOut < CCHOF (aubLocal)); iIn++ )
    {
        if( pbCmd[ iIn ] == '#')
        {
            //
            // The next byte tells us what information is required.
            //

            switch ( pbCmd[ iIn + 1 ] )
            {
                case  'v':
                case  'V':       /*   Want the font's height */
                    iConv = pptl->y;
                    break;

                case  'h':
                case  'H':       /* Want the pitch */
                    iConv = pptl->x;
                    break;

                default:        /* This should not happen! */
                    ERR(( "UniFont!BSelScalableFont(): Invalid command format\n"));
                    return  FALSE;           /* Bad news */
            }
        
            iLen = IFont100toStr( &aubLocal[ iOut ], CCHOF(aubLocal) - iOut, iConv );


            if ( (iLen < 0) || iLen > ( (INT) CCHOF(aubLocal) - iOut ) )
            {
                ERR(( "UniFont!BSelectPCLScalableFont(): Error. Command may be too big\n"));
                return  FALSE;           /* Bad news */
            }

            iOut += iLen;


        }
        else
            aubLocal[iOut++] = pbCmd[iIn];
    }

    WriteSpoolBuf( pPDev, aubLocal, iOut);

    return TRUE;
}

BOOL
BSelectCapslScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    INT  iIn, iConv, iOut, iLen;
    BYTE aubLocal[80];

    ASSERT(pPDev && pbCmd && pptl);

    iOut = 0;

    for( iIn = 0; iIn < iCmdLength && (iOut < CCHOF (aubLocal) ) ; iIn++ )
    {
        if( pbCmd[ iIn ] == '#')
        {
            //
            // The next byte tells us what information is required.
            //

            switch ( pbCmd[ iIn + 1 ] )
            {
                case  'v':
                case  'V':
                    iConv = pptl->y * 300 / 72;
                    break;

                case  'h':
                case  'H':
                    iConv = pptl->x;
                    break;

                default:
                    ERR(( "Invalid command format\n"));
                    return  FALSE;
            }
            iIn ++;

            iLen = iDrvPrintfSafeA(&aubLocal[iOut], CCHOF(aubLocal)-iOut, "%d", (iConv + 50)/100);
            if ( iLen <= 0 || iLen > (INT)CCHOF(aubLocal)-iOut )
            {
                ERR( ("Invalid command format. Command maybe too big\n"));
                return FALSE;
            }
            iOut += iLen;
        }
        else
            aubLocal[iOut++] = pbCmd[iIn];
    }

    WriteSpoolBuf( pPDev, aubLocal, iOut);

    return TRUE;
}

BOOL
BSelectPPDSScalableFont(
    PDEV   *pPDev,
    BYTE   *pbCmd,
    INT     iCmdLength,
    POINTL *pptl)
{
    INT  iIn, iOut, iConv;
    BYTE aubLocal[80];

    ASSERT(pPDev && pbCmd && pptl);

    iOut = 0;

    for( iIn = 0; iIn < iCmdLength && (iOut < CCHOF (aubLocal) ); iIn++ )
    {
        if (pbCmd[ iIn ] == '\x0B' && pbCmd[ iIn + 1] == '#')
        //
        // Height param for PPDS
        //
        {
            if ( iOut + 8 < CCHOF (aubLocal) ) //8 chars to be written into aubLocal
            {

                aubLocal[ iOut++ ] = '\x0B';
                aubLocal[ iOut++ ] = '\x06';
                iConv = pptl->y;
    
                //
                //  Due to restriction of PPDS cmds, param must be sent in
                //  xxx.xx format !
                //

                if ( ( iDrvPrintfSafeA(&aubLocal[ iOut ], CCHOF(aubLocal)-iOut, "%05d",iConv ) ) != 5 )
                        return FALSE;   /* Bad news */
    
                //
                // insert the decimal point
                //
                aubLocal[ iOut+5 ] = aubLocal[ iOut+4 ];
                aubLocal[ iOut+4 ] = aubLocal[ iOut+3 ];
                aubLocal[ iOut+3 ] = '.';
    
                iOut += 6; // xxx.xx  ( ie 6 incl decimal pt
                iIn++;
            }
            else
            {
                ERR( ("Invalid command format. Command maybe too big\n"));
                return FALSE;
            }
        }
        else if (pbCmd[ iIn ] == '\x0E' && pbCmd[ iIn + 1] == '#') 
        //
        // Pitch param  for GPC_TECH_PPDS
        //
        {
            if ( iOut + 9 < CCHOF (aubLocal) ) //9 chars to be written into aubLocal
            {
                aubLocal[ iOut++ ] = '\x0E';
                aubLocal[ iOut++ ] = '\x07';
                aubLocal[ iOut++ ] = '\x30';  // special byte required
                iConv = pptl->x;

                if ( ( iDrvPrintfSafeA(&aubLocal[ iOut ], CCHOF(aubLocal)-iOut, "%05d",iConv ) ) != 5 )
                    return FALSE;
    
                //
                // insert the decimal point
                //
    
                aubLocal[ iOut+5 ] = aubLocal[ iOut+4 ];
                aubLocal[ iOut+4 ] = aubLocal[ iOut+3 ];
                aubLocal[ iOut+3 ] = '.';

                iOut += 6; // xxx.xx  ( ie 6 incl decimal pt
                iIn++;
            }
            else
            {
                ERR( ("Invalid command format. Command maybe too big\n"));
                return FALSE;
            }
        }
        else
            //
            // No translation necessary
            //
            aubLocal[ iOut++ ] = pbCmd[ iIn ];

    }

    WriteSpoolBuf( pPDev, aubLocal, iOut );

    return TRUE;

}

BOOL
BRLEDeselectFont(
    PDEV     *pPDev,
    PFONTMAP pFM)
{
    PFONTMAP_DEV  pfmdev;
    CD           *pCD;
    BOOL          bRet = TRUE;

    ASSERT(pPDev && pFM);

    pfmdev = pFM->pSubFM;
    pCD    = pfmdev->cmdFontDesel.pCD;

    if (pCD &&
        pCD->wLength != 0 &&
        pCD->rgchCmd &&
        pCD->wLength != WriteSpoolBuf(pPDev, pCD->rgchCmd, pCD->wLength))
            bRet = FALSE;

    return bRet;
}


INT
IGetIFIGlyphWidth(
    PDEV    *pPDev,
    FONTMAP *pFM,
    HGLYPH   hg)
{
    FONTMAP_DEV *pfmdev;
    NT_RLE      *pntrle;           // The RLE stuff - may be needed
    UHG          uhg;              // Defined access to HGLYPH contents
    INT          iWide = 0;

    ASSERT(pPDev && pFM);

    pfmdev = pFM->pSubFM;
    pntrle = pfmdev->pvNTGlyph;

    ASSERT(pfmdev && pntrle);

    if( pfmdev->W.psWidth )
    {
        /*   Proportional font - width varies per glyph */

        uhg.hg = (HGLYPH)hg;

        /*
         *    We need the index value from the HGLYPH.  The
         *  index is the offset in the width table.  For all
         *  but the >= 24 bit offset types,  the index is
         *  included in the HGLYPH.  For the 24 bit offset,
         *  the first WORD of the destination is the index,
         *  while for the 32 bit offset, it is the second WORD
         *  at the offset.
         */

        switch( pntrle->wType )
        {
        case  RLE_DIRECT:
        case  RLE_PAIRED:
            iWide = uhg.rd.wIndex;
            break;

        case  RLE_LI_OFFSET:
            iWide = uhg.rli.bIndex;
            break;

        case  RLE_L_OFFSET:
            iWide = (DWORD)uhg.hg & 0x00ffffff;
            iWide = *((WORD *)((BYTE *)pntrle + iWide));
            break;

        case  RLE_OFFSET:
            iWide = (DWORD)uhg.hg + sizeof( WORD );
            iWide = *((WORD *)((BYTE *)pntrle + iWide));
            break;
        }

        iWide = pfmdev->W.psWidth[iWide];

        //
        // If this is a proportionally spaced font,
        // we need to adjust the width table entries
        // to the current resolution.  The width tables are NOT
        // converted for lower resolutions,  so we add the factor in now.
        // Fixed pitch fonts must not be adjusted, since the width is converted
        // in the font metrics.
        //

        iWide = iWide * pPDev->ptGrxRes.x / pFM->wXRes;
    }
    else
    {
        //
        //  Fixed pitch fonts come from IFIMETRICS
        //

        iWide = ((IFIMETRICS  *)(pFM->pIFIMet))->fwdMaxCharInc;

    }

    return iWide;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\qeryfont.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qeryfont.c

Abstract:

    Implementation of Functions to answer font queries from the engine.
Environment:

    Windows NT Unidrv driver

Revision History:

    12/19/96 -ganeshp-
        Created

--*/

#include "font.h"



PIFIMETRICS
FMQueryFont(
    PDEV    *pPDev,
    ULONG_PTR iFile,
    ULONG   iFace,
    ULONG_PTR *pid
    )
/*++

Routine Description:
    Returns the IFIMETRICS of the nominated font.

Arguments:

    pPDev           Pointer to PDEV
    iFile           This is the identifier of the driver font file.
    iFace           Font index of interest,  first is # 1
    pid             Can be used by driver to id or flag the return data

Return Value:

    Pointer to the IFIMETRICS of the requested font.  NULL on error.
Note:
    11-18-96: Created it -ganeshp-

--*/

{

    //
    //    This is not too hard - verify that iFace is within range,  then
    //  use it as an index into the array of FONTMAP structures hanging
    //  off the PDEV!  The FONTMAP array contains the address of the
    //  IFIMETRICS structure!
    //

    FONTPDEV *pFontPDev;
    FONTMAP  *pfm;

    pFontPDev = PFDV;

    //
    // This can be used by the driver to flag or id the data returned.
    // May be useful for deletion of the data later by DrvFree().
    //

    *pid = 0;        // dont really need to do anything with it

    if( iFace == 0 && iFile == 0 )
    {
        return (IFIMETRICS *)IntToPtr(pPDev->iFonts);
    }

    if( iFace < 1 || (int)iFace > pPDev->iFonts )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        ERR(( "iFace = %ld WHICH IS INVALID\n", iFace ));
        return  NULL;
    }

    pfm = PfmGetDevicePFM( pPDev, iFace );

    return   pfm ? pfm->pIFIMet : NULL;

}

ULONG
FMGetGlyphMode(
    PDEV    *pPDev,
    FONTOBJ *pfo
    )
/*++

Routine Description:
    Tells engine how we want to handle various aspects of glyph
    information.
Arguments:

    pPDev           Pointer to PDEV.
    pfo             The font in question?.

Return Value:

    Information about glyph handling.
Note:
    11-18-96: Created it -ganeshp-

--*/
{
    return  FO_GLYPHBITS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\posnsort.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    posnsort.h

Abstract:

    The details required for posnsort.c - code used to sort the output
    glyphs by position on the page.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/02/97 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _POSNSORT_H

/*
 *   The structure used to store glyph data.  These are allocated from
 *  chunks of memory,  as required.  Entries are stored as an array,
 *  but are part of a linked list;  there is one list for every y
 *  value.  The order in the linked list is that in which the glyphs
 *  are received by the driver,  which may or may not be the order
 *  in which they will be printed.
 */
typedef  struct PSGlyph
{
    struct  PSGlyph  *pPSGNext;         /* Next in list,  0 for last */
    INT     ixVal;                      /* The X coordinate */
    HGLYPH  hg;                         /* The HGLYPH to print */
    SHORT   sFontIndex;                 /* The font to use */
    PVOID   pvColor;                    /* Colour for this glyph */
    DWORD   dwAttrFlags;                /* Font attribute flags, italic/bold */
    FLONG   flAccel;
    FLOATOBJ  eXScale;          // X Scale factor
    FLOATOBJ  eYScale;          // Y Scale factor
} PSGLYPH;

/*
 *    Structure used to manage the chunks of memory allocated for the
 *  PSGLYPH structures.  Basically it remembers the necessary details
 *  for freeing the block(s),  and also how much free space is available.
 */

#define PSG_CHUNK       1024            /* Glyph details per chunk */

typedef  struct  PSChunk
{
    struct  PSChunk  *pPSCNext;         /* Next in chain,  0 for last */
    int     cUsed;                      /* Entries in use */
    PSGLYPH aPSGData[ PSG_CHUNK ];      /* Actual glyph data */
} PSCHUNK;

/*
 *    The linked lists of PSGLYPH are based in a linked list of the
 * following structures.  These are linked in order of Y coordinate,
 * with an indexing table to speed scanning the list to find the
 * current Y coordinate.  Some caching also takes place.
 */

typedef  struct  YList
{
    struct  YList  *pYLNext;            /* Next in chain */
    int       iyVal;                    /* The Y coordinate */
    int       iyMax;                    /* Greatest height font this line */
    int       cGlyphs;                  /* The number of glyphs in this list */
    PSGLYPH  *pPSGHead;                 /* The start of the list of glyphs */
    PSGLYPH  *pPSGTail;                 /* The end of the list of glyphs */
} YLIST;

/*
 *    Structure used to manage the chunks of memory allocated for the
 *  PSGLYPH structures.  Basically it remembers the necessary details
 *  for freeing the block(s),  and also how much free space is available.
 */

#define YL_CHUNK        128             /* Glyph details per chunk */

typedef  struct  YLChunk
{
    struct  YLChunk  *pYLCNext;         /* Next in chain,  0 for last */
    int     cUsed;                      /* Entries in use */
    YLIST   aYLData[ YL_CHUNK ];        /* Actual YLIST data */
} YLCHUNK;


/*
 *   Finally,  the overall header block:  used to head the chain(s) of
 * data,  and to hold the cache and speedup data.
 */

#define NUM_INDICES     32              /* Indices into Y linked list */

typedef  struct  PSHead
{
    PSCHUNK  *pPSCHead;         /* Head of X linked data chunks */
    YLCHUNK  *pYLCHead;         /* Head of Y list chunks */
    int       cGlyphs;          /* Glyph count in longest list */
    int       iyDiv;            /* y div iyDiv -> index to following */
    YLIST    *pYLIndex[ NUM_INDICES ];  /* Speed up index into linked list */
    YLIST    *pYLLast;          /* Last Y element used.  This is a sort of
                                 * cache,  on the presumption that the last
                                 * used value is the one most likely to be
                                 * used next, AT LEAST for horizontal text.
                                 */
    PSGLYPH **ppPSGSort;        /* Memory used to sort the glyph lists */
    int       cGSIndex;         /* Index of next returned value in above */
} PSHEAD;


#define _POSNSORT_H
#endif  // !_POSNSORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\posnsort.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    posnsort.c

Abstract:

    Functions used to store/sort/retrieve output glyphs based on their
    position on the page.  This is required to be able to print
    the page in one direction,  as vertical repositioning may not
    be available,  and is generally not accurate enough. Not required
    for page printers.

Environment:

    Windows NT Unidrv driver

Revision History:

    01//97 -ganeshp-
        Created

--*/

#include "font.h"

/*
 *   Private function prototypes.
 */

static  PSGLYPH *
GetPSG(
    PSHEAD  *pPSH
    );

static  YLIST *
GetYL(
    PSHEAD  *pPSH
    );

static INT __cdecl
iPSGCmp(                  /*   The qsort() compare function */
    const void   *ppPSG0,
    const void   *ppPSG1
    );


#if     PRINT_INFO
int     __LH_QS_CMP;            /* Count number of qsort() comparisons */
#endif


BOOL
BCreatePS(
    PDEV  *pPDev
    )
/*++

Routine Description:
    Set up the data for the position sorting functions.  Allocate
    the header and the first of the data chunks,  and set up the
    necessary pointers etc.  IT IS ASSUMED THAT THE CALLER HAS
    DETERMINED THE NEED TO CALL THIS FUNCTION; otherwise,  some
    memory will be allocated,  but not used.


Arguments:

    pPDev           Pointer to PDEV

Return Value:

    TRUE for success and FALSE for failure
Note:
    01/02/97 -ganeshp-
        Created it.

--*/
{
    /*
     *    Initialise the position sorting tables.
     */

    PSCHUNK     *pPSC;
    YLCHUNK     *pYLC;
    PSHEAD      *pPSHead;
    FONTPDEV    *pFontPDev = PFDV;

    if( !(pPSHead = (PSHEAD *)MemAllocZ(sizeof( PSHEAD))) )
    {
        ERR(("UniFont!BCreatePS:Can't allocate PSHEAD\n"));
        return  FALSE;
    }


    pFontPDev->pPSHeader = pPSHead;         /* Connect to other structures */

    /*
     *   Get a chunk of memory for the first PSCHUNK data block.  The
     * address is recorded in the PSHeader allocated above.
     */

    if( !(pPSC = (PSCHUNK *)MemAllocZ( sizeof( PSCHUNK ) )) )
    {
        ERR(("UniFont!BCreatePS:Can't allocate PSCHUNK\n"));
        VFreePS( pPDev );

        return  FALSE;
    }
    pPSC->pPSCNext = 0;                 /* This is the only chunk */
    pPSC->cUsed = 0;                    /* AND none of it is in use */

    pPSHead->pPSCHead = pPSC;

    /*
     *   Get a chunk of memory for the first YLCHUNK data block.  The
     * address is recorded in the PSHeader allocated above.
     */

    if( !(pYLC = (YLCHUNK *)MemAllocZ( sizeof( YLCHUNK ) )) )
    {
        ERR(("UniFont!BCreatePS:Can't allocate YLCHUNK\n"));
        VFreePS( pPDev );

        return  FALSE;
    }
    pYLC->pYLCNext = 0;                 /* This is the only chunk */
    pYLC->cUsed = 0;                    /* AND none of it is in use */
    pPSHead->pYLCHead = pYLC;

    //
    // To text units
    //
    pPSHead->iyDiv = (pPDev->sf.szImageAreaG.cy * pPDev->ptGrxScale.y) / pFontPDev->ptTextScale.y;

    //
    // Round up one to avoid DIVIDED-BY-ZERO.
    //
    pPSHead->iyDiv = (pPSHead->iyDiv + NUM_INDICES) / NUM_INDICES;



#if     PRINT_INFO
    __LH_QS_CMP = 0;            /* Count number of qsort() comparisons */
#endif
    return  TRUE;
}



VOID
VFreePS(
    PDEV  *pPDev
    )
/*++

Routine Description:
     Free all memory allocated for the posnsort operations.  Start with
     the header to find the chains of data chunks we have,  freeing
     each as it is found.


Arguments:

    pPDev           Pointer to PDEV

Return Value:
    None.

Note:
    01/02/97 -ganeshp-

--*/
{

    PSCHUNK   *pPSC;
    PSCHUNK   *pPSCNext;                /* For working through the list */
    YLCHUNK   *pYLC;
    YLCHUNK   *pYLCNext;                /* Ditto */
    PSHEAD    *pPSH;
    FONTPDEV    *pFontPDev = PFDV;

#if     PRINT_INFO
    DbgPrint( "vFreePS: %ld qsort() comparisons\n", __LH_QS_CMP );
#endif

    if( !(pPSH = pFontPDev->pPSHeader) )
        return;                         /* Nothing to free! */


    for( pPSC = pPSH->pPSCHead; pPSC; pPSC = pPSCNext )
    {
        pPSCNext = pPSC->pPSCNext;      /* Next one, if any */
        MemFree( (LPSTR)pPSC );
    }

    /*   Repeat for the YLCHUNK segments */
    for( pYLC = pPSH->pYLCHead; pYLC; pYLC = pYLCNext )
    {
        pYLCNext = pYLC->pYLCNext;      /* Next one, if any */
        MemFree( (LPSTR)pYLC );
    }

    /*  Array storage for sorting - free it too!  */
    if( pPSH->ppPSGSort )
        MemFree( (LPSTR)pPSH->ppPSGSort );

    /*   Finally,  the hook in the PDEV.  */
    MemFree( (LPSTR)pPSH );

    pFontPDev->pPSHeader = NULL;

    return;
}


BOOL
BAddPS(
    PSHEAD  *pPSH,
    PSGLYPH *pPSGIn,
    INT      iyVal,
    INT      iyMax
    )
/*++

Routine Description:
    Add an entry to the position sorting data.

Arguments:
    pPSH    All the pointer data needed.
    pPSGIn  Glyph, font, X coordinate info.
    iyVal   The y coordinate.
    iyMax   fwdWinAscender for this font.



Return Value:
    TRUE/FALSE,  for success or failure.  Failure comes from a lack
    of memory to store more data.

Note:
    01/02/97 -ganeshp-

--*/
{

    PSCHUNK  *pPSC;     /* Local for faster access */
    PSGLYPH  *pPSG;     /* Summary of data passed to us,  and stored away */
    YLIST    *pYL;      /* Finding the correct list */

    //VERBOSE(("BAddPS:iyVal = %d\n", iyVal));

    //
    // Validate the Y position. It shouldn't be -ve. For negative y position
    // return true without adding the text in in the list.
    //
    if (iyVal < 0 || pPSH->ppPSGSort)
    {
#if DBG
        if (pPSH->ppPSGSort)
            WARNING(("BAddPS: Additional glyph after ppPSGSort was allocated.\n"));
#endif
        return TRUE;
    }

    pPSC = pPSH->pPSCHead;

    /*
     *   Step 1:  Store the data in the next PSGLYPH.
     */

    if( !(pPSG = GetPSG( pPSH )) )
        return  FALSE;

    *pPSG = *pPSGIn;            /* Major data */
    pPSG->pPSGNext = 0;         /* No next value! */

    /*
     *    Step 2 is to see if this is the same Y location as last time.
     *  If so,  our job is easy,  since all we need do is tack onto the
     *  end of the list we have at hand.
     */

    pYL = pPSH->pYLLast;
    if( pYL == 0 || pYL->iyVal != iyVal )
    {
        /*  Out of luck,  so go pounding through the lists  */
        YLIST   *pYLTemp;
        int      iIndex;

        iIndex = iyVal / pPSH->iyDiv;
        if( iIndex >= NUM_INDICES )
            iIndex = NUM_INDICES - 1;   /* Value is out of range */

        pYLTemp = pPSH->pYLIndex[ iIndex ];

        if( pYLTemp == 0 )
        {
            /*  An empty slot,  so now we must fill it  */
            if( !(pYL = GetYL( pPSH )) )
            {
                /*  Failed,  so we cannot do anything  */

                return  FALSE;
            }
            pYL->iyVal = iyVal;
            pPSH->pYLIndex[ iIndex ] = pYL;
        }
        else
        {
            /*  We have a list,  start scanning for this value,  or higher */
            YLIST  *pYLLast;

            pYLLast = 0;                /* Means looking at first */
            while( pYLTemp && pYLTemp->iyVal < iyVal )
            {
                pYLLast = pYLTemp;
                pYLTemp = pYLTemp->pYLNext;
            }
            if( pYLTemp == 0 || pYLTemp->iyVal != iyVal )
            {
                /*  Not available,  so get a new one and add it in  */
                if( !(pYL = GetYL( pPSH )) )
                    return  FALSE;

                pYL->iyVal = iyVal;

                if( pYLLast == 0 )
                {
                    /*  Needs to be first on the list */
                    pYL->pYLNext = pPSH->pYLIndex[ iIndex ];
                    pPSH->pYLIndex[ iIndex ] = pYL;
                }
                else
                {
                    /*  Need to insert it */
                    pYL->pYLNext = pYLTemp;     /* Next in chain */
                    pYLLast->pYLNext = pYL;     /* Link us in */
                }
            }
            else
                pYL = pYLTemp;          /* That's the one!  */
        }
    }
    /*
     *   pYL is now pointing at the Y chain for this glyph.  Add the new
     *  entry to the end of the chain.  This means that we will mostly
     *  end up with presorted text,  for apps that draw L->R with a
     *  font that is oriented that way.
     */

    if( pYL->pPSGHead )
    {
        /*   An existing chain - add to the end of it */
        pYL->pPSGTail->pPSGNext = pPSG;
        pYL->pPSGTail = pPSG;
        if( iyMax > pYL->iyMax )
            pYL->iyMax = iyMax;        /* New max height */
    }
    else
    {
        /*   A new YLIST structure,  so fill in the details  */
        pYL->pPSGHead = pYL->pPSGTail = pPSG;
        pYL->iyVal = iyVal;
        pYL->iyMax = iyMax;
    }
    pYL->cGlyphs++;                     /* Another in the list */
    if( pYL->cGlyphs > pPSH->cGlyphs )
        pPSH->cGlyphs = pYL->cGlyphs;

    pPSH->pYLLast = pYL;


    return  TRUE;
}


static  PSGLYPH  *
GetPSG(
    PSHEAD  *pPSH
    )
/*++

Routine Description:
    Returns the address of the next available PSGLYPH structure.  This
    may require allocating additional memory.

Arguments:
    pPSH    All the pointer data needed.

Return Value:
    The address of the structure, or zero on error.

Note:
    01/02/97 -ganeshp-

--*/
{

    PSCHUNK   *pPSC;
    PSGLYPH   *pPSG;

    pPSC = pPSH->pPSCHead;              /* Current chunk */

    if( pPSC->cUsed >= PSG_CHUNK )
    {
        /*   Out of room,  so add another chunk,  IFF we get the memory */
        PSCHUNK  *pPSCt;

        if( !(pPSCt = (PSCHUNK *)MemAllocZ(sizeof(PSCHUNK))) )
        {
            ERR(("UniFont!GetPSG: Unable to Allocate PSCHUNK\n"));
            return  FALSE;
        }


        /*  Initialise the new chunk,  add it to list of chunks */
        pPSCt->cUsed = 0;
        pPSCt->pPSCNext = pPSC;
        pPSH->pPSCHead = pPSC = pPSCt;

    }

    pPSG = &pPSC->aPSGData[ pPSC->cUsed ];

    ++(pPSC->cUsed);

    return  pPSG;
}



static  YLIST  *
GetYL(
    PSHEAD  *pPSH
    )
/*++

Routine Description:
    Allocates another YLIST structure,  allocating any storage that
    may be required,  and then initialises some of the fields.

Arguments:
    pPSH    All the pointer data needed.

Return Value:
     Address of new YLIST structure,  or zero for error.

Note:
    01/02/97 -ganeshp-

--*/
{

    YLCHUNK   *pYLC;
    YLIST     *pYL;


    pYLC = pPSH->pYLCHead;              /* Chain of these things */

    if( pYLC->cUsed >= YL_CHUNK )
    {
        /*  These have all gone,  we need another chunk  */
        YLCHUNK  *pYLCt;


        if( !(pYLCt = (YLCHUNK *)MemAllocZ( sizeof(YLCHUNK) )) )
        {
            ERR(("UniFont!GetPSG: Unable to Allocate YLCHUNK\n"));
            return  0;
        }


        pYLCt->pYLCNext = pYLC;
        pYLCt->cUsed = 0;
        pYLC = pYLCt;

        pPSH->pYLCHead = pYLC;
    }

    pYL = &pYLC->aYLData[ pYLC->cUsed ];
    ++(pYLC->cUsed);                      /* Count this one off */

    pYL->pYLNext = 0;
    pYL->pPSGHead = pYL->pPSGTail = 0;
    pYL->cGlyphs = 0;                   /* None in this list (yet) */

    return  pYL;
}


INT
ILookAheadMax(
    PDEV    *pPDev,
    INT     iyVal,
    INT     iLookAhead
    )
/*++

Routine Description:
    Scan down the next n scanlines,  looking for the largest device
    font in this area.   This value is returned,  and becomes the
    "text output box", as defined in the HP DeskJet manual.  In
    essence,  we print any font in this area.

Arguments:
    pPDev       Base of our operations.
    iyVal       The current scan line
    iLookAhead  Size of lookahead region, in scan lines

Return Value:
     The number of scan lines to look ahead,  0 is legitimate.

Note:
    01/02/97 -ganeshp-

--*/
{

    INT     iyMax = 0;     /* Returned value */
    INT     iIndex;        /* For churning through the red tape */
    YLIST   *pYL;           /* For looking down the scan lines */
    PSHEAD  *pPSH = PFDV->pPSHeader;

    /*
     *  Scan from iyVal to iyVal + iLookAhead,  and return the largest
     *  font encountered.  We have remembered the largest font on each
     *  line,  so there is no difficulty finding this information.This
     *  has to be done only if the device has fonts.
     */


    if (pPDev->iFonts)
    {
        ASSERT(pPSH);

        for( iyMax = 0; --iLookAhead > 0; ++iyVal )
        {
            /*
             *    Look for the YLIST for this particular scan line.  There
             *  may not be one - this will be the most common case.
             */

            iIndex = iyVal / pPSH->iyDiv;
            if( iIndex >= NUM_INDICES )
                iIndex = NUM_INDICES;

            if( (pYL = pPSH->pYLIndex[ iIndex ]) == 0 )
                continue;                   /* Nothing on this scan line */

            /*
             *   Have a list,  so scan the list to see if we have this value.
             */

            while( pYL && pYL->iyVal < iyVal )
                pYL = pYL->pYLNext;

            if( pYL && pYL->iyVal == iyVal )
                iyMax = max( iyMax, pYL->iyMax );
        }

    }

    return  iyMax;
}



INT
ISelYValPS(
    PSHEAD  *pPSH,
    int     iyVal
    )
/*++

Routine Description:
    Set the desired Y value for glyph retrieval.  Returns the number
    of glyphs to be used in this row.

Arguments:
    pPSH        Base of our operations.
    iyVal       The current scan line

Return Value:
     Number of glyphs in this Y row.  -1 indicates an error.

Note:
    01/02/97 -ganeshp-

--*/
{
    /*
     *    All that is needed is to scan the relevant Y list.  Stop when
     *  either we have gone past the iyVal (and return 0), OR when we
     *  find iyVal,  and then sort the data on X order.
     */

    int     iIndex;

    YLIST     *pYL;
    PSGLYPH  **ppPSG;
    PSGLYPH   *pPSG;

    //VERBOSE(("ISelYValPS:iyVal = %d\n", iyVal));

    iIndex = iyVal / pPSH->iyDiv;
    if( iIndex >= NUM_INDICES )
        iIndex = NUM_INDICES;

    if( (pYL = pPSH->pYLIndex[ iIndex ]) == 0 )
        return  0;                      /* Nothing there */

    /*
     *   Have a list,  so scan the list to see if we have this value.
     */

    while( pYL && pYL->iyVal < iyVal )
        pYL = pYL->pYLNext;

    if( pYL == 0 || pYL->iyVal != iyVal )
        return  0;                      /* Nothing on this row  */

    /*
     *   There are glyphs on this row,  so sort them.  This requires an
     *  array to use as pointers into the linked list elements.  The
     *  array is allocated for the largest size linked list (we have
     *  kept records on this!),  so the allocation is only done once.
     */

    if( pPSH->ppPSGSort == 0 )
    {
        /*  No,  so allocate it now  */
        if( !(pPSH->ppPSGSort = (PSGLYPH **)MemAllocZ(pPSH->cGlyphs * sizeof(PSGLYPH *))) )
        {
            ERR(("UniFont!ISelYValPS: Unable to Alloc Sorting Array of PSGLYPH\n"));
            return  -1;
        }
    }

    /*
     *    Scan down the list,  recording the addresses as we go.
     */

    ppPSG = pPSH->ppPSGSort;
    pPSG = pYL->pPSGHead;

    while( pPSG )
    {
        *ppPSG++ = pPSG;
        pPSG = pPSG->pPSGNext;
    }

    /*   Sorting is EASY!  */
    qsort( pPSH->ppPSGSort, pYL->cGlyphs, sizeof( PSGLYPH * ), iPSGCmp );

    pPSH->cGSIndex = 0;
    pPSH->pYLLast = pYL;        /* Speedier access in psgGetNextPSG() */

    return  pYL->cGlyphs;
}


static INT __cdecl
iPSGCmp(
    const void   *ppPSG0,
    const void   *ppPSG1
    )
/*++

Routine Description:
    Compare function for qsort() X position ordering.  Look at the
    qsort() documentation for further details.

Arguments:
    ppPSG0        Value 1.
    ppPSG1        Value 2.

Return Value:
    < 0 if arg0 < arg1
      0 if arg0 == arg1
    > 0 if arg0 > arg1


Note:
    01/02/97 -ganeshp-

--*/
{

#if     PRINT_INFO
    __LH_QS_CMP++;              /* Count number of qsort() comparisons */
#endif

    return  (*((PSGLYPH **)ppPSG0))->ixVal - (*((PSGLYPH **)ppPSG1))->ixVal;

}

/************************ Function Header *********************************
 * psgGetNextPSG
 *
 * RETURNS:
 *
 *
 * HISTORY:
 *  14:44 on Wed 12 Dec 1990    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 ***************************************************************************/

PSGLYPH  *
PSGGetNextPSG(
    PSHEAD  *pPSH
    )
/*++

Routine Description:
    Return the address of the next PSGLYPH structure from the current
    sorted list.  Returns 0 when the end has been reached.

Arguments:
    pPSH        Base of our operations.

Return Value:
     The address of the PSGLYPH to use,  or 0 for no more.

Note:
    01/02/97 -ganeshp-

--*/
{

    if( pPSH->cGSIndex >= pPSH->pYLLast->cGlyphs )
        return  0;                      /* We have none left */

    return  pPSH->ppPSGSort[ pPSH->cGSIndex++ ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\qadvwdth.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qadvwdth.c

Abstract:

    Implements the DrvQueryAdvanceWidths function - returns information
    about glyph widths.

Environment:

    Windows NT Unidrv driver

Revision History:

    01/02/97 -ganeshp-
        Created

--*/

#include "font.h"


BOOL
FMQueryAdvanceWidths(
    PDEV    *pPDev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH *phg,
    PVOID  *pvWidths,
    ULONG   cGlyphs
    )
/*++

Routine Description:
    Return Width information about glyphs in the font.

Arguments:

    pPDev           Pointer to PDEV
    pfo             The font of interest
    iMode           Glyphdata or kerning information
    phg             handle to glyph
    pvWidths        Output area
    cGlyphs         The number of them

Return Value:

    TRUE for success and FALSE if widths of all the glyphs cannot be computed.
    It returns DD_ERROR if the function fails.
Note:
    01/02/97 -ganeshp-

--*/
{
    /*
     *   First version is for fixed pitch fonts,  which are easy to do:
     *  the data is in the font's metrics!
     */



    FONTPDEV    *pFontPDev;
    int         iRot;             /* Rotation multiple of 90 degrees */
    BOOL        bRet;             /* Value returned */
    FONTMAP     *pFM;              /* Font data */
    IFIMETRICS  *pIFI;
    XFORMOBJ    *pxo;
    FONTCTL     ctl;              /* Scaling information */
    USHORT      *pusWidths;
    FLOATOBJ    fo;

    pFontPDev = pPDev->pFontPDev;
    bRet      = DDI_ERROR;
    pusWidths = (USHORT *) pvWidths;


    if( pfo->iFace < 1 || (int)pfo->iFace > pPDev->iFonts )
    {
        ERR(("UniFont!FMQueryAdvanceWidths: Bad FONTOBJ, iFace is %d",pfo->iFace));
        SetLastError( ERROR_INVALID_PARAMETER );
        return  bRet;
    }

    pFM = PfmGetDevicePFM( pPDev, pfo->iFace );

    if( pFM == NULL )
        return   FALSE;


    pIFI = pFM->pIFIMet;                /* IFIMETRICS - useful to have */


    if( !(pxo = FONTOBJ_pxoGetXform( pfo )) )
    {
        ERR(( "UniFont!FMQueryAdvanceWidths: FONTOBJ_pxoGetXform fails\n" ));
        return  bRet;
    }

    /*
     *   ALWAYS call the iSetScale function,  because some printers can
     *  rotate bitmap fonts.
     */

    //Added Check for HP Intellifont
    iRot = ISetScale( &ctl, pxo, ((pFM->flFlags & FM_SCALABLE) &&
                          (((PFONTMAP_DEV)pFM->pSubFM)->wDevFontType ==
                                            DF_TYPE_HPINTELLIFONT)),
                          (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

    if( pFM->flFlags & FM_SCALABLE )
    {

        int         iPtSize, iAdjustedPtSize;       /* For scale factor adjustment */

    #ifdef USEFLOATS

        /*  The limited font size resolution */
        iPtSize = (int)(0.5 + ctl.eYScale * pIFI->fwdUnitsPerEm * 7200) / pPDev->ptGrxRes.y;

        /* if the tranform is very small (Less than a quarter of point size)
         * then make it atleast a quarter point. This was causing AV in certain
         * cases.
         */

        if (iPtSize < 25)
        {
            iPtSize = 25;

        }
        iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

        //Adjust the Scale Factor for quarter point adjustment.
        ctl.eXScale = (ctl.eXScale * iAdjustedPtSize) / iPtSize;
        ctl.eYScale = (ctl.eYScale * iAdjustedPtSize) / iPtSize;

    #else

        fo = ctl.eYScale;
        FLOATOBJ_MulLong(&fo,pIFI->fwdUnitsPerEm);
        FLOATOBJ_MulLong(&fo,7200);

        #ifndef WINNT_40 //NT 5.0

        FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

        #else // NT 4.0

        FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

        #endif //!WINNT_40

        iPtSize = FLOATOBJ_GetLong(&fo);
        iPtSize /= pPDev->ptGrxRes.y;

        /* if the trannform is very small (Less than a quarter of point size)
         * then make it atleast a quarter point. This was causing AV in certain
         * cases.
         */

        if (iPtSize < 25)
        {
            iPtSize = 25;

        }

        iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

        //Adjust the Scale Factor for quarter point adjustment.
        FLOATOBJ_MulLong(&ctl.eXScale,iAdjustedPtSize);
        FLOATOBJ_DivLong(&ctl.eXScale,iPtSize);

        FLOATOBJ_MulLong(&ctl.eYScale,iAdjustedPtSize);
        FLOATOBJ_DivLong(&ctl.eYScale,iPtSize);
    #endif
    }


    /* We need to adjust the width table entries to the current resolution.IGetGlyphWidth
     * returns the scaled width for current resolution.
     */

    switch( iMode )
    {
    case  QAW_GETWIDTHS:            /* Glyph width etc data */
    case  QAW_GETEASYWIDTHS:

        while( cGlyphs-- > 0 )
        {

            int   iWide;            /* Glyph's width */


            iWide = IGetGlyphWidth( pPDev, pFM, (HGLYPH)*phg++);

            iWide = LMulFloatLong(&ctl.eXScale,iWide);

            *pusWidths++ = LTOFX( iWide );
        }
        bRet = TRUE;

        break;

    default:
        ERR(( "UniFont!FMQueryAdvanceWidths:  illegal iMode value" ));
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    return  bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\qfontree.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qfontree.c

Abstract:

    Routines Generates the trees required by the engine.  There are three
    tree types defined,  UNICODE (handle <-> glyph), ligatures and kerning
    pairs.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

--*/

#include "font.h"


//
//
// Functions
//
//

PVOID
FMQueryFontTree(
    PDEV    *pPDev,
    ULONG_PTR iFile,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR *pid
    )
/*++

Routine Description:
    Returns tree structured data describing the mapping between UNICODE
    and printer glyphs,  or ligature information or kerning pair data.


Arguments:

    pPDev           Pointer to PDEV
    iFile           Not Used.
    iFace           Font about which information is desired
    iMode           Type of information requested
    pid             Our field: fill as needed for recognition

Return Value:

    A pointer to the relevant structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{

    /*
     *  Processing differs dramatically,  depending upon iMode.  We will
     *  always handle the QFT_GLYPHSET case,  the others we may not have
     *  any information about.
     */


    void   *pvRet;                      /* Return value */


    UNREFERENCED_PARAMETER(iFile);

    if( PFDV->dwSignature != FONTPDEV_ID )
    {
        ERR(( "UniFont!FMQueryFontTree: Invalid FONTPDEV\n" ));

        SetLastError( ERROR_INVALID_PARAMETER );

        return  NULL;
    }

    if( iFace < 1 || (int)iFace >  pPDev->iFonts )
    {
        ERR(( "UniFont!FMQueryFontTree:  Illegal value for iFace (%ld)", iFace ));

        SetLastError( ERROR_INVALID_PARAMETER );

        return  NULL;
    }

    pvRet = NULL;                       /* Default return value: error */

    /*
     *   The pid field is one which allows us to put identification data in
     *  the font information, and which we can use later in DrvFree().
     */

    *pid = 0;


    switch( iMode )
    {

    case QFT_GLYPHSET:          /* RLE style UNICODE -> glyph handle mapping */
        pvRet = PVGetUCGlyphSetData( pPDev, iFace );
        break;


    case  QFT_LIGATURES:        /* Ligature variant information */
        SetLastError( ERROR_NO_DATA );
        break;

    case  QFT_KERNPAIRS:        /* Kerning information */
        pvRet = PVGetUCKernPairData( pPDev, iFace );
        break;

    default:
        ERR(( "Rasdd!DrvQueryFontTree: iMode = %ld - illegal value\n", iMode ));
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    return  pvRet;

}



VOID  *
PVGetUCGlyphSetData(
    PDEV   *pPDev,
    UINT    iFace
    )
/*++

Routine Description:
    Generates the array of WCRUN data used as a mapping between UNICODE and
    our internal representation.

Arguments:

    pPDev           Pointer to PDEV
    iFace           Font about which information is desired

Return Value:

    A pointer to the array of WCRUN structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{
    FONTMAP     *pFM;             /* Details of the particular font */
    FONTMAP_DEV *pFMDev;
    VOID        *pvData = NULL;

    if (pFM = PfmGetDevicePFM( pPDev, iFace ) )
    {
        pFMDev = pFM->pSubFM;

        if (!pFMDev->pUCTree)  //No FD_GLYPHSET data for this font.
        {
            if( pFM->flFlags & FM_GLYVER40 )    //NT 4.0 RLE
                pvData = PVGetUCRLE(pPDev, pFM);
            else                                // New stuff
                pvData = PVGetUCFD_GLYPHSET(pPDev, pFM);

        }
        else
            pvData = pFMDev->pUCTree;
    }

    // VDBGDUMPUCGLYPHDATA(pFM);

    return pvData;
}

VOID  *
PVGetUCKernPairData(
    PDEV   *pPDev,
    UINT    iFace
    )
/*++

Routine Description:
    Generates the array of FD_KERNPAIR data for the given font.

Arguments:

    pPDev           Pointer to PDEV
    iFace           Font about which information is desired

Return Value:

    A pointer to the array of WCRUN structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{
    FONTMAP     *pFM;             /* Details of the particular font */
    FONTMAP_DEV *pFMDev;
    VOID        *pvData = NULL;

    if (pFM = PfmGetDevicePFM( pPDev, iFace ) )
    {
        pFMDev = pFM->pSubFM;

        if (!pFMDev->pUCKernTree)  //No FD_GLYPHSET data for this font.
        {
            /* pvUCKernPair should allocate the appropriate buffer, if
             * necessary and store the value in FONTMAP, pFM->pUCKernTree.
             */

            if( pFM->flFlags & FM_GLYVER40 )    //NT 4.0 RLE
            {
                SetLastError( ERROR_NO_DATA );
            }
            else
                pvData = PVUCKernPair(pPDev, pFM);

        }
        else
            pvData = pFMDev->pUCKernTree;
    }

    return pvData;

}

VOID  *
PVGetUCRLE(
    PDEV      *pPDev,
    FONTMAP   *pFM
    )
/*++

Routine Description:
    Generates the array of WCRUN data used as a mapping between
    UNICODE and our internal representation.  The format of this
    data is explained in the DDI,  but basically for each group of
    glyphs we support,  we provide starting glyph and count info.
    There is an overall structure to define the number and location
    of each of the run data.

Arguments:

    pPDev           Pointer to PDEV.
    pFM             FONTMAP struct of the Font about for which information is
                    desired.

Return Value:

    A pointer to the array of WCRUN structure.
Note:
    12-30-96: Created it -ganeshp-

--*/
{
    /*
     *    Basically all we need do is allocate storage for the FD_GLYPHSET
     *  structure we will return.  Then the WCRUN entries in this need
     *  to have the offsets (contained in the resource format data) changed
     *  to addresses,  and we are done.  One minor point is to amend the
     *  WCRUN data to only point to glyphs actually available with this
     *  font.  This means limiting the lower and upper bounds as
     *  determined by the IFIMETRICS.
     */


    INT         cbReq;           /* Bytes to allocate for tables */
    INT         cRuns;           /* Number of runs we discover */
    INT         iI;              /* Loop index */
    INT         iStart, iStop;   /* First and last WCRUNs to use */
    INT         iDiff;           /* For range limiting operations */
    FD_GLYPHSET *pGLSet;       /* Base of returned data */
    IFIMETRICS  *pIFI;          /* For convenience */
    NT_RLE      *pntrle;        /* RLE style data already available */
    WCRUN       *pwcr;
    FONTMAP_DEV *pFMDev;

    #if DBG
    PWSTR pwszFaceName;
    #endif

    pIFI   = pFM->pIFIMet;
    pFMDev = pFM->pSubFM;

    #if DBG
    pwszFaceName = (PWSTR)(((BYTE*) pIFI) + pIFI->dpwszFaceName  );
    #endif

    TRACE(\nUniFont!PVGetUCRLE:START);
    PRINTVAL(pwszFaceName, %ws);
    PRINTVAL((pFM->flFlags & FM_GLYVER40), 0X%x);

    /*
     *    Start working on memory requirements.  First generate the bit
     *  array of available glyphs.  In the process,  count the number
     *  of glyphs too!  This tells us how much storage will be needed
     *  just for the glyph handles.
     */

    cRuns = 0;                  /* Count number of runs */

    pntrle = pFMDev->pvNTGlyph;         /* Translation table */

    if( !pntrle )
    {
        ERR(( "!!!UniFont!PVGetUCRLE:( NULL Glyph Translation Data, pwszFaceName = %s )\n",pwszFaceName ));
        TRACE(UniFont!PVGetUCRLE:END\n);
        return   NULL;          /* Should not happen */
    }

    /*
     *    The hard part is deciding whether to trim the number of glyph
     *  handles returned due to limitiations of the font metrics.
     */

    cRuns = pntrle->fdg.cRuns;        /* Max number of runs */
    iStart = 0;
    iStop = cRuns;

    /*
     *   Look to see if the first glyph in the font is higher than the lowest
     *  in the RLE data.  If so, we need to amend the lower limit.
     */


    if( pFM->wFirstChar > pntrle->wchFirst )
    {
        /*  Need to amend the lower end  */

        pwcr = &pntrle->fdg.awcrun[ iStart ];

        for( ; iStart < iStop; ++iStart, ++pwcr )
        {
            if( pFM->wFirstChar < (pwcr->wcLow + pwcr->cGlyphs) )
                break;

        }
    }


    if( pFM->wLastChar < pntrle->wchLast )
    {
        /*  The top end goes too far!  */

        pwcr = &pntrle->fdg.awcrun[ iStop - 1 ];

        for( ; iStop > iStart; --iStop, --pwcr )
        {
            if( pFM->wLastChar >= pwcr->wcLow )
                break;

        }
    }

    /*   Now have a new count of runs (sometimes, anyway)  */
    cRuns = iStop - iStart;


    if( cRuns == 0 )
    {
        /*  SHOULD NEVER HAPPEN! */
        cRuns = 1;
        ERR(( "UniFont!DrvQueryFontTree: cRuns == 0, pwszFaceName = %s\n", pwszFaceName ));
    }


    /*
     *   Allocate the storage required for the header.  Note that the
     *  FD_GLYPHSET structure contains 1 WCRUN,  so we reduce the number
     *  required by one.
     */

    cbReq = sizeof( FD_GLYPHSET ) + (cRuns - 1) * sizeof( WCRUN );

    pFMDev->pUCTree = (void *)MemAllocZ(cbReq );

    if( pFMDev->pUCTree == NULL )
    {
        /*  Tough - give up now */
        ERR(( "!!!UniFont!PVGetUCRLE:( MemAlloc Failed for pUCTree \n"));
        TRACE(UniFont!PVGetUCRLE:END\n);

        return  NULL;
    }
    pGLSet = pFMDev->pUCTree;
    CopyMemory( pGLSet, &pntrle->fdg, sizeof( FD_GLYPHSET ) );

    /*
     *     Copy the WCRUN data as appropriate.  Some of those in the
     *  resource may be dropped at this time,  depending upon the range
     *  of glyphs in the font.  It is also time to convert the offsets
     *  stored in the phg field to an address.
     */

    pwcr = &pntrle->fdg.awcrun[ iStart ];
    pGLSet->cGlyphsSupported = 0;             /* Add them up as we go! */
    pGLSet->cRuns = cRuns;

    for( iI = 0; iI < cRuns; ++iI, ++pwcr )
    {
        pGLSet->awcrun[ iI ].wcLow = pwcr->wcLow;
        pGLSet->awcrun[ iI ].cGlyphs = pwcr->cGlyphs;
        pGLSet->cGlyphsSupported += pwcr->cGlyphs;
        pGLSet->awcrun[ iI ].phg = (HGLYPH *)((BYTE *)pntrle + (ULONG_PTR)pwcr->phg);
    }

    /*  Do the first and last entries need modifying??  */
    if( (iDiff = (UINT)pGLSet->awcrun[0].wcLow - (UINT)pFM->wFirstChar) > 0 )
    {
        /*   The first is not the first,  so adjust values  */


        pGLSet->awcrun[ 0 ].wcLow += (WORD)iDiff;
        pGLSet->awcrun[ 0 ].cGlyphs -= (WORD)iDiff;
        pGLSet->awcrun[ 0 ].phg += (ULONG_PTR)iDiff;

        pGLSet->cGlyphsSupported -= iDiff;
    }


    if( (iDiff = (UINT)pGLSet->awcrun[ cRuns - 1 ].wcLow +
                 (UINT)pGLSet->awcrun[ cRuns - 1 ].cGlyphs - 1 -
                 (UINT)pFM->wLastChar) > 0 )
    {
         /*  Need to limit the top one too!  */


         pGLSet->awcrun[ cRuns - 1 ].cGlyphs -= (WORD)iDiff;

         pGLSet->cGlyphsSupported -= (ULONG)iDiff;

    }

    TRACE(UniFont!PVGetUCRLE:END\n);
    return   pFMDev->pUCTree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\qfontdat.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    qfontdat.c

Abstract:

    Implements the DrvQueryFontData function - returns information
    about glyphs (size, position wrt box) or kerning information.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/19/96 -ganeshp-
        Created

--*/
#include "font.h"


/*
 *    The values for pteBase, pteSide in FD_DEVICEMETRICS,  allowing
 *  for rotation by 90 degree multiples.
 */

#if defined(USEFLOATS) || defined(WINNT_40)

static  const  POINTE  pteRotBase[] =
{
    { (FLOAT) 1.0, (FLOAT) 0.0 },
    { (FLOAT) 0.0, (FLOAT)-1.0 },
    { (FLOAT)-1.0, (FLOAT) 0.0 },
    { (FLOAT) 0.0, (FLOAT) 1.0 }
};

static  const  POINTE  pteRotSide[] =
{
    { (FLOAT) 0.0, (FLOAT)-1.0 },
    { (FLOAT)-1.0, (FLOAT) 0.0 },
    { (FLOAT) 0.0, (FLOAT) 1.0 },
    { (FLOAT) 1.0, (FLOAT) 0.0 }
};

#else

static  const  POINTE  pteRotBase[] =
{
    { (FLOATL) FLOATL_1_0, (FLOATL) FLOATL_0_0 },
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0M },
    { (FLOATL) FLOATL_1_0M,(FLOATL) FLOATL_0_0 },
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0 }
};

static  const  POINTE  pteRotSide[] =
{
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0M },
    { (FLOATL) FLOATL_1_0M,(FLOATL) FLOATL_0_0 },
    { (FLOATL) FLOATL_0_0, (FLOATL) FLOATL_1_0 },
    { (FLOATL) FLOATL_1_0, (FLOATL) FLOATL_0_0 }
};
#endif //defined(USEFLOATS) || defined(WINNT_40)


/*  The X dimension rotation cases */

static  const  POINTL   ptlXRot[] =
{
    {  1,  0 },
    {  0, -1 },
    { -1,  0 },
    {  0,  1 },
};


/*  The Y dimension rotation cases */

static  const  POINTL   ptlYRot[] =
{
    {  0,  1 },
    {  1,  0 },
    {  0, -1 },
    { -1,  0 },
};


LONG
FMQueryFontData(
    PDEV       *pPDev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
/*++

Routine Description:
    Return information about glyphs in the font,  OR kerning data.

    Arguments:
    pPDev   Really  a pPDev
    pfo     The font of interest
    iMode   Glyphdata or kerning information
    hg      Handle to glyph
    pgd     Place to put metrics
    pv      Output area
    cjSize  Size of output area



Return Value:

    Number of bytes needed or written,  0xffffffff for error.

Note:
    12-29-96: Created it -ganeshp-

--*/
{


    FONTPDEV    *pFontPDev;
    int         iRot;             /* Rotation multiple of 90 degrees */
    LONG        lRet;             /* Value returned */
    FONTMAP     *pFM;             /* Font data */
    FONTMAP_DEV *pFMDev;          /* Font data */
    FONTCTL     ctl;              /* Font scale/rotation adjustments */
    IFIMETRICS  *pIFI;
    XFORMOBJ    *pxo;
    LONG        lAscender;
    LONG        lDescender;
    FLOATOBJ    fo;

    pFontPDev =  pPDev->pFontPDev;
    lRet = FD_ERROR;

    if( pfo->iFace < 1 || (int)pfo->iFace > pPDev->iFonts )
    {
        ERR(("Bad FONTOBJ, iFace is %d",pfo->iFace));
        SetLastError( ERROR_INVALID_PARAMETER );
        return  lRet;
    }

    pFM = PfmGetDevicePFM( pPDev, pfo->iFace );
    if( pFM == NULL )
        return  lRet;

    VDBGDUMPFONTMAP(pFM);

    pFMDev = pFM->pSubFM;
    pIFI = pFM->pIFIMet;                /* IFIMETRICS - useful to have */

    if( pgd || pv )
    {
        /*
         *    Need to obtain a transform to adjust these numbers as to
         *  how the engine wants them.
         */


        if( !(pxo = FONTOBJ_pxoGetXform( pfo )) )
        {
            ERR(( "UniFont!FMQueryFontData: FONTOBJ_pxoGetXform fails\n" ));
            return  lRet;
        }

        /*  Can now obtain the transform!  */

        //Added Check for HP Intellifont
        iRot = ISetScale( &ctl, pxo, ((pFM->flFlags & FM_SCALABLE) &&
                                      (pFMDev->wDevFontType ==
                                                DF_TYPE_HPINTELLIFONT)),
                                     (pFontPDev->flText & TC_CR_ANY)?TRUE:FALSE);

        if (pFontPDev->flText & TC_CR_ANY)
            iRot = (iRot + 45) / 90;


        /*
         *    There are some adjustments to make to the scale factors.  One
         *  is to compensate for resolutions (these are coarse, integral
         *  adjustments),  the others are to to do with Intellifont.  First
         *  is the Intellifont point is 1/72.31 inches (!), and secondly
         *  the LaserJet only adjusts font size to the nearest 0.25 point,
         *  and hence when we round to that multiple, we need to adjust
         *  the width accordingly.
         */

        if( pFM->flFlags & FM_SCALABLE )
        {

            int         iPtSize, iAdjustedPtSize;       /* For scale factor adjustment */

        #ifdef USEFLOATS

            /*  The limited font size resolution */
            iPtSize = (int)(0.5 + ctl.eYScale * pIFI->fwdUnitsPerEm * 7200) / pPDev->ptGrxRes.y;

            /* if the tranform is very small (Less than a quarter of point size)
             * then make it atleast a quarter point. This was causing AV in certain
             * cases.
             */

            if (iPtSize < 25)
            {
                iPtSize = 25;

            }
            iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

            //Adjust the Scale Factor for quarter point adjustment.
            ctl.eXScale = (ctl.eXScale * iAdjustedPtSize) / iPtSize;
            ctl.eYScale = (ctl.eYScale * iAdjustedPtSize) / iPtSize;

        #else

            fo = ctl.eYScale;
            FLOATOBJ_MulLong(&fo,pIFI->fwdUnitsPerEm);
            FLOATOBJ_MulLong(&fo,7200);

            #ifndef WINNT_40 //NT 5.0

            FLOATOBJ_AddFloat(&fo,(FLOATL)FLOATL_00_50);

            #else // NT 4.0

            FLOATOBJ_AddFloat(&fo,(FLOAT)0.5);

            #endif //!WINNT_40

            iPtSize = FLOATOBJ_GetLong(&fo);
            iPtSize /= pPDev->ptGrxRes.y;

            /* if the trannform is very small (Less than a quarter of point size)
             * then make it atleast a quarter point. This was causing AV in certain
             * cases.
             */

            if (iPtSize < 25)
            {
                iPtSize = 25;

            }

            iAdjustedPtSize = ((iPtSize + 12) / 25) * 25;

            //Adjust the Scale Factor for quarter point adjustment.
            FLOATOBJ_MulLong(&ctl.eXScale,iAdjustedPtSize);
            FLOATOBJ_DivLong(&ctl.eXScale,iPtSize);

            FLOATOBJ_MulLong(&ctl.eYScale,iAdjustedPtSize);
            FLOATOBJ_DivLong(&ctl.eYScale,iPtSize);
        #endif
        }
    }

    /*
     * precompute the lDescender and lAscender
     */

    lDescender = LMulFloatLong(&ctl.eYScale,pIFI->fwdWinDescender);
    lAscender  = LMulFloatLong(&ctl.eYScale,pIFI->fwdWinAscender);

    switch( iMode )
    {
    case  QFD_GLYPHANDBITMAP:            /* Glyph width etc data */
        // size is now just the size of the bitmap, which in this
        // case doesn't exist.
        lRet = 0;

        if( pgd )
        {

            int   iWide;            /* Glyph's width */

            /*
             *    First get the width of this glyph,  as this is needed
             *  in several places.The width returned by IGetGlyphWidth
             *  is not scaled in device units. To convert in device units
             *  multily with the scale factor calculated earlier.
             */

            iWide = IGetGlyphWidth( pPDev, pFM, hg);

            iWide = LMulFloatLong(&ctl.eXScale,iWide);

            switch( iRot )
            {
            case 0:
                pgd->rclInk.left   = 0;
                pgd->rclInk.top    = lDescender;
                pgd->rclInk.right  = iWide;
                pgd->rclInk.bottom = -lAscender;
                break;

            case 1:
                pgd->rclInk.left   = lDescender;
                pgd->rclInk.top    = iWide;
                pgd->rclInk.right  = -lAscender;
                pgd->rclInk.bottom = 0;
                break;

            case 2:
                pgd->rclInk.left   = -iWide;
                pgd->rclInk.top    = -lAscender;
                pgd->rclInk.right  = 0;
                pgd->rclInk.bottom = lDescender;
                break;

            case 3:
                pgd->rclInk.left   = lAscender;
                pgd->rclInk.top    = 0;
                pgd->rclInk.right  = -lDescender;
                pgd->rclInk.bottom = -iWide;
                break;
            }

            pgd->fxD = LTOFX( iWide );
            pgd->ptqD.x.HighPart = pgd->fxD * ptlXRot[ iRot ].x;
            pgd->ptqD.x.LowPart = 0;
            pgd->ptqD.y.HighPart =  pgd->fxD * ptlXRot[ iRot ].y;
            pgd->ptqD.y.LowPart = 0;

            pgd->fxA = 0;
            pgd->fxAB = pgd->fxD;

            pgd->fxInkTop = (FIX)LTOFX( lAscender );
            pgd->fxInkBottom = -(FIX)LTOFX( lDescender );

            pgd->hg = hg;
            pgd->gdf.pgb = NULL;

        }
        break;

    case  QFD_MAXEXTENTS:         /* Alternative form of the above */

        lRet = sizeof( FD_DEVICEMETRICS );

        if( pv )
        {
            LONG   lTmp;            /* Rotated case */
            FD_DEVICEMETRICS *pdm =  ((FD_DEVICEMETRICS *)pv);

            /*
             *   Check that the size is reasonable!
             */

            if( cjSize < sizeof( FD_DEVICEMETRICS ) )
            {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                ERR(( "rasdd!DrvQueryFontData: cjSize (%ld) too small\n", cjSize ));
                return  -1;
            }
            // BUG 757060 - set this to 0 explicitly, because some drivers
            // were using this before it was set, and may have code paths that
            // break if this is a reasonable value.  Before this fix, the value
            // was the 0xCD pattern, and on newer IA64 machines, requests for this
            // much memory (>3GB) could be handled, but at the expense of locking up 
            // the machine for minutes or even hours.
            pdm->cjGlyphMax = 0;

            /*
             *   These are accelerator flags - it is not obvious to me
             *  that any of them are relevant to printer driver fonts.
             */
            pdm->flRealizedType = 0;

            /*
             *   Following fields set this as a normal type of font.
             */

            pdm->pteBase = pteRotBase[ iRot ];
            pdm->pteSide = pteRotSide[ iRot ];

            pdm->cxMax = LMulFloatLong(&ctl.eXScale,pIFI->fwdMaxCharInc);

            //
            // DBCS fonts are not monospaced, have halfwidth glyphs and
            // fullwidth glyphs.
            //

            if ( pFMDev->W.psWidth ||
                IS_DBCSCHARSET(((IFIMETRICS*)pFM->pIFIMet)->jWinCharSet))
            {
                pdm->lD = 0;      /* Proportionally spaced font */
            }
            else
            {
                pdm->lD = pdm->cxMax;
            }

            pdm->fxMaxAscender = (FIX)LTOFX( lAscender );
            pdm->fxMaxDescender = (FIX)LTOFX( lDescender );

            lTmp = -LMulFloatLong(&ctl.eYScale,pIFI->fwdUnderscorePosition);
            pdm->ptlUnderline1.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlUnderline1.y = lTmp * ptlYRot[ iRot ].y;

            lTmp = -LMulFloatLong(&ctl.eYScale,pIFI->fwdStrikeoutPosition);
            pdm->ptlStrikeOut.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlStrikeOut.y = lTmp * ptlYRot[ iRot ].y;

            lTmp = LMulFloatLong(&ctl.eYScale,pIFI->fwdUnderscoreSize);
            pdm->ptlULThickness.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlULThickness.y = lTmp * ptlYRot[ iRot ].y;

            lTmp = LMulFloatLong(&ctl.eYScale,pIFI->fwdStrikeoutSize);
            pdm->ptlSOThickness.x = lTmp * ptlYRot[ iRot ].x;
            pdm->ptlSOThickness.y = lTmp * ptlYRot[ iRot ].y;
        }
        break;

    default:
        ERR(( "Rasdd!DrvQueryFontData:  unprocessed iMode value - %ld",iMode ));
        SetLastError( ERROR_INVALID_PARAMETER );
        break;
    }

    return  lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\sfinst.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    sfinst.h

Abstract:

    Data structures  used for reading the common font installer file format.
    Typically used by drivers during font counting and enumeration at
    EnabldPDEV() time - at the time of writing!  Subject to change as the
    DDI/GDI change.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/

/*
 *   The following structure is returned from the FIOpenRead() function,
 * and contains the basic information needed to access the data in the
 * file once it is memory mapped.
 */

typedef  struct
{
    HANDLE hFont;               /* Font installer file, for downloaded part */
    BYTE  *pbBase;              /* Base address of data as mapped */
    void  *pvFix;               /* Fixed part at start of file */
    ULONG  ulFixSize;           /* Bytes in fixed data record */
    ULONG  ulVarOff;            /* File offset of data, relative file start */
    ULONG  ulVarSize;           /* Bytes in variable part */
}  FI_MEM;


/*
 *      Definitions used in the font file.  This is the file which holds
 *      information about cartridge and download fonts.  The file format
 *      is quite basic:  a header for verification; then an array of
 *      records,  each with a header.  These records contain FONTMAP
 *      information.  Cartridges have an array of these, one for each
 *      font.  Finally,  the tail of the file contains extra data, as
 *      required.  For download fonts,  this would be the download data.
 *
 */


/*
 *   The file header.   One of these is located at the beginning of the file.
 *  The ulVarData field is relative to the beginning of the file.  This
 *  makes it easier to regenerate the file when fonts are deleted.
 */

typedef  struct
{
    ULONG   ulID;               /* ID info - see value below */
    ULONG   ulVersion;          /* Version information - see below */
    ULONG   ulFixData;          /* Start of FF_REC_HEADER array */
    ULONG   ulFixSize;          /* Number of bytes in fixed section */
    ULONG   ulRecCount;         /* Number of records in fixed part */
    ULONG   ulVarData;          /* Start of variable data, rel to 0 */
    ULONG   ulVarSize;          /* Numbier of bytes in variable portion */
}  FF_HEADER;

/*
 *   Values for the ID and Version fields.
 */

#define FF_ID           0x6c666e66              /* "fnfl" - fOnTfIlE */
#define FF_VERSION      1                       /* Start at the bottom */

/*
 *   Each entry in the file starts with the following header.  Typically
 * there will be one of these for a softfont, and one per cartridge.
 * In the case of a cartridge,  there will be an array of these, within
 * the master entry.  Each sub-entry will be for one specific font.
 *
 *   Note that there is a dummy entry at the end.  This contains a 0
 * in the ulSize field - it is to mark the last one,  and makes it
 * easier to manipulate the file.
 */

typedef  struct
{
    ULONG   ulRID;              /* Record ID */
    ULONG   ulNextOff;          /* Offset from here to next record: 0 == end */
    ULONG   ulSize;             /* Bytes in this record */
    ULONG   ulVarOff;           /* Offset from start of variable data */
    ULONG   ulVarSize;          /* Number of bytes in variable part */
}  FF_REC_HEADER;

#define FR_ID           0x63657266              /* "frec" - fONT recORD */

/*
 *   Define the file extensions used.  The first is the name of the
 * font installer file;  the others are temporaries used during update
 * of the (possibly) existing file.
 */


#define  FILE_FONTS     L"fi_"           /* "Existing" single file */
#define  TFILE_FIX      L"fiX"           /* Fixed part of file */
#define  TFILE_VAR      L"fiV"           /* Variable (optional) portion */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\common.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    common.h

Abstract:

    This file contain information and function prototypes for helper
    library functions provided by the Control module

Environment:

        Windows NT Unidrv driver

Revision History:

    10/12/96 -amandan-
        Created

    dd-mm-yy -author-
         description

--*/

#ifndef _COMMON_H_
#define _COMMON_H_

#ifdef __cplusplus
extern "C" {
#endif


#include "ddint5.h"

INT
WriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    );


VOID  WriteAbortBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount,
    DWORD       dwWait
    );


BOOL
FlushSpoolBuf(
    PDEV    *pPDev
    );

INT
WriteChannel(
    PDEV    *pPDev,
    COMMAND *pCmd
    );

INT
WriteChannelEx(
    PDEV    *pPDev,
    COMMAND *pCmd,
    INT     iRequestedValue,
    INT     iDeviceScaleFac
    );


VOID
SetRop3(
    PDEV    *pPDev,
    DWORD   dwRop3
    );


INT
XMoveTo(
    PDEV    *pPDev,
    INT     iXIn,
    INT     fFlags
    );

INT
YMoveTo(
    PDEV    *pPDev,
    INT     iYIn,
    INT     fFlags
    );

BOOL
BIntersectRect(
    OUT PRECTL   prcDest,
    IN  PRECTL   prcRect1,
    IN  PRECTL   prcRect2
    );

BOOL
bIsRegionWhite (
        SURFOBJ *,
        RECTL *
        );

VOID
CheckBitmapSurface(
        SURFOBJ *,
        RECTL *
        );

ULONG
DrawPatternRect(
        PDEV *,
        PDRAWPATRECT
        );
/*
 *   Flags to use when calling the [XY]Moveto functions.
 *
 *  MV_UPDATE  is used when it is desired to change our record of where
 *      the cursor is now located.  Typically this will happen after some
 *      operation such as printing a glyph, or sending graphics.
 *
 *  MV_RELATIVE  means add the value passed to the current position.  This
 *      would be used after printing a glyph,  and passing in the glyph
 *      width as parameter,  rather than calculating the new position.
 *
 *  MV_GRAPHICS  indicates that the value is in GRAPHICS RESOLUTION units.
 *      Otherwise MASTER UNITS are assumed.  If set,  the value will be
 *      converted to master units before processing.  Typically used to
 *      pass information when sending scan lines of graphics data.
 *
 *  MV_PHYSICAL  is used to indicate that the value passed in is relative
 *      to the printers print origin,  and not the printable area,  which
 *      is the case otherwise.  Typically this flag would be used to
 *      allow setting the position to the printer's X = 0 position after
 *      sending a <CR>.
 *
 *  MV_FINE  requests sending graphics data (nulls) to position the cursor
 *      to finer position than can otherwise be achieved.  Typically
 *      only available in the direction of movement of the head on a
 *      dot matrix printer.  This command may be ignored.  It must not
 *      be issued for a LaserJet,  since it will cause all sorts of other
 *      problems.
 */

//
// 4/7/97 Zhanw
// the first 4 constants are defined in "printoem.h" since we now export
// XMoveTo and YMoveTo to OEM DLL's
//

//#define MV_UPDATE       0x0001
//#define MV_RELATIVE     0x0002
//#define MV_GRAPHICS     0x0004
//#define MV_PHYSICAL     0x0008

//
// Internal use only!!! update warning in oak\inc\printoem.h
// whenever new flags are added.
//
#define MV_FORCE_CR         0x4000
#define MV_FINE             0x8000

BOOL
BSelectProgrammableBrushColor(
    PDEV   *pPDev,
    ULONG   Color
    );

VOID
VResetProgrammableBrushColor(
    PDEV   *pPDev
    );

DWORD
BestMatchDeviceColor(
    PDEV    *pPDev,
    DWORD   Color
    );

BYTE
BGetMask(
    PDEV *  pPDev,
    RECTL * pRect
    );
BOOL
BGetStandardVariable(
    PDEV    *pPDev,
    DWORD   dwIndex,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded
    );
DWORD
ConvertRGBToGrey(
    DWORD   Color
    );

BOOL
BGetGPDData(
    PDEV    *pPDev,
    DWORD       dwType,     // Type of the data
    PVOID         pInputData,   // reserved. Should be set to 0
    PVOID          pBuffer,     // Caller allocated Buffer to be copied
    DWORD       cbSize,     // Size of the buffer
    PDWORD      pcbNeeded   // New Size of the buffer if needed.
    ) ;


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\truetype.c ===
/*++

  Copyright (c) 1996 - 1999  Microsoft Corporation,
                     Hewlett-Packard

  Module Name:

    TrueType.c

  Abstract:

    This module implements the TrueType-as-Outline support.

  Author:

    Sandra Matts. v-sandma@microsoft.com
    Jim Fordemwalt: v-jford@microsoft.com

  Notes:

    When time permits a flags field should be added to the privateFM including
    a flag for fixed-pitch/variable-pitch.

    When time permits code should be added to retrieve a list of exempted fonts
    from the registry.  Look at raster.c and enable.c for calls to
    EngGetPrinterData and use a string like L"ExemptedFonts" of type multi-sz.

  Revision History:

    10/95   Sandra Matts
        First version

--*/

//Comment out this line to disable FTRC and FTST macroes.
//#define FILETRACE

//
// This KLUDGE flag signifies that I am running a kludgey version
// of this file.  As I am cleaning up I will need to remove this and
// deal with the issues in the code.  However, this allows me to compile,
// run and test without being complete.
//
// #define KLUDGE 1

//
// The TT_ECHO_ON flag indicates that I want to see TT messages for each
// font and glyph that is sent to the printer.  It should be used with care
// because even a modest page can contain several thousand glyph-outs.  It
// will cause printing to occur very slowly!
//
// #define TT_ECHO_ON 1

#include    "font.h"

///////////////////////////////////////////////////////////////////////////////
// Local function prototypes


USHORT
usParseTTFile(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT PTABLEDIR pPCLTableDir,
    OUT PTABLEDIR pTableDir,
    OUT BOOL *pbExistPCLTTable
);

PTABLEDIR
pFindTag(
    IN PTABLEDIR pTableDir,
    IN USHORT usMaxDirEntries,
    IN char *pTag
);

BOOL
bCopyDirEntry(
    OUT PTABLEDIR pDst,
    IN PTABLEDIR pSrc
);

BOOL
bTagCompare(
    IN ULONG uTag,
    IN char *pTag
);

DWORD
dwDLTTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN TT_HEADER ttheader,
    IN USHORT usNumTags,
    IN PTABLEDIR pPCLTableDir,
    IN BYTE *PanoseNumber,
    IN BOOL bExistPCLTTable
);

BOOL
bOutputSegment(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN BYTE *pbData,
    IN LONG ulSegSize,
    IN OUT USHORT *pusCheckSum
);

BOOL
bOutputSegHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN ULONG ulSegSize,
    IN OUT USHORT *pusCheckSum
);

BOOL
bOutputSegData(
    IN PDEV *pPDev,
    IN BYTE *pbData,
    IN LONG ulDataSize,
    IN OUT USHORT *pusCheckSum
);

BOOL
bSendFontData(
    IN PDEV *pPDev,
    IN FONT_DATA *aFontData,
    IN USHORT usNumTags,
    IN BYTE *abNumPadBytes,
    IN OUT USHORT *pusCheckSum
);

DWORD
dwTTOutputGlyphData(
    IN PDEV *pPDev,
    IN HGLYPH hGlyph
);

PBYTE pbGetGlyphInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    OUT USHORT *pusGlyphLen
);

BOOL
bReadInTable(
    IN PVOID pTTFile,
    IN PVOID pvTableDir,
    IN char *tag,
    OUT PVOID pvTable,
    IN LONG lSize
);

BOOL
bCopyGlyphData(
    IN OUT PDEV *pPDev,
    IN PFONTMAP pFM,
    IN CMAP_TABLE cmapTable,
    IN PTABLEDIR pTableDir
);

ULONG
ulCalcTableCheckSum(
    IN ULONG *pulTable,
    IN ULONG ulLength
);

USHORT
usCalcCheckSum(
    IN BYTE *pbData,
    IN ULONG ulLength
);

void
vBuildTrueTypeHeader(
    IN PVOID pTTFile,
    OUT TRUETYPEHEADER *trueTypeHeader,
    IN USHORT usNumTags,
    IN BOOL bExistPCLTTable
);

void
vGetFontName(
    IN PDEV *pPDev,
    IFIMETRICS  *pIFI,
    OUT char *szFontName,
    IN size_t cchFontName
);

USHORT
usGetCharCode(
    IN HGLYPH hglyph,
    IN PDEV *pPDev
);

BYTE *
pbGetTableMem(
    IN char *tag,
    IN PTABLEDIR pTableDir,
    IN PVOID pTTFile
);

void
vGetHmtxInfo(
    OUT BYTE *hmtxTable,
    IN USHORT glyphId,
    IN USHORT numberOfHMetrics,
    IN HMTX_INFO *hmtxInfo
);

USHORT
usGetDefStyle(
    IN USHORT WidthClass,
    IN USHORT macStyle,
    IN USHORT flSelFlags
);

SBYTE
sbGetDefStrokeWeight(
    IN USHORT WeightClass,
    IN USHORT macStyle
);

USHORT
usGetDefPitch(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
);

void
vGetPCLTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT TT_HEADER *ttheader,
    IN PCLT_TABLE pcltTable,
    IN BOOL bExistPCLTTable,
    IN OS2_TABLE OS2Table,
    IN HEAD_TABLE headTable,
    IN POST_TABLE postTable,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
);

void
vSetFontFlags(
    IN OUT PFONTMAP pFM,
    IN IFIMETRICS *pIFI
);

LRESULT
IsFont2Byte(
    IN PFONTMAP pFM
);

DWORD
dwSendCompoundCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph
);

DWORD
dwSendCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    IN USHORT usCharCode
);

HGLYPH
hFindGlyphId(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usCharCode
);

BOOL
bInitTrueTypeFontMap(
    PFONTMAP pFontMap,
    FONTOBJ *pFontObj
);

BOOL
bSetParseMode(
    IN PDEV *pPDev,
    IN OUT PFONTMAP pFM,
    IN DWORD dwNewTextParseMode
);

USHORT
usGetCapHeight(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bIsTrueTypeFileTTC(
    IN PVOID pTTFile
);

USHORT
usGetNumTableDirEntries(
    IN PVOID pTTFile
);

PTABLEDIR
pGetTableDirStart(
    IN PVOID pTTFile
);

BOOL
bPCL_SetFontID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bPCL_SendFontDCPT(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN DWORD dwDefinitionSize
);

BOOL
bPCL_SelectFontByID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bPCL_SelectPointSize(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN POINTL *pptl
);

BOOL
bPCL_DeselectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
);

BOOL
bPCL_SetParseMode(
    PDEV *pPDev,
    PFONTMAP pFM
);

BOOL
bPCL_SetCharCode(
    PDEV *pPDev,
    PFONTMAP pFM,
    USHORT usCharCode
);

BOOL
bPCL_SendCharDCPT(
    PDEV *pPDev,
    PFONTMAP pFM,
    DWORD dwSend
);

PVOID
pvGetTrueTypeFontFile(
    IN  PDEV *pPDev,
    OUT ULONG *pulSize
);

BOOL BIsExemptedFont(
    PDEV        *pPDev,
    IFIMETRICS  *pIFI
);

BOOL BIsPDFType1Font(
    IFIMETRICS  *pIFI
);

///////////////////////////////////////////////////////////////////////////////
// Local Macros

/*++

  Macro Description:

    The PCLSTRING is used to send specific (short) PCL command strings
    to the printer.

--*/
#define PCLSTRLEN 30
typedef char PCLSTRING[PCLSTRLEN];

/*++

  Macro Description:

    The INTSTRING is used to store integer values when converted to string.

--*/
#define INTSTRLEN 15
typedef char INTSTRING[INTSTRLEN];

#define MAX_PAD_BYTES 4

// [ISSUE] Where is a better place to define this?
#ifndef MAX_USHORT
#define MAX_USHORT 0xFFFF
#endif

/*++

  Macro Description:

    Text parsing mode controls PCL treatment of text data.
    We will use parsing mode 21 with format 16 because most printers
    don't support parsing mode 2.

--*/
#define PARSE_MODE_0   0
#define PARSE_MODE_21 21

/*++

  Macro Description:

    GetPrivateFM: isolates the private truetype fontmap field

  Arguments:

    pFontMap - The fontmap which contains the truetype private section

  Return Value:

    The private fontmap field.

--*/
#define GETPRIVATEFM(pFontMap) ((pFontMap) ? ((FONTMAP_TTO*)pFontMap->pSubFM) : NULL)


/*++

  Macro Description:

    GetFontPDev: isolates the font FontPDev buried in the PDEV structure.

  Arguments:

    pPDev - The PDEV for the current process

  Return Value:

    The FontPDev field.

--*/
#define GETFONTPDEV(pPDev)  ((pPDev) ? ((PFONTPDEV)pPDev->pFontPDev) : NULL)


/*++

  Macro Description:

    Swaps bytes: b1 b2 b3 b4 becomes b4 b3 b2 b1

  Arguments:

    x - ULONG to be swapped

  Return Value:

    None.

--*/
#define SWAL( x )  ((ULONG)(x) = (ULONG) ((((((x) >> 24) & 0x000000ff) | \
                                         (((((x) >> 8) & 0x0000ff00)   | \
                                         ((((x) << 8) & 0x00ff0000)    | \
                                         (((x) << 24) & 0xff000000))))))))

/*++

  Macro Description:

    Returns whether the given FONTMAP_TTO is in a valid state.
    Note that we don't check the pvDLData.

  Arguments:

    pPrivateFM - TrueType fontmap structure.

  Return Value:

    TRUE if FONTMAP_TTO is valid, else FALSE

--*/
#define VALID_FONTMAP_TTO(pPrivateFM)                                       \
    ((pPrivateFM) &&                                                        \
     /*(pPrivateFM)->pTTFile && */                                          \
     (pPrivateFM)->pvGlyphData &&                                           \
     /* (pPrivateFM)->pvDLData */ TRUE )


/*++

  Macro Description:

    Returns whether the given FONTMAP is in a valid state.

  Arguments:

    pFM - fontmap structure.

  Return Value:

    TRUE if FONTMAP is valid, else FALSE

--*/
#define VALID_FONTMAP(pFM)  ((pFM) && VALID_FONTMAP_TTO(GETPRIVATEFM(pFM)))


/*++

  Macro Description:

    Asserts if the given FONTMAP is not in a valid state.

  Arguments:

    pFM - fontmap structure.

  Return Value:

    None.

--*/
#define ASSERT_VALID_FONTMAP(pFM)                                           \
{                                                                           \
    ASSERTMSG(VALID_FONTMAP(pFM), ("Invalid FONTMAP\n"));                   \
}


/*++

  Macro Description:

    Asserts if the given FONTPDEV is not in a valid state.

  Arguments:

    pFontPDev - TrueType fontmap structure.

  Return Value:

    None.

--*/
#define ASSERT_VALID_FONTPDEV(pFontPDev)                                    \
{                                                                           \
    ASSERTMSG(VALID_FONTPDEV(pFontPDev), ("Invalid FONTPDEV\n"));           \
    /* ASSERTMSG(pFontPDev, ("FONTPDEV: NULL\n")); */                       \
}


/*++

  Macro Description:

    Asserts if the given TO_DATA is not in a valid state.

  Arguments:

    pTod - TO_DATA structure.

  Return Value:

    None.

--*/
#define ASSERT_VALID_TO_DATA(pTod)                                          \
{                                                                           \
    ASSERTMSG(pTod, ("TO_DATA: NULL\n"));                                   \
    ASSERT_VALID_PDEV(pTod->pPDev);                                         \
    ASSERT_VALID_FONTMAP(pTod->pfm);                                        \
    ASSERTMSG(pTod->pgp, ("TO_DATA: pgp NULL\n"));                          \
}

/*++

  Macro Description:

    Determines if the file is a converted Type 1 font.

  Arguments:

    pIFI - IFI metrics structure

  Return Value:

    TRUE if Type 1, else FALSE

--*/
#define IS_TYPE1(pIFI) ((pIFI) && ((pIFI)->flInfo & FM_INFO_TECH_TYPE1))

/*++

  Macro Description:

    Determines if the file is a natural TrueType file (TTF)

  Arguments:

    pIFI - IFI metrics structure

  Return Value:

    TRUE if TrueType, else FALSE

--*/
#define IS_TRUETYPE(pIFI) ((pIFI) && ((pIFI)->flInfo & FM_INFO_TECH_TRUETYPE))

#define IS_BIDICHARSET(j) \
    (((j) == HEBREW_CHARSET)      || \
     ((j) == ARABIC_CHARSET)      || \
     ((j) == EASTEUROPE_CHARSET))

/*++

  Constant Description:

    Certain fonts do not print well (or at all) when downloaded as truetype
    outline.  Aside from modifying each and every gpd file this simple list
    will allow the driver to punt (to bitmap--probably) the downloading of
    fonts we don't handle.

    aszExemptedFonts - A lower case list of fonts we don't want to download.
                       The name of the fonts should be in lower case.
    nExemptedFonts - The number of items in the aszExemptedFonts list

--*/
const char * aszExemptedFonts[] = {
    "courier new",
    /* "wingdings", */
#ifdef WINNT_40
    "wingdings",
#endif
    "wide latin" };

const int nExemptedFonts = sizeof(aszExemptedFonts) /
                                sizeof(aszExemptedFonts[0]);

#define BWriteToSpoolBuf(pdev, data, size)                                  \
    (TTWriteSpoolBuf((pdev), (data), (size)) == (size))
//#define BWriteToSpoolBuf(pdev, data, size)                                  \
    //(WriteSpoolBuf((pdev), (data), (size)) == (size))

BOOL BWriteStrToSpoolBuf(IN PDEV *pdev, char *szStr);

/*++

  Macro Description:

    Shorter, simpler way to call WriteSpoolBuf.

  Arguments:

    pdev - Pointer to PDEV
    data - data to write
    size - bytes of data

  Return Value:

    TRUE if successful, else FALSE

--*/
INT TTWriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    );

/*++

  Macro Description:

    Mock-exception handling macros.  These macros perform a simplified
    exception handline using goto and function only within a given routine.

  Arguments:

    label - Goto label.  Multiple labels are supported for a single TRY.

  Return Value:

    None.

--*/
#define TRY             { BOOL __bError = FALSE; BOOL __bHandled = FALSE;
#define TOSS(label)     { __bError = TRUE; WARNING(("Tossing " #label "\n")); goto label; }
#define CATCH(label)    label: if (__bError && !__bHandled) WARNING(("Catching " #label "\n")); \
                               if (__bError && !__bHandled && (__bHandled = TRUE))
#define OTHERWISE       if (!__bError && !__bHandled && (__bHandled = TRUE))
#define ENDTRY          }

/*++

  Macro Description:

    This macro returns TRUE if the pPtr is between pStart and (pStart + ulSize).
    In other words it verifies that pPtr is a valid pointer into the data
    pointed to by pStart of size ulSize.  The macro will evaluate to false if
    the pointer falls before or after the desired range.

  Arguments:

    pStart - The start of data
    ulSize - The number of bytes pointed to by pStart
    pPtr   - A pointer into the data of pStart

  Return Value:

    TRUE if pPtr is in range, else FALSE.

--*/
#define PTR_IN_RANGE(pStart, ulSize, pPtr) \
    (((PBYTE)(pPtr) >= (PBYTE)(pStart)) && \
    ((PBYTE)(pPtr) < ((PBYTE)(pStart) + (ulSize))))

/*++

  Macro Description:

    Converts a FIXED number to a long, with the 'value' field in the
    upper 16 bits and the 'fract' value in the lower 16 bits.
    Note: I'm not using this right now, but let's not delete it just yet.

  Arguments:

    fixed - the FIXED value to convert.

  Return Value:

    The LONG number which is 15-value-8.7-fract-0

#define FIXEDTOLONG(fixed) (((fixed).value << 16) | ((fixed).fract))
--*/

/*++

  Macro Description:

    Evaluates to TRUE if the font is BOLD.

  Arguments:

    pfm - the FONTMAP for thie font.

  Return Value:

    TRUE if the font is BOLD, FALSE otherwise

--*/
#define FONTISBOLD(pfm) ((pfm)->pIFIMet->fsSelection & FM_SEL_BOLD)

/*++

  Macro Description:

    Evaluates to TRUE if the font is ITALIC.

  Arguments:

    pfm - the FONTMAP for thie font.

  Return Value:

    TRUE if the font is ITALIC, FALSE otherwise

--*/
#define FONTISITALIC(pfm) ((pfm)->pIFIMet->fsSelection & FM_SEL_ITALIC)

/*++

  Macro Description:

    Returns TRUE if the font is being simulated (i.e. there is not actual
    ttf file for this specific font).
    Note that there are several different times we will check for simulated
    fonts.  This one handles the initialization of the FONTMAP.

  Arguments:

    flFontType - The FONTOBJ.flFontType for thie font.

  Return Value:

    TRUE if the font is being simulated, FALSE otherwise

--*/

#define FONTISSIMULATED(flFontType) \
    ((flFontType & FO_SIM_BOLD) || (flFontType & FO_SIM_ITALIC))

#define DLMAP_FONTIS2BYTE(pdlm) ((pdlm)->wLastDLGId > 0x00FF)

#ifdef KLUDGE
void mymemcpy(const char *szFileName, int nLineNo,
              void *dst, const void *src, size_t size)
{
    DbgPrint("%s (%d): memcpy(%x,%x,%d)\n",
        szFileName, nLineNo, dst, src, size);
    memcpy(dst, src, size);
}

void mymemset(const char *szFileName, int nLineNo,
              void *dst, int byte, size_t size)
{
    DbgPrint("%s (%d): memset(%x,%d,%d)\n",
        szFileName, nLineNo, dst, byte, size);
    memset(dst, byte, size);
}

#define memcpy(dst, src, size) mymemcpy(StripDirPrefixA(__FILE__), __LINE__, (dst), (src), (size))

#define strcpy(dst, src) mymemcpy(StripDirPrefixA(__FILE__), __LINE__, (dst), (src), strlen(src)+1)

#undef ZeroMemory
#define ZeroMemory(ptr, size) mymemset(StripDirPrefixA(__FILE__), __LINE__, (ptr), 0, (size))

#endif


#define VERIFY_VALID_FONTFILE(pPDev) { }

///////////////////////////////////////////////////////////////////////////////
// Implementation

FONTMAP *
InitPFMTTOutline(
    PDEV    *pPDev,
    FONTOBJ *pFontObj
    )
/*++

  Routine Description:

    Initializes a FONTMAP structure for a truetype font.  Memory is allocated
    for the FONTMAP and private FONTMAP areas.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFontObj - Font object--used to get truetype file.

  Return Value:

    A FONTMAP for a truetype font with initialized fields.

--*/
{
    PFONTMAP pFontMap;
    DWORD    dwSize;


    FTRC(Entering InitPFMTTOutline...);

    ASSERT(VALID_PDEV(pPDev));

    // I want TERSE messages to print.
#ifdef TT_ECHO_ON
    giDebugLevel = DBG_TERSE;
#endif

    //
    // This is an example of Device font sub module.
    //
    dwSize = sizeof(FONTMAP) + sizeof(FONTMAP_TTO);
    TRY
    {
        if (!VALID_PDEV(pPDev) || !pFontObj)
            TOSS(ParameterError);

        if (FONTISSIMULATED(pFontObj->flFontType))
            TOSS(SimulatedFont);

        pFontMap = MemAlloc(dwSize);
        if (pFontMap == NULL)
            TOSS(MemoryAllocationFailure);

        ZeroMemory(pFontMap, dwSize);

        pFontMap->dwSignature = FONTMAP_ID;
        pFontMap->dwSize      = sizeof(FONTMAP);
        pFontMap->dwFontType  = FMTYPE_TTOUTLINE;
        pFontMap->pSubFM      = (PVOID)(pFontMap+1);
        pFontMap->flFlags    |= FM_SCALABLE;

        //
        // This function initializes pFontMap->pfnXXXX function pointer, pSubFM data structure.
        //
        if (!bInitTrueTypeFontMap(pFontMap, pFontObj))
        {
            MemFree(pFontMap);
            pFontMap = NULL;
        }
        TERSE(("Preparing to print a TrueType font.\n"));

    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        pFontMap = NULL;
    }
    CATCH(SimulatedFont)
    {
        TERSE(("Font is simulated bold or italic. Punting.\n"));
        pFontMap = NULL;
    }
    CATCH(MemoryAllocationFailure)
    {
        pFontMap = NULL;
    }
    ENDTRY;

    FTRC(Leaving InitPFMTTOutline...);

    return pFontMap;
}


BOOL
bInitTrueTypeFontMap(
    IN OUT PFONTMAP pFontMap,
    IN FONTOBJ *pFontObj
    )
/*++

  Routine Description:

    Initializes the truetype specific part of the fontmap structure, including
    the truetype file pointer itself.  The truetype file is loaded and memory-
    mapped as a result of this funciton.

  Arguments:

    pFontMap - Newly created fontmap structure to be initialized
    pFontObj - Font object--used to get truetype file.

  Return Value:

    TRUE if successful
    FALSE if failure

--*/
{
    FONTMAP_TTO *pPrivateFM;
    ULONG ulFile;
    BOOL bRet;

    FTRC(Entering bInitTrueTypeFontMap...);

    pFontMap->ulDLIndex             = (ULONG)-1;
    pFontMap->pfnSelectFont         = bTTSelectFont;
    pFontMap->pfnDeSelectFont       = bTTDeSelectFont;
    pFontMap->pfnDownloadFontHeader = dwTTDownloadFontHeader;
    pFontMap->pfnDownloadGlyph      = dwTTDownloadGlyph;
    pFontMap->pfnGlyphOut           = dwTTGlyphOut;
    pFontMap->pfnCheckCondition     = bTTCheckCondition;
    pFontMap->pfnFreePFM            = bTTFreeMem;

    // set other TT-specific fields here
    pPrivateFM = GETPRIVATEFM(pFontMap);

    // pPrivateFM->pTTFile = FONTOBJ_pvTrueTypeFontFile(pFontObj, &ulFile);

    // Set to default parsing mode
    pPrivateFM->dwCurrentTextParseMode = PARSE_MODE_0;

    // Grab a copy of the font type
    pPrivateFM->flFontType = pFontObj->flFontType;

    // Grab some memory for the GlyphData
    TRY
    {
        pPrivateFM->pvGlyphData = MemAlloc(sizeof(GLYPH_DATA));
        if (pPrivateFM->pvGlyphData == NULL)
            TOSS(MemoryAllocationFailure);

        ZeroMemory(pPrivateFM->pvGlyphData, sizeof(GLYPH_DATA));
    }
    CATCH(MemoryAllocationFailure)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bInitTrueTypeFontMap...);

    return bRet;
}


BOOL
bTTSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN POINTL *pptl
    )
/*++

  Routine Description:

    Selects the given font on the device.

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to select

  Return Value:

    TRUE if successful
    FALSE if failure

--*/
{
    DWORD dwParseMode; // Current PCL text parsing mode
    FONTMAP_TTO *pPrivateFM = GETPRIVATEFM(pFM);
    BOOL bRet;

    FTRC(Entering bTTSelectFont...);

    if (!VALID_PDEV(pPDev) || NULL == pFM)
    {
            return FALSE;
    }
    VERIFY_VALID_FONTFILE(pPDev);

    TERSE(("Selecting font ID 0x%x.\n", pFM->ulDLIndex));

    // IMPORTANT: Please note that the order of the point size command
    // and the font id command are very important.  If you send the
    // point size command *after* the font ID command you may not
    // get the font you wanted! JFF

    //
    // send Point Size Command if needed
    // Let's set it every time just to be sure! JFF
    // Note that this is now even more interesting because some fonts
    // are fixed space and the lCurrentPointSize doesn't apply.
    //
    // if (pptl->y != pPrivateFM->lCurrentPointSize)
    bRet = bPCL_SelectPointSize(pPDev, pFM, pptl);
    pPrivateFM->lCurrentPointSize = pptl->y;

    //
    // Select font pFM->ulDLIndex
    //
    bRet = bRet & bPCL_SelectFontByID(pPDev, pFM);

    //
    // Text Parsing Command
    //
    if (bRet & (S_OK == IsFont2Byte(pFM)))
    {
        bRet = bSetParseMode(pPDev, pFM, PARSE_MODE_21);
    }

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving bTTSelectFont...);

    return bRet;
}


BOOL
bSetParseMode(
    IN PDEV *pPDev,
    IN OUT PFONTMAP pFM,
    IN DWORD dwNewTextParseMode
    )
/*++

  Routine Description:

    Sets the parsing mode for this font.  Use parse mode 21 for two bype
    fonts and parse mode 0 for single byte fonts.  If the parsing mode
    already matches the given parsing mode nothing is done.

  Arguments:

    pFM - Font map
    dwNewTextParseMode - desired text parsing mode

  Return Value:

    Success.

--*/
{
    BOOL bRet;
    FONTMAP_TTO *pPrivateFM = GETPRIVATEFM(pFM);


    FTRC(Entering bSetParseMode...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    bRet = FALSE;

    if (pPrivateFM)
    {
        if (pPrivateFM->dwCurrentTextParseMode != dwNewTextParseMode)
        {
            pPrivateFM->dwCurrentTextParseMode = dwNewTextParseMode;
            if (bPCL_SetParseMode(pPDev, pFM))
                bRet = TRUE;
        }
        else
            bRet = TRUE;
    }

    FTRC(Leaving bSetParseMode...);

    return bRet;
}


BOOL
bTTDeSelectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    DeSelects the given font on the device.

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to deselect

  Return Value:

    TRUE if successful
    FALSE if failure

--*/
{
    BOOL bRet;
    FTRC(Entering bTTDeSelectFont...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    TERSE(("Deselecting font ID 0x%x.\n", pFM->ulDLIndex));

    // send Text Parsing Command - set to 0 (default)
    bRet = bSetParseMode(pPDev, pFM, PARSE_MODE_0) &&

    // send Font DeSelection Command
           bPCL_DeselectFont(pPDev, pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving bTTDeSelectFont...);

    return bRet;
}


DWORD
dwTTDownloadGlyph(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    WORD wDLGlyphId,
    WORD *pwWidth
    )
/*++

  Routine Description:

    Download the glyph table for the glyph passed to us.

    Two basic steps: first is to generate the header structure and send that
    off,  then send the actual glyph table.  The only complication happens if
    the download data exceeds 32,767 bytes of glyph image.  This is unlikely
    to happen, but we should be prepared for it.

    Note: If this routine fails do we download as bitmap, or is there another
    routine that we call, or does the caller handle this?

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to download
    hGlyph - specifies glyph to download

  Return Value:

    Bytes of memory used to download glyph.  On failure returns 0.

--*/
{
    USHORT   usGlyphLen;        // number of bytes in glyph
    BYTE    *pbGlyphMem;        // location of glyph in tt file
    DWORD    dwBytesSent;       // Amount of glyph data sent to device
    GLYPH_DATA_HEADER glyphData;
    PFONTPDEV pFontPDev;


    FTRC(Entering dwTTDownloadGlyph...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pwWidth, ("dwTTDownloadGlyph!pwWidth NULL\n"));

    VERIFY_VALID_FONTFILE(pPDev);

    TRY
    {
        dwBytesSent = 0;

        TERSE(("Downloading glyph ID 0x%x.\n", wDLGlyphId));

        if (NULL == (pFontPDev = GETFONTPDEV(pPDev)))
        {
            TOSS(DataError);
        }

        //
        // The font id is no longer set at the beginning of the download sequence.
        // However, the FDV_SET_FONTID flag will tell me when I need to send it.
        //
        if (!(pFontPDev->flFlags & FDV_SET_FONTID))
        {
            PFONTMAP_TTO pPrivateFM;
            DL_MAP *pDLMap;

            if (NULL == (pPrivateFM = GETPRIVATEFM(pFM)))
            {
                TOSS(DataError);
            }
            pDLMap = (DL_MAP*)pPrivateFM->pvDLData;

            TERSE(("Setting Font ID 0x%x.\n", pDLMap->wCurrFontId));
            pFM->ulDLIndex = pDLMap->wCurrFontId;
            bPCL_SetFontID(pPDev, pFM);
            pFontPDev->flFlags  |= FDV_SET_FONTID;
        }

        pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        if (pbGlyphMem == NULL)
            TOSS(DataError);

        memcpy(&glyphData, pbGlyphMem, sizeof(glyphData));


        #if PRINT_INFO
        if (glyphData.numberOfContours < 0)
            ERR(( "dwTTDownloadGlyph!Complex Glyph\n" ));
        #endif

        dwBytesSent = dwSendCharacter(pPDev, pFM, hGlyph, wDLGlyphId);

        //
        // If the glyph is a composite character, need to send the remaining glyph
        // data with a special glyph id of 0xffff
        //
        if (glyphData.numberOfContours < 0)
            dwBytesSent += dwSendCompoundCharacter(pPDev, pFM, hGlyph);
    }
    CATCH(DataError)
    {
        dwBytesSent = 0;
    }
    ENDTRY;

    if (dwBytesSent == 0)
        ERR(("dwTTDownloadGlyph!No bytes sent to printer.\n"));

    VERIFY_VALID_FONTFILE(pPDev);

    //
    // When downloading as TT outline there is no way to calculate the width.
    // So use the width returned by GDI. Do to this just return zero.
    //

    *pwWidth = 0;

    FTRC(Leaving dwTTDownloadGlyph...);

    return  dwBytesSent;
}


DWORD
dwTTGlyphOut(
    IN TO_DATA *pTod
    )
/*++

  Routine Description:

    Invokes a set of glyphs on the device.

    We are given two arrays in the TOD: a glyphpos array and a dlglyph
    array.  The first specifies the position of the glyphs on the page,
    and the second specifies the download ids of the glyphs.  The
    cGlyphsToPrint member specifies how many glyphs to send in this call.

  Arguments:

    pTod - The Text Out data--specifies glyph and everything
    pTod->cGlyphsToPrint - Number of glyphs to send
    pTod->pgp - Glyph positions array
    pTod->apdlGlyph - Glyph download ids array
    pTod->dwCurrGlyph - index into pdlGlyph of where to begin

  Return Value:

    The number of glyphs printed.


--*/
{
    // DWORD dwBytesSent;
    DWORD dwGlyphsSent;
    PDEV *pPDev;
    PFONTPDEV pFontPDev;
    GLYPHPOS *pgp;
    GLYPHPOS *pgpPrev;
    DWORD i;
    BOOL bDefaultPlacement;
    BOOL bHorizontalMovement;
    POINTL ptlFirst, rtlRem;
    BOOL bFirstLoop;
    DWORD dwGlyphs;
    PDLGLYPH pDLG ;
    INT iRelX = 0;
    INT iRelY = 0;
    LONG lWidth = 0;


    FTRC(Entering dwTTGlyphOut...);

    ASSERT_VALID_TO_DATA(pTod);

    pPDev = pTod->pPDev;
    i = pTod->dwCurrGlyph;
    pgp = pTod->pgp;
    pgpPrev = NULL;
    // dwBytesSent = 0;
    dwGlyphsSent = 0;
    bDefaultPlacement = !(SET_CURSOR_FOR_EACH_GLYPH(pTod->flAccel));
    ptlFirst = pgp->ptl;
    bFirstLoop = TRUE;
    dwGlyphs = pTod->cGlyphsToPrint;

    VERIFY_VALID_FONTFILE(pPDev);

    //
    // Set the cursor to first glyph if not already set.
    //
    // If there is rounding error, when scaling width,
    // disable x position optimization
    //
    //
    if ( !(pTod->flFlags & TODFL_FIRST_GLYPH_POS_SET) ||
         (pFontPDev = GETFONTPDEV(pPDev)) &&
	 pFontPDev->flFlags & FDV_DISABLE_POS_OPTIMIZE )
    {

        VSetCursor( pPDev, pgp->ptl.x, pgp->ptl.y, MOVE_ABSOLUTE, &rtlRem);

        //
        // We need to handle the return value. Devices with resoloutions finer
        // than their movement capability (like LBP-8 IV) get into a knot here,
        // attempting to y-move on each glyph. We pretend we got where we
        // wanted to be.
        //

        pPDev->ctl.ptCursor.x += rtlRem.x;
        pPDev->ctl.ptCursor.y += rtlRem.y ;

        //
        // Now set the flag.
        //
        pTod->flFlags |= TODFL_FIRST_GLYPH_POS_SET;
    }

    while (dwGlyphs--)
    {
        // Locate the download glyph info (pgp is already set)
        pDLG = pTod->apdlGlyph[i++];

        // Skip this the first time through.
        if (bFirstLoop)
        {
            ASSERT(pgpPrev == NULL);
            bFirstLoop = FALSE;
        }
        else
        {
            ASSERT(pgp && pgpPrev);

            //
            // If default placement is off then the character spacing is
            // defined by the pgp->ptl.  Otherwise, the printer's CAP movement
            // will suffice.
            //
            if (!bDefaultPlacement)
            {

                VSetCursor(pPDev, pgp->ptl.x, pgp->ptl.y,
                           MOVE_ABSOLUTE, &rtlRem);
            }
        }

        // Send the glyph to the printer
        TERSE(("Outputting glyph ID 0x%x.\n", (UINT)pDLG->wDLGlyphID));

        if (BPrintADLGlyph(pPDev, pTod, pDLG))
            dwGlyphsSent++;


        //
        // Update the cusor position. This is done only for non default
        // placement case.
        //
        if (!bDefaultPlacement)
        {
            iRelX = 0;
            iRelY = 0;

            lWidth = pDLG->wWidth;

            if (pTod->flAccel & SO_VERTICAL)
                iRelY =  lWidth;
            else
                iRelX = lWidth;

            VSetCursor( pPDev, iRelX, iRelY,
                        MOVE_RELATIVE | MOVE_UPDATE, &rtlRem);
        }

        // Keep track of pos for next loop.
        pgpPrev = pgp;

        // Go to the next glyph in the list
        pgp++;
    }

    // If default placement is on, then we've been ignoring position info.  Time to
    // reconcile with the printer's CAP.  The trick is getting the width of the last
    // char.  The last char is pointed to by pgpPrev and the width is in the bitmap bits.
    if (!bFirstLoop)
    {
        LONG lDelta;
        iRelX = 0;
        iRelY = 0;

        ASSERT(pgpPrev);

        lWidth = pDLG->wWidth;

        if (pTod->flAccel & SO_HORIZONTAL)
        {
            iRelX = pgpPrev->ptl.x - ptlFirst.x + lWidth;
        }
        else if (pTod->flAccel & SO_VERTICAL)
        {
            iRelY = pgpPrev->ptl.y - ptlFirst.y + lWidth;
        }
        else
        {
            iRelX = pgpPrev->ptl.x - ptlFirst.x + lWidth;
            iRelY = pgpPrev->ptl.y - ptlFirst.y;
        }
        VSetCursor(pPDev, iRelX, iRelY, MOVE_RELATIVE | MOVE_UPDATE, &rtlRem);
    }
    // Note: pFM->ctl.iRotate also indicates print direction (?).
    // Represented as 90 degrees * pFM->ctl.iRotate.

    FTRC(Leaving dwTTGlyphOut...);

    VERIFY_VALID_FONTFILE(pPDev);

    return dwGlyphsSent;
}


BOOL IsAnyCharsetDbcs(PBYTE aCharSets)
{
    BOOL bRet = FALSE;

    if (NULL != aCharSets)
    {
        for ( ;*aCharSets != DEFAULT_CHARSET; aCharSets++)
        {
            if (IS_DBCSCHARSET(*aCharSets))
	    {
	        bRet = TRUE;
	        break;
	    }
        }
    }
    return bRet;
}

BOOL IsAnyCharsetBidi(PBYTE aCharSets)
{
    BOOL bRet = FALSE;

    if (NULL != aCharSets)
    {
        for ( ;*aCharSets != DEFAULT_CHARSET; aCharSets++)
        {
            if (IS_BIDICHARSET(*aCharSets))
            {
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

#ifdef WINNT_40
BOOL BIsFontPFB(
        IFIMETRICS* pifi)
{
    BOOL  bRet;
    PTSTR pTmp;

    if (pTmp = wcsrchr((WCHAR*)((PBYTE)pifi+pifi->dpwszFaceName), L'.'))
    {
        bRet = (0 == _wcsicmp(pTmp, L".tmp"));
    }
    else
        bRet = FALSE;


    return bRet;
}
#endif

// Note these are guesses! There should be a better way! JFF
#define AVG_BYTES_PER_HEADER 4096
#define AVG_BYTES_PER_GLYPH   275

BOOL
bTTCheckCondition(
    PDEV        *pPDev,
    FONTOBJ     *pfo,
    STROBJ      *pstro,
    IFIMETRICS  *pifi
    )
/*++

  Routine Description:

    Verifies that the current operation can be carried out by this module.

  Arguments:

    pPDev - Pointer to PDEV
    pGlyphPos - A glyph to be printed
    pFI - font info

  Return Value:

    TRUE if the operation can be carried.
    FALSE otherwise.

--*/
{
    BOOL         bEnoughMem = FALSE;
    DL_MAP      *pDLMap;
    PFONTPDEV    pFontPDev;
    ULONG        ulTTFileLen;

    FTRC(Entering bTTCheckCondition...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(pfo, ("bTTCheckCondition!pfo NULL.\n"));
    ASSERTMSG(pstro, ("bTTCheckCondition!pstro NULL.\n"));

    //
    // Make sure that all parameters ara valid.
    //
    if (NULL == pPDev ||
        NULL == (pFontPDev = GETFONTPDEV(pPDev)) ||
        NULL == pfo   ||
        NULL == pstro ||
        NULL == pifi   )
    {
        return FALSE;
    }

    VERIFY_VALID_FONTFILE(pPDev);

    pDLMap = PGetDLMapFromIdx(pFontPDev, PtrToLong(pfo->pvConsumer) - 1);

    TRY
    {
        WORD wTotalGlyphs;
        DWORD cjMemReq;

        //
        // Make sure that the technology of the font matches the capabilities
        // of the driver.  For example we don't like converted Type 1 fonts.
        //
        if (!IS_TRUETYPE(pifi) && IS_TYPE1(pifi))
            TOSS(UnhandledFont);

#ifdef WINNT_40
        if (BIsFontPFB(pifi))
            TOSS(UnhandledFont);
#endif

        //
        // Fonts we don't want to handle are in the UnhandledFonts list
        //
        if (BIsExemptedFont(pPDev, pifi))
            TOSS(UnhandledFont);

        //
        // Is PDF Type1 font?
        //
        if (BIsPDFType1Font(pifi))
        {
            TOSS(UnhandledFont);
        }

        //
        //
        // TrueType outline downloaded font can't be scaled by non-square
        // (X and Y independendly).
        //
        if(NONSQUARE_FONT(pFontPDev->pxform))
            TOSS(UnhandledFont);

        // Trunction may have happened.We won't download if the number glyphs
        // or Glyph max size are == MAXWORD.  (Note to self: what is "Trunction"?)
        //
        if ( (pDLMap->cTotalGlyphs  == MAXWORD) ||
             (pDLMap->wMaxGlyphSize == MAXWORD) ||
             (pDLMap->wFirstDLGId   == MAXWORD) ||
             (pDLMap->wLastDLGId    == MAXWORD) )
             TOSS(InsufficientFontMem);

        wTotalGlyphs = min( (pDLMap->wLastDLGId - pDLMap->wFirstDLGId),
                           pDLMap->cTotalGlyphs );

        //
        // Calculate the predicted memory requirements for this font.
        //
        cjMemReq = AVG_BYTES_PER_HEADER;
        cjMemReq += wTotalGlyphs * AVG_BYTES_PER_GLYPH;

        //
        // This one's easy.  Don't use all the font memory!
        //
        if ((pFontPDev->dwFontMemUsed + cjMemReq) > pFontPDev->dwFontMem)
            TOSS(InsufficientFontMem);

        //
        // Another check: don't use more than 1/4 of the font memory on any
        // single font!
        //
        if ((cjMemReq * 4) > pFontPDev->dwFontMem)
            TOSS(InsufficientFontMem);

        //
        // Check: don't download wide truetype font. Check the character set
        // of font and if it's one of CJK, return FALSE.
        //

        if (pifi && (IS_DBCSCHARSET(pifi->jWinCharSet) || (pifi->dpCharSets && IsAnyCharsetDbcs((PBYTE)pifi + pifi->dpCharSets))))
            TOSS(CharSetMismatch);

        //
        // Check: If the font is a TTC, but the mode is single-byte then we
        // will probably run out of glyph ids.  Better punt.
        //
        if (bIsTrueTypeFileTTC(pvGetTrueTypeFontFile(pPDev, &ulTTFileLen)) &&
                !DLMAP_FONTIS2BYTE(pDLMap))
            TOSS(CharSetMismatch);
    }
    CATCH(InsufficientFontMem)
    {
        WARNING(("UniFont!bTTCheckCondition:"
                 "Not Downloading the font:TOO BIG for download\n"));
        bEnoughMem = FALSE;
    }
    CATCH(CharSetMismatch)
    {
        //
        // The character set is unacceptable to the truetype download code.
        //
        WARNING(("UniFont!bTTCheckCondition:"
                 "Not Downloading the font:Character set mismatch.\n"));
        bEnoughMem = FALSE;
    }
    CATCH(UnhandledFont)
    {
        //
        // Although there may be enough memory to handle this font we will
        // return false to indicate that this font should be handled some
        // other way--such as bitmap.
        //
        bEnoughMem = FALSE;
    }
    OTHERWISE
    {
        bEnoughMem = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bTTCheckCondition...);

    VERIFY_VALID_FONTFILE(pPDev);

    return bEnoughMem;
}


BOOL
bTTFreeMem(
    IN OUT PFONTMAP pFM
    )
/*++

  Routine Description:

    Free's any memory used by the fontmap structure, including the fontmap
    itself.  Now is a good time to do any cleanup necessary.
    This funciton must reflect the memory allocated in the Init function.

  Arguments:

    pFM - FontMap to be free'd.

  Return Value:

    None.

--*/
{
    BOOL bRet = FALSE;


    FTRC(Entering bTTFreeMem...);

    ASSERT_VALID_FONTMAP(pFM);

    TERSE(("Preparing to release a TrueType font.\n"));

    TRY
    {
        FONTMAP_TTO *pPrivateFM;

        if (!pFM || (pFM->dwFontType != FMTYPE_TTOUTLINE))
            TOSS(ParameterError);

        pPrivateFM = GETPRIVATEFM(pFM);

        // Return the GlyphData memory too.
        if (pPrivateFM->pvGlyphData)
            MemFree(pPrivateFM->pvGlyphData);

        // Return the entire fontmap structure.
        MemFree(pFM);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;


    FTRC(Leaving bTTFreeMem...);

    return bRet;
}


DWORD
dwTTDownloadFontHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Sends a font header to the device for the given font.

  Arguments:

    pPDev - Pointer to PDEV
    pFM - Font map--specifies font to download

  Return Value:

    Memory used to download header.  On failure returns 0.

--*/
{
    FONTMAP_TTO *pPrivateFM;
    DL_MAP      *pDLMap;

    PVOID       pTTFile;
    ULONG       ulTTFileLen;

    TT_HEADER   ttheader;
    USHORT      usNumTags;
    BOOL        bStatus;
    BOOL        bExistPCLTTable = FALSE;  // TRUE if the optional PCLT Table is in TT file
    DWORD       dwBytesSent;

    HEAD_TABLE  headTable;
    POST_TABLE  postTable;
    MAXP_TABLE  maxpTable;
    PCLT_TABLE  pcltTable;
    CMAP_TABLE  cmapTable;
    NAME_TABLE  nameTable;
    OS2_TABLE   OS2Table;
    HHEA_TABLE  hheaTable;
    BYTE        PanoseNumber[LEN_PANOSE];
    BOOL        bUse2Byte;

    ATABLEDIR PCLTableDir; // Tables needed for PCL download
    ATABLEDIR TableDir;    // Other tables needed for info but not sent to printer


    FTRC(Entering dwTTDownloadFontHeader...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    if (!(pPrivateFM = GETPRIVATEFM(pFM)))
    {
        ERR(("dwTTDownloadFontHeader!pPrivateFM NULL\n"));
        return 0;
    }

    pDLMap = (DL_MAP*)pPrivateFM->pvDLData;
    pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

    //
    // UNIDRV failed to get a memory mapped TT file image.
    //
    if (!pTTFile)
    {
        ERR(("dwTTDownloadFontHeader!pTTFile NULL\n"));
        return 0;
    }

    bUse2Byte = (S_OK == IsFont2Byte(pFM));

    if (pDLMap == 0)
    {
        ERR(("dwTTDownloadFontHeader!pDLMap NULL\n"));
        return 0;
    }

    VERIFY_VALID_FONTFILE(pPDev);

    ZeroMemory(&ttheader, sizeof(ttheader));        // Safe default values
    ZeroMemory(&PCLTableDir, sizeof (PCLTableDir));

    //
    // First fill in the stuff that is easy to find
    //

    //
    // Note that the TT_HEADER and UB_TT_HEADER structures are identical.
    // Therefore, many fields will be treated the same from format 15 to
    // format 16.  Differences start to show up in the segmented font data.
    //
    ttheader.usSize = sizeof(TT_HEADER); // = sizeof(UB_TT_HEADER); too
    SWAB(ttheader.usSize);

    if (bUse2Byte)
    {
        ttheader.bFormat = PCL_FM_2B_TT;
        ttheader.bFontType = TT_2BYTE_FONT; // not TT_UNBOUND_FONT;
    }
    else
    {
        ttheader.bFormat = PCL_FM_TT;
        ttheader.bFontType = TT_BOUND_FONT;
    }

    //
    // Now fill in the entries from the True Type File
    // pPCLTableDir is the table directory that is downloaded
    // to the printer.
    // pvTableDir is the table directory containing info that
    // is needed for the font but it is not downloaded to
    // the printer. Keep the two tables separate so it's easier
    // to dump to the printer later - simply dump the pPCLTableDir
    // and free the pvTableDir memory.
    //

    usNumTags = usParseTTFile (pPDev, pFM, PCLTableDir, TableDir, &bExistPCLTTable);

    //
    // Get the various tables so we can parse the font information
    //
    bReadInTable (pTTFile, PCLTableDir, TABLEHEAD, &headTable, sizeof ( headTable ));
    pPrivateFM->sIndexToLoc = headTable.indexToLocFormat;

    bReadInTable (pTTFile, PCLTableDir, TABLEMAXP, &maxpTable, sizeof ( maxpTable ));
    pPrivateFM->usNumGlyphs = maxpTable.numGlyphs;

    bReadInTable (pTTFile, TableDir,   TABLEPOST, &postTable, sizeof ( postTable ));
    bReadInTable (pTTFile, TableDir,   TABLECMAP, &cmapTable, sizeof ( cmapTable ));
    bReadInTable (pTTFile, TableDir,   TABLENAME, &nameTable, sizeof ( nameTable ));
    bReadInTable (pTTFile, PCLTableDir, TABLEHHEA, &hheaTable, sizeof ( hheaTable ));

    bReadInTable (pTTFile, TableDir,  TABLEOS2,  &OS2Table, sizeof (OS2Table));

    if (bExistPCLTTable)
        bReadInTable (pTTFile, TableDir,  TABLEPCLT, &pcltTable, sizeof ( pcltTable ));

    //
    // Fill in the True Type header with the info from the True
    // Type file.
    //
    SWAB (headTable.xMax);
    SWAB (headTable.xMin);
    SWAB (headTable.yMax);
    SWAB (headTable.yMin);
    ttheader.wCellWide = (headTable.xMax - headTable.xMin);
    SWAB (ttheader.wCellWide);
    ttheader.wCellHeight = (headTable.yMax - headTable.yMin);
    SWAB (ttheader.wCellHeight);

    ttheader.bSpacing = postTable.isFixedPitch ? FIXED_SPACING : 1; // 1=PROPORTIONAL
    // pUDPDev->pFM->bSpacing = postTable.isFixedPitch ? FIXED_SPACING : 1; // 1=PROPORTIONAL

#ifdef DBG
    // I'm going to use jWinPitchAndFamily later.  Make sure that
    // it agrees with postTable.isFixedPitch. JFF
    {
        BYTE fontPitch = (pFM->pIFIMet->jWinPitchAndFamily & 0x03);
        if ((postTable.isFixedPitch && (fontPitch != FIXED_PITCH)) ||
            (!postTable.isFixedPitch && (fontPitch != VARIABLE_PITCH)))
        {
            ERR(("dwTTDownloadFontHeader!postTable.isFixedPitch different from "
             "pIFI->jWinPitchAndFamily"));
        }
    }
#endif
    //
    // Build the Glyph linked list. Each node contains a character
    // code and its corresponding Glyph ID from the True Type file.
    //
    bCopyGlyphData (pPDev, pFM, cmapTable, TableDir);

    // Get the PCL table. If it's not present generate defaults.
    vGetPCLTInfo (pPDev, pFM, &ttheader, pcltTable, bExistPCLTTable, OS2Table, headTable, postTable, hheaTable, PCLTableDir);

    ttheader.bQuality = TT_QUALITY_LETTER;

    //
    // Set the first/last ids.  When using 2-byte downloading I override the
    // DL_MAP values with the parse-mode 21 char codes.
    //
    if (bUse2Byte)
    {
        //
        // [ISSUE] The number of chars, 0x0800, is just a guess for now.  We need a sensible
        // algorithm for determining this number so that it's large enough to be useful
        // but doesn't blow the memory on the printer.
        //
        ttheader.wFirstCode = pDLMap->wFirstDLGId = FIRST_TT_2B_CHAR_CODE;
        ttheader.wLastCode  = pDLMap->wLastDLGId  = FIRST_TT_2B_CHAR_CODE + 0x0800;
        SWAB(ttheader.wFirstCode);
        SWAB(ttheader.wLastCode);

        // Because I changed the range I need to change this too.
        pDLMap->wNextDLGId = pDLMap->wFirstDLGId;
    }
    else
    {
        // ttheader.wFirstCode = OS2Table.usFirstCharIndex;
        // ttheader.wLastCode = OS2Table.usLastCharIndex;
        // ttheader.wLastCode = 0xff00;
        ttheader.wFirstCode = pDLMap->wFirstDLGId;
        ttheader.wLastCode  = pDLMap->wLastDLGId;
        SWAB(ttheader.wFirstCode);
        SWAB(ttheader.wLastCode);
    }

    //
    // Get the font name from the True Type Font file and put
    // it into the ttheader
    //
    vGetFontName (pPDev, pFM->pIFIMet, ttheader.FontName, (size_t)LEN_FONTNAME);

    ttheader.wScaleFactor = headTable.unitsPerEm;
    SWAB (headTable.unitsPerEm);

    ttheader.sMasterUnderlinePosition = postTable.underlinePosition;
    ttheader.sMasterUnderlinePosition = -(SHORT) (headTable.unitsPerEm/5);
    SWAB (ttheader.sMasterUnderlinePosition);

    ttheader.usMasterUnderlineHeight = postTable.underlineThickness;
    ttheader.usMasterUnderlineHeight = (USHORT) (headTable.unitsPerEm/20);
    SWAB (ttheader.usMasterUnderlineHeight);

    ttheader.usTextHeight = SWAB(OS2Table.sTypoLineGap) +
                            headTable.unitsPerEm;
    SWAB (ttheader.usTextHeight);

    ttheader.usTextWidth = OS2Table.xAvgCharWidth;

    ttheader.bFontScaling = 1;

#ifdef COMMENTEDOUT
    if (ttheader.wSymSet == 0)
        ttheader.wSymSet = DEF_SYMBOLSET;
#endif
    //
    // The symbol set is conflicting with device font symbol sets.  This is most evident
    // when printing the Euro character.  The downloaded TNR TT font causes future uses of the
    // TNR device font to be ignored.  Characters are interpreted as glyph ids and nothing
    // useful is printed.  The solution is to use a custom character set (in this case 0Q)
    // for all TT downloaded fonts.
    //
    ttheader.wSymSet = 17; // Symbol set 0Q
    SWAB(ttheader.wSymSet);



    memcpy (&PanoseNumber, &OS2Table.Panose, LEN_PANOSE);

    //
    // Send the font info from the True Type file to the printer
    //
    dwBytesSent = dwDLTTInfo (pPDev, pFM, ttheader, usNumTags, PCLTableDir, PanoseNumber, bExistPCLTTable);

    //
    // rem return maxpTable.numGlyphs;
    // return mem used.  This may be the size of the font header.
    //
    FTRC(Leaving dwTTDownloadFontHeader...);

    VERIFY_VALID_FONTFILE(pPDev);

    return dwBytesSent;
}


USHORT
usParseTTFile(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT PTABLEDIR pPCLTableDir,
    OUT PTABLEDIR pTableDir,
    OUT BOOL *pbExistPCLTTable
    )
/*++

  Routine Description:

    Function to  retrieve True Type font information from the True Type file
    and store into the ttheader font structure.  Modifies pbExistPCLTTable: True
    if PCLT table is in the True Type file otherwise pbExistPCLTTable becomes
    FALSE.

    Need to parse through and pick up the tables needed for the PCL spec. There
    are 8 tables of which 5 are required and three are optional. Tables are
    sorted in alphabetical order.   The PCL tables needed are:
        cvt -  optional
        fpgm - optional
        gdir - required
        head - required
        hhea - required
        hmtx - required
        maxp - required
        prep - optional
    The optional tables are used in hinted fonts.

    usNumTags is incremented only for PCL tables.

  Arguments:

    pPDev - Unidriver-specific PDev structure
    pPCLTableDir - Pointer to PCL Tables Total 8, They are sent to printer
    pvTableDir - Pointer to General Tables Total 3, used for other info.
    pbExistPCLTTable - Set to TRUE if PCLT table is in True Type file

  Return Value:

    The number of tags in the True Type file.

--*/
{
#define REQUIRED_TABLE(pTable, TableName) { if ((pTable) == NULL) { \
    ERR(("usParseTTFile!Missing required table " #TableName "\n")); return 0; } }

    FONTMAP_TTO *pPrivateFM;
    PVOID        pTTFile;
    ULONG        ulTTFileLen;

    USHORT usNumTags; // Num elements in PCL Table Dir
    USHORT usMaxTags; // Num elements in TrueType file
    PTABLEDIR pDirectory; // Pointer to TrueType file's table dir
    PTABLEDIR pDirEntry; // Pointer to desired entry


    FTRC(Entering usParseTTFile...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    //
    // Use byte-pointers to move through the table arrays.  A counter
    // will track the number of elements in the PCLTableDir.
    //
    pPrivateFM = GETPRIVATEFM(pFM);
    pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

    if (!pTTFile)
    {
        ERR(("usParseTTFile!pTTFile NULL\n"));
        return 0;
    }

    usNumTags = 0;
    usMaxTags = usGetNumTableDirEntries(pTTFile);
    pDirectory = pGetTableDirStart(pTTFile);
    pDirEntry = NULL;

    //
    // Much of this code works from this basic assumption
    //
    if ((sizeof(TABLEDIR) != TABLE_DIR_ENTRY) ||
        (sizeof(TABLEDIR) != 4 * sizeof(ULONG)))
    {
        ERR(("usParseTTFile!Fundamental assumption invalid: sizeof(TABLEDIR)\n"));
        return 0;
    }

    if (NULL == pTableDir)
    {
        ERR(("usParseTTFile!Fundamental assumption invalid: NULL pTableDir\n"));
        return 0;
    }

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEOS2))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLEOS2);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEPCLT))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
        *pbExistPCLTTable = TRUE;
    }
    else
    {
        *pbExistPCLTTable = FALSE;
    }

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLECMAP))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLECMAP);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLECVT))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEFPGM))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }

    // add gdir table here
    memcpy (pPCLTableDir, TABLEGDIR, 4);
    pPCLTableDir++;
    usNumTags += 1;

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEGLYF))
    {
        pPrivateFM->ulGlyphTable = pDirEntry->uOffset;
        pPrivateFM->ulGlyphTabLength = pDirEntry->uLength;

        SWAL (pPrivateFM->ulGlyphTable);
        SWAL (pPrivateFM->ulGlyphTabLength);
    }
    REQUIRED_TABLE(pDirEntry, TABLEGLYF);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEHEAD))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEHEAD);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEHHEA))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEHHEA);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEHMTX))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEHMTX);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLELOCA))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pPrivateFM->ulLocaTable = pTableDir->uOffset;
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLELOCA);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEMAXP))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }
    REQUIRED_TABLE(pDirEntry, TABLEMAXP);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLENAME))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLENAME);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEPOST))
    {
        bCopyDirEntry(pTableDir, pDirEntry);
        pTableDir++;
    }
    REQUIRED_TABLE(pDirEntry, TABLEPOST);

    if (pDirEntry = pFindTag(pDirectory, usMaxTags, TABLEPREP))
    {
        bCopyDirEntry(pPCLTableDir, pDirEntry);
        pPCLTableDir++;
        usNumTags += 1;
    }

    FTRC(Leaving usParseTTFile...);

    return usNumTags;

#undef REQUIRED_TABLE
}


PTABLEDIR
pFindTag(
    IN PTABLEDIR pTableDir,
    IN USHORT usMaxDirEntries,
    IN char *pTag
    )
/*++

  Routine Description:

    Locates the given tag in the true-type header and returns a pointer
    to the desired entry, or NULL if it was not found.

    Note that this routine leaves room for improvement.  Since the fields
    are defined to be in alpha order you should be able to stop after
    passing the desired location (but before reaching the end).

  Arguments:

    pTableDir - pointer to directory entries
    usMaxDirEntries - number of fields in pTableDir
    pTag - pointer to tag we want to find

  Return Value:

    A pointer to the desired entry or NULL if failure.

--*/
{
    USHORT us;
    PTABLEDIR pEntry;


    FTRC(Entering pFindTag...);

    ASSERTMSG(pTableDir, ("pFindTag!pTableDir NULL.\n"));
    ASSERTMSG(pTag, ("pFindTag!pTag NULL.\n"));

    pEntry = NULL;

    //
    // Search the array.  Return the matching item if found.
    //
    for (us = 0; (us < usMaxDirEntries) && pTableDir; us++)
    {
        if (bTagCompare(pTableDir->uTag, pTag))
        {
            pEntry = pTableDir;
            break;
        }

        pTableDir++;
    }

    //
    // Return the item if it was found, else NULL
    //
    FTRC(Leaving pFindTag...);

    return pEntry;
}


BOOL
bCopyDirEntry(
    OUT PTABLEDIR pDst,
    IN PTABLEDIR pSrc
    )
/*++

  Routine Description:

    Copies a table directory entry out of the true type file (i.e. from
    the given location) into the given destination.  The offset field
    byte order is fixed-up.

    Note that this uses the same parameter order as strcpy: (Dest, Src)

  Arguments:

    pbDst - Pointer to destination
    pbSrc - Pointer to source

  Return Value:

    TRUE if the entry could be copied. FALSE otherwise.

--*/
{
    BOOL bRet = FALSE;

    FTRC(Entering bCopyDirEntry...);

    ASSERTMSG(pSrc, ("bCopyDirEntry!pSrc NULL.\n"));
    ASSERTMSG(pDst, ("bCopyDirEntry!pDst NULL.\n"));

    if ((pSrc != NULL) && (pDst != NULL))
    {
        // Get the table directory entry
        memcpy(pDst, pSrc, TABLE_DIR_ENTRY);

        // now fix the byte-order of the offset field
        SWAL(pDst->uOffset);
        SWAL(pDst->uLength);

        bRet = TRUE;
    }
    else
        bRet = FALSE;

        FTRC(Leaving bCopyDirEntry...);

    return bRet;
}


BOOL
bTagCompare(
    IN ULONG uTag,
    IN char *pTag
    )
/*++

  Routine Description:

    Compares the memory and tag to see if they are equal.

    Note this only works when the size of the tag does not exceed
    4 bytes AND any three-letter tags have the following space, e.g.
    "cvt"  <-- WRONG
    "cvt " <-- RIGHT

    Since this routine works by casting the 4 character string to a DWORD it
    is constrained by the fact that sizeof(DWORD) == (4 * sizeof(char)).

  Arguments:

    uTag - Hardcoded tag value
    pTag - Pointer to tag

  Return Value:

    TRUE if the tag at the current location in the TT file matches the
    given tag.  Otherwise FALSE.

--*/
{
    BOOL   bMatch;


    //FTRC(Entering bTagCompare...);

    ASSERTMSG(pTag, ("bTagCompare!pTag NULL.\n"));

    // If this fails change the include file (see above)
    ASSERTMSG(strcmp("cvt ", TABLECVT) == 0, ("bTagCompare!'cvt ' string incorrect.\n"));

    if (pTag != NULL)
    {
        DWORD *pdwTag = (DWORD *)pTag;
        bMatch = (uTag == *pdwTag);
    }
    else
        bMatch = FALSE;

        //FTRC(Leaving bTagCompare...);

    return bMatch;
}


BOOL
bIsTrueTypeFileTTC(
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Returns whether the truetype file is in the TTC file format or not
    (your other choice is TTF).

  Arguments:

    pTTFile - Pointer to memory mapped TrueType file

  Return Value:

    TRUE if the file is TTC, or FALSE if the file is TTF.

--*/
{
    BOOL bRet;
    const ULONG *pulFile = (const ULONG*)pTTFile;

    FTRC(Entering bIsTrueTypeFileTTC...);

    if (pTTFile)
        bRet = bTagCompare(*(pulFile), "ttcf");
    else
        bRet = FALSE;

    FTRC(Leaving bIsTrueTypeFileTTC...);

    return bRet;
}


USHORT
usGetNumTableDirEntries(
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Returns the number of TABLEDIR entries in the TrueType file.

  Arguments:

    pTTFile - Pointer to memory mapped TrueType file

  Return Value:

    Number of TABLEDIR entries.

--*/
{
    USHORT usNumTags;
    USHORT *pusFile;


    FTRC(Entering usGetNumTableDirEntries...);

    ASSERTMSG(pTTFile, ("usGetNumTableDirEntries!pTTFile NULL.\n"));

    pusFile = (USHORT*)pTTFile;
    if (bIsTrueTypeFileTTC(pTTFile))
    {
        usNumTags = *(pusFile + 12); // byte 24 in file
    }
    else
    {
        usNumTags = *(pusFile + 2); // Just after version (Fixed)
    }
    SWAB(usNumTags);

    FTRC(Leaving usGetNumTableDirEntries...);

    return usNumTags;
}


PTABLEDIR
pGetTableDirStart(
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Returns a pointer to the start of the TABLEDIR entries in the truetype file.

  Arguments:

    pTTFile - Pointer to memory mapped TrueType file

  Return Value:

    Pointer to TABLEDIR entries.

--*/
{
    BYTE *pStart;


    FTRC(Entering pGetTableDirStart...);

    ASSERTMSG(pTTFile, ("pGetTableDirStart!pTTFile NULL.\n"));

    if (bIsTrueTypeFileTTC(pTTFile))
    {
        pStart = (PBYTE)pTTFile + 32; // How should I calculate this?
    }
    else
    {
        pStart = (PBYTE)pTTFile + TRUE_TYPE_HEADER;
    }

    FTRC(Leaving pGetTableDirStart...);

    return (PTABLEDIR) pStart;
}


DWORD
dwDLTTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN TT_HEADER ttheader,
    IN USHORT usNumTags,
    IN PTABLEDIR pPCLTableDir,
    IN BYTE *PanoseNumber,
    IN BOOL bExistPCLTTable
    )
/*++

  Routine Description:

    Function to  retrieve build a new True Type header structure relative to
    the PCL file that is sent to the printer and also send the font data from
    the True Type file.

  Arguments:

    pPDev - Pointer to current PDev
    ttheader - TrueType header structure
    usNumTags - Number of tags found in TrueType file
    pPCLTableDir - Tags from TrueType file
    PanoseNumber - Panose number for this font
    bExistPCLTTable - True if PCLT table was present in TrueType file

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PVOID   pTTFile;
    BYTE   *pbTTFile;
    ULONG   ulTTFileLen;
    ULONG   ulOffset;
    ULONG  *pulOffset;
    ULONG  *pulLength;
    USHORT  us;
    DWORD   dwBytes;
    DWORD   dwTotalBytes;
    ULONG   ulTableLen = 0;
    USHORT  usCheckSum = 0;    //font header checkSum

    BOOL      bUse2Byte;       // True for format 16, false for format 15

    ATABLEDIR PCLtableDir; // Table directory sent to printer,PCL takes   8 table dirs
    ATABLEDIR TTtableDir;  // Temporary Buffer for PCL tables. Needed for
                                 // Calculating new field valued
    TRUETYPEHEADER trueTypeHeader;

    USHORT  usSegHeaderSize;   // Segment header size. Depends on format 15/16

    FONT_DATA  fontData[NUM_DIR_ENTRIES];    // There are eight PCL tables
    BYTE       abNumPadBytes[NUM_DIR_ENTRIES];         // Padding array, Contains num of bytes to be
                                  // padded for each table

    ULONG     ulGTSegSize;
    PTABLEDIR pEntry; // Pointer to dir entry, used for walking tables.


    FTRC(Entering dwDLTTInfo...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pPCLTableDir, ("dwDLTTInfo!pPCLTableDir NULL.\n"));
    ASSERTMSG(PanoseNumber, ("dwDLTTInfo!PanoseNumber NULL.\n"));

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM) ||
            !pPCLTableDir || !PanoseNumber)
            TOSS(ParameterError);

        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);
        if (!pTTFile)
            TOSS(DataError);

        bUse2Byte = (S_OK == IsFont2Byte(pFM));
        usSegHeaderSize = (bUse2Byte ? (sizeof(USHORT) + sizeof(ULONG)) :    // format 16
                                      (sizeof(USHORT) + sizeof(USHORT)));   // format 15
            // (bUse2Byte ? sizeof(UB_SEG_HEADER) : sizeof(SEG_HEADER));

        TERSE(("Downloading TrueType ID 0x%x, as %s.\n", pFM->ulDLIndex,
               (bUse2Byte ? "double-byte" : "single-byte")));

        ZeroMemory(&PCLtableDir, sizeof(PCLtableDir));
        ZeroMemory(&abNumPadBytes, sizeof(abNumPadBytes));

        //
        // Recalculate offsets starting after the end of the tabledir
        //
        ulOffset = TRUE_TYPE_HEADER + SIZEOF_TABLEDIR;

        memcpy (&TTtableDir, (BYTE *)pPCLTableDir, sizeof (TTtableDir));

        //
        // Build the True Type Header with information from the
        // True Type file.
        //
        vBuildTrueTypeHeader (pTTFile, &trueTypeHeader, usNumTags, bExistPCLTTable);

        //
        // Fill in the New Table Dir - which is sent to printer -
        // with the recalculated offsets.
        //
        for (pEntry = pPCLTableDir, us = 0; us < usNumTags; us++, pEntry++)
        {
            PCLtableDir[us].uTag = pEntry->uTag;

            //
            // GDIR is a contrived segment.  It needs to have len = ofs = 0.
            //
            if (!bTagCompare (PCLtableDir[us].uTag, TABLEGDIR))
            {
                PCLtableDir[us].uOffset = ulOffset;
            }

            if (pEntry->uLength % (sizeof (DWORD)) != 0)
            {
                pEntry->uLength += sizeof(DWORD) - (pEntry->uLength % (sizeof (DWORD)));
            }
            PCLtableDir[us].uLength = pEntry->uLength;

            ulOffset += pEntry->uLength;
            ulTableLen += pEntry->uLength;
        }

        //
        // Now send the actual font data from the True Type file.
        // Read in the offsets from the original table directory
        // and fetch the data at the offset in the True Type file.
        // Then dump it to the spooler file.
        //
        for (pEntry = pPCLTableDir, us = 0; us < usNumTags; us++, pEntry++)
        {
            pbTTFile = (BYTE *)pTTFile + pEntry->uOffset;

            fontData[us].ulOffset = TTtableDir[us].uOffset;

            fontData[us].ulLength = TTtableDir[us].uLength;

            //
            // Since the tables have  to be DWORD aligned, we make
            // the adjustments here. Pad to the next word with zeros.
            //
            if (TTtableDir[us].uLength != PCLtableDir[us].uLength)
            {
                abNumPadBytes[us] = (BYTE)(PCLtableDir[us].uLength - TTtableDir[us].uLength);
                PCLtableDir[us].uLength = TTtableDir[us].uLength;
            }


            PCLtableDir[us].uCheckSum = ulCalcTableCheckSum ((ULONG *)pbTTFile,
                                            pEntry->uLength);
            SWAL (PCLtableDir[us].uCheckSum);
            SWAL (PCLtableDir[us].uOffset);
            SWAL (PCLtableDir[us].uLength);
        }

        //
        // Calculate the total number of bytes being sent
        // and send it all to the printer.
        //
        dwBytes = dwTotalBytes = sizeof (TT_HEADER);
        dwTotalBytes += (DWORD) ulOffset;
        dwTotalBytes += (DWORD) LEN_PANOSE;
        dwTotalBytes += (DWORD) usSegHeaderSize; // sizeof (PanoseID);
        dwTotalBytes += (DWORD) usSegHeaderSize; // sizeof (SegHead);
        dwTotalBytes += (DWORD) usSegHeaderSize; // sizeof (NullSegment);
        if (bUse2Byte)
        {
            dwTotalBytes += (DWORD) sizeof(CC_SEGMENT); // sizeof (CCSegment);
            //dwTotalBytes += (DWORD) sizeof(CE_SEGMENT); // sizeof (CESegment);
            //dwTotalBytes += (DWORD) sizeof(GC_SEGMENT); // sizeof (GCSegment);
        }
        dwTotalBytes += sizeof(usCheckSum);      // ending checksum

        // make sure the font header is not too large for PCL5
        // JFF: Need to break up these segments if they are too large.
        if (dwTotalBytes > PCL_MAXHEADER_SIZE)
        {
            ERR(("dwDLTTInfo!PCL Header too large to download.\n"));
            TOSS(ParameterError);
        }

        //
        // This command is sent by the caller: {download.c,BDownLoadAsTT}
        //
        // bPCL_SetFontID(pPDev, pFM);

        bPCL_SendFontDCPT(pPDev, pFM, dwTotalBytes);

        if(!BWriteToSpoolBuf( pPDev, (BYTE *)&ttheader, (LONG)dwBytes ))
            TOSS(WriteError);

        usCheckSum = usCalcCheckSum ((BYTE*)&ttheader.wScaleFactor,
                                  sizeof (ttheader.wScaleFactor));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.sMasterUnderlinePosition,
                                   sizeof (ttheader.sMasterUnderlinePosition));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.usMasterUnderlineHeight,
                                   sizeof (ttheader.usMasterUnderlineHeight));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.bFontScaling,
                                   sizeof (ttheader.bFontScaling));

        usCheckSum += usCalcCheckSum ((BYTE*)&ttheader.bVariety,
                                   sizeof (ttheader.bVariety));

        if (bUse2Byte)
        {
            CC_SEGMENT CCSeg;
            CE_SEGMENT CESeg;
            GC_SEGMENT GCSeg;
            
#if 0
            //
            // Send the Chracter Enhancement Segment (Format 16 only)
            //
            CESeg.wSig = CE_SEG_SIGNATURE;
            CESeg.wSize = 0;
            CESeg.wSizeAlign = SWAPW(sizeof(CE_SEGMENT) - offsetof(CE_SEGMENT, wStyle));
            if (pFM->pIFIMet->fsSelection & FM_SEL_ITALIC)
            {
                CESeg.wStyle = 0x0;
                CESeg.wStyleAlign |= SWAPW(0x2); // Pseudo-italics
            }
            else
            {
                CESeg.wStyle = 0x0;
                CESeg.wStyleAlign = 0x0;
            }
            CESeg.wStrokeWeight = 0XFFFF; // ??? HP monolich does this.
            CESeg.wSizing = 0x0;
            if (!bOutputSegData(pPDev, (PBYTE)&CESeg, sizeof(CESeg), &usCheckSum))
                TOSS(WriteError);
#endif
            //
            // Send the Character Complement (Array of UBYTE)
            // Please see the detain about CC in sfttpcl.h.
            //
            CCSeg.wSig = CC_SEG_SIGNATURE;
            CCSeg.wSize = 0;
            CCSeg.wSizeAlign = SWAPW(sizeof(CCSeg) - offsetof(CC_SEGMENT, wCCNumber1));
            CCSeg.wCCNumber1 = 0;
            CCSeg.wCCNumber2 = SWAPW(0xFFFE);
            CCSeg.wCCNumber3 = 0;
            CCSeg.wCCNumber4 = SWAPW(0xFFFE);
            if (!bOutputSegData(pPDev, (PBYTE)&CCSeg, sizeof(CCSeg), &usCheckSum))
                TOSS(WriteError);

#if 0
            //
            // Galley Character Segment (Format 16 only)
            //
            GCSeg.wSig = GC_SEG_SIGNATURE;
            GCSeg.wSize = 0;
            GCSeg.wSizeAlign = SWAPW(sizeof(GCSeg) - offsetof(GC_SEGMENT, wFormat));
            GCSeg.wFormat = 0;
            GCSeg.wDefaultGalleyChar = 0xFFFF;
            GCSeg.wNumberOfRegions = SWAPW(1);
            GCSeg.RegionChar[0].wRegionUpperLeft = 0;
            GCSeg.RegionChar[0].wRegionLowerRight = 0xFFFE;
            GCSeg.RegionChar[0].wRegional = 0xFFFE;
            if (!bOutputSegData(pPDev, (PBYTE)&GCSeg, sizeof(GCSeg), &usCheckSum))
                TOSS(WriteError);
#endif
        }

        //
        // Send the Panose structure. This include a 2 bytes tag "PA",
        // the size of the Panose Number, and the Panose number.
        //
        if (!bOutputSegment(pPDev, pFM, PANOSE_TAG, PanoseNumber, LEN_PANOSE, &usCheckSum))
            TOSS(WriteError);

        //
        // Send GlobalTrueType data "GT"
        //

        // First calculate the segment size--this is independent of format 15/16
        //ul = sizeof (TRUETYPEHEADER) + ((usNumTags ) * sizeof (TABLEDIR));
        //
        // usNumTags can be 7 or 8, but we always write out 8 entries even when the
        // last one is all zeroes. Therefore usNumTags should *not* be taken into
        // account in this computation. JFF
        //
        ulGTSegSize = sizeof (TRUETYPEHEADER) + (SIZEOF_TABLEDIR);
        ulGTSegSize += ulTableLen;

        if (!bOutputSegHeader(pPDev, pFM, SEG_TAG, ulGTSegSize, &usCheckSum))
            TOSS(WriteError);

        //
        // Send the True Type Header
        //
        if (!bOutputSegData(pPDev, (BYTE*)&trueTypeHeader, TRUE_TYPE_HEADER, &usCheckSum))
            TOSS(WriteError);

        //
        // Send the True Type table directory and the font data.
        //
        if (!bOutputSegData(pPDev, (BYTE*)PCLtableDir, SIZEOF_TABLEDIR, &usCheckSum))
            TOSS(WriteError);

        if (!bSendFontData(pPDev, fontData, usNumTags, abNumPadBytes, &usCheckSum))
            TOSS(WriteError);

        //
        // Send the null segment to indicate the end of segment data
        //
        if (!bOutputSegHeader(pPDev, pFM, Null_TAG, 0, &usCheckSum))
            TOSS(WriteError);

        usCheckSum = 256 - (usCheckSum % 256);
        SWAB (usCheckSum);

        // Don't bother with checksum calculations since we're *sending* it.
        if (!bOutputSegData(pPDev, (BYTE *)&usCheckSum, sizeof (usCheckSum), NULL))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        // Return 0 to show that the header wasn't correctly downloaded.
        dwTotalBytes = 0;
    }
    CATCH(WriteError)
    {
        // Return 0 to show that the header wasn't correctly downloaded.
        dwTotalBytes = 0;
    }
    CATCH(DataError)
    {
        // Return 0 to show that the header wasn't correctly downloaded.
        dwTotalBytes = 0;
    }
    ENDTRY;

    if (dwTotalBytes == 0)
        ERR(("dwDLTTInfo!Font header not downloaded.\n"));
    FTRC(Leaving dwDLTTInfo...);

    return dwTotalBytes;
}

BOOL
bOutputSegment(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN BYTE *pbData,
    IN LONG ulSegSize,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Sends a segment header and data to the printer using bOutputSegHeader
    and bOutputSegData.  This is a handy shortcut for simple segments.

  Arguments:

    pPDev - Pointer to PDEV
    usSegId - Segment ID
    pbData - Segment Data
    ulSegSize - Amount of data (number of bytes pointed to by pbData)
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    BOOL bRet = FALSE;


    FTRC(Entering bOutputSegment...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pbData, ("bOutputSegment!pbData NULL.\n"));

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM) || !pbData)
            TOSS(ParameterError);

        if (!bOutputSegHeader(pPDev, pFM, usSegId, ulSegSize, pusCheckSum))
            TOSS(WriteError);

        if (!bOutputSegData(pPDev, pbData, ulSegSize, pusCheckSum))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bOutputSegment...);

    return bRet;
}


BOOL
bOutputSegHeader(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usSegId,
    IN ULONG ulSegSize,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Sends a segment header to the printer given the segment's id
    and size.  Handles format 15 or format 16.  Also continues to
    caclulate the checksum for data sent.

  Arguments:

    pPDev - Pointer to PDEV
    usSegId - Segment ID
    ulSegSize - Amount of data
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, FALSE if an error occurred.

--*/
{
    BOOL bUse2Byte = (S_OK == IsFont2Byte(pFM));
    BOOL bRet = TRUE;


    FTRC(Entering bOutputSegHeader...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        if (bUse2Byte)
        {
            // Segment id is already swapped. just swap the size
            SWAL(ulSegSize);

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&usSegId, sizeof(USHORT) ))
                TOSS(WriteError);

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&ulSegSize, sizeof(ULONG) ))
                TOSS(WriteError);

            if (pusCheckSum)
            {
                *pusCheckSum += usCalcCheckSum ((BYTE*)&usSegId, sizeof(USHORT));
                *pusCheckSum += usCalcCheckSum ((BYTE*)&ulSegSize, sizeof(ULONG));
            }
        }
        else
        {
            USHORT usSegSize = (USHORT) ulSegSize;
            SWAB(usSegSize);
            if (ulSegSize > MAX_USHORT)
                ERR(("bOutputSegHeader!Segment size too large.\n"));

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&usSegId, sizeof(USHORT) ))
                TOSS(WriteError);

            if(!BWriteToSpoolBuf( pPDev, (BYTE*)&usSegSize, sizeof(USHORT) ))
                TOSS(WriteError);

            if (pusCheckSum)
            {
                *pusCheckSum += usCalcCheckSum ((BYTE*)&usSegId, sizeof(USHORT));
                *pusCheckSum += usCalcCheckSum ((BYTE*)&usSegSize, sizeof(USHORT));
            }
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bOutputSegHeader...);

    return bRet;
}


BOOL
bOutputSegData(
    IN PDEV *pPDev,
    IN BYTE *pbData,
    IN LONG ulDataSize,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Sends segment data to the printer. Should be called after calling
    bOutputSegHeader.

  Arguments:

    pPDev - Pointer to PDEV
    usSegId - Segment ID
    ulSegSize - Amount of data
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, FALSE if an error occurred.

--*/
{
    BOOL bRet = FALSE;


    FTRC(Entering bOutputSegData...);

    ASSERT(VALID_PDEV(pPDev));

    TRY
    {
        TERSE(("Sending %d bytes of segment data.\n", ulDataSize));

        if (!VALID_PDEV(pPDev))
            TOSS(ParameterError);

        if(!BWriteToSpoolBuf( pPDev, pbData, ulDataSize ))
            TOSS(WriteError);

        if (pusCheckSum)
        {
            *pusCheckSum += usCalcCheckSum (pbData, ulDataSize);
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bOutputSegData...);

    return bRet;
}


BOOL
bSendFontData(
    IN PDEV *pPDev,
    IN FONT_DATA *aFontData,
    IN USHORT usNumTags,
    IN BYTE *abNumPadBytes,
    IN OUT USHORT *pusCheckSum
    )
/*++

  Routine Description:

    Function to retrieve the actual font information from the true type file
    and then send the data to the printer.

  Arguments:

    pPDev - Pointer to PDEV
    aFontData - Array specifing locations of font data to be sent
    usNumTags - Number of tables to be sent
    abNumPadBytes - Number of bytes to pad for each table
    pusCheckSum - Checksum

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PVOID   pTTFile;
    BYTE   *pbTTFile;
    ULONG   ulTTFileLen;
    BYTE    abZeroArray[MAX_PAD_BYTES];
    USHORT  usZeroArraySize;
    USHORT  us;
    BOOL    bRet = FALSE;


    FTRC(Entering bSendFontData...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(aFontData, ("bSendFontData!aFontData NULL.\n"));
    ASSERTMSG(abNumPadBytes, ("bSendFontData!abNumPadBytes NULL.\n"));
    ASSERTMSG(pusCheckSum, ("bSendFontData!pusCheckSum NULL.\n"));

    // Initialize 4 bytes of padding. The abNumPadBytes[] array describes how many to
    // use for each table
    usZeroArraySize = MAX_PAD_BYTES / sizeof(BYTE);
    ZeroMemory(abZeroArray, usZeroArraySize);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !aFontData ||
            !abNumPadBytes || !pusCheckSum)
            TOSS(ParameterError);

        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

        if (!pTTFile)
            TOSS(DataError);

        // Output each of the tables from the truetype file
        for (us = 0; us < usNumTags; us++)
        {
            pbTTFile = (BYTE *)pTTFile + aFontData[us].ulOffset;

            if (!bOutputSegData(pPDev, pbTTFile, aFontData[us].ulLength, pusCheckSum))
                TOSS(WriteError);

            // If necessary write out zeroes from the zero array to pad to the next boundary.
            if (abNumPadBytes[us] != 0)
            {
                ASSERT(abNumPadBytes[us] <= MAX_PAD_BYTES);

                if (!bOutputSegData(pPDev, abZeroArray, abNumPadBytes[us], pusCheckSum))
                    TOSS(WriteError);
            }
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    CATCH(DataError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bSendFontData...);

    return bRet;
}


DWORD
dwSendCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    IN USHORT usCharCode
    )
/*++

  Routine Description:

    Creates a character header for the true type glyph and sends
    it to the printer

  Arguments:

    pPDev - Pointer to PDEV
    hGlyph - Glyph handle
    usCharCode - Character code associated with glyph

  Return Value:

    Amount of memory used by the glyph.

--*/
{
    TTCH_HEADER  ttCharH;                // true type character header
    USHORT       usCheckSum = 0;
    USHORT       usGlyphLen;            // number of bytes in glyph
    BYTE        *pbGlyphMem;            // location of glyph in tt file
    DWORD        dwTotal;               // Total number of bytes to send
    DWORD        dwSend;                // If size > 32767; send in chunks
    DWORD        dwBytesSent;           // Number of bytes actually sent


    FTRC(Entering dwSendCharacter...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        if (pbGlyphMem == NULL)
            TOSS(DataError);

        ttCharH.bFormat = PCL_FM_TT;
        ttCharH.bContinuation = 0;
        ttCharH.bDescSize = 2;
        ttCharH.bClass = PCL_FM_TT;
        ttCharH.wCharDataSize = usGlyphLen + 2 * sizeof (USHORT);
        ttCharH.wGlyphID = (WORD)hGlyph;

        SWAB (ttCharH.wGlyphID);
        SWAB (ttCharH.wCharDataSize);

        dwTotal = sizeof (ttCharH) + usGlyphLen + sizeof (usCheckSum);

        //
        // Presume that data is less than the maximum, and so can be
        // sent in one hit.  Then loop on any remaining data.
        //

        dwSend = min( dwTotal, 32767 );

        //
        // send the character header and glyph data to the printer
        //
        bPCL_SetCharCode(pPDev, pFM, usCharCode);

        bPCL_SendCharDCPT(pPDev, pFM, dwSend);

        if(!BWriteToSpoolBuf( pPDev, (BYTE *)&ttCharH, sizeof( ttCharH )))
            TOSS(WriteError);

        // Send the actual TT Glyph data
        if(!BWriteToSpoolBuf( pPDev, pbGlyphMem, usGlyphLen ))
            TOSS(WriteError);

        usCheckSum = usCalcCheckSum ((BYTE *)&ttCharH.wCharDataSize,
                                     sizeof (ttCharH.wCharDataSize));

        usCheckSum += usCalcCheckSum ((BYTE *)&ttCharH.wGlyphID,
                                      sizeof (ttCharH.wGlyphID));

        usCheckSum += usCalcCheckSum (pbGlyphMem, usGlyphLen);

        usCheckSum = (~usCheckSum + 1) & 0x00ff;
        SWAB (usCheckSum);

        if(!BWriteToSpoolBuf( pPDev, (BYTE *)&usCheckSum, sizeof (usCheckSum)))
            TOSS(WriteError);

        dwBytesSent = dwSend;

        //   Sent some,  so reduce byte count to compensate
        dwSend -= sizeof( ttCharH );
        dwTotal -= sizeof( ttCharH );

        dwTotal -= dwSend;                   // Adjust for about to send data

        if( dwTotal > 0 )
        {
            ERR(("dwSendCharacter!Glyph data too large; need loop.\n"));
            TOSS(WriteError);
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        // Set to zero to indicate that glyph wasn't sent.
        dwBytesSent = 0;
    }
    CATCH(WriteError)
    {
        // Set to zero to indicate that glyph wasn't sent.
        ERR(("dwSendCharacter!Write error. Glyph not downloaded.\n"));
        dwBytesSent = 0;
    }
    CATCH(DataError)
    {
        dwBytesSent = 0;
    }
    ENDTRY;

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving dwSendCharacter...);

    return dwBytesSent;
}


DWORD
dwSendCompoundCharacter(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph
    )
/*++

  Routine Description:

    Finds the additional glyph information for a complex glyph
    and ends the gylph data to the printer using the character
    select code of -1.

  Arguments:

    pPDEV - Pointer to PDEV
    hGlyph - Glyph handle

  Return Value:

    Number of bytes sent to the device

--*/
{
    USHORT   usGlyphLen;        // number of bytes in glyph
    BYTE    *pbGlyphMem;           // location of glyph in tt file
    USHORT   usFlag;
    SHORT   *psGlyphDescMem;
    USHORT  *pusGlyphId;
    GLYPH_DATA_HEADER  glyphData;
    DWORD    dwBytesSent;


    FTRC(Entering dwSendCompoundCharacter...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    VERIFY_VALID_FONTFILE(pPDev);

    TRY
    {
        pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        if (pbGlyphMem == NULL)
            TOSS(DataError);

        memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));
        psGlyphDescMem = (SHORT*)(pbGlyphMem + sizeof (glyphData));
        dwBytesSent = 0;

        do {
            //
            // Get the glyph flag
            //
            usFlag = *((USHORT*)psGlyphDescMem);
            SWAB (usFlag);
            psGlyphDescMem++;

            //
            // Get the glyph id
            //
            pusGlyphId = (USHORT*)psGlyphDescMem;
            psGlyphDescMem++;

            //
            // Skip over args
            //
            if (usFlag & ARG_1_AND_2_ARE_WORDS)
            {
                psGlyphDescMem += 2;
            }
            else
            {
                psGlyphDescMem++;
            }

            //
            // Skip over scale
            //
            if (usFlag & WE_HAVE_A_TWO_BY_TWO)
            {
                psGlyphDescMem += 4;
            }
            else if (usFlag & WE_HAVE_AN_X_AND_Y_SCALE)
            {
                psGlyphDescMem += 2;
            }
            else if (usFlag & WE_HAVE_A_SCALE)
            {
                psGlyphDescMem++;
            }

            //
            // Now send the glyph
            //
            hGlyph = *pusGlyphId;
            SWAB (hGlyph);
            dwBytesSent += dwSendCharacter(pPDev, pFM, hGlyph, 0xffff);
        } while (usFlag & MORE_COMPONENTS);
    }
    CATCH(DataError)
    {
        //
        // Flag the error by returning zero.
        //
        dwBytesSent = 0;
    }
    ENDTRY;

    VERIFY_VALID_FONTFILE(pPDev);

    FTRC(Leaving dwSendCompoundCharacter...);

    return dwBytesSent;
}


PBYTE
pbGetGlyphInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HGLYPH hGlyph,
    OUT USHORT *pusGlyphLen
    )
/*++

  Routine Description:

    Function to get the glyph data for a particular glyph.
    The glyph id is passed in as a parameter and the
    glyph data is kept in the loca table in the True Type file.

  Arguments:

    hGlyph - Glyph handle
    pPDev - Pointer to PDEV
    ppbGlyphMem - Pointer to a pointer which will be directed to the glyph data

  Return Value:

    The number of bytes in the Glyph data table.

--*/
{
    ULONG  ulGlyphTable;
    ULONG  ulLength;
    ULONG  ulLocaTable;
    PVOID  pTTFile;
    PBYTE  pbTTFile;
    PBYTE  pbGlyphMem;
    ULONG  ulTTFileLen;

    ULONG  ul;
    FONTMAP_TTO *pPrivateFM;
    PFONTPDEV pFontPDev = pPDev->pFontPDev;


    FTRC(Entering pbGetGlyphInfo...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pusGlyphLen, ("pbGetGlyphInfo!pusGlyphLen NULL.\n"));

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        pPrivateFM = GETPRIVATEFM(pFM);
        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

        if ((!pTTFile) || (ulTTFileLen == 0))
            TOSS(DataError);

        // JFF: What is the best thing to do here?
        if (hGlyph == INVALID_GLYPH)
            TOSS(InvalidGlyph);

        ulGlyphTable = pPrivateFM->ulGlyphTable;
        ulLength = pPrivateFM->ulGlyphTabLength;
        pbTTFile = (BYTE *)pTTFile;
        ulLocaTable = pPrivateFM->ulLocaTable;

        pbTTFile += ulLocaTable;

        //
        // Before accessing pbTTFile, make sure that the pointer is valid.
        //
        if (pbTTFile > ((BYTE *)pTTFile + ulTTFileLen))
            TOSS(DataError);

        if (pPrivateFM->sIndexToLoc == SHORT_OFFSET)
        {
            USHORT  *pusOffset;
            USHORT   ui;
            USHORT   uj;

            pusOffset = (USHORT *) pbTTFile + hGlyph;

            ui = pusOffset[0];
            SWAB (ui);
            uj = pusOffset[1];

            *pusGlyphLen = (SWAB (uj) - ui) << 1;
            ul = ui;
            pbGlyphMem = (BYTE *)((BYTE *)pTTFile + ulGlyphTable) + (ul << 1);

            if (!PTR_IN_RANGE(pTTFile, ulTTFileLen, pbGlyphMem + *pusGlyphLen - 1))
                TOSS(DataError);

        }
        else     // LONG_OFFSET
        {
            ULONG   *pulOffset,
                     uj;

            pulOffset = (ULONG *) pbTTFile + hGlyph;

            ul = pulOffset[0];
            SWAL (ul);
            uj = pulOffset[1];
            *pusGlyphLen = (USHORT)(SWAL (uj) - ul);
            pbGlyphMem = (BYTE *)((BYTE *)pTTFile + ulGlyphTable) + ul;

            if (!PTR_IN_RANGE(pTTFile, ulTTFileLen, pbGlyphMem + *pusGlyphLen - 1))
                TOSS(DataError);

        }
        //
        // add check here to make sure pbGlyphMem <= pTTFile + size of file
        //
        if (pbGlyphMem > ((BYTE *)pTTFile + ulTTFileLen))
            TOSS(DataError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        *pusGlyphLen = 0;
        pbGlyphMem = NULL;
    }
    CATCH(DataError)
    {
        *pusGlyphLen = 0;
        pbGlyphMem = NULL;
    }
    CATCH(InvalidGlyph)
    {
        ERR(("pbGetGlyphInfo!Invalid glyph handle given.\n"));
        *pusGlyphLen = 0;
        pbGlyphMem = NULL;
    }
    ENDTRY;

    FTRC(Leaving pbGetGlyphInfo...);

    return pbGlyphMem;
}


BOOL
bReadInTable(
    IN PVOID pTTFile,
    IN PTABLEDIR pTableDir,
    IN char *szTag,
    OUT PVOID pvTable,
    IN LONG lSize
    )
/*++

  Routine Description:

    Finds the table in the truetype file that matches the given tag and copies
    the data into the given pointer.

  Arguments:

    pTTFile - Memory mapped truetype file
    pvTableDir - Index of table locations and sizes
    tag - Tag of desired table
    pvTable - buffer to place table data in
    lSize - size of pvTable structure

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PTABLEDIR pEntry;
    BYTE     *pbSrcTable;
    BOOL      bRet = FALSE;


    FTRC(Entering bReadInTable...);

    ASSERTMSG(pTTFile, ("bReadInTable!pTTFile NULL.\n"));
    ASSERTMSG(pTableDir, ("bReadInTable!pTableDir NULL.\n"));
    ASSERTMSG(szTag, ("bReadInTable!szTag NULL.\n"));
    ASSERTMSG(pvTable, ("bReadInTable!pvTable NULL.\n"));
    //
    // Locate the desired table in the truetype file.
    // If it is found copy the table bits to the desired
    // location.
    //
    pbSrcTable = pbGetTableMem(szTag, pTableDir, pTTFile);

    if (pbSrcTable)
    {
        memcpy((BYTE*)pvTable, pbSrcTable, lSize);
        bRet = TRUE;
    }
    else
    {
        ERR(("bReadInTable!Unable to locate tag: '%s'.\n", szTag));
        bRet = FALSE;
    }

    FTRC(Leaving bReadInTable...);

        return bRet;
}


ULONG
ulCalcTableCheckSum(
    IN ULONG *pulTable,
    IN ULONG ulLength
    )
/*++

  Routine Description:

    Calculates checksum for the given table.

  Arguments:

    pulTable - pointer to table data
    ulLength - number of bytes in table

  Return Value:

    Checksum value.

--*/
{
    ULONG  ulSum = 0L;
    ULONG  ulNumFields = (ULONG)(((ulLength + 3) & ~3) / sizeof(ULONG));
    ULONG  ul;


    FTRC(Entering ulCalcTableCheckSum...);

    ASSERTMSG(pulTable, ("ulCalcTableCheckSum!pulTable NULL.\n"));

    for(ul = 0; ul < ulNumFields; ul++)
    {
        ULONG ulTemp = *pulTable;
        SWAL(ulTemp);
        ulSum += ulTemp;
        pulTable++;
    }

    FTRC(Leaving ulCalcTableCheckSum...);

    return (ulSum);
}


void
vBuildTrueTypeHeader(
    IN PVOID pTTFile,
    OUT TRUETYPEHEADER *trueTypeHeader,
    IN USHORT usNumTags,
    IN BOOL bExistPCLTTable
    )
/*++

  Routine Description:

    Fills truetype header structure with the correct information.

  Arguments:

    pTTFile - memory mapped truetype file
    pTrueTypeHeader - header structure to be filled
    usNumTags - number of tables found in TT file
    bExistPCLTTable - whether PCLT table was present

  Return Value:

    None.

--*/
{
    int num;
    int i;


    FTRC(Entering vBuildTrueTypeHeader...);

    ASSERTMSG(pTTFile, ("vBuildTrueTypeHeader!pTTFile NULL.\n"));
    ASSERTMSG(trueTypeHeader, ("vBuildTrueTypeHeader!trueTypeHeader NULL.\n"));

    memcpy (&trueTypeHeader->version, pTTFile, sizeof (trueTypeHeader->version));
    if (!bExistPCLTTable)
        usNumTags = 8;

    trueTypeHeader->numTables = usNumTags;
    num = usNumTags << 4;
    i = 15;
    while ( (i > 0) && (! (num & 0x8000)) )
    {
        num = num << 1;
        i--;
    }
    num = 1 << i;
    trueTypeHeader->searchRange = (USHORT)num;

    num =  usNumTags;
    i = 15;
    while ( (i > 0) && (! (num & 0x8000)) )
    {
        num = num << 1;
        i--;
    }
    trueTypeHeader->entrySelector = (USHORT)i;

    num = (usNumTags << 4) - trueTypeHeader->searchRange;
    trueTypeHeader->rangeShift = (USHORT)num;

    SWAB (trueTypeHeader->searchRange);
    SWAB (trueTypeHeader->numTables);
    SWAB (trueTypeHeader->entrySelector);
    SWAB (trueTypeHeader->rangeShift);

    FTRC(Leaving vBuildTrueTypeHeader...);
}


USHORT
usCalcCheckSum(
    IN BYTE *pbData,
    IN ULONG ulLength
    )
/*++

  Routine Description:

    Calculates the checksum for a buffer

  Arguments:

    pbData - data
    ulLength - amount of data

  Return Value:

    Checksum

--*/
{
    ULONG  ul;
    USHORT usSum = 0;


    FTRC(Entering usCalcCheckSum...);

    ASSERTMSG(pbData, ("usCalcCheckSum!pbData NULL.\n"));

    for (ul = 0; ul < ulLength; ul++)
    {
        usSum += (USHORT)*pbData;
        pbData++;
    }

    FTRC(Leaving usCalcCheckSum...);

    return (usSum);
}


void
vGetFontName(
    IN PDEV *pPDev,
    IN IFIMETRICS *pIFI,
    OUT char *szFontName,
    IN size_t cchFontName
    )
/*++

  Routine Description:

    Retrieves the fontname from the name table.

  Arguments:

    pPDev - pointer to PDEV
    PCLFontName - name of font
    pUnicodeFontName - The name as stored in the TT file
    StringLen - length of font name

  Return Value:

    None.

--*/
{
    PWSTR wszUniFaceName;
    ULONG ulUniFaceNameLen;

    char abMultiByteStr[(LEN_FONTNAME + 1) * 2];
    ULONG ulMultiByteStrLen;
    ULONG ulBytesUsed;


    FTRC(Entering vGetFontName...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(szFontName, ("vGetFontName!szFontName NULL.\n"));

    // Retrieve the name from the IFI metrics
    wszUniFaceName = (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName);
    ulUniFaceNameLen = min(wcslen(wszUniFaceName), LEN_FONTNAME) * 2;

    // Copy and convert unicode to a (multibyte?) string.
    EngUnicodeToMultiByteN(abMultiByteStr, ulUniFaceNameLen, &ulBytesUsed,
                           wszUniFaceName, ulUniFaceNameLen);
    ulBytesUsed = min(ulBytesUsed, LEN_FONTNAME-1);
    abMultiByteStr[ulBytesUsed] = '\0';

    // Transfer at most LEN_FONTNAME chars to the destination.
    StringCchCopyA ( szFontName, cchFontName, abMultiByteStr);

    FTRC(Leaving vGetFontName...);
}


USHORT
usGetDefStyle(
    IN USHORT usWidthClass,
    IN USHORT usMacStyle,
    IN USHORT flSelFlags
    )
/*++

  Routine Description:

    Fills in style.

  Arguments:

    usWidthClass -
    usMacStyle -

  Return Value:

    Default style bits

--*/
{
    USHORT usStyle;
    USHORT usModifier;
    const USHORT usStyleTable[] = { 0, 4, 2, 1, 1, 0, 6, 6, 7, 7 };
    const USHORT usStyleTableLen = sizeof(usStyleTable) /
                                   sizeof(usStyleTable[0]);

        FTRC(Entering usGetDefStyle...);

    usStyle = DEF_STYLE;
    SWAB (usWidthClass);

    // Default value
    //
    usModifier = 0;

    // If possible translate width class to style information using table
    //
    if ((usWidthClass >= 0) && (usWidthClass < usStyleTableLen))
    {
        usModifier = usStyleTable[usWidthClass];
    }

    // Adjust the style with the modifier we just looked up
    //
    usModifier = usModifier << 2;
    usStyle |= usModifier;

    // Apply the mac style too
    usModifier = (usMacStyle >> 1) & 0x0001;
    usStyle |= usModifier;

    // Set the posture bits: 0: Upright, 1: Italic,
    //                       2: Alternate Italic, 3: Reserved
    // Note: I'm selecting 2 for Bold/Italic.
    if (flSelFlags & FM_SEL_ITALIC)
    {
        usModifier = ((flSelFlags & FM_SEL_BOLD) ? 0x0002 : 0x0001);
        usStyle |= usModifier;
    }

    FTRC(Leaving usGetDefStyle...);

    return usStyle;
}


SBYTE
sbGetDefStrokeWeight(
    IN USHORT WeightClass,
    IN USHORT macStyle
    )
/*++

  Routine Description:

    Calculates the stroke weight of the font.

  Arguments:

    WeightClass -
    macStyle -

  Return Value:

    The stroke weight of the font

--*/
{
    SBYTE sbStrokeWeight;
    SBYTE sbModifier;


        FTRC(Entering sbGetDefStrokeWeight...);

    sbStrokeWeight = DEF_STROKEWEIGHT;
    sbModifier = WeightClass / 100;
    if (WeightClass >= 400)
        sbStrokeWeight = sbModifier - 4;
    else
        sbStrokeWeight = sbModifier - 6;

    FTRC(Leaving sbGetDefStrokeWeight...);

    return sbStrokeWeight;
}


void
vGetHmtxInfo(
    OUT BYTE *hmtxTable,
    IN USHORT glyphId,
    IN USHORT numberOfHMetrics,
    IN HMTX_INFO *hmtxInfo
    )
/*++

  Routine Description:

    Fills in hmtxInfo.

  Arguments:

    hmtxTable -
    glyphId -
    numberOfHMetrics -
    hmtxInfo -

  Return Value:

    None.

--*/
{
    HORIZONTALMETRICS   *longHorMetric;
    uFWord               advanceWidth;


    FTRC(Entering vGetHmtxInfo...);

    ASSERTMSG(hmtxTable, ("vGetHmtxInfo!hmtxTable NULL.\n"));
    ASSERTMSG(hmtxInfo, ("vGetHmtxInfo!hmtxInfo NULL.\n"));

    if (hmtxInfo == NULL)
    {
        //
        // Error exit
        //
        return;
    }

    longHorMetric = ((HMTXTABLE *)hmtxTable)->longHorMetric;

    if (longHorMetric == NULL)
    {
        //
        // Error exit
        //
        hmtxInfo->advanceWidth = 0;
    }
    else
    {
        if (glyphId < numberOfHMetrics)
        {
            advanceWidth = longHorMetric[glyphId].advanceWidth;
            hmtxInfo->advanceWidth = SWAB(advanceWidth);
        }
        else
        {
            advanceWidth = longHorMetric[numberOfHMetrics-1].advanceWidth;
            hmtxInfo->advanceWidth = SWAB(advanceWidth);
        }
    }

    FTRC(Leaving vGetHmtxInfo...);
}


BYTE *
pbGetTableMem(
    IN char *szTag,
    IN PTABLEDIR pTableDir,
    IN PVOID pTTFile
    )
/*++

  Routine Description:

    Function to find the location of a specific table in the true type file.

  Arguments:

    tag -
    tableDir -
    pTTFile -

  Return Value:

    A Pointer to the beginning of the table in the true type file.

--*/
{
    PTABLEDIR pEntry;
    BYTE     *pRet = NULL;


    FTRC(Entering pbGetTableMem...);

    ASSERTMSG(szTag, ("pbGetTableMem!szTag NULL.\n"));
    ASSERTMSG(pTableDir, ("pbGetTableMem!pTableDir NULL.\n"));
    ASSERTMSG(pTTFile, ("pbGetTableMem!pTTFile NULL.\n"));
    //
    // Locate the tag in the directory entry array.  Return FALSE
    // if the entry cannot be located.
    //
    pEntry = pFindTag(pTableDir, NUM_DIR_ENTRIES, szTag);

    if (pEntry)
    {
        pRet = ((BYTE *)pTTFile + pEntry->uOffset);
    }
    else
    {
        ERR(("pbGetTableMem!Unable to find entry '%s'.\n", szTag));
        pRet = NULL;
    }

    //
    // Found the directory for the table. Now need to
    // read the actual bits at the offset specified in
    // the table directory.
    //
    FTRC(Leaving pbGetTableMem...);

    return pRet;
}


USHORT
usGetXHeight(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Calculates the XHeight for the font. This is only called for
    fonts that do not have a PCLT table.

  Arguments:

    pPDev -

  Return Value:

    The XHeight.

--*/
{
    HGLYPH hGlyph;
    USHORT usHeight;


    FTRC(Entering usGetXHeight...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

#ifdef COMMENTEDOUT
    hGlyph = hFindGlyphId (pPDev, pFM, x_UNICODE);
    if (hGlyph != INVALID_GLYPH)
    {
        USHORT            usGlyphLen;    // number of bytes in glyph
        BYTE             *pbGlyphMem;    // location of glyph in tt file
        GLYPH_DATA_HEADER glyphData;

        phGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
        memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));

        usHeight = glyphData.yMax;
    }
    else
    {
        usHeight = DEF_XHEIGHT;
    }
#else
    usHeight = DEF_XHEIGHT;
#endif

    FTRC(Leaving usGetXHeight...);

    return usHeight;
}


USHORT
usGetCapHeight(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Calculates the CapHeight for the font.  This is only called when the
    font does not have a PCLT table.

    This function has two versions.  The newer version--which is commented out--
    and the older version below it.  This is because the newer version is not
    'tried and true' and we want less turmoil at this time.

  Arguments:

    pPDev -

  Return Value:

    The cap hight.

--*/
#ifdef COMMENTEDOUT
{
    //
    // Nominally we would get the height for glyph #43.  After all, that's what
    // the 95 driver does, so it must be right.  However, in some cases the
    // entire glyph set is not present (such as embedded TTF in PDF files) and
    // we will punt.  The first punt, in my opinion, is to try other glyphs which
    // are probably capital letters.  Let's suppose that 43 is supposed to be 'M'.
    // Then the next 12 glyphs should be capitals too.  If that fails
    //
    const HGLYPH kEmGlyph = 43;
    const HGLYPH kStartGlyph = (kEmGlyph - 12);
    const HGLYPH kEndGlyph = (kStartGlyph + 25);

    typedef struct tagGLYPH_RANGE
    {
        HGLYPH start;
        HGLYPH end;
    } GLYPH_RANGE;

    const GLYPH_RANGE aGlyphRange[] = {
        { kEmGlyph, kEndGlyph },
        { kStartGlyph, kEmGlyph - 1 }
    };
    const int kNumGlyphRanges = sizeof aGlyphRange / sizeof aGlyphRange[0];

    USHORT      usGlyphLen;         // number of bytes in glyph
    BYTE       *pbGlyphMem;         // location of glyph in tt file
    HGLYPH      hGlyph;
    GLYPH_DATA_HEADER  glyphData;
    int         i;


    FTRC(Entering usGetCapHeight...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    for (i = 0; i < kNumGlyphRanges; i++)
    {
        for (hGlyph = aGlyphRange[i].start; hGlyph <= aGlyphRange[i].end; hGlyph++)
        {
            pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
            if (pbGlyphMem != NULL)
            {
                memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));
                FTRC(Leaving usGetCapHeight...);
                return glyphData.yMax;
            }
        }
    }

    FTRC(Leaving usGetCapHeight...);

    return DEF_CAPHEIGHT;
}
#else
{
    USHORT            usGlyphLen;         // number of bytes in glyph
    BYTE             *pbGlyphMem;         // location of glyph in tt file
    HGLYPH            hGlyph;             // Glyph handle
    GLYPH_DATA_HEADER glyphData;          // Glyph data structure
    USHORT            usCapHeight;        // The glyph cap height


    FTRC(Entering usGetCapHeight...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // Windows 95 driver uses 43 so we will too.  Probably 'M'.
    hGlyph = 43;

    pbGlyphMem = pbGetGlyphInfo(pPDev, pFM, hGlyph, &usGlyphLen);
    if (pbGlyphMem != NULL)
    {
        memcpy (&glyphData, pbGlyphMem, sizeof (glyphData));
        usCapHeight = glyphData.yMax;
    }
    else
    {
        usCapHeight = DEF_CAPHEIGHT;
    }

    FTRC(Leaving usGetCapHeight...);

    return usCapHeight;
}
#endif

USHORT
usGetDefPitch(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
    )
/*++

  Routine Description:

    Calculates the pitch for the font.  Uses the htmx table to get the
    inormation.  This is only called for fonts that have no PCLT table.

  Arguments:

    pPDev -
    pFM -
    hheaTable -
    pTableDir -

  Return Value:

    Pitch or zero if failure.

--*/
{
    HMTX_INFO    HmtxInfo;
    USHORT       glyphId;
    BYTE        *hmtxTable;
    PVOID        pTTFile;
    FONTMAP_TTO *pPrivateFM;
    USHORT       usPitch;


    FTRC(Entering usGetDefPitch...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pTableDir, ("usGetDefPitch!pTableDir NULL.\n"));

    pPrivateFM = GETPRIVATEFM(pFM);
    pTTFile = pvGetTrueTypeFontFile(pPDev, 0);

    if (!pTTFile)
        return 0;

    if (NULL == (hmtxTable = pbGetTableMem (TABLEHMTX, pTableDir, pTTFile)))
    {
        return 0;
    }

    // pick a typical glyph to use - Windows 95 driver uses 3
    glyphId = 3;
    vGetHmtxInfo (hmtxTable, glyphId, hheaTable.numberOfHMetrics,
                 &HmtxInfo);

    usPitch = HmtxInfo.advanceWidth;
    SWAB(usPitch);

    FTRC(Leaving usGetDefPitch...);

    return usPitch;
}


void
vGetPCLTInfo(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    OUT TT_HEADER *ttheader,
    IN PCLT_TABLE pcltTable,
    IN BOOL bExistPCLTTable,
    IN OS2_TABLE OS2Table,
    IN HEAD_TABLE headTable,
    IN POST_TABLE postTable,
    IN HHEA_TABLE hheaTable,
    IN PTABLEDIR pTableDir
    )
/*++

  Routine Description:

    Fills in the TrueType header with information from the PCLT table in the
    TrueType file.  If the PCLT table dos not exist (it's optional), then a good
    set of defaults are used.  The defaults come from the Windows 95 driver.

    ISSUE: These structures are being passed on the stack!

  Arguments:

    pPDev -
    ttheader -
    pcltTable -
    bExistPCLTTable -
    OS2Table -
    headTable -
    postTable -
    hheaTable -
    pTableDir -

  Return Value:

    None.

--*/
{
    FTRC(Entering vGetPCLTInfo...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(ttheader, ("vGetPCLTInfo!ttheader NULL.\n"));
    ASSERTMSG(pTableDir, ("vGetPCLTInfo!pTableDir NULL.\n"));

    SWAL (pcltTable.Version);

    //
    // If there is a PCLT table and it's version is
    // later than 1.0, we can use it.
    //
    if (bExistPCLTTable && (pcltTable.Version >= 0x10000L))
    {
        SWAB (pcltTable.Style);
        ttheader->bStyleMSB = (BYTE)(pcltTable.Style >> 8);
        ttheader->wSymSet = pcltTable.SymbolSet;

        ttheader->wPitch = pcltTable.Pitch;
        ttheader->wXHeight = pcltTable.xHeight;

        ttheader->sbWidthType = pcltTable.WidthType;
        ttheader->bStyleLSB = (BYTE)pcltTable.Style & 0x0ff;

        ttheader->sbStrokeWeight = pcltTable.StrokeWeight;

        ttheader->usCapHeight = pcltTable.CapHeight;
        ttheader->ulFontNum = pcltTable.FontNumber;

        ttheader->bTypefaceLSB = (BYTE) ((pcltTable.TypeFamily & 0xff00) >> 8);
        ttheader->bTypefaceMSB = (BYTE) pcltTable.TypeFamily & 0x00ff;

        ttheader->bSerifStyle =  pcltTable.SerifStyle;
    }
    else
    {
        USHORT usStyle;
        USHORT TypeFamily;
        BOOL   bRet;

        usStyle = usGetDefStyle (OS2Table.usWidthClass, headTable.macStyle,
                                 pFM->pIFIMet->fsSelection);

        ttheader->bStyleMSB = (BYTE)(usStyle >> 8);
        ttheader->bStyleLSB = (BYTE)(usStyle & 0x0ff);

        ttheader->ulFontNum = DEF_FONTNUMBER;
        ttheader->sbWidthType = DEF_WIDTHTYPE;
        ttheader->bSerifStyle =  DEF_SERIFSTYLE;
        TypeFamily = DEF_TYPEFACE;

        ttheader->bTypefaceLSB = (BYTE) (TypeFamily & 0x0ff);
        ttheader->bTypefaceMSB = (BYTE) (TypeFamily >> 8);

        ttheader->wSymSet = 0;

        ttheader->wPitch = usGetDefPitch(pPDev, pFM, hheaTable, pTableDir);

        ttheader->wXHeight = usGetXHeight (pPDev, pFM);

        ttheader->sbStrokeWeight = sbGetDefStrokeWeight (
                                        SWAB (OS2Table.usWeightClass),
                                        SWAB (headTable.macStyle) );

        ttheader->usCapHeight =  usGetCapHeight(pPDev, pFM);
    }

    FTRC(Leaving vGetPCLTInfo...);
}


BOOL
bCopyGlyphData(
    IN OUT PDEV *pPDev,
    IN PFONTMAP pFM,
    IN CMAP_TABLE cmapTable,
    IN PTABLEDIR pTableDir
    )
/*++

  Routine Description:

    Pull out information about the location of the cmap table in the TrueType
    file and store it into the FONTMAP structure.  We need this information in
    case we have to reconstruct the glyph list.

  Arguments:

    pPDev -
    cmapTable -
    pvTableDir -

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    FONTMAP_TTO *pPrivateFM;
    PTABLEDIR    pEntry;
    GLYPH_DATA  *pGlyphData;
    BOOL         bRet = FALSE;


    FTRC(Entering bCopyGlyphData...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);
    ASSERTMSG(pTableDir, ("bCopyGlyphData!pTableDir NULL.\n"));

    if (NULL == (pPrivateFM = GETPRIVATEFM(pFM)))
    {
        return FALSE;
    }
    
    pGlyphData = (GLYPH_DATA*)pPrivateFM->pvGlyphData;

    //
    // Locate CMAP table in the tabledir
    //
    pEntry = pFindTag(pTableDir, NUM_DIR_ENTRIES, TABLECMAP);

    //
    // Copy the glyph information from the CMAP table
    //
    if (pEntry)
    {
        pGlyphData->offset = pEntry->uOffset;
        pGlyphData->cmapTable.Version = cmapTable.Version;
        pGlyphData->cmapTable.nTables = cmapTable.nTables;
        memcpy(pGlyphData->cmapTable.encodingTable,
               cmapTable.encodingTable,
               sizeof(cmapTable.encodingTable));
        bRet = TRUE;
    }
    else
    {
        ERR(("bCopyGlyphData!Unable to find table '%s'.\n", TABLECMAP));
        bRet = FALSE;
    }

    FTRC(Leaving bCopyGlyphData...);

    return bRet;
}


HGLYPH
hFindGlyphId(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN USHORT usCharCode
    )
/*++

  Routine Description:

    Retrieves the glyph id from the cmap table given the character code for a
    glyph.

    Normally the TOSS/CATCH is for error handling.  However, in this routine
    some of the CATCH labels are for normal processing and have OK appended to
    them to demonstrate that it is not necessarily an error with they occur.

  Arguments:

    usCharCode -
    pPDev -

  Return Value:

    Glyph id if successful, else INVALID_GLYPH.

--*/
{
    int     iI;
    ULONG   ulOffset;
    BYTE   *pbTmp;
    USHORT  segCount;            // Number of segments in table
    USHORT  TTFileSegments;      // Number of segments actually parsed -
                                 // in case segCount is really large
    GLYPH_MAP_TABLE  mapTable;
    CMAP_TABLE       cmapTable;
    PIFIMETRICS      pIFIMet;
    PVOID            pTTFile;
    ULONG            ulTTFileLen;

    USHORT        *pGlyphIdArray;
    USHORT        *pRangeOffset;
    USHORT        startCode[MAX_SEGMENTS];
    USHORT        endCode[MAX_SEGMENTS];
    SHORT         idDelta[MAX_SEGMENTS];
    USHORT        idRangeOffset[MAX_SEGMENTS];
    USHORT        GlyphId;

    ULONG        ulTmp;
    int          iJ, iIndex = 0;
    USHORT       usMaxChar;
    BOOL         bFound = FALSE;
    FONTMAP_TTO *pPrivateFM;
    GLYPH_DATA  *pGlyphData;
    HGLYPH       hGlyph = INVALID_GLYPH;


    FTRC(Entering hFindGlyphId...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        pPrivateFM = GETPRIVATEFM(pFM);
        pGlyphData = (GLYPH_DATA*)pPrivateFM->pvGlyphData;
        ZeroMemory(&endCode, sizeof(endCode));

        pIFIMet = pFM->pIFIMet;
        pTTFile = pvGetTrueTypeFontFile(pPDev, &ulTTFileLen);

        if (!pTTFile)
            TOSS(DataError);

        usMaxChar = 0xffff;

        //
        // The cmap table contains the Character to Glyph Index mapping table.
        //
        ulOffset = pGlyphData->offset;
        pbTmp = pTTFile;

        //
        // Get the encoding format based on the format id
        // Windows uses Platform ID 3
        // Encoding ID = 1 means format 4
        //
        cmapTable = pGlyphData->cmapTable;
        SWAB (cmapTable.nTables);
        for (iI = 0; iI < cmapTable.nTables; iI++)
        {
            SWAB (cmapTable.encodingTable[iI].PlatformID);
            SWAB (cmapTable.encodingTable[iI].EncodingID);
            if (cmapTable.encodingTable[iI].PlatformID == PLATFORM_MS)
            {
                switch ( cmapTable.encodingTable[iI].EncodingID)
                {
                    case SYMBOL_FONT:    // Symbol font
                        SWAL (cmapTable.encodingTable[iI].offset);
                        ulOffset += cmapTable.encodingTable[iI].offset;
                        bFound = TRUE;
                        break;
                    case UNICODE_FONT:    // Unicode font
                        SWAL (cmapTable.encodingTable[iI].offset);
                        ulOffset += cmapTable.encodingTable[iI].offset;
                        bFound = TRUE;
                        break;
                    default:   // error - can't handle
                        TOSS(GlyphNotFound);
                }
            }

        }
        if (!bFound)
            TOSS(GlyphNotFound);

        pbTmp += ulOffset;
        if (!PTR_IN_RANGE(pTTFile, ulTTFileLen, pbTmp))
            TOSS(DataError);

        memcpy (&ulTmp, pbTmp, sizeof (ULONG));
        ulTmp = (0x0000ff00 & ulTmp) >> 8;

        switch (ulTmp)
        {
            case 4:
                memcpy (&mapTable, pbTmp, sizeof (mapTable));
                SWAB (mapTable.SegCountx2 );
                segCount = mapTable.SegCountx2 / 2;
                TTFileSegments = segCount;

                if (segCount > MAX_SEGMENTS)
                    segCount = MAX_SEGMENTS;

                pbTmp += 7 * sizeof (USHORT);
                memcpy (&endCode, pbTmp, segCount*sizeof(USHORT));

                pbTmp += ((TTFileSegments +1) * sizeof (USHORT));
                memcpy (&startCode, pbTmp, segCount*sizeof(USHORT));

                pbTmp += (TTFileSegments * sizeof (USHORT));
                memcpy (&idDelta, pbTmp, segCount*sizeof(USHORT));

                pbTmp += (TTFileSegments * sizeof (USHORT));
                memcpy (&idRangeOffset, pbTmp, segCount*sizeof(USHORT));
                pRangeOffset = (USHORT*)pbTmp;

                pbTmp += (TTFileSegments * sizeof (USHORT));

                pGlyphIdArray = (USHORT*)pbTmp;

                for (iI = 0; iI < segCount-1; iI++)
                {
                    SWAB (startCode[iI]);
                    SWAB (endCode[iI]);
                }

                for (iI = 0; iI < segCount-1; iI++)
                {
                    SWAB (idDelta[iI]);
                    SWAB (idRangeOffset[iI]);
                    for (iJ = startCode[iI]; iJ <= endCode[iI]; iJ++)
                    {
                        if (iIndex < usMaxChar)
                        {
                            if (usCharCode == iJ)
                            {
                                if (idRangeOffset[iI] == 0)
                                {
                                    //if ((HGLYPH)(idDelta[iI] + iJ) == hglyph)
                                    hGlyph = (HGLYPH)(idDelta[iI] + iJ);
                                    TOSS(GlyphFoundOk);
                                }
                                else
                                {
                                    GlyphId =  *(pGlyphIdArray + (iJ - startCode[iI]) );
                                    SWAB (GlyphId);
                                    GlyphId += idDelta[iI];
                                    //if (GlyphId == hglyph)
                                    hGlyph = (HGLYPH)GlyphId;
                                    TOSS(GlyphFoundOk);
                                }
                            }
                            iIndex++;
                        }
                    }

                }

                break;
            default:
                TOSS(GlyphFoundOk);
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        hGlyph = INVALID_GLYPH;
    }
    CATCH(GlyphNotFound)
    {
        // Not found.  Return invalid glyph handle.
        hGlyph = INVALID_GLYPH;
    }
    CATCH(DataError)
    {
        // Not found.  Return invalid glyph handle.
        hGlyph = INVALID_GLYPH;
    }
    CATCH(GlyphFoundOk)
    {
        // Just a placeholder.  The glyph id is in hGlyph--to be returned.
    }
    ENDTRY;

    FTRC(Leaving hFindGlyphId...);

    return hGlyph;
}


LRESULT
IsFont2Byte(
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Returns whether or not this font should be output as a format 16 font.
    Put this logic here in case we decide to change it!

  Arguments:

    pPDev -

  Return Value:

    S_OK for format 16,
    S_FALSE for format 15.
    Otherwise E_UNEXPECTED.

--*/
{
    FONTMAP_TTO *pPrivateFM;
    DL_MAP *pDLMap;

    FTRC(Entering IsFont2Byte...);

    ASSERT_VALID_FONTMAP(pFM);

    if (NULL == (pPrivateFM = GETPRIVATEFM(pFM)))
    {
        return E_UNEXPECTED;
    }

    pDLMap = (DL_MAP*)pPrivateFM->pvDLData;
    ASSERTMSG(pDLMap, ("IsFont2Byte!pDLMap NULL\n"));

    if (NULL == pDLMap)
    {
        return E_UNEXPECTED;
    }

    FTRC(Leaving IsFont2Byte...);

#ifdef FORCE_TT_2_BYTE
    return S_OK;
#else
    if (NULL != pFM->pIFIMet && 
            ((IS_BIDICHARSET(pFM->pIFIMet->jWinCharSet)) ||
             (IS_DBCSCHARSET(pFM->pIFIMet->jWinCharSet))))
        return S_OK;
    else
    return DLMAP_FONTIS2BYTE(pDLMap)?S_OK:S_FALSE;
    // return (pDLMap->wLastDLGId > 0x00FF);
    // return (pDLMap->wFlags & DLM_UNBOUNDED) != 0;
#endif
    // return (pPDev->pUDPDev->fMode & PF_DLTT_ASTT_2BYTE) != 0;
}


BOOL
bPCL_SetFontID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Sends the PCL string to select the font specified by pFM
    The history of this process has been left for your amusement.

    The GPD contains a line something like this.
    *Command: CmdSetFontID { *Cmd : "<1B>*c" %d{NextFontID}"D" }

  Arguments:

    pPDev -
    pFM -

  Return Value:

    TRUE if successful else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;


    FTRC(Entering bPCL_SetFontID...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // 1: The good-old-fashoned way.
    //iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "\033*c%dD", pFM->ulDLIndex);
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_SetFontID!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return 0;

    // 2: The old-fashoned way.
    //WriteChannel(pPDev, CMD_SET_FONT_ID, pFM->ulDLIndex);

    // 3: The new way.
    BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETFONTID));

    FTRC(Leaving bPCL_SetFontID...);

    return TRUE;
}


BOOL
bPCL_SendFontDCPT(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN DWORD dwDefinitionSize
    )
/*++

  Routine Description:

    Outputs PCL string that begins a font definition download.  This should follow
    a call to bPCL_SetFontID and be followed by the truetype header info etc.

    [ISSUE] Is there a GPD string for this command?

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    dwDefinitionSize - Num bytes in the font data to be sent.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;
    BOOL bRet = FALSE;

    FTRC(Entering bPCL_SendFontDCPT...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // 1: The old way
    // Send the font definition command
    //WriteChannel( pPDev, CMD_SEND_FONT_DCPT, dwTotalBytes );

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "\033)s%dW", dwDefinitionSize);
        if (iCmdLen < 0 || iCmdLen >= PCLSTRLEN)
            TOSS(InappropriateBuffer);

        if (!BWriteToSpoolBuf(pPDev, szCmdStr, iCmdLen))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(InappropriateBuffer)
    {
        ERR(("bPCL_SendFontDCPT!Inappropriate buffer size.\n"));
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        ERR(("bPCL_SendFontDCPT!Write Error.\n"));
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

        FTRC(Leaving bPCL_SendFontDCPT...);

    return bRet;
}


BOOL
bPCL_SelectFontByID(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Outputs PCL string that selects a font by font-id.  The font-id is passed in as
    pFM->ulDLIndex.

    The GPD contains a line like this:
    *Command: CmdSelectFontID { *Cmd : "<1B>(" %d{CurrentFontID}"X" }

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    pFM->ulDLIndex - id of font to select.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;


    FTRC(Entering bPCL_SelectFontByID...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    //iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "\033(%dX", pFM->ulDLIndex);
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_SelectFontByID!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return FALSE;

    BUpdateStandardVar(pPDev, pFM, 0, 0, STD_CFID);
    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTID));

        FTRC(Leaving bPCL_SelectFontByID...);

    return TRUE;
}


BOOL
bPCL_SelectPointSize(
    IN PDEV *pPDev,
    IN PFONTMAP pFM,
    IN POINTL *pptl
    )
/*++

  Routine Description:

    This routine downloads the height or width of the font depending
    on whether it is a fixed-pitch or variable-pitch font.

    Variable Pitch: send down the font height command, "Esc(s#V", using
      pptl->y as POINT_SIZE * 100.

    Fixed Pitch: the font height command, "Esc(s#V", is ignored for
      fixed-pitch fonts (PCL Implementor's Guide, p9-19).  Send down
      the Font Pitch command, "Esc(s#H", instead.  Use the pptl->x as
      CPI * 100.

    [ISSUE] Although there are GPD commands, CmdSelectFontHeight and
    CmdSelectFontWidth, and the standard variables, STD_FW and STD_FH,
    there are two problems with the GPD solution.
    1) BUpdateStandardVariable doesn't use any parameters when calculating
       the PDEV::dwFontWidth or PDEV::dwFontHeight values.  That isn't what
       I want.  I want to pass in pptl->x / 100 or pptl->y / 100.
    2) The GPD commands CMD_SELECTFONTHEIGHT/WIDTH, which evaluate to
       CmdSelectFontHeight/Width in the GPD file, are evaluating to NULL in
       the CMDPOINTER() macro even though I've added the entries to my GPD
       file.
    I have use the COMMENTEDOUT macro to omit the non-working code for now.

  Arguments:

    pPDev - pointer to PDEV
    pptl->x - Width of glyph expressed as CPI * 100
    pptl->y - Heigt of glyph expressed in points * 100
    pfm - Current font

  Return Value:

    TRUE/FALSE,   TRUE for success.

--*/
{
// #define USE_GPD_HEIGHTWIDTH 1

#ifndef USE_GPD_HEIGHTWIDTH
    PCLSTRING szCmd;
    INTSTRING szValue;
    int iLen;
#endif
    BOOL bRet = FALSE;
    HRESULT hr = S_FALSE;


    FTRC(Entering bPCL_SelectPointSize...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERTMSG(pptl, ("bPCL_SelectPointSize!pptl NULL.\n"));

    TRY
    {
        BYTE fontPitch = (pFM->pIFIMet->jWinPitchAndFamily & 0x03);

        if (!VALID_PDEV(pPDev) || !pptl)
            TOSS(ParameterError);

        if (fontPitch == FIXED_PITCH)
        {
#ifdef USE_GPD_HEIGHTWIDTH
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_FW);
            if (WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTWIDTH)) == NOOCD)
                TOSS(WriteError);
#else
            iLen = IFont100toStr (szValue, CCHOF(szValue), pptl->x);
            if (iLen <= 0 || iLen >= INTSTRLEN)
                TOSS(DataError);

            // IFont100toStr does not NULL terminate.
            szValue[iLen] = '\0';

            // Intention: sprintf(szCmd, "\033(s%sH", szValue);
            hr = StringCchPrintfA ( szCmd,  CCHOF(szCmd),  "\033(s%sH",  szValue);

            if ( SUCCEEDED (hr) )
            {
                if (!BWriteStrToSpoolBuf(pPDev, szCmd))
                    TOSS(WriteError);
            }
            else
            {
                TOSS(WriteError);
            }
#endif
        }
        else if (fontPitch == VARIABLE_PITCH)
        {
#ifdef USE_GPD_HEIGHTWIDTH
            BUpdateStandardVar(pPDev, pFM, 0, 0, STD_FH);
            if (WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTHEIGHT)) == NOOCD)
                TOSS(WriteError);
#else
            iLen = IFont100toStr (szValue, CCHOF(szValue), pptl->y);
            if (iLen <= 0 || iLen >= INTSTRLEN)
                TOSS(DataError);

            // IFont100toStr does not NULL terminate.
            szValue[iLen] = '\0';

            // Intention: sprintf(szCmd, "\033(s%sV", szValue);
            hr = StringCchPrintfA ( szCmd,  CCHOF(szCmd),  "\033(s%sV",  szValue);

            if ( SUCCEEDED (hr) )
            {
                if (!BWriteStrToSpoolBuf(pPDev, szCmd))
                    TOSS(WriteError);
            }
            else
            {
                TOSS(WriteError);
            }
#endif
        }
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
#ifndef USE_GPD_HEIGHTWIDTH
    CATCH(DataError)
    {
        bRet = FALSE;
    }
#endif
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

    FTRC(Leaving bPCL_SelectPointSize...);

    return bRet;
}

BOOL
bPCL_DeselectFont(
    IN PDEV *pPDev,
    IN PFONTMAP pFM
    )
/*++

  Routine Description:

    Outputs PCL string that deselects a font.  This routine really doesn't do
    much since PCL doesn't have the notion of deselecting fonts.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;


    FTRC(Entering bPCL_DeselectFont...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    // I don't think PCL has the notion of "deselection"
    //iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "");
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_DeselectFont!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return FALSE;

    //BUpdateStandardVar(pPDev, pFM, 0, 0, STD_NFID);
    //WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SELECTFONTID));

        FTRC(Leaving bPCL_DeselectFont...);

    return TRUE;
}


BOOL
bPCL_SetParseMode(
    PDEV *pPDev,
    PFONTMAP pFM
    )
/*++

  Routine Description:

    Outputs PCL string to set the PCL parsing mode.  The logical choices
    for this are mode 0 (default) and 21 (two-byte with 0x2100 offset).  The desired
    mode is passed in with pFM.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    pFM->dwCurrentTextParseMode - desired parsing mode

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;
    FONTMAP_TTO *pPrivateFM;
    BOOL bRet = FALSE;


    FTRC(Entering bPCL_SetParseMode...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    pPrivateFM = GETPRIVATEFM(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM) || (pPrivateFM == NULL))
            TOSS(ParameterError);

        iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "\033&t%dP", pPrivateFM->dwCurrentTextParseMode);
        if (iCmdLen < 0 || iCmdLen >= PCLSTRLEN)
            TOSS(InappropriateBuffer);

        if (!BWriteToSpoolBuf(pPDev, szCmdStr, iCmdLen))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(InappropriateBuffer)
    {
        ERR(("bPCL_SetParseMode!Inappropriate buffer size.\n"));
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

        FTRC(Leaving bPCL_SetParseMode...);

    return bRet;
}


BOOL
bPCL_SetCharCode(
    PDEV *pPDev,
    PFONTMAP pFM,
    USHORT usCharCode
    )
/*++

  Routine Description:

    Outputs PCL string to specify the character code for the next downloaded
    character.  This should be followed by the characters glyph definition.

    The GPD will contain something like this:
    *Command: CmdSetCharCode { *Cmd : "<1B>*c" %d{NextGlyph}"E" }

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    usCharCode - Designated download-id for the character.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;

        FTRC(Entering bPCL_SetCharCode...);

    // WriteChannel( pPDev, CMD_SET_CHAR_CODE, usCharCode );

    // CMD_SET_CHAR_CODE, usCharCode
    //iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "\033*c%dE", usCharCode);
    //ASSERTMSG(iCmdLen < PCLSTRLEN, ("bPCL_SetCharCode!Insufficient buffer size.\n"));
    //if (WriteSpoolBuf(pPDev, szCmdStr, iCmdLen) != iCmdLen)
    //    return FALSE;

    BUpdateStandardVar(pPDev, pFM, usCharCode, 0, STD_GL);
    WriteChannel(pPDev, COMMANDPTR(pPDev->pDriverInfo, CMD_SETCHARCODE));

        FTRC(Leaving bPCL_SetCharCode...);

    return TRUE;
}


BOOL
bPCL_SendCharDCPT(
    PDEV *pPDev,
    PFONTMAP pFM,
    DWORD dwSend
    )
/*++

  Routine Description:

    Outputs PCL string to begin the downloading of a character's glyph info.
    This should be followed immediately by the glyph data.

    Want: WriteChannel( pPDev, CMD_SEND_CHAR_DCPT, dwSend );

  Arguments:

    pPDev - Pointer to PDEV structure.
    pFM - pointer to this font
    dwSend - the number of bytes in the glyph data to follow.

  Return Value:

    TRUE if successful, else FALSE.

--*/
{
    PCLSTRING szCmdStr;
    int iCmdLen;
    BOOL bRet = FALSE;


        FTRC(Entering bPCL_SendCharDCPT...);

    ASSERT(VALID_PDEV(pPDev));
    ASSERT_VALID_FONTMAP(pFM);

    TRY
    {
        if (!VALID_PDEV(pPDev) || !VALID_FONTMAP(pFM))
            TOSS(ParameterError);

        iCmdLen = iDrvPrintfSafeA(szCmdStr, CCHOF(szCmdStr), "\033(s%dW", dwSend);
        if (iCmdLen < 0 || iCmdLen >= PCLSTRLEN)
            TOSS(InappropriateBuffer);

        if (!BWriteToSpoolBuf(pPDev, szCmdStr, iCmdLen))
            TOSS(WriteError);
    }
    CATCH(ParameterError)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
    }
    CATCH(InappropriateBuffer)
    {
        ERR(("bPCL_SendCharDCPT!Inappropriate buffer size.\n"));
        bRet = FALSE;
    }
    CATCH(WriteError)
    {
        bRet = FALSE;
    }
    OTHERWISE
    {
        bRet = TRUE;
    }
    ENDTRY;

        FTRC(Leaving bPCL_SendCharDCPT...);

    return bRet;
}

PVOID
pvGetTrueTypeFontFile(
    PDEV *pPDev,
    ULONG *pulSize
    )
/*++

  Routine Description:

    Retrieves the pointer to the truetype file.  The pointer may be cached
    in the pFontPDev, or returned from FONTOBJ_pvTrueTypeFontFile.

    Should I/Can I use VirtualProtect?
    VirtualProtect(pFontPDev->pTTFile, ulFile, PAGE_READONLY, &oldProtect);

  Arguments:

    pPDev - Pointer to PDEV structure.
    pulSize - Pointer to size variable, if NULL this is ignored

  Return Value:

    Pointer to the truetype file.

--*/
{
    PFONTPDEV pFontPDev;
    PVOID     pTTFile;

    ASSERT(VALID_PDEV(pPDev));

    pFontPDev = GETFONTPDEV(pPDev);
    if (pFontPDev)
    {
        if ( pFontPDev->pTTFile == NULL)
        {
            //
            // Get the pointer to memory mapped TrueType font from GDI.
            //
            TO_DATA *pTod;
            ULONG ulFile;
            DWORD oldProtect;
            pTod = (TO_DATA *)pFontPDev->ptod;
            ASSERTMSG(pTod, ("Null TO_DATA.\n"));

            pTTFile = pFontPDev->pTTFile
                    = FONTOBJ_pvTrueTypeFontFile(pTod->pfo, &ulFile);
            pFontPDev->pcjTTFile = ulFile;
        }
        else
        {
            //
            // Get the pointer from font pdev.
            //
            pTTFile = pFontPDev->pTTFile;
        }

        if (pulSize)
            *pulSize = pFontPDev->pcjTTFile;
    }
    else
    {
        pTTFile = NULL;
        if (NULL != pulSize)
        {
            *pulSize = 0;
        }
    }

    return pTTFile;
}

//
// DCR: This function is a workaround for WritePrinter Failure, which happens
// because  of a bug in spooler which treates TT memory mapped file pointers to
// be user mode memory. Onece this is fix in spooler, we will disable this code.
//
#define MAX_SPOOL_BYTES 2048
INT TTWriteSpoolBuf(
    PDEV    *pPDev,
    BYTE    *pbBuf,
    INT     iCount
    )
{
    INT iTotalBytesWritten = 0;

    while (iCount)
    {
        INT iBytesToWrite = min(iCount, MAX_SPOOL_BYTES);
        INT iBytesWritten = WriteSpoolBuf(pPDev, pbBuf, iBytesToWrite);
        if (iBytesToWrite != iBytesWritten)
            break;

        iTotalBytesWritten += iBytesWritten;
        pbBuf += iBytesWritten;
        iCount -= iBytesWritten;
    }
    return iTotalBytesWritten;
}

BOOL BIsExemptedFont(
    PDEV       *pPDev,
    IFIMETRICS *pIFI
)
/*++

  Routine Description:

    Determines whether the given font is one of the unhandled fonts.

  Arguments:

    pPDev - Pointer to PDEV structure.
    pIFI - Pointer to ifimetrics structure

  Return Value:

    TRUE if the font is an unhandled font else FALSE.

--*/
{
    int i;
    char szFontName[LEN_FONTNAME]; //Want to make size same as in TT_HEADER.FontName
    BOOL bRet = FALSE;

    ASSERT(VALID_PDEV(pPDev));

    vGetFontName(pPDev, pIFI, szFontName, CCHOF(szFontName));

    TRY
    {
        char *pszRegExemptedFont;

        if (strlen(szFontName) == 0)
            TOSS(BlankFontName);
        //
        // Make it lower case.
        //
        _strlwr(szFontName);

        for (i = 0; i < nExemptedFonts; i++)
        {
            //
            // Search the exemptedfont name in current font. we search for
            // subtring only. So if "courier new" is exempted then we don't
            // download any font that contains "courier new" string. This will
            // cause "Courier New Bold" to be not downloaded as TT outline.
            //
            if (strstr(szFontName, aszExemptedFonts[i]))
            {
                bRet = TRUE;
                break;
            }
        }

#ifdef COMMENTEDOUT
        //
        // When the registry entry is passed in then
        // pszRegExemptedFont should be set to that value instead
        // of the test value.Note For registry we test exact match
        // of font name.
        //
        for (pszRegExemptedFont = "One\0Two\0Three\0";
             *pszRegExemptedFont;
             pszRegExemptedFont += (strlen(pszRegExemptedFont) + 1))
        {
            if (strcmp(szFontName, pszRegExemptedFont) == 0)
            {
                bRet = TRUE;
                break;
            }
        }
#endif
    }
    CATCH(BlankFontName)
    {
        //
        // The name was blank so it can't match one of the exempted fonts,
        // but I'm not happy about that.
        //
        bRet = FALSE;
    }
    ENDTRY;

    return bRet;
}

BOOL BIsPDFType1Font(
    IFIMETRICS  *pIFI)
/*++

  Routine Description:

    Helper function to determine if the font is TrueType font converted from
    Type1 font by PDF writer.

  Arguments:

    pIFI - a pointer to IFIMETRICS.

  Return Value:

    TRUE if the font of the IFIMETRICS is a TrueType font converted from Type1.

--*/
{
    const WCHAR szPDFType1[] = L".tmp";
    WCHAR *szFontName;

    if (NULL == pIFI)
    {
        //
        // Error return. Disable TrueType font downloading.
        //
        TRUE;
    }
    szFontName = (WCHAR*)((PBYTE)pIFI+pIFI->dpwszFamilyName);

    if (wcsstr(szFontName, szPDFType1))
        return TRUE;
    else
        return FALSE;
}

BOOL BWriteStrToSpoolBuf(
    IN PDEV *pPDev,
    IN char *szStr
)
/*++

  Routine Description:

    Helper function to write null-terminated strings to the printer.

  Arguments:

    pPDev - Pointer to PDEV structure.
    szStr - Pointer to null-terminated string

  Return Value:

    TRUE if the string was successfully written, else FALSE

--*/
{
    LONG iLen = 0;

    if (!pPDev || !szStr)
        return FALSE;

    iLen = strlen(szStr);
    return BWriteToSpoolBuf(pPDev, szStr, iLen);
}


#ifdef KLUDGE
#undef ZeroMemory
#define ZeroMemory(pb, cb) memset((pb),0,(cb))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\fd_glyph.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fd_glyhph.h

Abstract:

    Stock FD_GLYPHSET data definitions.

Environment:

    Windows NT printer drivers

Revision History:

    01/21/96 -eigos-
        Created it.

--*/

#ifndef _FD_GLYPH_H_
#define _FD_GLYPH_H_


//
// Stock FD_GLYPHSET id
//

#define STOCK_GLYPHSET_932       0  // Japan
#define STOCK_GLYPHSET_936       1  // Chinese (PRC, Singapore)
#define STOCK_GLYPHSET_949       2  // Korean
#define STOCK_GLYPHSET_950       3  // Chinese (Taiwan, Hong Kong)

#define MAX_STOCK_GLYPHSET       4

//
// Codepage macros
//

#define CP_SHIFTJIS_932        932
#define CP_GB2312_936          936
#define CP_WANSUNG_949         949
#define CP_CHINESEBIG5_950     950

//
// Predefined GTT Resource ID
//

#define GTT_CC_CP437              1
#define GTT_CC_CP850              2
#define GTT_CC_CP863              3
#define GTT_CC_CBIG5              10
#define GTT_CC_ISC                11
#define GTT_CC_JIS                12
#define GTT_CC_JIS_ANK            13
#define GTT_CC_NS86               14
#define GTT_CC_TCA                15
#define GTT_CC_GB2312             16
#define GTT_CC_WANSUNG            17

#endif // _FD_GLYPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\font\sfttpcl.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    sfttpcl.h

Abstract:

    TT outline download header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    06/03/97 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _SFTTPCL_H

#define _SFTTPCL_H

/*
 * True Type data structures
 */
typedef  signed  char  SBYTE;
/*
 * Table Directory for True Type Font files
 */
#define TABLE_DIR_ENTRY_SIZE    (16/sizeof(int))
#define TABLE_DIR_ENTRY         4 * TABLE_DIR_ENTRY_SIZE
#define SIZEOF_TABLEDIR         8 * TABLE_DIR_ENTRY
typedef ULONG     TT_TAG;
#define TRUE_TYPE_HEADER        12
#define NUM_DIR_ENTRIES         8

typedef unsigned short int  uFWord;
typedef short int           FWord;
/* Some True Type Font default values   */
#define TT_QUALITY_LETTER     2
#define DEF_WIDTHTYPE         0
#define DEF_SERIFSTYLE        0
#define DEF_FONTNUMBER        0
#define DEF_STYLE             0x03e0
#define DEF_TYPEFACE          254
#define DEF_STROKEWEIGHT      0
#define DEF_XHEIGHT           0
#define DEF_CAPHEIGHT         0
#define DEF_SYMBOLSET         0x7502
#define MAX_SEGMENTS          0x200
#define MAX_CHAR              0x100
#define x_UNICODE             0x78
#define H_UNICODE             0x48
#define INVALID_GLYPH         0xffff
#define MAX_FONTS             8
#define MORE_COMPONENTS       0x20

#define FIXED_SPACING         0
#define PROPORTIONAL_SPACING  1
#define LEN_FONTNAME          16
#define LEN_PANOSE            10
#define LEN_COMPLEMENTNUM     8
#define UB_SYMBOLSET          56
#define RESERVED_CHARID       0xffff
#define PCL_MAXHEADER_SIZE   32767


#define PANOSE_TAG            0x4150          // "PA" swapped
#define CE_TAG                'EC'
#define CC_TAG                'CC'
#define GC_TAG                'CG'
#define SEG_TAG               0x5447          // already swapped
#define Null_TAG              0xffff
#define CHAR_COMP_TAG         0x4343

#define PLATFORM_MS           3
#define SYMBOL_FONT           0
#define UNICODE_FONT          1
#define TT_BOUND_FONT         2
#define TT_2BYTE_FONT         3
#define TT_UNBOUND_FONT       11
#define FAMILY_NAME           4

// For Parsing Method 21 we need to start at 0x2100
#define FIRST_TT_2B_CHAR_CODE 0x2100

#define SHORT_OFFSET          0
#define LONG_OFFSET           1

/*
 * Constants used for compound glyphs
 */
#define     ARG_1_AND_2_ARE_WORDS       0x01
#define     WE_HAVE_A_SCALE             0x08
#define     MORE_COMPONENTS             0x20
#define     WE_HAVE_AN_X_AND_Y_SCALE    0x40
#define     WE_HAVE_A_TWO_BY_TWO        0x80


/* TT Table directory header. This is the first str */
typedef struct
{
    FIXED      version;
    USHORT     numTables;
    USHORT     searchRange;
    USHORT     entrySelector;
    USHORT     rangeShift;
} TRUETYPEHEADER;

/* TT Table directory structure. */
typedef struct
{
    ULONG      uTag;
    ULONG      uCheckSum;
    ULONG      uOffset;
    ULONG      uLength;
} TABLEDIR;

typedef TABLEDIR ATABLEDIR[NUM_DIR_ENTRIES];
typedef TABLEDIR *PTABLEDIR;

/* List of tables needed for PCL TT download. They are listed in order. */

#define   TABLEOS2     "OS/2" /* Not sent to PCL header */
#define   TABLEPCLT    "PCLT" /* Not sent to PCL header */
#define   TABLECMAP    "cmap" /* Not sent to PCL header */

#define   TABLECVT     "cvt "
#define   TABLEFPGM    "fpgm"
#define   TABLEGDIR    "gdir" /* This is PCL specific table. Not a TT table */
#define   TABLEGLYF    "glyf" /* This table is not sent in PCL font header */
#define   TABLEHEAD    "head"
#define   TABLEHHEA    "hhea"
#define   TABLEHMTX    "hmtx"
#define   TABLELOCA    "loca" /* Not sent to PCL header */
#define   TABLEMAXP    "maxp"
#define   TABLENAME    "name" /* Not sent to PCL header */
#define   TABLEPOST    "post" /* Not sent to PCL header */
#define   TABLEPREP    "prep"



typedef struct
{
    ULONG u1;
    ULONG u2;
} DATETIME;

typedef struct
{
    FIXED   version;
    FIXED   fontRevision;
    ULONG   checkSumAdjustment;
    ULONG   magicNumber;
    USHORT  flags;
    USHORT  unitsPerEm;
    DATETIME    dateCreated;
    DATETIME    dateModified;
    SHORT   xMin;
    SHORT   yMin;
    SHORT   xMax;
    SHORT   yMax;
    USHORT  macStyle;
    USHORT  lowestRecPPEM;
    SHORT   fontDirectionHint;
    SHORT   indexToLocFormat;
} HEAD_TABLE;

typedef struct
{
    BYTE stuff[34];
    USHORT numberOfHMetrics;
} HHEA_TABLE;

typedef struct {
    uFWord      advanceWidth;
    FWord       leftSideBearing;
} HORIZONTALMETRICS;

typedef struct {
    HORIZONTALMETRICS   longHorMetric[1];
} HMTXTABLE;

typedef struct
{
    uFWord   advanceWidth;
} HMTX_INFO;

typedef struct
{
    FIXED   version;
    USHORT  numGlyphs;
} MAXP_TABLE;

typedef struct
{
    USHORT      version;
    SHORT       xAvgCharWidth;
    USHORT      usWeightClass;
    USHORT      usWidthClass;
    SHORT       fsType;
    SHORT       ySubscriptXSize;
    SHORT       ySubscriptYSize;
    SHORT       ySubscriptXOffset;
    SHORT       ySubscriptYOffset;
    SHORT       ySuperscriptXSize;
    SHORT       ySuperscriptYSize;
    SHORT       ySuperscriptXOffset;
    SHORT       ySuperscriptYOffset;
    SHORT       yStrikeoutSize;
    SHORT       yStrikeoutPosition;
    SHORT       sFamilyClass;
    PANOSE      Panose;
    SHORT       ss1;
    SHORT       ss2;
    SHORT       ss3;
    ULONG       ulCharRange[3];
    SHORT       ss4;
    USHORT      fsSelection;
    USHORT      usFirstCharIndex;
    USHORT      usLastCharIndex;
    USHORT      sTypoAscender;
    USHORT      sTypoDescender;
    USHORT      sTypoLineGap;
    USHORT      usWinAscent;
    USHORT      usWinDescent;
} OS2_TABLE;

typedef struct
{
    FIXED   FormatType;
    FIXED   italicAngle;
    SHORT   underlinePosition;
    SHORT   underlineThickness;
    ULONG   isFixedPitch;              /* set to 0 if proportional, else !0  */
} POST_TABLE;

typedef struct
{
    ULONG   Version;
    ULONG   FontNumber;
    USHORT  Pitch;
    USHORT  xHeight;
    USHORT  Style;
    USHORT  TypeFamily;
    USHORT  CapHeight;
    USHORT  SymbolSet;
    char    Typeface[LEN_FONTNAME];
    char    CharacterComplement[8];
    char    FileName[6];
    char    StrokeWeight;
    char    WidthType;
    BYTE    SerifStyle;
} PCLT_TABLE;

typedef struct
{
    USHORT  PlatformID;
    USHORT  EncodingID;
    ULONG   offset;
} ENCODING_TABLE;

typedef struct
{
    USHORT  Version;
    USHORT  nTables;
    ENCODING_TABLE  encodingTable[3];
} CMAP_TABLE;

typedef struct
{
    USHORT   format;
    USHORT   length;
    USHORT   Version;
    USHORT   SegCountx2;
    USHORT   SearchRange;
    USHORT   EntrySelector;
    USHORT   RangeShift;
} GLYPH_MAP_TABLE;

typedef struct
{
    SHORT numberOfContours;
    FWord xMin;
    FWord yMin;
    FWord xMax;
    FWORD yMax;
//    SHORT GlyphDesc[1];
} GLYPH_DATA_HEADER;

typedef struct
{
    CMAP_TABLE cmapTable;
    ULONG      offset;
} GLYPH_DATA;

typedef struct
{
    USHORT   PlatformID;
    USHORT   EncodingID;
    USHORT   LanguageID;
    USHORT   NameID;
    USHORT   StringLen;
    USHORT   StringOffset;
} NAME_RECORD;

typedef struct
{
    USHORT      FormatSelector;
    USHORT      NumOfNameRecords;
    USHORT      Offset;
    NAME_RECORD *pNameRecord;
} NAME_TABLE;

typedef struct
{
    ULONG ulOffset;
    ULONG ulLength;
} FONT_DATA;

/* Segment data */
#define CE_SEG_SIGNATURE 'EC'
typedef struct
{
    WORD  wSig;
    WORD  wSize;
    WORD  wSizeAlign;
    WORD  wStyle; // 1 = italics, 0,2,3=reserved.
    WORD  wStyleAlign; // 1 = italics, 0,2,3=reserved.
    WORD  wStrokeWeight;
    WORD  wSizing;
} CE_SEGMENT;

//
// From PCL TechRef.pdf
//
// Character Complement Numbers
//
// The "Intellifont Unbound Scalable Font Header" (header) includes a
// 64 bit field (bytes 78-85) which contains the Character Complement
// number. For TrueType fonts, in the "15 Font Header for
// Scalable Fonts" (unbound), the Character Complement number is
// included in the accompanying "Font Data" section of the
// header.
// The Character Complement number identifies the symbol collections
// in the font. Each bit in this field corresponds to a symbol collection
// (not all bits are currently defined; refer to Appendix D in the PCL 5
// Comparison Guide).
//
// This 8-byte field works in conjunction with the Character Complement
// field in the header of a type 10 or 11 (unbound) font to determine the
// compatibility of a symbol set with an unbound font. These two fields
// identify the unbound fonts in the printer which contain the symbol
// collections required to build a symbol set. Refer to "Scalable
// Fonts" in Chapter 9, for a description of symbol collections and
// unbound fonts.
// Each bit in the field represents a specific collection. Setting a bit to 1
// indicates that collection is required; setting the bit to 0 indicates that
// collection is not required. (Bit 63 refers to the most significant bit of
// the first byte, and bit 0 refers to the least significant bit of the eight
// byte field.) The bit representations for the collections are shown
// below.
//
// MSL Symbol index
//
// Bit   Field Designated Use
// 58-63 Reserved for Latin fonts.
// 55-57 Reserved for Cyrillic fonts.
// 52-54 Reserved for Arabic fonts.
// 50-51 Reserved for Greek fonts.
// 48-49 Reserved for Hebrew fonts.
// 3-47  Miscellaneous uses (South Asian, Armenian, 
//       other alphabets, bar codes, OCR, Math, PC Semi-graphics, etc.).
// 0-2   Symbol Index field. 111 - MSL Symbol Index
//
// Unicode Symbol Index
//
// Bit   Field Designated Use
// 32-63 Miscellaneous uses (South Asian, Armenian, other
//       alphabets, bar codes, OCR, Math, etc.).
// 28-31 Reserved for Latin fonts.
// 22-27 Reserved for platform/application variant fonts.
// 3-21  Reserved for Cyrillic, Arabic, Greek and Hebrew fonts.
// 0-2   Symbol Index field. 110 - Unicode Symbol Index
//
// MSL Symbol Index Character Complement Bits
// Bit Value
// 63  0 if font is compatible with standard Latin character
//       sets (e.g., Roman-8, ISO 8859-1 Latin 1);
//     1 otherwise.
// 62  0 if font is compatible with East European Latin
//       character sets (e.g., ISO 8859-2 Latin 2); 1 otherwise.
// 61  0 if font contains Turkish character sets
//       (e.g., ISO 8859/9 Latin 5); 1 otherwise.
// 34  0 if font has access to the math characters of the
//       Math-8, PS Math and Ventura Math character sets;
//     1 otherwise.
// 33  0 if font has access to the semi-graphic characters of
//       the PC-8, PC-850, etc. character sets; 1 otherwise.
// 32  0 if font is compatible with ITC Zapf Dingbats series
//       100, 200, etc.;
//     1 otherwise.
// 2, 1, 0 
//     111 if font is arranged in MSL Symbol Index order.
//
// Unicode Symbol Index Character Complement Bits
// Bit Value
// 31  0 if font is compatible with 7-bit ASCII;
//     1 otherwise.
// 30  0 if font is compatible with ISO 8859/1 Latin 1 (West
//       Europe) character sets;
//     1 otherwise.
// 29  0 if font is compatible with ISO 8859/2 Latin 2 (East
//       Europe) character sets;
//     1 otherwise.
// 28  0 if font is compatible with Latin 5 (Turkish) character
//       sets (e.g., ISO 8859/9 Latin 5, PC-Turkish);
//     1 otherwise.
// 27  0 if font is compatible with Desktop Publishing
//       character sets (e.g., Windows 3.1 Latin 1, DeskTop, MC Text);
//     1 otherwise.
// 26  0 if font is compatible with character sets requiring a
//       wider selection of accents (e.g., MC Text, ISO 8859/1 Latin 1);
//     1 otherwise.
// 25  0 if font is compatible with traditional PCL character
//       sets (e.g., Roman-8, Legal, ISO 4 United Kingdom);
//     1 otherwise.
// 24  0 if font is compatible with the Macintosh character set (MC Text);
//     1 otherwise.
// 23  0 if font is compatible with PostScript Standard Encoding (PS Text);
//     1 otherwise.
// 22  0 if font is compatible with Code Pages
//       (e.g., PC-8, PC 850, PC-Turk, etc.);
//     1 otherwise.
// 2,1,0
//     110 if font is arranged in Unicode Symbol Index order.
//
#define CC_SEG_SIGNATURE 'CC'
typedef struct
{
    WORD  wSig;
    WORD  wSize;
    WORD  wSizeAlign;
    //
    // 64 bit field
    //
    WORD  wCCNumber1;
    WORD  wCCNumber2;
    WORD  wCCNumber3;
    WORD  wCCNumber4;
} CC_SEGMENT;

#define GC_SEG_SIGNATURE 'CG'
typedef struct
{
    WORD  wSig;
    WORD  wSize;
    WORD  wSizeAlign;
    WORD  wFormat; // = 0
    WORD  wDefaultGalleyChar; //FFFF
    WORD  wNumberOfRegions;   // 1 (Hebrew)
    struct {
        WORD wRegionUpperLeft; // 0
        WORD wRegionLowerRight; // FFFE
        WORD wRegional;         // FFFE
    } RegionChar[1];
} GC_SEGMENT;

/* True Type character descriptor */
typedef struct
{
    BYTE    bFormat;
    BYTE    bContinuation;
    BYTE    bDescSize;
    BYTE    bClass;
    WORD    wCharDataSize;
    WORD    wGlyphID;
} TTCH_HEADER;

/* Unbound True Type Font Descriptor */
typedef struct
{
    USHORT  usSize;
    BYTE    bFormat;
    BYTE    bFontType;
    BYTE    bStyleMSB;
    BYTE    bReserve1;
    USHORT  usBaselinePosition;
    USHORT  usCellWidth;
    USHORT  usCellHeight;
    BYTE    bOrientation;
    BYTE    bSpacing;
    USHORT  usSymbolSet;
    USHORT  usPitch;
    USHORT  usHeight;
    USHORT  usXHeight;
    SBYTE   sbWidthType;
    BYTE    bStyleLSB;
    SBYTE   sbStrokeWeight;
    BYTE    bTypefaceLSB;
    BYTE    bTypefaceMSB;
    BYTE    bSerifStyle;
    BYTE    bQuality;
    SBYTE   sbPlacement;
    SBYTE   sbUnderlinePos;
    SBYTE   sbUnderlineThickness;
    USHORT  Reserve2;
    USHORT  Reserve3;
    USHORT  Reserve4;
    USHORT  usNumberContours;
    BYTE    bPitchExtended;
    BYTE    bHeightExtended;
    WORD    wCapHeight;
    ULONG   ulFontNum;
    char    FontName[LEN_FONTNAME];
    WORD    wScaleFactor;
    SHORT   sMasterUnderlinePosition;
    USHORT  usMasterUnderlineHeight;
    BYTE    bFontScaling;
    BYTE    bVariety;
} UB_TT_HEADER;

/* Bounded True Type Font Descriptor */
typedef struct
{
    USHORT  usSize;                    /* Number of bytes in here     */
    BYTE    bFormat;                  /* Descriptor Format  TT is 15 */
    BYTE    bFontType;                /* 7, 8, or PC-8 style font    */
    BYTE    bStyleMSB;
    BYTE    wReserve1;                /* Reserved                    */
    WORD    wBaselinePosition;        /* TT = 0                      */
    USHORT    wCellWide;                /* head.xMax - xMin            */
    USHORT    wCellHeight;              /* head.yMax - yMin            */
    BYTE    bOrientation;             /* TT = 0                      */
    BYTE    bSpacing;                 /* post.isFixedPitch           */
    WORD    wSymSet;                  /* PCLT.symbolSet              */
    WORD    wPitch;                   /* hmtx.advanceWidth           */
    WORD    wHeight;                  /* TT = 0                      */
    WORD    wXHeight;                 /* PCLT.xHeight                */
    SBYTE   sbWidthType;              /* PCLT.widthType              */
    BYTE    bStyleLSB;
    SBYTE   sbStrokeWeight;           /* OS2.usWeightClass          */
    BYTE    bTypefaceLSB;             /*                            */
    BYTE    bTypefaceMSB;             /*                            */
    BYTE    bSerifStyle;              /* PCLT.serifStyle            */
    BYTE    bQuality;
    SBYTE   sbPlacement;              /* TT = 0                     */
    SBYTE   sbUnderlinePos;           /* TT = 0                     */
    SBYTE   sbUnderlineThickness;     /* TT = 0                     */
    USHORT  usTextHeight;             /* Reserved                    */
    USHORT  usTextWidth;              /* Reserved                    */
    WORD    wFirstCode;               /* OS2.usFirstCharIndex       */
    WORD    wLastCode;                /* OS2.usLastCharIndex        */
    BYTE    bPitchExtended;           /* TT = 0                    */
    BYTE    bHeightExtended;          /* TT = 0                    */
    USHORT  usCapHeight;              /* PCLT.capHeight             */
    ULONG   ulFontNum;                /* PCLT.FontNumber            */
    char    FontName[LEN_FONTNAME];   /* name.FontFamilyName        */
    WORD    wScaleFactor;             /* head.unitsPerEm            */
    SHORT   sMasterUnderlinePosition; /* post.underlinePosition     */
    USHORT  usMasterUnderlineHeight;   /* post.underlineThickness    */
    BYTE    bFontScaling;             /* TT = 1                     */
    BYTE    bVariety;                 /* TT = 0                     */
} TT_HEADER;

#endif  // !_SFTTPCL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\fmlib.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmlib.h

Abstract:

    Include file to provide prototypes and data types for the rasdd
    private library.

Environment:

    Windows NT printer drivers

Revision History:

    11/11/96 -eigos-
        From NT4.0.

Note:

    uni16gpc.h has to be included before including this header file.
    Definition CD is defined in uni16gpc.h

--*/

#ifndef _FMLIB_H_
#define _FMLIB_H_


//
//   A convenient grouping for passing around information about the
// Win 3.1 font information.
//

typedef  struct
{
    BYTE           *pBase;      // The base address of data area
    DWORD           dwFlags;    // Misc. flags.
    DRIVERINFO      DI;         // DRIVERINFO for this font
    PFMHEADER       PFMH;       // Properly aligned, not resource format
    PFMEXTENSION    PFMExt;     // Extended PFM data,  properly aligned!
    EXTTEXTMETRIC  *pETM;        // Extended text metric
    CD             *pCDSelectFont;
    CD             *pCDUnSelectFont;
    DWORD           dwKernPairSize;
    w3KERNPAIR     *pKernPair;
    DWORD           dwWidthTableSize;
    PSHORT          psWidthTable;
    DWORD           dwCodePageOfFacenameConv;
} FONTIN, *PFONTIN;

#define FLAG_FONTSIM        0x01

typedef struct
{
    DWORD dwSize;
    PBYTE pCmdString;
} CMDSTRING, *PCMDSTRING;

typedef struct
{
    UNIFM_HDR   UniHdr;
    UNIDRVINFO  UnidrvInfo;
    CMDSTRING   SelectFont;
    CMDSTRING   UnSelectFont;
    CMDSTRING   IDString;
    DWORD       dwIFISize;
    PIFIMETRICS pIFI;
    EXTTEXTMETRIC  *pETM;        // Extended text metric
    DWORD       dwKernDataSize;
    PKERNDATA   pKernData;
    DWORD       dwWidthTableSize;
    PWIDTHTABLE pWidthTable;
} FONTOUT, *PFONTOUT;

typedef struct
{
    PWSTR pwstrUniqName;
} FONTMISC, *PFONTMISC;

//
//   Function prototypes for functions that convert Win 3.1 PFM style
//  font info to the IFIMETRICS etc required by NT.
//

//
// Convert PFM style metrics to IFIMETRICS
//

BOOL BFontInfoToIFIMetric(
    IN     HANDLE,
    IN     FONTIN*,
    IN     PWSTR,
    IN     DWORD,
    IN OUT PIFIMETRICS*,
    IN OUT PDWORD,
    IN DWORD);

//
// Align PFM data
//

BOOL
BAlignPFM(
    FONTIN   *pFInData);

//
// Extract the Command Descriptors for (de)selecting a font
//

BOOL BGetFontSelFromPFM(
    IN     HANDLE,
    IN     FONTIN*,
    IN     BOOL,
    IN OUT CMDSTRING*);

//
//   Obtain a width vector - proportionally spaced fonts only
//

BOOL BGetWidthVectorFromPFM(
    IN     HANDLE,
    IN     FONTIN*,
    IN OUT PSHORT*,
    IN OUT PDWORD);

//
// Obtain a kerning pair
//

BOOL
BGetKerningPairFromPFM(
    IN  HANDLE,
    IN  FONTIN*,
    OUT w3KERNPAIR **);

//
// Function to convert PFM to UFM
//

BOOL
BConvertPFM2UFM(
    IN     HANDLE,
    IN     PBYTE,
    IN     PUNI_GLYPHSETDATA,
    IN     DWORD,
    IN     PFONTMISC,
    IN     PFONTIN,
    IN     int,
    IN OUT PFONTOUT,
    IN     DWORD);

//
// Function to convert CTT to GTT
//

BOOL
BConvertCTT2GTT(
    IN     HANDLE,
    IN     PTRANSTAB,
    IN     DWORD,
    IN     WCHAR,
    IN     WCHAR,
    IN     PBYTE,
    IN     PBYTE,
    IN OUT PUNI_GLYPHSETDATA*,
    IN     DWORD);

#endif // _FMLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\fmnewgly.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmnewgly.h

Abstract:

    Universal printer driver specific font metrics resource header

Environment:

    Windows NT printer drivers

Revision History:

    10/30/96 -eigos-
        Created it.

--*/

#ifndef _FMNEWGLY_H_
#define _FMNEWGLY_H_

//
// NOTE: To include this header file, it is necessary to include
//       winddi.h which has a definition of FD_GLYPHSET
//       parser.h which has a definition of INVOCATION
//

//
// UNI_GLYPHSETDATA
//
// GLYPHSETDATA data structure represents a character encoding information
// of printer device font.
//

typedef struct _UNI_GLYPHSETDATA {
        DWORD   dwSize;
        DWORD   dwVersion;
        DWORD   dwFlags;
        LONG    lPredefinedID;
        DWORD   dwGlyphCount;
        DWORD   dwRunCount;
        DWORD   loRunOffset;
        DWORD   dwCodePageCount;
        DWORD   loCodePageOffset;
        DWORD   loMapTableOffset;
        DWORD   dwReserved[2];
} UNI_GLYPHSETDATA, *PUNI_GLYPHSETDATA;

#define UNI_GLYPHSETDATA_VERSION_1_0    0x00010000

#define GET_GLYPHRUN(pGTT)     \
    ((PGLYPHRUN) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loRunOffset))
#define GET_CODEPAGEINFO(pGTT) \
    ((PUNI_CODEPAGEINFO) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loCodePageOffset))
#define GET_MAPTABLE(pGTT) \
    ((PMAPTABLE) ((PBYTE)(pGTT) + ((PUNI_GLYPHSETDATA)pGTT)->loMapTableOffset))

//
// UNI_CODEPAGEINFO
//
// This UNI_CODEPAGEINFO dats structure has a list of Codepage values
// which are supported by this UNI_GLYPHSETDATA.
//

typedef struct _UNI_CODEPAGEINFO {
    DWORD      dwCodePage;
    INVOCATION SelectSymbolSet;
    INVOCATION UnSelectSymbolSet;
} UNI_CODEPAGEINFO, *PUNI_CODEPAGEINFO;

//
// GLYPHRUN
//
// GLYPHRUN dats structure represents the conversion table from Unicode to
// UNI_GLYPHSETDATA specific glyph handle. Glyph handle is continuous number
// starting from zero.
//

typedef struct _GLYPHRUN {
    WCHAR   wcLow;
    WORD    wGlyphCount;
} GLYPHRUN, *PGLYPHRUN;


//
// MAPTABLE and TRANSDATA
//
// This MAPTABLE data structure represents a conversion table fron glyph handle
// to codepage/character code.
//

typedef struct _TRANSDATA {
    BYTE  ubCodePageID; // Codepage index to CODEPAGENFO data structure array
    BYTE  ubType;       // a type of TRANSDATA
    union
    {
        SHORT   sCode;
        BYTE    ubCode;
        BYTE    ubPairs[2];
    } uCode;
} TRANSDATA, *PTRANSDATA;

typedef struct _MAPTABLE {
    DWORD     dwSize;     // the size of MAPTABLE including TRANSDATA array
    DWORD     dwGlyphNum; // the number of glyphs supported in MAPTABLE
    TRANSDATA Trans[1];   // an array of TRANSDATA
} MAPTABLE, *PMAPTABLE;

//
// ubType flags
//
// One of following three can be specified for the type of uCode.
//

#define MTYPE_FORMAT_MASK 0x07
#define MTYPE_COMPOSE   0x01 // wCode is an array of 16-bit offsets from the
                             // beginning of the MAPTABLE pointing to the
                             // strings to use for translation.
                             // bData representes thelength of the translated
                             // string.
#define MTYPE_DIRECT    0x02 // wCode is a byte data of one-to-one translation
#define MTYPE_PAIRED    0x04 // wCode contains a word data to emit.

//
// One of following tow can be specified for Far East multibyte character.
//

#define MTYPE_DOUBLEBYTECHAR_MASK   0x18
#define MTYPE_SINGLE    0x08 // wCode contains a single byte character code in
                             // multi byte character string.
#define MTYPE_DOUBLE    0x10 // wCode contains a double byte character code in
                             // multi byte character string.
//
// One of following three can be specified for replace/add/disable system
// predefined GTT.
//

#define MTYPE_PREDEFIN_MASK   0xe0
#define MTYPE_REPLACE   0x20 // wCode contains a data to replace predefined one.
#define MTYPE_ADD       0x40 // wCode contains a data to add to predefiend one.
#define MTYPE_DISABLE   0x80 // wCode contains a data to remove from predefined.


//
// System predefined character conversion
//
// UNIDRV is going to support  following system predefined character conversion.
// By speciffying these number in UNIFM.dwGlyphSetDataRCID;
//

#define CC_NOPRECNV 0x0000FFFF // Not use predefined

//
// ANSI
//

#define CC_DEFAULT  0 // Default Character Conversion
#define CC_CP437   -1 // Unicode to IBM Codepage 437
#define CC_CP850   -2 // Unicode to IBM Codepage 850
#define CC_CP863   -3 // Unicode to IBM Codepage 863

//
// Far East
//

#define CC_BIG5     -10 // Unicode to Chinese Big 5. Codepage 950.
#define CC_ISC      -11 // Unicode to Korean Industrial Standard. Codepage 949.
#define CC_JIS      -12 // Unicode to JIS X0208. Codepage 932.
#define CC_JIS_ANK  -13 // Unicode to JIS X0208 except ANK. Codepage 932.
#define CC_NS86     -14 // Big-5 to National Standstand conversion. Codepage 950
#define CC_TCA      -15 // Big-5 to Taipei Computer Association. Codepage 950.
#define CC_GB2312   -16 // Unicode to GB2312. Codepage 936
#define CC_SJIS     -17 // Unicode to Shift-JIS. Codepage 932.
#define CC_WANSUNG  -18 // Unicode to Extented Wansung. Codepage 949.

#endif // _FMNEWGLY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\fmnewfm.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmnewfm.h

Abstract:

    Universal printer driver specific font metrics resource header

Environment:

    Windows NT printer drivers

Revision History:

    10/30/96 -eigos-
        Created it.

--*/

#ifndef _FMNEWFM_H_
#define _FMNEWFM_H_

//
// NOTE: To include this header file, it is necessary to include
//       parser.h which has a definition of INVOCATION structure,
//       winddi.h which has a definition of IFIMETRICS, FD_KERNINGPAIR
//
//


//
// UNIFM
//
// Universal printer driver (UNIDRV) font file header.
//

#define UNIFM_VERSION_1_0 0x00010000

typedef struct _UNIFM_HDR
{
    DWORD      dwSize;             // a total size of this font file
    DWORD      dwVersion;          // a version number of this font file
    ULONG      ulDefaultCodepage;  // this font's default codepage
    LONG       lGlyphSetDataRCID;  // a resource ID of GLYPHDATA
    DWORD      loUnidrvInfo;       // offset to UNIDRVINFO
    DWORD      loIFIMetrics;       // offset to IFIMETRICS
    DWORD      loExtTextMetric;    // offset to EXTTEXTMETRIC
    DWORD      loWidthTable;       // offset to WIDTHTABLE
    DWORD      loKernPair;         // offset to KERNPAIR
    DWORD      dwReserved[2];
} UNIFM_HDR, *PUNIFM_HDR;

#define GET_UNIDRVINFO(pUFM)    \
        ((PUNIDRVINFO)((PBYTE)(pUFM) + (pUFM)->loUnidrvInfo))
#define GET_IFIMETRICS(pUFM)    \
        ((IFIMETRICS*)((PBYTE)(pUFM) + (pUFM)->loIFIMetrics))
#define GET_EXTTEXTMETRIC(pUFM) \
        ((EXTTEXTMETRIC*)((PBYTE)(pUFM) + (pUFM)->loExtTextMetric))
#define GET_WIDTHTABLE(pUFM)    \
        ((PWIDTHTABLE)((PBYTE)(pUFM) + (pUFM)->loWidthTable))
#define GET_KERNDATA(pUFM)      \
        ((PKERNDATA)((PBYTE)(pUFM) + (pUFM)->loKernPair))

//
// UNIDRVINFO
//
// UNIDRVINFO is used to define printer specific information.
//

typedef struct _UNIDRVINFO
{
    DWORD   dwSize;
    DWORD   flGenFlags;
    WORD    wType;
    WORD    fCaps;
    WORD    wXRes;
    WORD    wYRes;
    short   sYAdjust;
    short   sYMoved;
    WORD    wPrivateData;
    short   sShift;
    INVOCATION SelectFont;
    INVOCATION UnSelectFont;
    WORD    wReserved[4];
}  UNIDRVINFO, *PUNIDRVINFO;

#define GET_SELECT_CMD(pUni)    \
        ((PCHAR)(pUni) + (pUni)->SelectFont.loOffset)
#define GET_UNSELECT_CMD(pUni)  \
        ((PCHAR)(pUni) + (pUni)->UnSelectFont.loOffset)

//
// flGenFlags
//

#define UFM_SOFT        0x00000001 // Softfont, thus needs downloading
#define UFM_CART        0x00000002 // This is a cartridge font
#define UFM_SCALABLE    0x00000004 // Font is scalable

//
// wType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2

//
// fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline via
                                        // FONTSIMU ATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec
                                        // for details

//
// EXTTEXTMETRIC
//
// The EXTTEXTMETRIC structure provides extended-metric information for a font.
// All the measurements are given in the specified units,
// regardless of the current mapping mode of the display context.
//

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

typedef struct _EXTTEXTMETRIC
    {
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC, *PEXTTEXTMETRIC;

#endif // _EXTTEXTMETRIC_


//
// WIDTHTABLE
//
// This data structure represents the character width table.
// This width table is a continuous GLYPHHANDLE base,
// not Unicode nor codepage/character code base.
// GLYPHANDLE information is in the GLYPHDATA.
//

typedef struct _WIDTHRUN
{
    WORD    wStartGlyph;       // index of the first glyph handle
    WORD    wGlyphCount;       // number of glyphs covered
    DWORD   loCharWidthOffset; // glyph width table
} WIDTHRUN, *PWIDTHRUN;

typedef struct _WIDTHTABLE
{
    DWORD   dwSize;        // the size of this structure including every run
    DWORD   dwRunNum;      // the number of widthrun
    WIDTHRUN WidthRun[1];  // width run array
} WIDTHTABLE, *PWIDTHTABLE;

//
// The array has wGlyphCount elements and each element is the char width
// for a single glyph. The first width corresponds to glyph index wStartGlyph
// and so on. The byte offset is relative to the beginning of WIDTHTABLE
// structure and must be WORD-aligned.
// In case of Western device font, proportional font has all varibal pitch
// characters. This means that dwRunNum is set to 1 and loCharWidthOffset
// would be an offset from the top of WIDTHTABLE to a width vector of all
// characters.
// In case of Far Eastern device font, basically IFIMETRICS.fwdAveCharWidth and
// IFIMETRICS.fwdMaxCharWidth are used for single byte and double byte character
// width. If a font is proportional, a UFM has a WIDTHTABLE which represents
// only the proportional pitch characters. Other characters use fdwAveCharWidth
// and fwdMaxCharInc for single and double byte characters.
//

//
// KERNDATA
// This data structure represents kerning pair information.
// This kerning pair table is a Unicode base.
//

typedef struct _KERNDATA
{
    DWORD dwSize;               // the size of this structure including array
    DWORD dwKernPairNum;        // the number of kerning pair
    FD_KERNINGPAIR KernPair[1]; // FD_KERNINGPAIR array
} KERNDATA, *PKERNDATA;

#endif //_FMNEWFM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\fmoldrle.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fmoldrle.h

Abstract:

    NT4.0 RASDD RLE resource header

Environment:

    Windows NT printer drivers

Revision History:

    11/08/96 -eigos-
        Created it.

--*/

#ifndef _FMOLDRLE_H_
#define _FMOLDRLE_H_

//
//   The following structure represents the layout of this data in the
//  resource.  References to addresses are actually stored as offsets.
//  Basically this is a small amount of header data coupled with the
//  standard GDI  FD_GLYPHSET structures.   These latter require a little
//  manipulation before being returned to GDISRV.
//
//  POINTS OF INTEREST:
//    The first 4 bytes of this structure match the Win 3.1 CTT layout.
//  The reason for this is to allow us to verify that we have an NT
//  format structure, rather than a Win 3.1 layout.  This is also helped
//  by using a different range for the wType field.  As well,  the
//  CTT chFirstChar and chLastChar fields are set to have chLastChar <
//  chFirstChar,  which must not happen with Win 3.1.
//
//  The FD_GLYPHSET structure contains POINTERS.  These are stored in
//  the resource as offsets to the beginning of the resource,  and will
//  need to be translated at run time.  When this resource is passed
//  to GDISRV,  the FD_GLYPHSET information will be allocated from the
//  heap,  and all pointers will have the offsets converted to real
//  addresses.  That way we manage to keep the resource data as a resource,
//  but we pass addresses to GDISRV.
//

#define RLE_MAGIC0    0xfe
#define RLE_MAGIC1    0x78

typedef  struct
{
    WORD   wType;             /* Format of data */
    BYTE   bMagic0;           /* chFirstChar in CTT data */
    BYTE   bMagic1;           /* chLastChar in CTT data */
    DWORD  cjThis;            /* Number of bytes in this resource */
    WORD   wchFirst;          /* First glyph index */
    WORD   wchLast;           /* Last glyph index */
    FD_GLYPHSET  fdg;         /* The actual GDI desired information  */
}  NT_RLE;

//
//
//
typedef struct
{
    WCHAR   wcLow;
    USHORT  cGlyphs;
    DWORD   dwOffset_phg;
} WCRUN_res;

typedef struct
{
    WORD  wType;
    BYTE  bMagic0;
    BYTE  bMagic1;
    DWORD cjThis;

    WORD  wchFirst;
    WORD  wchLast;

    //
    // FD_GLYPHSET
    //
    ULONG fdg_cjThis;

    FLONG fdg_flAccel;

    ULONG fdg_cGlyphSupported;
    ULONG fdg_cRuns;
    WCRUN_res fdg_wcrun_awcrun[1];
} NT_RLE_res;

//
//    Values for the wType field above.  These control the interpretation
//  of the contents of the HGLYPH fields in the FD_GLYPHSET structure.
//
//  This is a data how many RLE file has each type of CTT.
//  Type          Number
//  RLE_DIRECT    67
//  RLE_PAIRED    40
//  RLE_L_OFFSET  0
//  RLE_LI_OFFSET 73
//  RLE_OFFSET    0
//


#define RLE_DIRECT    10     /*  Index + 1 or 2 data bytes */
#define RLE_PAIRED    11     /*  Index plus 2 bytes,  overstruck */
#define RLE_L_OFFSET  12     /*  Length + 3 byte offset to data */
#define RLE_LI_OFFSET 13     /*  Length + Index + 2 byte Offset */
#define RLE_OFFSET    14     /*  Offset to (length; data) */

//
//   Note that for RLE_DIRECT and RLE_PAIRED,  each HGLYPH consists of
//  2 WORDS:  the low WORD is the byte/bytes to send to the printer, the
//  high WORD is the linear index of this glyph.  Linear index starts at
//  0 for the first, and increments by one for every glyph in the font.
//  It is used to access width tables.
//
//    For RLE_L_OFFSET,  the high byte is the length of data to send to
//  the printer,  the low 24 bits are the offset (relative to start of
//  resource data) to the data,  which is WORD aligned,  and contains
//  a WORD with the index followed by the data.  The length byte does NOT
//  include the index WORD.
//
//     For RLE_LI_OFFSET,  the high byte contains a length, the next
//  lower byte contains a length,  and the bottom WORD contains the
//  offset to the actual data in the file.
//

typedef  struct
{
    BYTE   b0;         /* First (only) data byte to send to printer */
    BYTE   b1;         /* Second byte: may be null,  may be overstruck */
    WORD   wIndex;     /* Index to width tables */
} RD;                  /* Layout for RLE_DIRECT,  RLE_PAIRED */


typedef  struct
{
    WORD    wOffset;   /* Offset to (length, data) in resource */
    BYTE    bIndex;    /* Index to width tables */
    BYTE    bLength;   /* Length of data item */
} RLI;                  /* Layout for RLE_LI_OFFSET  */


typedef  struct
{
    BYTE   b0;      /* First (only) data byte */
    BYTE   b1;      /* Optional second byte */
    BYTE   bIndex;  /* Index to width tables */
    BYTE   bLength; /* Length byte */
} RLIC;                 /* Compact format for RLI - no offset */


typedef  union
{
    RD      rd;     /* Direct/overprint format */
    RLI     rli;    /* Short offset format: 3 byte offset + 1 byte length */
    RLIC    rlic;   /* The data format for 1 or 2 byte entries */
    HGLYPH  hg;     /* Data as an HGLYPH */
}  UHG;

#endif // _FMOLDRLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\palette.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

        pdev.h

Abstract:

        Unidrv PDEV and related infor header file.

Environment:

        Windows NT Unidrv driver

Revision History:

        dd-mm-yy -author-
                description

--*/

#ifndef _PALETTE_H_
#define _PALETTE_H_


#define PALETTE_MAX 256

typedef  struct _PAL_DATA {

    INT         iWhiteIndex;             // Index for white entry (background)
    INT         iBlackIndex;             // Index for black entry (background)
    WORD        wPalGdi;                 // Number of colors in GDI palette
    WORD        wPalDev;                 // Number of colors in printer palette
    WORD        fFlags;                  // Various Bit Flags.
    WORD        wIndexToUse;             // Progammable index
    ULONG       *pulDevPalCol;           // Device Palette entry, only in planer mode.
    HPALETTE    hPalette;                // Palette Handle
    ULONG       ulPalCol[ PALETTE_MAX ]; // GDI Palette enties
} PAL_DATA;

//
// Macro Definitions
//

#define     PALETTE_SIZE_DEFAULT        2
#define     PALETTE_SIZE_8BIT           256
#define     PALETTE_SIZE_24BIT          8
#define     PALETTE_SIZE_4BIT           16
#define     PALETTE_SIZE_3BIT           8
#define     PALETTE_SIZE_1BIT           2
#define     RGB_BLACK_COLOR             0x00000000
#define     RGB_WHITE_COLOR             0x00FFFFFF
#define     INVALID_COLOR               0xFFFFFFFF
#define     INVALID_INDEX               0xFFFF

//fMode Flags
#define     PDF_DOWNLOAD_GDI_PALETTE        0x0001
#define     PDF_PALETTE_FOR_24BPP           0x0002
#define     PDF_PALETTE_FOR_8BPP            0x0004
#define     PDF_PALETTE_FOR_4BPP            0x0008
#define     PDF_PALETTE_FOR_1BPP            0x0010
#define     PDF_USE_WHITE_ENTRY             0x0020
#define     PDF_DL_PAL_EACH_PAGE            0x0040
#define     PDF_DL_PAL_EACH_DOC             0x0080
#define     PDF_PALETTE_FOR_8BPP_MONO       0x0100
#define     PDF_PALETTE_FOR_OEM_24BPP       0x0200

/* defines for color manipulation    */
#define RED_VALUE(c)   ((BYTE) c & 0xff)
#define GREEN_VALUE(c) ((BYTE) (c >> 8) & 0xff)
#define BLUE_VALUE(c)  ((BYTE) (c >> 16) & 0xff)


#endif // !_PALETTE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\mini.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    mini.h

Abstract:

    Minidrv related header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _MINI_H_
#define _MINI_H_

typedef struct _MINIPAPERFORMAT {

    //
    // All paper units are in Master units
    //

    SIZEL       szPaper;                        // Physical size of paper selected, in text resolution
    SIZEL       szImageArea;                    // Imageable area of paper
    POINT       ptImgOrigin;                    // X, Y origin of where image area starts
    POINT       ptPrinterOffset;                // X, Y offset to printer cursor position

} MINIPAPERFORMAT, *PMINIPAPERFORMAT;


typedef struct {
    DWORD       fGeneral;           /* Misc. flags for RASDD use*/
    DWORD       fMGeneral;          /* Misc. flags for minidriver use*/
    short       iOrient;            /* DMORIENT_LANDSCAPE else portrait */
    WORD        fColorFormat;       /* color flags DEVCOLOR: */
    short       sDevPlanes;         /* # of planes in the device color model, */
    short       sBitsPixel;         /* Bits per pixel  - if Pixel model */
    int         iLookAhead;         /* Look ahead region: DeskJet type */
    int         iyPrtLine;          /* Current Y printer cursor position */
    MINIPAPERFORMAT minipf;         /* paper format structure */
    SIZEL       szlPage;            /* Whole page, in graphics units */
    SIZEL       szlBand;            /* Size of banding region, if banding */
    BYTE        *pMemBuf;            /* Pointer to buffer for minidriver use (rasdd frees) */
    int         iMemReq;            /* Minidriver needs some memory */
    int         ixgRes;             /* Resolution, x graphics */
    int         iygRes;             /* Ditto, y */
    int         iModel;             /* index into the MODELDATA array. */
    int         iCompMode;          /* Which compression mode in use */
    short       sImageControl;       /* Index of Image Control in Use */
    short       sTextQuality;        /* Index of Text Quality in Use */
    short       sPaperQuality;       /* Index of Paper Quality in Use */
    short       sPrintDensity;       /* Index of Print Density in Use */
    short       sColor;              /* Index of DevColor Struct in Use */
    WORD        wReserved;           /* Alignment of struct */
    DWORD       dwMReserved[16];     /* Reserved for minidriver use */
    DWORD       dwReserved[16];      /* Reserved for future RASDD use */
} MDEV;

typedef MDEV *PMDEV;


typedef struct{
            MDEV *pMDev;
}
M_UD_PDEV;

#endif  // !_MINI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\oemkm.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    oemkm.h

Abstract:

    Header file to support kernel mode OEM plugins

Environment:

        Windows NT Universal Printer driver (UNIDRV)

Revision History:

        03/28/97 -zhanw-
                Adapted from Pscript driver.

--*/


#ifndef _OEMKM_H_
#define _OEMKM_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <printoem.h>
#include "oemutil.h"


//
// Information about OEM hooks
//

typedef struct _OEM_HOOK_INFO
{
    OEMPROC             pfnHook;        // function address of the hook
    POEM_PLUGIN_ENTRY   pOemEntry;      // which OEM plugin hooked it
} OEM_HOOK_INFO, *POEM_HOOK_INFO;

//
// This macro should be placed near the beginning of every
// DDI entrypoint which can be hooked by OEM plugin
//

#define HANDLE_OEMHOOKS(pdev, ep, pfnType, resultType, args) \
        if ((pdev)->pOemHookInfo != NULL && \
            (pdev)->pOemHookInfo[ep].pfnHook != NULL && \
            (pdev)->dwCallingFuncID != ep) \
        { \
            resultType result; \
            DWORD      dwCallerFuncID;\
            dwCallerFuncID = (pdev)->dwCallingFuncID;\
            (pdev)->dwCallingFuncID = ep; \
            (pdev)->devobj.hOEM = ((pdev)->pOemHookInfo[ep].pOemEntry)->hInstance; \
            (pdev)->devobj.pdevOEM = ((pdev)->pOemHookInfo[ep].pOemEntry)->pParam; \
            (pdev)->devobj.pOEMDM = ((pdev)->pOemHookInfo[ep].pOemEntry)->pOEMDM; \
            result = ((pfnType) (pdev)->pOemHookInfo[ep].pfnHook) args; \
            (pdev)->dwCallingFuncID = dwCallerFuncID; \
            return result; \
        }

//
// Macros used to call an entrypoint for all OEM plugins
//

#define START_OEMENTRYPOINT_LOOP(pdev) \
        { \
            DWORD _oemCount = (pdev)->pOemPlugins->dwCount; \
            POEM_PLUGIN_ENTRY pOemEntry = (pdev)->pOemPlugins->aPlugins; \
            for ( ; _oemCount--; pOemEntry++) \
            { \
                if (pOemEntry->hInstance == NULL) continue; \
                (pdev)->devobj.hOEM    = pOemEntry->hInstance; \
                (pdev)->devobj.pdevOEM = pOemEntry->pParam; \
                (pdev)->devobj.pOEMDM = pOemEntry->pOEMDM;

#define END_OEMENTRYPOINT_LOOP \
            } \
        }

//
// Get information about OEM plugins associated with the current device
// Load them into memory and call OEMEnableDriver for each of them
//

typedef struct _PDEV PDEV;

#ifdef WINNT_40

PVOID
DrvMemAllocZ(
    ULONG   ulSize
    );

VOID
DrvMemFree(
    PVOID   pMem
    );


LONG
DrvInterlockedIncrement(
    PLONG pRef
    );

LONG
DrvInterlockedDecrement(
    PLONG  pRef
    );

#endif //WINNT_40


BOOL
BLoadAndInitOemPlugins(
    PDEV    *pPDev
    );

// Constant flag bits for OEM_PLUGIN_ENTRY.dwFlags field

#define OEMENABLEDRIVER_CALLED  0x0001
#define OEMENABLEPDEV_CALLED    0x0002

//
// Unload OEM plugins and free all relevant resources
//

VOID
VUnloadOemPlugins(
    PDEV    *pPDev
    );

#define FIX_DEVOBJ(pPDev, ep) \
    { \
        (pPDev)->devobj.pdevOEM = (pPDev)->pOemHookInfo[ep].pOemEntry->pParam; \
        (pPDev)->devobj.pOEMDM = (pPDev)->pOemHookInfo[ep].pOemEntry->pOEMDM; \
        (pPDev)->pOemEntry = (PVOID)((pPDev)->pOemHookInfo[ep].pOemEntry); \
    } \


//
// Provide OEM plugins access to driver private settings
//

BOOL
BGetDriverSettingForOEM(
    PDEV    *pPDev,
    PCSTR   pFeatureKeyword,
    PVOID   pOutput,
    DWORD   cbSize,
    PDWORD  pcbNeeded,
    PDWORD  pdwOptionsReturned
    );

BOOL
BSetDriverSettingForOEM(
    PDEVMODE    pdm,
    PTSTR       pPrinterName,
    PCSTR       pFeatureKeyword,
    PCSTR       pOptionKeyword
    );




//
// Unidrv specific COM wrappers
//

//
// Method for getting the implemented method.
// Returns S_OK if the given method is implemneted.
// Returns S_FALSE if the given method is notimplemneted.
//

HRESULT HComGetImplementedMethod(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PSTR  pMethodName
    );


//
// OEMDriverDMS - UNIDRV only,
//

HRESULT HComDriverDMS(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PVOID                 pDevObj,
    PVOID                 pBuffer,
    WORD                  cbSize,
    PDWORD                pcbNeeded
    );

//
// OEMCommandCallback - UNIDRV only,
//

HRESULT HComCommandCallback(
    POEM_PLUGIN_ENTRY     pOemEntry,
    PDEVOBJ               pdevobj,
    DWORD                 dwCallbackID,
    DWORD                 dwCount,
    PDWORD                pdwParams,
    OUT INT               *piResult
    ) ;


//
// OEMImageProcessing - UNIDRV only,
//

HRESULT HComImageProcessing(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pSrcBitmap,
    PBITMAPINFOHEADER       pBitmapInfoHeader,
    PBYTE                   pColorTable,
    DWORD                   dwCallbackID,
    PIPPARAMS               pIPParams,
    OUT PBYTE               *ppbResult
    );

//
// OEMFilterGraphics - UNIDRV only,
//

HRESULT HComFilterGraphics(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pBuf,
    DWORD                   dwLen
    );

//
// OEMCompression - UNIDRV only,
//

HRESULT HComCompression(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pInBuf,
    PBYTE                   pOutBuf,
    DWORD                   dwInLen,
    DWORD                   dwOutLen,
    OUT INT                 *piResult
    );

//
// OEMHalftone - UNIDRV only
//

HRESULT HComHalftonePattern(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PBYTE                   pHTPattern,
    DWORD                   dwHTPatternX,
    DWORD                   dwHTPatternY,
    DWORD                   dwHTNumPatterns,
    DWORD                   dwCallbackID,
    PBYTE                   pResource,
    DWORD                   dwResourceSize
    ) ;

//
// OEMMemoryUsage - UNIDRV only,
//

HRESULT HComMemoryUsage(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    POEMMEMORYUSAGE         pMemoryUsage
    );

//
// OEMTTYGetInfo - UNIDRV only
//

HRESULT HComTTYGetInfo(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    DWORD                   dwInfoIndex,
    PVOID                   pOutputBuf,
    DWORD                   dwSize,
    DWORD                   *pcbcNeeded
    );
//
// OEMDownloadFontheader - UNIDRV only
//

HRESULT HComDownloadFontHeader(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    );

//
// OEMDownloadCharGlyph - UNIDRV only
//

HRESULT HComDownloadCharGlyph(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    HGLYPH                  hGlyph,
    PDWORD                  pdwWidth,
    OUT DWORD               *pdwResult
    );


//
// OEMTTDownloadMethod - UNIDRV only
//

HRESULT HComTTDownloadMethod(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    OUT DWORD               *pdwResult
    );

//
// OEMOutputCharStr - UNIDRV only
//

HRESULT HComOutputCharStr(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    DWORD                   dwType,
    DWORD                   dwCount,
    PVOID                   pGlyph
    );

//
// OEMSendFontCmd - UNIDRV only
//


HRESULT HComSendFontCmd(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    PUNIFONTOBJ             pUFObj,
    PFINVOCATION            pFInv
    );

//
// OEMTextOutAsBitmap - UNIDRV only
//

HRESULT HComTextOutAsBitmap(
    POEM_PLUGIN_ENTRY       pOemEntry,
    SURFOBJ                 *pso,
    STROBJ                  *pstro,
    FONTOBJ                 *pfo,
    CLIPOBJ                 *pco,
    RECTL                   *prclExtra,
    RECTL                   *prclOpaque,
    BRUSHOBJ                *pboFore,
    BRUSHOBJ                *pboOpaque,
    POINTL                  *pptlOrg,
    MIX                     mix
    );

//
// OEMWritePrinter - UNIDRV only (Interface 2 only)
//

HRESULT HComWritePrinter(
    POEM_PLUGIN_ENTRY       pOemEntry,
    PDEVOBJ                 pdevobj,
    LPVOID                  pBuf,
    DWORD                   cbBuf,
    LPDWORD                 pcbWritten
    );

#ifdef __cplusplus
}
#endif

#endif  // !_OEMKM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\rasterif.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

        rasterif.h

Abstract:

        Interface between Control module and Render module

Environment:

        Windows NT Unidrv driver

Revision History:

        10/14/96 -amandan-
                Created

        01-17-97 -alvins-
                Added definition for bIsRegionWhite

        mm-dd-yy -author-
                description

--*/


#ifndef _RASTERIF_H_
#define _RASTERIF_H_


BOOL
RMInit (
        PDEV    *pPDev,
        DEVINFO *pDevInfo,
        GDIINFO *pGDIInfo
        );

typedef struct _RMPROCS {

        BOOL
        (*RMStartDoc) (
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL
        (*RMStartPage) (
                SURFOBJ *pso
                );

        BOOL
        (*RMSendPage)(
                SURFOBJ *pso
                );

        BOOL
        (*RMEndDoc)(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL
        (*RMNextBand)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*RMStartBanding)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*RMResetPDEV)(
                PDEV  *pPDevOld,
                PDEV  *pPDevNew
                );

        BOOL
        (*RMEnableSurface)(
                PDEV *pPDev
                );

        VOID
        (*RMDisableSurface)(
                PDEV *pPDev
                );

        VOID
        (*RMDisablePDEV)(
                PDEV *pPDev
                );

        BOOL
        (*RMCopyBits)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        BOOL
        (*RMBitBlt)(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL
        (*RMStretchBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

        ULONG
        (*RMDitherColor)(
                PDEV    *pPDev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL
        (*RMStretchBltROP)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );
        BOOL
        (*RMPaint)(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL
        (*RMPlgBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                POINTFIX   *pptfx,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

}RMPROCS, * PRMPROCS;

BOOL
RMInitDevicePal(
    PDEV *pPDev,
    PAL_DATA *pPal
    );

#endif  // !_RASTERIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\render.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    pdev.h

Abstract:

    Unidrv PDEV and related infor header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    dd-mm-yy -author-
        description

--*/

#ifndef _RENDER_H_
#define _RENDER_H_


#define PALETTE_MAX 256

typedef  struct _PAL_DATA {

    INT     iPalGdi;                    // Number of colors in GDI palette
    INT     iPalDev;                    // Number of colors in printer palette
    INT     iWhiteIndex;                // Index for white entry (background)
    INT     iBlackIndex;                // Index for black entry (background)
    ULONG   ulPalCol[ PALETTE_MAX ];    // Palette enties!
} PAL_DATA;


#endif // !_RENDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\fontif.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    fontif.h

Abstract:

    Interface between Control module and Font module

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    dd-mm-yy -author-
        description

--*/


#ifndef _FONTIF_H_
#define _FONTIF_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL
FMInit (
    PDEV    *pPDev,
    DEVINFO *pDevInfo,
    GDIINFO *pGDIInfo
    );

typedef struct _FMPROCS {

    BOOL
    (*FMStartDoc) (
        SURFOBJ *pso,
        PWSTR   pDocName,
        DWORD   jobId
        );

    BOOL
    (*FMStartPage) (
        SURFOBJ *pso
        );

    BOOL
    (*FMSendPage)(
        SURFOBJ *pso
        );

    BOOL
    (*FMEndDoc)(
        SURFOBJ *pso,
        FLONG   flags
        );

    BOOL
    (*FMNextBand)(
        SURFOBJ *pso,
        POINTL *pptl
        );

    BOOL
    (*FMStartBanding)(
        SURFOBJ *pso,
        POINTL *pptl
        );

    BOOL
    (*FMResetPDEV)(
        PDEV  *pPDevOld,
        PDEV  *pPDevNew
        );

    BOOL
    (*FMEnableSurface)(
        PDEV *pPDev
        );

    VOID
    (*FMDisableSurface)(
        PDEV *pPDev
        );

    VOID
    (*FMDisablePDEV)(
        PDEV *pPDev
        );


    BOOL
    (*FMTextOut)(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix
        );


    PIFIMETRICS
    (*FMQueryFont)(
        PDEV    *pPDev,
        ULONG_PTR   iFile,
        ULONG   iFace,
        ULONG_PTR *pid
        );

    PVOID
    (*FMQueryFontTree)(
        PDEV    *pPDev,
        ULONG_PTR   iFile,
        ULONG   iFace,
        ULONG   iMode,
        ULONG_PTR *pid
        );

    LONG
    (*FMQueryFontData)(
        PDEV       *pPDev,
        FONTOBJ    *pfo,
        ULONG       iMode,
        HGLYPH      hg,
        GLYPHDATA  *pgd,
        PVOID       pv,
        ULONG       cjSize
        );

    ULONG
    (*FMFontManagement)(
        SURFOBJ *pso,
        FONTOBJ *pfo,
        ULONG   iMode,
        ULONG   cjIn,
        PVOID   pvIn,
        ULONG   cjOut,
        PVOID   pvOut
        );

    BOOL
    (*FMQueryAdvanceWidths)(
        PDEV    *pPDev,
        FONTOBJ *pfo,
        ULONG   iMode,
        HGLYPH *phg,
        PVOID  *pvWidths,
        ULONG   cGlyphs
        );

    ULONG
    (*FMGetGlyphMode)(
        PDEV    *pPDev,
        FONTOBJ *pfo
        );


}FMPROCS, * PFMPROCS;

/* Font Interface functions for Raster Module */

INT
ILookAheadMax(
    PDEV    *pPDev,
    INT     iyVal,
    INT     iLookAhead
    );

BOOL
BDelayGlyphOut(
    PDEV  *pPDev,
    INT    yPos
    );

VOID
VResetFont(
    PDEV   *pPDev
    );

/* Font Interface functions for OEM Module */

BOOL
FMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlBrushOrg,
    MIX         mix
    );

#ifdef __cplusplus
}
#endif

#endif  // !_FONTIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\state.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    state.h

Abstract:

    Graphic state tracking header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    05/14/96 -amandan-
        Created

--*/

#ifndef _STATE_H_
#define _STATE_H_

typedef struct _DEVBRUSH{

    DWORD       dwBrushType;            // One of BRUSH_XXX types listed above
    INT         iColor;                 // Color of the brush, depending on the type
                                        // it could be one of the following:
                                        // 2. RGB Color
                                        // 3. User define pattern ID
                                        // 4. Shading percentage
    PVOID       pNext;                  // Pointed to next brush in list

}DEVBRUSH, *PDEVBRUSH;

typedef struct _GSTATE {

    //
    // Current Brush Information
    //

    DEVBRUSH    CurrentBrush;
    PDEVBRUSH   pRealizedBrush;
    PWORD       pCachedPatterns;


} GSTATE, * PGSTATE;

PDEVBRUSH
GSRealizeBrush(
    IN OUT  PDEV        *pPDev,
    IN      SURFOBJ     *pso,
    IN      BRUSHOBJ    *pbo
    );

BOOL
GSSelectBrush(
    IN      PDEV        *pPDev,
    IN      PDEVBRUSH   pDevBrush
    );

VOID
GSResetBrush(
    IN OUT  PDEV        *pPDev
    );

VOID
GSUnRealizeBrush(
    IN      PDEV    *pPDev
    );


#endif // _STATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\pdev.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    pdev.h

Abstract:

    Unidrv PDEV and related info header file.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    03/31/97 -zhanw-
        Added OEM customization support

--*/

#include "oemkm.h"
#include "state.h"

#ifndef _PDEV_H_
#define _PDEV_H_

#define CCHNAME         32                  // length of port names.
#define CCHMAXBUF       128                 // size of local buffer
#define CCHSPOOL        4096                // Size of spool buffer
#define PDEV_ID         0x72706476          // "rpdv" in ASCII

#define BBITS           8                   // Bits per BYTE
#define WBITS           (sizeof( WORD ) * BBITS)
#define WBYTES          (sizeof( WORD ))
#define DWBITS          (sizeof( DWORD ) * BBITS)
#define DWBYTES         (sizeof( DWORD ))

#define NOOCD           -1                  // Command does not exist

#define MIN(x, y)   ((x) < (y) ? (x) : (y))
#define MAX(x, y)   ((x) < (y) ? (y) : (x))

//
// Possible personality types
//
typedef enum _EPERSONALITY {
    kNoPersonality,
    kPCLXL,
    kHPGL2,
    kPCLXL_RASTER,
} EPERSONALITY;

//
// SHRINK_FACTOR is used to reduce the number of scan lines in the
// drawing surface bitmap when we cannot create a full sized version.
// Each iteration of the "try this size" loop  will reduce the number
// of scan lines by this factor.
//

#define SHRINK_FACTOR     2                 // Bitmap reduction size
#define ONE_MBYTE         (1024L * 1024L)
#define MAX_SIZE_OF_BITMAP (6L * ONE_MBYTE)
#define MIN_SIZE_OF_BITMAP (ONE_MBYTE / 2L)
#define MAX_COLUMM        8
#define LINESPERBLOCK     32                // scans per bitmap block for erasing surface
#define MAX_NUM_RULES     256
//
//  OUTPUTCTL is included in PDEVICE for controlling the state of the output
//  device during banding
//

typedef struct _OUTPUTCTL {

    POINT           ptCursor;        // current cursor position (printer's CAP)
                                     // (in master units), use this for
                                     // absolute x,y move cmds
    POINT           ptRelativePos;   // The desired relative cursor position,
                                     // relative to current
                                     // cursor position
    POINT           ptAbsolutePos;   // The absolute cursor postion
    DWORD           dwMode;          // flags for controling printer state.
    LONG            lLineSpacing;    // last line spacing chosen
    ULONG           ulBrushColor;    // Current Brush Color.

    //
    // The following fields are initialized and update by
    // the Raster module
    //

    SHORT           sColor;                     // Last color chosen
    SHORT           sBytesPerPinPass;           // number of bytes per row of printhead.
    SHORT           sPad;                       // Padding for alignment

} OUTPUTCTL;

//
// flags for OUTPUTCTL.dwCursorMode
//

#define MODE_CURSOR_X_UNINITIALIZED  0x00000001
#define MODE_CURSOR_Y_UNINITIALIZED  0x00000002
#define MODE_CURSOR_UNINITIALIZED    0x00000003    // both X and Y
#define MODE_BRUSH_RESET_COLOR       0x00000004    // Reset the brush color by
                                                   // by sending the command.

typedef struct _PAPERFORMAT {
    //
    // All paper units are in Master units. All fields are in Portrait orientation.
    //

    SIZEL       szPhysSizeM;        // Physical size, in Portrait
    SIZEL       szImageAreaM;       // Imageable area of paper, in Portrait
    POINT       ptImageOriginM;     // X, Y origin of imageable area, in Portrait

} PAPERFORMAT, *PPAPERFORMAT;

typedef struct _SURFACEFORMAT {
    //
    // all fields in this structure are in the current orientation.
    // Fields end with 'M' are in master units; and those end with 'G' are in graphics
    // device units.

    POINT   ptPrintOffsetM;     // X, Y offset of image origin relative to cursor origin
    SIZEL   szPhysPaperG;
    SIZEL   szImageAreaG;
    POINT   ptImageOriginG;

} SURFACEFORMAT, * PSURFACEFORMAT;
//
// PDEVICE structure for Unidrv
//

typedef struct _PDEV {
    //
    // the first field must be DEVOBJ, defined in <printoem.h>.
    //
    DEVOBJ       devobj;        // the first field of DEVOBJ is the pointer
                                // to PDEV itself.
    //
    // General information
    //

    PVOID       pvStartSig;                     // Signature at the start
    ULONG       ulID;                           // For PDEV verification
    HANDLE      hUniResDLL;                     // Handle to resource DLL
    HBITMAP     hbm;                            // The bitmap handle from EngCreateBitmap
    HSURF       hSurface;                       // The surface handle from EngCreateDeviceSurface
    SURFOBJ     *pso;                           // Pointer to driver managed surface
    DWORD       fMode;                          // Device context flags
    DWORD       fMode2;				// Device context flags
    DWORD       fHooks;                         // Hook flag for EngAssociateSurface
    WINRESDATA  WinResData;                     // Struct for resource data loading
    //  WINRESDATA  localWinResData;                     //  references  unires.dll
    BOOL        bTTY;                           // Set if the printer is TTY
    PDRIVER_INFO_3  pDriverInfo3;               // pointer to DRIVER_INFO_3 structure
    DWORD       dwDelta;                        // Size of each columm for z-ordering fix
    PBYTE       pbScanBuf;                      // Array representing # of scan lines on the band
    PBYTE       pbRasterScanBuf;                // Array representing # of scan lines block on the band
#ifndef DISABLE_NEWRULES
    PRECTL      pbRulesArray;			// Array containing pseudo vector rectangles
    DWORD       dwRulesCount;			// Number of pseudo vector rectangles
#endif
    DWORD	dwHTPatSize;			// Size of halftone pattern
    PFORM_INFO_1    pSplForms;     //   Array of forms registered in forms database.
    DWORD       dwSplForms ;       //   Number of forms in the array.

    //
    // OEM info
    //
    POEM_PLUGINS    pOemPlugins;
    POEM_PLUGINS    pOemEntry;  //  the Plugin that supports the selected OEM entry point
    POEM_HOOK_INFO  pOemHookInfo;
    DWORD           dwCallingFuncID;
    PFN_OEMCommandCallback  pfnOemCmdCallback;  // cache the function ptr, if any

    //
    // Graphic State Info
    //

    GSTATE      GState;

    //
    // Personality
    //
    EPERSONALITY ePersonality;

    //
    // Memory related information
    //

    DWORD       dwFreeMem;                      // Memory available on printer

    //
    // Banding related information
    //

    BOOL        bBanding;                       // Flag to indicate banding
    INT         iBandDirection;                 // Banding direction
    SIZEL       szBand;                         // Dimensions of the band in Graphic units
    RECTL       rcClipRgn;                      // Clipping region
    //
    // Binary data related information
    //

    GPDDRIVERINFO *pDriverInfo;                 // Pointer to GPDDRVINFO
    RAWBINARYDATA *pRawData;                    // Pointer to RAWBINARYDATA
    INFOHEADER *pInfoHeader;                    // Pointer to INFOHEADER
    UIINFO      *pUIInfo;                       // Pointer to UIINFO
    PRINTERDATA PrinterData;                    // PRINTERDATA struct
    POPTSELECT  pOptionsArray;                  // Pointer to combined option array
    SHORT       sBitsPixel;                     // Bits per pixel selected, from COLORMODEEX

    PDWORD      arStdPtrs[SV_MAX];              // Array of PDWORD , where the
                                                // pointers points to the standard variables
    GLOBALS     * pGlobals;                     // Pointer to GLOBALS struct

    PCOMMAND    arCmdTable[CMD_MAX];            // Table containing pointers
                                                // to each predefined command index as
                                                // enumerated in gpd.h, CMDINDEX

    //
    // The following fields are use by the standard variable table.
    //

    //
    // Control module items
    //

    SHORT       sCopies;                        // SV_COPIES
                                                // SV_DESTX, SV_DESTY,
                                                // SV_DESTXREL, SV_DESTYREL,
                                                // SV_LINEFEED
                                                // are in OUTPUTCTL

                                                // SV_PHYSPAPERLENGTH, SV_PHYSPAPERWIDTH,
                                                // are in PAPERFORMAT

    DWORD       dwRop3;                         // SV_ROP3

                                                // SV_TEXTXRES , SV_TEXTYRES are
                                                // in ptTextRes

    DWORD  dwPageNumber ;  //  SV_PAGENUMBER   of a document - may not be accurate
						//  if multiple copies is simulated.
    //
    // Brush specific standard variables
    //

    DWORD       dwPatternBrushType;                // SV_PATTERNBRUSH_TYPE
    DWORD       dwPatternBrushID;                  // SV_PATTERNBRUSH_ID
    DWORD       dwPatternBrushSize;                // SV_PATTERNBRUSH_SIZE

    //
    // Palette specific standard variables.
    //

    DWORD       dwRedValue;                     // SV_REDVALUE
    DWORD       dwGreenValue;                   // SV_GREENVALUE
    DWORD       dwBlueValue ;                   // SV_BLUEVALUE
    DWORD       dwPaletteIndexToProgram;        // SV_PALETTEINDEXTOPROGRAM
    DWORD       dwCurrentPaletteIndex ;         // SV_CURRENTPALETTEINDEX



    //
    // Raster module items
    //

    DWORD       dwNumOfDataBytes;               // SV_NUMDATABYTES
    DWORD       dwWidthInBytes;                 // SV_WIDTHINBYTES
    DWORD       dwHeightInPixels;               // SV_HEIGHTINPIXELS
    DWORD       dwRectXSize;                    // SV_RECTXSIZE
    DWORD       dwRectYSize;                    // SV_RECTYSIZE
    DWORD       dwGrayPercentage;               // SV_GRAYPERCENT

    //
    // Font module items
    //

    DWORD       dwPrintDirection;               // SV_PRINTDIR
    DWORD       dwNextFontID;                   // SV_NEXTFONTID
    DWORD       dwNextGlyph;                    // SV_NEXTGLYPH
    DWORD       dwFontHeight;                   // SV_FONTHEIGHT
    DWORD       dwFontWidth;                    // SV_FONTWIDTH
    DWORD       dwFontMaxWidth;                    // SV_FONTMAXWIDTH
    DWORD       dwFontBold;                     // SV_FONTBOLD
    DWORD       dwFontItalic;                   // SV_FONTITALIC
    DWORD       dwFontUnderline;                // SV_FONTUNDERLINE
    DWORD       dwFontStrikeThru;               // SV_FONTSTRIKETHU
    DWORD       dwCurrentFontID;                // SV_CURRENTFONTID

    //
    // The following are the pointers to the options selected
    // as indicated in the pOptionsArray
    //

    PORIENTATION pOrientation;              // Pointer to ORIENTATION option
    PRESOLUTION pResolution;                // Pointer to RESOLUTION option
    PRESOLUTIONEX pResolutionEx;            // Pointer to RESOLUTIONEX option
    PCOLORMODE    pColorMode;               // Pointer to COLORMODE option
    PCOLORMODEEX  pColorModeEx;             // Pointer to COLORMODEEX option
    PDUPLEX     pDuplex;                    // Pointer to DUPLEX option
    PPAGESIZE   pPageSize;                  // Pointer to PAGESIZE option
    PPAGESIZEEX pPageSizeEx;                // Pointer to PAGESIZEEX option
    PINPUTSLOT  pInputSlot;                 // Pointer to INPUTSLOT option
    PMEMOPTION  pMemOption;                 // Pointer to MEMOPTION option
    PHALFTONING pHalftone;                  // Pointer to HALFTONING option
    PPAGEPROTECT  pPageProtect;             // Pointer to PAGEPROTECT option

//    PMEDIATYPE  pMediaType;               // Pointer to MEDIATYPE option
//    POPTION     pOutputBin;               // Pointer to OUTPUTBIN option
//    POPTION     pCollate;                 // Pointer to COLLATE option


    //
    // Text and Graphics Resolution
    //

    POINT       ptGrxRes;                       // Graphics resolution selected
    POINT       ptTextRes;                      // Text resolution selected
    POINT       ptGrxScale;                     // Scale between Master and Graphics Units
    POINT       ptDeviceFac;                    // Factor to convert from Device to Master Units

    //
    // UNIDRV devmode
    //

    PDEVMODE        pdm;                        // current devmode
    PUNIDRVEXTRA    pdmPrivate;                 // pointer to driver private portion

    //
    // Output Control Information, Paper Format and Palette
    //

    OUTPUTCTL       ctl;                        // State of the printer
    PAPERFORMAT     pf;                         // PAPERFORMAT struct
    SURFACEFORMAT   sf;                         // SURFACEFORMAT struct
    DWORD       fYMove;                         // Fields saved from looking
                                                // ast YMoveAttributes keyword
    PVOID       pPalData;                       // Pointer to PAL_DATA structure
    //
    // Spool buffer
    //

    INT        iSpool;                          // offset into the spool buffer
    PBYTE      pbOBuf;                          // Output buffer base address

    //
    // Text Specific Information
    //
    INT       iFonts;                          // Number of Device Fonts
    DWORD     dwLookAhead;                     // Look ahead region:DskJet type
    POINT     ptDefaultFont;                   // Default font width & height.
    PVOID     pFontPDev;                       // Font Module PDEV
    PVOID     pFontProcs;                      // Table of font functions
    PVOID     pFileList;                       // Pointer to Font File List

    //
    // Raster Specific Information
    //

    PVOID    pRasterPDEV;                      // Raster Module PDEV
    PVOID    pRasterProcs;                     // Table of raster functions

    //
    // Vector Specific Information
    //

    PVOID   pVectorPDEV;                       // Vector Module PDEV
    PVOID   pVectorProcs;                      // Table of vector functions
    DWORD   dwVMCallingFuncID;                 // ID of vector function.

    //
    // Temporary copies due to the fact that we unload
    // the binary data at DrvEnablePDEV and reloads it at
    // DrvEnableSurface
    //

    DWORD   dwMaxCopies;
    DWORD   dwMaxGrayFill;
    DWORD   dwMinGrayFill;
    CURSORXAFTERRECTFILL    cxafterfill;    // *CursorXAfterRectFill
    CURSORYAFTERRECTFILL    cyafterfill;    // *CursorYAfterRectFill

    //
    // DMS
    //
    DWORD dwDMSInfo;

    PVOID   pvEndSig;                       // Signature at the end

} PDEV, *PPDEV;

#define SW_DOWN     0
#define SW_LTOR     1
#define SW_RTOL     2
#define SW_UP     4    //  enum bottom band first and work towards top

//
// Flags for fMode
//

#define  PF_ABORTED             0x00000001 // Output aborted
#define  PF_DOCSTARTED          0x00000002 // Document Started
#define  PF_DOC_SENT            0x00000004 // Indicates start doc cmds sent,
                                           // this flag is  propagated during a resetPDEV.
#define  PF_PAGEPROTECT         0x00000008 // PageProtection

// Set in DrvResetPDEV for not sending  cmds  that cause page eject.
#define  PF_SEND_ONLY_NOEJECT_CMDS     0x00000010
#define  PF_NOEMFSPOOL          0x00000020 // No EMF Spooling
#define  PF_CCW_ROTATE90        0x00000040 // Rotation is 90 degress ccw
#define  PF_ROTATE              0x00000080 // We are doing L->P rotation ourselves since device cannot rotate grx data
#define  PF_NO_RELX_MOVE        0x00000100 // No relative X move cmd
#define  PF_NO_RELY_MOVE        0x00000200 // No relative Y move cmd
#define  PF_NO_XMOVE_CMD        0x00000400 // No X move cmd
#define  PF_NO_YMOVE_CMD        0x00000800 // No Y move cmd
#define  PF_FORCE_BANDING       0x00001000 // Force banding
#define  PF_ENUM_TEXT           0x00002000 // This is a delayed Text Band
#define  PF_REPLAY_BAND         0x00004000 // Enumerate the same band again
#define  PF_ENUM_GRXTXT         0x00008000 // This is a Graphics/Text Band.
#define  PF_RECT_FILL           0x00010000 // device support rect area fill
#define  PF_RESTORE_WHITE_ENTRY 0x00020000 // Restore palette Last entry to original color.
#define  PF_ANYCOLOR_BRUSH      0x00040000 // Device supports programmable color brush.
#define  PF_DOWNLOADED_TEXT     0x00080000 // To indicate we have seen downloaded or device font for the page
#define  PF_WHITEBLACK_BRUSH    0x00100000 // To indicate white/black brush selection cmds
#define  PF_DOWNLOAD_PATTERN    0x00200000 // To indicate support user defined download patter
#define  PF_SHADING_PATTERN     0x00400000 // To indicate support pattern shading
#define  PF_SURFACE_USED        0x00800000 // Indicates the bitmap surface has been used
#define  PF_RECTWHITE_FILL      0x01000000
#define  PF_SURFACE_ERASED      0x02000000 // Indicates entire surface has been cleared

#define  PF_RESELECTFONT_AFTER_GRXDATA  0x04000000 // Reset font after Graphics
#define  PF_RESELECTFONT_AFTER_XMOVE    0x08000000 // Reset Font after XMOVE
#define  PF_RESELECTFONT_AFTER_FF       0x10000000 // Reset Font after FF
#define  PF_DEVICE_MANAGED              0x20000000 // Indicates a device surface driver

#define  PF_JOB_SENT     0x40000000 // Indicates job cmds sent, this flag is
                                    // propagated during a resetPDEV.
#define  PF_SINGLEDOT_FILTER    0x80000000 // Enables filter to expand single pixels

//
// Flags for fMode2
//

#define  PF2_MIRRORING_ENABLED         0x00000001 // Indicates to mirror output raster
#define  PF2_WRITE_PRINTER_HOOKED      0x00000002 // One of plug-ins hooks WritePrinter
#define  PF2_CALLING_OEM_WRITE_PRINTER 0x00000004 // a call to an OEM WRitePrinter is in process
#define  PF2_PASSTHROUGH_CALLED_FOR_TTY 0x00000008// DrvEscape with passthrough
                                                  // is called for TTY drv.
                                                  // TTY driver.
#define  PF2_DRVTEXTOUT_CALLED_FOR_TTY 0x00000010 // DrvText is called for TTY.
#define  PF2_INVERTED_ROP_MODE         0x00000020 // Indicates ROPs should be inverted for CMY vs RGB
#define  PF2_WHITEN_SURFACE            0x00000040 // If you want psoDst to be Whitened when 
                                                  // psoSrc=STYPE_DEVICE, psoDst=STYPE_BITMAP 
                                                  // in DrvCopyBits
#define  PF2_SURFACE_WHITENED          0x00000080 // Just tells that surface has been whitened 
                                                  
                                                  
//
// Flags for fYMove
//

#define FYMOVE_FAVOR_LINEFEEDSPACING    0x00000001
#define FYMOVE_SEND_CR_FIRST            0x00000002

//
// MACROS
//

#define VALID_PDEV(pdev) \
        ((pdev) && ((pdev) == (pdev)->pvStartSig) && \
        ((pdev) == (pdev)->pvEndSig) && \
        ((pdev)->ulID == PDEV_ID))

#if DBG

#define ASSERT_VALID_PDEV(pdev) ASSERT(VALID_PDEV(pdev))

#else   // ! DBG

#define ASSERT_VALID_PDEV(pdev) \
    if (!(VALID_PDEV(pdev)))  \
    {   \
        SetLastError(ERROR_INVALID_PARAMETER); \
        return 0;   \
    }

#endif  // end !DBG

//
// checks for device managed surface
//
#define DRIVER_DEVICEMANAGED(pPDev) ((pPDev->fMode) & PF_DEVICE_MANAGED)


#ifndef USERMODE_DRIVER

extern HSEMAPHORE ghUniSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghUniSemaphore
#define INIT_CRITICAL_SECTION()     ghUniSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghUniSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghUniSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghUniSemaphore)
#define IS_VALID_DRIVER_SEMAPHORE() (ghUniSemaphore ? TRUE : FALSE)

#else // USERMODE_DRIVER

extern CRITICAL_SECTION gUniCritSection;

#define DECLARE_CRITICAL_SECTION    CRITICAL_SECTION gUniCritSection
#define INIT_CRITICAL_SECTION()     InitializeCriticalSection(&gUniCritSection)
#define ENTER_CRITICAL_SECTION()    EnterCriticalSection(&gUniCritSection)
#define LEAVE_CRITICAL_SECTION()    LeaveCriticalSection(&gUniCritSection)
#define DELETE_CRITICAL_SECTION()   DeleteCriticalSection(&gUniCritSection)

#endif // USERMODE_DRIVER


#endif  // !_PDEV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\uni16gpc.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    uni16gpc.h

Abstract:

    Universal printer driver specific resource header
    This file contains definitions for tables contained in the resource file
    of the Mini Drivers. It should be shared by both gentool and the
    generic library.

Environment:

    Windows NT printer drivers

Revision History:

    10/30/96 -eigos-
        Created it.

--*/

#ifndef _UNI16GPC_H_
#define _UNI16GPC_H_

//
//  The following definitions are  the resource IDs for the minidrivers.
//  These values are public,  since anyone producing minidrivers needs
//  them.
//

#define RC_TABLES      257
#define RC_FONT        258
#define RC_TRANSTAB    259

//
// DATAHDR is at the beginning of each Mini Driver, describes where the rest
// of the strcutures are, their size, count, etc.
//

typedef struct
{
    short   sOffset;     /* offset from the beginning of this resource  */
                         /* to obtain a table entry  */
    short   sLength;     /* length of each element in the table  */
    short   sCount;      /* number of elements in the table.  */
} HEADERENTRY;

//
// Index into array of header entry in DATAHDR
//

#define HE_MODELDATA       0
#define HE_RESOLUTION      1
#define HE_PAPERSIZE       2
#define HE_PAPERQUALITY    3
#define HE_PAPERSOURCE     4
#define HE_PAPERDEST       5
#define HE_TEXTQUAL        6
#define HE_COMPRESSION     7
#define HE_FONTCART        8
#define HE_PAGECONTROL     9
#define HE_CURSORMOVE      10
#define HE_FONTSIM         11
#define HE_COLOR           12
#define HE_RECTFILL        13
#define HE_DOWNLOADINFO    14

//
//normanh following need to be defined for GPC3
//

#define HE_RESERVED1       15
#define HE_RESERVED2       16
#define HE_RESERVED3       17
#define HE_RESERVED4       18
#define HE_RESERVED5       19
#define HE_RESERVED6       20
#define HE_RESERVED7       21
#define HE_RESERVED8       22

//
// derryd added for WDL release June 1995
//

#define HE_IMAGECONTROL    23
#define HE_PRINTDENSITY    24
#define HE_COLORTRC        25
#define HE_RESERVED12      26
#define HE_RESERVED13      27
#define HE_RESERVED14      28
#define HE_RESERVED15      29
#define MAXHE              30

#define MAXHE_GPC2         15 //for GPC2 compatibility

typedef struct
{
    short        sMagic;          /* Must be 0x7F00 */
    WORD         wVersion;        /* GPC file version # */
    POINTw       ptMaster;        /* Horizontal & Vertical Master Units  */
    DWORD        loHeap;          /* Offset from  DATAHDR to HEAP section */
    DWORD        dwFileSize;      /* Size of file in bytes */
    WORD         fTechnology;     /* Flags for special technologies */
    WORD         fGeneral;        /* Misc flags */
    char         rgchRes[10];     /* 10 bytes reserved */
    short        sMaxHE;          /* Header entry count (15 here) */
    HEADERENTRY  rghe[MAXHE];
} DATAHDR, *PDH;

#define LPDH    PDH               /* UNIDRV compatability */

//
//   The version field consists of two bytes.  The high byte is the major
//  number,  the low byte the minor number.  Version number checking
//  should take place against the high byte,  since this changes when
//  there is a significant structural change.  The minor number will
//  change with updated data only.
//

#define GPC_VERSION3          0x0300    // GPC file version 3
#define GPC_VERSION           0x0300    // current GPC file version #

#define VERSION_CHECK(x)     (((x) & 0xff00) <= GPC_VERSION)


//
// fTechnology--used as an ID, not a bitfield
//

#define GPC_TECH_DEFAULT       0   // Default technology
#define GPC_TECH_PCL4          1   // Uses PCL level 4 or above
#define GPC_TECH_CAPSL         2   // Uses CaPSL level 3 or above
#define GPC_TECH_PPDS          3   // Uses PPDS
#define GPC_TECH_TTY           4   // TTY printer--user configurable
#define GPC_TECH_DBCS          5   // Uses DBCS PDL printer

//
// fGeneral
//

#define GPC_GEN_PRIVATE_HELP    0x0001  // this driver has a private help
#define GPC_GEN_DRAFT_SINGLE    0x0002    // Only 1 font in draft mode


#ifndef _OCD_
#define _OCD_

//
// OCD are offsets into the heap to obtain a CD structure
//

typedef WORD       OCD;
typedef DWORD      LOCD;            /* double word offset to a CD  */
typedef WORD       OOCD;            /* offset to table of OCD's.  */
typedef OCD *      POCD;

#endif //_OCD_

//*****************************************************************************
//
// MODELDATA contains information describing the attributes and capabilities
// of a single printer model.
//
//*****************************************************************************

//
// MODELDATA.rgoi[] index values
//

#define MD_OI_FIRST           MD_OI_PORT_FONTS
#define MD_OI_PORT_FONTS      0
#define MD_OI_LAND_FONTS      1
#define MD_OI_RESOLUTION      2
#define MD_OI_PAPERSIZE       3
#define MD_OI_PAPERQUALITY    4
#define MD_OI_PAPERSOURCE     5
#define MD_OI_PAPERDEST       6
#define MD_OI_TEXTQUAL        7
#define MD_OI_COMPRESSION     8
#define MD_OI_FONTCART        9
#define MD_OI_COLOR          10
#define MD_OI_MEMCONFIG      11
#define MD_OI_MAX            12

//
// MODELDATA.rgoi2[] index values
//

#define MD_OI2_PENINFO      0
#define MD_OI2_IMAGECONTROL 1
#define MD_OI2_PRINTDENSITY 2
#define MD_OI2_COLORTRC     3
#define MD_OI2_RESERVED1    4
#define MD_OI2_MAX          5

//
//   MODELDATA.rgi[] index values
//

#define MD_I_PAGECONTROL      0
#define MD_I_CURSORMOVE       1
#define MD_I_FONTSIM          2
#define MD_I_RECTFILL         3
#define MD_I_DOWNLOADINFO     4
#define MD_I_VECTPAGE         5
#define MD_I_CAROUSEL         6
#define MD_I_LINEINFO         7
#define MD_I_BRUSHINFO        8
#define MD_I_VECTOUTPUT       9
#define MD_I_POLYVECTOUTPUT  10
#define MD_I_VECTSUPPORT     11
#define MD_I_RESERVED1       12
#define MD_I_RESERVED2       13
#define MD_I_RESERVED3       14
#define MD_I_RESERVED4       15
#define MD_I_MAX             16

//
// define some constants help uniform access of rgoi and rgoi2 arrays.
// When more indices are used in rgoi2 array, make sure to add new define's.
//

#define  MD_OI_OI2                 (MD_OI_MAX + MD_I_MAX)
#define  MD_OI_PENINFO             (MD_OI_OI2 + MD_OI2_PENINFO)
#define  MD_OI_IMAGECONTROL        (MD_OI_OI2 + MD_OI2_IMAGECONTROL)
#define  MD_OI_PRINTDENSITY        (MD_OI_OI2 + MD_OI2_PRINTDENSITY)
#define  MD_OI_COLORTRC            (MD_OI_OI2 + MD_OI2_COLORTRC)
#define  MD_OI_RESERVED            (MD_OI_OI2 + MD_OI2_RESERVED)
#define  MD_OI_TOTALMAX            (MD_OI_OI2 + MD_OI2_MAX)

typedef struct
{
    short   cbSize;          // size of MODELDATA, 150 bytes
    short   sIDS;           // stringtable ID for model name
    WORD    fGeneral;       // General printer capabilities
    WORD    fCurves;        // Curve Capabilities
    WORD    fLines;         // Line Capabilities
    WORD    fPolygonals;    // Polygonal Capabilities
    WORD    fText;          // Text Capabilities
    WORD    fClip;          // Clipping Capabilities
    WORD    fRaster;        // Raster Capabilities
    WORD    fLText;         // Text Capabilities in landscape mode
    short   sLeftMargin;    // Unprintable minimum left margin.
    short   sMaxPhysWidth;  // Maximum physical page width
    POINTw  ptMax;          // Maximum X & Y printable dimensions in master units
    POINTw  ptMin;          // Minimum X & Y page dimensions in master units
    short   sDefaultFontID; // Default font resource ID
    short   sLookAhead;     // Size of Lookahead region
    short   sMaxFontsPage;  // Max number of fonts printer can place on single
                            // page -1 if no limit
    short   sCartSlots;     // Number of cartridge slots on printer
    short   sDefaultCTT;
    WORD    rgoi[MD_OI_MAX];// list of offsets to index lists
    short   rgi[MD_I_MAX];  // list of indices.

    //
    // The following fields are added in GPC 3.0
    //

    WORD  rgoi2[MD_OI2_MAX];// Orphans from rgoi (here due to compatibility)
    WORD  orgoiDefaults;    // Offset to list of defaults for RGOI & RGOI2
    WORD  wReserved;        // Needed for alignment
    DWORD dwICMManufacturer;// id to match ICC profiles against
    DWORD dwICMModel;       // id to match ICC profiles against
    DWORD rgdwReserved[8];  // 32 bytes reserved for future use
} MODELDATA, *PMODELDATA;

//
//   MODELDATA.fGeneral flag values
//

#define MD_SERIAL             0x0001 // must output text serially such
                                     // as dotmatrix printers
#define MD_PARAMETERIZE       0x0002 // supports parameterized escape codes
#define MD_ROTATE_FONT_ABLE   0x0004 // can rotate hardware fonts
#define MD_COPIES             0x0008 // supports multiple copies
#define MD_DUPLEX             0x0010 // supports duplexing
#define MD_NO_ADJACENT        0x0020 // old model, cannot print adjacent pins
#define MD_LANDSCAPE_GRX_ABLE 0x0040 // can rotate raster graphics
#define MD_ALIGN_BASELINE     0x0080 // text output are algned on the
                                     // baseline, not top of char
#define MD_FONT_MEMCFG        0x0100 // Mem ref'd @ rgoi[MD_OI_MEMCONFIG]
                                     // used for download fonts only.
#define MD_LANDSCAPE_RT90     0x0200 // landscape is portrait rotated
        // 90 degress counter-clockwise, i.e. the end of a page is printed
        // first. The default is 270 degrees, i.e. the beginning of a
        // page is printed first. !!!For printers which do not have the
        // set-orientation command (i.e. only have portrait mode), this
        // bit should NOT be set. UNIDRV will rotate the graphics and
        // the beginning of a page will come out first.

#define MD_USE_CURSOR_ORIG    0x0400 // use cursor origins in
        // PAPERSIZE to calculate the print origin. The default
        // cursor origin is the upper left corner of the printable area.

#define MD_WHITE_TEXT         0x0800 // can print white text on black
                                     // bkgrd. Cmds from DEVCOLOR struct.
#define MD_PCL_PAGEPROTECT    0x1000 // provide PCL5-style page protection
#define MD_MARGINS            0x2000 // allow the user to set paper
                // unprintable area. On some printers (such
                // as Epson, the user could manipulate the
                // printer to have different margins than
                // the default. Add this bit for Win3.0
                // driver compatibility.
#define MD_CMD_CALLBACK       0x4000 // Model requires fnOEMGetCmd callback
#define MD_MEMRES             0x8000 // User may reserve printer memory

//*****************************************************************************
//
// RESOLUTION contains information needed to compose bitmap images on the printer.
// There is one RESOLUTION structure defined for each supported printer resolution.
// RESOLUTION array should be arranged from the highest resolution to the lowest
// resolution. It is also the order that will be displayed in the dialog box.
// This strucuture becomes part of the physical device block.
//
//*****************************************************************************

//
//   RESOLUTION.rgocd[] index values
//

#define RES_OCD_SELECTRES              0
#define RES_OCD_BEGINGRAPHICS          1
#define RES_OCD_ENDGRAPHICS            2
#define RES_OCD_SENDBLOCK              3
#define RES_OCD_ENDBLOCK               4
#define RES_OCD_MAX                    5

//
//  Note: RESOLUTION data structure is defined in parser.h for GPD.
//        GPC RESOLUTION data strucutre is changed as GPCRESOLUTION
//

typedef struct                  // size is 40 bytes
{
    short   cbSize;              // size of RESOLUTION, 40 bytes
    short   sIDS;               // String ID for displaying resolution
    WORD    fDump;              // Dump method flags.
    WORD    fBlockOut;          // Block out method flags.
    WORD    fCursor;            // Cursor position flags.
    short   iDitherBrush;       // selected brush for dithering
    POINTw  ptTextScale;        // relationship between master units and text units.
    POINTw  ptScaleFac;         // relationship between graphics and text
                // scale factors. expressed in powers of 2.
    short   sNPins;             // Minimum height of the image to be rendered
                // together.
    short   sPinsPerPass;       // Physical number of pins fired in one pass.
    short   sTextYOffset;       // offset from top of graphics output that of text
                // output
    short   sMinBlankSkip;      // Min. # of bytes of null data that must occur before
                // compression (strip null data only) will occur
    short   sSpotDiameter;      // size of dot at this resolution
    OCD     rgocd[RES_OCD_MAX];
} GPCRESOLUTION, *PGPCRESOLUTION;

//
//   RESOLUTION.fDump values
//

#define RES_DM_GDI              0x0040 // GDI bitmap format
#define RES_DM_LEFT_BOUND       0x0080 // Optimize by bounding rect
#define RES_DM_COLOR            0x0100 // Color support is available
#define RES_DM_DOWNLOAD_OUTLINE 0x0200 // this res supports outline font download
#define RES_DM_CALLBACK         0x8000 // Color support is available
                                       // for this resolution
//
//   RESOLUTION.fBlockOut values
//

#define RES_BO_LEADING_BLNKS  0x0001 // Strip leading blanks if sMinBlankSkip
                                     // or more bytes of null data occur
#define RES_BO_TRAILING_BLNKS 0x0002 // Strip trailing blanks if sMinBlankSkip
                                     // or more bytes of null data occur
#define RES_BO_ENCLOSED_BLNKS 0x0004 // Strip enclosed blanks if sMinBlankSkip
                                     // or more bytes of null data occur
#define RES_BO_RESET_FONT     0x0008 // Must reselect font after
                                     // blockout command
#define RES_BO_3BYTESIN4      0x0010 // each pixel is expressed in 4 bytes
#define RES_BO_UNIDIR         0x0020 // send unidir
#define RES_BO_NO_ADJACENT    0x0040 // no adjacent pins can be fired
                                     // block out command
//
// !!!LindsayH additions - for Seiko Color Point */
//

#define RES_BO_ALL_GRAPHICS   0x0100 // Send ALL graphics - no cursor

#define RES_BO_OEMGRXFILTER   0x4000 // use oem supplied graphics filter

//
// Removed ..normanh 20/11/93 minidriv.c does not have this.
// rasdd deson't use it. unidrv GPC3 needs this bit.
// #define RES_BO_CALLBACK         0x8000       // Color support is available
//

#define RES_BO_MULTIPLE_ROWS  0x8000 // Multiple lines of data can be sent
                                     // with the RES_OCD_SENDBLOCK command.


//
//   RESOLUTION.fCursor values
//

#define RES_CUR_X_POS_ORG  0x0001  // X Position is at X start point
                                   // of graphic data after rendering data
#define RES_CUR_X_POS_AT_0 0x0002  // X position at leftmost place
                                   // on page after rendering data
#define RES_CUR_Y_POS_AUTO 0x0004  // Y position automatically moves
                                   // to next Y row
#define RES_CUR_CR_GRX_ORG 0x0008  // CR moves X pos to X start point of
                                   // of graphic data

//
//   RESOLUTION.fDitherBrush flag values
//

#define RES_DB_NONE             0
#define RES_DB_COARSE           1
#define RES_DB_FINE             2
#define RES_DB_LINEART          3
#define RES_DB_ERRORDIFFUSION   4
#define RES_DB_MAX       RES_DB_ERRORDIFFUSION   // last defined ditherbrush

//*****************************************************************************
//
// PAPERSIZE contains physical paper sizes and unprintable margins
//
//*****************************************************************************

//
// PAPERSIZE.rgocd[] index values
//

#define PSZ_OCD_SELECTPORTRAIT      0
#define PSZ_OCD_SELECTLANDSCAPE     1
#define PSZ_OCD_PAGEPROTECT_ON      2
#define PSZ_OCD_PAGEPROTECT_OFF     3
#define PSZ_OCD_RESERVED1           4
#define PSZ_OCD_RESERVED2           5
#define PSZ_OCD_MAX                 6

typedef struct
{
  short cbSize;         // size of PAPERSIZE, 60 bytes.
  short sPaperSizeID;   // If sPaperSizeID is < 256 then it's predefined.
                        // If it's = 256, allow user defined sizes.
                        // If it's >= 257, it's driver-defined & is the
                        // string ID to name this driver-defined PAPERSIZE
  WORD   fGeneral;      // General flag to describe info about this size
  WORD   fPaperType;    // Bit field to describe this size, used by PAPERSRC
  POINTw ptSize;        // X & Y paper size dimension in master units.
  RECTw  rcMargins;     // Specifies the unprintable margins in master units.
                        // (Portrait mode in new spec)
  POINTw ptCursorOrig;  // Cursor origin relative to physical page origin.
  POINTw ptLCursorOrig; // Cursor origin relative to physical page origin
                        // in landscape.
  OCD    rgocd[PSZ_OCD_MAX]; // Command Descriptors
  RECTw  rcLMargins;    // Specifies the unprintable margins in master units
                        // when printing in landscape mode.
  POINTw ptVectOffset;  // Offset (in master units) from vector 0,0 to
                        // UL corner of page in portrait mode
  POINTw ptLVectOffset; // Offset (in master units) from vector 0,0 to
                        // UL corner of page in landscape mode
  WORD  wYSizeUnit;     // Base unit for custom paper size dimensions
  WORD  wPageProtMem;   // Amount of mem (in KBs) PAGEPROTECT_ON uses
} PAPERSIZE, * PPAPERSIZE;

//
//   PAPERSIZE.fGeneral flag values
//

#define PS_CENTER           0x0001 // center the printable area along the paper path
#define PS_ROTATE           0x0002 // rotate X & Y dimensions
#define PS_SUGGEST_LNDSCP   0x0004 // suggest landscape mode
#define PS_EJECTFF          0x0008 // eject page via CURSORMOVE.rgocd[CM_OCD_FF]

//
//   PAPERSIZE.fPaperType flag values
//

#define PS_T_STD            0x0001
#define PS_T_LARGE          0x0002
#define PS_T_ENV            0x0004
#define PS_T_LRGENV         0x0008
#define PS_T_ROLL           0x0010
#define PS_T_OEM1           0x0400
#define PS_T_OEM2           0x0800
#define PS_T_OEM3           0x1000
#define PS_T_OEM4           0x2000
#define PS_T_OEM5           0x4000
#define PS_T_OEM6           0x8000

//*****************************************************************************
//
// PAPERQUALITY contains an ID & OCD
//
//*****************************************************************************

//
// ganeshp!Change the order of wReserved and dwReserved to make dwReserved DWORD
// aligned, as NT compiler adds a word after wReserved to make dwReserved
// DWORD aligned. Because of this ocdSelect gets bad value from the GPC data.
//

typedef struct
{
    short   cbSize;         // size of PAPERQUALITY, 12 bytes.
    short   sPaperQualID;   //
    DWORD   dwReserved;     // "                      "
    WORD    wReserved;      // resevered for future use
    OCD     ocdSelect;      // Command Descriptor to select this Paper Quality.
} PAPERQUALITY, *PPAPERQUALITY;

//*****************************************************************************
//
// PAPERSOURCE contains information needed to select a feed methods and
// the margin that might be introduced by the feed method.
//
//*****************************************************************************

typedef struct
{
    short   cbSize;        // size of PAPERSOURCE, 16 bytes
    short   sPaperSourceID;// If sPaperSourceID <= 256 then it's predefined
                           // by genlib, otherwise, it is the string ID.
    WORD    fGeneral;
    WORD    fPaperType;    // Bit field to describe this size, used by PAPERSRC
    short   sTopMargin;    // Top margin introduced by the feed method.
    short   sBottomMargin; // Bottom margin introduced by the feed method.
    short   sBinAdjust;    // Describes adjustments supported by bin
    OCD     ocdSelect;     // Command Descriptor to select this Paper source.
} PAPERSOURCE, * PPAPERSOURCE;

//
//   PAPERSOURCE.fGeneral flag values
//

#define PSRC_EJECTFF        0x0001
#define PSRC_MAN_PROMPT     0x0002

//*****************************************************************************
//
// PAPERDEST contains information needed to select a paper out bin/tray
//
//*****************************************************************************

typedef struct
{
    short   cbSize;        // size of PAPERDEST, 8 bytes
    short   sID;           // If sID <= 256 then it's predefined
                           // otherwise, it is the stringtable ID.
    short   fGeneral;      // General purpose Bit field
    OCD     ocdSelect;     // Command Descriptor to select this attribute.
} PAPERDEST, * PPAPERDEST;


//
// PAPERDEST.fGeneral flag values
//

#define PDST_JOBSEPARATION  0x0001

//*****************************************************************************
//
// TEXTQUALITY contains information needed to select a text quality attribute
//
//*****************************************************************************

typedef struct
{
    short   cbSize;         // size of TEXTQUALITY, 8 bytes
    short   sID;            // If sID <= 256 then it's predefined
                            // otherwise, it is the string ID.
    short   fGeneral;       // General purpose Bit field
    OCD     ocdSelect;      // Command Descriptor to select this text quality.
} TEXTQUALITY, * PTEXTQUALITY;

//*****************************************************************************
//
//  COMPRESSMODE
//
//*****************************************************************************

//
//    COMPRESSMODE.rgocd[] index values
//
#define CMP_OCD_BEGIN  0
#define CMP_OCD_END    1
#define CMP_OCD_MAX    2

typedef struct
{
    short   cbSize;              // size of COMPRESSMODE, 8 bytes
    WORD    iMode;               // ID for type of commpression mode
    OCD     rgocd[CMP_OCD_MAX];  // Actual Command String, variable length
} COMPRESSMODE, *PCOMPRESSMODE;

//
//    COMPRESSMODE.wModeID flags
//

#define CMP_ID_FIRST                           CMP_ID_RLE
#define CMP_ID_RLE                             1
#define CMP_ID_TIFF40                          2
#define CMP_ID_DELTAROW                        3
#define CMP_ID_BITREPEAT                       4
#define CMP_ID_FE_RLE                          5
#define CMP_ID_LAST                            CMP_ID_FE_RLE

//*****************************************************************************
//
//  GPCFONTCART
//
//*****************************************************************************

#define FC_ORGW_PORT                     0
#define FC_ORGW_LAND                     1
#define FC_ORGW_MAX                      2

typedef struct
{
    short   cbSize;               // size of FONTCART, 12 bytes
    WORD    sCartNameID;          // stringtable ID for cartridge name
    WORD    orgwPFM[FC_ORGW_MAX]; // array of offsets to array of indices
                                  // of PFM resources
    WORD    fGeneral;             // General bit flags
    short   sShiftVal;            // amt to shift each font in this cart by
} GPCFONTCART, *PGPCFONTCART;

//#define FC_GEN_RESIDENT 0x0001  // resident font cart

//*****************************************************************************
//
//  PAGECONTROL
//
//*****************************************************************************

//
//    PAGECONTROL.rgocd[] index values
//

#define PC_OCD_BEGIN_DOC      0
#define PC_OCD_BEGIN_PAGE     1
#define PC_OCD_DUPLEX_ON      2
#define PC_OCD_ENDDOC         3
#define PC_OCD_ENDPAGE        4
#define PC_OCD_DUPLEX_OFF     5
#define PC_OCD_ABORT          6
#define PC_OCD_PORTRAIT       7
#define PC_OCD_LANDSCAPE      8
#define PC_OCD_MULT_COPIES    9
#define PC_OCD_DUPLEX_VERT    10
#define PC_OCD_DUPLEX_HORZ    11
#define PC_OCD_PRN_DIRECTION  12
#define PC_OCD_JOB_SEPARATION 13
#define PC_OCD_MAX            14

typedef struct
{
    short   cbSize;             // size of PAGECONTROL, 36 bytes
    short   sMaxCopyCount;     // max # of copies w/ PC_OCD_MULT_COPIES
    WORD    fGeneral;          // General bit flags
    WORD    orgwOrder;
    OCD     rgocd[PC_OCD_MAX];
} PAGECONTROL, * PPAGECONTROL;

//
//    PAGECONTROL.owOrder index values
//

#define PC_ORD_BEGINDOC        1
#define PC_ORD_ORIENTATION     2
#define PC_ORD_MULT_COPIES     3
#define PC_ORD_DUPLEX          4
#define PC_ORD_DUPLEX_TYPE     5
#define PC_ORD_TEXTQUALITY     6
#define PC_ORD_PAPER_SOURCE    7
#define PC_ORD_PAPER_SIZE      8
#define PC_ORD_PAPER_DEST      9
#define PC_ORD_RESOLUTION      10
#define PC_ORD_BEGINPAGE       11
#define PC_ORD_SETCOLORMODE    12
#define PC_ORD_PAPER_QUALITY   13
#define PC_ORD_PAGEPROTECT     14
#define PC_ORD_IMAGECONTROL    15
#define PC_ORD_PRINTDENSITY    16
#define PC_ORD_MAX             PC_ORD_PRINTDENSITY
#define PC_ORD_LAST            PC_ORD_PRINTDENSITY

//*****************************************************************************
//
//  CURSORMOVE
//
//*****************************************************************************

//
//    CURSORMOVE.rgocd[] index values
//

#define CM_OCD_XM_ABS          0
#define CM_OCD_XM_REL          1
#define CM_OCD_XM_RELLEFT      2
#define CM_OCD_YM_ABS          3
#define CM_OCD_YM_REL          4
#define CM_OCD_YM_RELUP        5
#define CM_OCD_YM_LINESPACING  6
#define CM_OCD_XY_REL          7
#define CM_OCD_XY_ABS          8
#define CM_OCD_CR              9
#define CM_OCD_LF              10
#define CM_OCD_FF              11
#define CM_OCD_BS              12
#define CM_OCD_UNI_DIR         13
#define CM_OCD_UNI_DIR_OFF     14
#define CM_OCD_PUSH_POS        15
#define CM_OCD_POP_POS         16
#define CM_OCD_MAX             17

typedef struct
{
    short   cbSize;             // size of CURSORMOVE, 44 bytes
    short   sReserved;
    WORD    fGeneral;
    WORD    fXMove;
    WORD    fYMove;
    OCD     rgocd[CM_OCD_MAX];  // Actual Command String, variable length
} CURSORMOVE, *PCURSORMOVE;

//
// CURSORMOVE.fGeneral flags
//

#define CM_GEN_FAV_XY   0x0002  // from Win95 GPC

//
//    CURSORMOVE.fXmove flag values
//

#define CM_XM_NO_POR_GRX    0x0004  // no x movemnt while in graphics mode, portrait
#define CM_XM_NO_LAN_GRX    0x0008  // no x movemnt while in graphics mode, landscape
#define CM_XM_RESET_FONT    0x0010  // Font is reset after x movement command
#define CM_XM_FAVOR_ABS     0x0080  // favor absolute x command
#define CM_XM_REL_LEFT      0x0200  // has relative x to the left
#define CM_XM_ABS_NO_LEFT   0x0400  // No left X movement command
#define CM_XM_RES_DEPENDENT 0x0800  // X movement in resolution unit, not mu


//
//    CURSORMOVE.fYmove flag values
//

#define CM_YM_FAV_ABS       0x0001
#define CM_YM_REL_UP        0x0002
#define CM_YM_NO_POR_GRX    0x0004  // no y movemnt while in graphics mode, portrait
#define CM_YM_NO_LAN_GRX    0x0008  // no y movemnt while in graphics mode, landscape
#define CM_YM_CR            0x0040
#define CM_YM_LINESPACING   0x0080
#define CM_YM_TRUNCATE      0x0100  // don't compensate for ymovement error
#define CM_YM_RES_DEPENDENT 0x0200  // X movement in resolution unit, not mu

//*****************************************************************************
//
// FONTSIMULATION describes various printer commands to enable and disable
// various character attributes such as bold, italic, etc.
//
//*****************************************************************************

//
//   FONTSIMULATION.rgocStd[] index values
//

#define FS_OCD_BOLD_ON                   0
#define FS_OCD_BOLD_OFF                  1
#define FS_OCD_ITALIC_ON                 2
#define FS_OCD_ITALIC_OFF                3
#define FS_OCD_UNDERLINE_ON              4
#define FS_OCD_UNDERLINE_OFF             5
#define FS_OCD_DOUBLEUNDERLINE_ON        6
#define FS_OCD_DOUBLEUNDERLINE_OFF       7
#define FS_OCD_STRIKETHRU_ON             8
#define FS_OCD_STRIKETHRU_OFF            9
#define FS_OCD_WHITE_TEXT_ON             10
#define FS_OCD_WHITE_TEXT_OFF            11
#define FS_OCD_SINGLE_BYTE               12
#define FS_OCD_DOUBLE_BYTE               13
#define FS_OCD_VERT_ON                   14
#define FS_OCD_VERT_OFF                  15
#define FS_OCD_MAX                       16

typedef struct
{
    short   cbSize;            // size of FONTSIMULATION, 44 bytes
    short   sReserved;         // so DW aligned
    WORD    fGeneral;
    short   sBoldExtra;
    short   sItalicExtra;
    short   sBoldItalicExtra;
    OCD     rgocd[FS_OCD_MAX];
} FONTSIMULATION, * PFONTSIMULATION;

//*****************************************************************************
//
// DEVCOLOR is the physical color info which describes the device color
// capabilities and how to compose colors based on available device colors.
//
//*****************************************************************************

//
//   DEVCOLOR.fGeneral bit flags:
//

#define DC_PRIMARY_RGB      0x0001   // use RGB as 3 primary colors.
                                     // Default: use CMY instead.
#define DC_EXTRACT_BLK      0x0002   // Separate black ink/ribbon is available.
                                     // Default: compose black using CMY.
                                     // It is ignored if DC_PRIMARY_RGB is set
#define DC_CF_SEND_CR       0x0004   // send CR before selecting graphics
                                     // color. Due to limited printer buffer
#define DC_SEND_ALL_PLANES  0x0008   // All color plane data must be sent
#define DC_SEND_PAGE_PLANE  0x0010   // Color separation required
#define DC_EXPLICIT_COLOR   0x0020   // Color must be set before sending
                                     // the RES_OCD_SENDBLOCK command.
#define DC_SEND_PALETTE     0x0040   // Color palette must be downloaded

//
// sandram
// add field to send dithered text for Color LaserJet - set foreground color.
//

#define DC_FG_TEXT_COLOR    0x0080  // Send command to select text foreground color
#define DC_ZERO_FILL        0x0100  // This model fills raster to the end of the page with zeros

//
// One and only one of DEVCOLOR.sPlanes or DEVCOLOR.sBitsPixel must be 1.
//
// Example:
//
// DEVCOLOR.sPlanes:
//      Valid values are:
//          1:         use the pixel color model.
//          n (n > 1): use the plane color model.
//                     Ex. for Brother M-1924, n = 4; for PaintJet, n = 3.
//
// DEVCOLOR.sBitsPixel:
//      Valid values are:
//          1:      use the plane color model.
//          4 & 8:  use the pixel color model.
//                  The color bits (4 or 8) are directly from DIB driver. They
//                  should be used as index into the printer's color palette.
//                  The mini driver write should make sure that the printer's
//                  color palette is configured in the same way as DIB's
//                  color palette in respective cases.
//

//
// DEVCOLOR.rgocd array values
//

#define DC_OCD_TC_BLACK        0
#define DC_OCD_TC_RED          1
#define DC_OCD_TC_GREEN        2
#define DC_OCD_TC_YELLOW       3
#define DC_OCD_TC_BLUE         4
#define DC_OCD_TC_MAGENTA      5
#define DC_OCD_TC_CYAN         6
#define DC_OCD_TC_WHITE        7
#define DC_OCD_SETCOLORMODE    8
#define DC_OCD_PC_START        9
#define DC_OCD_PC_ENTRY       10
#define DC_OCD_PC_END         11
#define DC_OCD_PC_SELECTINDEX 12
#define DC_OCD_SETMONOMODE    13
#define DC_OCD_MAX            14

//
// DEVCOLOR.rgbOrder array values
//

#define DC_PLANE_NONE    0
#define DC_PLANE_RED     1
#define DC_PLANE_GREEN   2
#define DC_PLANE_BLUE    3
#define DC_PLANE_CYAN    4
#define DC_PLANE_MAGENTA 5
#define DC_PLANE_YELLOW  6
#define DC_PLANE_BLACK   7

#define DC_MAX_PLANES    4

typedef struct
{
  short cbSize;               // size of DEVCOLOR, 44 bytes
  WORD  fGeneral;             // general flag bit field
  short sPlanes;              // # of color planes required
  short sBitsPixel;           // # of bits per pixel (per plane). At least
                              // one of 'sPlanes' and 'sBitsPixel' is 1.
  WORD  orgocdPlanes;         // offset to a list of OCD's for sending data
                              // planes. The # of OCD's is equal to 'sPlanes'.
                              // This field is not used in case of pixel
                              // color models. The first command will be
                              // used to send data of the first plane,
                              // and so on.
  OCD   rgocd[DC_OCD_MAX];    // array of Offsets to commands.
  BYTE  rgbOrder[DC_MAX_PLANES]; // order in which color planes are sent
  WORD  wReserved;            // For alignment
} DEVCOLOR, * PDEVCOLOR, FAR * LPDEVCOLOR;

//*****************************************************************************
//
//  RECTFILL
//
//*****************************************************************************

//
//    RECTFILL.rgocd[] index values
//

#define RF_OCD_X_SIZE                   0
#define RF_OCD_Y_SIZE                   1
#define RF_OCD_GRAY_FILL                2
#define RF_OCD_WHITE_FILL               3
#define RF_OCD_HATCH_FILL               4
#define RF_OCD_MAX                      5

typedef struct
{
    short   cbSize;             // size of RECTFILL, 20 bytes
    WORD    fGeneral;
    WORD    wMinGray;
    WORD    wMaxGray;
    OCD     rgocd[RF_OCD_MAX];   // Actual Command String, variable length
    WORD    wReserved;
} RECTFILL, *PRECTFILL;

//
//    RECTFILL.fGenral flag values
//

#define RF_WHITE_ABLE     0x0001        // White rule exists
#define RF_MIN_IS_WHITE   0x0002        // min. graylevel = white rule

#define RF_CUR_X_END      0x0100        // X Position is at X end point
                                        // of fill area after rendering
#define RF_CUR_Y_END      0x0200        // Y position is at Y end point
                                        // of fill area after rendering
                                        // default is no chg of position

//*****************************************************************************
//
// DOWNLOADINFO describes that way in which genlib should instruct the font
// installer to handle downloading soft fonts.  It contains OCDs for all
// appropriate codes.
//
//*****************************************************************************

//
//   DOWNLOADINFO.rgocd[] index values
//

#define DLI_OCD_RESERVED                 0
#define DLI_OCD_BEGIN_DL_JOB             1
#define DLI_OCD_BEGIN_FONT_DL            2
#define DLI_OCD_SET_FONT_ID              3
#define DLI_OCD_SEND_FONT_DESCRIPTOR     4
#define DLI_OCD_SELECT_FONT_ID           5
#define DLI_OCD_SET_CHAR_CODE            6
#define DLI_OCD_SEND_CHAR_DESCRIPTOR     7
#define DLI_OCD_END_FONT_DL              8
#define DLI_OCD_MAKE_PERM                9
#define DLI_OCD_MAKE_TEMP                10
#define DLI_OCD_END_DL_JOB               11
#define DLI_OCD_DEL_FONT                 12
#define DLI_OCD_DEL_ALL_FONTS            13
#define DLI_OCD_SET_SECOND_FONT_ID       14
#define DLI_OCD_SELECT_SECOND_FONT_ID    15
#define DLI_OCD_MAX                      16

typedef struct
{
    short   cbSize;            // size of DOWNLOADINFO, 52 bytes
    WORD    wReserved;         // for DWORD alignment
    WORD    fGeneral;          // general bit flags
    WORD    fFormat;           // describes download font format
    WORD    wIDMin;
    WORD    wIDMax;
    short   cbBitmapFontDescriptor;
    short   cbScaleFontDescriptor;
    short   cbCharDescriptor;
    WORD    wMaxCharHeight;
    short   sMaxFontCount;
    WORD    orgwCmdOrder;
    OCD     rgocd[DLI_OCD_MAX];
} DOWNLOADINFO, * PDOWNLOADINFO;

//
//   DOWNLOADINFO.fGeneral flag values
//

#define DLI_GEN_CNT             0x0001  // printer limits # DL fonts by fixed #
#define DLI_GEN_MEMORY          0x0002  // printer limits # DL fonts by memory
#define DLI_GEN_DLJOB           0x0004  // printer can only DL fonts on per
                                        // job basis
#define DLI_GEN_DLPAGE          0x0008  // printer can DL fonts on per page
                                        // basis
//
// NOTE: if neither of the above 2 flags
// are ste, assume DL can happen any time
//

#define DLI_GEN_PT_IDS          0x0010  // use OCD_SET_FONT_ID for specifiy
                                        // perm/temp

#define DLI_GEN_FNTDEL          0x0020  // del single font supported
#define DLI_GEN_ALLFNTDEL       0x0040  // del all fonts supported
#define DLI_GEN_FNTDEL_ANYWHERE 0x0080  // if set, fonts can be deleted at
                                        // any point. Default is at page
                                        // boundary only
#define DLI_GEN_7BIT_CHARSET    0x0100  // printer supports only 7-bit charset

//
//   DOWNLOADINFO.fFormat flag values
//

#define DLI_FMT_PCL           0x0001 // PCL printer
#define DLI_FMT_INCREMENT     0x0002 // incremental download recommended
#define DLI_FMT_RES_SPECIFIED 0x0004 // allow resolution specified bitmap
                                     // font download. The X & Y resolutions
                                     // are attached to the end of the
                                     // regular bitmap font descriptor.
#define DLI_FMT_OUTLINE       0x0008 // from WIN95 GPC
#define DLI_FMT_PCLETTO       0x0008 // alias for outline downloading (remove later)
#define DLI_FMT_CAPSL         0x0010 // Use CaPSL download header
#define DLI_FMT_PPDS          0x0020 // Use PPDS download header
#define DLI_FMT_CALLBACK      0x0040 // minidriver provide callbacks for
                                     // for downloading bitmap fonts.
//*****************************************************************************
//
//  VECTPAGE describes information about the vector page and miscellaneous
//  vector capabilities and commands
//
//*****************************************************************************

//
// VECTPAGE.rgocd[] index values
//

#define VP_OCD_INIT_VECT       0
#define VP_OCD_ENTER_VECT      1
#define VP_OCD_EXIT_VECT       2
#define VP_OCD_TRANSPARENT     3
#define VP_OCD_OPAQUE          4
#define VP_OCD_ANCHOR          5
#define VP_OCD_SET_CLIPRECT    6
#define VP_OCD_CLEAR_CLIPRECT  7
#define VP_OCD_ENDCAP_FLAT     8
#define VP_OCD_ENDCAP_ROUND    9
#define VP_OCD_ENDCAP_SQUARE  10
#define VP_OCD_JOIN_BEVEL     11
#define VP_OCD_JOIN_MITER     12
#define VP_OCD_JOIN_ROUND     13
#define VP_OCD_RESERVED1      14
#define VP_OCD_RESERVED2      15
#define VP_OCD_RESERVED3      16
#define VP_OCD_RESERVED4      17
#define VP_OCD_MAX            18

typedef struct
{
  WORD  cbSize;            // Size of VECTPAGE, 44 bytes
  WORD  fGeneral;          // General use bitfield
  POINT ptVectDPI;         // Vector units per inch
  OCD   rgocd[VP_OCD_MAX]; // Offsets to commands
} VECTPAGE, *PVECTPAGE, FAR *LPVECTPAGE;

//
// VECTPAGE.fGeneral flags
//

#define VP_GEN_X_AXIS_LEFT 0x0001 // Set if plotter's X axis (horizontal)
                                  // extends left. Default is to the right
#define VP_GEN_Y_AXIS_UP   0x0002 // Sef if plotter's Y axis (vertical)

//******************************************************************************//
//  CAROUSEL describes carousel characteristics. If the pens are fixed,
//  this also specifies the colors of each pen.
//
//******************************************************************************

//
// CAROUSEL.rgocd[] index values
//

#define CAR_OCD_SELECT_PEN_COLOR   0
#define CAR_OCD_SET_PEN_WIDTH      1
#define CAR_OCD_RETURN_PEN         2
#define CAR_OCD_RESERVED           3
#define CAR_OCD_MAX                4

typedef struct
{
    WORD  cbSize;               // Size of CAROUSEL, 16 bytes
    WORD  fGeneral;             // General purpose bitfield
    WORD  wNumPens;             // # of pens in carousel
    short oiRGBColors;          // colors of pens in carousel
    OCD   rgocd[CAR_OCD_MAX];   // commands associated with carousel
} CAROUSEL, *PCAROUSEL, FAR *LPCAROUSEL;

//
// CAROUSEL.fGeneral flags
//

#define CAR_GEN_CAROUSEL_LEFT      0x0001 // Set if pen moves to the left of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_RIGHT     0x0002 // Set if pen moves to the right of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_TOP       0x0004 // Set if pen moves to the top of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_BOTTOM    0x0008 // Set if pen moves to the bottom of
                                          // page when returned to carousel
#define CAR_GEN_CAROUSEL_FIXED     0x0010 // Carousel has fixed set of pens
#define CAR_GEN_RETURN_PEN         0x0020 // Pen must be explicitly returned
                                          // to the carousel before selecting
                                          // a new pen.
#define CAR_GEN_VARIABLE_PEN_WIDTH 0x0040 // Set if SET_PEN_WIDTH changes
                                          // the width of the (logical) pen
                                          // as opposed to informing the
                                          // plotter of the physical width.

//******************************************************************************//
//  PENINFO describes the characteristics of an available pen
//
//******************************************************************************

//
// PENINFO.rgocd[] index values
//

typedef struct
{
    WORD  cbSize;              // Size of PENINFO, 16 bytes
    WORD  fGeneral;            // General purpose bitfield
    DWORD fType;               // Surfaces on which pen can draw
    DWORD dwColor;             // RGB color of the pen
    WORD  fThick;              // Thickness in which pen is available
    WORD  wIDS;                // Stringtable resource for this color's name
} PENINFO, *PPENINFO, FAR *LPPENINFO;

//
// PENINFO.fThick values
//

#define PI_FTHICK_18     0x0001   // Pen comes in 0.18mm
#define PI_FTHICK_25     0x0002   // Pen comes in 0.25mm
#define PI_FTHICK_30     0x0004   // Pen comes in 0.30mm
#define PI_FTHICK_35     0x0008   // Pen comes in 0.35mm
#define PI_FTHICK_50     0x0010   // Pen comes in 0.50mm
#define PI_FTHICK_70     0x0020   // Pen comes in 0.70mm
#define PI_FTHICK_100    0x0040   // Pen comes in 1.00mm

//
// PENINFO.fType values depend on the defined paper sources, but reserve
// the high bit to indicate that any paper source is valid.
//

#define PI_FTYPE_ANY     0x80000000

//******************************************************************************//
//  LINEINFO describes the line style creation and selection commands
//
//******************************************************************************

//
// LINEINFO.rgocd[] index values
//

#define LI_OCD_DELETE_LINESTYLE    0
#define LI_OCD_SELECT_NULL         1
#define LI_OCD_SELECT_SOLID        2
#define LI_OCD_CREATE_DASH         3
#define LI_OCD_SELECT_DASH         4
#define LI_OCD_CREATE_DOT          5
#define LI_OCD_SELECT_DOT          6
#define LI_OCD_CREATE_DASHDOT      7
#define LI_OCD_SELECT_DASHDOT      8
#define LI_OCD_CREATE_DASHDOTDOT   9
#define LI_OCD_SELECT_DASHDOTDOT  10
#define LI_OCD_RESERVED1          11
#define LI_OCD_RESERVED2          12
#define LI_OCD_RESERVED3          13
#define LI_OCD_RESERVED4          14
#define LI_OCD_RESERVED5          15
#define LI_OCD_MAX                16

typedef struct
{
    WORD  cbSize;           // Size of LINEINFO, 40 bytes
    WORD  fGeneral;         // General purpose bitfield
    short sMaxUserDefined;  // Max # of line styles that can be defined at once
    WORD  wReserved;        // Maintain DWORD alignment
    OCD   rgocd[LI_OCD_MAX];// Offsets to commands
} LINEINFO, *PLINEINFO, FAR *LPLINEINFO;

//******************************************************************************//
//  BRUSHINFO describes the brush style creation and selection commands
//
//******************************************************************************

//
// BRUSHINFO.rgocd[] index values
//

#define BI_OCD_SELECT_NULL             0
#define BI_OCD_SELECT_SOLID            1
#define BI_OCD_SELECT_HS_HORIZONTAL    2
#define BI_OCD_SELECT_HS_VERTICAL      3
#define BI_OCD_SELECT_HS_FDIAGONAL     4
#define BI_OCD_SELECT_HS_BDIAGONAL     5
#define BI_OCD_SELECT_HS_CROSS         6
#define BI_OCD_SELECT_HS_DIAGCROSS     7
#define BI_OCD_CREATE_BRUSHSTYLE_1     8
#define BI_OCD_CREATE_BIT_1            9
#define BI_OCD_CREATE_SEPARATOR_1     10
#define BI_OCD_CREATE_BRUSHSTYLE_2    11
#define BI_OCD_CREATE_BYTE_2          12
#define BI_OCD_SELECT_BRUSHSTYLE      13
#define BI_OCD_DELETE_BRUSHSTYLE      14
#define BI_OCD_CREATE_END_1           15
#define BI_OCD_RESERVED2              16
#define BI_OCD_RESERVED3              17
#define BI_OCD_MAX                    18

typedef struct
{
    WORD  cbSize;             // Size of BRUSHINFO, 40 bytes
    WORD  fGeneral;           // General purpose bitfield
    short sMaxUserDefined;    // Max # of user-defined brushes allowed at once
    WORD  wReserved;          // Maintain DWORD alignment
    OCD   rgocd[BI_OCD_MAX];  // Offsets to commands
} BRUSHINFO, *PBRUSHINFO, FAR *LPBRUSHINFO;

//
// BRUSHINFO.fGeneral flags
//

#define BI_GEN_BRUSHSTYLE1     0x0001  // BRUSHSTYLE1 supported
#define BI_GEN_BRUSHSTYLE2     0x0002  // BRUSHSTYLE2 supported
#define BI_GEN_BRUSH32x32      0x0004  // Brush size of 32x32 pixels ONLY

//******************************************************************************//
//  VECTOUTPUT describes the graphic output drawing commands & ordering
//
//******************************************************************************

//
// VECTOUTPUT.rgocd[] index values
//

#define VO_OCD_RECTANGLE         0
#define VO_OCD_CIRCLE            1
#define VO_OCD_ELLIPSE           2
#define VO_OCD_C_PIE             3
#define VO_OCD_E_PIE             4
#define VO_OCD_C_ARC             5
#define VO_OCD_E_ARC             6
#define VO_OCD_C_CHORD           7
#define VO_OCD_E_CHORD           8
#define VO_OCD_RESERVED1         9
#define VO_OCD_RESERVED2        10
#define VO_OCD_RESERVED3        11
#define VO_OCD_RESERVED4        12
#define VO_OCD_RESERVED5        13
#define VO_OCD_RESERVED6        14
#define VO_OCD_RESERVED7        15
#define VO_OCD_MAX              16
#define VO_OCD_NUM               9  // # non-reserved VOs

typedef struct
{
    WORD  cbSize;             // Size of VECTOUTPUT, 40 bytes
    WORD  fGeneral;           // General purpose bitfield
    WORD  wReserved;          // Maintain DWORD alignment
    short rgoi[VO_OCD_MAX];   // Offsets to arrays of VECTSUPPORT
    OCD   rgocd[VO_OCD_MAX];  // Offsets to commands
} VECTOUTPUT, *PVECTOUTPUT, FAR *LPVECTOUTPUT;

//******************************************************************************//
//  POLYVECTOUTPUT describes the polygon/polyline drawing commands & ordering
//
//******************************************************************************

//
// POLYVECTOUTPUT.rgocd[] index values
//

#define PVO_OCD_POLYLINE       0
#define PVO_OCD_ALTPOLYGON     1
#define PVO_OCD_WINDPOLYGON    2
#define PVO_OCD_POLYBEZIER     3
#define PVO_OCD_RESERVED1      4
#define PVO_OCD_RESERVED2      5
#define PVO_OCD_RESERVED3      6
#define PVO_OCD_RESERVED4      7
#define PVO_OCD_MAX            8
#define PVO_OCD_NUM            4    // # non-reserved PVOs

//
// Indices into 2-dimensional array rgocd
//

#define OCD_BEGIN              0
#define OCD_CONTINUE           1
#define OCD_SEPARATOR          2
#define OCD_END                3
#define OCD_MAX                4

typedef struct
{
    WORD   cbSize;                    // sizeof POLYVECTOUTPUT, 88 bytes
    WORD   fGeneral;                  // General purpose bitfield
    WORD   wPointLimit;               // Polygon Point Number Limit
    WORD   wReserved;                 // Reserved for future use
    short  rgoi[PVO_OCD_MAX];         // Describes which VECTSUPPORTs are used
    OCD    rgocd[PVO_OCD_MAX][OCD_MAX]; // offsets to commands
} POLYVECTOUTPUT, *PPOLYVECTOUTPUT, FAR *LPPOLYVECTOUTPUT;

//******************************************************************************//
//  VECTSUPPORT describes methods used by VECTOUTPUT and POLYVECTOUTPUT
//
//******************************************************************************

//
// VECTSUPPORT.rgocd[] index values
//

#define VS_OCD_BEGIN_POLYDEF    0
#define VS_OCD_END_POLYDEF      1
#define VS_OCD_WIND_FILL        2
#define VS_OCD_ALT_FILL         3
#define VS_OCD_STROKE           4
#define VS_OCD_PEN_UP           5
#define VS_OCD_PEN_DOWN         6
#define VS_OCD_RESERVED1        7
#define VS_OCD_RESERVED2        8
#define VS_OCD_RESERVED3        9
#define VS_OCD_MAX             10

//
// These are used by VECTOUTPUT and POLYVECTOUTPUT to represent their ordering
// of pen and brush selection, as well as their OCD or Begin OCD, Continue
// OCD, and End OCD combination
//

#define VS_SELECT_PEN    -1
#define VS_SELECT_BRUSH  -2
#define VS_OCD           -3
#define VS_OCD_BEGIN     -4
#define VS_OCD_CONTINUE  -5
#define VS_OCD_END       -6

typedef struct
{
    WORD  cbSize;               // Size of VECTSUPPORT, 24 bytes
    WORD  fGeneral;             // General purpose bitfield
    short rgocd[VS_OCD_MAX];    // Offsets to commands
} VECTSUPPORT, *PVECTSUPPORT, FAR *LPVECTSUPPORT;

//*****************************************************************************
//
// IMAGECONTROL contains information needed to select an image control
//
//*****************************************************************************

typedef struct
{
    short cbSize;         // size of IMAGECONTROL, 8 bytes
    short sID;            // If sID <= 256 then it's predefined
                          // otherwise, it is the stringtable ID.
    short fGeneral;       // General purpose Bit field
    OCD   ocdSelect;      // Command Descriptor to select this attribute.
} IMAGECONTROL, * PIMAGECONTROL, FAR * LPIMAGECONTROL;

//
// IMAGECONTROL.fGeneral flag values
//
// None defined

//*****************************************************************************
//
// PRINTDENSITY contains information needed to select an image control
//
//*****************************************************************************

typedef struct
{
    short cbSize;         // size of PRINTDENSITY, 8 bytes
    short sID;            // If sID <= 256 then it's predefined
                          // otherwise, it is the stringtable ID.
    OCD   ocdSelect;      // Command Descriptor to select this attribute.
    WORD  wReserved;      // make the structure DWORD aligned.
} PRINTDENSITY, * PPRINTDENSITY, FAR * LPPRINTDENSITY;

//*****************************************************************************
//
// COLORTRC contains rgb transfer curves on PAPERQUALITY and RESOLUTION basis
//
//*****************************************************************************

typedef struct tagColorTRC
{
    short cbSize;                   // size of COLORTRC, 116 bytes
    WORD  wReserved;                // keep everything DWORD aligned
    WORD  fGeneral;
    WORD  wIndexPaperQuality;
    WORD  wIndexResolution;
    WORD  wDitherType;              // reserved for dither, set to zero
    WORD  wReserved1;               // always a good idea
    WORD  wReserved2;
    BYTE  RGBOrdinates[3][17];
    BYTE  padding0;                 // keep everything DWORD aligned
    BYTE  DarkRGBOrdinates[3][17];
    BYTE  padding1;                 // keep everything DWORD aligned
} COLORTRC, * PCOLORTRC, FAR * LPCOLORTRC;

//
// flags for COLORTRC
//

#define  CTRC_NO_CHECKER_BOARD    0x0001
#define  CTRC_NO_BLACK_PEN        0x0002

//
// Offsets into arrays of ORDINATELIST
//

#define TRC_RED         0
#define TRC_GREEN       1
#define TRC_BLUE        2

//*****************************************************************************
//
//  CD - Command Descriptor is used in many of the following structures to
//  reference a particular set of printer command/escape codes
//  used to select paper sizes, graphics resolutions, character attributes,
//  etc. If CD.wType = CMD_FTYPE_EXTENDED, the CD is followed by CD.sCount
//  EXTCD structures.
//
//*****************************************************************************

typedef struct
{
    BYTE    fGeneral;       // general purpose bit fields
    BYTE    bCmdCbId;       // command callback id. 0 iff no callback
    WORD    wCount;
    WORD    wLength;        // length of the command
} CD, *PCD;

#define LPCD    PCD     /* For UNIDRV code */

//
// for cd.fGeneral field
//

#define CMD_GEN_MAY_REPEAT 0x0001 // Command may be sent multiple times if
                                  // the parameter exceeds sMax


#define CMD_MARKER          '%'

//
//  EXTCD - Extended portion of the  Command Descriptor.  This structure
//  follows rgchCmd[] if cd.wType is 1.
//

typedef struct
{
    WORD    fGeneral;   // Modes, special command formats.
    short   sUnitDiv;   // Units relative to master units (divide by)
    short   sUnitMult;  // Units to multiply master units by, 1 usually
    short   sUnitAdd;   // Units to add to parameter value, usually 0
    short   sPreAdd;    // Units to add to master units prior to multiplication
    short   sMax;       // Maximum parameter allowed in command units.
    short   sMin;       // Minimum parameter allowed in command units.
                        // normanh following added for GPC3 .
    WORD    wParam;     // Parameter ordinal for multiple parameters
} EXTCD;
typedef EXTCD UNALIGNED *PEXTCD ;

#define LPEXTCD  PEXTCD         /* For UNIDRV code */

#define XCD_GEN_RESERVED   0x0001   // Previously defined, now unused
#define XCD_GEN_NO_MAX     0x0002   // Set if there is no max (sMax ignored)
#define XCD_GEN_NO_MIN     0x0004   // Set if there is no min (sMin ignored)
#define XCD_GEN_MODULO     0x0008   // Set if divide should be modulo

#define CMD_FMODE_SETMODE  0x0001

//
//   pre-defined text qualities
//

#define DMTEXT_FIRST        DMTEXT_LQ
#define DMTEXT_LQ           1
#define DMTEXT_NLQ          2
#define DMTEXT_MEMO         3
#define DMTEXT_DRAFT        4
#define DMTEXT_TEXT         5
#define DMTEXT_LAST         DMTEXT_TEXT

#define DMTEXT_USER         256 // lower bound for user-defined text quality id

//
//   pre-defined paper qualities
//

#define DMPAPQUAL_FIRST     DMPAPQUAL_NORMAL
#define DMPAPQUAL_NORMAL            1
#define DMPAPQUAL_TRANSPARENT       2
#define DMPAPQUAL_LAST      DMPAPQUAL_TRANSPARENT

//
//   misc
//

#define NOT_USED                  -1        // the value should not be used.
#define NOOCD                     0xFFFF           // command does not exist

// added by Derry Durand [derryd], June  95 for WDL release


#endif // _UNI16GPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\unidebug.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    Unidebug.h

Abstract:

    Unidrv specific Debugging header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/30/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/

// Macroes for file lavel tracing. Define FILETRACE at the of the file
// before including font.h.

#if DBG

#ifdef FILETRACE

#define FVALUE( Val, format)  DbgPrint("[UniDrv!FVALUE] Value of "#Val " is "#format "\n",Val );
#define FTRACE( Val )         DbgPrint("[UniDrv!FTRACE] "#Val"\n");\

#else  //FILETRACE

#define FVALUE( Val, format)
#define FTRACE( Val )

#endif //FILETRACE

#else //DBG

#define FVALUE( Val, format)
#define FTRACE( Val )

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\uni16res.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

    uni16res.h

Abstract:

    Universal printer driver specific resource header
    Windows 16 UNIDRV Font data structure

Environment:

    Windows NT printer drivers

Revision History:

    10/16/96 -eigos-
        Created it.

--*/

#ifndef _UNI16RES_H_
#define _UNI16RES_H_

//
// NOTE: It is necessary to include "uni16res.h" header before including this
//       file.
//

#ifndef _OCD_
#define _OCD_

//
// OCD are offsets into the heap to obtain a CD structure
//

typedef WORD       OCD;
typedef DWORD      LOCD;            /* double word offset to a CD  */
typedef WORD       OOCD;            /* offset to table of OCD's.  */

#endif //_OCD_

//
// Old version of the structure
//

#define DRIVERINFO_VERSION      0x0200


//
// DRIVERINFO contains extra font information needed by genlib to output text
//

#pragma pack (2)
typedef struct _DRIVERINFO
{
    short   sSize;          /* size of this structure */
    short   sVersion;       /* version number */
    WORD    fCaps;          /* Capabilties Flags */
    short   sFontID;        /* unique font id defined by the driver */
    short   sYAdjust;       /* adjust y position before output character */
                            /* used by double height characters */
    short   sYMoved;        /* cursor has moved after printing this font */
    short   sTransTab;      /* ID value for CTT */
    short   sUnderLinePos;
    short   sDoubleUnderlinePos;
    short   sStrikeThruPos;
    LOCD    locdSelect;     /* long offset to command descriptor */
    LOCD    locdUnSelect;   /* long offset to command descriptor to unselect */
                            /* NOOCD is none */

    WORD    wPrivateData;   /* Used in DeskJet driver for font enumerations */
    short   sShift;         /* # of pixels shifted from the center of the
                             * char center-line. Used for Z1 cartidge.
                             * Use a negative value representing left shift.
                             */
    WORD    wFontType;   /* Type of font */
}  DRIVERINFO;
#pragma pack ()

//
// flags defined for DRIVERINFO.fCaps
//

#define DF_NOITALIC             0x0001  // Cannot italicize via FONTSIMULATION
#define DF_NOUNDER              0x0002  // Cannot underline via FONTSIMULATION
#define DF_XM_CR                0x0004  // send CR after using this font
#define DF_NO_BOLD              0x0008  // Cannot bold via FONTSIMULATION
#define DF_NO_DOUBLE_UNDERLINE  0x0010  // Cannot double underline
                                        // via FONTSIMULATION
#define DF_NO_STRIKETHRU        0x0020  // Cannot strikethru via FONTSIMULATION
#define DF_BKSP_OK              0x0040  // Can use backspace char, see spec.


//
// Types for DRIVERINFO.wFontType
//

#define DF_TYPE_HPINTELLIFONT         0     // HP's Intellifont
#define DF_TYPE_TRUETYPE              1     // HP's PCLETTO fonts on LJ4
#define DF_TYPE_PST1                  2     // Lexmark PPDS scalable fonts
#define DF_TYPE_CAPSL                 3     // Canon CAPSL scalable fonts
#define DF_TYPE_OEM1                  4     // OEM scalable font type 1
#define DF_TYPE_OEM2                  5     // OEM scalable font type 2


//
//  The following structure has awful alignment characteristics.  So,
//  all the non-aligned entries have been turned into BYTE arrays.  This
//  ensures that the structure has the correct size,  since we MUST
//  use the data in the minidrivers,  which have this format.
//

//
// res_PFMHEADER
//

typedef struct _res_PFMHEADER
{
    short dfType;
    short dfPoints;
    short dfVertRes;
    short dfHorizRes;
    short dfAscent;
    short dfInternalLeading;
    short dfExternalLeading;
    BYTE  dfItalic;
    BYTE  dfUnderline;
    BYTE  dfStrikeOut;
    BYTE  b_dfWeight[ 2 ];        // short  dfWeight;
    BYTE  dfCharSet;
    short dfPixWidth;
    short dfPixHeight;
    BYTE  dfPitchAndFamily;
    BYTE  b_dfAvgWidth[ 2 ];      // short  dfAvgWidth;
    BYTE  b_dfMaxWidth[ 2 ];      // short  dfMaxWidth;
    BYTE  dfFirstChar;
    BYTE  dfLastChar;
    BYTE  dfDefaultChar;
    BYTE  dfBreakChar;
    BYTE  b_dfWidthBytes[ 2 ];    // short  dfWidthBytes;
    BYTE  b_dfDevice[ 4 ];        // DWORD  dfDevice;
    BYTE  b_dfFace[ 4 ];          // DWORD  dfFace;
    BYTE  b_dfBitsPointer[ 4 ];   // DWORD  dfBitsPointer;
    BYTE  b_dfBitsOffset[ 4 ];    // DWORD  dfBitsOffset;
    BYTE  dfReservedByte;
} res_PFMHEADER;

//
// PFMHEADER
//
// Following are the correctly byte aligned versions of the above
// structures with a name beginning res_
//

typedef struct _PFMHEADER
{
    DWORD       dfDevice;
    DWORD       dfFace;
    DWORD       dfBitsPointer;
    DWORD       dfBitsOffset;
    short       dfType;
    short       dfPoints;
    short       dfVertRes;
    short       dfHorizRes;
    short       dfAscent;
    short       dfInternalLeading;
    short       dfExternalLeading;
    short       dfWeight;
    short       dfPixWidth;
    short       dfPixHeight;
    short       dfAvgWidth;
    short       dfMaxWidth;
    short       dfWidthBytes;
    BYTE        dfItalic;
    BYTE        dfUnderline;
    BYTE        dfStrikeOut;
    BYTE        dfCharSet;
    BYTE        dfFirstChar;
    BYTE        dfLastChar;
    BYTE        dfDefaultChar;
    BYTE        dfBreakChar;
    BYTE        dfPitchAndFamily;
    BYTE        dfReservedByte;
} PFMHEADER;

//
// res_PFMEXTENSION
//

typedef struct _res_PFMEXTENSION
{
    WORD    dfSizeFields;
    BYTE    b_dfExtMetricsOffset[ 4 ];
    BYTE    b_dfExtentTable[ 4 ];
    BYTE    b_dfOriginTable[ 4 ];
    BYTE    b_dfPairKernTable[ 4 ];
    BYTE    b_dfTrackKernTable[ 4 ];
    BYTE    b_dfDriverInfo[ 4 ];
    BYTE    b_dfReserved[ 4 ];
} res_PFMEXTENSION;

//
// PFMEXTENSION
//
//  The aligned version of the above - for civilised users
//

typedef struct _PFMEXTENSION
{
    DWORD   dfSizeFields;               /* DWORD for alignment */
    DWORD   dfExtMetricsOffset;
    DWORD   dfExtentTable;
    DWORD   dfOriginTable;
    DWORD   dfPairKernTable;
    DWORD   dfTrackKernTable;
    DWORD   dfDriverInfo;
    DWORD   dfReserved;
} PFMEXTENSION;

//
// PFM structure used by all hardware fonts
//

typedef struct _PFM
{
    res_PFMHEADER    pfm;
    res_PFMEXTENSION pfme;
} PFM;

//
// BMFEXTENSION
//
// bitmap font extension
//

typedef struct _BMFEXTENSION
{
    DWORD   flags;              // Bit Blags
    WORD    Aspace;             // Global A space, if any
    WORD    Bspace;             // Global B space, if any
    WORD    Cspace;             // Global C space, if any
    DWORD   oColor;             // offset to color table, if any
    DWORD   reserve;
    DWORD   reserve1;
    WORD    reserve2;
    WORD    dfCharOffset[1];    // Area for storing the character offsets
} BMFEXTENSION;

//
// BMF
// bitmap font structure used by 3.0 bitmap fonts
//

typedef struct _BMF
{
    PFMHEADER       pfm;
    BMFEXTENSION    bmfe;
} BMF;

#ifndef _EXTTEXTMETRIC_
#define _EXTTEXTMETRIC_

//
// EXTTEXTMETRIC
//

typedef struct _EXTTEXTMETRIC
{
    short   emSize;
    short   emPointSize;
    short   emOrientation;
    short   emMasterHeight;
    short   emMinScale;
    short   emMaxScale;
    short   emMasterUnits;
    short   emCapHeight;
    short   emXHeight;
    short   emLowerCaseAscent;
    short   emLowerCaseDescent;
    short   emSlant;
    short   emSuperScript;
    short   emSubScript;
    short   emSuperScriptSize;
    short   emSubScriptSize;
    short   emUnderlineOffset;
    short   emUnderlineWidth;
    short   emDoubleUpperUnderlineOffset;
    short   emDoubleLowerUnderlineOffset;
    short   emDoubleUpperUnderlineWidth;
    short   emDoubleLowerUnderlineWidth;
    short   emStrikeOutOffset;
    short   emStrikeOutWidth;
    WORD    emKernPairs;
    WORD    emKernTracks;
} EXTTEXTMETRIC;

#endif //_EXTTEXTMETRIC_

//
// w3KERNPAIR
//

typedef struct _w3KERNPAIR
{
    union
    {
        BYTE each[2];
        WORD both;
    } kpPair;
    short kpKernAmount;
} w3KERNPAIR;

//
// w3KERNTRACK
//

typedef struct _w3KERNTRACK
{
    short ktDegree;
    short ktMinSize;
    short ktMinAmount;
    short ktMaxSize;
    short ktMaxAmount;
} w3KERNTRACK;


//
// TRANSTAB is used to do ANSI to OEM code pages.
//

typedef struct _TRANSTAB
{
    WORD    wType;       // tells what type of translation table
    BYTE    chFirstChar;
    BYTE    chLastChar;
    union
    {
        short   psCode[1];
        BYTE    bCode[1];
        BYTE    bPairs[1][2];
    } uCode;
} TRANSTAB, *PTRANSTAB;

//
// Defined indices for wType
//

#define CTT_WTYPE_COMPOSE   0
                //
                // uCode is an array of 16-bit offsets from the
                // beginning of the file pointing to the strings to
                // use for translation.  The length of the translated
                // string is the difference between the next offset
                // and the current offset.
                //

#define CTT_WTYPE_DIRECT    1
                //
                // uCode is a byte array of one-to-one translation
                // table from bFirstChar to bLastChar
                //

#define CTT_WTYPE_PAIRED    2
                //
                // uCode contains an array of paired unsigned
                // bytes.  If only one character is needed to do
                // the translation then the second byte is zero,
                // otherewise the second byte is struct over the
                // first byte.
                //

//
// Predefined CTT in Win95
//

#define CTT_CP437     -1    // MS-DOS United States
#define CTT_CP850     -2    // MS-DOS Multilingual (Latin I)
#define CTT_CP863     -3    // MS-DOS Canadian-French
#define CTT_BIG5      -261  // Chinese (PRC, Singapore)
#define CTT_ISC       -258  // Korean
#define CTT_JIS78     -256  // Japan
#define CTT_JIS83     -259  // Japan
#define CTT_JIS78_ANK -262  // Japan
#define CTT_JIS83_ANK -263  // Japan
#define CTT_NS86      -257  // Chinese (PRC, Singapore)
#define CTT_TCA       -260  // Chinese (PRC, Singapore)

//
// PFMDATA
//

typedef struct _PFMDATA
{
    PFMHEADER        *pPfmHeader;
    short            *pCharWidths;
    PFMEXTENSION     *pPfmExtension;
    EXTTEXTMETRIC    *pExtTextMetrics;
    short            *pExtentTable;
    DRIVERINFO       *pDriverInfo;
    w3KERNPAIR       *pKernPair;
    w3KERNTRACK      *pKernTrack;
} PFMDATA;

//
// PCMHEADER is taken from HP/PCL font installer's "pfm.h".
//

typedef struct _PCMHEADER
{
    WORD pcmMagic;
    WORD pcmVersion;
    DWORD pcmSize;
    DWORD pcmTitle;
    DWORD pcmPFMList;
} PCMHEADER;

#define PCM_MAGIC       0xCAC
#define PCM_VERSION 0x310

#endif // _UNI16RES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\uni16cid.h ===
//--------------------------------------------------------------------------//
//  Copyright (c) 1996  - 1999  Microsoft Corporation
// Filename: cmdid.h
//
// This file contains constants defined for indicies of PDEVICE.rgocd[].
// It is used as the second parameter of WriteChannel(). If a mini driver
// wants to call-back WriteChannel(), it must include this file.
//
// Created: 10/11/90    zhanw
//
// 10/25/96 -zhanw-
//  copied from \\trango\slmro tree. Remove vector commands.
//--------------------------------------------------------------------------//

// keep parentheses around constants to avoid potential errors in expansions.

//****************
// basic commands:
//****************
// --- from RESOLUTION:
#define CMD_RES_FIRST       0                                       // 0
#define CMD_RES_SELECTRES           (CMD_RES_FIRST + RES_OCD_SELECTRES)     // 0
#define CMD_RES_BEGINGRAPHICS       (CMD_RES_FIRST + RES_OCD_BEGINGRAPHICS) // 1
#define CMD_RES_ENDGRAPHICS         (CMD_RES_FIRST + RES_OCD_ENDGRAPHICS)   // 2
#define CMD_RES_SENDBLOCK           (CMD_RES_FIRST + RES_OCD_SENDBLOCK)     // 3
#define CMD_RES_ENDBLOCK            (CMD_RES_FIRST + RES_OCD_ENDBLOCK)      // 4
#define CMD_RES_LAST        (CMD_RES_FIRST + RES_OCD_MAX - 1)       // 4

// --- from COMPRESSMODE
#define CMD_CMP_FIRST       (CMD_RES_LAST + 1)                      // 5
#define CMD_CMP_NONE                (CMD_CMP_FIRST + 0)     // 5
#define CMD_CMP_RLE                 (CMD_CMP_FIRST + 1)     // 6
#define CMD_CMP_TIFF                (CMD_CMP_FIRST + 2)     // 7
#define CMD_CMP_DELTAROW            (CMD_CMP_FIRST + 3)     // 8
#define CMD_CMP_BITREPEAT           (CMD_CMP_FIRST + 4)     // 9
#define CMD_CMP_FE_RLE              (CMD_CMP_FIRST + 5)     // 10
#define CMD_CMP_LAST        (CMD_CMP_FE_RLE)                        // 10

// --- from PAGECONTROL structure
#define CMD_PC_FIRST        (CMD_CMP_LAST + 1)                      // 11
#define CMD_PC_BEGIN_DOC            (CMD_PC_FIRST + PC_OCD_BEGIN_DOC)   // 11
#define CMD_PC_BEGIN_PAGE           (CMD_PC_FIRST + PC_OCD_BEGIN_PAGE)  // 12
#define CMD_PC_DUPLEX_ON            (CMD_PC_FIRST + PC_OCD_DUPLEX_ON)   // 13
#define CMD_PC_ENDDOC               (CMD_PC_FIRST + PC_OCD_ENDDOC)      // 14
#define CMD_PC_ENDPAGE              (CMD_PC_FIRST + PC_OCD_ENDPAGE)     // 15
#define CMD_PC_DUPLEX_OFF           (CMD_PC_FIRST + PC_OCD_DUPLEX_OFF)  // 16
#define CMD_PC_ABORT                (CMD_PC_FIRST + PC_OCD_ABORT)       // 17
#define CMD_PC_PORTRAIT             (CMD_PC_FIRST + PC_OCD_PORTRAIT)    // 18
#define CMD_PC_ORIENTATION          (CMD_PC_PORTRAIT)                   // 18
#define CMD_PC_LANDSCAPE            (CMD_PC_FIRST + PC_OCD_LANDSCAPE)   // 19
#define CMD_PC_MULT_COPIES          (CMD_PC_FIRST + PC_OCD_MULT_COPIES) // 20
#define CMD_PC_DUPLEX_VERT          (CMD_PC_FIRST + PC_OCD_DUPLEX_VERT) // 21
#define CMD_PC_DUPLEX_HORZ          (CMD_PC_FIRST + PC_OCD_DUPLEX_HORZ) // 22
#define CMD_PC_PRINT_DIR            (CMD_PC_FIRST + PC_OCD_PRN_DIRECTION) // 23
#define CMD_PC_JOB_SEPARATION       (CMD_PC_FIRST + PC_OCD_JOB_SEPARATION) // 24
#define CMD_PC_LAST         (CMD_PC_FIRST + PC_OCD_MAX - 1)         // 24


// --- from CURSORMOVE
#define CMD_CM_FIRST        (CMD_PC_LAST + 1)                       // 25
#define CMD_CM_XM_ABS               (CMD_CM_FIRST + CM_OCD_XM_ABS)
#define CMD_CM_XM_REL               (CMD_CM_FIRST + CM_OCD_XM_REL)
#define CMD_CM_XM_RELLEFT           (CMD_CM_FIRST + CM_OCD_XM_RELLEFT)
#define CMD_CM_YM_ABS               (CMD_CM_FIRST + CM_OCD_YM_ABS)
#define CMD_CM_YM_REL               (CMD_CM_FIRST + CM_OCD_YM_REL)
#define CMD_CM_YM_RELUP             (CMD_CM_FIRST + CM_OCD_YM_RELUP)
#define CMD_CM_YM_LINESPACING       (CMD_CM_FIRST + CM_OCD_YM_LINESPACING)
#define CMD_CM_XY_REL               (CMD_CM_FIRST + CM_OCD_XY_REL)
#define CMD_CM_XY_ABS               (CMD_CM_FIRST + CM_OCD_XY_ABS)
#define CMD_CM_CR                   (CMD_CM_FIRST + CM_OCD_CR)
#define CMD_CM_LF                   (CMD_CM_FIRST + CM_OCD_LF)
#define CMD_CM_FF                   (CMD_CM_FIRST + CM_OCD_FF)
#define CMD_CM_BS                   (CMD_CM_FIRST + CM_OCD_BS)
#define CMD_CM_UNI_DIR              (CMD_CM_FIRST + CM_OCD_UNI_DIR)
#define CMD_CM_UNI_DIR_OFF          (CMD_CM_FIRST + CM_OCD_UNI_DIR_OFF)
#define CMD_CM_PUSH_POS             (CMD_CM_FIRST + CM_OCD_PUSH_POS)
#define CMD_CM_POP_POS              (CMD_CM_FIRST + CM_OCD_POP_POS)
#define CMD_CM_LAST         (CMD_CM_FIRST + CM_OCD_MAX - 1)         // 41

// --- from FONTSIMULATION
#define CMD_FS_FIRST        (CMD_CM_LAST + 1)                       // 42
#define CMD_FS_BOLD_ON              (CMD_FS_FIRST + FS_OCD_BOLD_ON)
#define CMD_FS_BOLD_OFF             (CMD_FS_FIRST + FS_OCD_BOLD_OFF)
#define CMD_FS_ITALIC_ON            (CMD_FS_FIRST + FS_OCD_ITALIC_ON)
#define CMD_FS_ITALIC_OFF           (CMD_FS_FIRST + FS_OCD_ITALIC_OFF)
#define CMD_FS_UNDERLINE_ON         (CMD_FS_FIRST + FS_OCD_UNDERLINE_ON)
#define CMD_FS_UNDERLINE_OFF        (CMD_FS_FIRST + FS_OCD_UNDERLINE_OFF)
#define CMD_FS_DOUBLEUNDERLINE_ON   (CMD_FS_FIRST + FS_OCD_DOUBLEUNDERLINE_ON)
#define CMD_FS_DOUBLEUNDERLINE_OFF  (CMD_FS_FIRST + FS_OCD_DOUBLEUNDERLINE_OFF)
#define CMD_FS_STRIKETHRU_ON        (CMD_FS_FIRST + FS_OCD_STRIKETHRU_ON)
#define CMD_FS_STRIKETHRU_OFF       (CMD_FS_FIRST + FS_OCD_STRIKETHRU_OFF)
#define CMD_FS_WHITE_TEXT_ON        (CMD_FS_FIRST + FS_OCD_WHITE_TEXT_ON)
#define CMD_FS_WHITE_TEXT_OFF       (CMD_FS_FIRST + FS_OCD_WHITE_TEXT_OFF)
#define CMD_FS_SINGLE_BYTE          (CMD_FS_FIRST + FS_OCD_SINGLE_BYTE)
#define CMD_FS_DOUBLE_BYTE          (CMD_FS_FIRST + FS_OCD_DOUBLE_BYTE)
#define CMD_FS_VERT_ON              (CMD_FS_FIRST + FS_OCD_VERT_ON)
#define CMD_FS_VERT_OFF             (CMD_FS_FIRST + FS_OCD_VERT_OFF)
#define CMD_FS_LAST         (CMD_FS_VERT_OFF)                       // 57

// from DEVCOLOR
#define CMD_DC_FIRST        (CMD_FS_LAST + 1)                       // 58
#define CMD_DC_TC_FIRST             (CMD_DC_FIRST)
#define CMD_DC_TC_BLACK             (CMD_DC_TC_FIRST + DC_OCD_TC_BLACK)
#define CMD_DC_TC_RED               (CMD_DC_TC_FIRST + DC_OCD_TC_RED)
#define CMD_DC_TC_GREEN             (CMD_DC_TC_FIRST + DC_OCD_TC_GREEN)
#define CMD_DC_TC_YELLOW            (CMD_DC_TC_FIRST + DC_OCD_TC_YELLOW)
#define CMD_DC_TC_BLUE              (CMD_DC_TC_FIRST + DC_OCD_TC_BLUE)
#define CMD_DC_TC_MAGENTA           (CMD_DC_TC_FIRST + DC_OCD_TC_MAGENTA)
#define CMD_DC_TC_CYAN              (CMD_DC_TC_FIRST + DC_OCD_TC_CYAN)
#define CMD_DC_TC_WHITE             (CMD_DC_TC_FIRST + DC_OCD_TC_WHITE)
#define CMD_DC_SETCOLORMODE         (CMD_DC_TC_FIRST + DC_OCD_SETCOLORMODE) //66
#define CMD_DC_PC_START             (CMD_DC_TC_FIRST + DC_OCD_PC_START)
#define CMD_DC_PC_ENTRY             (CMD_DC_TC_FIRST + DC_OCD_PC_ENTRY)
#define CMD_DC_PC_END               (CMD_DC_TC_FIRST + DC_OCD_PC_END)
#define CMD_DC_PC_SELECTINDEX       (CMD_DC_TC_FIRST + DC_OCD_PC_SELECTINDEX)
#define CMD_DC_SETMONOMODE          (CMD_DC_TC_FIRST + DC_OCD_SETMONOMODE)  // 71

#define DC_NUM_OCDS_USED            (DC_OCD_SETMONOMODE + 1)

// these are from DEVCOLOR.orgocdPlanes:
#define CMD_DC_GC_FIRST             (CMD_DC_SETMONOMODE + 1)
#define CMD_DC_GC_PLANE1            (CMD_DC_GC_FIRST + 0)       // 72
#define CMD_DC_GC_PLANE2            (CMD_DC_GC_FIRST + 1)       // 73
#define CMD_DC_GC_PLANE3            (CMD_DC_GC_FIRST + 2)       // 74
#define CMD_DC_GC_PLANE4            (CMD_DC_GC_FIRST + 3)       // 75
#define CMD_DC_LAST         (CMD_DC_GC_PLANE4)                      // 75


// --- from RECTFILL
#define CMD_RF_FIRST        (CMD_DC_LAST + 1)                       // 76
#define CMD_RF_X_SIZE               (CMD_RF_FIRST + RF_OCD_X_SIZE)
#define CMD_RF_Y_SIZE               (CMD_RF_FIRST + RF_OCD_Y_SIZE)
#define CMD_RF_GRAY_FILL            (CMD_RF_FIRST + RF_OCD_GRAY_FILL)
#define CMD_RF_WHITE_FILL           (CMD_RF_FIRST + RF_OCD_WHITE_FILL)
#define CMD_RF_LAST         (CMD_RF_WHITE_FILL)                     // 79

// --- from DOWNLOADINFO
#define CMD_DLI_FIRST       (CMD_RF_LAST + 1)   // 80
#define CMD_BEGIN_DL_JOB        (CMD_DLI_FIRST + DLI_OCD_BEGIN_DL_JOB) //81
#define CMD_BEGIN_FONT_DL       (CMD_DLI_FIRST + DLI_OCD_BEGIN_FONT_DL)
#define CMD_SET_FONT_ID         (CMD_DLI_FIRST + DLI_OCD_SET_FONT_ID)
#define CMD_SEND_FONT_DCPT      (CMD_DLI_FIRST + DLI_OCD_SEND_FONT_DESCRIPTOR)
#define CMD_SELECT_FONT_ID      (CMD_DLI_FIRST + DLI_OCD_SELECT_FONT_ID)
#define CMD_SET_CHAR_CODE       (CMD_DLI_FIRST + DLI_OCD_SET_CHAR_CODE)
#define CMD_SEND_CHAR_DCPT      (CMD_DLI_FIRST + DLI_OCD_SEND_CHAR_DESCRIPTOR)
#define CMD_END_FONT_DL         (CMD_DLI_FIRST + DLI_OCD_END_FONT_DL)
#define CMD_MAKE_PERM           (CMD_DLI_FIRST + DLI_OCD_MAKE_PERM)
#define CMD_MAKE_TEMP           (CMD_DLI_FIRST + DLI_OCD_MAKE_TEMP)
#define CMD_END_DL_JOB          (CMD_DLI_FIRST + DLI_OCD_END_DL_JOB)
#define CMD_DEL_FONT            (CMD_DLI_FIRST + DLI_OCD_DEL_FONT)
#define CMD_DEL_ALL_FONTS       (CMD_DLI_FIRST + DLI_OCD_DEL_ALL_FONTS)
#define CMD_SET_SECOND_FONT_ID  (CMD_DLI_FIRST + DLI_OCD_SET_SECOND_FONT_ID)
#define CMD_SELECT_SECOND_FONT_ID (CMD_DLI_FIRST + DLI_OCD_SELECT_SECOND_FONT_ID)
#define CMD_DLI_LAST        (CMD_DLI_FIRST + DLI_OCD_MAX - 1)   // 95

#define MAXCMD              (CMD_DLI_LAST + 1)      // 96

//*******************
// extended commands:
//*******************
#define CMD_TEXTQUALITY     (MAXCMD + 0) // command to select text quality
#define CMD_PAPERSOURCE     (MAXCMD + 1) // command to select paper source
#define CMD_PAPERQUALITY    (MAXCMD + 2) // command to select paper quality
#define CMD_PAPERDEST       (MAXCMD + 3) // selects paper destination
#define CMD_PAPERSIZE       (MAXCMD + 4) // selects paper size (Portrait or all)
#define CMD_PAPERSIZE_LAND  (MAXCMD + 5) // select landscape paper size
#define CMD_PAGEPROTECT_ON  (MAXCMD + 6) // selects page protection On
#define CMD_PAGEPROTECT_OFF (MAXCMD + 7) // selects page protection Off
#define CMD_IMAGECONTROL    (MAXCMD + 8) // selects image control option
#define CMD_PRINTDENSITY    (MAXCMD + 9) // selects image control option

#define MAXECMD             10  // total number of extended commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\xlraster.h ===
/*++

 Copyright (c) 1996  - 1999  Microsoft Corporation

 Module Name:

    common.h

Abstract:

    This file contain XL raster mode prorotypes.

Environment:

        Windows NT Unidrv driver

Revision History:

    10/25/00 -eigos-
        Created

    dd-mm-yy -author-
         description

--*/

#ifndef _XLRASTER_H_

#ifndef _PCLXLE_H_
typedef enum
{
    eDirectPixel = 0,
    eIndexedPixel = 1
} ColorMapping;

typedef enum
{
    eNoCompression = 0,
    eRLECompression = 1,
    eJPEGCompression = 2
} CompressMode;
#endif

#ifdef __cplusplus
extern "C" {
#endif

HRESULT
PCLXLSendBitmap(
    PDEVOBJ pdevobj,
    ULONG   ulInputBPP,
    LONG    lHeight,
    LONG    lScanlineWidth,
    INT     iLeft,
    INT     iRight,
    PBYTE   pbData,
    PDWORD  pdwcbOut);

HRESULT
PCLXLReadImage(
    PDEVOBJ pdevobj,
    DWORD  dwBlockHeight,
    CompressMode CMode);

HRESULT
PCLXLSetCursor(
    PDEVOBJ pdevobj,
    ULONG   ulX,
    ULONG   ulY);

HRESULT
PCLXLFreeRaster(
    PDEVOBJ pdevobj);

HRESULT
PCLXLResetPalette(
    PDEVOBJ pdevobj);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\compress.c ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    compress.c

Abstract:

    Implementation of compression formats for sending data to devices.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/15/96 -alvins-
        Created

--*/

#include        "raster.h"
#include        "compress.h"            /* Function prototypes */

//*************************************************************
int
iCompTIFF(
    BYTE *pbOBuf,
    BYTE *pbIBuf,
    int  iBCnt
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    TIFF v4 compression.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress

Return Value:

    Number of compressed bytes

Note:
    The output buffer is presumed large enough to hold the output.
    In the worst case (NO REPETITIONS IN DATA) there is an extra
    byte added every 128 bytes of input data.  So, you should make
    the output buffer at least 1% larger than the input buffer.

--*/
{
    BYTE   *pbOut;        /* Output byte location */
    BYTE   *pbStart;      /* Start of current input stream */
    BYTE   *pb;           /* Miscellaneous usage */
    BYTE   *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */
    BYTE   bLast;

    int     iSize;        /* Bytes in the current length */
    int     iSend;        /* Number to send in this command */


    pbOut = pbOBuf;
    pbStart = pbIBuf;
    pbEnd = pbIBuf + iBCnt;         /* The last byte */

#if (TIFF_MIN_RUN >= 4)
    // this is a faster algorithm for calculating TIFF compression
    // that assumes a minimum RUN of at least 4 bytes. If the
    // third and fourth byte don't equal then the first/second bytes are
    // irrelevant. This means we can determine non-run data three times
    // as fast since we only check every third byte pair.

   if (iBCnt > TIFF_MIN_RUN)
   {
    // make sure the last two bytes aren't equal so we don't have to check
    // for the buffer end when looking for runs
    bLast = pbEnd[-1];
    pbEnd[-1] = ~pbEnd[-2];
    while( (pbIBuf += 3) < pbEnd )
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // save the run start pointer, pb, and check whether the first
            // bytes are also part of the run
            //
            pb = pbIBuf-1;
            if (*pbIBuf == pbIBuf[-2])
            {
                pb--;
                if (*pbIBuf == pbIBuf[-3])
                    pb--;
            }

            //  Find out how long this run is
            jLast = *pb;
            do {
                pbIBuf++;
            } while (*pbIBuf == jLast);

            // test whether last byte is also part of the run
            //
            if (jLast == bLast && pbIBuf == (pbEnd-1))
                pbIBuf++;

            // Determine if the run is longer that the required
            // minimum run size.
            //
            if ((iSend = (int)(pbIBuf - pb)) >= (TIFF_MIN_RUN))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = (int)(pb - pbStart)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */
                iSize = iSend;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
        }
    }
    pbEnd[-1] = bLast;
   }
#else
    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */
            pb = pbIBuf;
            do {
                pbIBuf++;
            } while (pbIBuf < pbEnd && *pbIBuf == jLast);

            /*
             *  Note that pb points at the SECOND byte of the pattern!
             *  AND also that pbIBuf points at the first byte AFTER the run.
             */

            if ((iSend = pbIBuf - pb) >= (TIFF_MIN_RUN - 1))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = pb - pbStart - 1) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                iSize = iSend + 1;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
            if (pbIBuf == pbEnd)
                break;
        }

        jLast = *pbIBuf++;                   /* Onto the next byte */

    }
#endif

    if ((iSize = (int)(pbEnd - pbStart)) > 0)
    {
        /*  Left some dangling.  This can only be literal data.   */

        while( (iSend = min( iSize, TIFF_MAX_LITERAL )) > 0 )
        {
            *pbOut++ = iSend - 1;
            CopyMemory( pbOut, pbStart, iSend );
            pbOut += iSend;
            pbStart += iSend;
            iSize -= iSend;
        }
    }

    return  (int)(pbOut - pbOBuf);
}
//**********************************************************
int
iCompFERLE(
    BYTE *pbOBuf,
    BYTE *pbIBuf,
    int  iBCnt,
    int  iMaxCnt
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    Far East Run length encoding.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress
    iMaxCnt     Maximum number of bytes to create on output

Return Value:

    Number of compressed bytes or -1 if too large for buffer

--*/
{
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbI;          /* Scanning for runs */
    BYTE   *pbIEnd;      /* First byte past end of input data */
    BYTE   *pbStart;     /* Start of current data stream */
    BYTE   *pbTmp;
    BYTE    jLast;       /* Previous byte */

    int     iSize;       /* Number of bytes in the run */

    if (iBCnt == 0)
        return 0;

    pbO = pbOBuf;                 /* Working copy */
    pbIEnd = pbIBuf + iBCnt;          /* Gone too far if we reach here */

    /*
     * Calculate the maximum amount of data we will generate
     */

    pbStart = pbIBuf;

    while (++pbIBuf < pbIEnd)
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // valid run but we will first output any literal data
            if ((iSize = (int)(pbIBuf - pbStart) - 1) > 0)
            {
                if ((iMaxCnt -= iSize) < 0)  // test for output overflow
                    return -1;
                CopyMemory(pbO,pbStart,iSize);
                pbO += iSize;
            }

            // determine the run length
            jLast = *pbIBuf;
            pbI = pbIBuf;
            pbTmp = pbIBuf + FERLE_MAX_RUN - 1;
            if (pbTmp > pbIEnd)
                pbTmp = pbIEnd;
            do {
                pbIBuf++;
            } while (pbIBuf < pbTmp && *pbIBuf == jLast);

            iSize = (int)(pbIBuf - pbI) + 1; /* Number of times */

            // output the RLE strings
            if ((iMaxCnt -= 3) < 0)       // test for output overflow
                return -1;
            *pbO++ = jLast;             // copy data byte twice
            *pbO++ = jLast;
            *pbO++ = (BYTE)iSize;

            // test if we are done
            if( pbIBuf == pbIEnd )
                return (int)(pbO - pbOBuf);

            // setup for continuation of loop
            pbStart = pbIBuf;
        }
    }

    /*
     *  Since the data did not end in a run we must output the last
     *  literal data if we haven't overflowed the buffer.
     */
    iSize = (int)(pbIBuf - pbStart);

    if (iMaxCnt < iSize)
        return -1;

    CopyMemory(pbO,pbStart,iSize);
    pbO += iSize;
    return (int)(pbO - pbOBuf);
}

//****************************************************
int
iCompDeltaRow(
    BYTE  *pbOBuf,
    BYTE  *pbIBuf,
    BYTE  *pbPBuf,
    int   iBCnt,
    int   iLimit
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    delta row compression.

Arguments:

    pbOBuf      Pointer to output buffer
    pbIBuf      Pointer to data buffer to compress
    pbPBuf      Pointer to previous row data buffer
    iBCnt       Number of bytes in the above
    iLimit      Don't exceed this number of compressed bytes

Return Value:

    Number of compressed bytes or -1 if too large for buffer

Note:
    A return value of 0 is valid since it implies the two lines
    are identical.

--*/

{
#ifdef _X86_
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    BYTE   *pbIEnd;
    BYTE   *pbStart;
    BYTE   *pb;
    int    iDelta;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */

    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */
    pbO = pbOBuf;                 /* Working copy */
    pbOEnd = pbOBuf + iLimit - 2;
    iDelta = pbPBuf - pbIBuf;
    pbIEnd = pbIBuf + iBCnt;
    pbStart = pbIBuf;

    //
    // this is the main loop for compressing the data
    //
    while (pbIBuf < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbIBuf & 3))
        {
            while (pbIBuf <= (pbIEnd-4) && *(DWORD *)pbIBuf == *(DWORD *)&pbIBuf[iDelta])
                pbIBuf += 4;
            if (pbIBuf >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbIBuf != pbIBuf[iDelta])
        {
            // determine the run length
            pb = pbIBuf;
            do {
                pb++;
            } while (pb < pbIEnd && *pb != pb[iDelta]);

            iSize = (int)(pb - pbIBuf);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            if (((iSize * 9 + 7) >> 3) > (pbOEnd - pbO))     // gives tighter code
                return -1;
            iOffset = (int)(pbIBuf - pbStart);
            if (iOffset > 30)
            {
                if (iSize < 8)
                    *pbO++ = ((iSize-1) << 5) + 31;
                else
                    *pbO++ = (7 << 5) + 31;
                iOffset -= 31;
                while (iOffset >= 255)
                {
                    iOffset -= 255;
                    *pbO++ = 255;
                }
                *pbO++ = (BYTE)iOffset;
                if (iSize > 8)
                    goto FastEightByteRun;
            }
            else if (iSize > 8)
            {
                *pbO++ = (7 << 5) + iOffset;
FastEightByteRun:
                while (1)
                {
                    CopyMemory(pbO,pbIBuf,8);
                    pbIBuf += 8;
                    pbO += 8;
                    if ((iSize -= 8) <= 8)
                        break;
                    *pbO++ = (7 << 5);
                }
                *pbO++ = (iSize-1) << 5;
            }
            else
                *pbO++ = ((iSize-1) << 5) + iOffset;

            CopyMemory (pbO,pbIBuf,iSize);
            pbIBuf += iSize;
            pbO += iSize;
            pbStart = pbIBuf;
        }
        pbIBuf++;
    }
    return (int)(pbO - pbOBuf);
#else
    BYTE   *pbO;         /* Record output location */
    BYTE   *pbOEnd;      /* As far as we will go in the output buffer */
    BYTE   *pbIEnd;
    BYTE   *pbStart;
    BYTE   *pb;
    int    iOffset;     // index of current data stream
    int    iSize;       /* Number of bytes in the run */

    /*
     *   Limit the amount of data we will generate. For performance
     * reasons we will ignore the effects of an offset value
     * greater than 30 since it implies we were able to already skip
     * that many bytes. However, for safety sake we will reduce the
     * max allowable size by 2 bytes.
     */
    pbO = pbOBuf;                 /* Working copy */
    pbOEnd = pbOBuf + iLimit - 2;
    pbIEnd = pbIBuf + iBCnt;
    pbStart = pbIBuf;

    //
    // this is the main loop for compressing the data
    //
    while (pbIBuf < pbIEnd)
    {
        // fast skip for matching dwords
        //
        if (!((ULONG_PTR)pbIBuf & 3))
        {
            while (pbIBuf <= (pbIEnd-4) && *(DWORD *)pbIBuf == *(DWORD *)pbPBuf)
            {
                pbIBuf += 4;
                pbPBuf += 4;
            }
            if (pbIBuf >= pbIEnd)
                break;
        }
        // test for non-matching bytes and output the necessary compression string
        //
        if (*pbIBuf != *pbPBuf)
        {
            // determine the run length
            pb = pbIBuf;
            do {
                pb++;
                pbPBuf++;
            } while (pb < pbIEnd && *pb != *pbPBuf);

            iSize = (int)(pb - pbIBuf);

            // Lets make sure we have room in the buffer before
            // we continue this, this compression algorithm adds
            // 1 byte for every 8 bytes of data worst case.
            //
            if (((iSize * 9 + 7) >> 3) > (int)(pbOEnd - pbO))
                return -1;

            // special case the initial offset value since it
            // occurs only once and may require extra bytes
            //
            if ((iOffset = (int)(pbIBuf - pbStart)))
            {
                int iSend = min (iSize,8);
                if (iOffset > 30)
                {
                    *pbO++ = ((iSend-1) << 5) + 31;
                    iOffset -= 31;
                    while (iOffset >= 255)
                    {
                        *pbO++ = 255;
                        iOffset -= 255;
                    }
                    *pbO++ = (BYTE)iOffset;
                }
                else
                {
                    *pbO++ = ((iSend-1) << 5) + iOffset;
                }
                // output the initial changed bytes
                CopyMemory(pbO,pbIBuf,iSend);
                pbIBuf += iSend;
                pbO += iSend;
                iSize -= iSend;
            }

            // now output any remaining changed data
            //
            while (iSize)
            {
                if (iSize >= 8)
                {
                    *pbO++ = (8 - 1) << 5;
                    CopyMemory(pbO,pbIBuf,8);
                    pbIBuf += 8;
                    pbO += 8;
                    iSize -= 8;
                }
                else
                {
                    *pbO++ = (iSize-1) << 5;
                    CopyMemory(pbO,pbIBuf,iSize);
                    pbIBuf += iSize;
                    pbO += iSize;
                    break;
                }
            }
            pbStart = pbIBuf;
        }
        pbIBuf++;
        pbPBuf++;
    }
    return (int)(pbO - pbOBuf);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\inc\vectorif.h ===
/*++

Copyright (c) 1996  - 1999  Microsoft Corporation

Module Name:

        vectorif.h

Abstract:

        Interface between Control module and Vector module

Environment:

        Windows NT Unidrv driver

Revision History:

        02/29/00 -hsingh-
                Created

        mm-dd-yy -author-
                description

--*/


#ifndef _VECTORIF_H_
#define _VECTORIF_H_

#define HANDLE_VECTORHOOKS(pdev, ep, pfn, resultType, args) \
        if ((pdev)->pVectorProcs != NULL && \
            ((PVMPROCS)(pdev)->pVectorProcs)->pfn != NULL && \
            (pdev)->dwVMCallingFuncID != ep) \
        { \
            resultType result; \
            DWORD      dwCallerFuncID;\
            dwCallerFuncID = (pdev)->dwVMCallingFuncID;\
            (pdev)->dwVMCallingFuncID = ep; \
            (pdev)->devobj.pdevOEM = (pdev)->pVectorPDEV; \
            result = (((PVMPROCS)(pdev)->pVectorProcs)->pfn) args; \
            (pdev)->dwVMCallingFuncID = dwCallerFuncID; \
            return result; \
        }

#define HANDLE_VECTORPROCS_RET(pdev, pfn, retval, args) \
    if ((pdev)->pVectorProcs != NULL && \
        ((PVMPROCS)(pdev)->pVectorProcs)->pfn != NULL ) \
    { \
        (pdev)->devobj.pdevOEM = (pdev)->pVectorPDEV; \
        retval = (((PVMPROCS)(pdev)->pVectorProcs)->pfn) args;\
    }

#define HANDLE_VECTORPROCS(pdev, pfn, args) \
    if ((pdev)->pVectorProcs != NULL && \
        ((PVMPROCS)(pdev)->pVectorProcs)->pfn != NULL ) \
    { \
        (pdev)->devobj.pdevOEM = (pdev)->pVectorPDEV; \
        (((PVMPROCS)(pdev)->pVectorProcs)->pfn) args;\
    }

BOOL
VMInit (
        PDEV    *pPDev,
        DEVINFO *pDevInfo,
        GDIINFO *pGDIInfo
        );

//
// This structure provides a table of pointers to each function exported 
// by the plugin.
// The first part consists of functions defined in oemkm.h. 
// under the heading . "Unidrv specific COM wrappers"
// The second part consists of DDI's
//
//
// The order of functions listed is same as the order in 
// static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
//
typedef struct _VMPROCS {

    //
    // Part. 1
    // Functions listed in oemkm.h
    //
        BOOL
        (*VMDriverDMS)(
                PVOID   pdevobj,
                PVOID   pvBuffer,
                DWORD   cbSize,
                PDWORD  pcbNeeded
                );

        INT
        (*VMCommandCallback)(
                PDEVOBJ pdevobj,
                DWORD   dwCmdCbID,
                DWORD   dwCount,
                PDWORD  pdwParams
                );

        LONG
        (*VMImageProcessing)(
                PDEVOBJ             pdevobj,
                PBYTE               pSrcBitmap,
                PBITMAPINFOHEADER   pBitmapInfoHeader,
                PBYTE               pColorTable,
                DWORD               dwCallbackID,
                PIPPARAMS           pIPParams,
                OUT PBYTE           *ppbResult
                );

        LONG
        (*VMFilterGraphics)(
                PDEVOBJ     pdevobj,
                PBYTE       pBuf,
                DWORD       dwLen
                );

        
        LONG
        (*VMCompression)(
                PDEVOBJ     pdevobj,
                PBYTE       pInBuf,
                PBYTE       pOutBuf,
                DWORD       dwInLen,
                DWORD       dwOutLen,
                INT     *piResult
                );

        LONG
        (*VMHalftonePattern)(
                PDEVOBJ     pdevobj,
                PBYTE       pHTPattern,
                DWORD       dwHTPatternX,
                DWORD       dwHTPatternY,
                DWORD       dwHTNumPatterns,
                DWORD       dwCallbackID,
                PBYTE       pResource,
                DWORD       dwResourceSize
                );


        LONG
        (*VMMemoryUsage)(
                PDEVOBJ         pdevobj,
                POEMMEMORYUSAGE pMemoryUsage
                );

        LONG
        (*VMTTYGetInfo)(
                PDEVOBJ     pdevobj,
                DWORD       dwInfoIndex,
                PVOID       pOutputBuf,
                DWORD       dwSize,
                DWORD       *pcbcNeeded
                );

        LONG
        (*VMDownloadFontHeader)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG
        (*VMDownloadCharGlyph)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                HGLYPH      hGlyph,
                PDWORD      pdwWidth,
                OUT DWORD   *pdwResult
                );

        LONG
        (*VMTTDownloadMethod)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                OUT DWORD   *pdwResult
                );

        LONG
        (*VMOutputCharStr)(
                PDEVOBJ     pdevobj,
                PUNIFONTOBJ pUFObj,
                DWORD       dwType,
                DWORD       dwCount,
                PVOID       pGlyph
                );

        
        LONG
        (*VMSendFontCmd)(
                PDEVOBJ      pdevobj,
                PUNIFONTOBJ  pUFObj,
                PFINVOCATION pFInv
                );

        BOOL
        (*VMTextOutAsBitmap)(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

    //
    // Part 2.
    // Functions listed in enable.c
    // The order of functions listed is same as the order in 
    // static DRVFN UniDriverFuncs[]  in unidrv2\control\enable.c
    //
        PDEVOEM
        (*VMEnablePDEV)(
                PDEVOBJ   pdevobj,
                PWSTR     pPrinterName,
                ULONG     cPatterns,
                HSURF    *phsurfPatterns,
                ULONG     cjGdiInfo,
                GDIINFO  *pGdiInfo,
                ULONG     cjDevInfo,
                DEVINFO  *pDevInfo,
                DRVENABLEDATA  *pded        // Unidrv's hook table
                );

        BOOL
        (*VMResetPDEV)(
                PDEVOBJ  pPDevOld,
                PDEVOBJ  pPDevNew
                );

        VOID
        (*VMCompletePDEV)(
                DHPDEV  dhpdev,
                HDEV    hdev
                );

        VOID
        (*VMDisablePDEV)(
                PDEVOBJ pPDev
                );

        BOOL
        (*VMEnableSurface)(
                PDEVOBJ pPDev
                );

        VOID
        (*VMDisableSurface)(
                PDEVOBJ pPDev
                );

        VOID
        (*VMDisableDriver)(
                VOID
                );

        BOOL
        (*VMStartDoc)(
                SURFOBJ *pso,
                PWSTR   pDocName,
                DWORD   jobId
                );

        BOOL
        (*VMStartPage) (
                SURFOBJ *pso
                );

        BOOL
        (*VMSendPage)(
                SURFOBJ *pso
                );

        BOOL
        (*VMEndDoc)(
                SURFOBJ *pso,
                FLONG   flags
                );

        BOOL
        (*VMStartBanding)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*VMNextBand)(
                SURFOBJ *pso,
                POINTL *pptl
                );

        BOOL
        (*VMPaint)(
                SURFOBJ         *pso,
                CLIPOBJ         *pco,
                BRUSHOBJ        *pbo,
                POINTL          *pptlBrushOrg,
                MIX             mix
                );

        BOOL
        (*VMBitBlt)(
                SURFOBJ    *psoTrg,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclTrg,
                POINTL     *pptlSrc,
                POINTL     *pptlMask,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrush,
                ROP4        rop4
                );

        BOOL
        (*VMStretchBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode
                );

#ifndef WINNT_40
        BOOL
        (*VMStretchBltROP)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                SURFOBJ    *psoMask,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                COLORADJUSTMENT *pca,
                POINTL     *pptlHTOrg,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                POINTL     *pptlMask,
                ULONG       iMode,
                BRUSHOBJ   *pbo,
                DWORD       rop4
                );

        BOOL
        (*VMPlgBlt)(
                SURFOBJ         *psoDst,
                SURFOBJ         *psoSrc,
                SURFOBJ         *psoMask,
                CLIPOBJ         *pco,
                XLATEOBJ        *pxlo,
                COLORADJUSTMENT *pca,
                POINTL          *pptlBrushOrg,
                POINTFIX        *pptfixDest,
                RECTL           *prclSrc,
                POINTL          *pptlMask,
                ULONG           iMode
                );
#endif  //ifndef WINNT_40

        BOOL
        (*VMCopyBits)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                POINTL     *pptlSrc
                );

        ULONG
        (*VMDitherColor)(
                DHPDEV  dhpdev,
                ULONG   iMode,
                ULONG   rgbColor,
                ULONG  *pulDither
                );

        BOOL
        (*VMRealizeBrush)(
                BRUSHOBJ   *pbo,
                SURFOBJ    *psoTarget,
                SURFOBJ    *psoPattern,
                SURFOBJ    *psoMask,
                XLATEOBJ   *pxlo,
                ULONG       iHatch
                );

        BOOL 
        (*VMLineTo)(
                SURFOBJ    *pso,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                LONG        x1,
                LONG        y1,
                LONG        x2,
                LONG        y2,
                RECTL      *prclBounds,
                MIX         mix
                );
        
        BOOL
        (*VMStrokePath)(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                LINEATTRS  *plineattrs,
                MIX         mix
                );
        
        BOOL
        (*VMFillPath)(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                BRUSHOBJ   *pbo,
                POINTL     *pptlBrushOrg,
                MIX         mix,
                FLONG       flOptions 
                );
        
        BOOL
        (*VMStrokeAndFillPath)(
                SURFOBJ    *pso,
                PATHOBJ    *ppo,
                CLIPOBJ    *pco,
                XFORMOBJ   *pxo,
                BRUSHOBJ   *pboStroke,
                LINEATTRS  *plineattrs,
                BRUSHOBJ   *pboFill,
                POINTL     *pptlBrushOrg,
                MIX         mixFill,
                FLONG       flOptions
                );
        
#ifndef WINNT_40
        BOOL
        (*VMGradientFill)(
                SURFOBJ    *psoDest,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                TRIVERTEX  *pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL      *prclExtents,
                POINTL     *pptlDitherOrg,
                ULONG       ulMode
                );

        BOOL
        (*VMAlphaBlend)(
                SURFOBJ    *psoDest,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDest,
                RECTL      *prclSrc,
                BLENDOBJ   *pBlendObj
                );

        BOOL
        (*VMTransparentBlt)(
                SURFOBJ    *psoDst,
                SURFOBJ    *psoSrc,
                CLIPOBJ    *pco,
                XLATEOBJ   *pxlo,
                RECTL      *prclDst,
                RECTL      *prclSrc,
                ULONG      iTransColor,
                ULONG      ulReserved
                );
#endif // ifndef WINNT_40

        BOOL
        (*VMTextOut)(
                SURFOBJ    *pso,
                STROBJ     *pstro,
                FONTOBJ    *pfo,
                CLIPOBJ    *pco,
                RECTL      *prclExtra,
                RECTL      *prclOpaque,
                BRUSHOBJ   *pboFore,
                BRUSHOBJ   *pboOpaque,
                POINTL     *pptlOrg,
                MIX         mix
                );

        ULONG
        (*VMEscape)(
                SURFOBJ    *pso,
                ULONG       iEsc,
                ULONG       cjIn,
                PVOID       pvIn,
                ULONG       cjOut,
                PVOID       pvOut
                );

        PIFIMETRICS
        (*VMQueryFont)(
                DHPDEV      dhpdev,
                ULONG_PTR   iFile,
                ULONG       iFace,
                ULONG_PTR  *pid
                );

        PVOID
        (*VMQueryFontTree)(
                DHPDEV      dhpdev,
                ULONG_PTR   iFile,
                ULONG       iFace,
                ULONG       iMode,
                ULONG_PTR  *pid 
                );

        LONG
        (*VMQueryFontData)(
                DHPDEV      dhpdev,
                FONTOBJ    *pfo,
                ULONG       iMode,
                HGLYPH      hg,
                GLYPHDATA  *pgd,
                PVOID       pv,
                ULONG       cjSize
                );

        ULONG
        (*VMGetGlyphMode)(
                DHPDEV  dhpdev,
                FONTOBJ *pfo
                );

        ULONG
        (*VMFontManagement)(
                SURFOBJ *pso,
                FONTOBJ *pfo,
                ULONG   iMode,
                ULONG   cjIn,
                PVOID   pvIn,
                ULONG   cjOut,
                PVOID   pvOut
                );

        BOOL
        (*VMQueryAdvanceWidths)(
                DHPDEV  dhpdev,
                FONTOBJ *pfo,
                ULONG   iMode,
                HGLYPH *phg,
                PVOID  *pvWidths,
                ULONG   cGlyphs
                );

}VMPROCS, * PVMPROCS;

#endif  // !_VECTORIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\compress.h ===
/****************************** MODULE HEADER ******************************
 * compress.h
 *        Function prototypes and other curiosities associated with data
 *        compression code.
 *
 *   Copyright (C) 1997 - 1999  Microsoft Corporation.
 *
 ****************************************************************************/


//
// this parameter controls how much better (in bytes) a new compression mode
// must do before it will be used instead of the current output mode
#define COMP_FUDGE_FACTOR 4

/*
 *   TIFF Compression function.
 */
int  iCompTIFF( BYTE *, BYTE *, int );

//
//  Delta Row Compression function
//
int iCompDeltaRow(BYTE *, BYTE *, BYTE *, int, int);


/*
 *   Some constants defining the limits of TIFF encoding.  The first
 * represent the minimum number of repeats for which it is worth using
 * a repeat operation.  The other two represent the maximum length
 * of data that can be encoded in one control byte.
 */

#define TIFF_MIN_RUN       4            /* Minimum repeats before use RLE */
#define TIFF_MAX_RUN     128            /* Maximum repeats */
#define TIFF_MAX_LITERAL 128            /* Maximum consecutive literal data */

/*
 *   RLE (Run Length Encoding) functions.
 */

int  iCompRLE( BYTE *, BYTE *, int );
int  iCompFERLE (BYTE *, BYTE *, int, int );
/*
 *   Some constants relating to RLE operations.  RLE is ony useful in
 *  data containing runs.  In purely random data, the data size will
 *  double.  Consequently,  we allow a certain expansion of the data
 *  size before calling it off.  A small expansion is OK,  since the
 *  there is a cost involved in switching compression on and off.
 */

#define    FERLE_MAX_RUN    255          /* max consecutive byte count */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\raster.h ===
/*++

Copyright (c) 1996 - 1999  Microsoft Corporation

Module Name:

    raster.h

Abstract:

    Raster module main header file.

Environment:

    Windows NT Unidrv driver

Revision History:

    10/14/96 -amandan-
        Created

    12/10/96 -alvins-
        Added required header info for raster module
    dd-mm-yy -author-
        description

--*/


#ifndef _RASTER_H_
#define _RASTER_H_


#include "lib.h"
#include "unilib.h"
#include "gpd.h"
#include "mini.h"
#include "winres.h"
#include "pdev.h"
#include "palette.h"
#include "common.h"
#include "rasterif.h"
#include "printoem.h"
#include "oemutil.h"
#include "rastpdev.h"

#endif  // !_RASTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\print\drivers\usermode\unidrv2\render\initpal.c ===
/****************** Module Header *********************
*
* Copyright (c) 1996 - 1999  Microsoft Corporation
*
* initpal.c
*
* HISTORY
* 14:21 on Wed 05 July 1995   -by-   Sandra Matts
* initial version
*
*
******************************************************/

#include    "raster.h"

/* defines for color manipulation    */
#define RED_VALUE(c)   ((BYTE) c & 0xff)
#define GREEN_VALUE(c) ((BYTE) (c >> 8) & 0xff)
#define BLUE_VALUE(c)  ((BYTE) (c >> 16) & 0xff)

/************************** Function Header *********************************
 * lSetup8BitPalette
 *      Function to read in the 256 color palette from GDI into the
 *      palette data structure in Dev Info.
 *
 * RETURNS:
 *      The number of colors in the palette. Returns 0 if the call fails.
 *
 * HISTORY:
 *  10:43 on Wed 06 Sep 1995    -by-    Sandra Matts
 *      Created it to support the Color LaserJet
 *
 ****************************************************************************/
long lSetup8BitPalette (pRPDev, pPD, pdevinfo, pGDIInfo)
RASTERPDEV   *pRPDev;
PAL_DATA  *pPD;
DEVINFO   *pdevinfo;             /* Where to put the data */
GDIINFO   *pGDIInfo;
{

    long    lRet;
    int     _iI;

    PALETTEENTRY  pe[ 256 ];      /* 8 bits per pel - all the way */


    FillMemory (pe, sizeof (pe), 0xff);
    lRet = HT_Get8BPPFormatPalette(pe,
                                  (USHORT)pGDIInfo->ciDevice.RedGamma,
                                  (USHORT)pGDIInfo->ciDevice.GreenGamma,
                                  (USHORT)pGDIInfo->ciDevice.BlueGamma );
#if PRINT_INFO

    DbgPrint("RedGamma = %d, GreenGamma = %d, BlueGa