ect the globals!

***************************************************************************/
HRESULT OpenNotifySession(LPNOTIFICATION_LIST * lppNotificationList,
  LPHANDLE lphmemNotificationList,
  LPHANDLE lphmtxNotificationList,
  LPHANDLE lphevNotificationList) {
    HRESULT hResult = hrSuccess;
    BOOL fMutex = FALSE;
    TCHAR szName[CharSizeOf(szNotificationName) + CharSizeOf(szMEM)];


    StrCpyN(szName, szNotificationName, ARRAYSIZE(szName));
    StrCatBuff(szName, szMTX, ARRAYSIZE(szName));
    if (! (*lphmtxNotificationList = OpenMutex(SYNCHRONIZE,
      FALSE,                                            // inherit handle?
      szName))) {
        DebugTrace("OpenNotifySession:OpenMutex(%s) -> %u\n", szName, GetLastError());
        // No Advise sessions exist, don't bother with this.
        hResult = ResultFromScode(WAB_W_NO_ADVISE);
        goto exit;
    }

    if (hResult = HrWaitForObject(*lphmtxNotificationList, NOTIFY_CREATE_TIMEOUT)) {
        DebugTrace("CreateNotifySession:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    StrCpyN(szName, szNotificationName, ARRAYSIZE(szName));
    StrCatBuff(szName, szMEM, ARRAYSIZE(szName));
    if ((*lphmemNotificationList = CreateFileMapping(INVALID_HANDLE_VALUE,   // handle
      NULL,                                             // security descriptor
      PAGE_READWRITE | SEC_RESERVE,                     // reserve more
      0,                                                // max size high
      MAX_NOTIFICATION_SPACE,                           // max size low
      szName)) == NULL) {                               // name
        DebugTrace("CreateNotifySession: CreateFileMapping --> %u\n",
          GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    if ((*lppNotificationList = (LPNOTIFICATION_LIST)MapViewOfFile(*lphmemNotificationList,
      FILE_MAP_WRITE | FILE_MAP_READ,
      0,
      0,
      sizeof(NOTIFICATION_LIST))) == NULL) {
        DebugTrace("CreateNotifySession: CreateFileMapping --> %u\n",
          GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Initialize global notification list
    Assert((*lppNotificationList)->cAdvises != 0);                // Number of advise processes

    // Notification Event
    StrCpyN(szName, szNotificationName, ARRAYSIZE(szName));
    StrCatBuff(szName, szEVT, ARRAYSIZE(szName));
    if (! (*lphevNotificationList = CreateEvent(NULL,
      TRUE,                                             // Manual reset
      FALSE,                                            // initial state (not triggered)
      szName))) {
        DebugTrace("OpenNotifySession:CreateEvent(%S) -> %u\n", szName, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

exit:
    if (fMutex) {
        ReleaseMutex(*lphmtxNotificationList);
    }
    if (hResult) {
        // Failure, clean up
        if (*lphmemNotificationList) {
            CloseHandle(*lphmemNotificationList);
            *lphmemNotificationList = NULL;
        }

        if (*lphmtxNotificationList) {
            CloseHandle(*lphmtxNotificationList);
            *lphmtxNotificationList = NULL;
        }
        if (*lphevNotificationList) {
            CloseHandle(*lphevNotificationList);
            *lphevNotificationList = NULL;
        }
    }

    return(hResult);
}
#endif // NEW_STUFF


/***************************************************************************

    Name      : HrWaitForObject

    Purpose   : Wait for an object to be signalled

    Parameters: handle = object handle
                dwTimeout = timeout in milliseconds

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrWaitForObject(HANDLE handle, DWORD dwTimeout) {
    switch (WaitForSingleObject(handle, dwTimeout)) {
        case WAIT_ABANDONED:
            DebugTrace(TEXT("WARNING:HrWaitForObject got WAIT_ABANDONED\n"));
            // fall through to success
        case WAIT_OBJECT_0:
            return(hrSuccess);
        case WAIT_TIMEOUT:
            DebugTrace(TEXT("HrWaitForObject timed out\n"));
            return(ResultFromScode(MAPI_E_TIMEOUT));
        case WAIT_FAILED:
        default:
            DebugTrace(TEXT("HrWaitForObject failed -> %u\n"), GetLastError());
            return(ResultFromScode(MAPI_E_CALL_FAILED));
    }
}


/***************************************************************************

    Name      : HrWABNotify

    Purpose   : Scans registered clients and Notifies them of a store modification
                The first-cut at notifications is extremely simplistic. Any time
                the WAB store changes, we fire off a store notification. No attempt
                to check eventmasks or entryids etc

    Parameters: lpIAB = THIS object

    Returns   : HRESULT

    Comment   : What happens in here:

***************************************************************************/
HRESULT HrWABNotify(LPIAB lpIAB)
{
    HRESULT hResult = hrSuccess;

    LPADVISE_NODE lpAdviseNode = NULL;
    NOTIFICATION WABNotif = {0};

    EnterCriticalSection(&lpIAB->cs);

    if (!lpIAB->pWABAdviseList ||
        !lpIAB->pWABAdviseList->cAdvises) 
    {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }


    // Since calling applications may have no idea of container/folder changes, but may
    // call container based methods ..
    // update the list of WAB containers for that applicaiton so that GetContentsTable etc
    // will work correctly ..
    if(bAreWABAPIProfileAware(lpIAB))
        HrGetWABProfiles(lpIAB);

    WABNotif.ulEventType = fnevObjectModified;
    WABNotif.info.obj.ulObjType = MAPI_ADDRBOOK;
    WABNotif.info.obj.cbEntryID = WABNotif.info.obj.cbParentID = 
        WABNotif.info.obj.cbOldID = WABNotif.info.obj.cbOldParentID = 0; 
    WABNotif.info.obj.lpEntryID = WABNotif.info.obj.lpParentID = 
        WABNotif.info.obj.lpOldID = WABNotif.info.obj.lpOldParentID = NULL;
    WABNotif.info.obj.lpPropTagArray = NULL;

    lpAdviseNode = lpIAB->pWABAdviseList->lpNode;
    while(lpAdviseNode)
    {
        lpAdviseNode->lpAdviseSink->lpVtbl->OnNotify(lpAdviseNode->lpAdviseSink,
                                                     1,
                                                     &WABNotif);
        lpAdviseNode = lpAdviseNode->lpNext;
    }

exit:

    LeaveCriticalSection(&lpIAB->cs);

    return(hResult);


}

/***************************************************************************

    Name      : HrAdvise

    Purpose   : Performs client notification registration

    Parameters: lpIAB = THIS object
                cbEntryID = sizeof lpEntryID
                lpEntryID -> EntryID of object about which notifications
                  should be generated.
                ulEventMask = events about which to generate notifications
                  fnevObjectCreated
                  fnevObjectDeleted
                  fnevObjectModified
                  fnevTableModified
                  NOTE: WAB currently does not support fnevCriticalError,
                  fnevObjectCopied or fnevObjectMoved.
                lpAdviseSink -> Client's advise sink object
                lpulConnection -> returned connection number (client should
                  save to pass to Unadvise.)

    Returns   : HRESULT

    Comment   : What happens in here:
                    Store the EventMask and AdviseSink in the local advise list.
                    If there are no other Advise sessions open in this process:
                      Make sure there is one and register it

***************************************************************************/
HRESULT HrAdvise(LPIAB lpIAB,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  ULONG ulEventMask,
  LPMAPIADVISESINK lpAdvise,
  ULONG FAR * lpulConnection) 
{
    HRESULT hResult = hrSuccess;

    BOOL fExisted = FALSE;
    LPADVISE_NODE lpAdviseNode = NULL, lpTemp = NULL;
    static ULONG ulNextConnection = 1;

    EnterCriticalSection(&lpIAB->cs);

    if(!lpIAB->pWABAdviseList)
    {
        lpIAB->pWABAdviseList = LocalAlloc(LMEM_ZEROINIT, sizeof(ADVISE_LIST));
        if(!lpIAB->pWABAdviseList)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        lpIAB->pWABAdviseList->cAdvises = 0;
        lpIAB->pWABAdviseList->lpNode = NULL;
    }

    lpAdviseNode = LocalAlloc(LMEM_ZEROINIT, sizeof(ADVISE_NODE) + cbEntryID);
    if(!lpAdviseNode)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpAdviseNode->ulConnection = ulNextConnection++;
    lpAdviseNode->ulEventMask = ulEventMask;
    lpAdviseNode->lpAdviseSink = lpAdvise;
    if(cbEntryID && lpEntryID)
    {
        CopyMemory(&lpAdviseNode->EntryID, lpEntryID, cbEntryID);
    }

    lpAdviseNode->lpPrev = NULL;
    lpAdviseNode->lpNext = lpIAB->pWABAdviseList->lpNode;
    if(lpIAB->pWABAdviseList->lpNode)
        lpIAB->pWABAdviseList->lpNode->lpPrev = lpAdviseNode;
    lpIAB->pWABAdviseList->lpNode = lpAdviseNode;
    lpIAB->pWABAdviseList->cAdvises++;

    // Addref the LPADVISESINK pointer so we have a handle on it ...
    //
    lpAdvise->lpVtbl->AddRef(lpAdvise);
    *lpulConnection = lpAdviseNode->ulConnection;

exit:
    LeaveCriticalSection(&lpIAB->cs);

    return(hResult);


#ifdef NEW_STUFF
/*
    // Walk the advise list looking for the connection
    // Make sure we're safe to monkey with the list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) 
    {
        DebugTrace("HrUnadvise:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

  // Is there an open Advise session for this process?
    // If not, set up the advise session for this process.
    if (! lpNotificationList) {
        if (hResult = CreateNotifySession(&fExisted)) {
            DebugTraceResult( TEXT("HrAdvise:CreateNotifySession"), hResult);
            goto exit;
        }
    }

    // Add Advise info to Local Advise List.

    // Create the new node
    if (! (lpAdviseNode = LocalAlloc(LPTR, sizeof(ADVISE_NODE) + cbEntryID))) {
        DebugTrace("LocalAlloc(%u) AdviseNode -> %u\n", sizeof(ADVISE_NODE) + cbEntryID, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    lpAdviseNode->ulConnection = ulNextConnection++;
    lpAdviseNode->lpAdviseSink = lpAdvise;
    lpAdviseNode->ulEventMask = ulEventMask;
    lpAdviseNode->cbEntryID = cbEntryID;
    CopyMemory(&lpAdviseNode->EntryID, lpEntryID, cbEntryID);

    // Add the new node to front of the list

    // Make sure we're safe to monkey with the list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) {
        DebugTrace("HrAdvise:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    lpAdviseNode->lpNext = AdviseList.lpNode;
    AdviseList.lpNode = lpAdviseNode;
    AdviseList.cAdvises++;
    *lpulConnection = lpAdviseNode->ulConnection;

exit:
    if (fMutex) {
        ReleaseMutex(hmtxAdviseList);
    }
#else
    hResult = ResultFromScode(MAPI_E_CALL_FAILED);
*/
#endif

}


/***************************************************************************

    Name      : HrUnadvise

    Purpose   : Removes an Advise from the list

    Parameters: ulConnection = connection number to remove

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrUnadvise(LPIAB lpIAB, ULONG ulConnection) {
    HRESULT hResult = hrSuccess;

    BOOL fMutex = FALSE;
    LPADVISE_NODE lpAdviseNode = NULL;

    EnterCriticalSection(&lpIAB->cs);

    if (!lpIAB->pWABAdviseList ||
        !lpIAB->pWABAdviseList->cAdvises) 
    {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    lpAdviseNode = lpIAB->pWABAdviseList->lpNode;

    while (lpAdviseNode) 
    {
        if (lpAdviseNode->ulConnection == ulConnection) 
        {
            if(lpIAB->pWABAdviseList->lpNode == lpAdviseNode)
                lpIAB->pWABAdviseList->lpNode = lpAdviseNode->lpNext;

            if(lpAdviseNode->lpPrev)
                lpAdviseNode->lpPrev->lpNext = lpAdviseNode->lpNext;
            if(lpAdviseNode->lpNext)
                lpAdviseNode->lpNext->lpPrev = lpAdviseNode->lpPrev;

            // Release the hold on this pointer ...
            lpAdviseNode->lpAdviseSink->lpVtbl->Release(lpAdviseNode->lpAdviseSink);

            LocalFreeAndNull(&lpAdviseNode);

            lpIAB->pWABAdviseList->cAdvises--;

            //Assert(lpIAB->pWABAdviseList->cAdvises == 0 && lpIAB->pWABAdviseList->lpNode == NULL);
                
            if(!lpIAB->pWABAdviseList->cAdvises && !lpIAB->pWABAdviseList->lpNode)
            {
                LocalFree(lpIAB->pWABAdviseList);
                lpIAB->pWABAdviseList = NULL;
            }

            goto exit;
        }
        lpAdviseNode = lpAdviseNode->lpNext;
    }

    hResult = ResultFromScode(MAPI_E_NOT_FOUND);

exit:
    LeaveCriticalSection(&lpIAB->cs);
    return(hResult);


/*
#ifdef NEW_STUFF
    BOOL fMutex = FALSE;
    LPADVISE_NODE lpAdviseNode = NULL;
    LPADVISE_NODE * lppPrevNode = &(AdviseList.lpNode);

    if (hmtxAdviseList == NULL || AdviseList.cAdvises == 0) {
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // Walk the advise list looking for the connection
    // Make sure we're safe to monkey with the list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) {
        DebugTrace("HrUnadvise:Mutex wait failed\n");
        goto exit;
    }
    fMutex = TRUE;

    lpAdviseNode = AdviseList.lpNode;

    while (lpAdviseNode) {
        if (lpAdviseNode->ulConnection == ulConnection) {
            // Found it, remove from list
            *lppPrevNode = lpAdviseNode->lpNext;

            // BUGBUG: Don't forget to remove any notifications that haven't been
            // processed by this process yet.

            // Free the node
            LocalFreeAndNull(&lpAdviseNode);
            goto exit;
        }
        lppPrevNode = &(lpAdviseNode->lpNext);
        lpAdviseNode = lpAdviseNode->lpNext;
    }

    hResult = ResultFromScode(MAPI_E_NOT_FOUND);

exit:
    if (fMutex) {
        ReleaseMutex(hmtxAdviseList);
    }
#else
    hResult = ResultFromScode(MAPI_E_CALL_FAILED);
#endif

    return(hResult);
*/
}


/***************************************************************************

    Name      : HrFireNotification

    Purpose   : Fire a notification

    Parameters: lpNotification -> NOTIFICATION structure

    Returns   : HRESULT

    Comment   : What happens in here:
                    if shared memory exists
                        Map in the shared memory
                        Add the notification to the global Advise list
                        Set the count on this notification to the global
                          advise count.
                        trigger the Global Advise Event.

***************************************************************************/
HRESULT HrFireNotification(LPNOTIFICATION lpNotification) {
    HRESULT hResult = hrSuccess;
#ifdef NEW_STUFF
    LPNOTIFICATION_LIST lpNotifyList = NULL;
    HANDLE hmemNotifyList = NULL;
    HANDLE hmtxNotifyList = NULL;
    HANDLE hevNotifyList = NULL;
    LPNOTIFICATION_NODE lpNewNode = NULL, lpTempNode, *lppPrevNode;
    BOOL fNotifyMutex = FALSE, fAdviseMutex = FALSE;
    BOOL fOpened = FALSE;

    Assert(lpNotification);

    // If there is an Advise session, use it, else create a temporary
    // Notification session
    if (lpNotificationList) {
        lpNotifyList = lpNotificationList;
        hmtxNotifyList = hmtxNotificationList;
        hevNotifyList = hevNotificationList;
    } else {
        if (hResult = OpenNotifySession(&lpNotifyList,
          &hmemNotifyList,
          &hmtxNotifyList,
          &hevNotifyList)) {
            DebugTraceResult( TEXT("HrAdvise:OpenNotifySession"), hResult);
            // No waiting advise sessions, there's no point in continuing
            goto exit;
        }
        fOpened = TRUE;
    }


    // Request access to the Global Notification List
    if (hResult = HrWaitForObject(hmtxNotifyList, FIRE_NOTIFY_TIMEOUT)) {
        DebugTrace("HrFireNotification:Mutex wait failed\n");
        goto exit;
    }
    fNotifyMutex = TRUE;

    // Add the notification to the beginning of the global notification list
    // create a new node for it

    if (! (lpNewNode = LocalAlloc(LPTR, sizeof(NOTIFICATION_NODE)))) {
        DebugTrace("LocalAlloc(%u) NotificationNode -> %u\n", sizeof(NOTIFICATION_NODE), GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }


    lpNewNode->cbSize = sizeof(NOTIFICATION_NODE);

// BUGBUG: This doesn't copy the stuff pointed to in the notification structure!
    CopyMemory(&lpNewNode->Notification, lpNotification, sizeof(NOTIFICATION));

    // Add the new node to END of the list.  Note that it must go to the end
    // of the list so that the unique identifiers are kept in order.

    // Make sure we're safe to monkey with the Advise list
    if (hResult = HrWaitForObject(hmtxAdviseList, ADVISE_TIMEOUT)) {
        DebugTrace("HrAdvise:Mutex wait failed\n");
        goto exit;
    }
    fAdviseMutex = TRUE;

    lpNewNode->lpNext = NULL;

    lpTempNode = lpNotifyList->lpNode;
    lppPrevNode = &lpNotifyList->lpNode;
    while (lpTempNode) {
        lppPrevNode = &lpTempNode->lpNext;
        lpTempNode = lpTempNode->lpNext;
    }
    *lppPrevNode = lpNewNode;

    // Set the count on this notification to the global
    //   advise count.
    lpNewNode->ulCount = lpNotificationList->cAdvises;

    // Set the unique identifier for this notification
    lpNewNode->ulIdentifier = lpNotifyList->ulNextIdentifier++;

    // trigger the Global Advise Event.
    if (! PulseEvent(hevNotifyList)) {
        DebugTrace("HrFireNotification:PulseEvent -> %u\n", GetLastError());
        // what are ya gonna do?
        hResult = ResultFromScode(MAPI_E_CALL_FAILED);
        goto exit;
    }


exit:
    if (fNotifyMutex) {
        ReleaseMutex(hmtxNotifyList);
    }
    if (fAdviseMutex) {
        ReleaseMutex(hmtxAdviseList);
    }

    // Clean up the stuff if we opened it.
    if (fOpened) {
        if (lpNotifyList) {
            UnmapViewOfFile(lpNotifyList);
        }
        if (hmemNotifyList) {
            CloseHandle(hmemNotifyList);
        }
        if (hmtxNotifyList) {
            CloseHandle(hmtxNotifyList);
        }
        if (hevNotifyList) {
            CloseHandle(hevNotifyList);
        }
    }

#else
    hResult = ResultFromScode(MAPI_E_CALL_FAILED);
#endif
    return(hResult);
}

#ifdef NEW_STUFF
/***************************************************************************

    Name      : AdviseThread

    Purpose   : Thread routine for advise

    Parameters: lpdwParam = Thread parameter

    Returns   : DWORD return code.

    Comment   : What happens in here:
                    loop until Unadvise
                        wait for trigger of the Global Advise Event or Unadvise event
                        if Advise Event
                            Loop through global advise list
                                if we haven't already dealt with this notification
                                    check events in global advise list against local advise list
                                    if match
                                        call client's NotifCallback
                                    Decrement count in this notification
                                    if count == 0
                                        remove this item from the global advise list

                        if Unadvise
                            decrement global advise count
                            exit thread

***************************************************************************/
DWORD AdviseThread(LPDWORD lpdwParam) {
    BOOL fNotifyMutex = FALSE, fAdviseMutex = FALSE;
    LPNOTIFICATION_NODE lpNotifyNode = NULL, *lppNotifyPrev;
    LPADVISE_NODE lpAdviseNode = NULL;

    // loop until Unadvise
    while (TRUE) {
        // wait for trigger of the Global Advise Event or Unadvise event
        switch(WaitForTwoObjects(hevNotificationList, hevKillAdvise, ADVISE_THREAD_TIMEOUT)) {
            case 0:
                // New notification
                break;
            case (ULONG)-1:
                // error
                DebugTrace("AdviseThread:WaitForTwoObjects error\n");
                // fall through to kill
            case 1:
                // kill advise
                DebugTrace("Terminating AdviseThread\n");
                goto exit;
        }

        // New notification
        // Loop through global notification list
        // Gain access to list
        // wait for trigger of the Global Advise Event or Unadvise event
        switch(WaitForTwoObjects(hmtxNotificationList, hevKillAdvise, NOTIFY_ADVISE_TIMEOUT)) {
            case 0:
                // Got the List Mutex
                fNotifyMutex = TRUE;
                break;
            case (ULONG)-1:
                // error
                DebugTrace("AdviseThread:WaitForTwoObjects error\n");
                // fall through to kill
            case 1:
                // kill advise
                DebugTrace("Terminating AdviseThread\n");
                goto exit;
        }
        Assert(fNotifyMutex);

        // Also need to look at the local advise list
        switch(WaitForTwoObjects(hmtxAdviseList, hevKillAdvise, NOTIFY_ADVISE_TIMEOUT)) {
            case 0:
                // Got the List Mutex
                fAdviseMutex = TRUE;
                break;
            case (ULONG)-1:
                // error
                DebugTrace("AdviseThread:WaitForTwoObjects error\n");
                // fall through to kill
            case 1:
                // kill advise
                DebugTrace("Terminating AdviseThread\n");
                goto exit;
        }
        Assert(fAdviseMutex);

        lpNotifyNode = lpNotificationList->lpNode;
        lppNotifyPrev = &(lpNotificationList->lpNode);

        while (lpNotifyNode) {
            // if we haven't already dealt with this notification
            if (lpNotifyNode->ulIdentifier > ulMaxIdentifierSeen) {
                // We haven't seen this one yet.  Process it.
                // NOTE: For this to work, new notification nodes must be added
                // at the END of the notification list!
                ulMaxIdentifierSeen = lpNotifyNode->ulIdentifier;

                // check this notification event against local advise list
                lpAdviseNode = AdviseList.lpNode;
                while (lpAdviseNode) {
                    if (lpNotifyNode->Notification.ulEventType & lpAdviseNode->ulEventMask) {
                        // Right event type, is it the right object?
                        switch (lpNotifyNode->Notification.ulEventType) {
                            case fnevCriticalError:
                                // ERROR_NOTIFICATION
                                if (CompareEntryIDs(lpAdviseNode->cbEntryID,
                                  (LPENTRYID)&lpAdviseNode->EntryID,
                                  lpNotifyNode->Notification.info.err.cbEntryID,
                                  lpNotifyNode->Notification.info.err.lpEntryID)) {
                                    // This is it!
                                    // Call the notification callback
                                    lpAdviseNode->lpAdviseSink->lpVtbl->OnNotify(lpAdviseNode->lpAdviseSink,
                                      1,
                                      &lpNotifyNode->Notification);
                                }
                                break;
                            case fnevObjectCreated:
                            case fnevObjectDeleted:
                            case fnevObjectModified:
                            case fnevObjectCopied:
                            case fnevObjectMoved:
                            case fnevSearchComplete:
                                // OBJECT_NOTIFICATION
                                if (CompareEntryIDs(lpAdviseNode->cbEntryID,
                                  (LPENTRYID)&lpAdviseNode->EntryID,
                                  lpNotifyNode->Notification.info.obj.cbEntryID,
                                  lpNotifyNode->Notification.info.obj.lpEntryID)) {
                                    // This is it!
                                    // Call the notification callback
                                    lpAdviseNode->lpAdviseSink->lpVtbl->OnNotify(lpAdviseNode->lpAdviseSink,
                                      1,
                                      &lpNotifyNode->Notification);
                                }
                                break;

                            case fnevTableModified:
                                //  TABLE_NOTIFICATION
                                // BUGBUG: NYI

                                break;
                            default:
                                break;
                        }
                    }
                    lpAdviseNode = lpAdviseNode->lpNext;
                }

                // Decrement count in this notification
                // if count == 0
                // remove this item from the global notification list
                if (--lpNotifyNode->ulCount == 0) {
                    *lppNotifyPrev = lpNotifyNode->lpNext;
                    LocalFree(lpNotifyNode);
                    lpNotifyNode = *lppNotifyPrev;
                } else {
                    lpNotifyNode = lpNotifyNode->lpNext;
                }
            }
        }

        if (fNotifyMutex) {
            fNotifyMutex = FALSE;
            ReleaseMutex(hmtxNotificationList);
        }
        if (fAdviseMutex) {
            fAdviseMutex = FALSE;
            ReleaseMutex(hmtxAdviseList);
        }
    }

exit:
    // exit thread

    return(0);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\profiles.c ===
/*
 * Profiles.C - Stuff dealing with WAB Profile Handling
 *
 */


#include <_apipch.h>

enum {
    proDisplayName=0,
    proObjectType,
    proFolderEntries,
    proFolderShared,
    proFolderOwner,     // upto this many props are common to all folders
    proUserSubFolders,
    proUserProfileID,   // these are used by User Folders only
    proUserFolderMax,
};

#define proFolderMax proUserSubFolders


/*
- helper function for quick saving of folder props
-
*/
HRESULT HrSaveFolderProps(LPADRBOOK lpAdrBook, BOOL bCreateUserFolder, ULONG ulcProps, LPSPropValue lpProps, LPMAPIPROP * lppObject)
{
    HRESULT hr = S_OK;
    LPMAPIPROP lpObject = NULL;
    ULONG ulFlags = CREATE_CHECK_DUP_STRICT;
    BOOL bTryAgain = FALSE;

TryAgain:

    // Create a new mailuser for this entry
    if(HR_FAILED(hr = HrCreateNewObject(lpAdrBook, NULL, MAPI_MAILUSER, ulFlags, &lpObject)))
        goto out;

    if(HR_FAILED(hr = lpObject->lpVtbl->SetProps(   lpObject, ulcProps, lpProps,NULL)))
        goto out;

    if(bCreateUserFolder)
    {
        // if we are creating a user folder, we can't rely on the currently loaded folder-
        // container info so we will forcibly reset the parent folder item on the MailUser/Folder
        // object we are savign
        ((LPMailUser)lpObject)->pmbinOlk = NULL;
    }

    // SaveChanges
    if(HR_FAILED(hr = lpObject->lpVtbl->SaveChanges(lpObject, KEEP_OPEN_READWRITE)))
    {
        if(!bCreateUserFolder || hr != MAPI_E_COLLISION)
            goto out;

        // If something already exists with this same exact name, we want to merge with it
        // without losing any info on it, since most likely, the original dupe is also a contact
        if(!bTryAgain)
        {
            bTryAgain = TRUE;
            ulFlags |= CREATE_REPLACE | CREATE_MERGE;
            lpObject->lpVtbl->Release(lpObject);
            lpObject = NULL;
            lpProps[proFolderEntries].ulPropTag = PR_NULL; // don't overwrite the folder's contents
            goto TryAgain;
        }
    }

    if(lppObject)
    {
        *lppObject = lpObject;
        lpObject = NULL;
    }
out:
    if(lpObject)
        lpObject->lpVtbl->Release(lpObject);

    return hr;
}

/*
-
-   FreeProfileContainerInfo(lpIAB)
*
*
*
*/
void FreeProfileContainerInfo(LPIAB lpIAB)
{
    if( lpIAB && 
        lpIAB->cwabci && 
        lpIAB->rgwabci)
    {
        //ULONG i = 0;
        //for(i=0;i<lpIAB->cwabci;i++)
        //    LocalFreeAndNull(&(lpIAB->rgwabci[i].lpszName));
        if( lpIAB->rgwabci[0].lpEntryID &&
            !lpIAB->rgwabci[0].lpEntryID->cb &&
            !lpIAB->rgwabci[0].lpEntryID->lpb && 
            lpIAB->rgwabci[0].lpszName && 
            lstrlen(lpIAB->rgwabci[0].lpszName))
        {
            LocalFree(lpIAB->rgwabci[0].lpEntryID);
            LocalFree(lpIAB->rgwabci[0].lpszName);
        }
        
        LocalFreeAndNull(&(lpIAB->rgwabci));
        lpIAB->cwabci = 0;
    }
}

/*
-
-   FindWABFolder - Searches the list of cached folders for a specific WAB folder
-
*       The search is based on either the EID or the Name or the ProfileID
*       If ProfileID is specified, we only search for user folders 
*
*/
LPWABFOLDER FindWABFolder(LPIAB lpIAB, LPSBinary lpsb, LPTSTR lpName, LPTSTR lpProfileID)
{
    LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
    BOOL bUserFolders = FALSE;

    if(!lpFolder || lpProfileID)
    {
        lpFolder = lpIAB->lpWABUserFolders;
        bUserFolders = TRUE;
    }
    while(lpFolder)
    {
        if(lpsb)
        {
            if( lpsb->cb == lpFolder->sbEID.cb && 
                !memcmp(lpsb->lpb, lpFolder->sbEID.lpb, lpsb->cb) )
                return lpFolder;
        }
        else
        if(lpName)
        {
            if(!lstrcmpi(lpFolder->lpFolderName, lpName))
                return lpFolder;
        }
        else
        if(lpProfileID)
        {
            if( lpFolder->lpProfileID && 
                !lstrcmpi(lpFolder->lpProfileID, lpProfileID))
                return lpFolder;
        }
        lpFolder = lpFolder->lpNext;
        if(!lpFolder && !bUserFolders)
        {
            lpFolder = lpIAB->lpWABUserFolders;
            bUserFolders = TRUE;
        }
    }
    return NULL;
}



/*
-
-   HrGetWABProfileContainerInfo
*
*   Looks up all the folders for the current user and tabulates
*   them into a list of container names and entry ids for easy access
*   similar to Outlook ...
*   If there is no current user, we'll include all the folders for now
*
*/
HRESULT HrGetWABProfileContainerInfo(LPIAB lpIAB)
{
    HRESULT hr = E_FAIL;
    ULONG j = 0, i = 0, cVal = 0, cUserFolders = 0, cOtherFolders = 0;
    LPWABFOLDER lpFolder = NULL;
    LPWABFOLDERLIST lpFolderItem = NULL;

    if(lpIAB->cwabci)
        FreeProfileContainerInfo(lpIAB);

    if(!bIsThereACurrentUser(lpIAB))
    {
        // No specific user specified .. need to add ALL folders

        // Count all the folders
        lpFolder = lpIAB->lpWABUserFolders;
        while(lpFolder)
        {
            cUserFolders++;
            lpFolder = lpFolder->lpNext;
        }

        lpFolder = lpIAB->lpWABFolders;
        while(lpFolder)
        {
            cOtherFolders++;
            lpFolder = lpFolder->lpNext;
        }

        cVal = cUserFolders + cOtherFolders + 1; // +1 for Virtual PAB
    }
    else
    {
        // For a user, we add all the user's folders except shared ones followed by
        // all the shared folders...
        lpFolderItem = lpIAB->lpWABCurrentUserFolder->lpFolderList;
        while(lpFolderItem)
        {
            if(!lpFolderItem->lpFolder->bShared)
                cVal++;
            lpFolderItem = lpFolderItem->lpNext;
        }
        lpFolder = lpIAB->lpWABFolders;
        while(lpFolder)
        {
            if(lpFolder->bShared)
                cVal++;
            lpFolder = lpFolder->lpNext;
        }
        cVal++; // add 1 for the user folder itself
        cVal++; // add 1 for a virtual root item for this user  TEXT("All Contacts")
    }

    if(cVal)
    {
        if(!(lpIAB->rgwabci = LocalAlloc(LMEM_ZEROINIT, sizeof(struct _OlkContInfo)*cVal)))
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        cUserFolders = 0;
        // Add the  TEXT("All Contacts") item to the root - entryid is 0, NULL
        {
            TCHAR sz[MAX_PATH];
            ULONG cchSize;
            int nID = (bDoesThisWABHaveAnyUsers(lpIAB)) ? idsSharedContacts : idsContacts;
            LoadString(hinstMapiX, nID, sz, CharSizeOf(sz));
            cchSize = lstrlen(sz)+1;
            if(!(lpIAB->rgwabci[cUserFolders].lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize)))
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }
            StrCpyN(lpIAB->rgwabci[cUserFolders].lpszName, sz, cchSize);
            lpIAB->rgwabci[cUserFolders].lpEntryID = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
            cUserFolders++;
        }
        if(!lpIAB->lpWABCurrentUserFolder)
        {
            lpFolder = lpIAB->lpWABUserFolders;
            while(lpFolder)
            {
                lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolder->sbEID);
                lpIAB->rgwabci[cUserFolders].lpszName = lpFolder->lpFolderName;
                cUserFolders++;
                lpFolder = lpFolder->lpNext;
            }
            lpFolder = lpIAB->lpWABFolders;
            while(lpFolder)
            {
                lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolder->sbEID);
                lpIAB->rgwabci[cUserFolders].lpszName = lpFolder->lpFolderName;
                cUserFolders++;
                lpFolder = lpFolder->lpNext;
            }
        }
        else
        {
            // Add the first folder and then find the other folders one by one
            lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpIAB->lpWABCurrentUserFolder->sbEID);
            lpIAB->rgwabci[cUserFolders].lpszName = lpIAB->lpWABCurrentUserFolder->lpFolderName;
            cUserFolders++;
            lpFolderItem = lpIAB->lpWABCurrentUserFolder->lpFolderList;
            while(lpFolderItem)
            {
                if(!lpFolderItem->lpFolder->bShared)
                {
                    lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolderItem->lpFolder->sbEID);
                    lpIAB->rgwabci[cUserFolders].lpszName = lpFolderItem->lpFolder->lpFolderName;
                    cUserFolders++;
                }
                lpFolderItem = lpFolderItem->lpNext;
            }

            lpFolder = lpIAB->lpWABFolders;
            while(lpFolder)
            {
                if(lpFolder->bShared)
                {
                    lpIAB->rgwabci[cUserFolders].lpEntryID = &(lpFolder->sbEID);
                    lpIAB->rgwabci[cUserFolders].lpszName = lpFolder->lpFolderName;
                    cUserFolders++;
                }
                lpFolder = lpFolder->lpNext;
            }
        }
    
        lpIAB->cwabci = cUserFolders;
    }
    hr = S_OK;

out:
    if(HR_FAILED(hr) && lpIAB->rgwabci)
        FreeProfileContainerInfo(lpIAB);

    return hr;
}



/*
-   FreeWABFoldersList
-
-
*   Clears up existing Profile Folders info from the IAB object
*/
void FreeFolderItem(LPWABFOLDER lpFolder)
{
    LPWABFOLDERLIST lpFolderItem = NULL;
    if(!lpFolder)
        return;
    LocalFreeAndNull(&lpFolder->lpFolderName);
    LocalFreeAndNull(&lpFolder->lpProfileID);
    LocalFreeAndNull((LPVOID *) (&lpFolder->sbEID.lpb));
    LocalFreeAndNull(&lpFolder->lpFolderOwner);
    lpFolderItem = lpFolder->lpFolderList;
    while(lpFolderItem)
    {
        lpFolder->lpFolderList = lpFolderItem->lpNext;
        LocalFree(lpFolderItem);
        lpFolderItem = lpFolder->lpFolderList;
    }
    LocalFree(lpFolder);
}
void FreeWABFoldersList(LPIAB lpIAB)
{
    LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
    while(lpFolder)
    {
        lpIAB->lpWABFolders = lpFolder->lpNext;
        FreeFolderItem(lpFolder);
        lpFolder = lpIAB->lpWABFolders;    
    }
    lpFolder = lpIAB->lpWABUserFolders;
    while(lpFolder)
    {
        lpIAB->lpWABFolders = lpFolder->lpNext;
        FreeFolderItem(lpFolder);
        lpFolder = lpIAB->lpWABFolders;    
    }
    lpIAB->lpWABUserFolders = NULL;
    lpIAB->lpWABCurrentUserFolder = NULL;
    lpIAB->lpWABFolders = NULL;
}


/*
- SetCurrentUserFolder - scans list and updates pointer
-
*
*/
void SetCurrentUserFolder(LPIAB lpIAB, LPTSTR lpszProfileID)
{
    LPWABUSERFOLDER lpFolder = lpIAB->lpWABUserFolders;

    while(lpFolder && lpszProfileID && lstrlen(lpszProfileID))
    {
        if(!lstrcmpi(lpFolder->lpProfileID, lpszProfileID))
        {
            lpIAB->lpWABCurrentUserFolder = lpFolder;
            break;
        }
        lpFolder = lpFolder->lpNext;
    }
}

/*
-
-   CreateUserFolderName
*
*/
void CreateUserFolderName(LPTSTR lpProfile, LPTSTR * lppszName)
{
    LPTSTR lpName = NULL;
    TCHAR sz[MAX_PATH];
    LoadString(hinstMapiX, idsUsersContacts, sz, CharSizeOf(sz));
    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  sz, 0, 0, (LPTSTR)&lpName, 0, (va_list *)&lpProfile);
    *lppszName = lpName;
}


/*
-   HrLinkOrphanFoldersToDefaultUser(lpIAB)
-
*   If there are any folders that are associated with deleted users or that have
*   no parent and are orphaned, we want to associate them with the default user
*
*   This function is dependent on lpFolder->bOwned being correctly set in the
*       HrLinkUserFoldersToWABFolders
*
*/
HRESULT HrLinkOrphanFoldersToDefaultUser(LPIAB lpIAB)
{
    HRESULT hr = S_OK;
    LPWABUSERFOLDER lpDefUser = NULL;
    LPWABFOLDER lpFolder = NULL;
    TCHAR szDefProfile[MAX_PATH + 1];

    // First detect the user folder corresponding to the Default User
    *szDefProfile = '\0';
    if( HR_FAILED(hr = HrGetDefaultIdentityInfo(lpIAB, DEFAULT_ID_PROFILEID, NULL, szDefProfile, ARRAYSIZE(szDefProfile), NULL, 0)))
    {
        if(hr == 0x80040154) // E_CLASS_NOT_REGISTERD means no IDentity Manager
            hr = S_OK;
        else
            goto out;
    }

    if(lstrlen(szDefProfile))
    {
        lpDefUser = FindWABFolder(lpIAB, NULL, NULL, szDefProfile);
    }
    else
    {
        // can't find the default user so just fall back to picking someone at random
        lpDefUser = lpIAB->lpWABUserFolders;
    }

    // see if there are any orphan folders 
    // To qualify as an orphan, the lpFolder->bOwned should be FALSE and the folder must
    // also not be shared because if it's shared it will show up as part of Shared Contacts
    lpFolder = lpIAB->lpWABFolders;
    while(lpFolder)
    {
        if(!lpFolder->bOwned && !lpFolder->bShared)
        {
            LPWABUSERFOLDER lpOwnerFolder = lpDefUser;
            if(lpFolder->lpFolderOwner)
            {
                // Someone created this folder .. we need to make sure this is associated back to that original
                // creator and only if that doesn't work should we append it to the default user
                if(!(lpOwnerFolder = FindWABFolder(lpIAB, NULL, NULL, lpFolder->lpFolderOwner)))
                    lpOwnerFolder = lpDefUser;
            }
            
            if(lpOwnerFolder)
            {
                if(HR_FAILED(hr = HrAddRemoveFolderFromUserFolder(  lpIAB, lpDefUser, 
                                                                    &lpFolder->sbEID, NULL, FALSE ) ))
                    goto out;
            }
        }
        lpFolder = lpFolder->lpNext;
    }

out:
    return hr;

}


/*
-   HrLinkUserFoldersToWABFolders
-
*
*   Cross-links the user folder contents with the regular folders
*   This makes accessing folder info much easier ..
*/
HRESULT HrLinkUserFoldersToWABFolders(LPIAB lpIAB)
{
    HRESULT hr = S_OK;
    LPWABUSERFOLDER lpUserFolder = NULL;
    LPWABFOLDER lpFolder = NULL;
    ULONG ulcPropCount = 0, i = 0, j = 0;
    LPSPropValue lpProp = NULL;

    if(!lpIAB->lpWABUserFolders || !lpIAB->lpWABFolders)
        goto out;

    lpUserFolder = lpIAB->lpWABUserFolders;
    while(lpUserFolder)
    {
        if(HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, &lpUserFolder->sbEID,
                                     0, &ulcPropCount, &lpProp)))
            goto out;

        for(i=0;i<ulcPropCount;i++)
        {
            if(lpProp[i].ulPropTag == PR_WAB_USER_SUBFOLDERS)
            {
                for(j=0;j<lpProp[i].Value.MVbin.cValues;j++)
                {
                    lpFolder = FindWABFolder(lpIAB, &(lpProp[i].Value.MVbin.lpbin[j]), NULL, NULL);
                    if(lpFolder)
                    {
                        LPWABFOLDERLIST lpFolderItem = LocalAlloc(LMEM_ZEROINIT, sizeof(WABFOLDERLIST));
                        if(lpFolderItem)
                        {
                            lpFolderItem->lpFolder = lpFolder;
                            lpFolder->bOwned = TRUE;
                            lpFolderItem->lpNext = lpUserFolder->lpFolderList;
                            lpUserFolder->lpFolderList = lpFolderItem;
                        }
                    }
                }
                break;
            }
        }
        ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
        ulcPropCount = 0; 
        lpProp = NULL;
        lpUserFolder = lpUserFolder->lpNext;
    }

out:
    ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
    return hr;
}


/*
-   HrGetFolderInfo()
-
*   Reads a folder name directly from the prop store
*   Also checks if this is a user folder and what the profile is
*   Returns LocalAlloced LPTSTRs which caller needs to free
*/
HRESULT HrGetFolderInfo(LPIAB lpIAB, LPSBinary lpsbEID, LPWABFOLDER lpFolder)
{
    LPTSTR lpName = NULL, lpProfileID = NULL, lpOwner = NULL;
    HRESULT hr = S_OK;
    ULONG ulcPropCount = 0, j=0;
    LPSPropValue lpProp = NULL;
    BOOL bShared = FALSE;

    if(!bIsWABSessionProfileAware(lpIAB) || !lpsbEID)
        goto out;

    if(!lpsbEID->cb && !lpsbEID->lpb)
    {
        // special case - read the address book item
        lpName = LocalAlloc(LMEM_ZEROINIT, MAX_PATH);
        if(lpName)
            LoadString(hinstMapiX, idsContacts/*IDS_ADDRBK_CAPTION*/, lpName, MAX_PATH-1);
    }
    else
    {
        hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, lpsbEID,
                        0, &ulcPropCount, &lpProp);
        if(HR_FAILED(hr))
            goto out;

        for(j=0;j<ulcPropCount;j++)
        {
            ULONG cchSize;
            if(lpProp[j].ulPropTag == PR_DISPLAY_NAME)
            {
                cchSize = lstrlen(lpProp[j].Value.LPSZ)+1;
                if(lpName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize))
                    StrCpyN(lpName, lpProp[j].Value.LPSZ, cchSize);
                else
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
            }
            if(lpProp[j].ulPropTag == PR_WAB_USER_PROFILEID)
            {
                cchSize = lstrlen(lpProp[j].Value.LPSZ)+1;
                if(lpProfileID = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize))
                    StrCpyN(lpProfileID, lpProp[j].Value.LPSZ, cchSize);
                else
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
            }
            if(lpProp[j].ulPropTag == PR_WAB_FOLDEROWNER)
            {
                TCHAR szName[CCH_IDENTITY_NAME_MAX_LENGTH]; 
                *szName = '\0';
                if( !HR_FAILED(HrGetIdentityName(lpIAB, lpProp[j].Value.LPSZ, szName, ARRAYSIZE(szName))) &&
                    lstrlen(szName))
                {
                    cchSize = lstrlen(szName)+1;
                    if(lpOwner = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize))
                        StrCpyN(lpOwner, szName, cchSize);
                    else
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                }
            }
            if(lpProp[j].ulPropTag == PR_WAB_SHAREDFOLDER)
            {
                bShared = (lpProp[j].Value.l==FOLDER_SHARED?TRUE:FALSE);
            }
        }

        // ideally, we should be reading in a new name for all user folders at this point
        //if(lpProfileID && lstrlen(lpProfileID))
        //{
        //    if(lpName)
        //        LocalFree(lpName);
        //    CreateUserFolderName(lpProfileID, &lpName);
        //}
    }
    lpFolder->lpFolderName = lpName;
    lpFolder->lpProfileID = lpProfileID;
    lpFolder->bShared = bShared;
    lpFolder->lpFolderOwner = lpOwner;

out:

    ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);

    return hr;
}


/*
-   HrLoadWABFolders
-
*   Gets a list of all the folders from the WAB and sorts them out based on
*   whether they are user folders or ordinary folders
*
*/
HRESULT HrLoadWABFolders(LPIAB lpIAB)
{
    SCODE sc;
    HRESULT hr = E_FAIL;
    SPropertyRestriction PropRes = {0};
	SPropValue sp = {0};
    ULONG ulCount = 0;
    LPSBinary rgsbEntryIDs = NULL;
    ULONG i = 0;
    int nID = IDM_VIEW_FOLDERS1;

    // Now we will search the WAB for all objects of PR_OBJECT_TYPE = MAPI_ABCONT
    //
	sp.ulPropTag = PR_OBJECT_TYPE;
	sp.Value.l = MAPI_ABCONT;

    PropRes.ulPropTag = PR_OBJECT_TYPE;
    PropRes.relop = RELOP_EQ;
    PropRes.lpProp = &sp;

    hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
						NULL, 0, TRUE,
                        &PropRes, &ulCount, &rgsbEntryIDs);

    if (HR_FAILED(hr))
        goto out;

    if(ulCount && rgsbEntryIDs)
    {
        for(i=0;i<ulCount;i++)
        {
            ULONG cb = 0;
            LPENTRYID lpb = NULL;
            LPWABFOLDER lpFolder = NULL;

            lpFolder = LocalAlloc(LMEM_ZEROINIT, sizeof(WABFOLDER));
            if(!lpFolder)
                goto out;

            if(HR_FAILED(HrGetFolderInfo(lpIAB, &rgsbEntryIDs[i], lpFolder)))
                goto out;

            if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                            rgsbEntryIDs[i].lpb, NULL, NULL,
                                            rgsbEntryIDs[i].cb, 0,
                                            NULL, &cb, &lpb)))
            {
                // Add the entryids to this prop - ignore errors
                SetSBinary(&(lpFolder->sbEID), cb, (LPBYTE)lpb);
                MAPIFreeBuffer(lpb);
            }

            if(lpFolder->lpProfileID)
            {
                // this is a user folder
                lpFolder->lpNext = lpIAB->lpWABUserFolders;
                lpIAB->lpWABUserFolders = lpFolder;
            }
            else
            {
                lpFolder->lpNext = lpIAB->lpWABFolders;
                lpFolder->nMenuCmdID = nID++;
                lpIAB->lpWABFolders = lpFolder;
            }
        }
    }

    if(HR_FAILED(hr = HrLinkUserFoldersToWABFolders(lpIAB)))
        goto out;

    HrLinkOrphanFoldersToDefaultUser(lpIAB); // we can ignore errors in this call since it's not life-and-death

out:
    if(ulCount && rgsbEntryIDs)
    {
        FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore,
                    ulCount,
                    rgsbEntryIDs);
    }
    return hr;
}


/*
-
-   HrCreateNewFolder
*
*   Takes a profile ID, uses it to create a folder in the WAB
*   and sticks the new user folder onto the IAB 
*   Can create a user folder or an ordinary folder
*   For ordinary folders, we can also specify a parent folder to which the item can be added
*
*/
HRESULT HrCreateNewFolder(LPIAB lpIAB, LPTSTR lpName, LPTSTR lpProfileID, BOOL bUserFolder, 
                          LPWABFOLDER lpParentFolder, BOOL bShared, LPSBinary lpsbNew)
{
    HRESULT hr = S_OK;
    SPropValue spv[proUserFolderMax];
    LPSBinary lpsb = NULL;
    SBinary sb = {0};
    LPMAPIPROP lpObject = NULL;
    ULONG ulcProps = 0, j = 0;
    LPSPropValue lpProps = NULL;
    LPWABFOLDER lpFolder = NULL;
    ULONG ulPropCount = 0;
    ULONG cchSize;

    if(!(lpFolder = LocalAlloc(LMEM_ZEROINIT, sizeof(WABFOLDER))))
        return MAPI_E_NOT_ENOUGH_MEMORY;
    
    if(bUserFolder)
    {
        CreateUserFolderName(lpName ? lpName : lpProfileID, &lpFolder->lpFolderName);
        cchSize = lstrlen(lpProfileID)+1;
        if(!(lpFolder->lpProfileID = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize)))
            return MAPI_E_NOT_ENOUGH_MEMORY;
        StrCpyN(lpFolder->lpProfileID, lpProfileID, cchSize);
    }
    else
    {
        cchSize = lstrlen(lpName)+1;
        if(!(lpFolder->lpFolderName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize)))
            return MAPI_E_NOT_ENOUGH_MEMORY;
        StrCpyN(lpFolder->lpFolderName, lpName, cchSize);
    }

    // if there isn't a current user, all new folders should go into the shared contacts folder
    if(!bIsThereACurrentUser(lpIAB) && !lpProfileID && !lpParentFolder)
        bShared = TRUE;

    spv[ulPropCount].ulPropTag = PR_DISPLAY_NAME;
    spv[ulPropCount++].Value.LPSZ = lpFolder->lpFolderName;

    spv[ulPropCount].ulPropTag = PR_OBJECT_TYPE;
    spv[ulPropCount++].Value.l = MAPI_ABCONT;

    spv[ulPropCount].ulPropTag = PR_WAB_FOLDER_ENTRIES;
    spv[ulPropCount].Value.MVbin.cValues = 1;
    spv[ulPropCount++].Value.MVbin.lpbin = &sb;

    spv[ulPropCount].ulPropTag = PR_WAB_SHAREDFOLDER;
    spv[ulPropCount++].Value.l = (bUserFolder ? FOLDER_PRIVATE : (bShared ? FOLDER_SHARED : FOLDER_PRIVATE));
    
    if(lpProfileID)
    {
        spv[ulPropCount].ulPropTag = PR_WAB_FOLDEROWNER;
        spv[ulPropCount++].Value.LPSZ = lpProfileID;
    }

    if(bUserFolder)
    {
        spv[ulPropCount].ulPropTag = PR_WAB_USER_SUBFOLDERS;
        spv[ulPropCount].Value.MVbin.cValues = 1;
        spv[ulPropCount++].Value.MVbin.lpbin = &sb;

        spv[ulPropCount].ulPropTag = PR_WAB_USER_PROFILEID;
        spv[ulPropCount++].Value.LPSZ = lpFolder->lpProfileID;
    }

    if(HR_FAILED(hr = HrSaveFolderProps((LPADRBOOK)lpIAB, bUserFolder, 
                                        ulPropCount, 
                                        spv, &lpObject)))
        goto out;

    if(HR_FAILED(hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &ulcProps, &lpProps)))
        goto out;

    for(j=0;j<ulcProps;j++)
    {
        if(lpProps[j].ulPropTag == PR_ENTRYID)
        {
            lpsb = &(lpProps[j].Value.bin);
            break;
        }
    }

    if(lpsb)
    {
        ULONG cb = 0; 
        LPENTRYID lpb  = NULL;
        if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                        lpsb->lpb, NULL, NULL,
                                        lpsb->cb, 0,
                                        NULL, &cb, &lpb)))
        {
            // Add the entryids to this prop - ignore errors
            SetSBinary(&(lpFolder->sbEID), cb, (LPBYTE) lpb);
            MAPIFreeBuffer(lpb);
        }
    }

    if(bUserFolder)
    {
        lpFolder->lpNext = lpIAB->lpWABUserFolders;
        lpIAB->lpWABUserFolders = lpFolder;
    }
    else
    {
        lpFolder->lpNext = lpIAB->lpWABFolders;
        lpIAB->lpWABFolders = lpFolder;
        // Add this folder to the current user's profile
        HrAddRemoveFolderFromUserFolder(lpIAB, lpParentFolder, &(lpFolder->sbEID), NULL, FALSE);
    }

    if(lpsbNew)
        SetSBinary(lpsbNew, lpFolder->sbEID.cb, lpFolder->sbEID.lpb);

    hr = HrGetWABProfiles(lpIAB);

out:
    if(lpObject)
        lpObject->lpVtbl->Release(lpObject);

    FreeBufferAndNull(&lpProps);

    return hr;
}

/*
-   HrAddAllContactsToFolder
-
*   Adds all existing contacts and groups to the current user folder
*
*/
HRESULT HrAddAllContactsToFolder(LPIAB lpIAB)
{
    HRESULT hr = 0;
    SPropertyRestriction PropRes;
    LPSBinary rgsbEntryIDs = NULL;
    ULONG ulCount = 0, i,j;
    ULONG rgObj[] = {MAPI_MAILUSER, MAPI_DISTLIST};
    // This can be a labor intesive process
    HCURSOR hOldC = NULL;

    if(!bIsThereACurrentUser(lpIAB))
        return hr;

    hOldC = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //for(j=0;j<2;j++)
    {
        SPropValue sp = {0};
	    sp.ulPropTag = PR_WAB_FOLDER_PARENT;
	    //sp.Value.l = rgObj[j];

        PropRes.ulPropTag = PR_WAB_FOLDER_PARENT;
        PropRes.relop = RELOP_NE;
        PropRes.lpProp = &sp;

        // Find stuff that isn't in any folder
        if(!HR_FAILED(hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
						    NULL, AB_MATCH_PROP_ONLY, TRUE, &PropRes, &ulCount, &rgsbEntryIDs)))
        {
            for(i=0;i<ulCount;i++)
            {
                AddEntryToFolder((LPADRBOOK)lpIAB,NULL,
                                lpIAB->lpWABCurrentUserFolder->sbEID.cb,
                                (LPENTRYID) lpIAB->lpWABCurrentUserFolder->sbEID.lpb,
                                rgsbEntryIDs[i].cb,
                                (LPENTRYID) rgsbEntryIDs[i].lpb);
            }

            FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
        }
    }

    if(hOldC)
        SetCursor(hOldC);

    return hr;

}

/*
-   UpdateCurrentUserFolderName
-
*
*/
void UpdateCurrentUserFolderName(LPIAB lpIAB)
{
    LPTSTR lpsz = NULL;
    CreateUserFolderName(lpIAB->szProfileName, &lpsz);
    if(lstrcmpi(lpsz, lpIAB->lpWABCurrentUserFolder->lpFolderName))
    {
        LocalFree(lpIAB->lpWABCurrentUserFolder->lpFolderName);
        lpIAB->lpWABCurrentUserFolder->lpFolderName = lpsz;
        HrUpdateFolderInfo(lpIAB, &lpIAB->lpWABCurrentUserFolder->sbEID, FOLDER_UPDATE_NAME, FALSE, lpIAB->lpWABCurrentUserFolder->lpFolderName);
    }
    else
        LocalFree(lpsz);
}


/*
-   HrGetWABProfiles
-
*   Collates information about the WAB User Folders etc from the WAB
*   Creates a list of User Folders and generic Folders and caches these on the Address Book
*   Matches the provided profile to the user folders .. if it matches, points to the 
*   corresponding folder .. if it doesn't match, creates a new User Folder for the 
*   Profile ID.
*
*   <TBD> when the account manager is profile ready, use the profile ID to pull in the 
*   users name from the account manager and then use that to call it  TEXT("UserName's Contacts")
*   For now, we'll just use the profile id to do that
*/
HRESULT HrGetWABProfiles(LPIAB lpIAB)
{
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&lpIAB->cs);

    if(!bIsWABSessionProfileAware(lpIAB))
        goto out;

    if(!lstrlen(lpIAB->szProfileID))
        HrGetUserProfileID(&lpIAB->guidCurrentUser, lpIAB->szProfileID, CharSizeOf(lpIAB->szProfileID));

    if(!lstrlen(lpIAB->szProfileName))
        HrGetIdentityName(lpIAB, NULL, lpIAB->szProfileName, ARRAYSIZE(lpIAB->szProfileName));

    // Clear out old data
    if(lpIAB->lpWABUserFolders || lpIAB->lpWABFolders)
        FreeWABFoldersList(lpIAB);

    // Get a list of all the folders in the WAB
    if(HR_FAILED(hr = HrLoadWABFolders(lpIAB)))
        goto out;

    SetCurrentUserFolder(lpIAB, lpIAB->szProfileID);

    if(!bIsThereACurrentUser(lpIAB) && lstrlen(lpIAB->szProfileID) && lstrlen(lpIAB->szProfileName))
    {
        // Not Found!!!
        // Create a new user folder ..
        BOOL bFirstUser = bDoesThisWABHaveAnyUsers(lpIAB) ? FALSE : TRUE;

        if(HR_FAILED(hr = HrCreateNewFolder(lpIAB, lpIAB->szProfileName, lpIAB->szProfileID, TRUE, NULL, FALSE, NULL)))
            goto out;

        SetCurrentUserFolder(lpIAB, lpIAB->szProfileID);

        if(bFirstUser)
        {
            if(lpIAB->lpWABFolders)
            {
                // we want to put all existing folders under this user
                LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
                while(lpFolder)
                {
                    // There is a weird case where a preexisting folder with the same name as 
                    // a user's folder becomes nested under itself .. so don't add this folder to the
                    // User Folder
                    if(lstrcmpi(lpIAB->lpWABCurrentUserFolder->lpFolderName, lpFolder->lpFolderName))
                        HrAddRemoveFolderFromUserFolder(lpIAB, NULL, &lpFolder->sbEID, NULL, FALSE);
                    lpFolder = lpFolder->lpNext;
                }
                hr = HrLinkUserFoldersToWABFolders(lpIAB);
            }
            //We also want to put all existing contacts into this user folder
            hr = HrAddAllContactsToFolder(lpIAB);
        }
    }

    if( lpIAB->szProfileID && lstrlen(lpIAB->szProfileID) && lpIAB->szProfileName && lstrlen(lpIAB->szProfileName) && bIsThereACurrentUser(lpIAB))
    {
        // Use the latest name for this entry
        UpdateCurrentUserFolderName(lpIAB);
    }

    if(HR_FAILED(hr = HrGetWABProfileContainerInfo(lpIAB)))
        goto out;

    hr = S_OK;
out:
    LeaveCriticalSection(&lpIAB->cs);
    return hr;
}


/*
-   bIsProfileMember
-
*
*/
BOOL bIsProfileMember(LPIAB lpIAB, LPSBinary lpsb, LPWABFOLDER lpWABFolder, LPWABUSERFOLDER lpUserFolder)
{
    LPWABFOLDERLIST lpFolderItem = NULL;
    LPWABFOLDER lpFolder = lpWABFolder;
    
    if(!lpUserFolder && !lpIAB->lpWABCurrentUserFolder)
        return FALSE;
    
    lpFolderItem = lpUserFolder ? lpUserFolder->lpFolderList : lpIAB->lpWABCurrentUserFolder->lpFolderList;

    if(!lpFolder && lpsb)
        lpFolder = FindWABFolder(lpIAB, lpsb, NULL, NULL);

    while(lpFolderItem && lpFolder)
    {
        if(lpFolderItem->lpFolder == lpFolder)
            return TRUE;
        lpFolderItem = lpFolderItem->lpNext;
    }
    return FALSE;
}


/*
-   bDoesEntryNameAlreadyExist
-
*   Checks if a given name already exists in the WAB
*   Used for preventing duplicate folder and group names
*/
BOOL bDoesEntryNameAlreadyExist(LPIAB lpIAB, LPTSTR lpsz)
{
    SPropertyRestriction PropRes;
    SPropValue Prop = {0};
    LPSBinary rgsbEntryIDs = NULL;
    ULONG ulCount = 0;
    BOOL bRet = FALSE;

    // Verify that the new name doesn't actually exist
    Prop.ulPropTag = PR_DISPLAY_NAME;
    Prop.Value.LPSZ = lpsz;
    PropRes.lpProp = &Prop;
    PropRes.relop = RELOP_EQ;
    PropRes.ulPropTag = PR_DISPLAY_NAME;

    if (HR_FAILED(FindRecords(lpIAB->lpPropertyStore->hPropertyStore,
	                          NULL,			// pmbinFolder
                              0,            // ulFlags
                              TRUE,         // Always TRUE
                              &PropRes,     // Propertyrestriction
                              &ulCount,     // IN: number of matches to find, OUT: number found
                              &rgsbEntryIDs))) 
        goto out;

    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);

    if(ulCount >=1)
        bRet = TRUE;
out:
    return bRet;
}

/*
-   UpdateFolderName
-
*
*/
HRESULT HrUpdateFolderInfo(LPIAB lpIAB, LPSBinary lpsbEID, ULONG ulFlags, BOOL bShared, LPTSTR lpsz)
{
    LPSPropValue lpProp = NULL, lpPropNew = NULL;
    ULONG ulcPropCount = 0, i =0, ulcPropNew = 0;
    HRESULT hr = S_OK;
    BOOL bUpdate = FALSE, bFoundShare = FALSE;//, bOldShareState = FALSE;
    ULONG cchSize;

    if(!lpsbEID || !lpsbEID->cb || !lpsbEID->lpb)
        return MAPI_E_INVALID_PARAMETER;

    if(!HR_FAILED(hr = ReadRecord(   lpIAB->lpPropertyStore->hPropertyStore, 
                                lpsbEID, 0, &ulcPropCount, &lpProp)))
    {
        for(i=0;i<ulcPropCount;i++)
        {
            if( (ulFlags & FOLDER_UPDATE_NAME) && 
                lpProp[i].ulPropTag == PR_DISPLAY_NAME)
            {
                BOOL bCaseChangeOnly = (!lstrcmpi(lpsz, lpProp[i].Value.LPSZ) && 
                                         lstrcmp(lpsz, lpProp[i].Value.LPSZ) );
                LocalFree(lpProp[i].Value.LPSZ);
                cchSize = lstrlen(lpsz)+1;
                lpProp[i].Value.LPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
                if(lpProp[i].Value.LPSZ)
                {
                    StrCpyN(lpProp[i].Value.LPSZ, lpsz, cchSize);
                    if(!bCaseChangeOnly) // if this isn't just a case change, look for the name (if it's a case change, there will be a spurious error) //bug 33067
                    {
                        if(bDoesEntryNameAlreadyExist(lpIAB, lpProp[i].Value.LPSZ))
                        {
                            hr = MAPI_E_COLLISION;
                            goto out;
                        }
                    }
                    bUpdate = TRUE;
                }
            }
            if( (ulFlags & FOLDER_UPDATE_SHARE) && 
                lpProp[i].ulPropTag == PR_WAB_SHAREDFOLDER)
            {
                bFoundShare = TRUE;
                //bOldShareState = (lpProp[i].Value.l == FOLDER_SHARED) ? TRUE : FALSE;
                lpProp[i].Value.l = bShared ? FOLDER_SHARED : FOLDER_PRIVATE;
                bUpdate = TRUE;
            }
        }
    }

    if(!bFoundShare && (ulFlags & FOLDER_UPDATE_SHARE)) // this value doesnt already exist on the contact so update it
    {
        SPropValue Prop = {0};
        Prop.ulPropTag = PR_WAB_SHAREDFOLDER;
        Prop.Value.l = bShared ? FOLDER_SHARED : FOLDER_PRIVATE;

        // Create a new prop array with this additional property
        if(!(ScMergePropValues( 1, &Prop, ulcPropCount, lpProp,
                                &ulcPropNew, &lpPropNew)))
        {
            ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
            ulcPropCount = ulcPropNew;
            lpProp = lpPropNew;
            bUpdate = TRUE;
        }
    }

    if(bUpdate)
    {
        if(HR_FAILED(hr = HrSaveFolderProps((LPADRBOOK)lpIAB, FALSE, ulcPropCount, lpProp, NULL)))
            goto out;
    }


out:
    if(lpProp)
    {
        if(lpProp == lpPropNew)
            FreeBufferAndNull(&lpProp);
        else
            ReadRecordFreePropArray(NULL, ulcPropCount, &lpProp);
    }

    return hr;
}

/*
-   HrAddRemoveFolderFromCurrentUserFolder
-
*   Given a folder EID, adds or removes the folder EID from the current users
*   user folder
*   If there is no current user folder then use the lpUserFolder provided
*   else return
*
*   lpUFolder - parent folder to / from which to add / remove
*   lpsbEID - EID of folder we want to add / remove
*   lpName - Name to look for if we don't have an EID
*/
HRESULT HrAddRemoveFolderFromUserFolder(LPIAB lpIAB, LPWABFOLDER lpUFolder, 
                                        LPSBinary lpsbEID, LPTSTR lpName, 
                                        BOOL bRefreshProfiles)
{
    HRESULT hr = S_OK;
    ULONG ulcPropsNew = 0, ulcProps = 0, i = 0;
    LPSPropValue lpPropArrayNew = NULL;
    LPSPropValue lpProps = NULL;
    LPWABFOLDER lpUserFolder = NULL;
    
    if(!lpsbEID && lpName)
    {
        LPWABFOLDER lpFolder = FindWABFolder(lpIAB, NULL, lpName, NULL);
        lpsbEID = &lpFolder->sbEID;
    }

    if(lpIAB->lpWABCurrentUserFolder)
        lpUserFolder = lpIAB->lpWABCurrentUserFolder;
    else if(lpUFolder)
        lpUserFolder = lpUFolder;
    else 
        goto out;

    {
        // open the current user folder
        if(!HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, &(lpUserFolder->sbEID),
                                     0, &ulcProps, &lpProps)))
        {
            SPropValue spv = {0};
            spv.ulPropTag = PR_NULL;
            // Copy the props into a MAPI proparray
            if(!(ScMergePropValues( 1, &spv, ulcProps, lpProps,
                                    &ulcPropsNew, &lpPropArrayNew)))
            {
                for(i=0;i<ulcPropsNew;i++)
                {
                    if(lpProps[i].ulPropTag == PR_WAB_USER_SUBFOLDERS)
                    {
                        if(bIsProfileMember(lpIAB, lpsbEID, NULL, lpUserFolder))
                            RemovePropFromMVBin( lpPropArrayNew, ulcPropsNew, i, lpsbEID->lpb, lpsbEID->cb);
                        else
                            AddPropToMVPBin( lpPropArrayNew, i, lpsbEID->lpb, lpsbEID->cb, TRUE);
                        break;
                    }
                }
            }
            if(HR_FAILED(hr = HrSaveFolderProps((LPADRBOOK)lpIAB, FALSE, ulcPropsNew, lpPropArrayNew, NULL)))
                goto out;
        }
    }

    if(bRefreshProfiles)
        hr = HrGetWABProfiles(lpIAB);

out:
    ReadRecordFreePropArray(NULL, ulcProps, &lpProps);
    MAPIFreeBuffer(lpPropArrayNew);
    return hr;
}



/*
-
-   bDoesThisWABHaveAnyUsers
*
*   TRUE if some user folders exist .. FALSE if NO user folders exist
*/
BOOL bDoesThisWABHaveAnyUsers(LPIAB lpIAB)
{
    return (lpIAB->lpWABUserFolders != NULL);
}

/*
-
-   bIsThereACurrentUser
*
*   TRUE if there is a current user .. FALSE if not
*/
BOOL bIsThereACurrentUser(LPIAB lpIAB)
{
    // Don't change this test since success of this test implies that lpIAB->lpWABCurrentUserFolder is not NULL
    // and can be dereferenced
    return (lpIAB->lpWABCurrentUserFolder != NULL);
}

/*
-
-   bAreWABAPIProfileAware
*
*   TRUE if the WAB API should behave with profile-awareness, false if they should revert to old behaviour
*/
BOOL bAreWABAPIProfileAware(LPIAB lpIAB)
{
    return (lpIAB->bProfilesAPIEnabled);
}

/*
-
-   bIsWABSessionProfileAware
*
*   TRUE if the WAB should behave with profile-awareness, false if they should revert to old behaviour
*   This is also used to differentiate between Outlook sessions which are not at all profile aware
*/
BOOL bIsWABSessionProfileAware(LPIAB lpIAB)
{
    return (lpIAB->bProfilesEnabled);
}




/**************************************/
/******* Identity Manager Stuff *******/

// Global place to store the account manager object
//IUserIdentityManager * g_lpUserIdentityManager = NULL;
//BOOL fCoInitUserIdentityManager = FALSE;
//ULONG cIdentInit = 0;


//*******************************************************************
//
//  FUNCTION:   HrWrappedCreateIdentityManager
//
//  PURPOSE:    Load identity manager dll and create the object.
//
//  PARAMETERS: lppIdentityManager -> returned pointer to Identity manager
//              object.
//
//  RETURNS:    HRESULT
//
//*******************************************************************
HRESULT HrWrappedCreateUserIdentityManager(LPIAB lpIAB, IUserIdentityManager **lppUserIdentityManager)
{
    HRESULT                     hResult = E_FAIL;

    if (! lppUserIdentityManager) {
        return(ResultFromScode(E_INVALIDARG));
    }

    *lppUserIdentityManager = NULL;

    if (CoInitialize(NULL) == S_FALSE) 
    {
        // Already initialized, undo the extra.
        CoUninitialize();
    } else 
    {
        lpIAB->fCoInitUserIdentityManager = TRUE;
    }

    if (HR_FAILED(hResult = CoCreateInstance(&CLSID_UserIdentityManager,
                                              NULL,
                                              CLSCTX_INPROC_SERVER,
                                              &IID_IUserIdentityManager, 
                                              (LPVOID *)lppUserIdentityManager))) 
    {
        DebugTrace(TEXT("CoCreateInstance(IID_IUserIdentityManager) -> %x\n"), GetScode(hResult));
    }

    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   InitUserIdentityManager
//
//  PURPOSE:    Load and initialize the account manager
//
//  PARAMETERS: lppUserIdentityManager -> returned pointer to account manager
//              object.
//
//  RETURNS:    HRESULT
//
//  COMMENTS:   The first time through here, we will save the hResult.
//              On subsequent calls, we will check this saved value
//              and return it right away if there was an error, thus
//              preventing repeated time consuming LoadLibrary calls.
//
//*******************************************************************
HRESULT InitUserIdentityManager(LPIAB lpIAB, IUserIdentityManager ** lppUserIdentityManager) 
{
    static hResultSave = hrSuccess;
    HRESULT hResult = hResultSave;

    if (! lpIAB->lpUserIdentityManager && ! HR_FAILED(hResultSave)) 
    {
#ifdef DEBUG
        DWORD dwTickCount = GetTickCount();
        DebugTrace(TEXT(">>>>> Initializing User Identity Manager...\n"));
#endif // DEBUG

        if (hResult = HrWrappedCreateUserIdentityManager(lpIAB, &lpIAB->lpUserIdentityManager)) 
        {
            DebugTrace(TEXT("HrWrappedCreateUserIdentityManager -> %x\n"), GetScode(hResult));
            goto end;
        }
        Assert(lpIAB->lpUserIdentityManager);
        
        lpIAB->cIdentInit++; // +1 here to match the release in IAB_Neuter

#ifdef DEBUG
        DebugTrace( TEXT(">>>>> Done Initializing User Identity Manager... %u milliseconds\n"), GetTickCount() - dwTickCount);
#endif  // DEBUG
    }

    lpIAB->cIdentInit++;

end:
    if (HR_FAILED(hResult)) 
    {
        *lppUserIdentityManager = NULL;
        // Save the result
        hResultSave = hResult;
    } else 
    {
        *lppUserIdentityManager = lpIAB->lpUserIdentityManager;
    }


    return(hResult);
}


//*******************************************************************
//
//  FUNCTION:   UninitUserIdentityManager
//
//  PURPOSE:    Release and unLoad the account manager
//
//  PARAMETERS: none
//
//  RETURNS:    none
//
//*******************************************************************
void UninitUserIdentityManager(LPIAB lpIAB) 
{
    lpIAB->cIdentInit--;
    if (lpIAB->lpUserIdentityManager && lpIAB->cIdentInit==0) {
#ifdef DEBUG
        DWORD dwTickCount = GetTickCount();
        DebugTrace( TEXT(">>>>> Uninitializing Account Manager...\n"));
#endif // DEBUG

        lpIAB->lpUserIdentityManager->lpVtbl->Release(lpIAB->lpUserIdentityManager);
        lpIAB->lpUserIdentityManager = NULL;

        if (lpIAB->fCoInitUserIdentityManager) 
            CoUninitialize();
#ifdef DEBUG
        DebugTrace( TEXT(">>>>> Done Uninitializing Account Manager... %u milliseconds\n"), GetTickCount() - dwTickCount);
#endif  // DEBUG
    }
}


/*
-   HrGetDefaultIdentityInfo
-
*   Get's the hKey corresponding to the default identity
*/
HRESULT HrGetDefaultIdentityInfo(LPIAB lpIAB, ULONG ulFlags, HKEY * lphKey, LPTSTR lpProfileID, ULONG cchProfileID, LPTSTR lpName, ULONG cchName)
{
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    HRESULT hr = S_OK;
    BOOL fInit = FALSE;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, 
                                                                        (GUID *)&UID_GIBC_DEFAULT_USER,
                                                                        &lpUserIdentity)))
        goto out;

    Assert(lpUserIdentity);

    if(ulFlags & DEFAULT_ID_HKEY && lphKey)
    {
        if(HR_FAILED(hr = lpUserIdentity->lpVtbl->OpenIdentityRegKey(lpUserIdentity, 
                                                                    KEY_ALL_ACCESS, 
                                                                    lphKey)))
            goto out;
    }
    if(ulFlags & DEFAULT_ID_PROFILEID && lpProfileID)
    {
        GUID guidCookie = {0};
        TCHAR sz[MAX_PATH];
        // update this key for the account manager
        if(HR_FAILED(hr = lpUserIdentity->lpVtbl->GetCookie(lpUserIdentity, &guidCookie)))
            goto out;
        if(HR_FAILED(hr = HrGetUserProfileID(&guidCookie, sz, CharSizeOf(sz))))
            goto out;
        StrCpyN(lpProfileID, sz, cchProfileID);
    }
    if(ulFlags & DEFAULT_ID_NAME && lpName && lpProfileID)
    {
        if(HR_FAILED(hr = HrGetIdentityName(lpIAB, lpProfileID, lpName, cchName)))
            goto out;
    }

out:
    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    if(fInit)
        UninitUserIdentityManager(lpIAB);

    return hr;
}


/*
-   HrGetIdentityName
-
*   Gets the name string corresponding to the current user unless a specific profile ID is specified
*       (which is nothing but a string version of the GUID to use)
*       szName - buffer long enough for the user name (CCH_IDENTITY_NAME_MAX_LENGTH)
*/
HRESULT HrGetIdentityName(LPIAB lpIAB, LPTSTR lpID, LPTSTR szUserName, ULONG cchUserName)
{
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    WCHAR szNameW[CCH_IDENTITY_NAME_MAX_LENGTH];
    TCHAR szName[CCH_IDENTITY_NAME_MAX_LENGTH];
    HRESULT hr = S_OK;
    GUID guidCookie = {0};
    BOOL fInit = FALSE;

    if(!lpID && !bAreWABAPIProfileAware(lpIAB))
        goto out;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    if(lpIAB && !lpID)
        memcpy(&guidCookie, &lpIAB->guidCurrentUser, sizeof(GUID));
    else
    {
        if( (HR_FAILED(hr = CLSIDFromString(lpID, &guidCookie))) )
            goto out;
    }

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, &guidCookie, &lpUserIdentity)))
        goto out;

    Assert(lpUserIdentity);

    if(HR_FAILED(hr = lpUserIdentity->lpVtbl->GetName(lpUserIdentity, szNameW, CharSizeOf(szNameW))))
        goto out;
    StrCpyN(szName, szNameW, ARRAYSIZE(szName));

    if(!lstrcmp(szUserName, szName))
    {
        hr = E_FAIL;
        goto out;
    }

    StrCpyN(szUserName, szName, cchUserName);

out:
    if(fInit)
        UninitUserIdentityManager(lpIAB);

    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    if(HR_FAILED(hr))
        szUserName[0] = TEXT('\0');

    return hr;

}


/*
-   HrGetUserProfileID
-
*   Gets the profile string corresponding to the current user
*   The profile ID is nothing but a string represenatation of the user's Cookie (GUID)
*
*       szProfileID - buffer long enough for the user name
*/
HRESULT HrGetUserProfileID(LPGUID lpguidUser, LPTSTR szProfileID, ULONG cbProfileID)
{
    HRESULT hr = S_OK;
    LPOLESTR lpszW= 0 ;

    if (HR_FAILED(hr = StringFromCLSID(lpguidUser, &lpszW))) 
        goto out;

    StrCpyN(szProfileID,(LPCWSTR)lpszW,cbProfileID);

out:
    if (lpszW) 
    {
        LPMALLOC pMalloc = NULL;
        CoGetMalloc(1, &pMalloc);
        if (pMalloc) {
            pMalloc->lpVtbl->Free(pMalloc, lpszW);
            pMalloc->lpVtbl->Release(pMalloc);
        }
    }
    if(HR_FAILED(hr))
        szProfileID[0] = TEXT('\0');

    return hr;
}


/*
-
-   HrLogonAndGetCurrentUserProfile - Inits the User Identity Manger and calls into the Logon ..
-       Gets a user, either by showing UI or getting the current user and then gets a 
-       profile ID ( TEXT("Cookie")) for that user ..
*
*   bForceUI - forces the Logon dialog so user can switch users .. TRUE only when user wants to switch
*
*   bSwitchUser - True only after user has switched .. tells us to refresh and get details ont he new user
*
*/
HRESULT HrLogonAndGetCurrentUserProfile(HWND hWndParent, LPIAB lpIAB, BOOL bForceUI, BOOL bSwitchUser)
{
    HRESULT hr = S_OK;
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IUserIdentity * lpUserIdentity = NULL;
    GUID guidCookie = {0};
    BOOL fInit = FALSE;
    if(!bAreWABAPIProfileAware(lpIAB))
        goto out;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    // Logon will get the currently logged on user, or if there is a single user, it will return 
    //  that user, or if there are multiple users, it will prompt for a logon
    //
    if(!bSwitchUser)
    {
        hr = lpUserIdentityManager->lpVtbl->Logon(lpUserIdentityManager, 
                                                hWndParent, 
                                                bForceUI ? UIL_FORCE_UI : 0, 
                                                &lpUserIdentity);

#ifdef NEED
        if(hr == S_IDENTITIES_DISABLED)
            hr = E_FAIL;
#endif

        if(HR_FAILED(hr))
            goto out;
    }
    else
    {
        // just switching users, thats all
        if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->GetIdentityByCookie(lpUserIdentityManager, 
                                                                            (GUID *)&UID_GIBC_CURRENT_USER,
                                                                            &lpUserIdentity)))
            goto out;

    }

    Assert(lpUserIdentity);

    if(lpIAB->hKeyCurrentUser)
        RegCloseKey(lpIAB->hKeyCurrentUser);

    // get the identity's hkey for the wab
    if(HR_FAILED(hr = lpUserIdentity->lpVtbl->OpenIdentityRegKey(lpUserIdentity, KEY_ALL_ACCESS, &lpIAB->hKeyCurrentUser)))
        goto out;

    // get anothor one for the account manager (it will free it)
    if(HR_FAILED(hr = lpUserIdentity->lpVtbl->GetCookie(lpUserIdentity, &guidCookie)))
        goto out;
    else
    {
        IImnAccountManager2 * lpAccountManager = NULL;
        // [PaulHi] 1/13/99  Changed to initialize the account manager with
        // user guid cookie inside the InitAccountManager() function.
        InitAccountManager(lpIAB, &lpAccountManager, &guidCookie);
    }

    if(!memcmp(&lpIAB->guidCurrentUser, &guidCookie, sizeof(GUID)))
    {
        //current user is identical to the one we have so don't update anything here
        return S_OK;
    }

    memcpy(&lpIAB->guidCurrentUser, &guidCookie, sizeof(GUID));

    lpIAB->szProfileID[0] = TEXT('\0');
    lpIAB->szProfileName[0] = TEXT('\0');

    HrGetIdentityName(lpIAB, NULL, lpIAB->szProfileName, ARRAYSIZE(lpIAB->szProfileName));
    HrGetUserProfileID(&lpIAB->guidCurrentUser, lpIAB->szProfileID, CharSizeOf(lpIAB->szProfileID));
/*
    //register for changes
    if( !bSwitchUser && !bForceUI && !lpIAB->lpWABIDCN 
        //&& !memcmp(&lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)) 
        ) // register for notifications only if this is the WAB.exe process
    {
        HrRegisterUnregisterForIDNotifications( lpIAB, TRUE);
    }
*/
out:
    if(fInit)
        UninitUserIdentityManager(lpIAB);

    if(lpUserIdentity)
        lpUserIdentity->lpVtbl->Release(lpUserIdentity);

    return hr;
}


/*
-   HRESULT HrRegisterUnregisterForIDNotifications()
-
*   Creates/Releases a WABIDENTITYCHANGENOTIFY object
*
*/
HRESULT HrRegisterUnregisterForIDNotifications( LPIAB lpIAB, BOOL bRegister)
{

    HRESULT hr = S_OK;
    IUserIdentityManager * lpUserIdentityManager = NULL;
    IConnectionPoint * lpConnectionPoint = NULL;
    BOOL fInit = FALSE;

    // Need to register for notifications even if running under Outlook
    // Assume that relevant tests have occured before this is called ....
    // if(bRegister && !bAreWABAPIProfileAware(lpIAB))
    //    goto out;
    
    if( (!bRegister && !lpIAB->lpWABIDCN) ||
        (bRegister && lpIAB->lpWABIDCN) )
        goto out;

    if(HR_FAILED(hr = InitUserIdentityManager(lpIAB, &lpUserIdentityManager)))
        goto out;

    fInit = TRUE;

    Assert(lpUserIdentityManager);

    if(HR_FAILED(hr = lpUserIdentityManager->lpVtbl->QueryInterface(lpUserIdentityManager,
                                                                    &IID_IConnectionPoint, 
                                                                    (LPVOID *)&lpConnectionPoint)))
        goto out;

    if(bRegister)
    {
        if(lpIAB->lpWABIDCN)
        {
            lpIAB->lpWABIDCN->lpVtbl->Release(lpIAB->lpWABIDCN);
            lpIAB->lpWABIDCN = NULL;
        }

        if(HR_FAILED(hr = HrCreateIdentityChangeNotifyObject(lpIAB, &lpIAB->lpWABIDCN)))
            goto out;

        if(HR_FAILED(hr = lpConnectionPoint->lpVtbl->Advise(lpConnectionPoint, (LPUNKNOWN) lpIAB->lpWABIDCN, &lpIAB->dwWABIDCN)))
            goto out;
    }
    else
    {
        if(lpIAB->lpWABIDCN)
        {
            if(HR_FAILED(hr = lpConnectionPoint->lpVtbl->Unadvise(lpConnectionPoint, lpIAB->dwWABIDCN)))
                goto out;
            lpIAB->dwWABIDCN = 0;
            lpIAB->lpWABIDCN->lpVtbl->Release(lpIAB->lpWABIDCN);
            lpIAB->lpWABIDCN = NULL;
        }
    }
out:
    if(fInit)
        UninitUserIdentityManager(lpIAB);

    if(lpConnectionPoint)
        lpConnectionPoint->lpVtbl->Release(lpConnectionPoint);

    return hr;

}



/*--------------------------------------------------------------------------------------------------*/

WAB_IDENTITYCHANGENOTIFY_Vtbl vtblWABIDENTITYCHANGENOTIFY = {
    VTABLE_FILL
    WAB_IDENTITYCHANGENOTIFY_QueryInterface,
    WAB_IDENTITYCHANGENOTIFY_AddRef,
    WAB_IDENTITYCHANGENOTIFY_Release,
    WAB_IDENTITYCHANGENOTIFY_QuerySwitchIdentities,
    WAB_IDENTITYCHANGENOTIFY_SwitchIdentities,
    WAB_IDENTITYCHANGENOTIFY_IdentityInformationChanged
};

/*
-   HrCreateIdentityChangeNotifyObject
-
*   The ChangeNotificationObject is created only on the LPIAB object and on the
*   main browse window. Depending on where it's called from, we will pass in either the
*   lpIAB pointer or the hWnd of the Window.
*   THen when we get the callback notification, we can figure out what we want to do
*   based on which of the 2 are available to us ..
*
*/
HRESULT HrCreateIdentityChangeNotifyObject(LPIAB lpIAB, LPWABIDENTITYCHANGENOTIFY * lppWABIDCN)
{
    LPWABIDENTITYCHANGENOTIFY   lpIWABIDCN = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     		   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(WABIDENTITYCHANGENOTIFY), (LPVOID *) &lpIWABIDCN))) 
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpIWABIDCN,  TEXT("WAB IdentityChangeNotify Object"));

    ZeroMemory(lpIWABIDCN, sizeof(WABIDENTITYCHANGENOTIFY));

    lpIWABIDCN->lpVtbl = &vtblWABIDENTITYCHANGENOTIFY;

    lpIWABIDCN->lpIAB = lpIAB;

    lpIWABIDCN->lpVtbl->AddRef(lpIWABIDCN);

    *lppWABIDCN = lpIWABIDCN;

    return(hrSuccess);

err:

    FreeBufferAndNull(&lpIWABIDCN);
    return(hr);
}

void ReleaseWABIdentityChangeNotifyObj(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    MAPIFreeBuffer(lpIWABIDCN);
}

STDMETHODIMP_(ULONG)
WAB_IDENTITYCHANGENOTIFY_AddRef(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    return(++(lpIWABIDCN->lcInit));
}

STDMETHODIMP_(ULONG)
WAB_IDENTITYCHANGENOTIFY_Release(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    ULONG ulc = (--(lpIWABIDCN->lcInit));
    if(ulc==0)
       ReleaseWABIdentityChangeNotifyObj(lpIWABIDCN);
    return(ulc);
}


STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_QueryInterface(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpIWABIDCN;

    if(IsEqualIID(lpiid, &IID_IIdentityChangeNotify))
        lp = (LPVOID) lpIWABIDCN;

    if(!lp)
        return E_NOINTERFACE;

    ((LPWABIDENTITYCHANGENOTIFY) lp)->lpVtbl->AddRef((LPWABIDENTITYCHANGENOTIFY) lp);

    *lppNewObj = lp;

    return S_OK;

}


STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_QuerySwitchIdentities(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    HRESULT hr = S_OK;
    DebugTrace( TEXT("WAB: IDChangeNotify::QuerySwitchIdentities: 0x%.8x\n"), GetCurrentThreadId());
    if(lpIWABIDCN->lpIAB->hWndBrowse)
    {
        // if this relates to a window, then just make sure that the window is not deactivated
        // because that would imply that the window has a dialog in front of it.
        if (!IsWindowEnabled(lpIWABIDCN->lpIAB->hWndBrowse))
        {
            Assert(IsWindowVisible(lpIWABIDCN->lpIAB->hWndBrowse));
            return E_PROCESS_CANCELLED_SWITCH;
        }
    }
    return hr;
}

// MAJOR HACK WARNING
// [PaulHi] 12/22/98  See comment below.  We need to disable the "close WAB window
// on identity switch for when the client is OE5.  We don't want to change this code
// at this point for other clients.  I copied the OE5 PSExt GUID from the OE5 code
// base.
static const GUID OEBAControl_GUID =
{ 0x233a9694, 0x667e, 0x11d1, { 0x9d, 0xfb, 0x00, 0x60, 0x97, 0xd5, 0x04, 0x08 } };


STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_SwitchIdentities(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN)
{
    HRESULT hr = S_OK;
    DebugTrace( TEXT("WAB: IDChangeNotify::SwitchIdentities: 0x%.8x\n"), GetCurrentThreadId());

    if(memcmp(&lpIWABIDCN->lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)) ) //if not a wab.exe process .. shutdown
    {
        // [PaulHi] 12/22/98  Raid #63231, 48054
        // Don't close the WAB window here when OE is the host.  OE needs to shut
        // down the WAB in the correct order during identity switches or serious problems occur.
        if ( memcmp(&lpIWABIDCN->lpIAB->guidPSExt, &OEBAControl_GUID , sizeof(GUID)) != 0 )
            SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_CLOSE, 0, 0);
        return S_OK;
    }
    if(!HR_FAILED(HrLogonAndGetCurrentUserProfile(NULL, lpIWABIDCN->lpIAB, FALSE, TRUE)))
        HrGetWABProfiles(lpIWABIDCN->lpIAB);
    else    //they did a logoff
    {
        SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_CLOSE, 0, 0);
        return S_OK;
    }

    if(lpIWABIDCN->lpIAB->hWndBrowse) //hWndBrowse could be any window (main or find)
        SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_NOTIFY_REFRESHUSER, 0);

    return hr;
}

STDMETHODIMP
WAB_IDENTITYCHANGENOTIFY_IdentityInformationChanged(LPWABIDENTITYCHANGENOTIFY lpIWABIDCN, DWORD dwType)
{
    HRESULT hr = S_OK;
    DebugTrace( TEXT("WAB: IDChangeNotify::IdentityInformationChanged: %d 0x%.8x\n"), dwType, GetCurrentThreadId());
    if(dwType == IIC_CURRENT_IDENTITY_CHANGED)
    {
        // only thing we care about is a change in the name
        if(!HR_FAILED(HrGetIdentityName(lpIWABIDCN->lpIAB, NULL, lpIWABIDCN->lpIAB->szProfileName, ARRAYSIZE(lpIWABIDCN->lpIAB->szProfileName))))
        {
            UpdateCurrentUserFolderName(lpIWABIDCN->lpIAB);
            if(lpIWABIDCN->lpIAB->hWndBrowse)
                SendMessage(lpIWABIDCN->lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_NOTIFY_REFRESHUSER, 0);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\scs.c ===
/*--------------------------------------------------------------------
/
/ Screen.c
/
/ (c) Vikram Madan, 8/26/96
/
/   *** DO NOT REMOVE THIS CODE FROM THE WAB!!!! ***
/   
/---------------------------------------------------------------------*/

// Star         == A1111
// MAX_STARS    == A1112
// color        == A1113
// acc_time     == A1114
// acc_count    == A1115
// x            == A1116
// y            == A1117
// oldx         == A1118
// oldy         == A1119
// xv           == A1120
// yv           == A1121
// xa           == A1122
// ya           == A1123
// fnCredit     == A1124
// _Star        == A1125
// _NameInfo    == A1126
// width        == A1127
// delx         == A1128
// maxx         == A1129
// minx         == A1130
// tempx        == A1131
// cspace       == A1132
// delspace     == A1133
// clr          == A1134
// lpsz         == A1135
// len          == A1136
// THENAME_INFO == A1137
// LPTHENAME_INFO == A1138
// _credits     == A1139
// lpstar       == A1140
// nWidth       == A1141
// nHeight      == A1142
// hdc          == A1143
// hdcTemp      == A1144
// hWndPic      == A1145
// Names        == A1146
// rc           == A1147
// hbrBlack     == A1148
// hbm          == A1149
// hbmOld       == A1150
// CREDITS      == A1151
// LPCREDITS    == A1152
// Reset        == A1153
// MoveStars    == A1154
// InitStars    == A1155 
// lpcr         == A1156
// InitStar     == A1157
// ReInitStar   == A1158
// InitNames    == A1159
// srandom      == A1160
// seed         == A1161
// random       == A1162
// ID_TIMER     == A1163
// TIME_OUT     == A1164
// cr_hWnd      == A1165
// cr_hdc       == A1166
// cr_hdcTemp   == A1167
// cr_Names     == A1168
// cr_rc        == A1169
// cr_hbrBlack  == A1170
// cr_hbm       == A1171
// cr_hbmOld    == A1172
// cr_star      == A1173
// nCycle       == A1174
// hPen         == A1175
// hOldPen      == A1176
// i            == A1177
// count        == A1178
// nlen         == A1179
// j            == A1180
// k            == A1181
// lp           == A1182
// size         == A1183
// OldY         == A1184
// R            == A1185
// G            == A1186
// B            == A1187
// xStart       == A1188
// yStart       == A1189
// quadrant     == A1190
// divisor      == A1191
// table        == A1192
// t            == A1193


#include "_apipch.h"

INT_PTR CALLBACK A1124( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

typedef struct A1125
{
    int A1116,A1117;
    int A1118,A1119;
    int A1120,A1121;
    int A1122,A1123;
    COLORREF A1113;
    int A1114;
    int A1115;
} A1111, * LPA1111;

#define A1112 100


#define NAMES_MAX 43

typedef struct A1126
{
    int A1116;
    int A1117;
    int A1127;
    int A1128;
    int A1129;
    int A1130;
    int A1131;
    int A1132;
    int A1133;
    COLORREF A1134;
    LPSTR A1135;
    int A1136;
} A1137, * A1138;

typedef struct A1139
{
    LPA1111 A1140;
    int A1141,A1142;
    HDC A1143;
    HDC A1144;
    HWND A1145;
    A1137 * A1146;
    RECT A1147;
    HBRUSH A1148;
    HBITMAP A1149;
    HBITMAP A1150;
} A1151, *A1152;

void A1153(HWND hWnd, HDC A1143, A1138 A1146);
void A1154(A1152 A1156);
void A1155(A1152 A1156);
void A1157(LPA1111 A1140);
void A1158(LPA1111 A1140);
void A1159(A1138 A1146);
void A1160(unsigned int A1161);
int A1162(void);

#define A1163 999
#define A1164 25

int A1141,A1142;

void SCS(HWND hwndParent)
{
    A1152 A1156 = LocalAlloc(LMEM_ZEROINIT, sizeof(A1151));

    if(A1156)
    {
        if(!(A1156->A1140 = LocalAlloc(LMEM_ZEROINIT, sizeof(A1111)*A1112)))
            return;
        
        if(!(A1156->A1146 = LocalAlloc(LMEM_ZEROINIT, sizeof(A1137)*NAMES_MAX)))
            return;

        A1160 ((UINT) GetTickCount());

        DialogBoxParamA(
                    hinstMapiX,
                    (LPCSTR) MAKEINTRESOURCE(IDD_FORMVIEW),
                    hwndParent,
                    A1124,
                    (LPARAM) A1156);

        {
            int A1177;
            for(A1177=0;A1177<NAMES_MAX;A1177++)
            {
                if(A1156->A1146[A1177].A1135)
                    LocalFree(A1156->A1146[A1177].A1135);
            }

        }
        if(A1156->A1146)
            LocalFree(A1156->A1146);
        if(A1156->A1140)
            LocalFree(A1156->A1140);
        LocalFree(A1156);
    }
    return;
}

#define A1165     A1156->A1145
#define A1166      A1156->A1143
#define A1167  A1156->A1144
#define A1168    (A1156->A1146)
#define A1169       (A1156->A1147)
#define A1170 A1156->A1148
#define A1171      A1156->A1149
#define A1172   A1156->A1150
#define A1173     A1156->A1140

INT_PTR CALLBACK A1124(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    int A1177;

    A1152 A1156 = (A1152) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        A1156 = (A1152) lParam;
        SetWindowLongPtrA(hDlg, DWLP_USER, lParam);
        A1165 = GetDlgItem(hDlg,IDC_PIC);
        GetClientRect(A1165, &A1169);
        A1141 = A1169.right;
        A1142 = A1169.bottom;
        A1166 = GetDC(A1165);
        A1167 = CreateCompatibleDC(A1166);
        A1171 = CreateCompatibleBitmap(A1166, A1141, A1142);
        A1172 = SelectObject(A1167, A1171);
        SetBkColor(A1167, RGB(0,0,0));
        SetTextColor(A1167, RGB(255,255,0));
        SetBkMode(A1167, TRANSPARENT);
        A1170 = GetStockObject(BLACK_BRUSH);
        SetTimer(hDlg, A1163, A1164, NULL);
        A1155(A1156);
        A1159(A1168);
        A1153(A1165, A1167, A1168);
        break;


    case WM_TIMER:
        {
            static int A1174 = 0;
            IF_WIN32(if (hDlg != GetForegroundWindow()))
            IF_WIN16(if (hDlg != GetFocus()))
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDCANCEL, 0);
            A1174++;
            if(A1174 > 4)
                A1174 = 0;
            FillRect(A1167, &A1169, A1170);
            A1154(A1156);
            for(A1177=0;A1177<A1112;A1177++)
            {
                HPEN A1175 = CreatePen(PS_SOLID,0,(A1173[A1177]).A1113);
                HPEN A1176 = SelectObject(A1167, A1175);

                MoveToEx(A1167, A1173[A1177].A1118,A1173[A1177].A1119,NULL);
                LineTo(A1167, A1173[A1177].A1116, A1173[A1177].A1117);

                SelectObject(A1167, A1176);
                DeleteObject(A1175);

            }
            A1168[0].A1117--;
            for(A1177=1;A1177<NAMES_MAX;A1177++)
            {
                A1168[A1177].A1117--;
                if(A1174 == 1)
                {
                    A1168[A1177].A1132 += A1168[A1177].A1133;
                    if(A1168[A1177].A1132 == 0 || A1168[A1177].A1132 == 3)
                        A1168[A1177].A1133 *= -1;
                }
                A1168[A1177].A1131 += A1168[A1177].A1128;
                if(A1168[A1177].A1131 <= A1168[A1177].A1130 || A1168[A1177].A1131 >= A1168[A1177].A1129)
                    A1168[A1177].A1128 *= -1;
            }

            for(A1177=0;A1177<NAMES_MAX;A1177++)
            {
                if (A1168[A1177].A1117 < 0)
                    continue;
                if (A1168[A1177].A1117 > A1142)
                    break;
                SetTextColor(A1167, A1168[A1177].A1134);
                SetTextCharacterExtra(A1167, A1168[A1177].A1132);
                TextOutA(A1167, 
                    (A1177==0) ? A1168[A1177].A1116 :A1168[A1177].A1131 - ((A1168[A1177].A1136-1)*A1168[A1177].A1132)/2, 
                    A1168[A1177].A1117, A1168[A1177].A1135, A1168[A1177].A1136);
            }
            BitBlt(A1166, 0, 0, A1141, A1142, A1167, 0, 0, SRCCOPY);
            if(A1168[NAMES_MAX-1].A1117 < 0)
            {
                A1153(A1165, A1167, A1168);
            }
        }
        break;

   case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            KillTimer(hDlg, A1163);
            if(A1166)
            {
                ReleaseDC(A1165, A1166);
                A1166 = NULL;
            }
            if(A1171)
            {
                SelectObject(A1167, A1172);
                DeleteObject(A1171);
                A1171 = NULL;
            }
            if(A1167)
            {
                DeleteDC(A1167);
                A1167 = NULL;
            }
            EndDialog(hDlg, 1);
            break;
        }
        break;

    case WM_CLOSE:
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
    case WM_CHAR:
    case WM_KILLFOCUS:
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    case WM_MBUTTONUP:
        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDCANCEL, 0);
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;

}

// very simple name encryption
//
//  If you work on the WAB, you are welcome to add your name to the list below.. however, do not ever ever ever
//  remove any name from this list.
//  Each line that will be displayed on the screen should be represented as a seperate line in the array below.
//  The first number in each line is the count of all characters that will be in that line.
//  The encryption is simple with an 'a' subtracted from each character of the name. A key is provided for your
//  convenience. 
//  When you have added a name to the WAB, you should then increment the NAMES_MAX constant by the number of lines
//  you have added to the array below. Include all blank and 1 character lines in the count.
//  The list below is in approximate chronological order order so please maintain that by adding 
//  additional names to the bottom
//  ... and oh, you need to increase the NAMES_MAX structure by the added number of lines..
//  
//  Steps to trigger the credit screen:
//  1. Open WAB Main Window
//  2. Make sure you have atleast 1 entry in the List View
//  3. Select View Menu > Large Icon
//  4. Select View Menu > Sort By > Last Name
//  5. Make sure atleast 1 entry is selected in the List View
//  6. Press Ctrl Key + Alt Key + Shift Key all together and keep them pressed
//  7. Select File Menu > Properties
//  8. voila!  
//
// The Key (for adding more names is)
//  A   B   C   D   E   F   G   H   I   J   K   L   M   N    O   P   Q   R   S   T   U   V   W   X   Y   Z
// -32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 -21 -20 -19 -18 -17 -16 -15 -14 -13 -12 -11 -10  -9  -8 -7
//
//  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
//  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15  16  17  18  19  20  21>   22  23  24  25
//
//
// 
static const signed char nm[] =
{
//              //   W i  n d  o  w  s      A  d d r  e s  s        B  o  o  k
                20,-10,8,13,3,14,22,18,-65,-32,3,3,17,4,18,18,-65,-31,14,14,10,
                1,-65,
                1,-65,
                //   B  r  u c e       K e  l  l e  y
                12,-31,17,20,2,4,-65,-22,4,11,11,4,24,
                1,-65,
                // V i k r a m M a d a n
                12,-11,8,10,17,0,12,-65,-20,0,3,0,13,
                1,-65,
                // Y o r a m Y a a c o v i
                13,-8,14,17,0,12,-65,-8,0,0,2,14,21,8,
                1,-65,
                //   J e a  n       K a i  s e  r
                11,-23,4,0,13,-65,-22,0,8,18,4,17,
                1,-65,
                // M e a d H i m e l s t e i n
                15,-20,4,0,3,-65,-25,8,12,4,11,18,19,4,8,13,
                1,-65,
                //   T e  o  m a  n       S  m i  t h
                12,-13,4,14,12,0,13,-65,-14,12,8,19,7,
                1,-65,
                // M a r k D u r l e y
                11,-20,0,17,10,-65,-29,20,17,11,4,24,
                1,-65,
                // W i l l i a m L a i
                11,-10,8,11,11,8,0,12,-65,-21,0,8,
                1,-65,
                //   E  r i c       B e  r  m a  n
                11,-28,17,8,2,-65,-31,4,17,12,0,13,
                1,-65,
                //   S  u  s a  n       H i g g  s
                11,-14,20,18,0,13,-65,-25,8,6,6,18,
                1,-65,
                //  G e o r g e H a t o u n
                13, -26, 4, 14, 17, 6, 4, -65, -25, 0, 19, 14, 20, 13,
                1, -65,
                //   J  o h  n       T a f  o  y a
                11,-23,14,7,13,-65,-13,0,5,14,24,0,
                1,-65,
                //   G  o  r d  o  n       M c   E  l  r  o  y
                14,-26,14,17,3,14,13,-65,-20,2,-28,11,17,14,24,
                1,-65,
                //   L a  u  r e  n       A  n  t  o  n  o f f
                15,-21,0,20,17,4,13,-65,-32,13,19,14,13,14,5,5,
                1,-65,
                //   D e b  r a       W e i  s  s  m a  n
                14,-29,4,1,17,0,-65,-10,4,8,18,18,12,0,13,
                1,-65,
	            //   N e i  l       B  r e  n c h
	            11,-19,4,8,11,-65,-31,17,4,13,2,7,
	            1,-65,
                //   C h  r i  s       E  v a  n  s
                11,-30,7,17,8,18,-65,-28,21,0,13,18,
                1,-65,
                //   J a  s  o  n       S  t a j i c h
                13,-23,0,18,14,13,-65,-14,19,0,9,8,2,7,
                1,-65,
                //   C h  r i  s       D  r e  h  e  r
                12,-30,7,17,8,18,-65,-29,17,4, 7,4, 17,
                1,-65,
                //   W   e  i    B  i   n  g        Z  h  a   n
                12, -10, 4, 8, -31, 8, 13, 6, -65, -7, 7, 0, 13,
                1, -65,
};

void A1159(A1138 A1146)
{
    int A1177;
    int A1178 = 0;
    for(A1177=0;A1177<NAMES_MAX;A1177++)
    {
        int A1179 = nm[A1178++];
        int A1180;
        LPSTR A1182 = LocalAlloc(LMEM_ZEROINIT, A1179+1);
        A1146[A1177].A1135 = NULL;;
        if(!A1182)
        {
            DebugTrace(TEXT("InitStar LocalAlloc failed allocating %d bytes - error = %d\n"), (A1179+1), GetLastError());
            for(A1180=0;A1180<A1179;A1180++)
                A1178++;
            continue;
        }
        for(A1180=0;A1180<A1179;A1180++)
            A1182[A1180] = nm[A1178++] + 'a';
        A1182[A1179]='\0';
        A1146[A1177].A1135 = A1182;
        A1146[A1177].A1136 = A1179;
    }
    return;
}

void A1153(HWND hWnd, HDC A1143, A1138 A1146)
{

    RECT A1147;
    SIZE A1183;
    int A1184 = 0;
    int A1177,A1180;
    GetClientRect(hWnd, &A1147);
    A1146[0].A1117 = A1147.bottom;
    for(A1177=0;A1177<NAMES_MAX;A1177++)
    {
        GetTextExtentPoint32A(A1143,(LPSTR) A1146[A1177].A1135,A1146[A1177].A1136,&A1183);
        A1146[A1177].A1127 = A1183.cx;
        A1146[A1177].A1131 = A1146[A1177].A1116 = (A1147.right-A1183.cx)/2;
        A1146[A1177].A1129 = A1146[A1177].A1116 * 2 - 10;
        A1146[A1177].A1130 = 10;
        A1146[A1177].A1128 = A1162()%2 ? -1 : 1;
        A1146[A1177].A1134 = RGB(A1162()%128+128,A1162()%128+128,A1162()%192+64);
        A1146[A1177].A1133 = A1162()%2 ? -1 : 1;
        A1146[A1177].A1132 = 2;
        if(A1177>0)
            A1146[A1177].A1117 = A1146[A1177-1].A1117+A1184+1;
        A1184 = A1183.cy;
    }

    A1146[0].A1134 = RGB(255,255,0);
    A1146[0].A1128 = 0;
    A1146[0].A1133 = 0;
    A1146[0].A1132 = 0;

    for(A1177=1;A1177<NAMES_MAX;A1177++)
    {
        for(A1180=0;A1180<A1177;A1180++)
        {
            A1146[A1177].A1131 += A1146[A1177].A1128;
            if(A1146[A1177].A1131 <= A1146[A1177].A1130 || A1146[A1177].A1131 >= A1146[A1177].A1129)
                A1146[A1177].A1128 *= -1;
        }
    }
    return;
}

void A1157(LPA1111 A1140)
{
    int A1185 = A1162()%256;
    int A1186 = A1162()%256;
    int A1187 = A1162()%256;
    A1140->A1113 = RGB(A1185,A1186,A1187);
    A1158(A1140);
    A1140->A1114 = 1 + A1162()%3;

    return;
}

void A1158(LPA1111 A1140)
{
    int A1188 = A1141/4;
    int A1189 = A1142/4;
    int A1190 = ((int)A1162()%4);
    int A1191 = 1 + (A1162()%3);
    switch(A1190)
    {
    case 0:
        A1140->A1116 = 2*A1188 + A1162()%(A1188);
        A1140->A1117 = A1189 + A1162()%(A1189);
        A1140->A1120 = 1+(A1162()%3);
        A1140->A1121 = -1-(A1162()%3);
        break;
    case 1:
        A1140->A1116 = 2*A1188 + A1162()%(A1188);
        A1140->A1117 = 2*A1189 + A1162()%(A1189);
        A1140->A1120 = 1+(A1162()%3);
        A1140->A1121 = 1+(A1162()%3);
        break;
    case 2:
        A1140->A1116 = A1188 + A1162()%(A1188);
        A1140->A1117 = 2*A1189 + A1162()%(A1189);
        A1140->A1120 = -1-(A1162()%3);
        A1140->A1121 = 1+(A1162()%3);
        break;
    case 3:
        A1140->A1116 = A1188 + A1162()%(A1188);
        A1140->A1117 = A1189 + A1162()%(A1189);
        A1140->A1120 = -1-(A1162()%3);
        A1140->A1121 = -1-(A1162()%3);
        break;
    }
    A1140->A1118 = A1140->A1116 - A1140->A1120;
    A1140->A1119 = A1140->A1117 - A1140->A1121;
    A1140->A1122 = A1140->A1120/A1191;
    A1140->A1123 = A1140->A1121/A1191;
    A1140->A1115 = 0;
    return;
}

void A1155(A1152 A1156)
{
    int A1177;
    for(A1177=0;A1177<A1112;A1177++)
    {
        A1157(&(A1173[A1177]));
    }
    return;
}

void A1154(A1152 A1156)
{
    int A1177;
    for(A1177=0;A1177<A1112;A1177++)
    {
        A1173[A1177].A1118 = A1173[A1177].A1116;
        A1173[A1177].A1119 = A1173[A1177].A1117;
        A1173[A1177].A1116 += A1173[A1177].A1120;
        A1173[A1177].A1117 += A1173[A1177].A1121;

        if(
            (A1173[A1177].A1116 < 0) ||
            (A1173[A1177].A1117 < 0) ||
            (A1173[A1177].A1116 > A1141) ||
            (A1173[A1177].A1117 > A1142))
            A1158(&A1173[A1177]);

        if (++A1173[A1177].A1115 == A1173[A1177].A1114)
        {
            A1173[A1177].A1115 = 0;
            A1173[A1177].A1120 += A1173[A1177].A1122;
            A1173[A1177].A1121 += A1173[A1177].A1123;
        }
    }
    return;
}



static int		A1192[55];
static int		A1180, A1181;

void A1160(unsigned int A1161)
{
   int A1177;

   A1192[0] = A1161;
   for ( A1177 = 1 ; A1177 < 55 ; A1177++ )
   {
      A1192[A1177] = A1192[A1177-1] * 3;
      A1192[A1177] += 715827883;
   }
   A1180 = 22;
   A1181 = 54;
}

int A1162(void)
{
   unsigned int A1193;

   if (A1180 < 0)
   {
      A1160(0x8091A2B3);
   }
   A1193 = A1192[A1180] + A1192[A1181];        // overflow is ok.
   A1192[A1181] = A1193;

   A1180 = ( A1180 ) ? (A1180 - 1) : 54;
   A1181 = ( A1181 ) ? (A1181 - 1) : 54;

   return (int)(A1193 >> 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\strtype.c ===
//+------------------------------------------------------------------------
//
//  File:       strtype.c
//
//  Contents:   widechar character type function (CT_CTYPE1) and (CT_CTYPE3)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------

//#include "priv.h"
#include <_apipch.h>

#define __BIT_SHIFT 0
#define __INDEX_SHIFT 5
#define __PAGE_SHIFT 8

#define __BIT_MASK 31
#define __INDEX_MASK 7

// straight lookup functions are inlined.

#define ISCHARFUNC(type, wch) \
    (adwData[abIndex[abType1##type[wch>>__PAGE_SHIFT]] \
                          [(wch>>__INDEX_SHIFT)&__INDEX_MASK]] \
            >> (wch&__BIT_MASK)) & 1 
    
const DWORD adwData[218] =
{
#if 0
    0x00000000, 0x7fffffe0, 0xfffffeff, 0xffffffff,  // 0x00-0x03
    0xfffffd3f, 0xffffff00, 0x0000ffff, 0xff800000,  // 0x04-0x07
    0x02ebffff, 0xdfffffff, 0xfffefe2a, 0xbffff000,  // 0x08-0x0b
    0x7ffbffff, 0xffff7ffb, 0xd000ffff, 0xf998ffff,  // 0x0c-0x0f
    0xfff3fdd0, 0x00007fff, 0xfffffe00, 0x7fffffff,  // 0x10-0x13
    0xff000000, 0xffe0e000, 0x7fe00000, 0xffffff3e,  // 0x14-0x17
    0xfffef400, 0x07ffffff, 0xffffffd0, 0x000000ff,  // 0x18-0x1b
    0xd0000000, 0x07f99fff, 0xffbfa3d0, 0x0000000d,  // 0x1c-0x1f
    0xd000d000, 0x07e19fff, 0xffbfb6d0, 0x0000007a,  // 0x20-0x23
    0x07f5dfff, 0xffbfb7d0, 0x80000000, 0xffbfb3d0,  // 0x24-0x27
    0x07e3bd6b, 0x18e3fdd0, 0x07fbbfff, 0xffbff7d0,  // 0x28-0x2b
    0x00000002, 0xffbfffd0, 0xfffeb000, 0xfd000000,  // 0x2c-0x2f
    0x69a40f7f, 0x75360000, 0x0000000d, 0xfd00ffff,  // 0x30-0x33
    0xffffffd1, 0xe0ffffff, 0xffffffe0, 0xfffffdfd,  // 0x34-0x37
    0xfdfdff55, 0xfffffffd, 0xfffffbf8, 0x3bf8f3f0,  // 0x38-0x3b
    0xfff83bf8, 0x0000000f, 0xffd00000, 0x04000000,  // 0x3c-0x3f
    0xfffff81e, 0xffffffee, 0xfff87fff, 0xfffe0000,  // 0x40-0x43
    0xf0000000, 0xfffd0000, 0xfe001f01, 0xfffffefa,  // 0x44-0x47
    0xdbffffff, 0xffffd000, 0x00001fff, 0xffbfffff,  // 0x48-0x4b
    0xbfffffff, 0xffff3fff, 0x0000fff0, 0xfffffff8,  // 0x4c-0x4f
    0x03ffffff, 0x7ffffffe, 0x3f3f3f38, 0x007d0000,  // 0x50-0x53
    0xfff00000, 0x00000001, 0x7fff003f, 0x8000001f,  // 0x54-0x57
    0x8000001e, 0x00000100, 0x00002000, 0xfffffffe,  // 0x58-0x5b
    0xd0000d22, 0x0d000000, 0x3e000000, 0x0000007f,  // 0x5c-0x5f
    0x00400000, 0x00001800, 0x00080011, 0x801fe000,  // 0x60-0x63
    0x003d8000, 0x00000bff, 0x70000000, 0xfffdf800,  // 0x64-0x67
    0x3d008000, 0x0000000b, 0xf99d0100, 0x30003fe0,  // 0x68-0x6b
    0x20000000, 0xe19d0000, 0x0000f800, 0xfddd8000,  // 0x6c-0x6f
    0xf19d0300, 0x00008000, 0x30000000, 0x00000003,  // 0x70-0x73
    0xe3bd0100, 0xfbbd0600, 0xf3bd0100, 0x00014fe1,  // 0x74-0x77
    0x03ff0030, 0x0001ffdd, 0xfafd0000, 0x00000010,  // 0x78-0x7b
    0x00000007, 0xd0070007, 0x00070006, 0xfffeffff,  // 0x7c-0x7f
    0xfe000000, 0x003f003f, 0x003e0000, 0xffffff80,  // 0x80-0x83
    0xe000ffff, 0xffe00000, 0xf8000000, 0xfffffd00,  // 0x84-0x87
    0xfffbffff, 0xffff0000, 0xfffff03f, 0x7bdfffff,  // 0x88-0x8b
    0xff7fffff, 0xfff5e2fe, 0x7f0003ff, 0xfffff8ff,  // 0x8c-0x8f
    0xffff7ffe, 0xffffff01, 0x0000007e, 0x0000001e,  // 0x90-0x93
    0xfffffff1, 0xffff8000, 0xfff0ffff, 0xfffffe1f,  // 0x94-0x97
    0xf000ffff, 0xf87fefff, 0xfef0ebff, 0x7d008000,  // 0x98-0x9b
    0xfefe0000, 0x0000ffd0, 0x00003040, 0x03ff0000,  // 0x9c-0x9f
    0x01ffe000, 0x00008fd0, 0x7e000000, 0xfffffefe,  // 0xa0-0xa3
    0xaaaaaaaa, 0xaaaaaa55, 0x552aaaaa, 0xaaaaaad4,  // 0xa4-0xa7
    0x6b73db8d, 0xa94b7588, 0x0db55552, 0xaaaa682a,  // 0xa8-0xab
    0xaaaaaa00, 0x02eb7fff, 0xdff00000, 0x0000382a,  // 0xac-0xaf
    0xaaaa0000, 0x8000aaaa, 0x5110aaaa, 0xaaa2a880,  // 0xb0-0xb3
    0xaaaaa800, 0xaaaaaa80, 0x00ff00fd, 0x00ff00ff,  // 0xb4-0xb7
    0x00fd0055, 0x00ff0000, 0x00ff00f8, 0x00f800f0,  // 0xb8-0xbb
    0x00f800f8, 0x000003ff, 0x55555555, 0x555555aa,  // 0xbc-0xbf
    0xaad55555, 0x5555552b, 0x948d2472, 0x54948a64,  // 0xc0-0xc3
    0x06daaaad, 0x5555b415, 0x55555500, 0xdfdff5ff,  // 0xc4-0xc7
    0x3ffef026, 0x9f800000, 0x000fffff, 0xfffed600,  // 0xc8-0xcb
    0x1555f000, 0x40005555, 0x28885555, 0x55515440,  // 0xcc-0xcf
    0x555557e0, 0x55555540, 0xff00fd00, 0xff00ff00,  // 0xd0-0xd3
    0xfd00ff00, 0xff00fffd, 0xff00fb00, 0x3b00f300,  // 0xd4-0xd7
    0xff003b00, 0xfe001f00
#else
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
#endif
};

const BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

const BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL IsCharSpaceW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

#if 0   
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
   
    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

const BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

const BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL IsCharDigitW(WCHAR wch) { return ISCHARFUNC(Digit, wch); }

BOOL IsCharXDigitW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
#if 0
    return adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
           & (1<<(wch&__BIT_MASK));
#endif
}

const BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

const BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};


BOOL IsCharPunctW(WCHAR wch) { return ISCHARFUNC(Punct, wch); }


BOOL IsCharCntrlW(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL IsCharBlankW(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}


BOOL IsCharAlphaWrapW(WCHAR wch) { return ISCHARFUNC(Alpha, wch); }
BOOL IsCharUpperWrapW(WCHAR wch) { return ISCHARFUNC(Upper, wch); }
BOOL IsCharLowerWrapW(WCHAR wch) { return ISCHARFUNC(Lower, wch); }

BOOL IsCharAlphaNumericWrapW(WCHAR wch)
{
    return ISCHARFUNC(Alpha, wch) || ISCHARFUNC(Digit, wch);
}


static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}
const aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};


//
//  CType 3 Flag Bits.
//
//  In the interest of reducing our table complexity, we've here a reduced
//  bitfield.  Only those bits currently used by IE4 are returned by
//  GetStringType3Ex().
//

// These are the flags are they are defined in winnls.h
//

// C3_NONSPACING    0x0001
// C3_DIACRITIC     0x0002
// C3_VOWELMARK     0x0004
// C3_SYMBOL        0x0008
// C3_KATAKANA      0x0010
// C3_HIRAGANA      0x0020
// C3_HALFWIDTH     0x0040
// C3_FULLWIDTH     0x0080
// C3_IDEOGRAPH     0x0100
// C3_KASHIDA       0x0200
// C3_LEXICAL       0x0400
// C3_ALPHA         0x8000

// The supported flags are encoded by shifting them to the right 3 bits.

// C3_SYMBOL       0x0001
// C3_KATAKANA     0x0002
// C3_HIRAGANA     0x0004
// C3_HALFWIDTH    0x0008
// C3_FULLWIDTH    0x0010
// C3_IDEOGRAPH    0x0020

// GetStringType3Ex returns the correct Win32 flags NOT the compressed flags.


BOOL 
GetStringType3ExW(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPWORD  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        WORD wCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                wCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                wCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                wCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                wCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    const struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    wCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    wCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = wCharType << 3;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\structs.h ===
/*
 *	STRUCTS.H
 *	
 *	Structures defining method parameters for validation sub-system
 */

#ifndef STRUCTS_H
#define STRUCTS_H

#if defined(_AMD64_) || defined(_IA64_)
#define LARGE_INTEGER_ARG		LARGE_INTEGER
#define LARGE_INTEGER_ARG_2		LARGE_INTEGER
#define ULARGE_INTEGER_ARG		ULARGE_INTEGER
#define ULARGE_INTEGER_ARG_2	ULARGE_INTEGER
#else
#define LARGE_INTEGER_ARG		LPVOID	XXXX; LPVOID
#define LARGE_INTEGER_ARG_2		LPVOID	YYYY; LPVOID
#define ULARGE_INTEGER_ARG		LPVOID  XXXX; LPVOID
#define ULARGE_INTEGER_ARG_2	LPVOID  YYYY; LPVOID
#endif

/*
 * These structures represent the parameters for the appropriate functions as they
 * appear on the stack.
 *
 * The WIN16 stack is laid out differently, and has the parameters in the reverse order.
 *
 * Our __ValidateParameters function decides passes a pointer to the stack at the start of
 * the parameter list, and the type of the Validation routines parameter determines
 * what values it has to check.  These values do not change between platforms.
 *
 * If parameters to a method change, the structure must be updated to reflect the change.
 *
 * The names of the Typedefs are important as other things are generated based on these
 * names.
 *
 */

/* Keystroke Macros to convert method in MAPIDEFS.H to structure here
 *
 * 1. Convert MAPIMETHOD(XXX) to typedef struct _tagXXX_Params (search for ')')
 * 2. For each line, find comma, replace with ; and delete to end of line
 * 3. Start on typedef line, read XXX, search for IPURE, replace preceding )
 *	  with ;, add new line, generate } XXX_params, FAR * LPXXXParams;
 * 4. Change (THIS_ to LPVOID This;, split line
 *
 */


/****************** IUnknown *********************/
typedef struct _tagIUnknown_QueryInterface_Params
{
				LPVOID						This;	
				REFIID						iidInterface;
				LPVOID						lppNewObject;
} IUnknown_QueryInterface_Params, FAR * LPIUnknown_QueryInterface_Params;

typedef struct _tagIUnknown_AddRef_Params
{
				LPVOID						This;	
} IUnknown_AddRef_Params, FAR * LPIUnknown_AddRef_Params;

typedef struct _tagIUnknown_Release_Params
{
				LPVOID						This;	
} IUnknown_Release_Params, FAR * LPIUnknown_Release_Params;


/* AddRef and Release take no parameters */

/***************** IMAPIProp *********************/

typedef struct _tagIMAPIProp_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIProp_GetLastError_Params, FAR * LPIMAPIProp_GetLastError_Params;

typedef struct _tagIMAPIProp_SaveChanges_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IMAPIProp_SaveChanges_Params, FAR * LPIMAPIProp_SaveChanges_Params;


/* GetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_GetProps_Params
{
	LPVOID				This;
	LPSPropTagArray		lpPropTagArray;
	ULONG				ulFlags;
	ULONG FAR *			lpcValues;
	LPSPropValue FAR *	lppPropArray;
} IMAPIProp_GetProps_Params, FAR * LPIMAPIProp_GetProps_Params;



typedef struct _tagIMAPIProp_GetPropList_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTagArray;
} IMAPIProp_GetPropList_Params, FAR * LPIMAPIProp_GetPropList_Params;
				
typedef struct _tagIMAPIProp_OpenProperty_Params
{
				LPVOID						This;	
				ULONG						ulPropTag;
				LPIID						lpiid;
				ULONG						ulInterfaceOptions;
				ULONG						ulFlags;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIProp_OpenProperty_Params, FAR * LPIMAPIProp_OpenProperty_Params;

/* SetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_SetProps_Params
{
	LPVOID				This;
	ULONG				cValues;
	LPSPropValue 		lpPropArray;
	LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_SetProps_Params, FAR * LPIMAPIProp_SetProps_Params;


typedef struct _tagIMAPIProp_DeleteProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_DeleteProps_Params, FAR * LPIMAPIProp_DeleteProps_Params;
				
typedef struct _tagIMAPIProp_CopyTo_Params
{
				LPVOID						This;	
				ULONG						ciidExclude;
				LPIID						rgiidExclude;
				LPSPropTagArray				lpExcludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyTo_Params, FAR * LPIMAPIProp_CopyTo_Params;
				
typedef struct _tagIMAPIProp_CopyProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpIncludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyProps_Params, FAR * LPIMAPIProp_CopyProps_Params;
				
typedef struct _tagIMAPIProp_GetNamesFromIDs_Params
{
				LPVOID						This;	
				LPSPropTagArray FAR *		lppPropTags;
				LPGUID						lpPropSetGuid;
				ULONG						ulFlags;
				ULONG FAR *					lpcPropNames;
				LPMAPINAMEID FAR * FAR *	lpppPropNames;
} IMAPIProp_GetNamesFromIDs_Params, FAR * LPIMAPIProp_GetNamesFromIDs_Params;
				
typedef struct _tagIMAPIProp_GetIDsFromNames_Params
{
				LPVOID						This;	
				ULONG						cPropNames;
				LPMAPINAMEID FAR *			lppPropNames;
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTags;
} IMAPIProp_GetIDsFromNames_Params, FAR * LPIMAPIProp_GetIDsFromNames_Params;


/********************* IMAPITable **************************************/

typedef struct _tagIMAPITable_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPITable_GetLastError_Params, FAR * LPIMAPITable_GetLastError_Params;

typedef struct _tagIMAPITable_Advise_Params
{
				LPVOID						This;	
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMAPITable_Advise_Params, FAR * LPIMAPITable_Advise_Params;


typedef struct _tagIMAPITable_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMAPITable_Unadvise_Params, FAR * LPIMAPITable_Unadvise_Params;


typedef struct _tagIMAPITable_GetStatus_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulTableStatus;
				ULONG FAR *					lpulTableType;
} IMAPITable_GetStatus_Params, FAR * LPIMAPITable_GetStatus_Params;


typedef struct _tagIMAPITable_SetColumns_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
} IMAPITable_SetColumns_Params, FAR * LPIMAPITable_SetColumns_Params;


typedef struct _tagIMAPITable_QueryColumns_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lpPropTagArray;
} IMAPITable_QueryColumns_Params, FAR * LPIMAPITable_QueryColumns_Params;


typedef struct _tagIMAPITable_GetRowCount_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG FAR *					lpulCount;
} IMAPITable_GetRowCount_Params, FAR * LPIMAPITable_GetRowCount_Params;


typedef struct _tagIMAPITable_SeekRow_Params
{
				LPVOID						This;	
				BOOKMARK					bkOrigin;
				LONG						lRowCount;
				LONG FAR *					lplRowsSought;
} IMAPITable_SeekRow_Params, FAR * LPIMAPITable_SeekRow_Params;


typedef struct _tagIMAPITable_SeekRowApprox_Params
{
				LPVOID						This;	
				ULONG						ulNumerator;
				ULONG						ulDenominator;
} IMAPITable_SeekRowApprox_Params, FAR * LPIMAPITable_SeekRowApprox_Params;


typedef struct _tagIMAPITable_QueryPosition_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulRow;
				ULONG FAR *					lpulNumerator;
				ULONG FAR *					lpulDenominator;
} IMAPITable_QueryPosition_Params, FAR * LPIMAPITable_QueryPosition_Params;


typedef struct _tagIMAPITable_FindRow_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				BOOKMARK					bkOrigin;
				ULONG						ulFlags;
} IMAPITable_FindRow_Params, FAR * LPIMAPITable_FindRow_Params;


typedef struct _tagIMAPITable_Restrict_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				ULONG						ulFlags;
} IMAPITable_Restrict_Params, FAR * LPIMAPITable_Restrict_Params;


typedef struct _tagIMAPITable_CreateBookmark_Params
{
				LPVOID						This;	
				BOOKMARK FAR *				lpbkPosition;
} IMAPITable_CreateBookmark_Params, FAR * LPIMAPITable_CreateBookmark_Params;


typedef struct _tagIMAPITable_FreeBookmark_Params
{
				LPVOID						This;	
				BOOKMARK					bkPosition;
} IMAPITable_FreeBookmark_Params, FAR * LPIMAPITable_FreeBookmark_Params;


typedef struct _tagIMAPITable_SortTable_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPITable_SortTable_Params, FAR * LPIMAPITable_SortTable_Params;


typedef struct _tagIMAPITable_QuerySortOrder_Params
{
				LPVOID						This;	
				LPSSortOrderSet FAR *		lppSortCriteria;
} IMAPITable_QuerySortOrder_Params, FAR * LPIMAPITable_QuerySortOrder_Params;


typedef struct _tagIMAPITable_QueryRows_Params
{
				LPVOID						This;	
				LONG						lRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
} IMAPITable_QueryRows_Params, FAR * LPIMAPITable_QueryRows_Params;


typedef struct _tagIMAPITable_Abort_Params
{
				LPVOID						This;
} IMAPITable_Abort_Params, FAR * LPIMAPITable_Abort_Params;


typedef struct _tagIMAPITable_ExpandRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
				ULONG FAR *					lpulMoreRows;
} IMAPITable_ExpandRow_Params, FAR * LPIMAPITable_ExpandRow_Params;


typedef struct _tagIMAPITable_CollapseRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulFlags;
				ULONG FAR *					lpulRowCount;
} IMAPITable_CollapseRow_Params, FAR * LPIMAPITable_CollapseRow_Params;


typedef struct _tagIMAPITable_WaitForCompletion_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						ulTimeout;
				ULONG FAR *					lpulTableStatus;
} IMAPITable_WaitForCompletion_Params, FAR * LPIMAPITable_WaitForCompletion_Params;


typedef struct _tagIMAPITable_GetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbInstanceKey;
				LPBYTE						lpbInstanceKey;
				ULONG FAR *					lpcbCollapseState;
				LPBYTE FAR *				lppbCollapseState;
} IMAPITable_GetCollapseState_Params, FAR * LPIMAPITable_GetCollapseState_Params;
				
typedef struct _tagIMAPITable_SetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbCollapseState;
				LPBYTE						pbCollapseState;
				BOOKMARK FAR *				lpbkLocation;
} IMAPITable_SetCollapseState_Params, FAR * LPIMAPITable_SetCollapseState_Params;



/********************* IMAPIStatus *************************************/

typedef struct _tagIMAPIStatus_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_ValidateState_Params, FAR * LPIMAPIStatus_ValidateState_Params;
				
typedef struct _tagIMAPIStatus_SettingsDialog_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_SettingsDialog_Params, FAR * LPIMAPIStatus_SettingsDialog_Params;
				
typedef struct _tagIMAPIStatus_ChangePassword_Params
{
				LPVOID						This;
				LPTSTR						lpOldPass;
				LPTSTR						lpNewPass;
				ULONG						ulFlags;
} IMAPIStatus_ChangePassword_Params, FAR * LPIMAPIStatus_ChangePassword_Params;
				
typedef struct _tagIMAPIStatus_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IMAPIStatus_FlushQueues_Params, FAR * LPIMAPIStatus_FlushQueues_Params;


/******************** IMAPIContainer ***********************************/


typedef struct _tagIMAPIContainer_GetContentsTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetContentsTable_Params, FAR * LPIMAPIContainer_GetContentsTable_Params;


typedef struct _tagIMAPIContainer_GetHierarchyTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetHierarchyTable_Params, FAR * LPIMAPIContainer_GetHierarchyTable_Params;


typedef struct _tagIMAPIContainer_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIContainer_OpenEntry_Params, FAR * LPIMAPIContainer_OpenEntry_Params;


typedef struct _tagIMAPIContainer_SetSearchCriteria_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				LPENTRYLIST					lpContainerList;
				ULONG						ulSearchFlags;
} IMAPIContainer_SetSearchCriteria_Params, FAR * LPIMAPIContainer_SetSearchCriteria_Params;


typedef struct _tagIMAPIContainer_GetSearchCriteria_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSRestriction FAR *		lppRestriction;
				LPENTRYLIST FAR *			lppContainerList;
				ULONG FAR *					lpulSearchState;
} IMAPIContainer_GetSearchCriteria_Params, FAR * LPIMAPIContainer_GetSearchCriteria_Params;



/****************************** IABContainer *****************************/


typedef struct _tagIABContainer_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IABContainer_CreateEntry_Params, FAR * LPIABContainer_CreateEntry_Params;


typedef struct _tagIABContainer_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IABContainer_CopyEntries_Params, FAR * LPIABContainer_CopyEntries_Params;


typedef struct _tagIABContainer_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IABContainer_DeleteEntries_Params, FAR * LPIABContainer_DeleteEntries_Params;

typedef struct _tagIABContainer_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IABContainer_ResolveNames_Params, FAR * LPIABContainer_ResolveNames_Params;

/*************************** IDistList ***********************************/


typedef struct _tagIDistList_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulCreateFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IDistList_CreateEntry_Params, FAR * LPIDistList_CreateEntry_Params;


typedef struct _tagIDistList_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IDistList_CopyEntries_Params, FAR * LPIDistList_CopyEntries_Params;


typedef struct _tagIDistList_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IDistList_DeleteEntries_Params, FAR * LPIDistList_DeleteEntries_Params;

typedef struct _tagIDistList_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IDistList_ResolveNames_Params, FAR * LPIDistList_ResolveNames_Params;

/**************************** IMAPIFolder *******************************/

typedef struct _tagIMAPIFolder_CreateMessage_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMESSAGE FAR *				lppMessage;
} IMAPIFolder_CreateMessage_Params, FAR * LPIMAPIFolder_CreateMessage_Params;


typedef struct _tagIMAPIFolder_CopyMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyMessages_Params, FAR * LPIMAPIFolder_CopyMessages_Params;


typedef struct _tagIMAPIFolder_DeleteMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteMessages_Params, FAR * LPIMAPIFolder_DeleteMessages_Params;


typedef struct _tagIMAPIFolder_CreateFolder_Params
{
				LPVOID						This;	
				ULONG						ulFolderType;
				LPTSTR						lpszFolderName;
				LPTSTR						lpszFolderComment;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMAPIFOLDER FAR *			lppFolder;
} IMAPIFolder_CreateFolder_Params, FAR * LPIMAPIFolder_CreateFolder_Params;


typedef struct _tagIMAPIFolder_CopyFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				LPTSTR						lpszNewFolderName;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyFolder_Params, FAR * LPIMAPIFolder_CopyFolder_Params;


typedef struct _tagIMAPIFolder_DeleteFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteFolder_Params, FAR * LPIMAPIFolder_DeleteFolder_Params;


typedef struct _tagIMAPIFolder_SetReadFlags_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_SetReadFlags_Params, FAR * LPIMAPIFolder_SetReadFlags_Params;


typedef struct _tagIMAPIFolder_GetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				ULONG FAR *					lpulMessageStatus;
} IMAPIFolder_GetMessageStatus_Params, FAR * LPIMAPIFolder_GetMessageStatus_Params;


typedef struct _tagIMAPIFolder_SetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulNewStatus;
				ULONG						ulNewStatusMask;
				ULONG FAR *					lpulOldStatus;
} IMAPIFolder_SetMessageStatus_Params, FAR * LPIMAPIFolder_SetMessageStatus_Params;


typedef struct _tagIMAPIFolder_SaveContentsSort_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPIFolder_SaveContentsSort_Params, FAR * LPIMAPIFolder_SaveContentsSort_Params;


typedef struct _tagIMAPIFolder_EmptyFolder_Params
{
				LPVOID						This;	
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_EmptyFolder_Params, FAR * LPIMAPIFolder_EmptyFolder_Params;



/**************************** IMsgStore **********************************/

typedef struct _tagIMsgStore_Advise_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMsgStore_Advise_Params, FAR * LPIMsgStore_Advise_Params;


typedef struct _tagIMsgStore_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMsgStore_Unadvise_Params, FAR * LPIMsgStore_Unadvise_Params;


typedef struct _tagIMsgStore_CompareEntryIDs_Params
{
				LPVOID						This;	
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMsgStore_CompareEntryIDs_Params, FAR * LPIMsgStore_CompareEntryIDs_Params;

typedef struct _tagIMsgStore_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMsgStore_OpenEntry_Params, FAR * LPIMsgStore_OpenEntry_Params;



typedef struct _tagIMsgStore_SetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_SetReceiveFolder_Params, FAR * LPIMsgStore_SetReceiveFolder_Params;


typedef struct _tagIMsgStore_GetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG FAR *					lpcbEntryID;
				LPENTRYID FAR *				lppEntryID;
				LPTSTR FAR *				lppszExplicitClass;
} IMsgStore_GetReceiveFolder_Params, FAR * LPIMsgStore_GetReceiveFolder_Params;


typedef struct _tagIMsgStore_GetReceiveFolderTable_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetReceiveFolderTable_Params, FAR * LPIMsgStore_GetReceiveFolderTable_Params;


typedef struct _tagIMsgStore_StoreLogoff_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulFlags;
} IMsgStore_StoreLogoff_Params, FAR * LPIMsgStore_StoreLogoff_Params;


typedef struct _tagIMsgStore_AbortSubmit_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
} IMsgStore_AbortSubmit_Params, FAR * LPIMsgStore_AbortSubmit_Params;


typedef struct _tagIMsgStore_GetOutgoingQueue_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetOutgoingQueue_Params, FAR * LPIMsgStore_GetOutgoingQueue_Params;


typedef struct _tagIMsgStore_SetLockState_Params
{
				LPVOID						This;	
				LPMESSAGE					lpMessage;
				ULONG						ulLockState;
} IMsgStore_SetLockState_Params, FAR * LPIMsgStore_SetLockState_Params;


typedef struct _tagIMsgStore_FinishedMsg_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_FinishedMsg_Params, FAR * LPIMsgStore_FinishedMsg_Params;


typedef struct _tagIMsgStore_NotifyNewMail_Params
{
				LPVOID						This;	
				LPNOTIFICATION				lpNotification;
} IMsgStore_NotifyNewMail_Params, FAR * LPIMsgStore_NotifyNewMail_Params;



/*************************** IMessage ***********************************/

typedef struct _tagIMessage_GetAttachmentTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetAttachmentTable_Params, FAR * LPIMessage_GetAttachmentTable_Params;


typedef struct _tagIMessage_OpenAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPATTACH FAR *				lppAttach;
} IMessage_OpenAttach_Params, FAR * LPIMessage_OpenAttach_Params;


typedef struct _tagIMessage_CreateAttach_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulAttachmentNum;
				LPATTACH FAR *				lppAttach;
} IMessage_CreateAttach_Params, FAR * LPIMessage_CreateAttach_Params;


typedef struct _tagIMessage_DeleteAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMessage_DeleteAttach_Params, FAR * LPIMessage_DeleteAttach_Params;


typedef struct _tagIMessage_GetRecipientTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetRecipientTable_Params, FAR * LPIMessage_GetRecipientTable_Params;


typedef struct _tagIMessage_ModifyRecipients_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPADRLIST					lpMods;
} IMessage_ModifyRecipients_Params, FAR * LPIMessage_ModifyRecipients_Params;


typedef struct _tagIMessage_SubmitMessage_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SubmitMessage_Params, FAR * LPIMessage_SubmitMessage_Params;


typedef struct _tagIMessage_SetReadFlag_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SetReadFlag_Params, FAR * LPIMessage_SetReadFlag_Params;



/**************************** IStream *********************************/


typedef struct _tagIStream_Read_Params
{
				LPVOID						This;
				VOID HUGEP *				pv;
				ULONG						cb;
				ULONG FAR *					pcbRead;
} IStream_Read_Params, FAR * LPIStream_Read_Params;

typedef struct _tagIStream_Write_Params
{
				LPVOID						This;
				VOID const HUGEP *			pv;
				ULONG						cb;
				ULONG FAR *					pcbWritten;
} IStream_Write_Params, FAR * LPIStream_Write_Params;

typedef struct _tagIStream_Seek_Params
{
				LPVOID						This;
				LARGE_INTEGER_ARG			dlibMove;
				DWORD						dwOrigin;
				ULARGE_INTEGER FAR *		plibNewPosition;
} IStream_Seek_Params, FAR * LPIStream_Seek_Params;

typedef struct _tagIStream_SetSize_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libNewSize;
} IStream_SetSize_Params, FAR * LPIStream_SetSize_Params;

typedef struct _tagIStream_CopyTo_Params
{
				LPVOID						This;
				IStream FAR *				pstm;
				ULARGE_INTEGER				cb;
				ULARGE_INTEGER FAR *		pcbRead;
				ULARGE_INTEGER FAR *		pcbWritten;
} IStream_CopyTo_Params, FAR * LPIStream_CopyTo_Params;

typedef struct _tagIStream_Commit_Params
{
				LPVOID						This;
				DWORD						grfCommitFlags;
} IStream_Commit_Params, FAR * LPIStream_Commit_Params;

typedef struct _tagIStream_Revert_Params
{
				LPVOID						This;
} IStream_Revert_Params, FAR * LPIStream_Revert_Params;

typedef struct _tagIStream_LockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_LockRegion_Params, FAR * LPIStream_LockRegion_Params;

typedef struct _tagIStream_UnlockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_UnlockRegion_Params, FAR * LPIStream_UnlockRegion_Params;

typedef struct _tagIStream_Stat_Params
{
				LPVOID						This;
				STATSTG FAR *				pstatstg;
				DWORD						grfStatFlag;
} IStream_Stat_Params, FAR * LPIStream_Stat_Params;

typedef struct _tagIStream_Clone_Params
{
				LPVOID						This;
				IStream FAR * FAR *			ppstm;
} IStream_Clone_Params, FAR * LPIStream_Clone_Params;

/************************* IMAPIAdviseSink *****************************/

typedef struct _tagIMAPIAdviseSink_OnNotify_Params
{
				LPVOID						This;
				ULONG						cNotif;
				LPNOTIFICATION				lpNotifications;
} IMAPIAdviseSink_OnNotify_Params, FAR * LPIMAPIAdviseSink_OnNotify_Params;


/***************** IWABObject *********************/

typedef struct _tagIWABObject_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IWABObject_GetLastError_Params, FAR * LPIWABOBJECT_GetLastError_Params;

typedef struct _tagIWABObject_AllocateBuffer_Params
{
				LPVOID						This;	
				ULONG                       cbSize;
				LPVOID FAR *			    lppBuffer;
} IWABObject_AllocateBuffer_Params, FAR * LPIWABOBJECT_AllocateBuffer_Params;

typedef struct _tagIWABObject_AllocateMore_Params
{
				LPVOID						This;	
				ULONG                       cbSize;
               LPVOID                      lpObject;
				LPVOID FAR *			    lppBuffer;
} IWABObject_AllocateMore_Params, FAR * LPIWABOBJECT_AllocateMore_Params;

typedef struct _tagIWABObject_FreeBuffer_Params
{
				LPVOID						This;	
               LPVOID                      lpObject;
} IWABObject_FreeBuffer_Params, FAR * LPIWABOBJECT_FreeBuffer_Params;

typedef struct _tagIWABObject_Backup_Params
{
				LPVOID						This;	
               LPTSTR                      lpFileName;
} IWABObject_Backup_Params, FAR * LPIWABOBJECT_Backup_Params;

typedef struct _tagIWABObject_Import_Params
{
				LPVOID						This;	
               LPTSTR                      lpFileName;
} IWABObject_Import_Params, FAR * LPIWABOBJECT_Import_Params;



/************************** Provider INIT ******************************/

//
//typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
//	HINSTANCE				hInstance,
//	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
//	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
//	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
//	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
//	ULONG					ulFlags,
//	ULONG					ulMAPIVer,
//	ULONG FAR *				lpulProviderVer,
//	LPMSPROVIDER FAR *		lppMSProvider
//);
//
//typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//	ULONG				ulFlags,
//	ULONG				ulMAPIVer,
//	ULONG FAR *			lpulProviderVer,
//	LPXPPROVIDER FAR *	lppXPProvider);
//
//
//typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//    ULONG				ulFlags,
//    ULONG				ulMAPIVer,
//    ULONG FAR *			lpulProviderVer,
//    LPABPROVIDER FAR *	lppABProvider
//);


//typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
//			HINSTANCE		hInst,
//			LPMALLOC		lpMalloc,
//			ULONG			ulFlags,
//			ULONG			cbOptionData,
//			LPBYTE			lpbOptionData,
//			LPMAPISUP		lpMAPISup,
//			LPMAPIPROP		lpDataSource,
//			LPMAPIPROP FAR *lppWrappedSource,
//			LPTSTR FAR *	lppszErrorMsg,
//			LPTSTR FAR *	lppszErrorComponent,
//			ULONG FAR *		lpulErrorContext);



#endif /* STRUCTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\uimisc.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	UIMISC.C - common miscellaneous functions used by the UI
//
//
////////////////////////////////////////////////////////////////////////////////

#include "_apipch.h"

const LPTSTR szLDAPDefaultCountryValue =  TEXT("LDAP Default Country");
const LPTSTR szTrailingDots  =  TEXT("...");
const LPTSTR szArrow =  TEXT(" ->");
const LPTSTR szBackSlash =  TEXT("\\");

extern BOOL bDNisByLN;
extern BOOL bIsPasteData();

HINSTANCE ghCommDlgInst = NULL;

extern HINSTANCE ghCommCtrlDLLInst;
extern ULONG     gulCommCtrlDLLRefCount;
extern void SetVirtualPABEID(LPIAB lpIAB, ULONG * lpcb, LPENTRYID * lppb);

extern void vTurnOffAllNotifications();
extern void vTurnOnAllNotifications();

LP_INITCOMMONCONTROLSEX gpfnInitCommonControlsEx = NULL;
LPIMAGELIST_SETBKCOLOR gpfnImageList_SetBkColor  = NULL;
LPIMAGELIST_DRAW       gpfnImageList_Draw        = NULL;
LPIMAGELIST_DESTROY    gpfnImageList_Destroy     = NULL;

LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA     = NULL;
LPPROPERTYSHEET_A            gpfnPropertySheetA           = NULL;
LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA = NULL;
LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW     = NULL;
LPPROPERTYSHEET_W            gpfnPropertySheetW           = NULL;
LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW = NULL;

// CommCtrl function names
static const TCHAR cszCommCtrlClientDLL[]       =  TEXT("COMCTL32.DLL");
static const char cszInitCommonControlsEx[]    = "InitCommonControlsEx";
static const char cszImageList_SetBkColor[]    = "ImageList_SetBkColor";
static const char cszImageList_LoadImageA[]     = "ImageList_LoadImageA";
static const char cszPropertySheetA[]           = "PropertySheetA";
static const char cszCreatePropertySheetPageA[] = "CreatePropertySheetPageA";
static const char cszImageList_LoadImageW[]     = "ImageList_LoadImageW";
static const char cszPropertySheetW[]           = "PropertySheetW";
static const char cszCreatePropertySheetPageW[] = "CreatePropertySheetPageW";
static const char cszImageList_Draw[]          = "ImageList_Draw";
static const char cszImageList_Destroy[]       = "ImageList_Destroy";

// API table for CommonControl function addresses to fetch
#define NUM_CommCtrlAPI_PROCS  10 

APIFCN CommCtrlAPIList[NUM_CommCtrlAPI_PROCS] =
{
  { (PVOID *) &gpfnInitCommonControlsEx,     cszInitCommonControlsEx},
  { (PVOID *) &gpfnImageList_SetBkColor,     cszImageList_SetBkColor},
  { (PVOID *) &gpfnImageList_Draw,           cszImageList_Draw},
  { (PVOID *) &gpfnImageList_Destroy,        cszImageList_Destroy},
  { (PVOID *) &gpfnImageList_LoadImageA,     cszImageList_LoadImageA},
  { (PVOID *) &gpfnPropertySheetA,           cszPropertySheetA},
  { (PVOID *) &gpfnCreatePropertySheetPageA, cszCreatePropertySheetPageA},
  { (PVOID *) &gpfnImageList_LoadImageW,     cszImageList_LoadImageW},
  { (PVOID *) &gpfnPropertySheetW,           cszPropertySheetW},
  { (PVOID *) &gpfnCreatePropertySheetPageW, cszCreatePropertySheetPageW}
};


#ifdef COLSEL_MENU 
// for menu->column selection mapping
#define MAXNUM_MENUPROPS    12
const ULONG MenuToPropTagMap[] = {    
                                PR_HOME_TELEPHONE_NUMBER, 
                                PR_BUSINESS_TELEPHONE_NUMBER,
                                PR_PAGER_TELEPHONE_NUMBER,
                                PR_CELLULAR_TELEPHONE_NUMBER,
                                PR_BUSINESS_FAX_NUMBER,
                                PR_HOME_FAX_NUMBER,
                                PR_COMPANY_NAME,
                                PR_TITLE,
                                PR_DEPARTMENT_NAME,
                                PR_OFFICE_LOCATION,
                                PR_BIRTHDAY,
                                PR_WEDDING_ANNIVERSARY
                            };
#endif // COLSEL_MENU 

void CleanAddressString(TCHAR * szAddress);

static const LPTSTR g_szComDlg32 = TEXT("COMDLG32.DLL");

// Delay load substitutes for commdlg functions
//

BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAMEA pof);
BOOL (*pfnGetOpenFileNameW)(LPOPENFILENAMEW pof);

BOOL GetOpenFileName(LPOPENFILENAME pof)
{
//    static BOOL (*pfnGetOpenFileName)(LPOPENFILENAME pof);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {
       
        if ( pfnGetOpenFileNameA == NULL ) 
            pfnGetOpenFileNameA = (BOOL (*)(LPOPENFILENAMEA))GetProcAddress(ghCommDlgInst, "GetOpenFileNameA");
       
        if ( pfnGetOpenFileNameW == NULL ) 
            pfnGetOpenFileNameW = (BOOL (*)(LPOPENFILENAMEW))GetProcAddress(ghCommDlgInst, "GetOpenFileNameW");

        if (pfnGetOpenFileNameA && pfnGetOpenFileNameW)
            return pfnGetOpenFileName(pof);
    }
    return -1;
}

BOOL (*pfnGetSaveFileNameA)(LPOPENFILENAMEA pof);
BOOL (*pfnGetSaveFileNameW)(LPOPENFILENAMEW pof);

BOOL GetSaveFileName(LPOPENFILENAME pof)
{
//    static BOOL (*pfnGetSaveFileName)(LPOPENFILENAME pof);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {

          if ( pfnGetSaveFileNameA == NULL ) 
             pfnGetSaveFileNameA = (BOOL (*)(LPOPENFILENAMEA))GetProcAddress(ghCommDlgInst, "GetSaveFileNameA");

          if ( pfnGetSaveFileNameW == NULL )
             pfnGetSaveFileNameW = (BOOL (*)(LPOPENFILENAMEW))GetProcAddress(ghCommDlgInst, "GetSaveFileNameW");

          if ( pfnGetSaveFileNameA && pfnGetSaveFileNameW )
              return pfnGetSaveFileName(pof);
    }
    return -1;
}


BOOL (*pfnPrintDlgA)(LPPRINTDLGA lppd);
BOOL (*pfnPrintDlgW)(LPPRINTDLGW lppd);

BOOL PrintDlg(LPPRINTDLG lppd) 
{
//    static BOOL (*pfnPrintDlg)(LPPRINTDLG lppd);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {
        if ( pfnPrintDlgA == NULL ) 
          pfnPrintDlgA = (BOOL (*)(LPPRINTDLGA))GetProcAddress(ghCommDlgInst, "PrintDlgA");

        if ( pfnPrintDlgW == NULL )
          pfnPrintDlgW = (BOOL (*)(LPPRINTDLGW))GetProcAddress(ghCommDlgInst, "PrintDlgW");

        if ( pfnPrintDlgA && pfnPrintDlgW )
            return pfnPrintDlg(lppd);
    }
    return -1;
}

/*
- PrintDlgEx
-
- Loads the PrintDlgEx from the ComDlg32.dll
- If lppdex is NULL, then just loads and returns S_OK (this way we test for support for PrintDlgEx
- on the current system .. instead of trying to look at the OS version etc)
-
- Returns MAPI_E_NOT_FOUND if no support on OS
-
*/

HRESULT (*pfnPrintDlgExA)(LPPRINTDLGEXA lppdex);
HRESULT (*pfnPrintDlgExW)(LPPRINTDLGEXW lppdex);

HRESULT PrintDlgEx(LPPRINTDLGEX lppdex) 
{
//    static HRESULT (*pfnPrintDlgEx)(LPPRINTDLGEX lppdex);

    if(!ghCommDlgInst)
        ghCommDlgInst = LoadLibrary(g_szComDlg32);
    
    if(ghCommDlgInst)
    {
        if ( pfnPrintDlgExA == NULL ) 
           pfnPrintDlgExA = (HRESULT (*)(LPPRINTDLGEXA))GetProcAddress(ghCommDlgInst, "PrintDlgExA");

        if ( pfnPrintDlgExW == NULL )
           pfnPrintDlgExW = (HRESULT (*)(LPPRINTDLGEXW))GetProcAddress(ghCommDlgInst, "PrintDlgExW");

        if (!pfnPrintDlgExA || !pfnPrintDlgExW)
        {
            DebugTrace( TEXT("PrintDlgEx not found - %d\n"),GetLastError());
            return MAPI_E_NOT_FOUND;
        }
        if(!lppdex)
            return S_OK; //just testing for presence of this function

        return pfnPrintDlgEx(lppdex);
    }
    return E_FAIL;
}

extern void DeinitCommDlgLib()
{
    if(ghCommDlgInst)
    {
        FreeLibrary(ghCommDlgInst);
        ghCommDlgInst = NULL;
    }
}



//$$
//
// HandleSaveChangedInsufficientDiskSpace - Called when savechanges returns
//      insufficient disk space. If user selects to proceed
//
//
HRESULT HandleSaveChangedInsufficientDiskSpace(HWND hWnd, LPMAILUSER lpMailUser)
{
    HRESULT hr = MAPI_E_NOT_ENOUGH_DISK;

    while(hr == MAPI_E_NOT_ENOUGH_DISK)
    {
        if(IDOK == ShowMessageBox(  hWnd,
                                    idsNotEnoughDiskSpace,
                                    MB_OKCANCEL | MB_ICONEXCLAMATION))
        {
            // try saving again
            hr = lpMailUser->lpVtbl->SaveChanges( lpMailUser,
                                                  KEEP_OPEN_READWRITE);
        }
        else
            hr = MAPI_E_USER_CANCEL;
    }

    return hr;
}


//$$////////////////////////////////////////////////////////////////
//
//  SetRecipColumns - sets the columns we want to populate the 
//  RECIPIENTINFO item structures with
//
//////////////////////////////////////////////////////////////////
#define RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES 7   // Keep this in sync with ptaRecipArray below

HRESULT SetRecipColumns(LPMAPITABLE lpContentsTable)
{
    HRESULT hr = S_OK;
    SizedSPropTagArray(16, ptaRecipArray) =
    {   
        16, 
        {
		    PR_DISPLAY_NAME,
            PR_SURNAME,
            PR_GIVEN_NAME,
            PR_MIDDLE_NAME,
            PR_COMPANY_NAME,
            PR_NICKNAME,
		    PR_EMAIL_ADDRESS,
            PR_CONTACT_EMAIL_ADDRESSES, // [PaulHi] Use for PR_EMAIL_ADDRESS if no PR_EMAIL_ADDRESS exists
		    PR_ENTRYID,
		    PR_OBJECT_TYPE,
            PR_USER_X509_CERTIFICATE,
		    PR_HOME_TELEPHONE_NUMBER,
		    PR_OFFICE_TELEPHONE_NUMBER,
            PR_WAB_THISISME,
            PR_WAB_YOMI_FIRSTNAME, //keep these ruby props at the end of the list
            PR_WAB_YOMI_LASTNAME,
        }
    };

    if(PR_WAB_CUSTOMPROP1)
        ptaRecipArray.aulPropTag[11]  = PR_WAB_CUSTOMPROP1;
    if(PR_WAB_CUSTOMPROP2)
        ptaRecipArray.aulPropTag[12]  = PR_WAB_CUSTOMPROP2;

    if(!bIsRubyLocale()) // Don't ask for Ruby Props if we don't need em
        ptaRecipArray.cValues -= 2;

    hr =lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                                            (LPSPropTagArray)&ptaRecipArray, 0);

    return hr;
}

//$$////////////////////////////////////////////////////////////////
//
//  GetABContentsList Gets a contents list
//
//		hPropertyStore	handle to property store - this can be null for
//						non-property store containers
//		cbContEntryID	entryid of container
//		lpContEntryID	cont entry id
//		lpPTA,			Array of prop tags to fill in the list view
//						Can be null - in which case default array will be used
//		lpPropRes		Filter which caller can supply - if null  TEXT("DisplayName") is the default
//		ulFlags			Used with Filter - either 0 or AB_MATCH_PROP_ONLY
//      bGetProfileContents - If TRUE and profiles, gets full list of profile contents - if false 
//                      IF FALSE, checks if profiles are ON and gets container contents..
//		lppContentsList Returned Contents list pointing off to entries
//
//////////////////////////////////////////////////////////////////
HRESULT HrGetWABContentsList(   LPIAB lpIAB,
                                SORT_INFO SortInfo,
								LPSPropTagArray  lpPTA,
								LPSPropertyRestriction lpPropRes,
								ULONG ulFlags,
                                LPSBinary lpsbContainer,
                                BOOL bGetProfileContents,
                                LPRECIPIENT_INFO * lppContentsList)
{
    HRESULT hr = hrSuccess;
    ULONG i = 0,j=0;
    LPRECIPIENT_INFO lpItem = NULL;
    LPRECIPIENT_INFO lpLastListItem = NULL;
    HANDLE hPropertyStore = lpIAB->lpPropertyStore->hPropertyStore;
    SPropertyRestriction PropRes = {0};
    ULONG ulContentsTableFlags = MAPI_UNICODE | WAB_CONTENTTABLE_NODATA;
    ULONG ulcPropCount = 0;
    LPULONG lpPropTagArray = NULL;
    LPCONTENTLIST lpContentList = NULL;


/****/
    LPCONTAINER lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
	ULONG cbContainerEID = 0;
	LPENTRYID lpContainerEID = NULL;
    ULONG ulObjectType = 0;

    if(lpsbContainer)
    {	
        cbContainerEID = lpsbContainer->cb;
	    lpContainerEID = (LPENTRYID)lpsbContainer->lpb;
    }

    if(!cbContainerEID || !lpContainerEID)
    {
        // When calling GetPAB, this will normally return the users contact folder
        // In this case (where we havent been asked to get all the profile contents,
        // this implies that without container info, we should get the virtual 
        // folder contents
        if(!bGetProfileContents)
            SetVirtualPABEID((LPIAB)lpIAB, &cbContainerEID, &lpContainerEID);
	    hr = lpIAB->lpVtbl->GetPAB(lpIAB, &cbContainerEID, &lpContainerEID);
	    if(HR_FAILED(hr))
		    goto out;
    }

    //
    // First we need to open the container object corresponding to this Container EntryID
    //
    hr = lpIAB->lpVtbl->OpenEntry(
                            lpIAB,
                            cbContainerEID, 	
                            lpContainerEID, 	
                            NULL, 	
                            0, 	
                            &ulObjectType, 	
                            (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }

    if(bIsWABSessionProfileAware(lpIAB))
    {
        ulContentsTableFlags |= WAB_ENABLE_PROFILES;
        if(bGetProfileContents)
            ulContentsTableFlags |= WAB_PROFILE_CONTENTS;
    }

    //
    // Now we do a get contents table on this container ...
    //
    hr = lpContainer->lpVtbl->GetContentsTable(
                            lpContainer,
                            ulContentsTableFlags,
                            &lpContentsTable);
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

    // the default set of columns does not have all the information we are seeking
    // so we do a set columns
    hr = SetRecipColumns(lpContentsTable);
    if(HR_FAILED(hr))
        goto out;

    if(lpPropRes)
    {
        SRestriction sr = {0};
        sr.rt = RES_PROPERTY;
        sr.res.resProperty = *lpPropRes;
        if(HR_FAILED(hr = lpContentsTable->lpVtbl->Restrict(lpContentsTable,&sr,0)))
            goto out;
    }

    hr = HrQueryAllRows(lpContentsTable, NULL, NULL, NULL, 0, &lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    //
	// if there's anything in the contents list flush it away
	//
    if (*lppContentsList)
    {
        lpItem = (*lppContentsList);
        (*lppContentsList) = lpItem->lpNext;
        FreeRecipItem(&lpItem);
    }
    *lppContentsList = NULL;
    lpItem = NULL;


    for(i=0;i<lpSRowSet->cRows;i++)
    {
        LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;
        ULONG ulcPropCount = lpSRowSet->aRow[i].cValues;

        lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		if (!lpItem)
		{
			DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			hr = MAPI_E_NOT_ENOUGH_MEMORY;
			goto out;
		}

		GetRecipItemFromPropArray(ulcPropCount, lpPropArray, &lpItem);

		// The critical prop is display name - without it we are nothing ...
		// If no display name, junk this entry and continue ..

		if (!lstrlen(lpItem->szDisplayName) || (lpItem->cbEntryID == 0)) //This entry id is not allowed
		{
			FreeRecipItem(&lpItem);				
			continue;
		}

        // The entryids are in sorted order by display name
        // Depending on the sort order - we want this list to also be sorted by display
        // name or by reverse display name ...

        if (SortInfo.bSortByLastName)
            StrCpyN(lpItem->szDisplayName,lpItem->szByLastName,ARRAYSIZE(lpItem->szDisplayName));

        if(!SortInfo.bSortAscending)
        {
            //Add it to the contents linked list
            lpItem->lpNext = (*lppContentsList);
            if (*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            lpItem->lpPrev = NULL;
            *lppContentsList = lpItem;
        }
        else
        {
            if(*lppContentsList == NULL)
                (*lppContentsList) = lpItem;

            if(lpLastListItem)
                lpLastListItem->lpNext = lpItem;

            lpItem->lpPrev = lpLastListItem;
            lpItem->lpNext = NULL;

            lpLastListItem = lpItem;
        }

        lpItem = NULL;

    } //for i ....
/*****/

out:
/****/
    if(lpSRowSet)
        FreeProws(lpSRowSet);

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);

    if( (!lpsbContainer || !lpsbContainer->lpb) && lpContainerEID)
		MAPIFreeBuffer(lpContainerEID);
/****/

	if (lpContentList)
		FreePcontentlist(hPropertyStore, lpContentList);

	if (HR_FAILED(hr))
	{
		while(*lppContentsList)
		{
			lpItem = *lppContentsList;
			*lppContentsList=lpItem->lpNext;
			FreeRecipItem(&lpItem);
		}
	}
    return hr;
}


//$$////////////////////////////////////////////////////////////////
//
//  FreeRecipItem - frees a RECIPIENT_INFO structure
//
//  lppItem - pointer to the lpItem to free. It is set to NULL
//
//////////////////////////////////////////////////////////////////
void FreeRecipItem(LPRECIPIENT_INFO * lppItem)
{

    LocalFreeAndNull(&(*lppItem)->lpEntryID);
    LocalFreeAndNull(&(*lppItem)->lpByRubyFirstName);
    LocalFreeAndNull(&(*lppItem)->lpByRubyLastName);
	LocalFreeAndNull((lppItem));
	return;
}




//$$////////////////////////////////////////////////////////////////
//
//  InitListView - initializes a list view with style, columns,
//					image lists, headers etc
//
//
//	HWND hWndLV - Handle of ListView Control
//  dwStyle - style for list view
//	bShowHeaders - Show or hide the headers
//
//////////////////////////////////////////////////////////////////
HRESULT HrInitListView(	HWND hWndLV,
						DWORD dwStyle,
						BOOL bShowHeaders)
{
	HRESULT hr = hrSuccess;
    LV_COLUMN lvC;               // list view column structure
    TCHAR szText [MAX_PATH];      // place to store some text
	RECT rc;
	HIMAGELIST hSmall=NULL,hLarge=NULL;
    HFONT hFnt = GetStockObject(DEFAULT_GUI_FONT);

	DWORD dwLVStyle;
	ULONG nCols=0;
	ULONG index=0;

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    SendMessage(hWndLV, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

    ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(( dwLVStyle & LVS_TYPEMASK) != dwStyle)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_TYPEMASK) | dwStyle);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(( dwLVStyle & LVS_EDITLABELS) != dwStyle)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_EDITLABELS) | dwStyle);

    hSmall = gpfnImageList_LoadImage(   hinstMapiX, 	
                                    MAKEINTRESOURCE(IDB_BITMAP_SMALL),
                                    //(LPCTSTR) ((DWORD) ((WORD) (IDB_BITMAP_SMALL))),
                                    S_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);

    hLarge = gpfnImageList_LoadImage(  hinstMapiX,
                                    MAKEINTRESOURCE(IDB_BITMAP_LARGE),
                                    //(LPCTSTR) ((DWORD) ((WORD) (IDB_BITMAP_LARGE))),
                                    L_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);


	// Associate the image lists with the list view control.
	ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);
	ListView_SetImageList (hWndLV, hLarge, LVSIL_NORMAL);


	// <TBD> make the columns all the same width
	// Later on in life we will make it so users preferences are stored and then
	// played back ...

	
	nCols = NUM_COLUMNS;
	
	if (nCols==0)
	{
		DebugPrintError(( TEXT("Zero number of cols??\n")));
		hr = E_FAIL;
		goto out;
	}

	GetWindowRect(hWndLV,&rc);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column

	if (bShowHeaders)
	{
		lvC.mask |=	 LVCF_TEXT | LVCF_SUBITEM;
//		lvC.cx = (rc.right-rc.left)/nCols; // width of column in pixels
//		if (lvC.cx == 0)
			lvC.cx = 150; // <TBD> fix these limits somewhere ...
		lvC.pszText = szText;
	}
	else
	{
		// if no headers, we want these to be wide enough to fit all the info
		lvC.cx = 250; //<TBD> - change this hardcoding
		lvC.pszText = NULL;
	}

	// Add the columns.
    for (index = 0; index < nCols; index++)
    {
       lvC.iSubItem = index;
       LoadString (hinstMapiX, lprgAddrBookColHeaderIDs[index], szText, ARRAYSIZE(szText));
       if(index == colHomePhone && PR_WAB_CUSTOMPROP1 && lstrlen(szCustomProp1))
           StrCpyN(szText, szCustomProp1,ARRAYSIZE(szText));
       if(index == colOfficePhone && PR_WAB_CUSTOMPROP2 && lstrlen(szCustomProp2))
           StrCpyN(szText, szCustomProp2,ARRAYSIZE(szText));
       if((index == colDisplayName) || (index == colEmailAddress))
           lvC.cx = 150;
       else
           lvC.cx = 100;
       if (ListView_InsertColumn (hWndLV, index, &lvC) == -1)
		{
			DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
			hr = E_FAIL;
			goto out;
		}
    }


out:	

	return hr;
}


//$$////////////////////////////////////////////////////////////////
///
/// HrFillListView - fills a list view from an lpcontentslist
///
/// hWndLV - Handle of List View control to fill
/// lpContentsList - LPRECIPIENT_INFO linked list. We walk the list and
///                 add each item to the list view
///
//////////////////////////////////////////////////////////////////
HRESULT HrFillListView(	HWND hWndLV,
						LPRECIPIENT_INFO lpContentsList)
{
	LPRECIPIENT_INFO lpItem = lpContentsList;
    LV_ITEM lvI = {0};
    int index = 0;

	if ((!hWndLV) || (!lpContentsList))
		return MAPI_E_INVALID_PARAMETER;

    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM ;
	lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;
    lvI.iItem = 0;
    while(lpItem)
	{
        lvI.iImage = GetWABIconImage(lpItem);

	    lvI.iSubItem = colDisplayName;
	    lvI.lParam = (LPARAM) lpItem;
	    lvI.pszText = lpItem->szDisplayName;

        index = ListView_InsertItem (hWndLV, &lvI);
        if (index != -1)
	    {
            if(lstrlen(lpItem->szOfficePhone))
    	        ListView_SetItemText (hWndLV, index, colOfficePhone, lpItem->szOfficePhone);
            if(lstrlen(lpItem->szHomePhone))
    	        ListView_SetItemText (hWndLV, index, colHomePhone, lpItem->szHomePhone);
            if(lstrlen(lpItem->szEmailAddress))
                ListView_SetItemText (hWndLV, index, colEmailAddress, lpItem->szEmailAddress);
        }
		lpItem = lpItem->lpNext;
        lvI.iItem++;
	}

    LVSelectItem(hWndLV, 0);

	return S_OK;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  TrimSpaces - strips a string of leading and trailing blanks
//
//  szBuf - pointer to buffer containing the string we want to strip spaces off.
//
////////////////////////////////////////////////////////////////////////////////
BOOL TrimSpaces(TCHAR * szBuf)
{
    register LPTSTR lpTemp = szBuf;

    if(!szBuf || !lstrlen(szBuf))
        return FALSE;

    // Trim leading spaces
    while (IsSpace(lpTemp)) {
        lpTemp = CharNext(lpTemp);
    }

    if (lpTemp != szBuf) {
        // Leading spaces to trim
        StrCpyN(szBuf, lpTemp, lstrlen(lpTemp)+1);
        lpTemp = szBuf;
    }

    if (*lpTemp == '\0') {
        // empty string
        return(TRUE);
    }

    // Move to the end
    lpTemp += lstrlen(lpTemp);
    lpTemp--;

    // Walk backwards, triming spaces
    while (IsSpace(lpTemp) && lpTemp > szBuf) {
        *lpTemp = '\0';
        lpTemp = CharPrev(szBuf, lpTemp);
    }

    return(TRUE);
}


//$$/****************************************************************************
/*
*    FUNCTION: ListViewSort(LPARAM, LPARAM, LPARAM)
*
*    PURPOSE: Callback function that sorts depending on the column click
*
*    lParam1, lParam2 - lParam of the elements being compared
*    lParamSort - User defined data that identifies the sort criteria
*
****************************************************************************/
int CALLBACK ListViewSort(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	LPRECIPIENT_INFO lp1 = (LPRECIPIENT_INFO)lParam1;
	LPRECIPIENT_INFO lp2 = (LPRECIPIENT_INFO)lParam2;
	LPTSTR lpStr1, lpStr2, lpF1, lpL1, lpF2, lpL2;
    
    int iResult = 0;
	LPSORT_INFO lpSortInfo = (LPSORT_INFO) lParamSort;

	if (lp1 && lp2)
	{
		switch( lpSortInfo->iOldSortCol)
		{
			case colDisplayName:     // sort by Address
                lpF1 = lp1->lpByRubyFirstName ? lp1->lpByRubyFirstName : lp1->szByFirstName;
                lpL1 = lp1->lpByRubyLastName ? lp1->lpByRubyLastName : lp1->szByLastName;
                lpF2 = lp2->lpByRubyFirstName ? lp2->lpByRubyFirstName : lp2->szByFirstName;
                lpL2 = lp2->lpByRubyLastName ? lp2->lpByRubyLastName : lp2->szByLastName;
                lpStr1 = lpSortInfo->bSortByLastName ? lpL1 : lpF1;
                lpStr2 = lpSortInfo->bSortByLastName ? lpL2 : lpF2;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            case colEmailAddress:     // sort by Address
				lpStr1 = lp1->szEmailAddress;
				lpStr2 = lp2->szEmailAddress;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            case colHomePhone:     // sort by Address
				lpStr1 = lp1->szHomePhone;
				lpStr2 = lp2->szHomePhone;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            case colOfficePhone:     // sort by Address
				lpStr1 = lp1->szOfficePhone;
				lpStr2 = lp2->szOfficePhone;
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;

            default:
				iResult = 0;
				break;
        }
    }

    return(lpSortInfo->bSortAscending ? iResult : -1*iResult);
}




//$$****************************************************************************
/*
*    SetColumnHeaderBmp
*
*    PURPOSE: Sets the bmp on the ListView Column header to indicate sorting
*
*   hWndLV - handle of List View
*   SortInfo - The current Sort Information structure. It is used to determine
*               where to put the sort header bitmap
****************************************************************************/
void SetColumnHeaderBmp(HWND hWndLV, SORT_INFO SortInfo)
{

	LV_COLUMN lvc = {0};
    HIMAGELIST hHeader = NULL;
    HWND hWndLVHeader = NULL;

    //POINT pt;
    // we will try to get the hWnd for the ListView header and set its image lists
    //pt.x = 1;
    //pt.y = 1;
    //hWndLVHeader = ChildWindowFromPoint (hWndLV, pt);

    hWndLVHeader = ListView_GetHeader(hWndLV);
   // NULL hChildWnd means R-CLICKED outside the listview.
   // hChildWnd == ghwndLV means listview got clicked: NOT the
   // header.
   if ((hWndLVHeader) /*&& (hWndLVHeader != hWndLV)*/)
   {
       hHeader = (HIMAGELIST) SendMessage(hWndLVHeader,HDM_GETIMAGELIST,0,0);

       gpfnImageList_SetBkColor(hHeader, GetSysColor(COLOR_BTNFACE));

       SendMessage(hWndLVHeader, HDM_SETIMAGELIST, 0, (LPARAM) hHeader);

   }

	if (SortInfo.iOlderSortCol != SortInfo.iOldSortCol)
	{
		//Get rid of image from old column
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
        ListView_SetColumn(hWndLV, SortInfo.iOlderSortCol, &lvc);
	}


    // Set new column icon.
    lvc.mask = LVCF_IMAGE | LVCF_FMT;
    lvc.fmt = LVCFMT_IMAGE | LVCFMT_BITMAP_ON_RIGHT;
    lvc.iImage = SortInfo.bSortAscending ? imageSortAscending : imageSortDescending;

	ListView_SetColumn(hWndLV, SortInfo.iOldSortCol, &lvc);
	
	return;
}


//$$//////////////////////////////////////////////////////////////////////////
///
/// ClearListView - Clears all the list view items and associated contents list
///
///     hWndLV - list view to clear out
///     lppContentsList - contents list correponding to the contents in the
///                         list view
///
///////////////////////////////////////////////////////////////////////////////
void ClearListView(HWND hWndLV, LPRECIPIENT_INFO * lppContentsList)
{
    /*
	LPRECIPIENT_INFO lpItem = *lppContentsList;
    int i =0;
    int iItemIndex = ListView_GetItemCount(hWndLV);

    //OutputDebugString( TEXT("ClearListView entry\n"));

    if (iItemIndex <=0 )
        goto out;

    for(i=0;i<iItemIndex;i++)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, i);

        if (lpItem)
        {
            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;

            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;

            if (*lppContentsList == lpItem)
                *lppContentsList = lpItem->lpNext;

            if (lpItem)
                FreeRecipItem(&lpItem);
        }
    }

    ListView_DeleteAllItems(hWndLV);

    *lppContentsList = NULL;

out:
    //OutputDebugString( TEXT("ClearListView exit\n"));
    */
    ListView_DeleteAllItems(hWndLV);
    FreeRecipList(lppContentsList);
    return;
};


//$$//////////////////////////////////////////////////////////////////////
//
// DeleteSelectedItems - Delete all the selected items from the List View
//
//  hWndLV -handle of List View
//  lpIAB - handle to current AdrBook object - used for certificate stuff
//  hPropertyStore - Handle of PropertyStore - <TBD> change this function to
//                   call deleteEntries instead of delete record.
//  lpftLast - WAB file time at last update
//
//////////////////////////////////////////////////////////////////////////
void DeleteSelectedItems(HWND hWndLV, LPADRBOOK lpAdrBook, HANDLE hPropertyStore, LPFILETIME lpftLast)
{
	int iItemIndex;
	int nSelected;
	LV_ITEM LVItem;
	HWND hDlg = GetParent(hWndLV);
	HRESULT hr = hrSuccess;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpWABCont = NULL;
    ULONG ulObjType,i=0;
    SBinaryArray SBA = {0};
    
	nSelected = ListView_GetSelectedCount(hWndLV);

	if (nSelected <= 0)
    {
        ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEMS_DELETE, MB_ICONEXCLAMATION);
		hr = E_FAIL;
        goto out;
    }

    hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbWABEID, &lpWABEID);
    if(HR_FAILED(hr))
        goto out;

    hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont);

    if(HR_FAILED(hr))
        goto out;

    if (IDYES == ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_DELETE, MB_ICONEXCLAMATION | MB_YESNO))
    {
        int iLastDeletedItemIndex;
        BOOL bDeletedItem = FALSE;
		DWORD dwLVStyle = 0;
		BOOL bWasShowSelAlwaysStyle = FALSE;
        HCURSOR hOldCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
        ULONG ulCount = 0;

        SendMessage(hWndLV, WM_SETREDRAW, FALSE, 0);

		// The list view may be set to ShowSelAlways style -
		// When deleting, we normally look for the selected entries and
		// delete them - but with this style, the list view automatically selects the
		// next entry - which is problematic because then we end up deleting that
		// one also ... so we need to unset the style now and set it later
		
		dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
		
		if( dwLVStyle & LVS_SHOWSELALWAYS)
		{
			SetWindowLong(hWndLV,GWL_STYLE,dwLVStyle & ~LVS_SHOWSELALWAYS);
			bWasShowSelAlwaysStyle = TRUE;
		}

        if(!(SBA.lpbin = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary)*nSelected)))
            goto out;

        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
        do
        {
			// otherwise get the entry id of this thing
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
            if (lpItem)
            {
                SetSBinary(&(SBA.lpbin[ulCount]), lpItem->cbEntryID, (LPBYTE)lpItem->lpEntryID);
                ulCount++;
            }
            iLastDeletedItemIndex = iItemIndex;
            iItemIndex = ListView_GetNextItem(hWndLV,iItemIndex,LVNI_SELECTED);
        }
        while (iItemIndex != -1);

        SBA.cValues = ulCount;

        hr = lpWABCont->lpVtbl->DeleteEntries( lpWABCont, (LPENTRYLIST) &SBA, 0);

        // Ideally DeleteEntries will skip over errors silently so we have a dilemma here
        // that if there are errors,do we knock out the corresponding items out of the UI or not ..
        // For now, lets knock them out of the UI .. when the UI refreshes, this will sort itself out ..
        //
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
        do
        {
            ListView_DeleteItem(hWndLV,iItemIndex);
            iLastDeletedItemIndex = iItemIndex;
            iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
        }
        while (iItemIndex != -1);
		bDeletedItem = TRUE;

/*  33751 - need to fail silently here ..
        else
        {
            ShowMessageBoxParam(hDlg, IDS_ADDRBK_MESSAGE_DELETING_ERROR, MB_ICONERROR, lpItem->szDisplayName);
            iLastDeletedItemIndex = iItemIndex;
			break;
		}
*/

		// reset the style if we changed it
		if(bWasShowSelAlwaysStyle )
			SetWindowLong(hWndLV,GWL_STYLE,dwLVStyle);
		
        SetCursor(hOldCur);

        // select the previous or next item ...
        if (iLastDeletedItemIndex >= ListView_GetItemCount(hWndLV))
            iLastDeletedItemIndex = ListView_GetItemCount(hWndLV)-1;
		LVSelectItem(hWndLV, iLastDeletedItemIndex);

	}

out:
    SendMessage(hWndLV, WM_SETREDRAW, TRUE, 0);

    if(SBA.lpbin && SBA.cValues)
    {
        for(i=0;i<SBA.cValues;i++)
            LocalFreeAndNull((LPVOID *) (&(SBA.lpbin[i].lpb)));
        LocalFreeAndNull(&SBA.lpbin);
    }

    if(lpWABCont)
        UlRelease(lpWABCont);

    if(lpWABEID)
        FreeBufferAndNull(&lpWABEID);

    return;
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[261];    // Big enough?  Strings better be smaller than 260!

    ulSize = LoadString(hinstMapiX, StringID, szBuffer, ARRAYSIZE(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, sizeof(TCHAR)*(ulSize + 1)))) {
        StrCpyN(lpBuffer, szBuffer, ulSize+1);
    }

    return(lpBuffer);
}


#ifdef VCARD


/***************************************************************************

    Name      : FormatAllocFilter

    Purpose   : Loads file filter name string resources and
                formats them with their file extension filters

    Parameters: StringID1 - String identifier to load       (required)
                szFilter1 - file name filter, ie,  TEXT("*.vcf")   (required)
                StringID2 - String identifier               (optional)
                szFilter2 - file name filter                (optional)
                StringID3 - String identifier               (optional)
                szFilter3 - file name filter                (optional)

    Returns   : LocalAlloc'd, Double null terminated string.  Caller is
                responsible for LocalFree'ing this buffer.  If the string
                can't be loaded or memory can't be allocated, returns NULL.

***************************************************************************/
LPTSTR FormatAllocFilter(int StringID1, LPCTSTR lpFilter1,
  int StringID2, LPCTSTR lpFilter2,
  int StringID3, LPCTSTR lpFilter3) {
    LPTSTR lpFileType1 = NULL, lpFileType2 = NULL, lpFileType3 = NULL;
    LPTSTR lpTemp = NULL;
    LPTSTR lpBuffer = NULL;
    // All string sizes include null
    ULONG cchFileType1 = 0, cchFileType2 = 0, cchFileType3 = 0;
    ULONG cchFilter1 = 0, cchFilter2 = 0, cchFilter3 = 0;
    ULONG cchBuffer, cchTemp = 0;

    cchBuffer = cchFilter1 = (lstrlen(lpFilter1) + 1);
    if (! (lpFileType1 = LoadAllocString(StringID1))) {
        DebugTrace( TEXT("LoadAllocString(%u) failed\n"), StringID1);
        return(NULL);
    }
    cchBuffer += (cchFileType1 = (lstrlen(lpFileType1) + 1));
    if (lpFilter2 && StringID2) {
        cchBuffer += (cchFilter2 = (lstrlen(lpFilter2) + 1));
        if (! (lpFileType2 = LoadAllocString(StringID2))) {
            DebugTrace( TEXT("LoadAllocString(%u) failed\n"), StringID2);
        } else {
            cchBuffer += (cchFileType2 = (lstrlen(lpFileType2) + 1));
        }
    }
    if (lpFilter3 && StringID3) {
        cchBuffer += (cchFilter3 = (lstrlen(lpFilter3) + 1));
        if (! (lpFileType3 = LoadAllocString(StringID3))) {
            DebugTrace( TEXT("LoadAllocString(%u) failed\n"), StringID3);
        } else {
            cchBuffer += (cchFileType3 = (lstrlen(lpFileType3) + 1));
        }
    }
    cchBuffer += 1; //terminating null

    Assert(cchBuffer == cchFilter1 + cchFilter2 + cchFilter3 + cchFileType1 + cchFileType2 + cchFileType3 + 1);

    if (lpBuffer = LocalAlloc(LPTR, sizeof(lpBuffer[0])*cchBuffer)) {
        lpTemp = lpBuffer;
        cchTemp = cchBuffer;

        Assert(cchTemp >= cchFileType1);
        if (cchTemp >= cchFileType1)
        {
            StrCpyN(lpTemp, lpFileType1, cchFileType1);
            lpTemp += cchFileType1;
            cchTemp -= cchFileType1;

            Assert(cchTemp >= cchFilter1);
            if (cchTemp >= cchFilter1)
            {
                StrCpyN(lpTemp, lpFilter1, cchFilter1);
                lpTemp += cchFilter1;
                cchTemp -= cchFilter1;
                
                LocalFree(lpFileType1);

                if (cchFileType2 && cchFilter2)
                {
                    Assert(cchTemp >= (cchFileType2 + cchFilter2));
                    if (cchTemp >= (cchFileType2 + cchFilter2))
                    {
                        StrCpyN(lpTemp, lpFileType2, cchFileType2);
                        lpTemp += cchFileType2;
                        cchTemp -= cchFileType2;

                        StrCpyN(lpTemp, lpFilter2, cchFilter2);
                        lpTemp += cchFilter2;
                        cchTemp -= cchFilter2;
                
                        LocalFree(lpFileType2);
                    }
                }
                    
                
                if (cchFileType3 && cchFilter3)
                {
                    Assert(cchTemp >= (cchFileType3 + cchFilter3));
                    if (cchTemp >= (cchFileType3 + cchFilter3))
                    {
                        StrCpyN(lpTemp, lpFileType3, cchFileType3);
                        lpTemp += cchFileType3;
                        cchTemp -= cchFileType3;

                        StrCpyN(lpTemp, lpFilter3, cchFilter3);
                        lpTemp += cchFilter3;
                        cchTemp -= cchFilter3;
                
                        LocalFree(lpFileType3);
                    }
                }
            }
        }
    }

    if (lpTemp)
    {
        if ((cchTemp >0) && (cchTemp < cchBuffer))  // ensure we have room and didn't wrap
            *lpTemp = '\0';
        else
        {
            Assert(FALSE);
            LocalFree(lpBuffer);
            lpBuffer = NULL;
        }
    }


    return(lpBuffer);
}


const LPTSTR szVCardFilter =  TEXT("*.vcf");

/***************************************************************************

    Name      : VCardCreate

    Purpose   : Creates a vCard file from the given Mailuser and filename

    Parameters: hwnd = hwndParent
                lpIAB -> IAddrBook object,
                ulFlags can be 0 or MAPI_DIALOG - MAPI_DIALOG means report
                    error messages in a dialog box, else
                    work silently ..
                lpszFileNAme - vCard file name to create
                lpMailUser - object to create vCard file from

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT VCardCreate(  LPADRBOOK lpAdrBook,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPMAILUSER lpMailUser)
{
    HRESULT hr = E_FAIL;
    HANDLE hVCard = NULL;

    if (INVALID_HANDLE_VALUE == (hVCard = CreateFile( lpszFileName,
                                                      GENERIC_WRITE,	
                                                      0,    // sharing
                                                      NULL,
                                                      CREATE_ALWAYS,
                                                      FILE_FLAG_SEQUENTIAL_SCAN,	
                                                      NULL)))
    {
        if(ulFlags & MAPI_DIALOG)
        {
            ShowMessageBoxParam(hWndParent,
                                IDE_VCARD_EXPORT_FILE_ERROR,
                                MB_ICONERROR,
                                lpszFileName);
        }

        goto out;
    }

    if (hr = WriteVCard(hVCard, FileWriteFn, lpMailUser))
    {
        switch (GetScode(hr))
        {
            case WAB_E_VCARD_NOT_ASCII:
                if(ulFlags & MAPI_DIALOG)
                {
                    ShowMessageBoxParam(hWndParent,
                                        IDS_VCARD_EXPORT_NOT_ASCII,
                                        MB_ICONEXCLAMATION,
                                        lpszFileName);
                }
                CloseHandle(hVCard);
                hVCard = NULL;
                DeleteFile(lpszFileName);
                hr = E_FAIL;
                break;

            default:
                if(ulFlags & MAPI_DIALOG)
                {
                    ShowMessageBoxParam(hWndParent,
                                        IDE_VCARD_EXPORT_FILE_ERROR,
                                        MB_ICONERROR,
                                        lpszFileName);
                }
                break;
        }
    }

out:

    if (hVCard)
        CloseHandle(hVCard);

    return hr;

}

//$$//////////////////////////////////////////////////////////////////////
//
//  VCardExportSelectedItems - Export all the selected items from the List View
//                             to vCard files.
//
//  hWndLV - handle of List view. We look up the selected item in this list
//              view, get its lParam structure, then get its EntryID and
//              call details
//  lpIAB - handle to current AdrBook object - used for calling details
//
//////////////////////////////////////////////////////////////////////////
HRESULT VCardExportSelectedItems(HWND hWndLV, LPADRBOOK lpAdrBook)
{
    HRESULT hr = E_FAIL;
    int iItemIndex;
    HWND hWndParent = GetParent(hWndLV);
    HANDLE hVCard = NULL;
    OPENFILENAME ofn;
    LPMAILUSER lpEntry = NULL;
    LPTSTR lpFilter = NULL;
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");
    LPTSTR lpTitle = NULL;
    LPTSTR lpTitleFormat = NULL;
    ULONG ulObjType;
    LPTSTR lpszArg[1];
    TCHAR szTmp[MAX_PATH];

    // Open props if only 1 item is selected
    iItemIndex = ListView_GetSelectedCount(hWndLV);
    if (iItemIndex == 1)
    {
        // Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);

        if (iItemIndex != -1)
        {
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;
            if(lpItem && lpItem->cbEntryID != 0)
            {
                StrCpyN(szFileName, lpItem->szDisplayName, ARRAYSIZE(szFileName));

                TrimIllegalFileChars(szFileName);

                if(lstrlen(szFileName))
                    StrCatBuff(szFileName, TEXT(".vcf"), ARRAYSIZE(szFileName));


                if (hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                  lpItem->cbEntryID,
                                                  lpItem->lpEntryID,
                                                  NULL,         // interface
                                                  0,            // flags
                                                  &ulObjType,
                                                  (LPUNKNOWN *)&lpEntry))
                {
                    DebugTraceResult( TEXT("VCardExportSelectedItems:OpenEntry"), hr);
                    goto exit;
                }
                if (ulObjType == MAPI_DISTLIST)
                {
                    ShowMessageBox(hWndParent, IDE_VCARD_EXPORT_DISTLIST, MB_ICONEXCLAMATION);
                    goto exit;
                }

                lpFilter = FormatAllocFilter(IDS_VCARD_FILE_SPEC, szVCardFilter, 0, NULL, 0, NULL);
                lpTitleFormat = LoadAllocString(IDS_VCARD_EXPORT_TITLE);

                // Win9x bug FormatMessage cannot have more than 1023 chars
                CopyTruncate(szTmp, lpItem->szDisplayName, MAX_PATH - 1);

                lpszArg[0] = szTmp;

                if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      lpTitleFormat,
                                      0,                    // stringid
                                      0,                    // dwLanguageId
                                      (LPTSTR)&lpTitle,     // output buffer
                                      0,                    //MAX_UI_STR
                                      (va_list *)lpszArg))
                {
                    DebugTrace( TEXT("FormatMessage -> %u\n"), GetLastError());
                }

                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner = hWndParent;
                ofn.hInstance = hinstMapiX;
                ofn.lpstrFilter = lpFilter;
                ofn.lpstrCustomFilter = NULL;
                ofn.nMaxCustFilter = 0;
                ofn.nFilterIndex = 0;
                ofn.lpstrFile = szFileName;
                ofn.nMaxFile = ARRAYSIZE(szFileName);
                ofn.lpstrFileTitle = NULL;
                ofn.nMaxFileTitle = 0;
                ofn.lpstrInitialDir = NULL;
                ofn.lpstrTitle = lpTitle;
                ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
                ofn.nFileOffset = 0;
                ofn.nFileExtension = 0;
                ofn.lpstrDefExt =  TEXT("vcf");
                ofn.lCustData = 0;
                ofn.lpfnHook = NULL;
                ofn.lpTemplateName = NULL;

                if (GetSaveFileName(&ofn))
                {
                    //Check if file already exists ..
                    if(0xFFFFFFFF != GetFileAttributes(szFileName))
                    {
                        // Ask user if they want to overwrite
                        if(IDNO == ShowMessageBoxParam(hWndParent,
                                                    IDE_VCARD_EXPORT_FILE_EXISTS,
                                                    MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND,
                                                    szFileName))
                        {
                            hr = MAPI_E_USER_CANCEL;
                            goto exit;
                        }
                    }

                    // Go ahead and overwrite the file if user said yes..

                    if(hr = VCardCreate(lpAdrBook,
                                     hWndParent,
                                     MAPI_DIALOG,
                                     szFileName,
                                     lpEntry))
                    {
                        goto exit;
                    }

                } // if GetSaveFileName...
            } // if (lpItem->cbEntryID)...
        }
    } else {
        if (iItemIndex <= 0) {
            // nothing selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
        } else {
            //multiple selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_ACTION, MB_ICONEXCLAMATION);
        }
        hr = E_FAIL;
        goto exit;
    }

    hr = S_OK;

exit:
    UlRelease(lpEntry);
    LocalFreeAndNull(&lpFilter);
    LocalFree(lpTitleFormat);

    if(lpTitle)
        LocalFree(lpTitle);
    return(hr);
}

/***************************************************************************

    Name      : VCardRetrive

    Purpose   : Retrieves a MailUser object from a given file name

    Parameters: hwnd = hwndParent
                lpIAB -> IAddrBook object,
                ulFlags can be 0 or MAPI_DIALOG - MAPI_DIALOG means report
                    error messages in a dialog box, else
                    work silently ..
                lpszFileNAme - vCard file name (file must exist)
                lpszBuf - a memory buffer containing the vCard file
                            which can be specified instead of the filename
                            Must be a null terminated string
                lppMailUser, returned MailUser ...

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT VCardRetrieve(LPADRBOOK lpAdrBook,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPSTR lpszBuf,
                      LPMAILUSER * lppMailUser)
{
    HRESULT hResult = E_FAIL;
    HANDLE hFile = NULL;
    LPSTR lpBuf = NULL;
    SBinary sb = {0};
    LPMAILUSER lpMailUser = NULL;

    // We will convert the vCard to a memory buffer and parse that buffer as needed
    // Somewhere in the buffer we need to track how much of the buffer has already
    // been parsed .. we'll polymorph a SBinary struct here so we can use the cb param
    // to track how much buffer has been parsed and the lpb to store the buffer

    SBinary buf = {0};


    if(!VCardGetBuffer(lpszFileName, lpszBuf, &lpBuf))
    {
        if(ulFlags & MAPI_DIALOG)
        {
            // couldn't open file.
            ShowMessageBoxParam(hWndParent, IDE_VCARD_IMPORT_FILE_ERROR,
                                MB_ICONEXCLAMATION, lpszFileName);
        }
        goto out;
    }

    if(hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &sb.cb, (LPENTRYID *)&sb.lpb))
        goto out;

    if (hResult = HrCreateNewObject(   lpAdrBook, &sb,
                                        MAPI_MAILUSER,
                                        CREATE_CHECK_DUP_STRICT,
                                        (LPMAPIPROP *) &lpMailUser))
    {
        goto out;
    }

    buf.cb = 0;
    buf.lpb = (LPBYTE) lpBuf;

    //if (hResult = ReadVCard(hFile, FileReadFn, *lppMailUser))
    if (hResult = ReadVCard((HANDLE) &buf, BufferReadFn, lpMailUser))
    {
        if(ulFlags & MAPI_DIALOG)
        {
            switch (GetScode(hResult))
            {
                case MAPI_E_INVALID_OBJECT:
                    ShowMessageBoxParam(hWndParent,
                                        IDE_VCARD_IMPORT_FILE_BAD,
                                        MB_ICONEXCLAMATION,
                                        lpszFileName);
                    goto out;

                default:
                    ShowMessageBoxParam(hWndParent,
                                        IDE_VCARD_IMPORT_PARTIAL,
                                        MB_ICONEXCLAMATION,
                                        lpszFileName);
                    break;
            }
        }
    }
    
out:
    if(lpBuf)
        LocalFree(lpBuf);

    if(sb.lpb)
        MAPIFreeBuffer(sb.lpb);

    if(lpMailUser)
    {
        if(HR_FAILED(hResult))
            lpMailUser->lpVtbl->Release(lpMailUser);
        else
            *lppMailUser = lpMailUser;
    }

    return hResult;
}

/***************************************************************************

    Name      : VCardImport

    Purpose   : Reads a vCard from a file to a new MAILUSER object.

    Parameters: hwnd = hwnd
                lpIAB -> IAddrBook object
                szVCardFile - name of the file to import if we already know it
                        in which case there is no OpenFileName dialog
                The entryids of the newly added objects are added to the
                    SPropValue which is a dummy prop of type MV_BINARY

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT VCardImport(HWND hWnd, LPADRBOOK lpAdrBook, LPTSTR szVCardFile, LPSPropValue * lppProp)
{
    HRESULT hResult = hrSuccess;
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_VCARD_FILE_SPEC, szVCardFilter, 0, NULL, 0, NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");
    HANDLE hFile = NULL;
    ULONG ulObjType;
    ULONG cProps;
    LPMAILUSER lpMailUser = NULL, lpMailUserNew = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    BOOL bChangesMade = FALSE;
	LPSPropValue lpspvEID = NULL;
    LPSTR lpBuf = NULL, lpVCardStart = NULL;
    LPSTR lpVCard = NULL, lpNext = NULL;
    LPSPropValue lpProp = NULL;
    
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = ARRAYSIZE(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = LoadAllocString(IDS_VCARD_IMPORT_TITLE);
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt =  TEXT("vcf");
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

	if(szVCardFile && lstrlen(szVCardFile))
        StrCpyN(szFileName, szVCardFile, ARRAYSIZE(szFileName));
	else
	    if (!GetOpenFileName(&ofn))
			goto exit;

	if(lstrlen(szFileName))
    {
        if(!VCardGetBuffer(szFileName, NULL, &lpBuf))
        {
            // couldn't open file.
            ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            goto exit;
        }

        lpVCardStart = lpBuf;

        // Loop through showing all the nested vCards one by one ..
        while(VCardGetNextBuffer(lpVCardStart, &lpVCard, &lpNext) && lpVCard)
        {
            if(!HR_FAILED(  hResult = VCardRetrieve( lpAdrBook, hWnd, MAPI_DIALOG, szFileName, lpVCard, &lpMailUser)))
            {
                if (!HR_FAILED(hResult = HrShowDetails(lpAdrBook, hWnd, NULL, 0, NULL, NULL, NULL,
                                                  (LPMAPIPROP)lpMailUser, SHOW_OBJECT, MAPI_MAILUSER, &bChangesMade))) 
                {
                    if (hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READONLY))
                    {
                        switch(hResult)
                        {
                        case MAPI_E_COLLISION:
                            {
                                LPSPropValue lpspv1 = NULL, lpspv2 = NULL;
                                if (! (hResult = HrGetOneProp((LPMAPIPROP)lpMailUser, PR_DISPLAY_NAME, &lpspv1))) 
                                {
                                    switch (ShowMessageBoxParam(hWnd, IDS_VCARD_IMPORT_COLLISION, MB_YESNOCANCEL | MB_ICONEXCLAMATION | MB_APPLMODAL | MB_SETFOREGROUND, lpspv1->Value.LPSZ, szFileName)) 
                                    {
                                    case IDYES:
                                        // Yes, replace
                                        // Create a new one with the right flags, copy the old one's props and save.
                                        ulCreateFlags |= ( CREATE_REPLACE | CREATE_MERGE );
                                        if(!HR_FAILED(hResult = HrCreateNewObject(lpAdrBook, ((LPMailUser)lpMailUser)->pmbinOlk, MAPI_MAILUSER, ulCreateFlags, (LPMAPIPROP *)&lpMailUserNew)))
                                        {
                                            if (!HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,NULL,MAPI_UNICODE,&cProps,&lpspv2))) 
                                            {
                                                if (!HR_FAILED(hResult = lpMailUserNew->lpVtbl->SetProps(lpMailUserNew,cProps,lpspv2,NULL))) 
                                                {
                                                    hResult = lpMailUserNew->lpVtbl->SaveChanges(lpMailUserNew,KEEP_OPEN_READONLY);
                                                }
                                            }
                                        }
                                        break;
                                    case IDCANCEL:
                                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                        break;  // no, don't replace
                                    default:
                                        hResult = E_FAIL;
                                        break;
                                    }
                                }
                                FreeBufferAndNull(&lpspv1);
                                FreeBufferAndNull(&lpspv2);
                            }
                            break;

                        case MAPI_E_NOT_ENOUGH_DISK:
                            hResult = HandleSaveChangedInsufficientDiskSpace(hWnd, lpMailUser);
                            break;

                        default:
                            if(HR_FAILED(hResult))
                                ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_BAD, MB_ICONEXCLAMATION, szFileName);
                            break;
                        }
                    }
                }
            } 

            if(!lpProp && !HR_FAILED(hResult))
            {
                SCODE sc;
                if(sc = MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpProp))
                {
                    hResult = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto exit;
                }
                lpProp->ulPropTag = PR_WAB_DL_ENTRIES; // Doesnt matter what we set this to as long as its MV_BINARY
                lpProp->Value.MVbin.cValues = 0;
                lpProp->Value.MVbin.lpbin = NULL;
            }

		    if(lpProp && !HR_FAILED(hResult))
            {
			    LPMAILUSER lpMU = (lpMailUserNew) ? lpMailUserNew : lpMailUser;
                if (! (hResult = HrGetOneProp((LPMAPIPROP)lpMU, PR_ENTRYID, &lpspvEID)))
			    {
                    AddPropToMVPBin(lpProp, 0 , lpspvEID->Value.bin.lpb, lpspvEID->Value.bin.cb, TRUE);
                	FreeBufferAndNull(&lpspvEID);
			    }
		    }

            if(lpMailUserNew)
                lpMailUserNew->lpVtbl->Release(lpMailUserNew);
            if(lpMailUser)
                lpMailUser->lpVtbl->Release(lpMailUser);

            lpMailUser = NULL;
            lpMailUserNew = NULL;

            if(hResult == MAPI_E_USER_CANCEL)
                break;

            lpVCard = NULL;
            lpVCardStart = lpNext;
        }
    } // getopenfilename ...

    *lppProp = lpProp;

exit:
    LocalFreeAndNull(&lpBuf);
    LocalFree(lpFilter);
    LocalFree((LPVOID)ofn.lpstrTitle);
    
    if (hFile)
        CloseHandle(hFile);
    if(lpMailUser)
        UlRelease(lpMailUser);
    if(lpMailUserNew)
        UlRelease(lpMailUserNew);
    
    return(hResult);
}
#endif


//$$//////////////////////////////////////////////////////////////////////
//	HrShowLVEntryProperties
//
//	Shows the properties of an entry in the list view ...
//	Assumes that all list views are based on lpRecipientInfo Structures
//
//  hWndLV - handle of List view. We look up the selected item in this list
//              view, get its lParam structure, then get its EntryID and
//              call details
//  lpIAB - handle to current AdrBook object - used for calling details
//  lpftLast - WAB file time at last update
//
//  Returns:MAPI_E_USER_CANCEL on cancel
//          MAPI_E_OBJECT_CHANGED if object was modified
//          S_OK if no changes and nothing modified
//////////////////////////////////////////////////////////////////////////
HRESULT HrShowLVEntryProperties(HWND hWndLV, ULONG ulFlags, LPADRBOOK lpAdrBook, LPFILETIME lpftLast)
{
	HRESULT hr = E_FAIL;
	int iItemIndex;
	HWND hWndParent = GetParent(hWndLV);
    LPRECIPIENT_INFO lpNewItem=NULL;

	// Open props if only 1 item is selected
	iItemIndex = ListView_GetSelectedCount(hWndLV);
	if (iItemIndex == 1)
	{
		// Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
		if (iItemIndex != -1)
		{
			LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;
			if(lpItem && lpItem->cbEntryID != 0)
			{
				hr = lpAdrBook->lpVtbl->Details(lpAdrBook,
											(PULONG_PTR) &hWndParent,            // ulUIParam
											NULL,
											NULL,
											lpItem->cbEntryID,
											lpItem->lpEntryID,
											NULL,
											NULL,
                                            NULL, 
                                            ulFlags); 
				// if details changed something - our event and semaphores should
				// notify us so we can update ourselves from the property store or
				// whatever ...
				// this is TBD - at this point there is no way to refresh anything ..
                if(HR_FAILED(hr))
                {
                    goto out;
                }
                else //if(!HR_FAILED(hr))
                {
                    //Open the item again and compare its UI props to see
                    //if anything changed ...

                    if(0 != IsWABEntryID(lpItem->cbEntryID,
                                         lpItem->lpEntryID,
                                         NULL, NULL, NULL, NULL, NULL))
                    {
                        // <TBD> the above test may not be good enough ..
                        // we really need to check if its a wab entryid ..
                        //
                        // This is not a WAB entry ID
                        // For now assume this is a read only contact and so
                        // we dont need to check it again for changes
                        //
                        goto out;
                    }

                    if(!ReadSingleContentItem(  lpAdrBook,
                                            lpItem->cbEntryID,
                                            lpItem->lpEntryID,
                                            &lpNewItem))
                        goto out;


                    // Compare the new item with the old item
                    // If anything changed, we need to update the item in the list view
                    if (lstrcmp(lpItem->szDisplayName,lpNewItem->szDisplayName))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colDisplayName,lpNewItem->szDisplayName);
                        StrCpyN(lpItem->szDisplayName,lpNewItem->szDisplayName,ARRAYSIZE(lpItem->szDisplayName));
                    }

                    if (lstrcmp(lpItem->szEmailAddress,lpNewItem->szEmailAddress))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colEmailAddress,lpNewItem->szEmailAddress);
                        StrCpyN(lpItem->szEmailAddress,lpNewItem->szEmailAddress,ARRAYSIZE(lpItem->szEmailAddress));
                    }

                    if (lstrcmp(lpItem->szHomePhone,lpNewItem->szHomePhone))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colHomePhone,lpNewItem->szHomePhone);
                        StrCpyN(lpItem->szHomePhone,lpNewItem->szHomePhone,ARRAYSIZE(lpItem->szHomePhone));
                    }

                    if (lstrcmp(lpItem->szOfficePhone,lpNewItem->szOfficePhone))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        ListView_SetItemText(hWndLV,iItemIndex,colOfficePhone,lpNewItem->szOfficePhone);
                        StrCpyN(lpItem->szOfficePhone,lpNewItem->szOfficePhone,ARRAYSIZE(lpItem->szOfficePhone));
                    }

                    if (lstrcmp(lpItem->szByLastName,lpNewItem->szByLastName))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        StrCpyN(lpItem->szByLastName,lpNewItem->szByLastName,ARRAYSIZE(lpItem->szByLastName));
                    }

                    if (lstrcmp(lpItem->szByFirstName,lpNewItem->szByFirstName))
                    {
                        hr = MAPI_E_OBJECT_CHANGED;
                        StrCpyN(lpItem->szByFirstName,lpNewItem->szByFirstName,ARRAYSIZE(lpItem->szByFirstName));
                    }

                    {
                        LVITEM lvI = {0};
                        lvI.mask = LVIF_IMAGE;
    	                lvI.iItem = iItemIndex;
                        lvI.iSubItem = 0;
                        lpItem->bHasCert = lpNewItem->bHasCert;
                        lpItem->bIsMe = lpNewItem->bIsMe;
                        lvI.iImage = GetWABIconImage(lpItem);
                        ListView_SetItem(hWndLV, &lvI);
                    }

                    // Update the wab file write time so the timer doesn't
                    // catch this change and refresh.
                    //if (lpftLast &&
                    //    lpItem->ulObjectType == MAPI_MAILUSER) // refresh for distlists not for mailusers (because distlists can cause further modifications)
                    //{
                    //   CheckChangedWAB(((LPIAB)lpIAB)->lpPropertyStore, lpftLast);
                    //}

                }
			}
		}
	}
	else
    {
        if (iItemIndex <= 0)
		{
			// nothing selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
		}
		else
		{
			//multiple selected
            ShowMessageBox(GetParent(hWndLV), IDS_ADDRBK_MESSAGE_ACTION, MB_ICONEXCLAMATION);
		}
		hr = E_FAIL;
        goto out;
    }


out:

    if(hr == MAPI_E_NOT_FOUND)
        ShowMessageBox(GetParent(hWndLV), idsEntryNotFound, MB_OK | MB_ICONEXCLAMATION);

    if(lpNewItem)
        FreeRecipItem(&lpNewItem);

    return hr;

}



//$$//////////////////////////////////////////////////////////////////////
//
// LVSelectItem - Selects a list view item and ensures it is visible
//
// hWndList - handle of list view control
// iItemIndex - index of item to select
//
////////////////////////////////////////////////////////////////////////
void LVSelectItem(HWND hWndList, int iItemIndex)
{
    DWORD dwStyle;

    // Hopefully, we only want to select a single item
    // So we cheat by making the ListView single select and
    // set our item, reseting everything else
    dwStyle = GetWindowLong(hWndList, GWL_STYLE);
    SetWindowLong(hWndList, GWL_STYLE, dwStyle | LVS_SINGLESEL);

	ListView_SetItemState ( hWndList,        // handle to listview
							iItemIndex,			    // index to listview item
							LVIS_FOCUSED | LVIS_SELECTED, // item state
							LVIS_FOCUSED | LVIS_SELECTED);                      // mask
	ListView_EnsureVisible (hWndList,        // handle to listview
							iItemIndex,
							FALSE);

    //reset back to the original style ..
    SetWindowLong(hWndList, GWL_STYLE, dwStyle);
	
    return;
}



//$$//////////////////////////////////////////////////////////////////////////////
///
/// AddWABEntryToListView - Adds a wab entry to a list view given a entryid
///
/// lpIAB - handle to AdrBook object
/// hWndLV - list view of interest
/// lpEID - EntryID of entry. Assumes size of entryid is WAB_ENTRY_ID
/// lppContentsList - List into which the entry is also linked
///
///
////////////////////////////////////////////////////////////////////////////////
BOOL AddWABEntryToListView( LPADRBOOK lpAdrBook,
                            HWND hWndLV,
                            ULONG cbEID,
                            LPENTRYID lpEID,
                            LPRECIPIENT_INFO * lppContentsList)
{
	BOOL bRet = FALSE;
	LPRECIPIENT_INFO lpItem = NULL;
	LV_ITEM lvi = {0};
	int index = 0;
	
	if (!lpEID)
		goto out;

	if (!ReadSingleContentItem( lpAdrBook, cbEID, lpEID, &lpItem))
		goto out;

	AddSingleItemToListView(hWndLV, lpItem);

	//we added to the end - so this is the last item
	//select it ...

	index = ListView_GetItemCount(hWndLV);
	LVSelectItem(hWndLV, index-1);

    //
    // Hook in the lpItem into the lpContentsList so we can free it later
    //
    lpItem->lpPrev = NULL;
    lpItem->lpNext = *lppContentsList;
    if (*lppContentsList)
        (*lppContentsList)->lpPrev = lpItem;
    (*lppContentsList) = lpItem;

	bRet = TRUE;
out:
	if (!bRet && lpItem)
		FreeRecipItem(&lpItem);

	return bRet;
}



//$$////////////////////////////////////////////////////////////////////////////
//
// AddSingleItemToListView - Takes a single lpItem and adds it to alist view
//
// hWndLV - handle of List View
// lpItem - Recipient Info corresponding to a single entry
//
//////////////////////////////////////////////////////////////////////////////
void AddSingleItemToListView(HWND hWndLV, LPRECIPIENT_INFO lpItem)
{
    LV_ITEM lvI = {0};
    int index = 0;

	// Add just a single item ...
    
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM ;
	lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;

    lvI.iImage = GetWABIconImage(lpItem);

    lvI.iItem = ListView_GetItemCount(hWndLV);
	lvI.iSubItem = colDisplayName;
	lvI.lParam = (LPARAM) lpItem;
	lvI.pszText = lpItem->szDisplayName;

    index = ListView_InsertItem (hWndLV, &lvI);
    if (index == -1)
	{
		DebugPrintError(( TEXT("ListView_InsertItem Failed\n")));
		goto out;
	}

	// TBD - this is assuming that all the fields exist and are filled in
    if(lstrlen(lpItem->szOfficePhone))
    	ListView_SetItemText (hWndLV, index, colOfficePhone, lpItem->szOfficePhone);
    if(lstrlen(lpItem->szHomePhone))
    	ListView_SetItemText (hWndLV, index, colHomePhone, lpItem->szHomePhone);
    if(lstrlen(lpItem->szEmailAddress))
        ListView_SetItemText (hWndLV, index, colEmailAddress, lpItem->szEmailAddress);

out:
	return;
}




//$$////////////////////////////////////////////////////////////////////////////
//
//  ReadSingeContentItem - reads a specified record from the prop store
//  and creates a single pointer item for the Address Linked list and
//  content window.
//
//  lpIAB - pointer to AdrBook Object
//  cbEntryID - EntryID byte count of object of interest
//  lpEntryID - EntryID of object of interest
//  lppItem - returned lppItem
//
//////////////////////////////////////////////////////////////////////////////
BOOL ReadSingleContentItem( LPADRBOOK lpAdrBook,
                            ULONG cbEntryID,
                            LPENTRYID lpEntryID,
                            LPRECIPIENT_INFO * lppItem)
{
    LPSPropValue lpPropArray = NULL;
    ULONG ulcProps = 0;
    ULONG nLen = 0;
    ULONG i = 0;
    BOOL bDisplayNameSet = FALSE;
    BOOL bEmailAddressSet = FALSE;
    BOOL bRet = FALSE;

    (*lppItem) = LocalAlloc(LMEM_ZEROINIT,sizeof(RECIPIENT_INFO));
    if(!(*lppItem))
    {
        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
        goto out;
    }

    (*lppItem)->lpNext = NULL;
    (*lppItem)->lpPrev = NULL;

    if (HR_FAILED(  HrGetPropArray( lpAdrBook,
                                    NULL,
                                    cbEntryID,
                                    lpEntryID,
                                    MAPI_UNICODE,
                                    &ulcProps,
                                    &lpPropArray) ) )
    {
        DebugPrintError(( TEXT("HrGetPropArray failed\n")));
        goto out;
    }

	GetRecipItemFromPropArray(ulcProps, lpPropArray, lppItem);

    //Bug-
    // 3/31/97 - vikramm
    // on NTDSDC5.0, we are getting no attributes back in some cases
    // and later on gpf when we try to look at the attributes ..
    // make a check here

	if (!lstrlen((*lppItem)->szDisplayName) || ((*lppItem)->cbEntryID == 0)) //This entry id is not allowed
	{
        goto out;
	}


    bRet = TRUE;


out:
    if (lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if (!bRet)
    {
        if (*lppItem)
            FreeRecipItem(lppItem);
    }

    return bRet;
}

/*
-
-   bIsRubyLocale - Checks if the current locale is Rubyenabled
-
*/
BOOL bIsRubyLocale()
{
    static LCID lcid = 0;
    if(!lcid)
    {
        lcid = GetUserDefaultLCID();
        //DebugTrace( TEXT("UserDefaultLCID = 0x%.4x\n"), lcid);
    }
    switch(lcid)
    {
    //case 0x0409: // us for testing
    case 0x0804: //chinese    
    case 0x0411: //japanese
    // case 0x0412: //korean - not use Ruby (YST)
    case 0x0404: //chinese - taiwan
    case 0x0c04: //chinese - hongkong
        return TRUE;
        break;
    }
    return FALSE;
}

/*
- TimeToString
-
*   Converts a FileTime prop into a short string
*/
void TimeToString(LPTSTR szTime, FILETIME ft,ULONG cb )
{
    SYSTEMTIME st = {0};
    static TCHAR szFormat[64];
    szTime[0] = TEXT('\0');
    if(!lstrlen(szFormat))
        LoadString(hinstMapiX, idsLVDateFormatString, szFormat, ARRAYSIZE(szFormat));
    if(FileTimeToSystemTime(&ft, &st))
        GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, szFormat, szTime, cb);
}




//$$////////////////////////////////////////////////////////////////////////////
//
// GetRcipItemFromPropArray - Scans a lpPropArray structure for the props of
//							interest and puts them in an recipientInfo structure
//
//  ulcPropCount - count of Props in the LPSPropValue array
//  rgPropVals - LPSPropValue array
//  lppItem - returned lppItem
//
//////////////////////////////////////////////////////////////////////////////
void GetRecipItemFromPropArray( ULONG ulcPropCount,
                                LPSPropValue rgPropVals,
                                LPRECIPIENT_INFO * lppItem)
{
	ULONG j=0,nLen=0;
	LPRECIPIENT_INFO lpItem = *lppItem;
    LPTSTR lpszDisplayName = NULL, lpszNickName = NULL, lpszCompanyName = NULL;
    LPTSTR lpszFirstName = NULL, lpszLastName = NULL, lpszMiddleName = NULL;
    LPTSTR lpszRubyFirstName = NULL, lpszRubyLastName = NULL;
    TCHAR szBufDisplayName[MAX_DISPLAY_NAME_LENGTH];
    TCHAR szBufOppositeName[MAX_DISPLAY_NAME_LENGTH];
    LPVOID lpBuffer = NULL;
    ULONG ulProp1, ulProp2;
    BOOL bRuby = bIsRubyLocale();

    ulProp1 = (PR_WAB_CUSTOMPROP1 ? PR_WAB_CUSTOMPROP1 : PR_HOME_TELEPHONE_NUMBER);
    ulProp2 = (PR_WAB_CUSTOMPROP2 ? PR_WAB_CUSTOMPROP2 : PR_OFFICE_TELEPHONE_NUMBER);

    for(j=0;j<ulcPropCount;j++)
	{
        // Check Custom Props first in case these are dupes of other props already in the switch statement
        //
		if(rgPropVals[j].ulPropTag == ulProp1)
        {
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_TSTRING)
            {
                nLen = CopyTruncate(lpItem->szHomePhone, rgPropVals[j].Value.LPSZ, 
                                    MAX_DISPLAY_NAME_LENGTH);
            }
            else // for birthday, anniversary etc
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_SYSTIME)
                TimeToString(lpItem->szHomePhone, rgPropVals[j].Value.ft, MAX_DISPLAY_NAME_LENGTH-1);
        }
        else if(rgPropVals[j].ulPropTag == ulProp2)
        {
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_TSTRING)
            {
                nLen = CopyTruncate(lpItem->szOfficePhone, rgPropVals[j].Value.LPSZ, 
                                    MAX_DISPLAY_NAME_LENGTH);
            }
            else // for birthday, anniversary etc
            if(PROP_TYPE(rgPropVals[j].ulPropTag) == PT_SYSTIME)
                TimeToString(lpItem->szOfficePhone, rgPropVals[j].Value.ft,MAX_DISPLAY_NAME_LENGTH-1);
        }

		switch(rgPropVals[j].ulPropTag)
		{
		case PR_DISPLAY_NAME:
            lpszDisplayName = rgPropVals[j].Value.LPSZ;
			break;

        case PR_SURNAME:
            lpszLastName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_GIVEN_NAME:
            lpszFirstName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_MIDDLE_NAME:
            lpszMiddleName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_COMPANY_NAME:
            lpszCompanyName = rgPropVals[j].Value.LPSZ;
            break;

        case PR_NICKNAME:
            lpszNickName = rgPropVals[j].Value.LPSZ;
            break;

		case PR_EMAIL_ADDRESS:
            nLen = CopyTruncate(lpItem->szEmailAddress, rgPropVals[j].Value.LPSZ, 
                                MAX_DISPLAY_NAME_LENGTH);
			break;
				
		case PR_ENTRYID:
			lpItem->cbEntryID = rgPropVals[j].Value.bin.cb;
			lpItem->lpEntryID = LocalAlloc(LMEM_ZEROINIT,lpItem->cbEntryID);
            if(!(lpItem->lpEntryID))
            {
                DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                goto out;
            }
			CopyMemory(lpItem->lpEntryID,rgPropVals[j].Value.bin.lpb,lpItem->cbEntryID);
			break;
			
		case PR_OBJECT_TYPE:
			lpItem->ulObjectType = rgPropVals[j].Value.l;
			break;

        case PR_USER_X509_CERTIFICATE:
            lpItem->bHasCert = TRUE;
            break;

        default:
            if(rgPropVals[j].ulPropTag == PR_WAB_THISISME)
                lpItem->bIsMe = TRUE;
            else if(rgPropVals[j].ulPropTag == PR_WAB_YOMI_FIRSTNAME)
                lpszRubyFirstName = rgPropVals[j].Value.LPSZ;
            else if(rgPropVals[j].ulPropTag == PR_WAB_YOMI_LASTNAME)
                lpszRubyLastName = rgPropVals[j].Value.LPSZ;
            break;
		}
			
	}

    // [PaulHi] 3/12/99  Raid 63006  Use the PR_CONTACT_EMAIL_ADDRESSES email
    // name if a PR_EMAIL_ADDRESS doesn't exist
    if ( lpItem->szEmailAddress && (*lpItem->szEmailAddress == '\0') )
    {
        if (rgPropVals[RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
        {
            // Just grap the first one in multi-valued list
            if (rgPropVals[RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.cValues != 0)
            {
                nLen = CopyTruncate(lpItem->szEmailAddress, 
                                    rgPropVals[RECIPCOLUMN_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.LPPSZ[0], 
                                    MAX_DISPLAY_NAME_LENGTH);
            }
        }
    }

    // Reduce display name to 32 char or less ...

    if(!lpszDisplayName) // should never happen
        lpszDisplayName = szEmpty;

    nLen = CopyTruncate(szBufDisplayName, lpszDisplayName, MAX_DISPLAY_NAME_LENGTH);

    // The display name will be either by first name or last name
    // so all we have to do is generate the other name and we'll
    // be all set

    szBufOppositeName[0]='\0';

    if(lpItem->ulObjectType == MAPI_DISTLIST)
    {
        StrCpyN(szBufOppositeName, szBufDisplayName, ARRAYSIZE(szBufOppositeName));
    }
    else
    {

        // if there is no first/middle/last (there will always be a display name)
        // and the display name does not match company name or nick name,
        // then we shall try to parse the display name into first/middle/last
        if( !lpszFirstName &&
            !lpszMiddleName && 
            !lpszLastName && 
            !(lpszCompanyName && !lstrcmp(lpszDisplayName, lpszCompanyName)) &&
            !(lpszNickName && !lstrcmp(lpszDisplayName, lpszNickName)) )
        {
            ParseDisplayName(   lpszDisplayName,
                                &lpszFirstName,
                                &lpszLastName,
                                NULL,           // Root WAB allocation
                                &lpBuffer);     // lppLocalFree
        }

        if (lpszFirstName ||
            lpszMiddleName ||
            lpszLastName)
        {
            LPTSTR lpszTmp = szBufOppositeName;

            SetLocalizedDisplayName(    lpszFirstName,
					bRuby ? NULL : lpszMiddleName,
                                        lpszLastName,
                                        NULL, //company
                                        NULL, //nickname
                                        (LPTSTR *) &lpszTmp, //&szBufOppositeName,
                                        MAX_DISPLAY_NAME_LENGTH,
                                        !bDNisByLN,
                                        NULL,
                                        NULL);
        }
    }

    if(!lstrlen(szBufOppositeName))
    {
        // There is only 1 type of name so use it everywhere
        StrCpyN(lpItem->szByFirstName,szBufDisplayName,ARRAYSIZE(lpItem->szByFirstName));
        StrCpyN(lpItem->szByLastName,szBufDisplayName,ARRAYSIZE(lpItem->szByLastName));
    }
    else if(bDNisByLN)
    {
        // Display Name is by Last Name
        StrCpyN(lpItem->szByFirstName,szBufOppositeName,ARRAYSIZE(lpItem->szByFirstName));
        StrCpyN(lpItem->szByLastName,szBufDisplayName,ARRAYSIZE(lpItem->szByLastName));
    }
    else
    {
        // Display Name is by First Name
        StrCpyN(lpItem->szByLastName,szBufOppositeName,ARRAYSIZE(lpItem->szByLastName));
        StrCpyN(lpItem->szByFirstName,szBufDisplayName,ARRAYSIZE(lpItem->szByFirstName));
    }

    StrCpyN(lpItem->szDisplayName, szBufDisplayName,ARRAYSIZE(lpItem->szDisplayName));

    if(bRuby)
    {
        if(lpszRubyFirstName)
            SetLocalizedDisplayName(lpszRubyFirstName, NULL,
                                    lpszRubyLastName ? lpszRubyLastName : (lpszLastName ? lpszLastName : szEmpty),
                                    NULL, NULL, NULL, 0, 
                                    FALSE, //DNbyFN
                                    NULL,
                                    &lpItem->lpByRubyFirstName);
        if(lpszRubyLastName)
            SetLocalizedDisplayName(lpszRubyFirstName ? lpszRubyFirstName : (lpszFirstName ? lpszFirstName : szEmpty),
                                    NULL,
                                    lpszRubyLastName,
                                    NULL, NULL, NULL, 0, 
                                    TRUE, //DNbyFN
                                    NULL,
                                    &lpItem->lpByRubyLastName);
    }

    // default object type to mailuser
    if(!lpItem->ulObjectType)
        lpItem->ulObjectType = MAPI_MAILUSER;

out: 
    if(lpBuffer)
        LocalFree(lpBuffer);

	return;

}

/*
-   AddEntryToGroupEx
-
*   Adds an entry to a group
*
*/
HRESULT AddEntryToGroupEx(LPADRBOOK lpAdrBook,
                        ULONG cbGroupEntryID,
                        LPENTRYID lpGroupEntryID,
                        DWORD cbEID,
                        LPENTRYID lpEID)
{
    HRESULT hr = E_FAIL;
    LPMAPIPROP lpMailUser = NULL;
    ULONG ulObjType;
    ULONG cValues = 0;
    LPSPropValue lpPropArray = NULL;
    LPSPropValue lpSProp = NULL;
    ULONG ulcNewProp = 0;
    LPSPropValue lpNewProp = NULL;
    SCODE sc;
    ULONG i,j;
    BOOL bDLFound = FALSE;
    BOOL bIsOneOff = (WAB_ONEOFF == IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL));
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(pt_bIsWABOpenExSession)
        bIsOneOff = FALSE;

    // [PaulHi] Raid 67581  First thing to do is check for cyclical references.
    // This was done as a special case below and is now moved up to the top of
    // the function.
    if(!bIsOneOff)
    {
        if(CheckForCycle(lpAdrBook, lpEID, cbEID, lpGroupEntryID, cbGroupEntryID))
        {
            hr = MAPI_E_FOLDER_CYCLE;
            goto out;
        }
    }

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(    lpAdrBook,
                                                    cbGroupEntryID,    // cbEntryID
                                                    lpGroupEntryID,    // entryid
                                                    NULL,         // interface
                                                    MAPI_MODIFY,                // ulFlags
                                                    &ulObjType,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugPrintError(( TEXT("IAB->OpenEntry: %x"), hr));
        goto out;
    }

    Assert(lpMailUser);

    if(ulObjType != MAPI_DISTLIST)
        goto out;

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,   // this
                                                    NULL,
                                                    MAPI_UNICODE,
                                                    &cValues,      // cValues
                                                    &lpPropArray)))
    {
        DebugPrintError(( TEXT("lpMailUser->Getprops failed: %x\n"),hr));
        goto out;
    }

    for(i=0;i<cValues;i++)
    {
        // For the DistList, the prop may not exist and if it doesnt exist, 
        // we make sure we can handle that case by adding the prop to the group..
        //
        if(lpPropArray[i].ulPropTag == (bIsOneOff ? PR_WAB_DL_ONEOFFS : PR_WAB_DL_ENTRIES) )
        {
            bDLFound = TRUE;
            // before we add the item to the distlist, we want to check for
            // duplicates
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                if( cbEID == lpPropArray[i].Value.MVbin.lpbin[j].cb 
                    && !memcmp(lpEID, lpPropArray[i].Value.MVbin.lpbin[j].lpb, cbEID))
                {
                    // yes its the same item
                    hr = S_OK;
                    goto out;
                }
            }

            if (HR_FAILED(hr = AddPropToMVPBin( lpPropArray, i, lpEID, cbEID, FALSE)))
            {
                DebugPrintError(( TEXT("AddPropToMVPBin -> %x\n"), GetScode(hr)));
                goto out;
            }
            break;
        }
    }

    if(!bDLFound)
    {
        // This item is empty and doesnt have a PR_WAB_DL_PROPS or PR_WAB_FOLDER_PROPS..
        // Add a new prop to this object ..

        MAPIAllocateBuffer(sizeof(SPropValue), &lpSProp);

        lpSProp->ulPropTag = (bIsOneOff ? PR_WAB_DL_ONEOFFS : PR_WAB_DL_ENTRIES);
        lpSProp->Value.MVbin.cValues = 0;
        lpSProp->Value.MVbin.lpbin = NULL;
        if (HR_FAILED(hr = AddPropToMVPBin( lpSProp, 0, lpEID, cbEID, FALSE)))
        {
            DebugPrintError(( TEXT("AddPropToMVPBin -> %x\n"), GetScode(hr)));
            goto out;
        }
        sc = ScMergePropValues( 1, lpSProp, 
                                cValues, lpPropArray,
                                &ulcNewProp, &lpNewProp);
        if (sc != S_OK)
        {
            hr = ResultFromScode(sc);
            goto out;
        }

        if(lpPropArray)
            MAPIFreeBuffer(lpPropArray);
        lpPropArray = lpNewProp;
        cValues = ulcNewProp;

        lpNewProp = NULL;
    }

    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,  cValues, lpPropArray, NULL)))
    {
        DebugPrintError(( TEXT("lpMailUser->Setprops failed\n")));
        goto out;
    }

    hr = lpMailUser->lpVtbl->SaveChanges( lpMailUser, KEEP_OPEN_READWRITE);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("SaveChanges failed\n")));
        goto out;
    }

out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpNewProp)
        MAPIFreeBuffer(lpNewProp);

    if(lpSProp)
        MAPIFreeBuffer(lpSProp);

	if(lpMailUser)
		lpMailUser->lpVtbl->Release(lpMailUser);

    return hr;
}


/*
-   RemoveEntryFromFolder
-
*
*
*/
HRESULT RemoveEntryFromFolder(LPIAB lpIAB,
                              LPSBinary lpsbFolder, 
                              ULONG cbEIDItem, LPENTRYID lpEIDItem)
{
    HRESULT hr = E_FAIL;
    ULONG ulObjType = 0, cValues = 0, i = 0, j = 0, k =0;
    int nIndex = -1;
    BOOL bRemoved = TRUE;
    LPSPropValue lpPropArray = NULL;

    // open the Folder
    if(HR_FAILED(hr = ReadRecord(lpIAB->lpPropertyStore->hPropertyStore, 
                                 lpsbFolder, 0, &cValues, &lpPropArray)))
        goto out;

    for(i=0;i<cValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
        {
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                if(lpPropArray[i].Value.MVbin.lpbin[j].cb == cbEIDItem)
                {
                    if(!memcmp(lpPropArray[i].Value.MVbin.lpbin[j].lpb, lpEIDItem, cbEIDItem))
                    {
                        //knock this item out of the list
                        LocalFree(lpPropArray[i].Value.MVbin.lpbin[j].lpb);
                        // move everything 1 up in the array
                        for(k=j;k<lpPropArray[i].Value.MVbin.cValues-1;k++)
                        {
                            lpPropArray[i].Value.MVbin.lpbin[k].lpb = lpPropArray[i].Value.MVbin.lpbin[k+1].lpb;
                            lpPropArray[i].Value.MVbin.lpbin[k].cb = lpPropArray[i].Value.MVbin.lpbin[k+1].cb;
                        }
                        lpPropArray[i].Value.MVbin.cValues--;
                        bRemoved = TRUE;
                        break;
                    }
                }
            }
        }
    }

    if(bRemoved)
    {
        // write this back to the store
        hr = WriteRecord(lpIAB->lpPropertyStore->hPropertyStore,
                         NULL, &lpsbFolder, 0, RECORD_CONTAINER, 
                         cValues, lpPropArray);
    }

out:
    ReadRecordFreePropArray(NULL, cValues, &lpPropArray);

    return hr;
}


/*
-   AddEIDToNewFolderParent
-
*   Adds the given EID to a given Folder
*/
HRESULT AddItemEIDToFolderParent(  LPIAB lpIAB,
                                   ULONG cbFolderEntryId,
                                   LPENTRYID lpFolderEntryId,
                                   ULONG cbEID, LPENTRYID lpEID)
{
    HRESULT hr = S_OK;
    SBinary sb = {0};
    ULONG cValues = 0,i;
    LPSPropValue lpPropArray = NULL;

    // ignore additions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(lpIAB))
        return S_OK;

    sb.cb = cbFolderEntryId;
    sb.lpb = (LPBYTE)lpFolderEntryId;

    if(HR_FAILED(hr = ReadRecord( lpIAB->lpPropertyStore->hPropertyStore, 
                                  &sb, 0, &cValues, &lpPropArray)))
        goto out;

    for(i=0;i<cValues;i++)
    {
        // For the folder, the  PR_WAB_FOLDER_ENTRIES will always exist
        //
        if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
        {
            // This is a local alloced prop array so we can just tag the entry to
            // the existing prop
            LPSBinary lpbin = LocalAlloc(LMEM_ZEROINIT, (lpPropArray[i].Value.MVbin.cValues+1)*sizeof(SBinary));
            ULONG j = 0;

            // First make sure this entry is not already a part of this folder
            // If it is, we dont need to do anything
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                if(cbEID == lpPropArray[i].Value.MVbin.lpbin[j].cb)
                {
                    if(!memcmp(lpEID, lpPropArray[i].Value.MVbin.lpbin[j].lpb, cbEID))
                    {
                        // yes its the same item
                        LocalFreeAndNull(&lpbin);
                        hr = S_OK;
                        goto out;
                    }
                }
            }

            // no match - so add it
            for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
            {
                lpbin[j].cb = lpPropArray[i].Value.MVbin.lpbin[j].cb;
                lpbin[j].lpb = lpPropArray[i].Value.MVbin.lpbin[j].lpb;
            }
            SetSBinary(&(lpbin[j]), cbEID, (LPBYTE)lpEID);
            if(lpPropArray[i].Value.MVbin.lpbin)
                LocalFree(lpPropArray[i].Value.MVbin.lpbin);
            lpPropArray[i].Value.MVbin.lpbin = lpbin;
            lpPropArray[i].Value.MVbin.cValues++;
            break;
        }
    }

    // Write this folder item back to the store
    {
        LPSBinary lpsb = &sb;
        if(HR_FAILED(hr = WriteRecord( lpIAB->lpPropertyStore->hPropertyStore,
                                    NULL, &lpsb, 0, RECORD_CONTAINER, 
                                    cValues, lpPropArray)))
        goto out;
    }
out:
    ReadRecordFreePropArray(NULL, cValues, &lpPropArray);

    return hr;
}

/*
-   AddFolderParentEIDToItem
-
*   Adds the Folders EID to given Item
*
*/
HRESULT AddFolderParentEIDToItem(LPIAB lpIAB,
                                 ULONG cbFolderEntryID,
                                 LPENTRYID lpFolderEntryID,
                                 LPMAPIPROP lpMU,
                                 ULONG cbEID, LPENTRYID lpEID)
{
    LPSPropValue lpspvMU = NULL;
    ULONG ulcPropsMU = 0,i;
    HRESULT hr = S_OK;

    // ignore additions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(lpIAB))
        return S_OK;

    if(!HR_FAILED(hr = lpMU->lpVtbl->GetProps(lpMU, NULL, MAPI_UNICODE, &ulcPropsMU, &lpspvMU)))
    {
        // Look for PR_WAB_FOLDER_PARENT
        BOOL bFound = FALSE;
        if(cbEID && lpEID) // means this is a preexisting entry not a new one
        {
            for(i=0;i<ulcPropsMU;i++)
            {
                if(lpspvMU[i].ulPropTag == PR_WAB_FOLDER_PARENT || lpspvMU[i].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP)
                {
                    LPSBinary lpsbOldParent = &(lpspvMU[i].Value.MVbin.lpbin[0]);

                    // an item can only have one folder parent 
                    if( lpFolderEntryID && cbFolderEntryID &&
                        cbFolderEntryID == lpsbOldParent->cb &&
                        !memcmp(lpFolderEntryID, lpsbOldParent->lpb, cbFolderEntryID))
                    {
                        //old is same as new .. don't need to do anything
                        hr = S_OK;
                        goto out;
                    }

                    // Remove this item from its old Parents list of contents
                    RemoveEntryFromFolder(lpIAB, lpsbOldParent, cbEID, lpEID);

                    // an item can only have one folder parent 
                    if(lpFolderEntryID && cbFolderEntryID)
                    {
                        LPBYTE lpb = NULL;
                        // overwrite the old setting
                        if(!MAPIAllocateMore(cbFolderEntryID, lpspvMU, (LPVOID *)&lpb))
                        {
                            lpspvMU[i].Value.MVbin.lpbin[0].cb = cbFolderEntryID;
                            lpspvMU[i].Value.MVbin.lpbin[0].lpb = lpb;
                            CopyMemory(lpspvMU[i].Value.MVbin.lpbin[0].lpb, lpFolderEntryID, cbFolderEntryID);
                            lpMU->lpVtbl->SetProps(lpMU, ulcPropsMU, lpspvMU, NULL);
                        }
                    }

                    bFound = TRUE;
                    break;
                }
            }
        }
        if(!bFound)
        {
            // Didnt find an old parent in which case, if this is a valid folder we
            // are dropping it on (and not a root item) then add a new property 
            // with new parent
            if(lpFolderEntryID && cbFolderEntryID) 
            {
                LPSPropValue lpPropFP = NULL;

                if(!MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID *)&lpPropFP))
                {
                    lpPropFP->ulPropTag = PR_WAB_FOLDER_PARENT;
                    lpPropFP->Value.MVbin.cValues = 0;
                    lpPropFP->Value.MVbin.lpbin = NULL;
                    if(!HR_FAILED(AddPropToMVPBin( lpPropFP, 0, lpFolderEntryID, cbFolderEntryID, FALSE)))
                        lpMU->lpVtbl->SetProps(lpMU, 1, lpPropFP, NULL);
                }
                if(lpPropFP)
                    MAPIFreeBuffer(lpPropFP);
            }
        }
        else
        {
            // We did find an old parent 
            // If the new parent is the root, then we basically need to remove the
            // old parent property
            SizedSPropTagArray(2, tagaFolderParent) =
            {
                2, 
                {
                    PR_WAB_FOLDER_PARENT,
                    PR_WAB_FOLDER_PARENT_OLDPROP
                }
            };
            if(!lpFolderEntryID || !cbFolderEntryID) 
                lpMU->lpVtbl->DeleteProps(lpMU, (LPSPropTagArray) &tagaFolderParent, NULL);
        }
    }
out:
    FreeBufferAndNull(&lpspvMU);

    return hr;
}

/*
-   AddEntryToFolder
-
*
*
*/
HRESULT AddEntryToFolder(LPADRBOOK lpAdrBook,
                         LPMAPIPROP lpMailUser,
                        ULONG cbFolderEntryId,
                        LPENTRYID lpFolderEntryId,
                        DWORD cbEID,
                        LPENTRYID lpEID)
{
    HRESULT hr = E_FAIL;
    ULONG ulObjType;
    SCODE sc;
    ULONG i;
    SBinary sb = {0};
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    
    // ignore additions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(lpIAB))
        return S_OK;

    // Check for a cycle of a folder being added to itself .. this is possible
    if(cbEID && lpEID && cbFolderEntryId && lpFolderEntryId)
    {
        SBinary sb = {0};
        IsWABEntryID(cbFolderEntryId, lpFolderEntryId, 
                 (LPVOID*)&sb.lpb,(LPVOID*)&sb.cb,NULL,NULL,NULL);
        if( sb.cb == cbEID && !memcmp(lpEID, sb.lpb, cbEID) )
            return S_OK;
    }

    if(cbFolderEntryId && lpFolderEntryId)
    {
        if(HR_FAILED(hr = AddItemEIDToFolderParent(lpIAB,
                                 cbFolderEntryId,
                                 lpFolderEntryId,
                                 cbEID, lpEID)))
            goto out;

    }

    // 2. Open the object we added to this folder 
    // Need to update its folder parent and also need to remove it from the old folder parent
    //
    if(lpMailUser || (cbEID && lpEID))
    {
        LPMAPIPROP lpMU = NULL;

        if(lpMailUser)
            lpMU = lpMailUser;
        else
        {
            if (HR_FAILED(hr = lpIAB->lpVtbl->OpenEntry(    lpIAB, cbEID, lpEID,
                                                            NULL,  MAPI_MODIFY, &ulObjType, 
                                                            (LPUNKNOWN *)&lpMU)))
            {
                DebugPrintError(( TEXT("IAB->OpenEntry: %x"), hr));
                goto out;
            }
        }

        if(!HR_FAILED(hr = AddFolderParentEIDToItem(lpIAB, cbFolderEntryId, lpFolderEntryId, lpMU,
                                                    cbEID, lpEID)))
        {
            // if we were given a mailuser to work with, don't bother calling SaveChanges from here just yet
            if(lpMU && lpMU!=lpMailUser)
            {
                lpMU->lpVtbl->SaveChanges(lpMU, KEEP_OPEN_READWRITE);
                lpMU->lpVtbl->Release(lpMU);
            }
        }
    }
out:

    return hr;
}

//$$////////////////////////////////////////////////////////////////////////////
//
// AddEntryToGroup - Adds given entryID to given group or folder
//
// cbGroupEntryID,cbGroupEntryID - entryid of group
// cbEID, lpEID, - entryid of new entry
//  ulObjectType = MAPI_ABCONT or MAPI_DISTLIST
//
//////////////////////////////////////////////////////////////////////////////
HRESULT AddEntryToContainer(LPADRBOOK lpAdrBook,
                        ULONG ulObjectType,
                        ULONG cbGEID,
                        LPENTRYID lpGEID,
                        DWORD cbEID,
                        LPENTRYID lpEID)
{
    if(ulObjectType == MAPI_ABCONT)
        return AddEntryToFolder(lpAdrBook,  NULL, cbGEID, lpGEID, cbEID, lpEID);
    else
        return AddEntryToGroupEx(lpAdrBook, cbGEID, lpGEID, cbEID, lpEID);
}


//$$////////////////////////////////////////////////////////////////////////////
//
// AddNewObjectTOListViewEx - Triggered by the NewContact menus and buttons -
//                          calls newentry and then adds the returned item to
//                          the list view
//
//  lpIAB - AddrBook object
//  hWndLV - handle of List View
//  ulObjectType - MailUser or DistList
//  SortInfo - Current Sort parameters
//  lppContentsList - Current ContentsList
//  lpftLast - WAB file time at last update
//  LPULONG - lpcbEID
//  LPPENTRYID - lppEntryID
//////////////////////////////////////////////////////////////////////////////
HRESULT AddNewObjectToListViewEx(LPADRBOOK lpAdrBook,
                                HWND hWndLV,
                                HWND hWndTV,
                                HTREEITEM hSelItem,
                                LPSBinary lpsbContainerEID,
                                ULONG ulObjectType,
                                SORT_INFO * lpSortInfo,
                                LPRECIPIENT_INFO * lppContentsList,
                                LPFILETIME lpftLast,
                                LPULONG lpcbEID,
                                LPENTRYID * lppEID)
{
	ULONG cbEID=0, cbEIDContainer = 0;
	LPENTRYID lpEID=NULL, lpEIDContainer = NULL;

    HRESULT hr = hrSuccess;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;
    ULONG ulObjTypeCont = 0;
    SBinary  sbContEID = {0};
    SBinary sbGroupEID = {0};
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    ULONG ulEIDPAB = 0;
    LPENTRYID lpEIDPAB = NULL;

    if (ulObjectType!=MAPI_MAILUSER && ulObjectType!=MAPI_DISTLIST)
        goto out;

    // Check if the currently selected TV item is a container or a group
    // and get the corresponding entryid
    //
    if(lpsbContainerEID)
    {
        SetSBinary(&sbContEID, lpsbContainerEID->cb, lpsbContainerEID->lpb);
    }
    else if(hWndTV)
    {
        HTREEITEM hItem = hSelItem ? hSelItem : TreeView_GetSelection(hWndTV);
        TV_ITEM tvI = {0};

        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        tvI.hItem = hItem;
        TreeView_GetItem(hWndTV, &tvI);
        if(tvI.lParam)
        {
            LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
            if(lptvStuff)
            {
                ulObjTypeCont = lptvStuff->ulObjectType;
                if(lptvStuff->ulObjectType == MAPI_DISTLIST)
		        {
		            // Bug 50029
		            if(lptvStuff->lpsbEID)
			            SetSBinary(&sbGroupEID, lptvStuff->lpsbEID->cb, lptvStuff->lpsbEID->lpb);
		            if(lptvStuff->lpsbParent)
			            SetSBinary(&sbContEID, lptvStuff->lpsbParent->cb, lptvStuff->lpsbParent->lpb);
                }
                else // current selection is a container
                {
                    if(lptvStuff->lpsbEID)
                        SetSBinary(&sbContEID, lptvStuff->lpsbEID->cb, lptvStuff->lpsbEID->lpb);
                }
            }
        }
    }
    else 
    {
        if(HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &ulEIDPAB, &lpEIDPAB)))
            goto out;
        sbContEID.cb = ulEIDPAB;
        sbContEID.lpb = (LPBYTE)lpEIDPAB;
    }

    if(HR_FAILED(hr = HrGetWABTemplateID(   lpAdrBook,
                                            ulObjectType,
                                            &cbTplEID,
                                            &lpTplEID)))
    {
        DebugPrintError(( TEXT("HrGetWABTemplateID failed: %x\n"), hr));
        goto out;
    }

    if(sbContEID.cb && sbContEID.lpb)
    {
        cbEIDContainer = sbContEID.cb;
        lpEIDContainer = (LPENTRYID) sbContEID.lpb;
    }

	if (HR_FAILED(hr = lpAdrBook->lpVtbl->NewEntry(	lpAdrBook,
				            					(ULONG_PTR) GetParent(hWndLV),
							            		0,
									            cbEIDContainer,
                                                lpEIDContainer,
									            cbTplEID,lpTplEID,
									            &cbEID,&lpEID)))
    {
        DebugPrintError(( TEXT("NewEntry failed: %x\n"),hr));
        goto out;
    }
	
    // Update the wab file write time so the timer doesn't
    // catch this change and refresh.
    //if (lpftLast) {
    //    CheckChangedWAB(((LPIAB)lpIAB)->lpPropertyStore, lpftLast);
    //}


	if (cbEID && lpEID)
	{
		if(	AddWABEntryToListView(	lpAdrBook, hWndLV, cbEID, lpEID, lppContentsList))
		{
            if(lpSortInfo)
                SortListViewColumn( lpIAB, hWndLV, 0, lpSortInfo, TRUE);
		}
	}

    if(sbGroupEID.cb != 0  && ulObjectType==MAPI_MAILUSER)
    {
        // Need to add this new object to the currently selected distribution list
        // Only if this item is a mailuser
        AddEntryToGroupEx(lpAdrBook, sbGroupEID.cb, (LPENTRYID) sbGroupEID.lpb, cbEID, lpEID);
    }

    if(lpcbEID)
        *lpcbEID = cbEID;
    if(lppEID)
        *lppEID = lpEID; // Callers responsibility to free
out:
    LocalFreeAndNull((LPVOID *) (&sbGroupEID.lpb));
    // [PaulHi] 12/16/98  Crash fix hack.  If lpEIDPAB is non-NULL then 
    // this means lpEIDPAB == sbContEID.lpb and is MAPIAllocBuffer allocated.
    // Don't deallocate twice and make sure we deallocate with correct function.
    // Otherwise sbContEID.lpb is a LocalAlloc allocation.
    if (lpEIDPAB)
    {
        FreeBufferAndNull(&lpEIDPAB);
        sbContEID.lpb = NULL;
    }
    else
        LocalFreeAndNull((LPVOID *) (&sbContEID.lpb));
    if(!lppEID)
        FreeBufferAndNull(&lpEID);
    FreeBufferAndNull(&lpTplEID);
    return hr;
}


/*
-   AddExtendedSendMailToItems
-
*   If there is only 1 item selected in the ListView and that item has
*   multiple email addresses, we populate the Send Mail To item with 
*   the multiple email addresses ..
*   If there is more than 1 item selected or the item doesn't have 
*   multiple email addresses, we will hide the Send Mail To item
*   The SendMailTo item should be the second last in the list ...
*
*   bAddItems - if TRUE means attempt to add items; if FALSE means remove the SendMailTo item
*/
void AddExtendedSendMailToItems(LPADRBOOK lpAdrBook, HWND hWndLV, HMENU hMenuAction, BOOL bAddItems)
{
    int nSendMailToPos = 1; // assumes IDM_SENDMAILTO is the second item in the list
    int nSelected = ListView_GetSelectedCount(hWndLV);
    HMENU hMenuSMT = GetSubMenu(hMenuAction, nSendMailToPos);
    int nMenuSMT = GetMenuItemCount(hMenuSMT);
    BOOL bEnable = FALSE;

    if(nMenuSMT > 0) // Assumes there is only 1 default item in the SendMailTO popup menu
    {
        // there is some left over garbage here which we need to clear
        int j = 0;
        for(j=nMenuSMT-1;j>=0;j--)
            RemoveMenu(hMenuSMT, j, MF_BYPOSITION);
    }

    if(bAddItems && nSelected == 1)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
        if (lpItem)
        {
            ULONG ulcValues = 0;
            LPSPropValue lpPropArray = NULL;
            SizedSPropTagArray(3, MUContactAddresses)=
            {
                3, { PR_CONTACT_EMAIL_ADDRESSES, PR_OBJECT_TYPE, PR_EMAIL_ADDRESS }
            };
            if(!HR_FAILED(HrGetPropArray(lpAdrBook, (LPSPropTagArray)&MUContactAddresses,
                                         lpItem->cbEntryID, lpItem->lpEntryID,
                                         MAPI_UNICODE,
                                         &ulcValues, &lpPropArray)))
            {
                if(ulcValues && lpPropArray)
                {
                    if( lpPropArray[1].ulPropTag == PR_OBJECT_TYPE &&
                        lpPropArray[1].Value.l == MAPI_MAILUSER )
                    {
                        if( lpPropArray[0].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES &&
                            lpPropArray[0].Value.MVbin.cValues > 1)
                        {
                            ULONG i;
                            LPTSTR lpDefEmail = (lpPropArray[2].ulPropTag == PR_EMAIL_ADDRESS) ? lpPropArray[2].Value.LPSZ : szEmpty;
                            for(i=0;i<lpPropArray[0].Value.MVSZ.cValues;i++)
                            {
                                TCHAR sz[MAX_PATH * 2];
                                LPTSTR lpEmail = lpPropArray[0].Value.MVSZ.LPPSZ[i];
                                if(!lstrcmpi(lpEmail, lpDefEmail))
                                {
                                    TCHAR sz1[MAX_PATH];
                                    LoadString(hinstMapiX, idsDefaultEmail, sz1, ARRAYSIZE(sz1));
                                    CopyTruncate(sz, lpEmail, ARRAYSIZE(sz)-lstrlen(sz1)-10);
                                    StrCatBuff(sz, TEXT("  "), ARRAYSIZE(sz));
                                    StrCatBuff(sz, sz1, ARRAYSIZE(sz));
                                    lpEmail = sz;
                                }
                                if(i < IDM_SENDMAILTO_MAX)
                                    InsertMenu( hMenuSMT, nMenuSMT+1, MF_STRING | MF_BYPOSITION,
                                                IDM_SENDMAILTO_START+1+i, // we add an extra 1 here because IDM_SENDMAILTO_START is not a allowed ID here
                                                lpEmail);
                            }
                            bEnable = TRUE;
                        }
                    }
                    MAPIFreeBuffer(lpPropArray);                
                }
            }
        }        
    }

    EnableMenuItem(hMenuAction, nSendMailToPos, MF_BYPOSITION | (bEnable ? MF_ENABLED : MF_GRAYED));
	//RemoveMenu(hMenuAction, nSendMailToPos, MF_BYPOSITION);
}

/*
-
- AddFolderListToMenu - Creates a FOlder menu from which we can choose folder items
*   Items are checked if they are shared and unchecked if they are not shared ..
*   The user can choose to share or un-share any particular folder
*
*/
void AddFolderListToMenu(HMENU hMenu, LPIAB lpIAB)
{
    LPWABFOLDER lpFolder = lpIAB->lpWABFolders;
    int nPos = 0;
    int nCount = GetMenuItemCount(hMenu);
    
    if(!bDoesThisWABHaveAnyUsers(lpIAB))
        return;

    while(nCount>0)
        RemoveMenu(hMenu, --nCount, MF_BYPOSITION);

    while(lpFolder)
    {
        BOOL bChecked = lpFolder->bShared;
        InsertMenu( hMenu, nPos, MF_STRING | MF_BYPOSITION | (bChecked ? MF_CHECKED : MF_UNCHECKED),
                    lpFolder->nMenuCmdID, lpFolder->lpFolderName);
        lpFolder = lpFolder->lpNext;
        nPos++;
    }
}

//$$////////////////////////////////////////////////////////////////////////////
//
//  ShowLVContextMenu -  Customizes and displays the context menu for various list
//                          views in the UI
//
//  LV      - app defined constant identifing the List View
//  hWndLV  - Handle of List View
//  hWndLVContainer - Handle of the List containing the containers
//  lParam  - WM_CONTEXTMENU lParam passed on to this function
//  lpVoid  - some List Views need more parameters than other list views - pass them
//              in this parameter
//  lpIAB   - AdrBook object
//
//////////////////////////////////////////////////////////////////////////////
int ShowLVContextMenu(int LV, // idicates which list view this is
					   HWND hWndLV,
                       HWND hWndLVContainer,
					   LPARAM lParam,  // contains the mouse pos info when called from WM_CONTEXTMENU
                       LPVOID lpVoid,
                       LPADRBOOK lpAdrBook,
                       HWND hWndTV)  //misc stuff we want to pass in
{
    int idMenu = 0, nPosAction = 0, nPosNew = 0;
    LPIAB lpIAB = (LPIAB) lpAdrBook;
	HMENU hMenu = NULL;//LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_LVCONTEXT));
	HMENU hMenuTrackPopUp = NULL;//GetSubMenu(hMenu, 0);
    HMENU hMenuAction = NULL;//GetSubMenu(hMenuTrackPopUp, posAction);
    HMENU hMenuNewEntry = NULL;//GetSubMenu(hMenuTrackPopUp, posNew);
    HMENU hm = NULL;
    int nret = 0;
    BOOL bState[tbMAX];
    int i=0;
    TCHAR tszBuf[MAX_UI_STR];

    switch(LV) /**WARNING - these menu sub pop up positions are HARDCODED so should be in sync with the resource**/
    {
    case lvToolBarAction:
    case lvToolBarNewEntry:
    case lvMainABView:
        idMenu = IDR_MENU_LVCONTEXT_BROWSE_LV;
        nPosAction = 5;
        nPosNew = 0;
        break;

    case lvDialogABContents:    // Modeless address view LV
    case lvDialogModalABContents:    // Modal addres vuew LV
        idMenu = IDR_MENU_LVCONTEXT_SELECT_LIST;
        nPosAction = 6;
        nPosNew = 4;
        break;

    case lvDialogABTo:               // To Well LV
    case lvDialogABCC:               // CC Well LV
    case lvDialogABBCC:              // BCC Well LV
    case lvDialogDistList:           // Disttribution list UI LV
    case lvDialogResolve:
        idMenu = IDR_MENU_LVCONTEXT_DL_LV;
        nPosAction = 0;
        nPosNew = -1;
        break;

    case lvDialogFind:               // Find dialog results LV
        idMenu = IDR_MENU_LVCONTEXT_FIND_LV;
        nPosNew = -1;
        nPosAction = 0;
        break;

    case lvMainABTV:
        idMenu = IDR_MENU_LVCONTEXT_TV;
        nPosNew = 0;
        nPosAction = -1;
        break;
#ifdef COLSEL_MENU 
    case lvMainABHeader:
        idMenu = IDR_MENU_LVCONTEXTMENU_COLSEL;
        nPosNew = 0;
        nPosAction = -1;
#endif
    }

	hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(idMenu));
	hMenuTrackPopUp = GetSubMenu(hMenu, 0);

    if (!hMenu || !hMenuTrackPopUp)
	{
		DebugPrintError(( TEXT("LoadMenu failed: %x\n"),GetLastError()));
		goto out;
	}

    if(nPosAction != -1)
        hMenuAction = GetSubMenu(hMenuTrackPopUp, nPosAction);
    if(nPosNew != -1)
        hMenuNewEntry = GetSubMenu(hMenuTrackPopUp, nPosNew);

    if(hMenuAction)
        AddExtendedMenuItems(lpAdrBook, hWndLV, hMenuAction, FALSE, 
                            (LV != lvMainABTV)); // this is the condition for updating SendMailTo items

	if(LV == lvMainABTV)
	{
		// everything on except Copy
		for(i=0;i<tbMAX;i++)
			bState[i] = TRUE;
		if(ListView_GetItemCount(hWndLV) <= 0)
			bState[tbPrint] = /*bState[tbAction] =*/ FALSE;
        // [PaulHi] 12/1/98  New Paste context menu item
        bState[tbPaste] = bIsPasteData();
	}
	else
    // get the current dialog state based on the current container and the
    // current list view - this is basically important only for the address
    // book views ...
        GetCurrentOptionsState( hWndLVContainer, hWndLV, bState);


	// we now customize the menu depending on which list box this is
	
    switch(LV)
	{
    case lvDialogFind: // Find Dialog List View
        // Set Add to Address Book to grey if this was a local search
        if(!bState[tbAddToWAB])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_ADDTOWAB,MF_BYCOMMAND | MF_GRAYED);
        // Set Delete to grey if this was a LDAP search
        if(!bState[tbDelete])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_DELETE,MF_BYCOMMAND | MF_GRAYED);
        break;

	case lvMainABTV:
        // [PaulHi] 12/1/98  Enable/disable Paste item, as required
        if(!bState[tbPaste])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PASTE,MF_BYCOMMAND | MF_GRAYED);
        // Do folder stuff here
        {
            LPWABFOLDER lpUserFolder = (LPWABFOLDER) lpVoid;
            if(lpUserFolder || !bDoesThisWABHaveAnyUsers(lpIAB)) // if a user folder was clicked or if this wab doesn't have user folder, no sense in sharing ..
            {
#ifdef FUTURE
            	RemoveMenu(hMenuTrackPopUp, 3, MF_BYPOSITION); //Folders seperator
            	RemoveMenu(hMenuTrackPopUp, 2, MF_BYPOSITION); //Folder seperator
#endif // FUTURE
            }
            else if(!lpIAB->lpWABFolders) // no sub-folders at all
            {
            	EnableMenuItem(hMenuTrackPopUp, 2, MF_BYPOSITION | MF_GRAYED); //Folder item
            	EnableMenuItem(hMenuTrackPopUp, 3, MF_BYPOSITION | MF_GRAYED); //Folder item
            }
            else
            {
                int nFolder = 2;
#ifdef FUTURE
                HMENU hMenuFolders = GetSubMenu(hMenuTrackPopUp, nFolder); //idmFolders
                AddFolderListToMenu(hMenuFolders, lpIAB);
#endif // FUTURE
            }
        }
        break; 

	case lvMainABView: //main view
		// For this one - we dont need the wells and
        if(!bState[tbPaste])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PASTE,MF_BYCOMMAND | MF_GRAYED);
        if(!bState[tbCopy])
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_COPY,MF_BYCOMMAND | MF_GRAYED);
        if ((!bState[tbProperties]))
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PROPERTIES,MF_BYCOMMAND | MF_GRAYED);
        if((!bState[tbDelete]))
            EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_DELETE,MF_BYCOMMAND | MF_GRAYED);
        break;

    case lvDialogModalABContents:
	case lvDialogABContents: //address book dialog contents list view
		//here we want the option to put it in to,cc,bcc
		//in the menu - we also want new contact/new group/properties
		// no delete unless this is DialogModal
        if(LV != lvDialogModalABContents)
		    RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_DELETE, MF_BYCOMMAND);

        // figure out some way to read the items on the dlg to figure out
		// how many wells to show and what to put in them ...
        {
            LPADRPARM lpAP = (LPADRPARM) lpVoid;
            if (lpAP)
            {
                switch(lpAP->cDestFields)
                {
                case 0:
            		RemoveMenu(hMenuTrackPopUp, 3, MF_BYPOSITION); //seperator
            		RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_ADDWELL1, MF_BYCOMMAND);
                case 1:
            		RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_ADDWELL2, MF_BYCOMMAND);
                case 2:
            		RemoveMenu(hMenuTrackPopUp, IDM_LVCONTEXT_ADDWELL3, MF_BYCOMMAND);
                    break;
                }

                if((lpAP->cDestFields > 0) && lpAP->lppszDestTitles)
                {
                    ULONG i;
                    // update the text of the menu with the button text
                    for(i=0;i<lpAP->cDestFields;i++)
                    {
                        int id;
                        switch(i)
                        {
                        case 0:
                            id = IDM_LVCONTEXT_ADDWELL1;
                            break;
                        case 1:
                            id = IDM_LVCONTEXT_ADDWELL2;
                            break;
                        case 2:
                            id = IDM_LVCONTEXT_ADDWELL3;
                            break;
                        }

                        // [PaulHi] 2/15/99  Check whether lpAP is ANSI or UNICODE
                        {
                            LPTSTR  lptszDestTitle = NULL;
                            BOOL    bDestAllocated = FALSE;

                            if (lpAP->ulFlags & MAPI_UNICODE)
                                lptszDestTitle = lpAP->lppszDestTitles[i];
                            else
                            {
                                // Convert single byte string to double byte
                                lptszDestTitle = ConvertAtoW((LPSTR)lpAP->lppszDestTitles[i]);
                                bDestAllocated = TRUE;
                            }

                            if (lptszDestTitle)
                            {
                                ULONG   iLen = TruncatePos(lptszDestTitle, MAX_UI_STR - 5);
                                CopyMemory(tszBuf, lptszDestTitle, sizeof(TCHAR)*iLen);
                                tszBuf[iLen] = '\0';
                                StrCatBuff(tszBuf, szArrow, ARRAYSIZE(tszBuf));
                                if (bDestAllocated)
                                    LocalFreeAndNull(&lptszDestTitle);
                            }
                            else
                                *tszBuf = '\0';
                        }

                        ModifyMenu( hMenuTrackPopUp, /*posTo + */i, MF_BYPOSITION | MF_STRING, id, tszBuf);
                    }
                }
            }
        }
		break;

	case lvDialogABTo: //address book dialog To well
	case lvDialogABCC:	//CC well
	case lvDialogABBCC:	//BCC well
        {
            int iItemIndex = 0;
            iItemIndex = ListView_GetSelectedCount(hWndLV);
            if (iItemIndex!=1)
            {
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PROPERTIES,MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_SENDMAIL,MF_BYCOMMAND | MF_GRAYED);
            }
            if (iItemIndex<=0)
            {
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_DELETE,MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_COPY,MF_BYCOMMAND | MF_GRAYED);
            }

            //
            // The wells may contain unresolved items without entryids ..
            // If the item does not have an entryid, we want to disable properties
            //
            if (iItemIndex == 1)
            {
                // we are potentially looking at the properties of this thing
                // get the items lParam
                iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                if(iItemIndex != -1)
                {
                    LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;

                    if(lpItem &&
                       ((lpItem->cbEntryID == 0) || (lpItem->lpEntryID == NULL)))
                    {
                        EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_PROPERTIES,MF_BYCOMMAND | MF_GRAYED);
                        EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_COPY,MF_BYCOMMAND | MF_GRAYED);
                        EnableMenuItem(hMenuTrackPopUp,IDM_LVCONTEXT_SENDMAIL,MF_BYCOMMAND | MF_GRAYED);
                    }
                }
            }
        }
		break;

	case lvDialogResolve: //Resolve dialog list view

        //Rename the  TEXT("delete") to  TEXT("Show More Names .. ")
        LoadString(hinstMapiX, idsShowMoreNames, tszBuf, ARRAYSIZE(tszBuf));
        ModifyMenu( hMenuTrackPopUp,
                    IDM_LVCONTEXT_DELETE,
                    MF_BYCOMMAND | MF_STRING,
                    IDM_LVCONTEXT_DELETE,
                    tszBuf);
        //And we want a seperator before  TEXT("Show More Names")
        InsertMenu( hMenuTrackPopUp,
                    IDM_LVCONTEXT_DELETE,
                    MF_BYCOMMAND | MF_SEPARATOR,
                    IDM_LVCONTEXT_DELETE,
                    NULL);
        
        break;
#ifdef COLSEL_MENU
    case lvMainABHeader:
        {
            UINT iIndex = PtrToUlong(lpVoid);
            ULONG ulShowingColTag;
            ULONG ulOtherColTag;
            UINT i = 0, j;
            // this will always be called with iIndex == colHomePhone or colOfficePhone
            Assert( iIndex == colHomePhone || iIndex == colOfficePhone );
            if( PR_WAB_CUSTOMPROP1 == 0 )
                PR_WAB_CUSTOMPROP1 = PR_HOME_TELEPHONE_NUMBER;
            if( PR_WAB_CUSTOMPROP2 == 0)
                PR_WAB_CUSTOMPROP2 = PR_OFFICE_TELEPHONE_NUMBER;
            ulShowingColTag = (colHomePhone == iIndex) ? PR_WAB_CUSTOMPROP1 : PR_WAB_CUSTOMPROP2;
            ulOtherColTag   = (ulShowingColTag == PR_WAB_CUSTOMPROP1) ? PR_WAB_CUSTOMPROP2 : PR_WAB_CUSTOMPROP1;

            // lets remove the tag that is displayed in the other col
            for( i = 0; i < MAXNUM_MENUPROPS; i++)
            {
                if( MenuToPropTagMap[i] == ulOtherColTag )
                {
                    if( RemoveMenu( hMenuTrackPopUp, i, MF_BYPOSITION) )
                        break;
                    else
                        DebugTrace( TEXT("could not remove menu: %x\n"), GetLastError() );
                }            
            }
            if( i == MAXNUM_MENUPROPS ) 
                DebugTrace( TEXT("Did not find other col's prop tag\n"));
            if( ulShowingColTag != ulOtherColTag )
            {
                UINT iMenuEntry;
                // potential bug, if someone sets value in registry 
                // then could have two columns with the same name and that 
                // would be bad because we would be looking for an entry 
                // that does not exist           
                for( j = 0; j < MAXNUM_MENUPROPS; j++)
                {
                    if( ulShowingColTag == MenuToPropTagMap[j] )    
                    {                
                        // num of items that can be in column heads
                        Assert( j != i ); // both cols have same value, bad!
                        iMenuEntry = ( j > i ) ? j - 1 : j;
                        CheckMenuRadioItem( hMenuTrackPopUp, 
                            0, 
                            MAXNUM_MENUPROPS - 1, // minus one because there will be one missing
                            iMenuEntry,
                            MF_BYPOSITION);
                        break;
                    }                
                }
                if( j == MAXNUM_MENUPROPS )
                {
                    DebugTrace( TEXT("Did not find match for checkbutton \n"));
                }
            }
        }
#endif // COLSEL_MENU
        }
        //
    // Popup the menu - if this was a toolbar action just pop up the submenu
    //
    if(LV == lvToolBarAction)
        hm = hMenuAction;
    else if(LV == lvToolBarNewEntry)
        hm = hMenuNewEntry;
    else
        hm = hMenuTrackPopUp;

    if(hMenuNewEntry)
    {
        if(!bIsWABSessionProfileAware((LPIAB)lpIAB) ||
           LV == lvDialogABTo || LV == lvDialogABCC || 
           LV == lvDialogABBCC || LV == lvDialogModalABContents || 
           LV == lvDialogABContents )
        {
            RemoveMenu(hMenuNewEntry, 2, MF_BYPOSITION); // remove new folder option
        }
        else
        {
            // Since this could be a rt-click menu, check the drophighlight else the selection
            //EnableMenuItem(hMenuNewEntry,2,MF_BYPOSITION | MF_ENABLED);
            //if(hWndTV && bDoesThisWABHaveAnyUsers((LPIAB)lpIAB))
            //{
            //    if(TreeView_GetDropHilight(hWndTV))
            //        EnableMenuItem( hMenuNewEntry,2,
            //        MF_BYPOSITION | (TreeView_GetDropHilight(hWndTV)!=TreeView_GetRoot(hWndTV) ? MF_ENABLED : MF_GRAYED));
            //else if(TreeView_GetSelection(hWndTV) == TreeView_GetRoot(hWndTV))
            //    EnableMenuItem(hMenuNewEntry,2,MF_BYPOSITION | MF_GRAYED);
            //}
        }
    }

    nret = TrackPopupMenu(	hm, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					LOWORD(lParam), HIWORD(lParam),
					0, GetParent(hWndLV), NULL);
	DestroyMenu(hMenu);
/*
    nret = TrackPopupMenuEx(hm, TPM_RETURNCMD | TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					LOWORD(lParam), HIWORD(lParam), GetParent(hWndLV), NULL);
	DestroyMenu(hMenu);
*/
out:

	return nret;
}



//$$/////////////////////////////////////////////////////////////
//
// GetChildClientRect - Gets the child's coordinates in its parents
//                      client units
//
//  hWndChild   - handle of child
//  lprc        - returned RECT.
//
///////////////////////////////////////////////////////////////
void GetChildClientRect(HWND hWndChild, LPRECT lprc)
{
    RECT rc;
    POINT ptTop,ptBottom;
    HWND hWndParent;

    ZeroMemory(lprc, sizeof(*lprc));

    if(!hWndChild)
        goto out;

    hWndParent = GetParent(hWndChild);

    if(!hWndParent)
        goto out;

    GetWindowRect(hWndChild,&rc);
    //
    //This api working in both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hWndParent, (LPPOINT)&rc, 2);    
    ptTop.x = rc.left;
    ptTop.y = rc.top;
    ptBottom.x = rc.right;
    ptBottom.y = rc.bottom;
    (*lprc).left = ptTop.x;
    (*lprc).top = ptTop.y;
    (*lprc).right = ptBottom.x;
    (*lprc).bottom = ptBottom.y;
out:
    return;
}


//$$/////////////////////////////////////////////////////////////
//
// DoLVQuickFind -  Simple quick find routine for matching edit box contents to
//                  List view entries
//
//  hWndEdit - handle of Edit Box
//  hWndLV  - handle of List View
//
///////////////////////////////////////////////////////////////
void DoLVQuickFind(HWND hWndEdit, HWND hWndLV)
{
	TCHAR szBuf[MAX_PATH] = TEXT("");
	int iItemIndex = 0;
    LV_FINDINFO lvF = {0};

    lvF.flags = LVFI_PARTIAL | LVFI_STRING | LVFI_WRAP;

    if(!GetWindowText(hWndEdit,szBuf,ARRAYSIZE(szBuf)))
		return;
	
	TrimSpaces(szBuf);
	
	if(lstrlen(szBuf))
	{
		lvF.psz = szBuf;
		iItemIndex = ListView_FindItem(hWndLV,-1, &lvF);
        //if (iItemIndex < 0) iItemIndex = 0;
		if(iItemIndex != -1)
		{
			ULONG cSel=0;
			cSel = ListView_GetSelectedCount(hWndLV);

			if(cSel)
			{
				// is there anything else selected ? - deselect and and
				// select this item ...

				int iOldItem = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
				while(iOldItem != -1)
				{
					ListView_SetItemState ( hWndLV,         // handle to listview
											iOldItem,         // index to listview item
											0, // item state
											LVIS_FOCUSED | LVIS_SELECTED);
					iOldItem = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
				}

			}

            LVSelectItem ( hWndLV,  iItemIndex);
		}

	}
	return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////////
//
// HrGetPropArray - for a selected resolved property (either in select_recipient or
//                  pick_user mode ... get the list of minimum required props as well
//                  as desired props (if they exist)
//
// lpIAB            - AddrBook Object
// hPropertyStore   - handle to prop store
// lpPTA            - Array of props to return - NULL to return ALL the props
// cbEntryID, lpEntryID - id of object
// ulFlags          - 0 or MAPI_UNICODE
// cValues, lppPropArray - returned props
//
//////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetPropArray( LPADRBOOK lpAdrBook,
                        LPSPropTagArray lpPTA,
                        ULONG cbEntryID,
                        LPENTRYID lpEntryID,
                        ULONG ulFlags,
                        ULONG * lpcValues,
                        LPSPropValue * lppPropArray)
{
    HRESULT hr = hrSuccess;
    LPMAPIPROP lpMailUser = NULL;
    LPSPropValue lpPropArray = NULL;
    ULONG ulObjType;
    ULONG cValues;

    *lppPropArray = NULL;

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                    cbEntryID,    // cbEntryID
                                                    lpEntryID,    // entryid
                                                    NULL,         // interface
                                                    0,                // ulFlags
                                                    &ulObjType,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugTraceResult( TEXT("Address: IAB->OpenEntry:"), hr);
        goto exit;
    }

    Assert(lpMailUser);

    //TBD - Check ObjectType here

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    (LPSPropTagArray)lpPTA,   // lpPropTagArray
                                                    ulFlags,
                                                    &cValues,     // how many properties were there?
                                                    &lpPropArray)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto exit;
    }

    *lppPropArray = lpPropArray;
    *lpcValues = cValues;

exit:

    if (HR_FAILED(hr))
    {
        if (lpPropArray)
            MAPIFreeBuffer(lpPropArray);
    }

    if (lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);

    return hr;

}

//$$///////////////////////////////////////////////////////////////
//
// SubStringSearchEx - Same as SubStringSearch except it does some
//          language related processing and mapping of dbcs input
//          strings etc
//
//  pszTarget   - Target string
//  pszSearch   - SubString to Search for
//
// returns - TRUE if match found
//           FALSE if no match
//
/////////////////////////////////////////////////////////////////
BOOL SubstringSearchEx(LPTSTR pszTarget, LPTSTR pszSearch, LCID lcid)
{
    if(!pszTarget && !pszSearch)
        return TRUE;
    if(!pszTarget || !pszSearch)
        return FALSE;
    if(lcid)
    {
        LPTSTR lpTH = NULL, lpSH = NULL;
        int nLenTH = 0, nLenSH = 0;

        LPTSTR lpT = NULL, lpS = NULL;

        BOOL bRet = FALSE;

        // Looks like this will have to be a two step process
        // First convert all half-width characters to full-width characters
        // Then convert all full-width katakana to full-width hirangana

        // Step 1. Convert half width and full width katakana to hiragana to full width
        int nLenT = LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszTarget, lstrlen(pszTarget)+1, lpT, 0);
        int nLenS = LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszSearch, lstrlen(pszSearch)+1, lpS, 0);

        lpT = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenT+1));
        lpS = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenS+1));

        if(!lpT || !lpS)
            goto err;

        LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszTarget, lstrlen(pszTarget)+1, lpT, nLenT);
        LCMapString(lcid, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, pszSearch, lstrlen(pszSearch)+1, lpS, nLenS);

        lpS[nLenS]=lpT[nLenT]='\0';

        // Step 2. Convert all to Half Width Hirangana
        nLenTH = LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpT, lstrlen(lpT)+1, lpTH, 0);
        nLenSH = LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpS, lstrlen(lpS)+1, lpSH, 0);

        lpTH = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenTH+1));
        lpSH = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLenSH+1));

        if(!lpTH || !lpSH)
            goto err;

        LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpT, lstrlen(lpT)+1, lpTH, nLenTH);
        LCMapString(lcid, LCMAP_HALFWIDTH | LCMAP_HIRAGANA, lpS, lstrlen(lpS)+1, lpSH, nLenSH);

        lpSH[nLenSH]=lpTH[nLenTH]='\0';


        // by now, all strings should be in Full Width Hirangana ..
        bRet = SubstringSearch(lpTH, lpSH);
err:
        if(lpT)
            LocalFree(lpT);
        if(lpS)
            LocalFree(lpS);
        if(lpTH)
            LocalFree(lpTH);
        if(lpSH)
            LocalFree(lpSH);
        return bRet;
    }
    else
        return(SubstringSearch(pszTarget, pszSearch));
}

//$$///////////////////////////////////////////////////////////////
//
// SubStringSearch - Used for doing partial resolves - Brute force
//                      search routine stolen from  Athena
//
// TBD - Is this DBCS safe .. ???
//
//  pszTarget   - Target string
//  pszSearch   - SubString to Search for
//
// returns - TRUE if match found
//           FALSE if no match
//
/////////////////////////////////////////////////////////////////
BOOL SubstringSearch(LPTSTR pszTarget, LPTSTR pszSearch)
    {
    LPTSTR pszT = pszTarget;
    LPTSTR pszS = pszSearch;

    if(!pszTarget && !pszSearch)
        return TRUE;
    if(!pszTarget || !pszSearch)
        return FALSE;
    if(!lstrlen(pszTarget) && !lstrlen(pszSearch))
        return TRUE;
    if(!lstrlen(pszTarget) || !lstrlen(pszSearch))
        return FALSE;

    while (*pszT && *pszS)
        {
        if (*pszT != *pszS &&
            (TCHAR) CharLower((LPTSTR)(DWORD_PTR)MAKELONG(*pszT, 0)) != *pszS  &&
            (TCHAR) CharUpper((LPTSTR)(DWORD_PTR)MAKELONG(*pszT, 0)) != *pszS)
            {
            pszT -= (pszS - pszSearch);
            pszT = CharNext(pszT); // dont start searching at half chars
            pszS = pszSearch;
            }
        else
            {
            pszS++;
            pszT++; // as long as the search is going on, do byte comparisons
            }
        }

    return (*pszS == 0);
    }



//$$
/****************************************************************************

    FUNCTION:	GetThreadStoragePointer()

    PURPOSE:	gets the private storage pointer for a thread, allocating one
				if it does not exist (i.e. the thread didn't go through LibMain
				THREAD_ATTACH)

	PARAMETERS:	none

	RETURNS:	a pointer to the thread's private storage
				NULL, if there was a failure (usually memory allocation failure)

****************************************************************************/
LPPTGDATA __fastcall GetThreadStoragePointer()
{
	LPPTGDATA lpPTGData=TlsGetValue(dwTlsIndex);

	// if the thread does not have a private storage, it did not go through
	// THREAD_ATTACH and we need to do this here.

	if (!lpPTGData)
	{
		DebugPrintTrace(( TEXT("GetThreadStoragePointer: no private storage for this thread 0x%.8x\n"),GetCurrentThreadId()));

        lpPTGData = (LPPTGDATA) LocalAlloc(LPTR, sizeof(PTGDATA));
	
        if (lpPTGData)
		    TlsSetValue(dwTlsIndex, lpPTGData);
	}

	return lpPTGData;

}


//$$////////////////////////////////////////////////////////////////////////
//
// HrCreateNewEntry - Creates a new mailuser or DistList
//
//  lpIAB   - handle to AdrBook object
//  hWndParent - hWnd for showing dialogs
//  ulCreateObjectType  - MailUser or DistList
//  ulFlags = CREATE_DUP_CHECK_STRICT or 0
//  cValues - PropCount of New properties from which to create
//              the object
//  lpPropArray - Props for this new object
//  lpcbEntryID, lppEntryID - returned, new entryid for newly created object
//  cbEIDContainer, lpEIDContainer - container in which to create this entry
//  ulContObjType - The container object type - this could be a DISTLIST of an ABCONT
//      if this is an ABCONT, we open the container and create the entry in the container
//      If it is a DISTLIST, we open the PAB, create the entry in the PAB and then
//          add the entry to the specified entryid
//
////////////////////////////////////////////////////////////////////////////
HRESULT HrCreateNewEntry(   LPADRBOOK   lpIAB,          //  AdrBook Object
                            HWND        hWndParent,     //  hWnd for Dialogs
                            ULONG       ulCreateObjectType,   //MAILUSER or DISTLIST
                            ULONG       cbEIDCont,
                            LPENTRYID   lpEIDCont,
                            ULONG       ulContObjType,
                            ULONG       ulFlags,
                            BOOL        bShowBeforeAdding,
                            ULONG       cValues,
                            LPSPropValue lpPropArray,
                            ULONG       *lpcbEntryID,
                            LPENTRYID   *lppEntryID )
{
    LPABCONT lpContainer = NULL;
    LPMAPIPROP lpMailUser = NULL;
    HRESULT hr  = hrSuccess;
    ULONG ulObjType = 0;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG cNewProps;
    SCODE sc = S_OK;
    ULONG nIndex;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;
    BOOL bFirst = TRUE;
    BOOL bChangesMade = FALSE;
    ULONG cbEIDContainer = 0;
    LPENTRYID lpEIDContainer = NULL;

    DebugPrintTrace(( TEXT("HrCreateNewEntry: entry\n")));

    if (    (!lpIAB) ||
            ((ulFlags != 0) && (ulFlags != CREATE_CHECK_DUP_STRICT)) ||
           ((ulCreateObjectType != MAPI_MAILUSER) && (ulCreateObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(lpcbEntryID)
        *lpcbEntryID = 0;
    if(lppEntryID)
        *lppEntryID = NULL;

    if(ulContObjType == MAPI_ABCONT && cbEIDCont && lpEIDCont)
    {
        cbEIDContainer = cbEIDCont;
        lpEIDContainer = lpEIDCont;
    }

    if(!cbEIDContainer || !lpEIDContainer)
    {
        SetVirtualPABEID((LPIAB)lpIAB, &cbWABEID, &lpWABEID);
        if (HR_FAILED(hr = lpIAB->lpVtbl->GetPAB( lpIAB, &cbWABEID, &lpWABEID)))
        {
            DebugPrintError(( TEXT("GetPAB Failed\n")));
            goto out;
        }
    }

    if (HR_FAILED(hr = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                                (cbWABEID ? cbWABEID : cbEIDContainer),
                                                (lpWABEID ? lpWABEID : lpEIDContainer),     // EntryID to open
                                                NULL,         // interface
                                                0,            // flags
                                                &ulObjType,
                                                (LPUNKNOWN *)&lpContainer)))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }

    // Opened PAB container OK

    // Get us the default creation entryids
    if (HR_FAILED(hr = lpContainer->lpVtbl->GetProps(   lpContainer,
                                                        (LPSPropTagArray)&ptaCreate,
                                                        MAPI_UNICODE,
                                                        &cNewProps,
                                                        &lpCreateEIDs)  )   )
    {
        DebugPrintError(( TEXT("Can't get container properties for WAB\n")));
        // Bad stuff here!
        goto out;
    }

    // Validate the properites
    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        DebugPrintError(( TEXT("Container Property Errors\n")));
        goto out;
    }

    if(ulCreateObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    cbTplEID = lpCreateEIDs[nIndex].Value.bin.cb;
    lpTplEID = (LPENTRYID) lpCreateEIDs[nIndex].Value.bin.lpb;

//Retry:

    if (HR_FAILED(hr = lpContainer->lpVtbl->CreateEntry(    lpContainer,
                                                            cbTplEID,
                                                            lpTplEID,
                                                            ulFlags,
                                                            &lpMailUser)))
    {
        DebugPrintError(( TEXT("Creating DISTLIST failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                                                    cValues,      // cValues
                                                    lpPropArray,  // property array
                                                    NULL)))
    {
        DebugPrintError(( TEXT("Setprops failed\n")));
        goto out;
    }


    if (    bFirst &&
            bShowBeforeAdding &&
            HR_FAILED(hr = HrShowDetails(   lpIAB,
                                            hWndParent,
                                            NULL,
                                            0, NULL,
                                            NULL, NULL,
                                            (LPMAPIPROP)lpMailUser,
                                            SHOW_OBJECT,
                                            MAPI_MAILUSER,
                                            &bChangesMade)))
    {
        goto out;
    }


    hr = lpMailUser->lpVtbl->SaveChanges( lpMailUser,
                                          KEEP_OPEN_READWRITE);
    if(HR_FAILED(hr))
    {
        switch(hr)
        {
        case MAPI_E_NOT_ENOUGH_DISK:
            hr = HandleSaveChangedInsufficientDiskSpace(hWndParent, (LPMAILUSER) lpMailUser);
            break;

        case MAPI_E_COLLISION:
            {
                LPSPropValue lpspv = NULL;
                if (bFirst &&
                    !HR_FAILED(HrGetOneProp((LPMAPIPROP)lpMailUser,
                                            PR_DISPLAY_NAME,
                                            &lpspv)))
                {
                    switch( ShowMessageBoxParam(    hWndParent,
                                                    idsEntryAlreadyExists,
                                                    MB_YESNO | MB_ICONEXCLAMATION,
                                                    lpspv->Value.LPSZ))
                    {
/***/
                    case IDNO:
                        FreeBufferAndNull(&lpspv);
                        hr = MAPI_W_ERRORS_RETURNED; //S_OK;
                        goto out;
                        break;
/***/
                    case IDYES:
                        // At this point the user may have modified the properties
                        // of this MailUser. Hence we can't discard the mailuser
                        // Instead we'll just cheat a little, change the save
                        // flag on the mailuser directly and do a SaveChanges
                        ((LPMailUser) lpMailUser)->ulCreateFlags |= (CREATE_REPLACE | CREATE_MERGE);
                        hr = lpMailUser->lpVtbl->SaveChanges(   lpMailUser,
                                                                KEEP_OPEN_READWRITE);
                        if(hr == MAPI_E_NOT_ENOUGH_DISK)
                            hr = HandleSaveChangedInsufficientDiskSpace(hWndParent, (LPMAILUSER) lpMailUser);

                        FreeBufferAndNull(&lpspv);
                        //UlRelease(lpMailUser);
                        //lpMailUser = NULL;
                        //bFirst = FALSE;
                        //goto Retry;
                        break;
                    }
                }
            }
            break;
        default:
            DebugPrintError(( TEXT("SaveChanges failed: %x\n"),hr));
            goto out;
            break;
        }
    }


    DebugObjectProps((LPMAPIPROP)lpMailUser,  TEXT("New Entry"));

    // Get the EntryID so we can return it...
    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(    lpMailUser,
                                                        (LPSPropTagArray)&ptaEid,
                                                        MAPI_UNICODE,
                                                        &cNewProps,
                                                        &lpNewProps)))
    {
        DebugPrintError(( TEXT("Can't get EntryID\n")));
        // Bad stuff here!
        goto out;
    }


    if(lpcbEntryID && lppEntryID)
    {
        *lpcbEntryID = lpNewProps[ieidPR_ENTRYID].Value.bin.cb;
        sc = MAPIAllocateBuffer(*lpcbEntryID, lppEntryID);
        if (sc != S_OK)
        {
            DebugPrintError(( TEXT("MAPIAllocateBuffer failed\n")));
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto out;
        }
        CopyMemory(*lppEntryID, lpNewProps[ieidPR_ENTRYID].Value.bin.lpb, *lpcbEntryID);
    }

    if(ulContObjType == MAPI_DISTLIST && *lpcbEntryID && *lppEntryID && cbEIDContainer && lpEIDContainer)
        AddEntryToGroupEx(lpIAB, *lpcbEntryID, *lppEntryID, cbEIDCont, lpEIDCont);

    hr = hrSuccess;

out:

    if (lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);

    if (lpNewProps)
        MAPIFreeBuffer(lpNewProps);

    if (lpCreateEIDs)
        MAPIFreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);

    if (lpWABEID)
        MAPIFreeBuffer(lpWABEID);

    return hr;
}




//$$/////////////////////////////////////////////////////////////////////
//
// HrGetWABTemplateID - Gets the WABs default Template ID for MailUsers
//                      or DistLists
//
//  lpIAB   - AdrBook Object
//  ulObjectType - MailUser or DistList
//  cbEntryID, lpEntryID - returned EntryID of this template
//
/////////////////////////////////////////////////////////////////////////
HRESULT HrGetWABTemplateID( LPADRBOOK lpAdrBook,
                            ULONG   ulObjectType,
                            ULONG * lpcbEID,
                            LPENTRYID * lppEID)
{

    LPABCONT lpContainer = NULL;
    HRESULT hr  = hrSuccess;
    SCODE sc = ERROR_SUCCESS;
    ULONG ulObjType = 0;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewProps = NULL;
    ULONG cNewProps;
    ULONG nIndex;

    DebugPrintTrace(( TEXT("HrGetWABTemplateID: entry\n")));

    if (    (!lpAdrBook) ||
           ((ulObjectType != MAPI_MAILUSER) && (ulObjectType != MAPI_DISTLIST)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpcbEID = 0;
    *lppEID = NULL;

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbWABEID, &lpWABEID)))
    {
        DebugPrintError(( TEXT("GetPAB Failed\n")));
        goto out;
    }

    if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                cbWABEID,     // size of EntryID to open
                                                lpWABEID,     // EntryID to open
                                                NULL,         // interface
                                                0,            // flags
                                                &ulObjType,
                                                (LPUNKNOWN *)&lpContainer)))
    {
        DebugPrintError(( TEXT("OpenEntry Failed\n")));
        goto out;
    }

    // Opened PAB container OK

    // Get us the default creation entryids
    if (HR_FAILED(hr = lpContainer->lpVtbl->GetProps(   lpContainer,
                                                        (LPSPropTagArray)&ptaCreate,
                                                        MAPI_UNICODE,
                                                        &cNewProps,
                                                        &lpCreateEIDs)  )   )
    {
        DebugPrintError(( TEXT("Can't get container properties for WAB\n")));
        // Bad stuff here!
        goto out;
    }

    // Validate the properites
    if (    lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
            lpCreateEIDs[icrPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        DebugPrintError(( TEXT("Container Property Errors\n")));
        goto out;
    }


    if(ulObjectType == MAPI_DISTLIST)
        nIndex = icrPR_DEF_CREATE_DL;
    else
        nIndex = icrPR_DEF_CREATE_MAILUSER;

    *lpcbEID = lpCreateEIDs[nIndex].Value.bin.cb;
    sc = MAPIAllocateBuffer(*lpcbEID,lppEID);
    if (sc != S_OK)
    {
        DebugPrintError(( TEXT("MAPIAllocateBuffer failed\n")));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    CopyMemory(*lppEID,lpCreateEIDs[nIndex].Value.bin.lpb,*lpcbEID);

out:
    if (lpCreateEIDs)
        MAPIFreeBuffer(lpCreateEIDs);

    if (lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);

    if (lpWABEID)
        MAPIFreeBuffer(lpWABEID);

    return hr;
}


//$$/////////////////////////////////////////////////////////////////////
//
// UpdateListViewItemsByName - Updates the displayed name corresponding to
//      each entry - by First Name or by Last Name depending on Sort criteria
//      Called by the Sort routine ...
//
//
/////////////////////////////////////////////////////////////////////////
void UpdateListViewItemsByName(HWND hWndLV, BOOL bSortByLastName)
{
    LV_ITEM lvi = {0};
    ULONG ulCount = 0;
    ULONG i;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = colDisplayName;
    lvi.lParam = 0;

    ulCount = ListView_GetItemCount(hWndLV);
    if (ulCount<=0)
        return;

    for(i=0;i<ulCount;i++)
    {
        LPRECIPIENT_INFO lpItem = NULL;
        lvi.iItem = i;
        if(!ListView_GetItem(hWndLV, &lvi))
            continue;

        lpItem = (LPRECIPIENT_INFO) lvi.lParam;

        if (bSortByLastName)
            StrCpyN(lpItem->szDisplayName, lpItem->szByLastName,ARRAYSIZE(lpItem->szDisplayName));
        else
            StrCpyN(lpItem->szDisplayName, lpItem->szByFirstName,ARRAYSIZE(lpItem->szDisplayName));

        ListView_SetItem(hWndLV, &lvi);
        ListView_SetItemText(hWndLV,i,colDisplayName,lpItem->szDisplayName);
    }

    return;
}

//$$-----------------------------------------------------------------------
//|
//| SortListViewColumn - Sorting Routine for the List View
//|
//| HWndLV      - handle of List View
//| iSortCol    - ColumnSorted by ...
//| lpSortInfo  - this particular dialogs sort info structure ...
//| bUseCurrentSettings - sometimes we want to call this function but dont want
//|     to change the sort settings - those times we set this to true, in which
//|     case, the iSortCol parameter is ignored
//|
//*------------------------------------------------------------------------
void SortListViewColumn(LPIAB lpIAB, HWND hWndLV, int iSortCol, LPSORT_INFO lpSortInfo, BOOL bUseCurrentSettings)
{

    HCURSOR hOldCur = NULL;

    if(!bUseCurrentSettings)
    {
        lpSortInfo->iOlderSortCol = lpSortInfo->iOldSortCol;

        if (lpSortInfo->iOldSortCol == iSortCol)
        {
            // if we previously sorted by this column then toggle the sort mode
            if(iSortCol == colDisplayName)
            {
                // For Display Name, the sort order is
                //      LastName        Ascending
                //          False           True
                //          False           False
                //          True            True
                //          True            False

                if(lpSortInfo->bSortByLastName && !lpSortInfo->bSortAscending)
                    lpSortInfo->bSortByLastName = FALSE;
                else if(!lpSortInfo->bSortByLastName && !lpSortInfo->bSortAscending)
                    lpSortInfo->bSortByLastName = TRUE;
            }

            lpSortInfo->bSortAscending = !lpSortInfo->bSortAscending;
        }
        else
        {
            // this is a new column - sort ascending
            lpSortInfo->bSortAscending = TRUE;
            lpSortInfo->iOldSortCol = iSortCol;
        }
    }

    hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    UpdateListViewItemsByName(hWndLV,lpSortInfo->bSortByLastName);

    ListView_SortItems( hWndLV, ListViewSort, (LPARAM) lpSortInfo);
	
    SetColumnHeaderBmp(hWndLV, *lpSortInfo);
	
    SetCursor(hOldCur);

    // Highlight the first selected item we can find
	if (ListView_GetSelectedCount(hWndLV) > 0)
	  ListView_EnsureVisible(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED), FALSE);

    WriteRegistrySortInfo(lpIAB, *lpSortInfo);

    return;

}


const LPTSTR  lpszRegSortKeyName = TEXT("Software\\Microsoft\\WAB\\WAB Sort State");
const LPTSTR  lpszRegSortKeyValueName = TEXT("State");
const LPTSTR  lpszRegPositionKeyValueName = TEXT("Position");
const LPTSTR  lpszRegFindPositionKeyValueName = TEXT("FindPosition");

//$$
/************************************************************************************
 -  ReadRegistrySortInfo
 -
 *  Purpose:
 *      Getss the previously stored Sort Info into the registry so we can have
 *      persistence between sessions.
 *
 *  Arguments:
 *      LPSORT_INFO lpSortInfo
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL ReadRegistrySortInfo(LPIAB lpIAB, LPSORT_INFO lpSortInfo)
{
    BOOL bRet = FALSE;
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(SORT_INFO);
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;


    if (!lpSortInfo)
        goto out;

    // default value
    //
    lpSortInfo->iOldSortCol = colDisplayName;
	lpSortInfo->iOlderSortCol = colDisplayName;
    lpSortInfo->bSortAscending = TRUE;
    lpSortInfo->bSortByLastName = bDNisByLN;

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if(dwDisposition == REG_CREATED_NEW_KEY)
        goto out;

    // Now Read this key
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                        lpszRegSortKeyValueName,
                                        NULL,
                                        &dwType,
                                        (LPBYTE) lpSortInfo,
                                        &dwLenName))
    {
        DebugTrace( TEXT("RegQueryValueEx failed\n"));
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}

//$$
/*************************************************************************************
 -  WriteRegistrySortInfo
 -
 *  Purpose:
 *      Write the current Sort Info into the registry so we can have
 *      persistence between sessions.
 *
 *  Arguments:
 *      SORT_INFO SortInfo
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL WriteRegistrySortInfo(LPIAB lpIAB, SORT_INFO SortInfo)
{
    BOOL bRet = FALSE;
//    const LPTSTR  lpszRegSortKeyName = TEXT( TEXT("Software\\Microsoft\\WAB\\WAB Sort State"));
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(SORT_INFO);
    DWORD   dwDisposition =0;


    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        DebugTrace( TEXT("RegCreateKeyEx failed\n"));
        goto out;
    }

    // Now Write this key
    if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                        lpszRegSortKeyValueName,
                                        0,
                                        REG_BINARY,
                                        (LPBYTE) &SortInfo,
                                        dwLenName))
    {
        DebugTrace( TEXT("RegSetValue failed\n"));
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}



//$$************************************************************\
//*
//* SetLocalizedDisplayName - sets the localized display name as
//*                             per localization information/
//*
//* szBuf points to a predefined buffer of length ulzBuf.
//* lpszFirst/Middle/Last/Company can be NULL
//* If szBuffer is null and ulszBuf=0, then we return the lpszBuffer
//* created here in the lppRetBuf parameter...
//* Caller has to LocalFree lppszRetBuf
//*
//
//  Rules for creating DisplayName
//
// - If there is no display name, and there is a first/middle/last name,
//      we make display name = localized(First/Middle/Last)
// - If there is no DN or FML, but NN, we make DN = NickName
// - If there is no DN, FML, NN but Company Name, we make
//      DN = Company Name
// - If there is no DN, FML, NN, CN, we fail
//\***************************************************************/
BOOL SetLocalizedDisplayName(
                    LPTSTR lpszFirstName,
                    LPTSTR lpszMiddleName,
                    LPTSTR lpszLastName,
                    LPTSTR lpszCompanyName,
                    LPTSTR lpszNickName,
                    LPTSTR * lppszBuf,
                    ULONG  ulszBuf,
                    BOOL   bDNbyLN,
                    LPTSTR lpTemplate,
                    LPTSTR * lppszRetBuf)
{
    LPTSTR szBuf = NULL;
    LPTSTR szResource = NULL;
    LPTSTR lpszArg[3];
    LPTSTR lpszFormatName = NULL;
    LPVOID lpszBuffer = NULL;
    BOOL bRet = FALSE;
    int idResource =0;

    if (!lpszFirstName && !lpszMiddleName && !lpszLastName && !lpszNickName && !lpszCompanyName)
        goto out;


    if (lppszBuf)
        szBuf = *lppszBuf;


    if(lpTemplate)
        szResource = lpTemplate;
    else
        szResource = bDNbyLN ? 
                    (bDNisByLN ? szResourceDNByLN : szResourceDNByCommaLN) 
                    : szResourceDNByFN;

    if (!lpszFirstName && !lpszMiddleName && !lpszLastName)
    {
        if(lpszNickName)
        {
            DWORD cchSize=lstrlen(lpszNickName) + 1;

            // Use the NickName
            if (! (lpszFormatName = LocalAlloc(LPTR, sizeof(TCHAR)*cchSize)))
                goto out;

            StrCpyN(lpszFormatName, lpszNickName, cchSize);
        }
        else if(lpszCompanyName)
        {
            DWORD cchSize=lstrlen(lpszCompanyName) + 1;

            // just use company name
            if (! (lpszFormatName = LocalAlloc(LPTR, sizeof(TCHAR)*cchSize)))
                goto out;

            StrCpyN(lpszFormatName, lpszCompanyName, cchSize);
        }
        else
            goto out; //shouldnt happen
    }
    else
    {
                //Bug #101350 - (erici) lstrlen will AV (and handle it) if passed a NULL
        if(     (lpszFirstName && (lstrlen(lpszFirstName) >= MAX_UI_STR)) ||
                (lpszMiddleName && (lstrlen(lpszMiddleName) >= MAX_UI_STR)) ||
                (lpszLastName && (lstrlen(lpszLastName) >= MAX_UI_STR)) )
            goto out;
            
        lpszArg[0] = lpszFirstName ? lpszFirstName : szEmpty;
        lpszArg[1] = lpszMiddleName? lpszMiddleName : szEmpty;
        lpszArg[2] = lpszLastName  ? lpszLastName : szEmpty;

        // FormatMessage doesnt do partial copying .. so we need to assimilate the name
        // first and then squeeze it into our buffer ...
        //
        if(!FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            szResource,
                            0, //ignored
                            0, //ignored
                            (LPTSTR) &lpszBuffer,
                            MAX_UI_STR,
                            (va_list *)lpszArg))
        {
            DebugPrintError(( TEXT("FormatStringFailed: %d\n"),GetLastError()));
            goto out;
        }
        lpszFormatName = (LPTSTR) lpszBuffer;

        TrimSpaces(lpszFormatName);

        // If we dont have a last name and the sort is by last name, then
        // we will get an ugly looking comma in the beginning for the english
        // version only .. special case cheating here to remove that coma
        //
        if(bDNbyLN && (!lpszLastName || !lstrlen(lpszLastName)))
        {
            BOOL bSkipChar = FALSE;

            if (lpszFormatName[0]==',')
            {
                bSkipChar = TRUE;
            }
            else
            {
                LPTSTR lp = lpszFormatName;
                if(*lp == 0x81 && *(lp+1) == 0x41) // Japanese Comma is 0x810x41.. will this work ??
                    bSkipChar = TRUE;
            }


            if(bSkipChar)
            {
                LPTSTR lpszTmp = CharNext(lpszFormatName);
                StrCpyN(lpszFormatName, lpszTmp, MAX_UI_STR);
                TrimSpaces(lpszFormatName);
            }
        }

        // Whatever the localizers combination of first middle last names for the
        // display name (eg FML, LMF, LFM etc), if the middle element is missing,
        // we'll get 2 blank spaces in the display name and we need to remove that.
        // Search and replace double blanks.
        {
            LPTSTR lpsz=lpszFormatName,lpsz1=NULL;
            while(lpsz && (*lpsz!='\0'))
            {
                lpsz1 = CharNext(lpsz);
                if (IsSpace(lpsz) && IsSpace(lpsz1)) {
                    StrCpyN(lpsz, lpsz1, lstrlen(lpsz1)+1); // this is safe because we are 
                                                            // copying the string over itself
                    continue;   // use same lpsz
                } else {
                    lpsz = lpsz1;
                }
            }
        }
    }


    // If we were provided a buffer, use it ...
    if((lppszRetBuf) && (szBuf == NULL) && (ulszBuf == 0))
    {
        *lppszRetBuf = lpszFormatName;
    }
    else
    {
        CopyTruncate(szBuf, lpszFormatName, ulszBuf);
    }


    bRet = TRUE;

out:

    if((lpszFormatName) && (lppszRetBuf == NULL) && (ulszBuf != 0))
        LocalFreeAndNull(&lpszFormatName);

    return bRet;
}




//$$
//*------------------------------------------------------------------------
//| SetChildDefaultGUIFont: Callback function that sets all the children of
//|                         any window to the default GUI font -
//|                         needed for localization.
//|
//| hWndChild - handle to child
//| lParam - ignored
//|
//*------------------------------------------------------------------------
STDAPI_(BOOL) SetChildDefaultGUIFont(HWND hWndChild, LPARAM lParam)
{
    // Code below is stolen from Shlwapi.dll 
    //
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    HFONT hfont;
    HFONT hfontDefault;
    LOGFONT lf;
    LOGFONT lfDefault;
    HWND hWndParent = GetParent(hWndChild);

    hfont = GetWindowFont(hWndParent ? hWndParent : hWndChild);
    GetObject(hfont, sizeof(LOGFONT), &lf);
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfDefault, 0);

    if ( (lfDefault.lfCharSet == lf.lfCharSet) &&
         (lfDefault.lfHeight == lf.lfHeight) &&
         (PARENT_IS_DIALOG == lParam) )
    {
        // if the dialog already has the correct character set and size
        // don't do anything.
        return TRUE;
    }

    if(PARENT_IS_DIALOG == lParam)
        hfontDefault = pt_hDlgFont;
    else
        hfontDefault = pt_hDefFont;

    // If we already have hfont created, use it.
    if(!hfontDefault)
    {
        // [bobn] Raid #88470: We should use the default size on dialogs

        if(PARENT_IS_DIALOG == lParam)
            lfDefault.lfHeight = lf.lfHeight;

        if (!(hfontDefault=CreateFontIndirect(&lfDefault)))
        {
            // restore back in failure
            hfontDefault = hfont;
        }
        if (hfontDefault != hfont)
        {
            if(PARENT_IS_DIALOG == lParam)
                pt_hDlgFont = hfontDefault;
            else
                pt_hDefFont = hfontDefault;
        }
    }

    if(!hfontDefault)
        hfontDefault = GetStockObject(DEFAULT_GUI_FONT);

    SetWindowFont(hWndChild, hfontDefault, FALSE);

	return TRUE;
}



//$$
//*------------------------------------------------------------------------
//| HrGetLDAPContentsList: Gets ContentsList from an LDAP container - Opens
//|                 a container - populates it using the given restriction,
//|                 and puts its contents in the List View
//|
//| lpIAB       - Address Book object
//| cbContainerEID, lpContainerEID  - LDAP Container EntryID
//| SortInfo    - Current Sort State
//| lpPropRes   - Property Restriction with which to do the Search
//| lpPTA       - PropTagArray to return - currently ignored
//| ulFlags     - 0 - currently ignored
//| lppContentsList - Returned, filled Contents List
//| lpAdvFilter - alternate advanced filter used in place of the property restriction
//*------------------------------------------------------------------------
HRESULT HrGetLDAPContentsList(LPADRBOOK lpAdrBook,
                                ULONG   cbContainerEID,
                                LPENTRYID   lpContainerEID,
                                SORT_INFO SortInfo,
        	                    LPSRestriction lpPropRes,
                                LPTSTR lpAdvFilter,
								LPSPropTagArray  lpPTA,
                                ULONG ulFlags,
                                LPRECIPIENT_INFO * lppContentsList)
{
    HRESULT hr = hrSuccess;
    HRESULT hrSaveTmp = E_FAIL; // temporarily saves partial completion error so it can be propogated to calling funtion
    ULONG ulObjectType = 0;
    LPCONTAINER lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
    ULONG i = 0,j=0;
    LPRECIPIENT_INFO lpItem = NULL;
    LPRECIPIENT_INFO lpLastListItem = NULL;

    DebugPrintTrace(( TEXT("-----HrGetLDAPContentsList: entry\n")));


    if(!lpPropRes && !lpAdvFilter)
    {
        DebugPrintError(( TEXT("No search restriction created\n")));
        hr = E_FAIL;
        goto out;
    }

    //
    // First we need to open the container object corresponding to this Container EntryID
    //
    hr = lpAdrBook->lpVtbl->OpenEntry(
                            lpAdrBook,
                            cbContainerEID, 	
                            lpContainerEID, 	
                            NULL, 	
                            0, 	
                            &ulObjectType, 	
                            (LPUNKNOWN *) &lpContainer);

    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }


    //
    // Now we do a get contents table on this container ...
    //
    hr = lpContainer->lpVtbl->GetContentsTable(
                            lpContainer,
                            MAPI_UNICODE,
                            &lpContentsTable);
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

/****
//$$$$$$$$$$$$
// Test code

    {
           SPropValue     valAnr;
           SRestriction   resAnr;
           LPSRowSet      prws;

           LPTSTR lpsz =  TEXT("Vikram");

           // Set up the Ambiguous Name Resolution property value.
           valAnr.ulPropTag  = PR_ANR;
           valAnr.Value.LPSZ = lpsz;

           // Set up the Ambiguous Name Resolution restriction.
           resAnr.rt                        = RES_PROPERTY;
           resAnr.res.resProperty.relop     = RELOP_EQ;
           resAnr.res.resProperty.ulPropTag = valAnr.ulPropTag;
           resAnr.res.resProperty.lpProp    = &valAnr;

           // Restrict the contents table.
           // Set columns and query rows to see what state we fall in.  We ask for one more
           // row than the value of the Few/Many threshold.  This allows us to tell whether
           // we are a Few/Many ambiguity.
           hr = lpContentsTable->lpVtbl->Restrict(lpContentsTable,
                                                  &resAnr,
                                                  TBL_BATCH);

           hr = lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                                                    (LPSPropTagArray)&ptaResolveDefaults,
                                                    TBL_BATCH);

           hr = lpContentsTable->lpVtbl->SeekRow(lpContentsTable,
                                                 BOOKMARK_BEGINNING,
                                                 0, 0);

           hr = lpContentsTable->lpVtbl->QueryRows(lpContentsTable,
                                                    1,
                                                    0,
                                                    &prws);


          FreeProws(prws);


    }
//$$$$$$$$$$$$
/*****/

    // If the user has specified an advanced filter, we need to figure out some way to 
    // pass it to the LDAP routines while still taking advantage of our LDAP contents table
    // To do this we will do a hack and pass in the lpAdvFilter cast to a LPPropRes and then
    // recast back at the other end
    // This may break if any changes are made to the table implementation
    //

    // We now do the find rows
    hr = lpContentsTable->lpVtbl->FindRow(
                                    lpContentsTable,
                                    lpAdvFilter ? (LPSRestriction) lpAdvFilter : lpPropRes,
                                    BOOKMARK_BEGINNING,
                                    lpAdvFilter ? LDAP_USE_ADVANCED_FILTER : 0); //flags
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("FindRow Failed: %x\n"),hr));
        goto out;
    }

    // if this was a partial completion error - we want to treat it as success
    // but also propogate it to the calling function
    if(hr == MAPI_W_PARTIAL_COMPLETION)
        hrSaveTmp = hr;

    // If we got this far, then we have a populated table
    // We should be able to do a Query Rows here ...

    hr = SetRecipColumns(lpContentsTable);
    if(HR_FAILED(hr))
        goto out;

    hr = HrQueryAllRows(lpContentsTable,
                        NULL,
                        NULL,
                        NULL,
                        0,
                        &lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    //
	// if there's anything in the contents list flush it away
	//
    if (*lppContentsList)
    {
        lpItem = (*lppContentsList);
        (*lppContentsList) = lpItem->lpNext;
        FreeRecipItem(&lpItem);
    }
    *lppContentsList = NULL;
    lpItem = NULL;


    for(i=0;i<lpSRowSet->cRows;i++)
    {
        LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;
        ULONG ulcPropCount = lpSRowSet->aRow[i].cValues;

        lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		if (!lpItem)
		{
			DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			hr = MAPI_E_NOT_ENOUGH_MEMORY;
			goto out;
		}

		GetRecipItemFromPropArray(ulcPropCount, lpPropArray, &lpItem);

		// The critical prop is display name - without it we are nothing ...
		// If no display name, junk this entry and continue ..

		if (!lstrlen(lpItem->szDisplayName) || (lpItem->cbEntryID == 0)) //This entry id is not allowed
		{
			FreeRecipItem(&lpItem);				
			continue;
		}


        // Tag this as an item from the contents and not from the original AdrList
        lpItem->ulOldAdrListEntryNumber = 0;


        // The entryids are in sorted order by display name
        // Depending on the sort order - we want this list to also be sorted by display
        // name or by reverse display name ...

        if (SortInfo.bSortByLastName)
            StrCpyN(lpItem->szDisplayName,lpItem->szByLastName,ARRAYSIZE(lpItem->szDisplayName));

        if(!SortInfo.bSortAscending)
        {
            //Add it to the contents linked list
            lpItem->lpNext = (*lppContentsList);
            if (*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            lpItem->lpPrev = NULL;
            *lppContentsList = lpItem;
        }
        else
        {
            if(*lppContentsList == NULL)
                (*lppContentsList) = lpItem;

            if(lpLastListItem)
                lpLastListItem->lpNext = lpItem;

            lpItem->lpPrev = lpLastListItem;
            lpItem->lpNext = NULL;

            lpLastListItem = lpItem;
        }

        lpItem = NULL;

    } //for i ....


    // reset this error if applicable so calling function can treat it correctly
    if(hrSaveTmp == MAPI_W_PARTIAL_COMPLETION)
        hr = hrSaveTmp;


out:

    if(lpSRowSet)
        FreeProws(lpSRowSet);

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpContainer)
        lpContainer->lpVtbl->Release(lpContainer);


	if (HR_FAILED(hr))
	{
		while(*lppContentsList)
		{
			lpItem = *lppContentsList;
			*lppContentsList=lpItem->lpNext;
			FreeRecipItem(&lpItem);
		}
	}

    return hr;
}




//$$
/******************************************************************************
//
// HrGetWABContents - Gets and fills the current list view with contents from the
//                      local store.
//
// hWndList - Handle to List View which we will populate
// lpIAB    - Handle to Address Bok object
// SortInfo - Current Sort State
// lppContentsList - linked list in which we will store info about entries
//
/******************************************************************************/
HRESULT HrGetWABContents(   HWND  hWndList,
                            LPADRBOOK lpAdrBook,
                            LPSBinary lpsbContainer,
                            SORT_INFO SortInfo,
                            LPRECIPIENT_INFO * lppContentsList)
{
    HRESULT hr = hrSuccess;
    LPIAB lpIAB = (LPIAB) lpAdrBook;

    int nSelectedItem = ListView_GetNextItem(hWndList, -1, LVNI_SELECTED);

    if(nSelectedItem < 0)
        nSelectedItem = 0;

    SendMessage(hWndList, WM_SETREDRAW, FALSE, 0L);

    ClearListView(hWndList, lppContentsList);

    if (HR_FAILED(hr = HrGetWABContentsList(
							    lpIAB,
                                SortInfo,
							    NULL,
							    NULL,
							    0,
                                lpsbContainer,
                                FALSE,
							    lppContentsList)))
	{
		goto out;
	}

    // There is a performance issue of filling names
    // If names are sorted by first name and are by first col,
    // we can show them updated - otherwise we cant

    if (HR_FAILED(hr = HrFillListView(	hWndList,
										*lppContentsList)))
	{
		goto out;
	}
/*
    if((SortInfo.iOldSortCol == colDisplayName) &&
       (!SortInfo.bSortByLastName))
    {
        // Already Sorted
        SetColumnHeaderBmp(hWndList, SortInfo);
    }
    else
*/  {
        // Otherwise sort
        SortListViewColumn(lpIAB, hWndList, colDisplayName, &SortInfo, TRUE);
    }

/*
	if (ListView_GetSelectedCount(hWndList) <= 0)
	{
		// nothing selected - so select 1st item
		// Select the first item in the List View
		LVSelectItem(hWndList, 0);
	}
    else
    {
        LVSelectItem(hWndList, ListView_GetNextItem(hWndList, -1, LVNI_SELECTED));
    }
*/
    LVSelectItem(hWndList, nSelectedItem);

out:

    SendMessage(hWndList, WM_SETREDRAW, TRUE, 0L);

    return(hr);

}


//$$
/******************************************************************************/
//
// HrGetLDAPSearchRestriction -
//
//
// For a simple search we have the following data to work with
// Country      - PR_COUNTRY
// DisplayName  - PR_DISPLAY_NAME
//
// For a detailed search
// We have the following data to work with
// Country      - PR_COUNTRY
// FirstName    - PR_GIVEN_NAME
// LastName     - PR_SURNAME
// EMail        - PR_EMAIL_ADDRESS
// Organization - PR_COMPANY_NAME
//
//
/******************************************************************************/
HRESULT HrGetLDAPSearchRestriction(LDAP_SEARCH_PARAMS LDAPsp, LPSRestriction lpSRes)
{
    SRestriction SRes = {0};
    LPSRestriction lpPropRes = NULL;
    ULONG ulcPropCount = 0;
    HRESULT hr = E_FAIL;
    ULONG i = 0;
    SCODE sc = ERROR_SUCCESS;

    lpSRes->rt = RES_AND;

    ulcPropCount = 0;

    if (lstrlen(LDAPsp.szData[ldspDisplayName]))
        ulcPropCount++; //PR_EMAIL_ADDRESS and PR_DISPLAY_NAME
    if (lstrlen(LDAPsp.szData[ldspEmail]))
        ulcPropCount++;

    if (!ulcPropCount)
    {
        DebugPrintError(( TEXT("No Search Props!\n")));
        goto out;
    }

    lpSRes->res.resAnd.cRes = ulcPropCount;

    lpSRes->res.resAnd.lpRes = NULL;
    sc = MAPIAllocateBuffer(ulcPropCount * sizeof(SRestriction), (LPVOID *) &(lpSRes->res.resAnd.lpRes));
    if (sc != S_OK)
    {
        DebugPrintError(( TEXT("MAPIAllocateBuffer failed\n")));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }


    if(!(lpSRes->res.resAnd.lpRes))
    {
        DebugPrintError(( TEXT("Error Allocating Memory\n")));
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpPropRes = lpSRes->res.resAnd.lpRes;

    ulcPropCount = 0;

    for(i=0;i<ldspMAX;i++)
    {
        if(lstrlen(LDAPsp.szData[i]))
        {
            ULONG ulPropTag = 0;
            DWORD cchSize;

            LPSPropValue lpPropArray = NULL;

            switch(i)
            {
            case ldspEmail:
                ulPropTag = PR_EMAIL_ADDRESS;
                break;
            case ldspDisplayName:
                ulPropTag = PR_DISPLAY_NAME;
                break;
            default:
                continue;
            }

            lpPropRes[ulcPropCount].rt = RES_PROPERTY;
            lpPropRes[ulcPropCount].res.resProperty.relop = RELOP_EQ;
            lpPropRes[ulcPropCount].res.resProperty.ulPropTag = ulPropTag;

            lpPropRes[ulcPropCount].res.resProperty.lpProp = NULL;
            MAPIAllocateMore(sizeof(SPropValue),lpPropRes, (LPVOID *) &(lpPropRes[ulcPropCount].res.resProperty.lpProp));
            lpPropArray = lpPropRes[ulcPropCount].res.resProperty.lpProp;
            if(!lpPropArray)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            lpPropArray->ulPropTag = ulPropTag;

            lpPropArray->Value.LPSZ = NULL;

            cchSize=lstrlen(LDAPsp.szData[i])+1;
            MAPIAllocateMore(sizeof(TCHAR)*cchSize, lpPropRes, (LPVOID *) (&(lpPropArray->Value.LPSZ)));
            if(!lpPropArray->Value.LPSZ)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            StrCpyN(lpPropArray->Value.LPSZ,LDAPsp.szData[i], cchSize);
            ulcPropCount++;
        }
    }

    hr = S_OK;

out:

    return hr;

}

//$$/////////////////////////////////////////////////////////////////////////
//
// ShowMessageBoxParam - Generic MessageBox displayer .. saves space all over
//
//  hWndParent  - Handle of Message Box Parent
//  MsgID       - resource id of message string
//  ulFlags     - MessageBox flags
//  ...         - format parameters
//
///////////////////////////////////////////////////////////////////////////
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_BUF_STR] =  TEXT("");
    TCHAR szCaption[MAX_PATH] =  TEXT("");
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list	vl;

    va_start(vl, ulFlags);

    LoadString(hinstMapiX, MsgId, szBuf, ARRAYSIZE(szBuf));
//    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0, //ignored
      (LPTSTR)&lpszBuffer,
      MAX_BUF_STR, //MAX_UI_STR
//      (LPTSTR *)&(lpParam))) {
      (va_list *)&vl)) {
        TCHAR szCaption[MAX_PATH];
        *szCaption = '\0';
        if(hWndParent)
            GetWindowText(hWndParent, szCaption, ARRAYSIZE(szCaption));
        if(!lstrlen(szCaption)) // if no caption get the parents caption - this is necessary for property sheets
        {
            if(hWndParent)
                GetWindowText(GetParent(hWndParent), szCaption, ARRAYSIZE(szCaption));
            if(!lstrlen(szCaption)) //if still not caption, get the generic title
                LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szCaption, ARRAYSIZE(szCaption));
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        LocalFreeAndNull(&lpszBuffer);
    }
    va_end(vl);
    return(iRet);
}

//$$/////////////////////////////////////////////////////////////////////////
//
// ShowMessageBox - Generic MessageBox displayer .. saves space all over
//
//  hWndParent  - Handle of Message Box Parent
//  MsgID       - resource id of message string
//  ulFlags     - MessageBox flags
//
///////////////////////////////////////////////////////////////////////////
int ShowMessageBox(HWND hWndParent, int MsgId, int ulFlags)
{
    TCHAR szBuf[MAX_BUF_STR];
    TCHAR szCaption[MAX_PATH];

    szCaption[0]='\0';
    szBuf[0]='\0';

    LoadString(hinstMapiX, MsgId, szBuf, ARRAYSIZE(szBuf));

    if(hWndParent)
    {
        GetWindowText(hWndParent, szCaption, ARRAYSIZE(szCaption));
        if(!lstrlen(szCaption))
        {
            // if we cant get a caption, get the windows parents caption
            HWND hWnd = GetParent(hWndParent);
            GetWindowText(hWnd, szCaption, ARRAYSIZE(szCaption));
        }
    }
    if(!lstrlen(szCaption))
    {
        //if we cant get the parents caption, get a generic title
        LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szCaption, ARRAYSIZE(szCaption));
    }


    return MessageBox(hWndParent, szBuf, szCaption, ulFlags);

}

//$$/////////////////////////////////////////////////////////////////////////////
//
// my_atoi - personal version of atoi function
//
//  lpsz - string to parse into numbers - non numeral characters are ignored
//
/////////////////////////////////////////////////////////////////////////////////
int my_atoi(LPTSTR lpsz)
{
    int i=0;
    int nValue = 0;

    if(lpsz)
    {
        if (lstrlen(lpsz))
        {
            nValue = 0;
            while((lpsz[i]!='\0')&&(i<=lstrlen(lpsz)))
            {
                int tmp = lpsz[i]-'0';
                if(tmp <= 9)
                    nValue = nValue*10 + tmp;
                i++;
            }
        }
    }

    return nValue;
}

#ifdef OLD_STUFF
//$$/////////////////////////////////////////////////////////////////////////////
//
// FillComboLDAPCountryNames - Fills a dropdown conbo with LDAP country names
//
//  hWndCombo - Handle of Combo
//
/////////////////////////////////////////////////////////////////////////////////
void FillComboLDAPCountryNames(HWND hWndCombo)
{
    TCHAR szBuf[MAX_UI_STR];
    int nCountrys = 0;
    int i=0;

    LoadString(hinstMapiX, idsCountryCount,szBuf,ARRAYSIZE(szBuf));
    nCountrys = my_atoi(szBuf);
    if(nCountrys == 0)
        nCountrys = MAX_COUNTRY_NUM;

    for(i=0;i<nCountrys;i++)
    {
        LoadString(hinstMapiX, idsCountry1+i,szBuf,ARRAYSIZE(szBuf));
        SendMessage(hWndCombo,CB_ADDSTRING, 0, (LPARAM) szBuf);
    }

    // Look in the regsitry for a default specfied country ...
    ReadRegistryLDAPDefaultCountry(szBuf, ARRAYSIZE(szBuf), NULL, 0);

    // set the selection to default from registry
    i = SendMessage(hWndCombo, CB_FINDSTRING, (WPARAM) -1, (LPARAM) szBuf);

    if(i==CB_ERR)
    {
        i = SendMessage(hWndCombo, CB_FINDSTRING, (WPARAM) -1, (LPARAM) TEXT("United States"));
    }

    SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) i, 0);


    return;
}
#endif


//$$/////////////////////////////////////////////////////////////////////////////
//
// ReadRegistryLDAPDefaultCountry - Reads the default country name or code from the
//                                  registry
//
//  szCountry, szCountryCode - buffers that will recieve the country and/or country
//                      code. These can be NULL if no country or countrycode is
//                      required.
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ReadRegistryLDAPDefaultCountry(LPTSTR szCountry, DWORD cchCountry, LPTSTR szCountryCode, DWORD cchCountryCode)
{
    BOOL bRet = FALSE;
    DWORD dwErr;
    HKEY hKey = NULL;
    ULONG ulSize = MAX_UI_STR;
    DWORD dwType;
    TCHAR szTemp[MAX_UI_STR];

    if(!szCountry && !szCountryCode)
        goto out;

    if (szCountry)
        szCountry[0]='\0';

    if (szCountryCode)
        szCountryCode[0]='\0';

    dwErr = RegOpenKeyEx(   HKEY_CURRENT_USER,
                            szWABKey,
                            0,
                            KEY_READ,
                            &hKey);

    if(dwErr)
        goto out;

    dwErr = RegQueryValueEx(    hKey,
                                (LPTSTR)szLDAPDefaultCountryValue,
                                NULL,
                                &dwType,
                                (LPBYTE)szTemp,
                                &ulSize);

    if(dwErr)
    {
        // We dont have a registry setting .. or there was some error
        // In this case we need to get the Default Country for this locale
        // using the NLS API
        ulSize = GetLocaleInfo( LOCALE_USER_DEFAULT,
                                LOCALE_SENGCOUNTRY,
                                (LPTSTR) szTemp,
                                ARRAYSIZE(szTemp));

        if(ulSize>0)
        {
            // We got a valid country but it obviously doesnt have a code

            if(szCountry)
                StrCpyN(szCountry, szTemp, cchCountry);

            if(szCountryCode)
            {
                int i =0;
                int cMax=0;
                TCHAR szBufCountry[MAX_UI_STR];

                szBufCountry[0]='\0';

                StrCpyN(szBufCountry,szTemp,ARRAYSIZE(szBufCountry));

                LoadString(hinstMapiX, idsCountryCount,szTemp,ARRAYSIZE(szTemp));
                cMax = my_atoi(szTemp);

                for(i=0;i<cMax;i++)
                {
                    LoadString(hinstMapiX, idsCountry1+i, szTemp, ARRAYSIZE(szTemp));
                    if(lstrlen(szTemp) < lstrlen(szBufCountry))
                        continue;

                    if( !memcmp(szTemp, szBufCountry, (lstrlen(szBufCountry) * sizeof(TCHAR))) )
                    {
                        //Found our match
                        LPTSTR lpszTmp = szTemp;

                        szCountryCode[0]='\0';

                        while(*lpszTmp && (*lpszTmp != '('))
                            lpszTmp = CharNext(lpszTmp);
                        if(*lpszTmp && (*lpszTmp == '('))
                        {
                            lpszTmp = CharNext(lpszTmp);
                            CopyMemory(szCountryCode,lpszTmp,sizeof(TCHAR)*2);
                            szCountryCode[2] = '\0';
                        }

                        break;
                    }
                }


                if(!lstrlen(szCountryCode))
                {
                    // default to US
                    StrCpyN(szCountryCode, TEXT("US"), cchCountryCode);
                }

            }

            bRet = TRUE;

            goto out;
        }
    }
    else
    {

        // Otherwise - do our normal processing

        if(szCountry)
            StrCpyN(szCountry, szTemp, cchCountry);


        if(szCountryCode)
        {
            LPTSTR lpszTmp = szTemp;

            szCountryCode[0]='\0';

            while(*lpszTmp && (*lpszTmp != '('))
                lpszTmp = CharNext(lpszTmp);
            if(*lpszTmp && (*lpszTmp == '('))
            {
                lpszTmp = CharNext(lpszTmp);
                CopyMemory(szCountryCode,lpszTmp,sizeof(TCHAR)*2);
                szCountryCode[2] = '\0';
            }


            if(!lstrlen(szCountryCode))
            {
                // default to US
                StrCpyN(szCountryCode, TEXT("US"), cchCountryCode);
            }

        }
    }

    bRet = TRUE;

out:

    if(hKey)
        RegCloseKey(hKey);

    return bRet;

}


#ifdef OLD_STUFF
//$$/////////////////////////////////////////////////////////////////////////////
//
// WriteRegistryLDAPDefaultCountry - Writes the default country name to the
//                                   registry
//
//  szCountry - default country code to write
//
/////////////////////////////////////////////////////////////////////////////////
BOOL WriteRegistryLDAPDefaultCountry(LPTSTR szCountry)
{
    BOOL bRet = FALSE;
    DWORD dwErr;
    HKEY hKey = NULL;
    ULONG ulSize = 0;

    if(!szCountry)
        goto out;

    if(!lstrlen(szCountry))
        goto out;

    dwErr = RegOpenKeyEx(   HKEY_CURRENT_USER,
                            szWABKey,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hKey);

    if(dwErr)
        goto out;

    dwErr = RegSetValueEx(  hKey,
                            (LPTSTR) szLDAPDefaultCountryValue,
                            0,
                            REG_SZ,
                            szCountry,
                            (lstrlen(szCountry)+1) * sizeof(TCHAR) );

    if(dwErr)
        goto out;

    bRet = TRUE;

out:

    return bRet;

}
#endif //OLD_STUFF


BOOL bIsGroupSelected(HWND hWndLV, LPSBinary lpsbEID)
{
    LPRECIPIENT_INFO lpItem;

    if(ListView_GetSelectedCount(hWndLV) != 1)
        return FALSE;

    lpItem = GetItemFromLV(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
    if(lpItem && lpItem->ulObjectType == MAPI_DISTLIST)
    {
        if(lpsbEID)
        {
            lpsbEID->cb = lpItem->cbEntryID;
            lpsbEID->lpb = (LPBYTE)lpItem->lpEntryID;
        }
        return TRUE;
    }
    return FALSE;
}


//$$
////////////////////////////////////////////////////////////////////////////////
//
// GetCurrentOptionsState - looks at the current state based on the ListView and
// the Combo and decides which options should be enabled or disabled
//
// hWndCombo - handle of Show Names combo
// hWndLV - handle of ListView to look at
// lpbState - points to a predefined array of BOOL bState[tbMAX]
//
////////////////////////////////////////////////////////////////////////////////
void GetCurrentOptionsState(HWND hWndLVContainer,
                            HWND hWndLV,
                            LPBOOL lpbState)
{
    int i = 0;
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    BYTE bType = 0;
    int nItemCount = ListView_GetItemCount(hWndLV);
    int nSelectedCount = ListView_GetSelectedCount(hWndLV);

    for(i=0;i<tbMAX;i++)
        lpbState[i] = FALSE;

    lpbState[tbPaste] = bIsPasteData();//  && ( (nSelectedCount<=0) || (bIsGroupSelected(hWndLV, NULL)) );
    
    lpbState[tbCopy] = lpbState[tbFind] = lpbState[tbAction] = TRUE;

    if(hWndLVContainer)
    {
        // in the rare event that we have LDAP containers ...
        GetCurrentContainerEID( hWndLVContainer,
                                &cbEID,
                                &lpEID);
        bType = IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL);
    }
    else
    {
        bType = WAB_PAB;
    }

    if(bType == WAB_PAB || bType == WAB_PABSHARED)
    {
        lpbState[tbNew] = lpbState[tbNewEntry] = lpbState[tbNewGroup] = lpbState[tbNewFolder] = TRUE;
        lpbState[tbAddToWAB] = FALSE;
        if(nItemCount > 0)
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = TRUE;
        else
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = FALSE;

        if(nSelectedCount <= 0)
            lpbState[tbCopy] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = FALSE;
        else if(nSelectedCount > 1)
            //lpbState[tbaction] =
            lpbState[tbProperties] = FALSE;


    }
    else if(bType == WAB_LDAP_CONTAINER)
    {
        lpbState[tbDelete] = lpbState[tbNew] = lpbState[tbNewEntry] = lpbState[tbNewGroup] = lpbState[tbNewFolder] = FALSE;
        if(nItemCount > 0)
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbAddToWAB] = TRUE;
        else
            lpbState[tbPrint] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbAddToWAB] = FALSE;

        if(nSelectedCount <= 0)
            lpbState[tbPaste] = lpbState[tbCopy] = /*lpbState[tbAction] =*/ lpbState[tbProperties] = lpbState[tbDelete] = FALSE;
        else if(nSelectedCount > 1)
            //lpbState[tbAction] =
            lpbState[tbProperties] = FALSE;


    }
    else
    {
        // cant handle this case so turn everything off ....
        for(i=0;i<tbMAX;i++)
            lpbState[i] = FALSE;
    }

    return;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  HrEntryAddToWAB - Adds an entry to the Address Book given an entryid
//
//
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrEntryAddToWAB(    LPADRBOOK lpAdrBook,
                            HWND hWndParent,
                            ULONG cbInputEID,
                            LPENTRYID lpInputEID,
                            ULONG * lpcbOutputEID,
                            LPENTRYID * lppOutputEID)
{
    HRESULT hr = E_FAIL;
    ULONG ulcProps = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i;

    hr = HrGetPropArray(lpAdrBook,
                        NULL,
                        cbInputEID,
                        lpInputEID,
                        MAPI_UNICODE,
                        &ulcProps,
                        &lpPropArray);

    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrGetPropArray failed:%x\n")));
        goto out;
    }


    //
    // This lpPropArray will have a non-zero entryid ... it will have the
    // LDAP entry id .. we want to remove that value so we can store this
    // lpPropArray as a fresh lpPropArray...
    //
    for(i=0;i<ulcProps;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_ENTRYID)
        {
            lpPropArray[i].Value.bin.cb = 0;
            break;
        }
    }

    // Since this function exclusively adds people to the local WAB from LDAP
    // we need to filter out non-storable properties here if they exist ...
    for(i=0;i<ulcProps;i++)
    {
        switch(lpPropArray[i].ulPropTag)
        {
        case PR_WAB_MANAGER:
        case PR_WAB_REPORTS:
        case PR_WAB_LDAP_LABELEDURI:
            lpPropArray[i].ulPropTag = PR_NULL;
            break;
        }
    }

    {
        ULONG cbContEID = 0; 
        LPENTRYID lpContEID = NULL;
        LPIAB lpIAB = (LPIAB) lpAdrBook;
        if(bIsThereACurrentUser(lpIAB))
        {
            cbContEID = lpIAB->lpWABCurrentUserFolder->sbEID.cb;
            lpContEID = (LPENTRYID)(lpIAB->lpWABCurrentUserFolder->sbEID.lpb);
        }
         hr = HrCreateNewEntry( lpAdrBook,
                                hWndParent,
                                MAPI_MAILUSER,   //MAILUSER or DISTLIST
                                cbContEID, lpContEID, 
                                MAPI_ABCONT,//add to root container only
                                CREATE_CHECK_DUP_STRICT,
                                TRUE,
                                ulcProps,
                                lpPropArray,
                                lpcbOutputEID,
                                lppOutputEID);
    }
    if(HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrCreateNewEntry failed:%x\n")));
        goto out;
    }


out:
    if (lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return hr;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  HrAddToWAB - Adds an LDAP or one-off entry to the Address Book
//          All such items will be added to the root container only
//
//  lpIAB - ADRBOOK object
//  hWndLV - Listview window handle
//  lpftLast - WAB file time at last update
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrAddToWAB( LPADRBOOK   lpIAB,
                    HWND hWndLV,
                    LPFILETIME lpftLast)
{
    HRESULT hr = hrSuccess;
    HRESULT hrDeferred = hrSuccess;
    int nSelectedCount = 0;
    LPRECIPIENT_INFO lpItem = NULL;
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    ULONG i = 0;
    HCURSOR hOldCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    //
    // Looks at the selected item in the List View,
    // gets its entry id, gets its props, creates a new item with those props
    //

    if (!lpIAB || !hWndLV)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    nSelectedCount = ListView_GetSelectedCount(hWndLV);

    if(nSelectedCount <= 0)
    {
        ShowMessageBox(GetParent(hWndLV), idsNoItemsSelectedForAdding, MB_ICONEXCLAMATION | MB_OK);
        hr = E_FAIL;
        goto out;
    }
    else
    {
        // Walk through all the items processing the one by one
        int iItemIndex = 0;
        int iLastItemIndex = -1;
        iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);

        while(iItemIndex != -1)
        {
            iLastItemIndex = iItemIndex;
            lpItem = GetItemFromLV(hWndLV, iItemIndex);
            if(lpItem)
            {
                nSelectedCount--; //now tracks how many are left

                hr = HrEntryAddToWAB(   lpIAB,
                                        GetParent(hWndLV),
                                        lpItem->cbEntryID,
                                        lpItem->lpEntryID,
                                        &cbEID,
                                        &lpEID);

                if(HR_FAILED(hr))
                {
                    DebugPrintError(( TEXT("HrEntryAddToWAB failed:%x\n")));

                    if(hr != MAPI_E_USER_CANCEL)
                        hrDeferred = hr;

                    if (lpEID)
                        MAPIFreeBuffer(lpEID);
                    lpEID = NULL;

                    if(hr == MAPI_E_USER_CANCEL && nSelectedCount)
                    {
                        // user canceled this one and some other remain ..
                        // Ask if he wants to cancel the whole import operation
                        if(IDYES == ShowMessageBox(GetParent(hWndLV),
                                                    idsContinueAddingToWAB,
                                                    MB_YESNO | MB_ICONEXCLAMATION))
                        {
                            goto out;
                        }
                    }
                    // just keep going on if there are any remaining entries
                    goto end_loop;
                }


                // Update the wab file write time so the timer doesn't
                // catch this change and refresh.
                //if (lpftLast) {
                //    CheckChangedWAB(((LPIAB)lpIAB)->lpPropertyStore, lpftLast);
                //}

                if (lpEID)
                    MAPIFreeBuffer(lpEID);
                lpEID = NULL;

            }
end_loop:
            // Get the next selected item ...
            iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);
        }
    }

out:

    if (lpEID)
        MAPIFreeBuffer(lpEID);

    if(hr != MAPI_E_USER_CANCEL)
    {
        if (!hrDeferred) //hr could be MAPI_W_ERRORS_RETURNED in which case it wasnt all roses so dont give this message ...
        {
            if(nSelectedCount)
                ShowMessageBox(GetParent(hWndLV), idsSuccessfullyAddedUsers, MB_ICONINFORMATION | MB_OK);
        }
        else if(hrDeferred == MAPI_E_NOT_FOUND)
            ShowMessageBox(GetParent(hWndLV), idsCouldNotAddSomeEntries, MB_ICONINFORMATION | MB_OK);
    }

    SetCursor(hOldCursor);
    return hr;
}


//$$
/************************************************************************************
 -  ReadRegistryPositionInfo
 -
 *  Purpose:
 *      Getss the previously stored modeless window size and column width info
 *      for persistence between sessions.
 *
 *  Arguments:
 *      LPABOOK_POSCOLSIZE  lpABPosColSize
 *      LPTSTR szPosKey - key to store it under
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL ReadRegistryPositionInfo(LPIAB lpIAB,
                              LPABOOK_POSCOLSIZE  lpABPosColSize,
                              LPTSTR szPosKey)
{
    BOOL bRet = FALSE;
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(ABOOK_POSCOLSIZE);
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;

    if(!lpABPosColSize)
        goto out;

tryReadingAgain:
    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        goto out;
    }

    if(dwDisposition == REG_CREATED_NEW_KEY)
        goto out;

    // Now Read the key
    if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                        szPosKey,
                                        NULL,
                                        &dwType,
                                        (LPBYTE) lpABPosColSize,
                                        &dwLenName))
    {
        DebugTrace( TEXT("RegQueryValueEx failed\n"));
        if(hKeyRoot != HKEY_CURRENT_USER)
        {
            // with identities .. this will fail the first time ..so recover old HKCU settings for upgrades
            hKeyRoot = HKEY_CURRENT_USER;
            if(hKey)
                RegCloseKey(hKey);
            goto tryReadingAgain;
        }
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}

//$$
/*************************************************************************************
 -  WriteRegistryPostionInfo
 -
 *  Purpose:
 *      Write the given window position to the registry
 *
 *  Arguments: 
 *      LPABOOK_POSCOLSIZE  lpABPosColSize
 *      LPTSTR szPosKey - key to write it in
 *
 *  Returns:
 *      BOOL
 *
 *************************************************************************************/
BOOL WriteRegistryPositionInfo(LPIAB lpIAB,
                               LPABOOK_POSCOLSIZE  lpABPosColSize,
                               LPTSTR szPosKey)
{
    BOOL bRet = FALSE;
    HKEY    hKey = NULL;
    HKEY    hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD   dwLenName = sizeof(ABOOK_POSCOLSIZE);
    DWORD   dwDisposition =0;

    if(!lpABPosColSize)
        goto out;

    // Open key
    if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot,
                                        lpszRegSortKeyName,
                                        0,      //reserved
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition))
    {
        DebugTrace( TEXT("RegCreateKeyEx failed\n"));
        goto out;
    }

    // Now Write this key
    if (ERROR_SUCCESS != RegSetValueEx( hKey,
                                        szPosKey,
                                        0,
                                        REG_BINARY,
                                        (LPBYTE) lpABPosColSize,
                                        dwLenName))
    {
        DebugTrace( TEXT("RegSetValue failed\n"));
        goto out;
    }

    bRet = TRUE;

out:
    if (hKey)
        RegCloseKey(hKey);

    return(bRet);
}



//$$////////////////////////////////////////////////////////////////////////////////
//
// ProcessLVCustomDraw - Processes the NMCustomDraw message for the various list views
//
// Used for setting the DistLists to a bolder font
//
// Parameters -
//
//  lParam - lParam of original message
//  hDlg - handle of dialog if the relevant window is a dialog, null otherwise
//  bIsDialog - flag that tells us if this is a dialog or not
//
////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessLVCustomDraw(HWND hDlg, LPARAM lParam, BOOL bIsDialog)
{
    NMCUSTOMDRAW *pnmcd = (NMCUSTOMDRAW *) lParam;

	if(pnmcd->dwDrawStage==CDDS_PREPAINT)
	{
        if(bIsDialog)
        {
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW|CDRF_DODEFAULT);
            return TRUE;
        }
        else
    		return CDRF_NOTIFYITEMDRAW|CDRF_DODEFAULT;
	}
	else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
	{
        LPRECIPIENT_INFO lpItem = (LPRECIPIENT_INFO) pnmcd->lItemlParam;

        if(lpItem)
        {
			if(lpItem->ulObjectType == MAPI_DISTLIST)
			{
				SelectObject(((NMLVCUSTOMDRAW *)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                if(bIsDialog)
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                    return TRUE;
                }
                else
				    return CDRF_NEWFONT;
			}
        }
	}

    if(bIsDialog)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
        return TRUE;
    }
    else
	    return CDRF_DODEFAULT;
}


/*****
//$$/////////////////////////////////////////////////////////////
//
// DoLVQuickFilter -  Simple quick find routine for matching edit box contents to
//                      List view entries
//
//  lpIAB   - lpAdrBook object
//  hWndEdit - handle of Edit Box
//  hWndLV  - handle of List View
//  lppContentsList - ContentsList
//
//  ulFlags - AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL or Both
//  int minLen - we may not want to trigger a search with 1 char or 2 char or less etc
//
///////////////////////////////////////////////////////////////
void DoLVQuickFilter(   LPADRBOOK lpAdrBook,
                        HWND hWndEdit,
                        HWND hWndLV,
                        LPSORT_INFO lpSortInfo,
                        ULONG ulFlags,
                        int nMinLen,
                        LPRECIPIENT_INFO * lppContentsList)
{
	TCHAR szBuf[MAX_PATH];
    HRESULT hr = hrSuccess;
    LPSBinary rgsbEntryIDs  = NULL;
    ULONG cValues = 0;
    ULONG i =0;
    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPIAB lpIAB = (LPIAB)lpIAB;

    GetWindowText(hWndEdit,szBuf,ARRAYSIZE(szBuf));
	
	TrimSpaces(szBuf);
	

	if(lstrlen(szBuf))
	{
        if(lstrlen(szBuf) < nMinLen)
            goto out;

		// BUGBUG <JasonSo>: Need to pass in the correct container here...
        hr = HrFindFuzzyRecordMatches(
                        lpIAB->lpPropertyStore->hPropertyStore,
						NULL,
                        szBuf,
                        ulFlags, //flags
                        &cValues,
                        &rgsbEntryIDs);

        if(HR_FAILED(hr))
            goto out;

        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
        ClearListView(hWndLV, lppContentsList);

        if(cValues <= 0)
        {
            goto out;
        }

        for(i=0;i<cValues;i++)
        {
            LPRECIPIENT_INFO lpItem = NULL;

	        if(!ReadSingleContentItem(  lpAdrBook,
                                        rgsbEntryIDs[i].cb,
                                        (LPENTRYID) rgsbEntryIDs[i].lpb,
                                        &lpItem))
                continue;

            if(!lpItem)
                continue;
            //
            // Hook in the lpItem into the lpContentsList so we can free it later
            //
            lpItem->lpPrev = NULL;
            lpItem->lpNext = *lppContentsList;
            if (*lppContentsList)
                (*lppContentsList)->lpPrev = lpItem;
            (*lppContentsList) = lpItem;
        }

        HrFillListView(hWndLV,
					   *lppContentsList);

        SortListViewColumn( hWndLV, 0, lpSortInfo, TRUE);

        LVSelectItem(hWndLV, 0);

        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);



    }
    else
    {
        hr = HrGetWABContents(  hWndLV,
                                lpAdrBook,
                                NULL,
                                *lpSortInfo,
                                lppContentsList);
    }

out:


    FreeEntryIDs(((LPIAB)lpIAB)->lpPropertyStore->hPropertyStore,
                cValues,
                rgsbEntryIDs);

    SetCursor(hOldCur);

    return;
}
/*******/

//$$/////////////////////////////////////////////////////////////
//
// SetWindowPropertiesTitle - puts the objects name in front of the
//      TEXT(" Properties") and puts it in the title
//
//  e.g.  Viewing properties on Vikram Madan would show a window
//      with  TEXT("Vikram Madan Properties") in the title as per
//      Windows guidelines.
//      if bProperties is false, shows  TEXT("Vikram Madan Reports")
///////////////////////////////////////////////////////////////
void SetWindowPropertiesTitle(HWND hWnd, LPTSTR lpszName)
{
    LPTSTR lpszBuffer = NULL;
    TCHAR szBuf[MAX_UI_STR];
    TCHAR szTmp[MAX_PATH], *lpszTmp;

	LoadString( hinstMapiX, 
                idsWindowTitleProperties, 
                szBuf, ARRAYSIZE(szBuf));

    // Win9x bug FormatMessage cannot have more than 1023 chars
    CopyTruncate(szTmp, lpszName, MAX_PATH - 1);
    lpszTmp = szTmp;

	if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |
                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szBuf,
                        0,0, //ignored
                        (LPTSTR) &lpszBuffer,
                        MAX_UI_STR,
                        (va_list *)&lpszTmp))
    {
        SetWindowText(hWnd, lpszBuffer);
        LocalFreeAndNull(&lpszBuffer);
    }

    return;
}

/**** Dont mess with the order of these arrays (especially the address components street,city,zip etc ****/
static const SizedSPropTagArray(25, ToolTipsProps)=
{
    25,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_PERSONAL_HOME_PAGE,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_COMPANY_NAME,
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_BUSINESS_HOME_PAGE,
        PR_COMMENT,
    }
};

enum _prop
{
    txtDisplayName=0,
    txtEmailAddress,
    txtHomeAddress,
    txtHomeCity,
    txtHomeState,
    txtHomeZip,
    txtHomeCountry,
    txtHomePhone,
    txtHomeFax,
    txtHomeCellular,
    txtHomeWeb,
    txtBusinessTitle,
    txtBusinessDept,
    txtBusinessOffice,
    txtBusinessCompany,
    txtBusinessAddress,
    txtBusinessCity,
    txtBusinessState,
    txtBusinessZip,
    txtBusinessCountry,
    txtBusinessPhone,
    txtBusinessFax,
    txtBusinessPager,
    txtBusinessWeb,
    txtNotes
};

static const int idsString[] =
{
    0,
    idsContactTextEmail,
    idsContactTextHomeAddress,
    0,
    0,
    0,
    0,
    idsContactTextHomePhone,
    idsContactTextHomeFax,
    idsContactTextHomeCellular,
    idsContactTextPersonalWebPage,
    idsContactTextTitle,
    idsContactTextDepartment,
    idsContactTextOffice,
    idsContactTextCompany,
    idsContactTextBusinessAddress,
    0,
    0,
    0,
    0,
    idsContactTextBusinessPhone,
    idsContactTextBusinessFax,
    idsContactTextBusinessPager,
    idsContactTextBusinessWebPage,
    idsContactTextNotes,
};


//
// The routine that generates data for tooltips, clipboard, and printing
// creates a localized version of the address for the contact. This
// localized formatmessage string may contain ugly blank spaces due to
// missing data hence we need to cleanup the address string
// This works for US build - hopefully the localizers wont break it
//
void CleanAddressString(TCHAR * szAddress)
{
    LPTSTR lpTemp = szAddress;
    LPTSTR lpTemp2 = NULL;
    // we search for these 2 substrings
    LPTSTR szText1 = TEXT("    \r\n");
    LPTSTR szText2 = TEXT("     ");
    ULONG nSpaceCount = 0;


//
// BUGBUG: This routine is not DBCS smart!
// It should use IsSpace and CharNext to parse these strings.
//
    if(SubstringSearch(szAddress, szText2))
    {
        //First remove continuous blanks beyond 4
        while(*lpTemp)
        {
            if(*lpTemp == ' ')
            {
                nSpaceCount++;
                if(nSpaceCount == 5)
                {
                    lpTemp2 = lpTemp+1;
                    StrCpyN(lpTemp, lpTemp2, lstrlen(lpTemp2)+1);
                    nSpaceCount = 0;
                    lpTemp = lpTemp - 4;
                    continue;
                }
            }
            else
                nSpaceCount = 0;
            lpTemp++;
        }
    }

    while(SubstringSearch(szAddress, szText1))
    {
        lpTemp = szAddress;
        lpTemp2 = szText1;

        while (*lpTemp && *lpTemp2)
        {
            if (*lpTemp != *lpTemp2)
            {
                lpTemp -= (lpTemp2 - szText1);
                lpTemp2 = szText1;
            }
            else
            {
                lpTemp2++;
            }
            lpTemp++;
        }
        if(*lpTemp2 == '\0')
        {
            //match found
            LPTSTR lpTemp3 = lpTemp;
            lpTemp -= (lpTemp2-szText1);
            StrCpyN(lpTemp, lpTemp3, lstrlen(lpTemp3)+1);
        }
    }


    // also need to strip out the \r\n at the end of the address string
    nSpaceCount = lstrlen(szAddress);
    if(nSpaceCount >= 2)
        szAddress[nSpaceCount-2] = '\0';
    return;

}

//$$/////////////////////////////////////////////////////////////////////////////
//
// void HrGetLVItemDataString - Gets the item's data for the currently selected
//  item in the list view and puts it in a string
//
//  lpIAB - Pointer to AddrBook object
//  hWndLV - Handle of list view
//  nItem - item in list view whose properties we are retrieving
//  lpszData - returned string containing item properties - a buffer is allocated
//          to hold the data and the user needs to LocalFree the buffer
//
////////////////////////////////////////////////////////////////////////////////
HRESULT HrGetLVItemDataString(LPADRBOOK lpAdrBook, HWND hWndLV, int iItemIndex, LPTSTR * lppszData)
{
    HRESULT hr = E_FAIL;
    LPRECIPIENT_INFO lpItem = NULL;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcProps = 0;
    ULONG i =0,j=0;
    ULONG ulBufSize = 0;
    LPTSTR lpszData = NULL;
    LPTSTR szParanStart = TEXT("  (");
    LPTSTR szParanEnd = TEXT(")");
    LPTSTR szLineBreakDL = TEXT("\r\n  ");
    LPTSTR lpszHomeAddress = NULL, lpszBusinessAddress = NULL;
    LPTSTR lpszEmailAddresses = NULL;
    LPTSTR * lpsz = NULL;
    BOOL bBusinessTitle = FALSE, bPersonalTitle = FALSE;
    ULONG * lpulPropTagArray = NULL;
    ULONG cchSize;

    // Some items will have both the PR_CONTACT_EMAIL_ADDRESSES and PR_EMAIL_ADDRESS
    // while others will have only PR_EMAIL_ADDRESS
    // In case of the former, we want to avoid duplication by ignoring email-address
    // when contact-email-addresses exist. For this we use a flag.
    BOOL bFoundContactAddresses = FALSE;

    ULONG ulObjectType = 0;
    SizedSPropTagArray(3, DLToolTipsProps)=
    {
        3,
        {
            PR_DISPLAY_NAME,
            PR_WAB_DL_ENTRIES, 
            PR_WAB_DL_ONEOFFS,
        }
    };

    *lppszData = NULL;

    lpItem = GetItemFromLV(hWndLV, iItemIndex);
    if(lpItem)
    {
        hr = HrGetPropArray(lpAdrBook, NULL,
                            lpItem->cbEntryID,
                            lpItem->lpEntryID,
                            MAPI_UNICODE,
                            &ulcProps, &lpPropArray);
        if(HR_FAILED(hr))
            goto out;

        // is this a MailUser or a Distribution List
        ulObjectType = lpItem->ulObjectType;

        if(ulObjectType == MAPI_DISTLIST)
        {
            LPTSTR * lppszNameCache = NULL, * lppDLName = NULL, * lppDLOneOffName = NULL;
            LPTSTR * lppszEmailCache = NULL, * lppDLEmail = NULL, * lppDLOneOffEmail = NULL;
            ULONG ulNumNames = 0, ulNames = 0, ulOneOffNames = 0;

            // First we count the data to get a buffer size for our buffer
            for(j=0;j<DLToolTipsProps.cValues;j++)
            {
                for(i=0;i<ulcProps;i++)
                {
                    if(lpPropArray[i].ulPropTag == DLToolTipsProps.aulPropTag[j])
                    {
                        if(lpPropArray[i].ulPropTag == PR_DISPLAY_NAME)
                        {
                            if(ulBufSize)
                                ulBufSize += sizeof(TCHAR)*(lstrlen(szCRLF));
                            // we may fdo some overcounting here but its harmless
                            ulBufSize += sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ) + 1);
                            break;
                        }
                        else if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES || lpPropArray[i].ulPropTag == PR_WAB_DL_ONEOFFS)
                        {
                            ULONG k;

                            ulNumNames = lpPropArray[i].Value.MVbin.cValues;
                            lppszNameCache = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ulNumNames);
                            if(!lppszNameCache)
                                break;
                            lppszEmailCache = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ulNumNames);
                            if(!lppszEmailCache)
                                break;

                            // TBD - check this localalloc value

                            for (k = 0; k < ulNumNames; k++)
                            {
                                LPSPropValue lpProps = NULL;
                                ULONG ulcVal = 0;
                                ULONG n = 0;

                                lppszNameCache[k] = NULL;
                                lppszEmailCache[k] = NULL;

                                hr = HrGetPropArray(lpAdrBook, NULL,
                                                    lpPropArray[i].Value.MVbin.lpbin[k].cb,
                                                    (LPENTRYID)lpPropArray[i].Value.MVbin.lpbin[k].lpb,
                                                    MAPI_UNICODE,
                                                    &ulcVal,
                                                    &lpProps);
                                if(HR_FAILED(hr))
                                    continue;

                                for(n=0;n<ulcVal;n++)
                                {
                                    switch(lpProps[n].ulPropTag)
                                    {
                                    case PR_DISPLAY_NAME:
                                        {
                                            LPTSTR lpsz = lpProps[n].Value.LPSZ;
                                            if(ulBufSize)
                                                ulBufSize += sizeof(TCHAR)*(lstrlen(szLineBreakDL));
                                            ulBufSize += sizeof(TCHAR)*(lstrlen(lpsz)+1);
                                            // cache away this name so we dont have to open the property store again
                                            cchSize=lstrlen(lpsz)+1;
                                            lppszNameCache[k] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
                                            StrCpyN(lppszNameCache[k], lpsz, cchSize);
                                        }
                                        break;
                                    case PR_EMAIL_ADDRESS:
                                        {
                                            LPTSTR lpsz = lpProps[n].Value.LPSZ;
                                            if(ulBufSize)
                                            {
                                                ulBufSize += sizeof(TCHAR)*(lstrlen(szParanStart));
                                                ulBufSize += sizeof(TCHAR)*(lstrlen(szParanEnd));
                                            }
                                            ulBufSize += sizeof(TCHAR)*(lstrlen(lpsz)+1);
                                            // cache away this name so we dont have to open the property store again
                                            cchSize=lstrlen(lpsz)+1;
                                            lppszEmailCache[k] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
                                            StrCpyN(lppszEmailCache[k], lpsz, cchSize);
                                        }
                                        break;
                                    }

                                }
                                if(lpProps)
                                    MAPIFreeBuffer(lpProps);
                                lpProps = NULL;
                            }

                            if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES)
                            {
                                lppDLName = lppszNameCache;
                                lppDLEmail = lppszEmailCache;
                                ulNames = ulNumNames;
                            }
                            else
                            {
                                lppDLOneOffName = lppszNameCache;
                                lppDLOneOffEmail = lppszEmailCache;
                                ulOneOffNames = ulNumNames;
                            }
                            break;
                        } //if
                    }
                } //for i
            } // for j

            lpszData = LocalAlloc(LMEM_ZEROINIT, ulBufSize);

            for(j=0;j<DLToolTipsProps.cValues;j++)
            {
                for(i=0;i<ulcProps;i++)
                {
                    if(lpPropArray[i].ulPropTag == DLToolTipsProps.aulPropTag[j])
                    {
                        if(lpPropArray[i].ulPropTag == PR_DISPLAY_NAME)
                        {
                            if (lstrlen(lpszData))
                                StrCatBuff(lpszData,szCRLF,ulBufSize/sizeof(TCHAR));
                            StrCatBuff(lpszData,lpPropArray[i].Value.LPSZ,ulBufSize/sizeof(TCHAR));
                            break;
                        }
                        else if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES || 
                                lpPropArray[i].ulPropTag == PR_WAB_DL_ONEOFFS)
                        {
                            ULONG k;
                            lppszNameCache = (lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES) ? lppDLName : lppDLOneOffName;
                            lppszEmailCache = (lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES) ? lppDLEmail : lppDLOneOffEmail;
                            ulNumNames = (lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES) ? ulNames : ulOneOffNames;
                            for (k = 0; k < ulNumNames; k++)
                            {
                                if (lppszNameCache[k])
                                {
                                    StrCatBuff(lpszData,szLineBreakDL,ulBufSize/sizeof(TCHAR));
                                    StrCatBuff(lpszData,lppszNameCache[k],ulBufSize/sizeof(TCHAR));
                                    if(lppszEmailCache[k])
                                    {
                                        StrCatBuff(lpszData,szParanStart,ulBufSize/sizeof(TCHAR));
                                        StrCatBuff(lpszData,lppszEmailCache[k],ulBufSize/sizeof(TCHAR));
                                        StrCatBuff(lpszData,szParanEnd,ulBufSize/sizeof(TCHAR));
                                    }
                                }
                            }
                            break;
                        }
                    }
                } // for i
            } // for j

            // cleanup memory
            if(ulNames)
            {
                for(i=0;i<ulNames;i++)
                {
                    LocalFreeAndNull(&lppDLName[i]);
                    LocalFreeAndNull(&lppDLEmail[i]);
                }
                LocalFreeAndNull((LPVOID *)&lppDLName);
                LocalFreeAndNull((LPVOID *)&lppDLEmail);
            }
            if(ulOneOffNames)
            {
                for(i=0;i<ulOneOffNames;i++)
                {
                    LocalFreeAndNull(&lppDLOneOffName[i]);
                    LocalFreeAndNull(&lppDLOneOffEmail[i]);
                }
                LocalFreeAndNull((LPVOID *)&lppDLOneOffName);
                LocalFreeAndNull((LPVOID *)&lppDLOneOffEmail);
            }
            lppszNameCache = NULL;
            lppszEmailCache = NULL;

        }
        else
        {
            // Do MailUser Processing

            lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR) * ToolTipsProps.cValues);
            if(!lpsz)
            {
                DebugPrintError(( TEXT("Local Alloc failed\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            lpulPropTagArray = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ToolTipsProps.cValues);
            if(!lpulPropTagArray)
            {
                DebugPrintError(( TEXT("Local Alloc failed\n")));
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            // if we dont have PR_CONTACT_EMAIL_ADDRESSES we want PR_EMAIL_ADDRESS
            // and vice versa
            for(j=0;j<ToolTipsProps.cValues;j++)
            {
                lpulPropTagArray[j] = ToolTipsProps.aulPropTag[j];
                if(ToolTipsProps.aulPropTag[j] == PR_EMAIL_ADDRESS)
                {
                    for(i=0;i<ulcProps;i++)
                    {
                        if(lpPropArray[i].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                        {
                            lpulPropTagArray[j] = PR_CONTACT_EMAIL_ADDRESSES;
                            break;
                        }
                    }
                }
            }


            for(j=0;j<ToolTipsProps.cValues;j++)
            {
                lpsz[j]=NULL;
                for(i=0;i<ulcProps;i++)
                {
                    if(lpPropArray[i].ulPropTag == lpulPropTagArray[j])
                    {
                        if(PROP_TYPE(lpPropArray[i].ulPropTag) == PT_TSTRING)
                        {
                            if(lpPropArray[i].ulPropTag == PR_EMAIL_ADDRESS)
                            {
                                ulBufSize = sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ)+lstrlen(szLineBreakDL)+1);
                                lpszEmailAddresses = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
                                if(!lpszEmailAddresses)
                                {
                                    DebugPrintError(( TEXT("Local Alloc Failed\n")));
                                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                                    goto out;
                                }
                                StrCpyN(lpszEmailAddresses, szLineBreakDL,ulBufSize/sizeof(TCHAR));
                                StrCatBuff(lpszEmailAddresses, lpPropArray[i].Value.LPSZ,ulBufSize/sizeof(TCHAR));
                                lpsz[j] = lpszEmailAddresses;
                            }
                            else
                                lpsz[j] = lpPropArray[i].Value.LPSZ;
                        }
                        else if(PROP_TYPE(lpPropArray[i].ulPropTag) == PT_MV_TSTRING)
                        {
                            ULONG k,ulBufSize=0;
                            for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                            {
                                ulBufSize += sizeof(TCHAR)*(lstrlen(szLineBreakDL));
                                ulBufSize += sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.MVSZ.LPPSZ[k])+1);
                            }
                            lpszEmailAddresses = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
                            if(!lpszEmailAddresses)
                            {
                                DebugPrintError(( TEXT("Local Alloc Failed\n")));
                                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                                goto out;
                            }
                            lpszEmailAddresses[0]=TEXT('\0');
                            for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                            {
                                StrCatBuff(lpszEmailAddresses,szLineBreakDL,ulBufSize/sizeof(TCHAR));
                                StrCatBuff(lpszEmailAddresses,lpPropArray[i].Value.MVSZ.LPPSZ[k],ulBufSize/sizeof(TCHAR));
                            }
                            lpsz[j]=lpszEmailAddresses;
                            break;
                        } //if
                    }//if
                }//for i
            }// for j

            //
            // Making this an elegant solution is really hard - just hack it for now
            //


            ulBufSize = 0;

            // Set the display name to the displayed name (whether it is
            // by first name or last name)
            lpsz[txtDisplayName] = lpItem->szDisplayName;

            // Set the localized versions of the addresses if any
            for(i=txtHomeAddress;i<=txtHomeCountry;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    {
                        //Bug 1115995 -  TEXT("(null)")s produced by Format message for null pointers
                        // in the va_list .. replace these with szEmpty
                        for(j=txtHomeAddress;j<=txtHomeCountry;j++)
                            if(!lpsz[j])
                                lpsz[j]=szEmpty;

                    }
                    LoadString(hinstMapiX, idsContactAddress, szBuf, ARRAYSIZE(szBuf));
                    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szBuf,
                          0,                    // stringid
                          0,                    // dwLanguageId
                          (LPTSTR)&lpszHomeAddress,     // output buffer
                          0,                    //MAX_UI_STR
                          (va_list *)&lpsz[txtHomeAddress]))
                    {
                        for(j=txtHomeAddress;j<=txtHomeCountry;j++)
                            lpsz[j]=NULL;
                        CleanAddressString(lpszHomeAddress);
                        lpsz[txtHomeAddress] = lpszHomeAddress;
                        break;
                    }

                }
            }

            for(i=txtHomeAddress;i<=txtHomeWeb;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    bPersonalTitle = TRUE;
                    LoadString(hinstMapiX, idsContactTextPersonal, szBuf, ARRAYSIZE(szBuf));
                    ulBufSize += sizeof(TCHAR)*(lstrlen(szBuf));
                    break;
                }
            }

            for(i=txtBusinessAddress;i<=txtBusinessCountry;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    {
                        //Bug 1115995 -  TEXT("(null)")s produced by Format message for null pointers
                        // in the va_list .. replace these with szEmpty
                        for(j=txtBusinessAddress;j<=txtBusinessCountry;j++)
                            if(!lpsz[j])
                                lpsz[j]=szEmpty;

                    }
                    LoadString(hinstMapiX, idsContactAddress, szBuf, ARRAYSIZE(szBuf));
                    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          szBuf,
                          0,                    // stringid
                          0,                    // dwLanguageId
                          (LPTSTR)&lpszBusinessAddress,     // output buffer
                          0,                    //MAX_UI_STR
                          (va_list *)&lpsz[txtBusinessAddress]))
                    {
                        for(j=txtBusinessAddress;j<=txtBusinessCountry;j++)
                            lpsz[j]=NULL;
                        CleanAddressString(lpszBusinessAddress);
                        lpsz[txtBusinessAddress] = lpszBusinessAddress;
                        break;
                    }

                }
            }

            for(i=txtBusinessAddress;i<=txtBusinessWeb;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    bBusinessTitle = TRUE;
                    LoadString(hinstMapiX, idsContactTextBusiness, szBuf, ARRAYSIZE(szBuf));
                    ulBufSize += sizeof(TCHAR)*(lstrlen(szBuf));
                    break;
                }
            }


            for(i=0;i<ToolTipsProps.cValues;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    if(idsString[i] != 0)
                    {
                        LoadString(hinstMapiX, idsString[i], szBuf, ARRAYSIZE(szBuf));
                        ulBufSize += sizeof(TCHAR)*(lstrlen(szBuf));
                    }
                    ulBufSize += sizeof(TCHAR)*(lstrlen(lpsz[i])+lstrlen(szCRLF));
                }
            }

            ulBufSize += sizeof(TCHAR); // space for trailing zero

            lpszData = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
            if(!lpszData)
            {
                DebugPrintError(( TEXT("Local Alloc failed\n")));
                goto out;
            }

            *lpszData = TEXT('\0');

            for(i=0;i<ToolTipsProps.cValues;i++)
            {
                if(lpsz[i])
                {
                    TCHAR szBuf[MAX_UI_STR];
                    switch(i)
                    {
                    case txtHomeAddress:
                    case txtHomePhone:
                    case txtHomeFax:
                    case txtHomeCellular:
                    case txtHomeWeb:
                        if(bPersonalTitle)
                        {
                            bPersonalTitle = FALSE;
                            LoadString(hinstMapiX, idsContactTextPersonal, szBuf, ARRAYSIZE(szBuf));
                            StrCatBuff(lpszData, szBuf, ulBufSize/sizeof(TCHAR));
                        }
                        break;
                    case txtBusinessTitle:
                    case txtBusinessDept:
                    case txtBusinessOffice:
                    case txtBusinessCompany:
                    case txtBusinessAddress:
                    case txtBusinessPhone:
                    case txtBusinessFax:
                    case txtBusinessPager:
                    case txtBusinessWeb:
                        if(bBusinessTitle)
                        {
                            bBusinessTitle = FALSE;
                            LoadString(hinstMapiX, idsContactTextBusiness, szBuf, ARRAYSIZE(szBuf));
                            StrCatBuff(lpszData, szBuf, ulBufSize/sizeof(TCHAR));
                        }
                        break;
                    }
                    if(idsString[i] != 0)
                    {
                        LoadString(hinstMapiX, idsString[i], szBuf, ARRAYSIZE(szBuf));
                        StrCatBuff(lpszData, szBuf, ulBufSize/sizeof(TCHAR));
                    }
                    StrCatBuff(lpszData, lpsz[i], ulBufSize/sizeof(TCHAR));
                    StrCatBuff(lpszData, szCRLF, ulBufSize/sizeof(TCHAR));
                }
            }

            //There is a spurious szCRLF at the end. Negate it
            ulBufSize = lstrlen(lpszData);
            lpszData[ulBufSize-2]='\0';


        } // mailuser or dist list

    }

    *lppszData = lpszData;
    hr = hrSuccess;
out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpszHomeAddress)
        LocalFree(lpszHomeAddress);
    if(lpszBusinessAddress)
        LocalFree(lpszBusinessAddress);
    if(lpszEmailAddresses)
        LocalFree(lpszEmailAddresses);
    if(lpsz)
        LocalFree(lpsz);

    if(lpulPropTagArray)
        LocalFree(lpulPropTagArray);

    if(HR_FAILED(hr))
    {
        LocalFreeAndNull(&lpszData);
        LocalFreeAndNull(lppszData);
    }

    return hr;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
// HrCopyItemDataToClipboard - Copies text from selected items in a List View
//      into the clipboard
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT HrCopyItemDataToClipboard(HWND hWnd, LPADRBOOK lpAdrBook, HWND hWndLV)
{
    HRESULT hr = E_FAIL;
    int iItemIndex = 0, i = 0;
    int iLastItemIndex = -1;
    int nItemCount = ListView_GetSelectedCount(hWndLV);
    LPTSTR lpszClipBoardData = NULL;

    if( nItemCount <= 0)
        goto out;
    // TBD - messagebox here or item should be grayed

    for(i=0;i<nItemCount;i++)
    {
        LPTSTR lpszData = NULL;
        LPTSTR lpszData2 = NULL;
        ULONG ulMemSize = 0;

        iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);

        hr = HrGetLVItemDataString(
                                lpAdrBook,
                                hWndLV,
                                iItemIndex,
                                &lpszData);
        if(HR_FAILED(hr))
        {
            goto out;
        }
        else
        {

            if(lpszData)
            {

                // Take the existing clipboard data and add
                // a linebreak and the new data and another linebreak

                if(lpszClipBoardData)
                    ulMemSize = sizeof(TCHAR)*(lstrlen(lpszClipBoardData)+lstrlen(szCRLF));

                ulMemSize += sizeof(TCHAR)*(lstrlen(lpszData) + lstrlen(szCRLF) + 1);

                lpszData2 = LocalAlloc(LMEM_ZEROINIT, ulMemSize);
                if(!lpszData2)
                {
                    hr = MAPI_E_NOT_ENOUGH_MEMORY;
                    goto out;
                }

                if(lpszClipBoardData)
                {
                    StrCpyN(lpszData2, lpszClipBoardData, ulMemSize/sizeof(TCHAR));
                    StrCatBuff(lpszData2, szCRLF, ulMemSize/sizeof(TCHAR));
                }

                StrCatBuff(lpszData2, lpszData, ulMemSize/sizeof(TCHAR));
                StrCatBuff(lpszData2, szCRLF, ulMemSize/sizeof(TCHAR));

                LocalFreeAndNull(&lpszClipBoardData);

                LocalFreeAndNull(&lpszData);

                lpszClipBoardData = lpszData2;

            }
        }

        iLastItemIndex = iItemIndex;

    }

    if(lpszClipBoardData)
    {
        LPSTR lpszA = ConvertWtoA(lpszClipBoardData);
        OpenClipboard(hWnd);
        EmptyClipboard();

        // We now hand over ownership of the clipboard data to the clipboard
        // which means that we dont have to free this pointer anymore
        SetClipboardData(CF_TEXT, lpszA);
        SetClipboardData(CF_UNICODETEXT, lpszClipBoardData);
        LocalFreeAndNull(&lpszA);
        CloseClipboard();
    }

    hr = hrSuccess;

out:

    return hr;
}


//*******************************************************************
//
//  FUNCTION:   InitCommonControlLib
//
//  PURPOSE:    Load the CommCtrl client libray and get the proc addrs.
//
//  PARAMETERS: None.
//
//  RETURNS:    TRUE if successful, FALSE otherwise.
//
//*******************************************************************
BOOL InitCommonControlLib(void)
{
  // See if we already initialized.
  if (NULL == ghCommCtrlDLLInst)
  {
    Assert(gulCommCtrlDLLRefCount == 0);

    // open LDAP client library
    ghCommCtrlDLLInst = LoadLibrary(cszCommCtrlClientDLL);
    if (!ghCommCtrlDLLInst)
    {
      DebugTraceResult( TEXT("InitCommCtrlClientLib: Failed to LoadLibrary CommCtrl"),GetLastError());
      return FALSE;
    }

    // cycle through the API table and get proc addresses for all the APIs we
    // need
    if (!GetApiProcAddresses(ghCommCtrlDLLInst,CommCtrlAPIList,NUM_CommCtrlAPI_PROCS))
    {
      DebugTrace( TEXT("InitCommCTrlLib: Failed to load LDAP API.\n"));

      // Unload the library we just loaded.
      if (ghCommCtrlDLLInst)
      {
        FreeLibrary(ghCommCtrlDLLInst);
        ghCommCtrlDLLInst = NULL;
      }

      return FALSE;
    }

    // Initialize the CommonControl classes
    {
        INITCOMMONCONTROLSEX iccex;
        iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccex.dwICC =   //ICC_ALL_CLASSES;
                        ICC_LISTVIEW_CLASSES |
                        ICC_TREEVIEW_CLASSES |
                        ICC_BAR_CLASSES |
                        ICC_COOL_CLASSES |
                        ICC_ANIMATE_CLASS |
                        ICC_WIN95_CLASSES |
                        ICC_DATE_CLASSES;

        iccex.dwICC |= ICC_NATIVEFNTCTL_CLASS;

        if(!gpfnInitCommonControlsEx(&iccex))
        {
            //Couldnt initialize
              DebugTrace( TEXT("InitCommCTrlLib: Failed to InitCommonControlsEx\n"));

              // Unload the library we just loaded.
              if (ghCommCtrlDLLInst)
              {
                FreeLibrary(ghCommCtrlDLLInst);
                ghCommCtrlDLLInst = NULL;
              }

              return FALSE;
        }
    }
  }

  gulCommCtrlDLLRefCount++;
  return TRUE;
}


//$$*****************************************************************
//
//  FUNCTION:   DeinitCommCtrlClientLib
//
//  PURPOSE:    decrement refcount on LDAP CLient library and
//              release if 0.
//
//  PARAMETERS: None.
//
//  RETURNS:    current refcount
//
//*******************************************************************
ULONG DeinitCommCtrlClientLib(void) {
    if (-- gulCommCtrlDLLRefCount == 0) {
        UINT nIndex;
        // No clients using the CommCtrl library.  Release it.

        if (ghCommCtrlDLLInst) {
            FreeLibrary(ghCommCtrlDLLInst);
            ghCommCtrlDLLInst = NULL;
        }

        // cycle through the API table and NULL proc addresses for all the APIs
        for (nIndex = 0; nIndex < NUM_CommCtrlAPI_PROCS; nIndex++) {
            *CommCtrlAPIList[nIndex].ppFcnPtr = NULL;
        }
    }
    return(gulCommCtrlDLLRefCount);
}



//$$*****************************************************************
//
//  FUNCTION:   HelpAboutDialogProc
//
//  PURPOSE:    minimal help/about dialog proc
//
//
//*******************************************************************
INT_PTR CALLBACK HelpAboutDialogProc(  HWND    hDlg,
                                       UINT    message,
                                       WPARAM  wParam,
                                       LPARAM  lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            // Easiest to keep this version info stuff in ANSI than to write wrappers for it ..
            // 
            DWORD dwSize = 0, dwh = 0;
            ULONG i = 0;
            char szFile[MAX_PATH];
            LPTSTR lpDataFile = NULL;
            GetModuleFileNameA(hinstMapiXWAB, szFile, sizeof(szFile));
            if(dwSize = GetFileVersionInfoSizeA(szFile, &dwh))
            {
                LPWORD lpwTrans = NULL;
                LPVOID lpInfo = LocalAlloc(LMEM_ZEROINIT, dwSize+1);
                if(lpInfo)
                {
                    if(GetFileVersionInfoA( szFile, dwh, dwSize, lpInfo))
                    {
                        LPVOID lpVersion = NULL, lpszT = NULL;
                        DWORD uLen;
                        char szBuf[MAX_UI_STR];
                        if (VerQueryValueA(lpInfo,  "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) &&
                            uLen >= (2 * sizeof(WORD)))
                        {
                            // set up buffer for calls to VerQueryValue()
                            CHAR *rgszVer[] = {  "FileVersion",  "LegalCopyright" };
                            int rgId[] =  { IDC_ABOUT_LABEL_VERSION, IDC_ABOUT_COPYRIGHT };
                            DWORD cch;

                            wnsprintfA(szBuf, ARRAYSIZE(szBuf), "\\StringFileInfo\\%04X%04X\\", lpwTrans[0], lpwTrans[1]);
                            lpszT = szBuf + lstrlenA(szBuf);    
                            cch = ARRAYSIZE(szBuf) - lstrlenA(szBuf);

                            // Walk through the dialog items that we want to replace:
                            for (i = 0; i <= 1; i++) 
                            {
                                StrCpyNA(lpszT, rgszVer[i], cch);
                                if (VerQueryValueA(lpInfo, szBuf, (LPVOID *)&lpVersion, &uLen) && uLen)
                                {
                                    LPTSTR lp = ConvertAtoW((LPSTR) lpVersion);
                                    SetDlgItemText(hDlg, rgId[i], lp);
                                    LocalFreeAndNull(&lp);
                                }
                            }
                        }
                    }
                    LocalFree(lpInfo);
                }
            }
            else
                DebugPrintTrace(( TEXT("GetFileVersionSize failed: %d\n"),GetLastError()));
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_lpIAB && !pt_bIsWABOpenExSession)
                {
                    // hack
                    lpDataFile = GetWABFileName(((LPIAB)pt_lpIAB)->lpPropertyStore->hPropertyStore, FALSE);
                }
                if(lpDataFile && lstrlen(lpDataFile))
                    SetDlgItemText(hDlg, IDC_ABOUT_EDIT_FILENAME, lpDataFile);
                else
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_ABOUT_EDIT_FILENAME), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_ABOUT_STATIC_FILENAME), SW_HIDE);
                }
            }
        }
        break;

   case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
        case IDOK:
            EndDialog(hDlg, 0);
            break;
        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

//$$////////////////////////////////////////////////////////////////////
//
//  nTruncatePos
//
// With DBCS strings we want to truncate the string at the beginning of
//  a TCHAR and not in the middle of the double TCHAR.
//  Hence we take a string, take in the maximum length we want, scan the
//  string and return the length of the string at which we can safely
//  truncate
//
// PARAMETERS:
//      lpsz - input string
//      nMaxLen - maximum allowed length of the string
//
////////////////////////////////////////////////////////////////////////
ULONG TruncatePos(LPTSTR lpsz, ULONG nMaxLen)
{
    ULONG nLen = 0;
    ULONG nDesiredLen = 0;


    if(!lpsz || !lstrlen(lpsz) || !nMaxLen)
        goto out;

    nLen = lstrlen(lpsz);

    if (nLen >= nMaxLen)
    {
        ULONG nCharsSteppedOverCount = 0;
        ULONG nLastCharCount = 0;
        ULONG nTotalLen = nLen; //lstrlen(lpsz);
        nDesiredLen = nMaxLen;
        while(*lpsz)
        {
            nLastCharCount = nCharsSteppedOverCount;
            lpsz = CharNext(lpsz);
            nCharsSteppedOverCount = nTotalLen - lstrlen(lpsz); // + 1;
            if(nCharsSteppedOverCount > nDesiredLen)
                break;
        }
        if (nCharsSteppedOverCount < nDesiredLen)
            nLen = nCharsSteppedOverCount;
        else
            nLen = nLastCharCount;
    }

out:
    return nLen;
}

//$$////////////////////////////////////////////////////////////////////
//
//  FreeRecipList - frees allocated memory in a RecipientInfo List
//
//
// PARAMETERS:
//      lppList - list to free
//
////////////////////////////////////////////////////////////////////////
void FreeRecipList(LPRECIPIENT_INFO * lppList)
{
    if(lppList)
    {
    	LPRECIPIENT_INFO lpItem = NULL;
    	lpItem = *lppList;
    	while(lpItem)
    	{
    		*lppList = lpItem->lpNext;
    		FreeRecipItem(&lpItem);
    		lpItem = *lppList;
    	}
    	*lppList = NULL;
    }

    return;
}


//$$////////////////////////////////////////////////////////////////////
//
//  HrCreateNewObject - Creates a new object in the wab
//
//
// PARAMETERS:
//      lpIAB - lpAdrbook
//      &lpMailUser - MailUser to return
//
////////////////////////////////////////////////////////////////////////
HRESULT HrCreateNewObject(LPADRBOOK lpAdrBook,
                          LPSBinary lpsbContainer,
                          ULONG ulObjectType,  
                            ULONG ulCreateFlags,
                            LPMAPIPROP * lppPropObj)
{
    HRESULT     hResult = hrSuccess;
    LPENTRYID   lpWABEID = NULL;
    ULONG       cbWABEID = 0;
    ULONG       ulObjType = 0;
    ULONG       cProps = 0;
    LPABCONT    lpContainer = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPMAPIPROP lpPropObj = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = (LPIAB) lpAdrBook;
    
    if(!lpsbContainer || !lpsbContainer->cb || !lpsbContainer->lpb)
    {
        SetVirtualPABEID(lpIAB, &cbWABEID, &lpWABEID);
        if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbWABEID, &lpWABEID)) 
            goto exit;
    }
    else
    {
        cbWABEID = lpsbContainer->cb;
        lpWABEID = (LPENTRYID) lpsbContainer->lpb;
    }

    if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)&lpContainer)) {
            goto exit;
        }

    // Get us the creation entryids
    if (hResult = lpContainer->lpVtbl->GetProps(lpContainer,
          (LPSPropTagArray)&ptaCreate,
          MAPI_UNICODE,
          &cProps,
          &lpCreateEIDs)) {
            DebugTrace( TEXT("Can't get container properties for PAB\n"));
            // Bad stuff here!
            goto exit;
        }

    if (hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
          (ulObjectType == MAPI_MAILUSER ? 
              lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.cb : lpCreateEIDs[icrPR_DEF_CREATE_DL].Value.bin.cb),
          (ulObjectType == MAPI_MAILUSER ? 
            (LPENTRYID)lpCreateEIDs[icrPR_DEF_CREATE_MAILUSER].Value.bin.lpb : (LPENTRYID)lpCreateEIDs[icrPR_DEF_CREATE_DL].Value.bin.lpb),
          ulCreateFlags,
          &lpPropObj)) {
            DebugTraceResult( TEXT("CreateMailUser:CreateEntry"), hResult);
            goto exit;
        }

    *lppPropObj = lpPropObj;

exit:

    if(HR_FAILED(hResult) && lpPropObj)
        lpPropObj->lpVtbl->Release(lpPropObj);

    if(lpWABEID && (!lpsbContainer || lpsbContainer->lpb != (LPBYTE) lpWABEID))
        FreeBufferAndNull(&lpWABEID);
    UlRelease(lpContainer);
    FreeBufferAndNull(&lpCreateEIDs);

    return hResult;
}

const LPTSTR szDefMailKey =  TEXT("Software\\Clients\\Mail");
const LPTSTR szOEDllPathKey =   TEXT("DllPath");
const LPTSTR szOEName =  TEXT("Outlook Express");

//$$///////////////////////////////////////////////////////////////////////
//
// CheckForOutlookExpress
//
//  szDllPath - is a big enough buffer that will contain the path for
//      the OE dll ..
//
//////////////////////////////////////////////////////////////////////////
BOOL CheckForOutlookExpress(LPTSTR szDllPath, DWORD cchDllPath)
{
    HKEY hKeyMail   = NULL;
    HKEY hKeyOE     = NULL;
    DWORD dwErr     = 0;
    DWORD dwSize    = 0;
    TCHAR szBuf[MAX_PATH];
    TCHAR szPathExpand[MAX_PATH];
    DWORD dwType    = 0;
    BOOL bRet = FALSE;


    szDllPath[0] = TEXT('\0');
    szPathExpand[0] = TEXT('\0');

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDefMailKey, 0, KEY_READ, &hKeyMail);
    if(dwErr != ERROR_SUCCESS)
    {
        DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = ARRAYSIZE(szBuf);         // Expect ERROR_MORE_DATA

    dwErr = RegQueryValueEx(    hKeyMail, NULL, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(!lstrcmpi(szBuf, szOEName))
    {
        // Yes its outlook express ..
        bRet = TRUE;
    }

    //Get the DLL Path anyway whether this is the default key or not

    // Get the DLL Path
    dwErr = RegOpenKeyEx(hKeyMail, szOEName, 0, KEY_READ, &hKeyOE);
    if(dwErr != ERROR_SUCCESS)
    {
        DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwSize = ARRAYSIZE(szBuf);
    szBuf[0]=TEXT('\0');

    dwErr = RegQueryValueEx(hKeyOE, szOEDllPathKey, NULL, &dwType, (LPBYTE)szBuf, &dwSize);
    if (REG_EXPAND_SZ == dwType) 
    {
        ExpandEnvironmentStrings(szBuf, szPathExpand, ARRAYSIZE(szPathExpand));
        StrCpyN(szBuf, szPathExpand,ARRAYSIZE(szBuf));
    }


    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(lstrlen(szBuf))
        StrCpyN(szDllPath, szBuf, cchDllPath);

out:
    if(hKeyOE)
        RegCloseKey(hKeyOE);
    if(hKeyMail)
        RegCloseKey(hKeyMail);
    return bRet;
}

static const SizedSPropTagArray(1, ptaMailToExItemType)=
{
    1,
    {
        PR_OBJECT_TYPE,
    }
};
// We will create a linked list of all selected entries that have an
// email address and then use that to create the recip list for sendmail
typedef struct _RecipList
{
    LPTSTR lpszName;
    LPTSTR lpszEmail;
    LPSBinary lpSB;
    struct _RecipList * lpNext;
} RECIPLIST, * LPRECIPLIST;

//$$/////////////////////////////////////////////////////////////////////
//
// FreeLPRecipList
//
// Frees a linked list containing the above structures
//
/////////////////////////////////////////////////////////////////////////
void FreeLPRecipList(LPRECIPLIST lpList)
{
    if(lpList)
    {
        LPRECIPLIST lpTemp = lpList;
        while(lpTemp)
        {
            lpList = lpTemp->lpNext;
            if(lpTemp->lpszName)
                LocalFree(lpTemp->lpszName);
            if(lpTemp->lpszEmail)
                LocalFree(lpTemp->lpszEmail);
            if(lpTemp->lpSB)
                MAPIFreeBuffer(lpTemp->lpSB);

            LocalFree(lpTemp);
            lpTemp = lpList;
        }
    }
}

//$$/////////////////////////////////////////////////////////////////////
//
// GetItemNameEmail
//
//  Gets the name and email address of the specified item
//  and appends it to the provided linked list ..
//
/////////////////////////////////////////////////////////////////////////
HRESULT HrGetItemNameEmail( LPADRBOOK lpAdrBook,
                            BOOL bIsOE,
                            ULONG cbEntryID,
                            LPENTRYID lpEntryID,
                            int nExtEmail,
                            LPRECIPLIST * lppList)
{
    HRESULT hr = E_FAIL;
    ULONG cValues;
    LPRECIPLIST lpTemp = NULL;
    LPSPropValue lpspv = NULL;
    LPRECIPLIST lpList = *lppList;
    LPTSTR lpEmail = NULL, lpAddrType = NULL, lpName = NULL;
    SizedSPropTagArray(5, ptaMailToEx)=
    {
        5,  {
                PR_DISPLAY_NAME,
                PR_EMAIL_ADDRESS,
                PR_ADDRTYPE,
                PR_CONTACT_EMAIL_ADDRESSES,
                PR_CONTACT_ADDRTYPES
            }
    };


    // Open the entry and read the email address.
    // NOTE: We can't just take the address out of the listbox
    // because it may be truncated!
    if (HR_FAILED(hr = HrGetPropArray(  lpAdrBook,
                                        (LPSPropTagArray)&ptaMailToEx,
                                         cbEntryID,
                                         lpEntryID,
                                         MAPI_UNICODE,
                                         &cValues,
                                         &lpspv)))
    {
        goto out;
    }

    lpName = (lpspv[0].ulPropTag == PR_DISPLAY_NAME) ? lpspv[0].Value.LPSZ : szEmpty;
    
    if( nExtEmail && 
        lpspv[3].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES &&
        lpspv[4].ulPropTag == PR_CONTACT_ADDRTYPES && 
        lpspv[3].Value.MVSZ.cValues >= (ULONG)nExtEmail)
    {
        lpEmail = lpspv[3].Value.MVSZ.LPPSZ[nExtEmail-1];
        lpAddrType = lpspv[4].Value.MVSZ.LPPSZ[nExtEmail-1];
    }
    
    if(!lpEmail)
        lpEmail = (lpspv[1].ulPropTag == PR_EMAIL_ADDRESS) ? lpspv[1].Value.LPSZ : szEmpty;
     
    if(!lpAddrType)
        lpAddrType = (lpspv[2].ulPropTag == PR_ADDRTYPE) ? lpspv[2].Value.LPSZ : szEmpty;

     if(lstrlen(lpEmail) && lstrlen(lpName)) //only if this item has a email address do we include it
    {
        lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPLIST));
        if(lpTemp)
        {
            DWORD cchEmail;
            DWORD cchName=lstrlen(lpName) + 1;
            lpTemp->lpszName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchName);
            if (lpTemp->lpszName)
            {
                StrCpyN(lpTemp->lpszName, lpName, cchName);
            }

            cchEmail=(lstrlen(lpEmail) + lstrlen(lpAddrType) + 2);
            lpTemp->lpszEmail = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchEmail);
            if (lpTemp->lpszEmail)
            {
                if(bIsOE)
                {
                    lpTemp->lpszEmail[0]=TEXT('\0');
                }
                else
                {
                    StrCpyN(lpTemp->lpszEmail, lpAddrType, cchEmail);
                    StrCatBuff(lpTemp->lpszEmail, szColon, cchEmail);
                }
                StrCatBuff(lpTemp->lpszEmail, lpEmail, cchEmail);
            }

            MAPIAllocateBuffer(sizeof(SBinary), (LPVOID) &(lpTemp->lpSB));

            // Create a one off entry id for this buffer
            CreateWABEntryID(WAB_ONEOFF,
                            lpTemp->lpszName,
                            lpAddrType,
                            lpEmail,
                            0, 0,
                            (LPVOID) lpTemp->lpSB,
                            (LPULONG) (&(lpTemp->lpSB->cb)),
                            (LPENTRYID *) &(lpTemp->lpSB->lpb));

            lpTemp->lpNext = lpList;
            lpList = lpTemp;
        }
    }
    FreeBufferAndNull(&lpspv);

    *lppList = lpList;

    hr = S_OK;

out:

    return hr;
}


//$$//////////////////////////////////////////////////////////////////
//
// Function that opens an item and adds it to the recip list
// If the opened item is a group, calls itself recursively for all
// subgroups ..
//
//  lpnRecipCount - returns the number of items in lppList
//  lppList - dynamically allocated - must be freed by caller
//  bIsOE - tells us to follow a slightly different code-path to handle OE
//          inconsistencies - ** warning ** - this will break when they
//          fix their inconsistencies
//  nExtEmail - this is non-zero when there is a single selection and the
//          user chose a non-default email address which should be used for
//          sending mail
//
//////////////////////////////////////////////////////////////////////
HRESULT GetRecipListFromSelection(LPADRBOOK lpAdrBook,
                               BOOL bIsOE,
                               ULONG cbEntryID,
                               LPENTRYID lpEntryID,
                               int nExtEmail,
                               ULONG * lpnRecipCount,
                               ULONG * lpnNoEmailCount,
                               LPRECIPLIST * lppList)
{
    ULONG ulObjectType = 0;
    HRESULT hr = E_FAIL;

    {
        ULONG cValues = 0;
        LPSPropValue lpspv = NULL;

        // First check if this item is a mailuser or a group
        if (HR_FAILED(hr = HrGetPropArray(  lpAdrBook,
                                            (LPSPropTagArray)&ptaMailToExItemType,
                                             cbEntryID,
                                             lpEntryID,
                                             MAPI_UNICODE,
                                             &cValues,
                                             &lpspv)))
        {
            return hr;
        }
        ulObjectType = lpspv[0].Value.l;
        FreeBufferAndNull(&lpspv);
    }


    if(ulObjectType == MAPI_MAILUSER)
    {
        LPRECIPLIST lpTemp = *lppList;
        if (!HR_FAILED(hr = HrGetItemNameEmail(lpAdrBook, bIsOE, cbEntryID,lpEntryID, nExtEmail, lppList)))
        {
            if(lpTemp != *lppList) // means an item was added to the list ..
                (*lpnRecipCount)++;
            else
                (*lpnNoEmailCount)++;
        }
	}
    else if(ulObjectType == MAPI_DISTLIST)
    {
        ULONG cValues = 0;
        LPSPropValue lpspv = NULL;
        SizedSPropTagArray(2, tagaDLEntriesOneOffs) =
        {
            2,
            {
                PR_WAB_DL_ENTRIES,
                PR_WAB_DL_ONEOFFS,
            }
        };


        if (HR_FAILED(hr = HrGetPropArray(  lpAdrBook, (LPSPropTagArray)&tagaDLEntriesOneOffs,
                                            cbEntryID, lpEntryID,
                                            MAPI_UNICODE,
                                            &cValues, &lpspv)))
        {
            return hr;
        }

        {
            ULONG i,j;
            for(i=0;i<2;i++)
            {
                if(lpspv[i].ulPropTag == PR_WAB_DL_ENTRIES || lpspv[i].ulPropTag == PR_WAB_DL_ONEOFFS)
                {
                    // Look at each entry in the PR_WAB_DL_ENTRIES and PR_WAB_DL_ONEOFFS
                    for (j = 0; j < lpspv[i].Value.MVbin.cValues; j++)
                    {
                        ULONG cbEID = lpspv[i].Value.MVbin.lpbin[j].cb;
                        LPENTRYID lpEID = (LPENTRYID)lpspv[i].Value.MVbin.lpbin[j].lpb;

                        GetRecipListFromSelection(lpAdrBook, bIsOE, cbEID, lpEID, 0, lpnRecipCount, lpnNoEmailCount, lppList);
                    }
                }
            }
        }
        FreeBufferAndNull(&lpspv);
    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////
//
//  HrSendMail - does the actual mail sending
//          Our first priority is to Outlook Express which currently has a
//          different code path than the regular MAPI client .. so we look
//          under HKLM\Software\Clients\Mail .. if the client is OE then
//          we just loadlibrary and getprocaddress for sendmail
//          If its not OE, then we call the mapi32.dll and load it ..
//          If both fail we will not be able to send mail ...
//
//          This function will free the lpList no matter what happens
//          so caller should not expect to reuse it (This is so we can
//          give the pointer to a seperate thread and not worry about it)
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMail(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, LPIAB lpIAB, BOOL bUseOEForSendMail)
{
	HRESULT hr = E_FAIL;
    HINSTANCE hLibMapi = NULL;
    BOOL bIsOE = FALSE; // right now there is a different code path
                        // for OE vs other MAPI clients

    TCHAR szBuf[MAX_PATH];
    LPMAPISENDMAIL lpfnMAPISendMail = NULL;
    LHANDLE hMapiSession = 0;
    LPMAPILOGON lpfnMAPILogon = NULL;
    LPMAPILOGOFF lpfnMAPILogoff = NULL;

    LPBYTE      lpbName, lpbAddrType, lpbEmail;
    ULONG       ulMapiDataType;
    ULONG       cbEntryID = 0;
    LPENTRYID   lpEntryID = NULL;

    MapiMessage Msg = {0};
    MapiRecipDesc * lprecips = NULL;

    if(!nRecipCount)
    {
        hr = MAPI_W_ERRORS_RETURNED;
        goto out;
    }

    // Check if OutlookExpress is the default current client ..
    bIsOE = CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf));

    // Turn off all notifications for simple MAPI send mail, if the default
    // email client is Outlook.  This is necessary because Outlook changes the 
    // WAB MAPI allocation functions during simple MAPI and we don't want any
    // internal WAB functions using these allocators.
    if (!bIsOE && !bUseOEForSendMail)
        vTurnOffAllNotifications();

    // if OE is the default client or OE launched this WAB, use OE for SendMail
    if(lstrlen(szBuf) && (bIsOE||bUseOEForSendMail))
    {
        hLibMapi = LoadLibrary(szBuf);
    }
    else
    {
        // Check if simple mapi is installed
        if(GetProfileInt( TEXT("mail"), TEXT("mapi"), 0) == 1)
            hLibMapi = LoadLibrary( TEXT("mapi32.dll"));
        
        if(!hLibMapi) // try loading the OE MAPI dll directly
        {
            // Load the path to the msimnui.dll
            CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf));
            if(lstrlen(szBuf))  // Load the dll directly - dont bother going through msoemapi.dll
                hLibMapi = LoadLibrary(szBuf);
        }
    }

    if(!hLibMapi)
    {
        DebugPrintError(( TEXT("Could not load/find simple mapi\n")));
        hr = MAPI_E_NOT_FOUND;
        goto out;
    }
    else if(hLibMapi)
    {
        lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hLibMapi, "MAPILogon");
        lpfnMAPILogoff= (LPMAPILOGOFF)GetProcAddress (hLibMapi, "MAPILogoff");
        lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hLibMapi, "MAPISendMail");

        if(!lpfnMAPISendMail || !lpfnMAPILogon || !lpfnMAPILogoff)
        {
            DebugPrintError(( TEXT("MAPI proc not found\n")));
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }
        hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                            NULL,              // No password needed.
                            0L,                // Use shared session.
                            0L,                // Reserved; must be 0.
                            &hMapiSession);       // Session handle.

        if(hr != SUCCESS_SUCCESS)
        {
            DebugTrace( TEXT("MAPILogon failed\n"));
            // its possible the logon failed since there was no shared logon session
            // Try again to create a new session with UI
            hr = lpfnMAPILogon( (ULONG_PTR)hWndParent, NULL,
                                NULL,                               // No password needed.
                                MAPI_LOGON_UI | MAPI_NEW_SESSION,   // Use shared session.
                                0L,                // Reserved; must be 0.
                                &hMapiSession);    // Session handle.

            if(hr != SUCCESS_SUCCESS)
            {
                DebugTrace( TEXT("MAPILogon failed\n"));
                goto out;
            }
        }
    }

    // Load the MAPI functions here ...
    //

    lprecips = LocalAlloc(LMEM_ZEROINIT, sizeof(MapiRecipDesc) * nRecipCount);
    {
        LPRECIPLIST lpTemp = lpList;
        ULONG count = 0;

        while(lpTemp)
        {
            lprecips[count].ulRecipClass = MAPI_TO;
            lprecips[count].lpszName = ConvertWtoA(lpTemp->lpszName);
            lprecips[count].lpszAddress = ConvertWtoA(lpTemp->lpszEmail);

            // [PaulHi] 4/20/99  Raid 73455
            // Convert Unicode EID OneOff strings to ANSI
            if ( IsWABEntryID(lpTemp->lpSB->cb, (LPVOID)lpTemp->lpSB->lpb, 
                              &lpbName, &lpbAddrType, &lpbEmail, (LPVOID *)&ulMapiDataType, NULL) == WAB_ONEOFF )
            {
#ifndef _WIN64 // As I founf from RAID this part only for Outlook
                if (ulMapiDataType & MAPI_UNICODE)
                {
                    hr = CreateWABEntryIDEx(
                        FALSE,              // Don't want Unicode EID strings
                        WAB_ONEOFF,         // EID type
                        (LPWSTR)lpbName,
                        (LPWSTR)lpbAddrType,
                        (LPWSTR)lpbEmail,
                        0,
                        0,
                        NULL,
                        &cbEntryID,
                        &lpEntryID);

                    if (FAILED(hr))
                        goto out;

                    lprecips[count].ulEIDSize = cbEntryID;
                    lprecips[count].lpEntryID = lpEntryID;
                }
                else
#endif // _WIN64
                {
                    lprecips[count].ulEIDSize = lpTemp->lpSB->cb;
                    lprecips[count].lpEntryID = (LPVOID)lpTemp->lpSB->lpb;
                }
            }
            lpTemp = lpTemp->lpNext;
            count++;
        }
    }

    Msg.nRecipCount = nRecipCount;
    Msg.lpRecips = lprecips;

    hr = lpfnMAPISendMail (hMapiSession, (ULONG_PTR)hWndParent,
                            &Msg,       // the message being sent
                            MAPI_DIALOG, // allow the user to edit the message
                            0L);         // reserved; must be 0
    if(hr != SUCCESS_SUCCESS)
        goto out;

    hr = S_OK;

out:

    // This must be freed within the Outlook simple MAPI session, since it was
    // allocated within this session (i.e., with Outlook allocators).
    if (lpEntryID)
        MAPIFreeBuffer(lpEntryID);

    // The simple MAPI session should end after this
    if(hMapiSession && lpfnMAPILogoff)
        lpfnMAPILogoff(hMapiSession,0L,0L,0L);

    if(hLibMapi)
        FreeLibrary(hLibMapi);

    // Turn all notifications back on and refresh the WAB UI (just in case)
    if (!bIsOE && !bUseOEForSendMail)
    {
        vTurnOnAllNotifications();
        if (lpIAB->hWndBrowse)
         PostMessage(lpIAB->hWndBrowse, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);
    }

    if(lprecips)
    {
        ULONG i = 0;
        for(i=0;i<nRecipCount;i++)
        {
            LocalFreeAndNull(&lprecips[i].lpszName);
            LocalFreeAndNull(&lprecips[i].lpszAddress);
        }

        LocalFree(lprecips);
    }
    
    // The one-off here was allocated before the simple MAPI session and so used
    // the default WAB allocators.
    if(lpList)
        FreeLPRecipList(lpList);

    switch(hr)
    {
    case S_OK:
    case MAPI_E_USER_CANCEL:
    case MAPI_E_USER_ABORT:
        break;
    case MAPI_W_ERRORS_RETURNED:
        ShowMessageBox(hWndParent, idsSendMailToNoEmail, MB_ICONEXCLAMATION | MB_OK);
        break;
    case MAPI_E_NOT_FOUND:
        ShowMessageBox(hWndParent, idsSendMailNoMapi, MB_ICONEXCLAMATION | MB_OK); 
        break;
    default:
        ShowMessageBox(hWndParent, idsSendMailError, MB_ICONEXCLAMATION | MB_OK);
        break;
    }

    return hr;
}

typedef struct _MailParams
{
    HWND hWnd;
    ULONG nRecipCount;
    LPRECIPLIST lpList;
    LPIAB lpIAB;
    BOOL bUseOEForSendMail;   // True means check and use OE before checking for Simple MAPI client
} MAIL_PARAMS, * LPMAIL_PARAMS;

//$$//////////////////////////////////////////////////////////////////////
//
// MailThreadProc - does the actual sendmail and cleans up
//
//////////////////////////////////////////////////////////////////////////
DWORD WINAPI MailThreadProc( LPVOID lpParam )
{
    LPMAIL_PARAMS lpMP = (LPMAIL_PARAMS) lpParam;
    LPPTGDATA lpPTGData = GetThreadStoragePointer(); // Bug - if this new thread accesses the WAB we lose a hunka memory
                                                // So add this thing here ourselves and free it when this thread's work is done

    if(!lpMP)
        return 0;

    DebugTrace( TEXT("Mail Thread ID = 0x%.8x\n"),GetCurrentThreadId());

    HrSendMail(lpMP->hWnd, lpMP->nRecipCount, lpMP->lpList, lpMP->lpIAB, lpMP->bUseOEForSendMail);

    LocalFree(lpMP);

    return 0;
}

//$$//////////////////////////////////////////////////////////////////////
//
// HrStartMailThread
//
//  Starts a seperate thread to send mapi based mail from
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrStartMailThread(HWND hWndParent, ULONG nRecipCount, LPRECIPLIST lpList, LPIAB lpIAB, BOOL bUseOEForSendMail)
{
    LPMAIL_PARAMS lpMP = NULL;
    HRESULT hr = E_FAIL;

    lpMP = LocalAlloc(LMEM_ZEROINIT, sizeof(MAIL_PARAMS));

    if(!lpMP)
        goto out;

    {
        HANDLE hThread = NULL;
        DWORD dwThreadID = 0;

        lpMP->hWnd = hWndParent;
        lpMP->nRecipCount = nRecipCount;
        lpMP->lpList = lpList;
        lpMP->bUseOEForSendMail = bUseOEForSendMail;
        lpMP->lpIAB = lpIAB;

        hThread = CreateThread(
                                NULL,           // no security attributes
                                0,              // use default stack size
                                MailThreadProc,     // thread function
                                (LPVOID) lpMP,  // argument to thread function
                                0,              // use default creation flags
                                &dwThreadID);   // returns the thread identifier

        if(hThread == NULL)
            goto out;

        hr = S_OK;

        CloseHandle(hThread);
    }

out:
    if(HR_FAILED(hr))
    {
        ShowMessageBox(hWndParent, idsSendMailError, MB_OK | MB_ICONEXCLAMATION);

        // we can assume that HrSendMail never got called so we should free lpList & lpMP
        if(lpMP)
            LocalFree(lpMP);

        if(lpList)
            FreeLPRecipList(lpList);

    }

    return hr;
}

//$$//////////////////////////////////////////////////////////////////////
//
//	HrSendMailToSelectedContacts
//
//	Uses simple MAPI to send mail to the selected contacts
//
//  hWndLV - handle of List view. We look up the all the selected items in
//              this list view, get their lParam structure, then get its
//              EntryID and get the email address .. in the case of a group
//              we get all the email addresses of all the members
//              All these are put into a recip list and given to
//              MAPISendMail ...
//
//  lpIAB - handle to current AdrBook object - used for calling details
//  nExtEmail - if this is a non-zero positive number, then it is the index of an
//      e-mail address in the PR_CONTACT_EMAIL_ADDRESSES property and means that
//      the user specified a non-default e-mail address to send mail to in which case
//      that particular email address should be used for sending mail. nExtEmail will be
//      non-zero only if one item is selected and a specific email is chosen for that item.
//
//  Returns:S_OK
//          E_FAIL
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMailToSelectedContacts(HWND hWndLV, LPADRBOOK lpAdrBook, int nExtEmail)
{
	HRESULT hr = E_FAIL;
	int nSelected = ListView_GetSelectedCount(hWndLV);
	int iItemIndex = 0;
	HWND hWndParent = GetParent(hWndLV);
    TCHAR szBuf[MAX_PATH];
    LPIAB lpIAB = (LPIAB) lpAdrBook;
    LPRECIPLIST lpList = NULL;
    ULONG nRecipCount = 0, nNoEmailCount = 0;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Check if OutlookExpress is the current client ..need to know this to workaround a bug
    // in what they expect right now as recipients
    BOOL bIsOE = CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf));

    // Create a recipients list to put in the new message ...
    if(nSelected > 0)
	{
		// Get index of selected item
        iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
		
		while (iItemIndex != -1)
		{
			LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;
			// Get item lParam LPRECIPIENT_INFO structure
            if (lpItem)
			{
                GetRecipListFromSelection(lpAdrBook, bIsOE,
                                          lpItem->cbEntryID,
                                          lpItem->lpEntryID,
                                          nExtEmail,
                                          &nRecipCount, &nNoEmailCount,
                                          &lpList);
			}
            iItemIndex = ListView_GetNextItem(hWndLV,iItemIndex,LVNI_SELECTED);
		}
        if(nRecipCount > 0 && nNoEmailCount > 0)
        {
            if(IDNO == ShowMessageBox(hWndParent, idsSomeHaveNoEmail, MB_ICONEXCLAMATION | MB_YESNO))
            {
                hr = MAPI_E_USER_CANCEL;
                goto out;
            }
        }
	}
	else
    {
		// nothing selected
        ShowMessageBox(hWndParent, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION);
        goto out;
    }

    hr = HrStartMailThread( hWndParent, nRecipCount, 
                            lpList,                     // HrSendMail frees lpList so dont reuse
                            lpIAB,
                            lpIAB->bUseOEForSendMail);

out:

    SetCursor(hOldCur);

	return hr;
}
/*
const LPTSTR szClients = TEXT( TEXT("Software\\Clients\\%s"));

//
//  FUNCTION:   ShellUtil_RunIndirectRegCommand()
//
//  PURPOSE:    find the default value under HKLM\Software\Clients\pszClient
//              tack on shell\open\command
//              then runreg that
//
void ShellUtil_RunClientRegCommand(HWND hwnd, LPCTSTR pszClient)
{
    TCHAR szDefApp[MAX_PATH];
    TCHAR szKey[MAX_PATH];
    LONG  cbSize = ARRAYSIZE(szDefApp);

    wnsprintf(szKey, ARRAYSIZE(szKey), szClients, pszClient);
    if (RegQueryValue(HKEY_LOCAL_MACHINE, szKey, szDefApp, &cbSize) == ERROR_SUCCESS)
        {
        TCHAR szFullKey[MAX_PATH];

        // tack on shell\open\command
        wnsprintf(szFullKey, ARRAYSIZE(szFullKey), TEXT("%s\\%s\\shell\\open\\command"), szKey, szDefApp);
        cbSize = ARRAYSIZE(szDefApp);
        if (RegQueryValue(HKEY_LOCAL_MACHINE, szFullKey, szDefApp, &cbSize) == ERROR_SUCCESS)
            {
            LPSTR pszArgs = NULL;
            SHELLEXECUTEINFO ExecInfo;
            LPTSTR lp = szDefApp;

            // if we have long file names in this string, we need to skip past the qoutes

            if(lp)
            {
                if(*lp == '"')
                {
                    lp = CharNext(lp);
                    while(lp && *lp && *lp!='"')
                        lp = CharNext(lp);
                }

                // Now find the next blank space because this is where the parameters start ..
                while(lp && *lp && *lp!=' ')    // No DBCS spaces here
                    lp = CharNext(lp);

                if(*lp == ' ')
                {
                    pszArgs = CharNext(lp);
                    *lp = '\0';
                    TrimSpaces(pszArgs);
                }

                //Now remove the quotes from lp
                lp = szDefApp;
                while(lp && *lp)
                {
                    if(*lp == '"')
                        *lp = ' ';
                    lp = CharNext(lp);
                }

                TrimSpaces(szDefApp);

            }

            ExecInfo.hwnd = hwnd;
            ExecInfo.lpVerb = NULL;
            ExecInfo.lpFile = szDefApp;
            ExecInfo.lpParameters = pszArgs;
            ExecInfo.lpDirectory = NULL;
            ExecInfo.nShow = SW_SHOWNORMAL;
            ExecInfo.fMask = 0;
            ExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);

            ShellExecuteEx(&ExecInfo);
            }
        }
}
*/
/*
//$$//////////////////////////////////////////////////////////////////////
//
//	HrSendMailToSingleContact
//
//	Uses simple MAPI to send mail to the specified contact
//
//  Returns:S_OK
//          E_FAIL
//
//////////////////////////////////////////////////////////////////////////
HRESULT HrSendMailToSingleContact(HWND hWnd, LPIAB lpIAB, ULONG cbEntryID, LPENTRYID lpEntryID)
{
	HRESULT hr = E_FAIL;
    TCHAR szBuf[MAX_PATH];

    LPRECIPLIST lpList = NULL;
    ULONG nRecipCount = 0;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Check if OutlookExpress is the current client ..need to know this to workaround a bug
    // in what they expect right now as recipients
    BOOL bIsOE = CheckForOutlookExpress(szBuf, ARRAYSIZE(szBuf));

    // Create a recipients list to put in the new message ...
    GetRecipListFromSelection((LPADRBOOK) lpIAB,
                              bIsOE,
                              cbEntryID,
                              lpEntryID,
                              0,
                              &nRecipCount,
                              &lpList);

    //hr = HrSendMail(hWnd, nRecipCount, lpList); // HrSendMail frees the lpList so dont reuse ..
    hr = HrStartMailThread(hWnd, nRecipCount, lpList); // HrSendMail frees lpList so dont reuse

    SetCursor(hOldCur);

	return hr;
}
*/

//$$///////////////////////////////////////////////////////////////////
//
// Removes all characters from input string that are not allowed by the
//  file system
//
///////////////////////////////////////////////////////////////////////
void TrimIllegalFileChars(LPTSTR sz)
{
    LPTSTR lpCurrent = sz;

    if(!lpCurrent)
        return;

    // Escape illegal chars in the file name
    while (*lpCurrent)
    {
        switch (*lpCurrent)
        {
            case '\\':
            case '/':
            case '<':
            case '>':
            case ':':
            case '"':
            case '|':
            case '?':
            case '*':
            //case '.':
                *lpCurrent = '_';   // replace with underscore
                break;

            default:
                break;
        }
        lpCurrent = CharNext(lpCurrent);
    }

    return;
}


/***************************************************************************

    Name      : IsSpace

    Purpose   : Does the single or DBCS character represent a space?

    Parameters: lpChar -> SBCS or DBCS character

    Returns   : TRUE if this character is a space

    Comment   :

***************************************************************************/
BOOL __fastcall IsSpace(LPTSTR lpChar) {
    Assert(lpChar);
    if (*lpChar) 
    {
/*
 *      [PaulHi] 3/31/99  Raid 73845.  DBCS is not valid for UNICODE app.
        if (IsDBCSLeadByte((BYTE)*lpChar)) 
        {
            WORD CharType[2] = {0};
            GetStringTypeW(CT_CTYPE1,lpChar,2,// Double-Byte
                            CharType);
            return(CharType[0] & C1_SPACE);
        }
*/
        return(*lpChar == ' ');
    } 
    return(FALSE);  // end of string
}

/***************************************************************************

    Name      : SetRegistryUseOutlook

    Purpose   : Sets the registry flag that makes us use Outlook

    Parameters: bUseOutlook or not

    Returns   : TRUE if it was correctly changed

    Comment   :

***************************************************************************/
BOOL SetRegistryUseOutlook(BOOL bUseOutlook)
{
    HKEY hKey = NULL;
    DWORD dwUseOutlook = (DWORD) bUseOutlook;
    BOOL bRet = FALSE;

    // We'll probably never have to create the key since Outlook will do that at setup
    //
    if(ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER,
                                        lpNewWABRegKey,
                                        0, NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL, &hKey, NULL))
    {
        if(ERROR_SUCCESS == RegSetValueEx( hKey,
                                            lpRegUseOutlookVal,
                                            0, REG_DWORD,
                                            (LPBYTE) &dwUseOutlook,
                                            sizeof(DWORD) ))
        {
            bRet = TRUE;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    return bRet;
}



const LPTSTR lpRegOffice = TEXT("Software\\Microsoft\\Office\\8.0");
const LPTSTR lpRegOffice9 = TEXT("Software\\Microsoft\\Office\\9.0");
const LPTSTR lpRegOutlWAB = TEXT("Software\\Microsoft\\WAB\\OutlWABDLLPath");
const LPTSTR lpRegOfficeBin = TEXT("BinDirPath");
const LPTSTR lpOUTLWAB_DLL_NAME = TEXT("Outlwab.dll");

BOOL bFindOutlWABDll(LPTSTR sz, DWORD cchSz, LPTSTR szDLLPath, DWORD cchDLLPath, BOOL bAppendName)
{
    BOOL bRet = FALSE;
    if(bAppendName)
    {
        if(*(sz+lstrlen(sz)-1) != '\\')
            StrCatBuff(sz, szBackSlash, cchSz);
        StrCatBuff(sz, lpOUTLWAB_DLL_NAME, cchSz);
    }
    if(GetFileAttributes(sz) != 0xFFFFFFFF)
    {
        if(szDLLPath)
            StrCpyN(szDLLPath, sz, cchDLLPath);
         bRet = TRUE;
    }
    return bRet;
}
//$$/////////////////////////////////////////////////////////////////////////////
//
// bCheckForOutlookWABDll
//
// Search for the Outlook WAB DLL .. if found, we
// can use that as na indicator that outlook is installed
//
// szDLLPath should be a big enough buffer
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bCheckForOutlookWABDll(LPTSTR szDLLPath, DWORD cchDLLPath)
{
    // Check in the Office Bin directory
    TCHAR sz[MAX_PATH];
    BOOL bRet = FALSE;
    DWORD dwType = REG_SZ;
    DWORD dwSize = ARRAYSIZE(sz);
    HKEY hKey = NULL;

    *sz = '\0';

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegOutlWAB, 0, KEY_READ, &hKey))
    {
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, szEmpty, NULL, &dwType, (LPBYTE) sz, &dwSize))
        {
            if(lstrlen(sz))
                bRet = bFindOutlWABDll(sz, ARRAYSIZE(sz), szDLLPath, cchDLLPath, FALSE);
        }
        RegCloseKey(hKey);
    }

    if (!bRet)
    {
        *sz = '\0';
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegOffice9, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpRegOfficeBin, NULL, &dwType, (LPBYTE) sz, &dwSize))
            {
                if(lstrlen(sz))
                    bRet = bFindOutlWABDll(sz, ARRAYSIZE(sz), szDLLPath, cchDLLPath, TRUE);
            }
        }
        RegCloseKey(hKey);
    }

    if(!bRet)
    {
        *sz = '\0';
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegOffice, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpRegOfficeBin, NULL, &dwType, (LPBYTE) sz, &dwSize))
            {
                if(lstrlen(sz))
                    bRet = bFindOutlWABDll(sz, ARRAYSIZE(sz), szDLLPath, cchDLLPath, TRUE);
            }
        }
        RegCloseKey(hKey);
    }
    // Check in the Windows System Directory
    if(!bRet)
    {
         *sz = '\0';
        GetSystemDirectory(sz, ARRAYSIZE(sz));
        if(lstrlen(sz))
            bRet = bFindOutlWABDll(sz, ARRAYSIZE(sz), szDLLPath, cchDLLPath, TRUE);
    }

    return bRet;
}

/***************************************************************************

    Name      : bUseOutlookStore

    Purpose   : Determines if we are supposed to be using Outlook

    Parameters: none

    Returns   : TRUE if we are supposed to use outlook AND we can find the
                outlook installation

    Comment   :

***************************************************************************/
BOOL bUseOutlookStore()
{
    HKEY hKey = NULL;
    DWORD dwUseOutlook = 0;
    BOOL bRet = FALSE;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    if(ERROR_SUCCESS == RegOpenKeyEx(   HKEY_CURRENT_USER,
                                        lpNewWABRegKey,
                                        0, KEY_READ,
                                        &hKey))
    {
        if(ERROR_SUCCESS == RegQueryValueEx(hKey,
                                            lpRegUseOutlookVal,
                                            NULL,
                                            &dwType,
                                            (LPBYTE) &dwUseOutlook,
                                            &dwSize))
        {
            bRet = (BOOL) dwUseOutlook;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    if(bRet)
    {
        // just double check that we can actually find the OutlookWABSPI dll
        bRet = bCheckForOutlookWABDll(NULL, 0);
    }

    return bRet;
}


//$$//////////////////////////////////////////////////////////
//
// Copies Src to Dest. If Src is longer than Dest, 
// truncates the src and trails it with 3 dots
//
//////////////////////////////////////////////////////////////
int CopyTruncate(LPTSTR szDest, LPTSTR szSrc, int nMaxLen)
{
    int nLen = lstrlen(szSrc)+1;
    if (nLen >= nMaxLen)
    {
        ULONG iLenDots = lstrlen(szTrailingDots) + 1;
        ULONG iLen = TruncatePos(szSrc, nMaxLen - iLenDots);
        CopyMemory(szDest,szSrc, sizeof(TCHAR)*(nMaxLen - iLenDots));
        szDest[iLen]='\0';
        StrCatBuff(szDest,szTrailingDots, nMaxLen);
        //DebugTrace("%s = %s\n", szDest, szSrc);
    }
    else
    {
        StrCpyN(szDest,szSrc,nMaxLen);
    }
    return nLen;
}


///////////////////////////////////////////////////////////////////
//
//  HrShowDSProps - shows Directory Service properties UI
//
//  hWndParent - hWnd of Parent
//  lpszName - pointer to a buffer ... also contains name of LDAP
//      server to view prperties on - this name can be modified so
//      lpszName should point to a big enough buffer
//  bAddNew - TRUE if this is a new entry, false if this is props
///////////////////////////////////////////////////////////////////
HRESULT HrShowDSProps(HWND      hWndParent,
                      LPTSTR    ptszAcct,
                      LPTSTR   *pptszName,
                      BOOL      bAddNew)
{
    HRESULT hr = hrSuccess;
    IImnAccountManager2 * lpAccountManager = NULL;
    IImnAccount * lpAccount = NULL;
    LPSTR lpAcct = ConvertWtoA(ptszAcct);

    // init account manager
    // Make sure there is an account manager
    if (hr = InitAccountManager(NULL, &lpAccountManager, NULL)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    // find this account
    if (hr = lpAccountManager->lpVtbl->FindAccount(lpAccountManager,
      AP_ACCOUNT_NAME,
      lpAcct,
      &lpAccount)) {
        DebugTrace( TEXT("FindAccount(%s) -> %x\n"), lpAcct, GetScode(hr));
        goto out;
    }

    // show properties
    if (hr = lpAccount->lpVtbl->ShowProperties(lpAccount,
      hWndParent,
      0)) {
        DebugTrace( TEXT("ShowProperties(%s) -> %x\n"), lpAcct, GetScode(hr));
        goto out;
    }

    {
        char szBuf[MAX_UI_STR];
        // Get the friendly name (== account name if this changed)
        if (! (HR_FAILED(hr = lpAccount->lpVtbl->GetPropSz(lpAccount, AP_ACCOUNT_NAME, szBuf, ARRAYSIZE(szBuf))))) 
        {
            LPTSTR lp = ConvertAtoW(szBuf);
            if(lp)
            {
                *pptszName = lp;
            }
        }
    }


out:

    if (lpAccount) {
        lpAccount->lpVtbl->Release(lpAccount);
    }

    LocalFreeAndNull(&lpAcct);
//  Don't release the account manager.  It will be done when the IAdrBook is released.
//    if (lpAccountManager) {
//        lpAccountManager->lpVtbl->Release(lpAccountManager);
//    }

    return hr;
}


//$$///////////////////////////////////////////////////////////////////////////////
//
// HrShowDirectoryServiceModificationDlg - Shows the main dialog with the list
// of directory services and with a prop sheet for changing check order
//
//  hWndParent - Parent for this dialog
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent, LPIAB lpIAB)
{
    ACCTLISTINFO ali;
    HRESULT hr = hrSuccess;
    IImnAccountManager2 * lpAccountManager;

    // Make sure there is an account manager
    if (hr = InitAccountManager(lpIAB, &lpAccountManager, NULL)) {
        ShowMessageBox(hWndParent, idsLDAPUnconfigured, MB_ICONEXCLAMATION | MB_OK);
        goto out;
    }

    ali.cbSize = sizeof(ACCTLISTINFO);
    ali.AcctTypeInit = (ACCTTYPE)-1;
    ali.dwAcctFlags = ACCT_FLAG_DIR_SERV;
    ali.dwFlags = 0;
    hr = lpAccountManager->lpVtbl->AccountListDialog(lpAccountManager,
      hWndParent,
      &ali);

out:
    return hr;
}

/*
-   HrShellExecInternetCall
-
*
*   Checks if the selected, single item has PR_SERVERS set on it and has a default
*   callto item - if yes, shell-exects this item ..
*/
HRESULT HrShellExecInternetCall(LPADRBOOK lpAdrBook, HWND hWndLV)
{
    HRESULT hr = E_FAIL;
    LPRECIPIENT_INFO lpItem = NULL;
    LPSPropValue lpPropArray  = NULL;
    ULONG ulcProps = 0;
    int nCount = ListView_GetSelectedCount(hWndLV);

    if(nCount != 1)
    {
        ShowMessageBox(GetParent(hWndLV), 
                                (nCount > 1) ? IDS_ADDRBK_MESSAGE_ACTION : IDS_ADDRBK_MESSAGE_NO_ITEM,
                                MB_ICONEXCLAMATION);
         goto out;
    }

    lpItem = GetItemFromLV(hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
    if(lpItem)
    {
        if(!HR_FAILED(hr = HrGetPropArray(  lpAdrBook, NULL, 
                                            lpItem->cbEntryID, lpItem->lpEntryID,
                                            MAPI_UNICODE,
                                            &ulcProps, &lpPropArray)))
        {
            ULONG i = 0, nConf = 0xffffffff, nDef = 0xffffffff;
            LPTSTR lpsz = NULL;
            for(i=0;i<ulcProps;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_WAB_CONF_SERVERS)
                    nConf = i;
                else if(lpPropArray[i].ulPropTag == PR_WAB_CONF_DEFAULT_INDEX)
                    nDef = i;
            }
            if(nConf != 0xffffffff)
            {
                TCHAR sz[MAX_PATH];
                if(nDef != 0xffffffff)
                {
                    ULONG iDef = lpPropArray[nDef].Value.l;
                    lpsz = lpPropArray[nConf].Value.MVSZ.LPPSZ[iDef];
                }
                else
                {
                    // no default .. find the first call to and use that
                    for(i=0;i<lpPropArray[nConf].Value.MVSZ.cValues;i++)
                    {
                        if(lstrlen(lpPropArray[nConf].Value.MVSZ.LPPSZ[i]) >= lstrlen(szCallto))
                        {
                            int nLen = lstrlen(szCallto);
                            CopyMemory(sz, lpPropArray[nConf].Value.MVSZ.LPPSZ[i], sizeof(TCHAR)*nLen);
                            sz[nLen] = '\0';
                            if(!lstrcmpi(sz, szCallto))
                            {
                                lpsz = lpPropArray[nConf].Value.MVSZ.LPPSZ[i];
                                break;
                            }
                        }
                    }
                }
                if(lpsz)
                    if(!ShellExecute(GetParent(hWndLV),  TEXT("open"), lpsz, NULL, NULL, SW_SHOWNORMAL))
                        ShowMessageBox(GetParent(hWndLV), idsCouldNotSelectUser, MB_ICONEXCLAMATION);
            }
            if(nConf == 0xffffffff || !lpsz)
                ShowMessageBox(GetParent(hWndLV), idsInternetCallNoCallTo, MB_ICONEXCLAMATION);
        }
    }

out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return hr;
}


/*
-   GetItemFromLV
-
*   utility function for returning the recipient item from the LV
*/
LPRECIPIENT_INFO GetItemFromLV(HWND hWndLV, int iItem)
{
    LPRECIPIENT_INFO lpItem = NULL;

    LV_ITEM LVItem;

    LVItem.mask = LVIF_PARAM;
    LVItem.iItem = iItem;
    LVItem.iSubItem = 0;
    LVItem.lParam = 0;

    // Get item lParam LPRECIPIENT_INFO structure
    if (ListView_GetItem(hWndLV,&LVItem))
        lpItem = ((LPRECIPIENT_INFO) LVItem.lParam);

    return lpItem;
}

/*
-   Helper function
-
*/
void SetSBinary(LPSBinary lpsb, ULONG cb, LPBYTE lpb)
{
    if(!lpsb || !cb || !lpb)
        return;
    if(lpsb->lpb = LocalAlloc(LMEM_ZEROINIT, cb))
    {
        lpsb->cb = cb;
        CopyMemory(lpsb->lpb, lpb, cb);
    }
}


/*
-   GetWABIconImage
-
*
*/
int GetWABIconImage(LPRECIPIENT_INFO lpItem)
{
    if(lpItem->cbEntryID == 0)
        return imageUnknown;

    if(lpItem->ulObjectType == MAPI_DISTLIST)
    {
        return imageDistList;
    }
    else
    {
        BYTE bType;

        if(lpItem->bIsMe)
            return imageMailUserMe;
        else if(lpItem->bHasCert)
            return imageMailUserWithCert;
        
        bType = IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID, NULL,NULL,NULL, NULL, NULL);
        if(bType == WAB_LDAP_MAILUSER)
            return imageMailUserLDAP;
        else if(bType == WAB_ONEOFF)
            return imageMailUserOneOff;

    }
    return imageMailUser;
}

enum
{
    IE401_DONTKNOW=0,
    IE401_TRUE,
    IE401_FALSE
};
static int g_nIE401 = IE401_DONTKNOW;
/*
-   bIsIE401
-
*   Checks if this installation has IE4.01 or greater so we can decide what flags to pass to the prop sheets
*
*/
BOOL bIsIE401OrGreater()
{
    BOOL bRet = FALSE;

    if(g_nIE401 == IE401_TRUE)
        return TRUE;
    if(g_nIE401 == IE401_FALSE)
        return FALSE;
    
    g_nIE401 = IE401_FALSE;

    // else we need to check
    InitCommonControlLib();

    //load the DLL
    if(ghCommCtrlDLLInst)   
    {
        LPDLLGETVERSIONPROCOE lpfnDllGetVersionProc = NULL;
        lpfnDllGetVersionProc = (LPDLLGETVERSIONPROCOE) GetProcAddress(ghCommCtrlDLLInst, "DllGetVersion");
        if(lpfnDllGetVersionProc)
        {
            // Check the version number
            DLLVERSIONINFO dvi = {0};
            dvi.cbSize = sizeof(dvi);
            lpfnDllGetVersionProc(&dvi);
            // we are looking for IE4 version 4.72 or more
            if( (dvi.dwMajorVersion > 4) ||
                (dvi.dwMajorVersion == 4 && dvi.dwMinorVersion >= 72) )
            {
                g_nIE401 = IE401_TRUE;
                bRet = TRUE;
            }
        }
    }

    DeinitCommCtrlClientLib();

    return bRet;
}

#ifdef COLSEL_MENU
/**
    ColSel_PropTagToString: This function will convert a propertytag to a string
*/
BOOL ColSel_PropTagToString( ULONG ulPropTag, LPTSTR lpszString, ULONG cchString)
{
    UINT i, j;
    UINT iIndex;
    HMENU hMainMenu;
    HMENU hMenu;
    MENUITEMINFO mii;
    BOOL fRet = FALSE;

    hMainMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_LVCONTEXTMENU_COLSEL));
    if( !hMainMenu )
    {    
        DebugTrace( TEXT("unable to load main colsel menu\n"));
        goto exit;
    }
    hMenu = GetSubMenu( hMainMenu, 0);
    if( !hMenu )
    {
        DebugTrace( TEXT("unable to load submenu from colsel main menu\n"));
        goto exit;
    }        
    if( !lpszString )
    {
        DebugTrace( TEXT("illegal argument -- lpszString must be valid mem\n"));
        goto exit;
    }
    mii.fMask = MIIM_TYPE;
    mii.cbSize = sizeof( MENUITEMINFO );
    mii.dwTypeData = lpszString;
    mii.cch = cchString;

    for( i = 0; i < MAXNUM_MENUPROPS; i++)
    {
        if( MenuToPropTagMap[i] == ulPropTag )
        {
            if( !GetMenuItemInfo( hMenu, i, TRUE, &mii) )
            {
                DebugTrace( TEXT("unable to get menu item info: %x\n"), GetLastError() );
                goto exit;
            }
            fRet = TRUE;
        }
    }
    
exit:
    if ( hMainMenu != NULL )
        DestroyMenu( hMainMenu );
    if( !fRet )
        DebugTrace( TEXT("unable to find property tag\n"));
    return fRet;
}
#endif // COLSEL_MENU

/*
-   IsWindowOnScreen
-   
*   Checks if a window is onscreen so that if it is not entirely onscreen we can push it back
*   into a viewable area .. this way if the user changes screen resolution or switches multi-monitors
*   around, we don't lose the app
*/
BOOL IsWindowOnScreen(LPRECT lprc)
{
    HDC hDC = GetDC(NULL);
    BOOL fRet = RectVisible(hDC, lprc);
    ReleaseDC(NULL, hDC);
    return fRet;
}

/*
-   IsHTTPMailEnabled
-   
*   Checks if HTTP is enabled so that we can hide UI if its not.
*/
static TCHAR c_szRegRootAthenaV2[] = TEXT("Software\\Microsoft\\Outlook Express");
static TCHAR c_szEnableHTTPMail[] = TEXT("HTTP Mail Enabled");

BOOL IsHTTPMailEnabled(LPIAB lpIAB)
{
#ifdef NOHTTPMAIL
    return FALSE;
#else
    DWORD   cb, bEnabled = FALSE;
    HKEY    hkey = NULL;

    // [PaulHi] 1/5/98  Raid #64160
    // Hotmail synchronization is disabled if the WAB is not in "identity aware"
    // mode.  So, we need to check for this too.
    bEnabled = lpIAB->bProfilesIdent;
    
    // @todo [PaulHi] 12/1/98
    // We really shouldn't be doing a registry query every time the user
    // opens up the Tools menu, i.e., in update menu.
    // Check this registry sometime during start up and save per instance.
    // open the OE5.0 key
    if ( bEnabled &&
         (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegRootAthenaV2, 0, KEY_QUERY_VALUE, &hkey)) )
    {
        cb = sizeof(bEnabled);
        RegQueryValueEx(hkey, c_szEnableHTTPMail, 0, NULL, (LPBYTE)&bEnabled, &cb);

        RegCloseKey(hkey);
    }

    //
    // [PaulHi] 12/1/98  Raid #57739
    // HACK WARNING
    // Since the Hotmail server is currently hard coded to the U.S. 1252
    // codepage, any other system codepage will result in corrupted data
    // after a round sync trip to the Hotmail server and back, for any fields
    // with DB characters (i.e., international).  The temporary solution is 
    // to simply disable Hotmail synchronization if a codepage other than 
    // 1252 is detected on the client machine.
    //
    #define USLatin1CodePage    1252
    if (bEnabled)
    {
        DWORD dwCodepage = GetACP();
        if (dwCodepage != USLatin1CodePage)
            bEnabled = FALSE;
    }

    return bEnabled;
#endif
}

/*
-
-   WriteRegistryDeletedHotsyncItem
*
*   Writes the Hotmail Contact/ID/Modtime info to the registry so we can track deletions for
*   Hotmail syncing
*
*/
extern LPTSTR g_lpszSyncKey;
void WriteRegistryDeletedHotsyncItem(LPTSTR lpServerID, LPTSTR lpContactID, LPTSTR lpModTime)
{
    HKEY hKey = NULL,hSubKey = NULL;

    DWORD dwDisposition = 0;

    if( !lpServerID || !lstrlen(lpServerID) ||
        !lpContactID || !lstrlen(lpContactID) ||
        !lpModTime || !lstrlen(lpModTime) )
        return;

    // Open key
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, g_lpszSyncKey, 0,      //reserved
                                        NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                        &hKey, &dwDisposition))
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(hKey,lpContactID, 0,
                                            NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                                            &hSubKey, &dwDisposition))
        {
            // Create a value here .. the value name is the Contact ID and the Value Data is the ModTime
            // Now Write this key
            RegSetValueEx( hSubKey, lpServerID, 0, REG_SZ, (LPBYTE) lpModTime, (lstrlen(lpModTime)+1) * sizeof(TCHAR) );
        }
    }

    if(hSubKey)
        RegCloseKey(hSubKey);
    if(hKey)
        RegCloseKey(hKey);
}

/*
-   HrSaveHotmailSyncInfoOnDeletion
-
*   If the user has ever done any hotmail syncing, we need to track deletions in the WAB
*   so that after you delete an entry in the WAB, the corresponding hotmail entry will
*   be deleted on Sync.
*
*   We store the hotmail sync info in the registry, hopefully there won't be too much of it
*   Whenever the hotmail sync happens, the info gets cleaned out.
*/
HRESULT HrSaveHotmailSyncInfoOnDeletion(LPADRBOOK lpAdrBook, LPSBinary lpEID)
{
    // Basically we will open the object being deleted, look for it's Hotmail
    // properties and if these properties exist, we will put them into the registry
    //
    HRESULT hr = S_OK;
    ULONG ulcValues = 0,i=0;
    LPSPropValue lpProps = NULL;
    SizedSPropTagArray(3, ptaHotProps) =
    {   
        3, 
        {
            PR_WAB_HOTMAIL_CONTACTIDS,
            PR_WAB_HOTMAIL_MODTIMES,
            PR_WAB_HOTMAIL_SERVERIDS,
        }
    };

    hr = HrGetPropArray(lpAdrBook,
                        (LPSPropTagArray) &ptaHotProps,
                        lpEID->cb,(LPENTRYID) lpEID->lpb,
                        MAPI_UNICODE,
                        &ulcValues,&lpProps);
    if(HR_FAILED(hr) || !ulcValues || !lpProps)
        goto out;

    // The three props are supposed to be in sync, so if one exists, the other 2 will also exist
    // and if this is not true, then don't write the data to the registry
    if( lpProps[0].ulPropTag != PR_WAB_HOTMAIL_CONTACTIDS ||
        !lpProps[0].Value.MVSZ.cValues ||
        lpProps[1].ulPropTag != PR_WAB_HOTMAIL_MODTIMES ||
        !lpProps[1].Value.MVSZ.cValues ||
        lpProps[2].ulPropTag != PR_WAB_HOTMAIL_SERVERIDS ||
        !lpProps[2].Value.MVSZ.cValues ||
        lpProps[0].Value.MVSZ.cValues != lpProps[1].Value.MVSZ.cValues ||
        lpProps[0].Value.MVSZ.cValues != lpProps[2].Value.MVSZ.cValues ||
        lpProps[1].Value.MVSZ.cValues != lpProps[2].Value.MVSZ.cValues)
        goto out;

    for(i=0;i<lpProps[0].Value.MVSZ.cValues;i++)
    {
        WriteRegistryDeletedHotsyncItem(    lpProps[2].Value.MVSZ.LPPSZ[i], //server id
                                            lpProps[0].Value.MVSZ.LPPSZ[i], //contact id
                                            lpProps[1].Value.MVSZ.LPPSZ[i]); //mod time
    }

out:

    FreeBufferAndNull(&lpProps);
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_cflct.c ===
#define COBJMACROS
#include <_apipch.h>
#include <wab.h>
#define COBJMACROS
#include "resource.h"
#include "objbase.h"
#include "ui_cflct.h"
#include "commctrl.h"
#include "winuser.h"

typedef struct CONFLICTS_PARAM
{
    LPHTTPCONFLICTINFO  prgConflicts;
    DWORD               cConflicts;
    DWORD               dwCurrentContact;
} CONFLICTS_PARAM, *LPCONFLICTS_PARAM;

#define ListView_GetFirstSel(_hwndlist)          ListView_GetNextItem(_hwndlist, -1, LVNI_SELECTED)
extern LPIMAGELIST_DESTROY         gpfnImageList_Destroy;
// extern LPIMAGELIST_LOADIMAGE    gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A     gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W     gpfnImageList_LoadImageW;

enum {
    LVINDEX_TITLE = 1,
    LVINDEX_ABVALUE = 2,
    LVINDEX_REPLACE = 0,
    LVINDEX_HMVALUE = 3,
};
static DWORD  g_rgFieldNameIds[] = 
{
    0,
    0,
    0,
    0,
    idsDisplayName,
    idsGivenName,
    idsSurname,
    idsNickname,
    idsEmail,
    idsHomeStreet,
    idsHomeCity,
    idsHomeState,
    idsHomePostalCode,
    idsHomeCountry,
    idsCompany,
    idsWorkStreet,
    idsWorkCity,
    idsWorkState,
    idsWorkPostalCode,
    idsWorkCountry,
    idsHomePhone,
    idsHomeFax,
    idsWorkPhone,
    idsWorkFax,
    idsMobilePhone,
    idsOtherPhone,
    idsBirthday,
    idsPager
};

/*
 *  CenterDialog
 *
 *  Purpose:
 *      This function centers a dialog with respect to its parent
 *      dialog.
 *
 *  Parameters:
 *      hwndDlg     hwnd of the dialog to center
 */
VOID CenterDialog(HWND hwndDlg)
{
    HWND    hwndOwner;
    RECT    rc;
    RECT    rcDlg;
    RECT    rcOwner;
    RECT    rcWork;
    INT     x;
    INT     y;
    INT     nAdjust;

    // Get the working area rectangle
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rcWork, 0);

    // Get the owner window and dialog box rectangles.
    //  The window rect of the destop window is in trouble on multimonitored
    //  macs. GetWindow only gets the main screen.
    if (hwndOwner = GetParent(hwndDlg))
        GetWindowRect(hwndOwner, &rcOwner);
    else
        rcOwner = rcWork;

    GetWindowRect(hwndDlg, &rcDlg);
    rc = rcOwner;

    // Offset the owner and dialog box rectangles so that
    // right and bottom values represent the width and
    // height, and then offset the owner again to discard
    // space taken up by the dialog box.
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
    OffsetRect(&rc, -rc.left, -rc.top);
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);

    // The new position is the sum of half the remaining
    // space and the owner's original position.
    // But not less than Zero - jefbai

    x= rcOwner.left + (rc.right / 2);
    y= rcOwner.top + (rc.bottom / 2);

    // Make sure the dialog doesn't go off the right edge of the screen
    nAdjust = rcWork.right - (x + rcDlg.right);
    if (nAdjust < 0)
        x += nAdjust;

    //$ Raid 5128: Make sure the left edge is visible
    if (x < rcWork.left)
        x = rcWork.left;

    // Make sure the dialog doesn't go off the bottom edge of the screen
    nAdjust = rcWork.bottom - (y + rcDlg.bottom);
    if (nAdjust < 0)
        y += nAdjust;

    //$ Raid 5128: Make sure the top edge is visible
    if (y < rcWork.top)
        y = rcWork.top;
    SetWindowPos(hwndDlg, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

static BOOL _ValidateEndConflictDialog(HWND hDlg)
{
    return TRUE;
}

void  _AddRow(HWND hwndList, DWORD dwIndex, DWORD dwResId, LPSTR pszServer, LPSTR pszClient, CONFLICT_DECISION cdCurrent)
{
    LVITEM  lvItem;
    TCHAR   szRes[255];

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    LoadString(hinstMapiX, (cdCurrent == CONFLICT_IGNORE ? idsSyncSkip : idsSyncKeep), szRes, CharSizeOf(szRes));
    lvItem.iItem = ListView_GetItemCount(hwndList);
    lvItem.lParam = dwIndex;
    lvItem.pszText = szRes;
    lvItem.iImage = cdCurrent;
    ListView_InsertItem(hwndList, &lvItem);

    // [PaulHi] 1/22/99  Raid 67407  Convert single byte to double byte strings
    {
        LPWSTR  lpwszServer = ConvertAtoW(pszServer);
        LPWSTR  lpwszClient = ConvertAtoW(pszClient);

        ListView_SetItemText(hwndList,lvItem.iItem, LVINDEX_ABVALUE, (lpwszClient ? lpwszClient :  TEXT("")));
        ListView_SetItemText(hwndList,lvItem.iItem, LVINDEX_HMVALUE, (lpwszServer ? lpwszServer :  TEXT("")));		
        LoadString(hinstMapiX, dwResId, szRes, CharSizeOf(szRes));
        ListView_SetItemText(hwndList,lvItem.iItem, LVINDEX_TITLE, szRes);		

        LocalFreeAndNull(&lpwszServer);
        LocalFreeAndNull(&lpwszClient);
    }
}

void _RowSelected(HWND hDlg, LPCONFLICTS_PARAM pConflicts)
{
    int                 iItem, cItems;
    HWND                hwndList;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);

    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);

    iItem = ListView_GetFirstSel(hwndList);
    cItems = ListView_GetSelectedCount(hwndList);

    if (iItem >= 0)
    {
        LVITEM  lvItem;
        TCHAR   szRes[256];

        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_PARAM;
        lvItem.pszText = szRes;
        lvItem.cchTextMax = 255;
        lvItem.iItem = iItem;
        lvItem.iSubItem = LVINDEX_TITLE;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            if (cItems > 1)
                LoadString(hinstMapiX, idsMultipleSelected, szRes, CharSizeOf(szRes));

            SetDlgItemText(hDlg, IDC_SYNC_FIELDNAME, szRes);
            CheckDlgButton(hDlg, IDC_SYNC_ADDRESSBOOK, FALSE);
            CheckDlgButton(hDlg, IDC_SYNC_HOTMAIL, FALSE);
            CheckDlgButton(hDlg, IDC_SYNC_IGNORE, FALSE);

            if (cItems == 1)
            {
                switch(pCurrConflict->rgcd[lvItem.lParam])
                {
                    case CONFLICT_IGNORE:
                        CheckDlgButton(hDlg, IDC_SYNC_IGNORE, TRUE);
                        break;

                    case CONFLICT_SERVER:
                        CheckDlgButton(hDlg, IDC_SYNC_HOTMAIL, TRUE);
                        break;

                    case CONFLICT_CLIENT:
                        CheckDlgButton(hDlg, IDC_SYNC_ADDRESSBOOK, TRUE);
                        break;
                }
            }
        }
    }
}


BOOL _PageContainsSkip(HWND hDlg, LPCONFLICTS_PARAM pConflicts)
{
    int                 iItem, cItems;
    LVITEM              lvItem;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);
    HWND                hwndList;

    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);

    cItems = ListView_GetItemCount(hwndList);
    pCurrConflict->fContainsSkip = FALSE;
    
    for (iItem = 0; iItem < cItems; iItem++)
    {
        ZeroMemory(&lvItem, sizeof(lvItem));
        lvItem.mask = LVIF_PARAM;
        lvItem.cchTextMax = 0;
        lvItem.iItem = iItem;
        lvItem.iSubItem = LVINDEX_TITLE;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            switch(pCurrConflict->rgcd[lvItem.lParam])
            {
                case CONFLICT_IGNORE:
                    pCurrConflict->fContainsSkip = TRUE;
                    break;

                case CONFLICT_SERVER:
                    break;

                case CONFLICT_CLIENT:
                    break;
            }
        }

        if (pCurrConflict->fContainsSkip)
            break;
    }

    return pCurrConflict->fContainsSkip;
}


static void _FillInPage(HWND hDlg, LPCONFLICTS_PARAM pConflicts)
{
    HWND                hwndList;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);
    TCHAR               szName[255] =  TEXT("");
    LPTSTR              psz = szName;
    LPSTR               *ppszServer = (LPSTR *)pCurrConflict->pciServer;
    LPSTR               *ppszClient = (LPSTR *)pCurrConflict->pciClient;
    DWORD               dwCount = ARRAYSIZE(g_rgFieldNameIds), dwIndex;


    if (pCurrConflict->pciClient->pszDisplayName)
        psz = ConvertAtoW(pCurrConflict->pciClient->pszDisplayName);
    else if (pCurrConflict->pciClient->pszGivenName && pCurrConflict->pciClient->pszSurname)
    {
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("%s %s"), pCurrConflict->pciClient->pszGivenName, pCurrConflict->pciClient->pszSurname);
        psz = szName;
    }
    else if (pCurrConflict->pciServer->pszGivenName && pCurrConflict->pciServer->pszSurname)
    {
        wnsprintf(szName, ARRAYSIZE(szName), TEXT("%s %s"), pCurrConflict->pciServer->pszGivenName, pCurrConflict->pciServer->pszSurname);
        psz = szName;
    }
    else if (pCurrConflict->pciServer->pszNickname)
    {
        psz = ConvertAtoW(pCurrConflict->pciServer->pszNickname);
    }

    SetDlgItemText(hDlg, IDC_SYNC_CONTACTNAME, psz);
    
    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);
    ListView_DeleteAllItems(hwndList);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);
    
    for (dwIndex = 5; dwIndex < dwCount; dwIndex++)
    {
        if (ppszServer[dwIndex] && ppszClient[dwIndex])
        {
            if (lstrcmpA(ppszServer[dwIndex], ppszClient[dwIndex]))
                _AddRow(hwndList, dwIndex, g_rgFieldNameIds[dwIndex], ppszServer[dwIndex], ppszClient[dwIndex], pCurrConflict->rgcd[dwIndex]);
        }
        else
        {
            if( ppszServer[dwIndex] || ppszClient[dwIndex])
                _AddRow(hwndList, dwIndex, g_rgFieldNameIds[dwIndex], ppszServer[dwIndex], ppszClient[dwIndex], pCurrConflict->rgcd[dwIndex]);
        }
    }

    EnableWindow(GetDlgItem(hDlg, IDC_SYNC_NEXT), (pConflicts->dwCurrentContact < pConflicts->cConflicts - 1)); 
    EnableWindow(GetDlgItem(hDlg, IDC_SYNC_BACK), pConflicts->dwCurrentContact > 0); 

    CheckDlgButton(hDlg, IDC_SYNC_ADDRESSBOOK, FALSE);
    CheckDlgButton(hDlg, IDC_SYNC_HOTMAIL, FALSE);
    CheckDlgButton(hDlg, IDC_SYNC_IGNORE, FALSE);
    SetDlgItemText(hDlg, IDC_SYNC_FIELDNAME, TEXT(""));

    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
    _RowSelected(hDlg, pConflicts);

    if(psz != szName)
        LocalFreeAndNull(&psz);
}

void _ChangeDecision(HWND hDlg, LPCONFLICTS_PARAM pConflicts, CONFLICT_DECISION cdNew)
{
    int                 iItem, cItems, i;
    HWND                hwndList;
    LPHTTPCONFLICTINFO  pCurrConflict = &(pConflicts->prgConflicts[pConflicts->dwCurrentContact]);

    hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);

    iItem = -1;
    cItems = ListView_GetSelectedCount(hwndList);

    for (i = 0; i < cItems; i++)
    {
        iItem = ListView_GetNextItem(hwndList, iItem, LVNI_SELECTED);
        if (iItem >= 0)
        {
            LVITEM  lvItem;
            TCHAR   szRes[256];

            ZeroMemory(&lvItem, sizeof(lvItem));
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.pszText = szRes;
            lvItem.cchTextMax = 255;
            lvItem.iItem = iItem;
    
            if (ListView_GetItem(hwndList, &lvItem))
            {
                DWORD   dwResId;

                pCurrConflict->rgcd[lvItem.lParam] = cdNew;

                dwResId = (cdNew == CONFLICT_IGNORE ? idsSyncSkip : idsSyncKeep);
                LoadString(hinstMapiX, dwResId, szRes, CharSizeOf(szRes));

                lvItem.pszText = szRes;
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
                lvItem.iSubItem = 0;
                lvItem.iImage = cdNew;
                ListView_SetItem(hwndList, &lvItem);
//                ListView_SetItemText(hwndList,lvItem.iItem, 2, (cdNew == CONFLICT_IGNORE ? "X": (cdNew == CONFLICT_SERVER ? "-->": "<--")));		
            }
        }
    }
}

static void _InitConflictList(HWND hwnd)
{
    LVCOLUMN    lvCol;
    int         rgiColOrder[4] = {LVINDEX_TITLE, LVINDEX_ABVALUE, LVINDEX_REPLACE, LVINDEX_HMVALUE};
    RECT        rcWnd;
    int         iColWidth;
    HIMAGELIST  hImageList;
    TCHAR       szRes[255];

    if (hImageList = gpfnImageList_LoadImage(hinstMapiX,
                      MAKEINTRESOURCE(IDB_SYNC_SYNCOP),
                      //(LPCTSTR) ((DWORD) ((WORD) (IDB_SYNC_SYNCOP))),
                      16,
                      0,
                      RGB(255, 0, 255),
                      IMAGE_BITMAP,
                      0)) 
        ListView_SetImageList(hwnd, hImageList, LVSIL_SMALL);

    GetClientRect(hwnd, &rcWnd);
    iColWidth = ((rcWnd.right - rcWnd.left) - 180) / 2;

    LoadString(hinstMapiX, idsSyncReplace, szRes, CharSizeOf(szRes));
    lvCol.mask = LVCF_TEXT | LVCF_FMT;
    lvCol.pszText = szRes;
    lvCol.fmt = LVCFMT_LEFT;
    ListView_InsertColumn(hwnd, LVINDEX_REPLACE, &lvCol);

    LoadString(hinstMapiX, idsSyncField, szRes, CharSizeOf(szRes));
    ListView_InsertColumn(hwnd, LVINDEX_TITLE, &lvCol);

    LoadString(hinstMapiX, idsSyncABInfo, szRes, CharSizeOf(szRes));
    ListView_InsertColumn(hwnd, LVINDEX_ABVALUE, &lvCol);

    LoadString(hinstMapiX, idsSyncHMInfo, szRes, CharSizeOf(szRes));
    ListView_InsertColumn(hwnd, LVINDEX_HMVALUE, &lvCol);

    ListView_SetColumnWidth(hwnd,LVINDEX_TITLE,120);
    ListView_SetColumnWidth(hwnd,LVINDEX_ABVALUE,iColWidth);
    ListView_SetColumnWidth(hwnd,LVINDEX_REPLACE,65);
    ListView_SetColumnWidth(hwnd,LVINDEX_HMVALUE,iColWidth);

    ListView_SetColumnOrderArray(hwnd, 4, &rgiColOrder);
}
/*
    _ConflictDlgProc

    Description: Dialog proc for handling the contact conflict.
*/
INT_PTR CALLBACK _ConflictDlgProc(HWND     hDlg, 
                               UINT     iMsg, 
                               WPARAM   wParam, 
                               LPARAM   lParam)
{
    static char *sOldNewPassword;
    HWND hwndList;
    LPCONFLICTS_PARAM pConflicts = NULL;
    switch (iMsg)
    {
        case WM_INITDIALOG:
            pConflicts = (LPCONFLICTS_PARAM)lParam;

            CenterDialog(hDlg);
            hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);
            _InitConflictList(hwndList);
            pConflicts->dwCurrentContact = 0;
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pConflicts);
            _FillInPage(hDlg, pConflicts);
            return TRUE;

        case WM_DESTROY:
            // Free image lists
            hwndList = GetDlgItem(hDlg, IDC_SYNC_LIST);
            if (IsWindow(hwndList) && NULL != gpfnImageList_Destroy)
            {
                HIMAGELIST  hImageList;

                hImageList = ListView_GetImageList(hwndList, LVSIL_SMALL);
                if (NULL != hImageList)
                    gpfnImageList_Destroy(hImageList);
            }
            return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
//            return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);
            return TRUE;
        
        case WM_SETFONT:
            return TRUE;

        case WM_COMMAND:
            pConflicts = (LPCONFLICTS_PARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (!pConflicts)
                break;

            switch(LOWORD(wParam))
            {
                case IDC_SYNC_NEXT:
                    _PageContainsSkip(hDlg, pConflicts);
                    pConflicts->dwCurrentContact++;
                    _FillInPage(hDlg, pConflicts);
                    return TRUE;

                case IDC_SYNC_BACK:
                    _PageContainsSkip(hDlg, pConflicts);
                    pConflicts->dwCurrentContact--;
                    _FillInPage(hDlg, pConflicts);
                    return TRUE;

                case IDC_SYNC_ADDRESSBOOK:
                    _ChangeDecision(hDlg, pConflicts, CONFLICT_CLIENT);
                    return TRUE;
                
                case IDC_SYNC_HOTMAIL:
                    _ChangeDecision(hDlg, pConflicts, CONFLICT_SERVER);
                    return TRUE;

                case IDC_SYNC_IGNORE:
                    _ChangeDecision(hDlg, pConflicts, CONFLICT_IGNORE);
                    return TRUE;

                case IDOK:
                    _PageContainsSkip(hDlg, pConflicts);
                    if (_ValidateEndConflictDialog(hDlg))
                        EndDialog(hDlg, IDOK);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;

            }
            break;

	    case WM_NOTIFY: 
 
            // Branch depending on the specific notification message. 
            switch (((LPNMHDR) lParam)->code) { 
 
                // selection changed, update the contols
                case NM_CLICK:
                case NM_CUSTOMDRAW:
                case LVN_BEGINDRAG:
                case LVN_ODSTATECHANGED:
                    pConflicts = (LPCONFLICTS_PARAM)GetWindowLongPtr(hDlg, GWLP_USERDATA);
                    _RowSelected(hDlg, pConflicts);
                    break; 
 
                // Process LVN_ENDLABELEDIT to change item labels after 
                // in-place editing. 
                case LVN_ENDLABELEDITA: 
                case LVN_ENDLABELEDITW: 
                    break; 
                // Process LVN_COLUMNCLICK to sort items by column. 
                case LVN_COLUMNCLICK: 
                    break;
            } 
        break; 


    }
    return FALSE;
}

/*
    ResolveConflicts

*/
BOOL    ResolveConflicts(HWND hwnd, LPHTTPCONFLICTINFO prgConflicts, DWORD cConflicts) 
{
    int bResult;
    DWORD dwErr;
    CONFLICTS_PARAM cParam = {0};

    Assert(hwnd);
    if (cConflicts == 0)
        return S_OK;

    cParam.cConflicts = cConflicts;
    cParam.prgConflicts = prgConflicts;
    bResult = (int) DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(iddConflict), hwnd, _ConflictDlgProc, (LPARAM)&cParam);
    dwErr = GetLastError();

    return (bResult == IDOK);   
}

typedef struct tagChooseServer
{
    IImnEnumAccounts *pEnumAccts;
    LPSTR             pszName;
    DWORD             cchName;
} CHOOSE_SERVER_PARAM;
/*
    _ChooseServerDlgProc

    Description: Dialog proc for handling the choose server.
*/
INT_PTR CALLBACK _ChooseServerDlgProc(HWND     hDlg, 
                               UINT     iMsg, 
                               WPARAM   wParam, 
                               LPARAM   lParam)
{
    CHOOSE_SERVER_PARAM *pParams;
    HWND                hwndList;
    DWORD               i, dwCount;
    HRESULT             hr;

    switch (iMsg)
    {
        case WM_INITDIALOG:
            pParams = (CHOOSE_SERVER_PARAM*)lParam;

            CenterDialog(hDlg);
            hwndList = GetDlgItem(hDlg, IDC_SERVER_LIST);
            SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR)pParams);

            SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
            
            *pParams->pszName = 0;

            pParams->pEnumAccts->lpVtbl->Reset(pParams->pEnumAccts);
            pParams->pEnumAccts->lpVtbl->SortByAccountName(pParams->pEnumAccts);

            if (SUCCEEDED(hr = pParams->pEnumAccts->lpVtbl->GetCount(pParams->pEnumAccts, &dwCount)))
            {
                IImnAccount *pAccount = NULL;
                char        szAcctName[CCHMAX_ACCOUNT_NAME+1];
                DWORD       ccb;

                for (i = 0; i < dwCount; i++)
                {
                    if (SUCCEEDED(hr = pParams->pEnumAccts->lpVtbl->GetNext(pParams->pEnumAccts, &pAccount)))
                    {
                        ccb = CharSizeOf(szAcctName);
                        if (FAILED(hr = pAccount->lpVtbl->GetProp(pAccount, AP_ACCOUNT_NAME, szAcctName, &ccb)))
                            continue;

                        // [PaulHi] 1/19/99  Raid 66195
                        // Must use wide character string
                        {
                            LPWSTR lpwszAcctName = ConvertAtoW(szAcctName);
                            SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)lpwszAcctName);
                            LocalFreeAndNull(&lpwszAcctName);
                        }

                        pAccount->lpVtbl->Release(pAccount);
                    }
                }
            }
            else
                return FALSE;

            return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
//            return OnContextHelp(hDlg, iMsg, wParam, lParam, g_rgCtxMapMultiUserGeneral);
            return TRUE;
        
        case WM_SETFONT:
            return TRUE;

        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case LBN_DBLCLK:
                    wParam = IDOK;
                    break;
                case LBN_SELCHANGE:
                    break;
            }

            pParams = (CHOOSE_SERVER_PARAM*)GetWindowLongPtr(hDlg, GWLP_USERDATA);
            if (!pParams)
                break;

            switch(LOWORD(wParam))
            {
                DWORD   dwSelItem;

                case IDOK:
                    dwSelItem = (DWORD) SendDlgItemMessage(hDlg, IDC_SERVER_LIST, LB_GETCURSEL, 0, 0);
                    if (LB_ERR != dwSelItem)
                    {
                        // [PaulHi] 1/19/99  Raid 66195
                        // Convert wide char back to MB
                        TCHAR   tszName[CCHMAX_ACCOUNT_NAME+1]=TEXT("");
                        LPSTR   lpstr = NULL;
                        int     nLen;

                        nLen = (int)SendDlgItemMessage(hDlg, IDC_SERVER_LIST, LB_GETTEXTLEN, dwSelItem, 0);
                        if (nLen < ARRAYSIZE(tszName))
                        {
                            nLen = (int) SendDlgItemMessage(hDlg, IDC_SERVER_LIST, LB_GETTEXT, dwSelItem, (LPARAM)tszName);
                        }

                        AssertSz((nLen <= CCHMAX_ACCOUNT_NAME), TEXT("ChooseHotmailServer: Returned account name too large for buffer"));

                        lpstr = ConvertWtoA(tszName);
                        StrCpyNA(pParams->pszName, lpstr, pParams->cchName);
                        LocalFreeAndNull(&lpstr);

                        EndDialog(hDlg, IDOK);
                    }
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    return TRUE;

            }
            break;
    }
    return FALSE;
}

/*
    ChooseHotmailServer

*/
BOOL    ChooseHotmailServer(HWND hwnd, IImnEnumAccounts *pEnumAccts, LPSTR pszAccountName, DWORD cchAccountName)
{
    int bResult;
    DWORD dwErr;
    CHOOSE_SERVER_PARAM cParam = {0};

    Assert(hwnd);

    cParam.pEnumAccts = pEnumAccts;
    cParam.pszName = pszAccountName;
    cParam.cchName = cchAccountName;
    bResult = (int) DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(iddChooseServer), hwnd, _ChooseServerDlgProc, (LPARAM)&cParam);

    return (bResult == IDOK);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\uimisc.h ===
////////////////////////////////////////////////////////////////////////////////
//
//	UIMISC.H - header for common miscellaneous functions used by the UI
//
//
////////////////////////////////////////////////////////////////////////////////
#ifndef __UIMISC_H_
#define __UIMISC_H_

#define IDC_TREEVIEW            9010 //These should really be in resource.h
#define IDC_SPLITTER            9011

#define TOOLTIP

#define MAX_DISPLAY_NAME_LENGTH 32
#define MAX_UI_STR              200
#define MAX_BUF_STR             4*MAX_UI_STR

#ifndef WIN16
static LPTSTR g_szWABHelpFileName = TEXT("WAB.HLP");
#else
static LPTSTR g_szWABHelpFileName = TEXT("WAB16.HLP");
#endif
extern const LPTSTR szInternetCallKey;
extern const LPTSTR szCallto;
extern const LPTSTR szCRLF;
extern const LPTSTR szColon;
extern const LPTSTR szTrailingDots;
extern const LPTSTR szArrow;
extern const LPTSTR szBackSlash;


#define IDC_BB_NEW      		8080
#define IDC_BB_PROPERTIES		8082
#define IDC_BB_DELETE			8083
#define IDC_BB_FIND				8084
#define IDC_BB_PRINT            8085
#define IDC_BB_ACTION           8086
#define IDC_BB_ADD_TO_ADDRBOOK  8087

// This should not be an enumeration as tbPrint can drop out at
// run-time.  Be very careful if you change the order of this
// enumeration - search for all uses of these enumerated values
// first.  There is code in ui_abook.c which relies on tbPrint
// being in front of tbAction.
enum _Toolbar
{
    tbNew=0,
    tbProperties,
    tbDelete,
    tbFind,
    tbPrint,
    tbAction, //upto this many on the toolbar
    tbAddToWAB,
    tbCopy,   //these on the context menu
    tbPaste,
    tbNewEntry,
    tbNewGroup,
    tbNewFolder,
    tbMAX
};

enum _AddressModalDialogState // Used in various forms of modal IAB_ADDRESS dialogs
{
    STATE_SELECT_RECIPIENTS = 0,
    STATE_PICK_USER,
    STATE_BROWSE,
    STATE_BROWSE_MODAL
};

// Returned values from our Search Dialog Proc
enum _SearchDialogReturnValues
{
    SEARCH_CANCEL=0,
    SEARCH_OK,
    SEARCH_ERROR,
	SEARCH_CLOSE,
	SEARCH_USE
};


//#define VCARD

// **** Keep this enum below in sync with the Main menu structure in CoolUI.RC
enum _MainMenuSubMenus
{
    idmFile = 0,
    idmEdit,
    idmView,
    idmTools,
    idmHelp
};

enum _FileMenu
{
    idmNewContact = 0,
    idmNewGroup,
    idmNewFolder,
    idmFSep1,
    idmProperties,
    idmDelete,
    idmFSep2,
    idmImport,
    idmExport,
    idmFSep3,
    idmPrint,
    idmFSep4,
#ifdef FUTURE
    idmFolders,
    idmSepFolders,
#endif
    idmSwitchUsers,
    idmAllContents,
    idmFSep5,
    idmClose,
    idmFileMax,
};

enum _EditMenu
{
    idmCopy=0,
    idmPaste,
    idmESep1,
    idmSelectAll,
    idmESep2,
//    idmProfile,
//    idmESep3,
    idmFindPeople,
};

enum _ViewMenus
{
    idmToolBar=0,
    idmStatusBar,
	idmGroupsList,
    idmSepUI,
    idmLargeIcon,
    idmSmallIcon,
    idmList,
    idmDetails,
    idmSepListStyle,
    idmSortBy,
    idmSepSort,
    idmRefresh,
    idmViewMax,
};

enum _ToolsMenus
{
    idmAccounts=0,
    idmSepAccounts,
    idmOptions,
    idsSepOptions,
    idmAction,
};

#define WAB_ONEOFF_NOADDBUTTON  0x00000080 // Flag used to surpress AddToWABButton in iAddrBook::Details


#ifdef HM_GROUP_SYNCING
// [PaulHi] Private message to begin a second group synchronization pass to main UI thread
#define WM_USER_SYNCGROUPS WM_USER+102
#endif


// Private message we send to our toolbar container so it can forward it to
// the toolbar.
#define WM_PRVATETOOLBARENABLE WM_USER+101
//////////////////////////////////////////////////////////////////////////////
//
// IMPORTANT NOTE: If you change this, you must change lprgAddrBookColHeaderIDs in
//   globals.c!
//
enum _AddrBookColumns
{
        colDisplayName=0,
        colEmailAddress,
		colOfficePhone,
		colHomePhone,
        NUM_COLUMNS
 };

//////////////////////////////////////////////////////////////////////////////
//
// This structure is used for storing the address book position and column sizes
// in the registry for persistence
//
typedef struct _AddressBookPosColSize
{
    RECT rcPos;
    int nColWidth[NUM_COLUMNS];
    BOOL bViewToolbar;
    DWORD dwListViewStyle;
    int nListViewStyleMenuID;
    BOOL bViewStatusBar;
    int colOrderArray[NUM_COLUMNS];
    BOOL bViewGroupList;
    int nTab;
    int nTViewWidth;
} ABOOK_POSCOLSIZE, * LPABOOK_POSCOLSIZE;
//////////////////////////////////////////////////////////////////////////////


extern const TCHAR *g_rgszAdvancedFindAttrs[];


/////////////////////////////////////////////////////////////////////////////
// This represents all the listview boxes in the UI
// Using these tags we can customize the context sensitive menus
// in one sub routine saving code duplication ...
/////////////////////////////////////////////////////////////////////////////
enum _AllTheListViewBoxes
{
	lvMainABView = 0,
	lvDialogABContents,         // Modeless address view LV
	lvDialogModalABContents,    // Modal addres vuew LV
	lvDialogABTo,               // To Well LV
	lvDialogABCC,               // CC Well LV
	lvDialogABBCC,              // BCC Well LV
	lvDialogDistList,           // Disttribution list UI LV
	lvDialogResolve,            // Resolve dialog LV
    lvDialogFind,               // Find dialog results LV
	lvMainABTV,					// TreeView in main AB
    lvToolBarAction,
    lvToolBarNewEntry,
#ifdef COLSEL_MENU 
    lvMainABHeader,             // column selection viewin main AB
#endif // COLSEL_MENU 

};


/////////////////////////////////////////////////////////////////////////////
// These are indexes into the bitmaps to show the little bitmap
// next to each entry - this has to be synchronized with the bmps
/////////////////////////////////////////////////////////////////////////////
enum _ListViewImages
{
	imageMailUser=0, //Common to small and large imagelists
	imageDistList,
	imageSortDescending,
	imageSortAscending,
    imageDirectoryServer,
    imageUnknown,
    imageMailUserLDAP,
    imageAddressBook,
    imageMailUserWithCert,
    imageMailUserMe,
    imageFolderClosed,
    imageFolderOpen,
    imageMailUserOneOff,
	imageMax
};

//
// cellwidth of LV image lists
//
#define S_BITMAP_WIDTH 16
#define S_BITMAP_HEIGHT 16
#define L_BITMAP_WIDTH 32

#define RGB_TRANSPARENT (COLORREF)0x00FF00FF

//
// UI control spacing - TBD confirm these numbers
//
#define BORDER 3 //pixels
#define CONTROL_SPACING 3


// UI Refresh timer defines
#define WAB_REFRESH_TIMER   14     // timer identifier
#define WAB_REFRESH_TIMEOUT 4000   // time-out value - 4 seconds


/////////////////////////////////////////////////////////////////////////////
// LDAP_SEARCH_PARAMS - specifies parameters for LDAP searches
/////////////////////////////////////////////////////////////////////////////
enum _LDAPSearch
{
    ldspDisplayName,
    ldspEmail,
    ldspAddress,
    ldspPhone,
    ldspOther,
    ldspMAX
};

typedef struct _LDAPSearchParams
{
    LPADRBOOK lpIAB;
    TCHAR szContainerName[MAX_UI_STR];
    TCHAR szData[ldspMAX][MAX_UI_STR];
    BOOL bUseOtherBase;
} LDAP_SEARCH_PARAMS, * LPLDAP_SEARCH_PARAMS;




/////////////////////////////////////////////////////////////////////////////
// Stores info about each entry in the list view control
// Each entry in the list view controls has 1 structure corresponding to that
// entry
/////////////////////////////////////////////////////////////////////////////
typedef struct _RecipientInfo
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;
    TCHAR       szDisplayName[MAX_DISPLAY_NAME_LENGTH];//The actual text that is displayed
//    LPTSTR      szDisplayName;
    TCHAR       szEmailAddress[MAX_DISPLAY_NAME_LENGTH];
    TCHAR       szHomePhone[MAX_DISPLAY_NAME_LENGTH];
    TCHAR       szOfficePhone[MAX_DISPLAY_NAME_LENGTH];
    TCHAR       szByLastName[MAX_DISPLAY_NAME_LENGTH]; // Stores the text preloaded by last name first
    TCHAR       szByFirstName[MAX_DISPLAY_NAME_LENGTH];// Stores preloaded DisplayName
    ULONG       ulRecipientType;
    ULONG       ulObjectType;
    BOOL        bHasCert;
    BOOL        bIsMe;
    ULONG       ulOldAdrListEntryNumber; //if this was an element passed into the Address lpAdrList
                                        //we store its original AdrList index here so that we dont
                                        //have to do inefficient searches later ...
                                        // ***VERY IMPORTANT*** Legal values range from 1 to AdrList->cValues (not from 0)
    LPTSTR      lpByRubyFirstName;
    LPTSTR      lpByRubyLastName;
    struct _RecipientInfo * lpNext;
    struct _RecipientInfo * lpPrev;
} RECIPIENT_INFO, * LPRECIPIENT_INFO;



//////////////////////////////////////////////////////////////////////////////
// Hack structure used for talking between the Find dialog and the select
// recipients dialog
//////////////////////////////////////////////////////////////////////////////
typedef struct _AdrParmFindInfo
{
    LPADRPARM lpAdrParms;
    LPRECIPIENT_INFO * lppTo;
    LPRECIPIENT_INFO * lppCC;
    LPRECIPIENT_INFO * lppBCC;
	int DialogState;	// identifies where it was called from
	int nRetVal;		// return code identifies what action closed the dialog
	LPENTRYID lpEntryID;
	ULONG cbEntryID;
} ADRPARM_FINDINFO, * LPADRPARM_FINDINFO;
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// A structure that will contain the LDAP URL subparts ...
typedef struct _LDAPURL
{
    LPTSTR   lpszServer;     // Server name
    LPTSTR   lpszBase;       // Base <dn>
    LPTSTR * ppszAttrib;     // Attributes requested
    ULONG   ulAttribCount;  //
    ULONG   ulScope;        // Search scope
    LPTSTR   lpszFilter;     // search filter
    LPTSTR   lpszExtension;  // And extension part of the URL
    LPTSTR   lpszBindName;   // A bindname extension for the URL
    BOOL    bServerOnly;    // Only found a server entry
    DWORD   dwAuthType;     // Authentication Type
    LPRECIPIENT_INFO lpList;// used to cache multple query results
} LDAPURL, * LPLDAPURL;
//////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// This structure holds information about
// the sort order of a particular list view
/////////////////////////////////////////////////////////////////////////////
typedef struct _SortInfo
{
    int iOldSortCol;
	int iOlderSortCol;
    BOOL bSortAscending;
    BOOL bSortByLastName;
} SORT_INFO, *LPSORT_INFO;


/////////////////////////////////////////////////////////////////////////////
// We will subclass some of the child controls on the main Address Book View to
// enable tabbing between the controls - the following
// are used in this subclassing
/////////////////////////////////////////////////////////////////////////////
enum _SubClassedControlIndexs
{
	s_EditQF=0,
	s_ListAB,
	s_TV,
	s_Max
};

typedef struct _ToolTipInfo
{
    int iItem;
    BOOL bActive;
    TCHAR szTipText[MAX_BUF_STR];
    UINT_PTR uTooltipTimer;
    BOOL bShowTooltip;
} TOOLTIP_INFO, * LPTOOLTIPINFO;

typedef struct _TVItemStuff
{
    ULONG ulObjectType;
    LPSBinary lpsbEID;
    LPSBinary lpsbParent;
    HTREEITEM hItemParent;
} TVITEM_STUFF, * LPTVITEM_STUFF;


// There may be several property sheets in the final version of the details pane
// Each list will have a seperate set of controls corresponding to different properties
// We want to retrieve the control values and map them into a property-array
// Each dialog will create its own proparray on exiting. The original record will also
// have some properties that never got mapped in the first place and some which may have been
// deleted thru the ui. Hence we look at the old array and the new array and create a merged
// list of props ... all mapped props in the new arrays superscede props in the
// old array

enum _PropSheets{   propSummary = 0,
                    propPersonal,   // a list of all the property sheets on this page
                    propHome,
                    propBusiness,
                    propNotes,
                    propConferencing,
                    propCert,
                    propOrg,
                    propTrident,
                    propFamily,
                    TOTAL_PROP_SHEETS
                };

enum _DLPropSheets{ propGroup = 0,
                    propGroupOther,
                    propDLMax
                    };

enum _DetailsDialogReturnValues
{
    DETAILS_RESET = 0, //blank return value
    DETAILS_OK,
    DETAILS_CANCEL,
    DETAILS_ADDTOWAB
};

enum
{
    contactHome=0,
    contactBusiness,
    groupOther,
    contactPersonal,
};



//////////////////////////////////////////////////////////////////////////////
//
// The PropArrayInfo is used by the property sheets displaying details on 
// contacts or groups
//
//////////////////////////////////////////////////////////////////////////////
// Misc flags used here
#define DETAILS_DNisCompanyName     0x00000001
#define DETAILS_DNisNickName        0x00000002
#define DETAILS_DNisFMLName         0x00000004
#define DETAILS_UseRubyPersonal     0x00000008 //  Determines if the displayed prop sheet is a RUBY one for Japan/China/Korea
#define DETAILS_Initializing        0x00000010 //  Prevents WM_COMMAND triggers during initialization
#define DETAILS_ProgChange          0x00000020 //  Diffrentiates between changes in Display Name caused by user and by other parts of the code
#define DETAILS_EditingEmail        0x00000040 //  So we can abort the email editing if user cancels
#define DETAILS_HideAddToWABButton  0x00000080 // Hides the add-to-wab button for some one-offs
#define DETAILS_ShowCerts           0x00000100 //  Decides whether or not to show certs UI
#define DETAILS_ShowTrident         0x00000200 //  Decides whether or not to show Trident in UI
#define DETAILS_ShowNetMeeting      0x00000400 //  Decides whether or not to show Netmeeting stuff
#define DETAILS_ShowOrg             0x00000800 //  Decides whether or not to show Org UI
#define DETAILS_EditingConf         0x00001000 //  Tracks if editing a server/email pair
#define DETAILS_ShowSummary         0x00002000 //  Decides whether or not to present summary information
#define DETAILS_EditingOneOff       0x00004000 //  Tracks if editing a group one-off
#define DETAILS_DefHomeChanged      0x00008000 //  Used to track changes in non-Edit controls on the Home prop sheets
#define DETAILS_DefBusChanged       0x00010000 //  Used to track changes in non-Edit controls on the Business prop sheets
#define DETAILS_GenderChanged       0x00020000 //  Used to track changes in Gender
#define DETAILS_DateChanged         0x00040000 //  Used to track changes in Date-Time fields
#define DETAILS_ChildrenChanged     0x00080000 //  Used to track changes in PR_CHILDRENS_NAMES
#define DETAILS_EditingChild        0x00100000 //  Tracks if we're in the middle of editing a children name

typedef struct _PropArrayInfo
{
    ULONG   cbEntryID;              // Entryid of this item
    LPENTRYID lpEntryID;
    ULONG   ulOperationType;        // SHOW_DETAILS or SHOW_NEW_ENTRY
    ULONG   ulObjectType;           // MAILUSER or DISTLIST
    LPMAPIPROP lpPropObj;           // Actual object we are displaying
    int     nRetVal;
    BOOL    bSomethingChanged;          //  flags changes so we dont waste processing
    BOOL    bPropSheetOpened[TOTAL_PROP_SHEETS];
    ULONG   ulFlags;
    HWND    hWndDisplayNameField;       //  Holds HWND of DN edit field
    int     ulTridentPageIndex;         //  index of the trident sheet in case we need to remove it
    LPADRBOOK lpIAB;
    LPIWABDOCHOST lpIWABDocHost;
    int     nDefaultServerIndex;
    int     nBackupServerIndex;
    LPTSTR  szDefaultServerName;        //  LocalAlloc storage for these and then free them later ..
    ULONG   cchDefaultServerName;
    LPTSTR  szBackupServerName;
    ULONG   cchBackupServerName;
    int     nConfEditIndex;
    SBinary sbDLEditingOneOff;
    HWND    hWndComboConf;
    LPRECIPIENT_INFO lpContentsList;    //  Used by groups only for member lists
    LPCERT_ITEM lpCItem;                //  Keeps a list of all our cert items ...
    int nPropSheetPages;                //  Total number of propsheets for this item
    HPROPSHEETPAGE * lphpages;          //  An array of all the prop sheets created for this item
    LPWABEXTDISPLAY lpWED;              //  Stores info about extended prop sheets
    LPEXTDLLINFO lpExtList;             //  List of shell extension objects
    LPTSTR  lpLDAPURL;                  //  Points to the LDAP URL, if any, being displayed
    BOOL    bIsNTDSURL;                   //  True if the LDAP URL represents an object from an NTDS
    LPTSTR  lpszOldName;                //  used for caching the old name of the prop being displayed
    int nNTDSPropSheetPages;            //  Tracks the number of NTDS PropSheet extensions
    HPROPSHEETPAGE * lphNTDSpages;      //  We cache the NTDS extension prop pages seperately since we may need to replace out own pages with these
    GUID    guidExt;                    // Used while creating prop sheet extensions for identifying the appropriate extension
} PROP_ARRAY_INFO, * LPPROP_ARRAY_INFO;

#define DL_INFO PROP_ARRAY_INFO 
#define LPDL_INFO LPPROP_ARRAY_INFO

//
// The following structure is used to cache various data associated with the
// main browse UI for the WAB
//
typedef struct _tabBrowseWindowInfo
{
    // Following are used in ui_abook.c in the main ui
    HWND        hWndListAB;        //  Handle of main list view
    HWND        hWndBB;            //  Handle of Button Bar
    HWND        hWndEditQF;
    HWND        hWndStaticQF;
    HWND        hWndAB;            //  Handle of the Address Book Window
    HWND        hWndSB;            //  Status bar
    int         iFocus;            //  Tracks who has the focus
    LPRECIPIENT_INFO lpContentsList;
    LPADRBOOK   lpAdrBook;      //  Hangs on to AdrBook object
    LPIAB       lpIAB;          //  Internal version of AdrBook object
    WNDPROC     fnOldProc[s_Max]; // Subclass some of the control procs
    HWND	    s_hWnd[s_Max];  //  HWNDS of subclasses controls
    LPFNDISMISS lpfnDismiss;//  Context for dismissing in the case of modeless IAdrBook window
    LPVOID      lpvDismissContext;  // Dismiss context as above
    HWND        hWndTools;           // handle of the toolbar window
    SORT_INFO   SortInfo;   //  Sort Info
#ifdef TOOLBAR_BACK
    HBITMAP     hbmBack;          // handle of the toolbar background
    HPALETTE    hpalBkgnd;       // handle of the toolbar background palette
#endif
    HWND        hWndTT;        // Tooltip control info in ui_abook.c
    TOOLTIP_INFO tti;
    BOOL        bDoQuickFilter;
    // bobn: brianv says we have to take this out...
    //int         nCount;
    // Used to override automatic notification-fueled refreshes
    BOOL        bDontRefreshLV;
    // Related to Treeview in ui_Abook.c
    HWND        hWndTV;
    HWND        hWndSplitter;
    // Related to drag and drop
    LPIWABDRAGDROP lpIWABDragDrop;
    // Related to Notifications and updates
    LPMAPIADVISESINK lpAdviseSink;
    ULONG       ulAdviseConnection;

    BOOL        bDeferNotification; // Used to defer next notification request

    HTREEITEM   hti; //used for caching rt-click items for treeview

    LPWABFOLDER lpUserFolder;           //  Used only to mark the User-Folder being rt-clicked
#ifdef COLSEL_MENU 
    ULONG       iSelColumn;             //  Used for Column Selection caching
#endif
} BWI, * LPBWI;

#define bwi_lpUserFolder     lpbwi->lpUserFolder
#define bwi_hti              lpbwi->hti
#define bwi_hWndListAB       lpbwi->hWndListAB
#define bwi_hWndBB           lpbwi->hWndBB
#define bwi_hWndSB           lpbwi->hWndSB
#define bwi_bDoQuickFilter   lpbwi->bDoQuickFilter
// bobn: brianv says we have to take this out...
//#define bwi_nCount           lpbwi->nCount
#define bwi_bDeferNotification  lpbwi->bDeferNotification

#define bwi_SortInfo         lpbwi->SortInfo

#define bwi_hWndTT           lpbwi->hWndTT
#define bwi_tt_iItem         ((lpbwi->tti).iItem)
#define bwi_tt_bActive       lpbwi->tti.bActive
#define bwi_tt_szTipText     ((lpbwi->tti).szTipText)
#define bwi_tt_TooltipTimer  ((lpbwi->tti).uTooltipTimer)
#define bwi_tt_bShowTooltip  ((lpbwi->tti).bShowTooltip)

#define bwi_hWndTV           (lpbwi->hWndTV)
#define bwi_hWndSplitter      (lpbwi->hWndSplitter)

#define bwi_hWndEditQF       lpbwi->hWndEditQF
#define bwi_hWndStaticQF     lpbwi->hWndStaticQF
#define bwi_hWndAB           lpbwi->hWndAB
#define bwi_iFocus           lpbwi->iFocus
#define bwi_lpIAB            (lpbwi->lpIAB)
#define bwi_lpAdrBook        (lpbwi->lpAdrBook)
#define bwi_fnOldProc        (lpbwi->fnOldProc)
#define bwi_s_hWnd           (lpbwi->s_hWnd)
#define bwi_lpContentsList   (lpbwi->lpContentsList)
#define bwi_lpfnDismiss      (lpbwi->lpfnDismiss)
#define bwi_lpvDismissContext (lpbwi->lpvDismissContext)

#define bwi_hWndTools         (lpbwi->hWndTools)

#ifdef TOOLBAR_BACK
#define bwi_hbmBack           (lpbwi->hbmBack)
#define bwi_hpalBkgnd         (lpbwi->hpalBkgnd)
#endif

#define bwi_bDontRefreshLV   (lpbwi->bDontRefreshLV)
#define bwi_lpIWABDragDrop   (lpbwi->lpIWABDragDrop)

#define bwi_lpAdviseSink     (lpbwi->lpAdviseSink)
#define bwi_ulAdviseConnection (lpbwi->ulAdviseConnection)

/////////////////////////////////////////////////////////////////////////////
// Each thread can generate a different Address Book window .. need to
// keep the data thread safe ...
/////////////////////////////////////////////////////////////////////////////
typedef struct _tagPerThreadGlobalData
{
    // Persistent search params
    LDAP_SEARCH_PARAMS LDAPsp;// Search parameters for LDAP

    LPADRBOOK lpIAB;
    HACCEL hAccTable;       //  Accelerator TAble

    HWND hWndFind;      // hWnd of Find dialog so LDAP cancel dialog has a parent
    HWND hDlgCancel;    // hWnd of the Cancel dialog
    BOOL bDontShowCancel;   // Dont show the cancel dialog when the find is launched ...

    // Used in print dialog
    BOOL bPrintUserAbort;
    HWND hWndPrintAbortDlg;

    // Tracks if this is an OpenExSession
    BOOL bIsWABOpenExSession;
    BOOL bIsUnicodeOutlook;     // Tracks if this WAB supports Unicode in which case we don't need to do Unicode conversions for it

#ifdef HM_GROUP_SYNCING
    LPTSTR lptszHMAccountId;    // Keeps Hotmail syncing account ID across two synchronization passes.
#endif

    BOOL bDisableParent;
    
    // Tracks first run for Directory Service modification
    BOOL bFirstRun;

    // Default Platform/Dialog Font
    HFONT hDefFont;
    HFONT hDlgFont;

    // Caches a cookie for LDAP paged results
    struct berval *   pCookie;

} PTGDATA, * LPPTGDATA;

#define pt_hDefFont         (lpPTGData->hDefFont)
#define pt_hDlgFont         (lpPTGData->hDlgFont)
#define pt_pCookie          (lpPTGData->pCookie)
#define pt_LDAPsp           (lpPTGData->LDAPsp)

#define pt_hWndFind         lpPTGData->hWndFind
#define pt_hDlgCancel       lpPTGData->hDlgCancel
#define pt_bDontShowCancel  lpPTGData->bDontShowCancel

#define pt_bPrintUserAbort  (lpPTGData->bPrintUserAbort)
#define pt_hWndPrintAbortDlg    (lpPTGData->hWndPrintAbortDlg)

#define pt_bIsWABOpenExSession (lpPTGData->bIsWABOpenExSession)
#define pt_bIsUnicodeOutlook        (lpPTGData->bIsUnicodeOutlook)

#define pt_bDisableParent   (lpPTGData->bDisableParent)

#define pt_bFirstRun        (lpPTGData->bFirstRun)

#define pt_lpIAB            (lpPTGData->lpIAB)
#define pt_hAccTable        (lpPTGData->hAccTable)

// This is a global
DWORD dwTlsIndex;                      // index for private thread storage


// for COLSEL_MENU stuff
#ifdef COLSEL_MENU
extern const ULONG MenuToPropTagMap[];
#endif // COLSEL_MENU

/**** MISC UI FUNCTIONS ****/

// Gets a threads storage pointer or creates a new one if none found
LPPTGDATA __fastcall GetThreadStoragePointer();

//This function frees up RECIPIENT_INFO structures
void FreeRecipItem(LPRECIPIENT_INFO * lppItem);


// This function loads a string and allocates space for it.
LPTSTR LoadAllocString(int StringID);


// This function initializes a list view
HRESULT HrInitListView(	HWND hWndLV,			// List view hWnd
						DWORD dwStyle,			// Style
						BOOL bShowHeaders);		// Hide or show column headers


// This function fills a list view from a contents list
HRESULT HrFillListView(	HWND hWndLV,			
						LPRECIPIENT_INFO lpContentsList);


// Call to create main view to address book
HWND hCreateAddressBookWindow(	LPADRBOOK lpIAB,	
								HWND hWndParent,
								LPADRPARM lpszCaption);


// Creates a ContentsList from the property store
HRESULT HrGetWABContentsList(   LPIAB lpIAB, 
                                SORT_INFO SortInfo,
								LPSPropTagArray  lpPTA,
								LPSPropertyRestriction lpPropRes,
								ULONG ulFlags,
                                LPSBinary lpsbContainer,
                                BOOL bGetProfileContents,
                                LPRECIPIENT_INFO * lppContentsList);


#define LDAP_USE_ADVANCED_FILTER 0x04000000 // completely made up flag
                                            // for passing a advanced filter 
                                            // to the LDAP_FindRow
// Creates ContentsList from an LDAP container
HRESULT HrGetLDAPContentsList(  LPADRBOOK lpIAB,
                                ULONG   cbContainerEID,
                                LPENTRYID   lpContainerEID,
                                SORT_INFO SortInfo,
	                            LPSRestriction lpPropRes,
                                LPTSTR lpAdvFilter,
								LPSPropTagArray  lpPTA,
                                ULONG ulFlags,
                                LPRECIPIENT_INFO * lppContentsList);

// Trims leading and trailing spaces from strings
BOOL TrimSpaces(TCHAR * szBuf);


// Sort Call Back funciton for list views
int CALLBACK ListViewSort(	LPARAM lParam1,
							LPARAM lParam2,
							LPARAM lParamSort);


// Retrieves the HWND for a list view column header
//HWND GetListViewColumnHeader(HWND hWndLV, DWORD dwPos);


// Paints bmps onto list view column headers
void SetColumnHeaderBmp(	HWND hWndLV,
							SORT_INFO SortInfo);

// Returns TRUE if the current viewed container is the PAB
BOOL CurrentContainerIsPAB(HWND hWndCombo);

// Cleans up the list view and releases the contents list
void ClearListView(	HWND hWndLV,
					LPRECIPIENT_INFO * lppContentsList);


// Deletes the selected items from a list view control and the property store
void DeleteSelectedItems(	HWND hWndLV,
                            LPADRBOOK lpIAB,
							HANDLE hPropertyStore,
                           LPFILETIME lpftLast);


// Calls properties on a list view item
HRESULT HrShowLVEntryProperties(	HWND hWndLV,
                                    ULONG ulFlags,
									LPADRBOOK lpIAB,
                                   LPFILETIME lpftLast);


// Exports list view items to vCard files
HRESULT VCardExportSelectedItems(HWND hWndLV,
                                 LPADRBOOK lpIAB);


// Imports vCard file to property store
HRESULT VCardImport(HWND hWnd, LPADRBOOK lpIAB, LPTSTR szVCardFile, LPSPropValue * lppProp);


// Selects the specified list view item
void LVSelectItem(	HWND hWndList,
					int iItemIndex);


//	Given an entryid, reads a single item from the store and creates a list view item
BOOL ReadSingleContentItem( LPADRBOOK lpIAB,
                            ULONG  cbEntryID,
							LPENTRYID lpEntryID,
							LPRECIPIENT_INFO * lppItem);


// Converts an lpPropArray into a LPRECIPIENT_INFO item
void GetRecipItemFromPropArray(	ULONG ulcPropCount,
								LPSPropValue rgPropVals,
								LPRECIPIENT_INFO * lppItem);


// Inserts a single RecipientInfo item into a list view
void AddSingleItemToListView(	HWND hWndLV,
								LPRECIPIENT_INFO lpItem);


// Higher level function that takes a WAB entryid and puts it in the list view
// Calls most of the above functions (this function assumes caller has checked that
// the entryid is a valid wab entryid
BOOL AddWABEntryToListView(	LPADRBOOK lpIAB,
                            HWND hWndLV,
                            ULONG cbEID,
							LPENTRYID lpEID,
                            LPRECIPIENT_INFO * lppContentsList);


// Called by the NewContact menu items or buttons
HRESULT AddNewObjectToListViewEx(	LPADRBOOK lpIAB,
								HWND hWndLV,
                                HWND hWndTV,
                                HTREEITEM hSelItem,
                                LPSBinary lpsbContEID,
                                ULONG ulObjectType,
								SORT_INFO * lpSortInfo,
                                LPRECIPIENT_INFO * lppContentsList,
                                LPFILETIME lpftLast,
                                LPULONG lpcbEID,
                                LPENTRYID * lppEID);

HRESULT AddEntryToContainer(LPADRBOOK lpIAB,
                        ULONG ulObjType, //MAPI_DISTLIST or MAPI_ABCONT
                        ULONG cbGroupEntryID,
                        LPENTRYID lpGroupEntryID,
                        DWORD cbEID,
                        LPENTRYID lpEID);

// Customizes and displays the context menu for various list views in the UI
int ShowLVContextMenu(int LV, // idicates which list view this is
					   HWND hWndLV,
                       HWND hWndCombo,
					   LPARAM lParam,  // contains the mouse pos info when called from WM_CONTEXTMENU
                       LPVOID lpVoid,  //misc stuff we want to pass in
                       LPADRBOOK lpIAB, HWND hWndTV);

// Gets the child's coordinates in client units
void GetChildClientRect(    HWND hWndChild,
                            LPRECT lprc);


// Finds the item in the LV matching the text in the EditBox
void DoLVQuickFind(HWND hWndEdit, HWND hWndLV);


// Does string searching of one within the other
BOOL SubstringSearch(LPTSTR pszTarget, LPTSTR pszSearch);



// Gets the props from a object
HRESULT HrGetPropArray( LPADRBOOK lpIAB,
                        LPSPropTagArray lpPTA,
                        ULONG cbEntryID,
                        LPENTRYID lpEntryID,
                        ULONG ulFlags,
                        ULONG * lpcValues,
                        LPSPropValue * lppPropArray);



// Calls CreateEntry for a new mailuser/distlist ...
HRESULT HrCreateNewEntry(   LPADRBOOK   lpIAB,          //AdrBook Object
                            HWND        hWndParent,     //Hwnd for dialog
                            ULONG       ulCreateObjectType,   //MAILUSER or DISTLIST
                            ULONG       cbEIDContainer,
                            LPENTRYID   lpEIDContainer,
                            ULONG       ulContObjectType,
                            ULONG       ulFlags,
                            BOOL        bShowBeforeAdding,
                            ULONG       cValues,
                            LPSPropValue lpPropArray,
                            ULONG       *lpcbEntryID,
                            LPENTRYID   *lppEntryID );


HRESULT HrGetWABTemplateID( LPADRBOOK lpIAB,
                            ULONG   ulObjectType,
                            ULONG * lpcbEID,
                            LPENTRYID * lppEID);


BOOL CheckForCycle( LPADRBOOK lpAdrBook,
                    LPENTRYID lpEIDChild,
                    ULONG cbEIDChild,
                    LPENTRYID lpEIDParent,
                    ULONG cbEIDParent); //from distlist.c


// Used for sorting columns in various list views ...
void SortListViewColumn(    LPIAB lpIAB,
                            HWND hWndLV,                //ListView Handle
                            int iSortCol,               //Column to sort by
                            LPSORT_INFO lpSortInfo,
                            BOOL bUseCurrentSettings);    // Sort Info structre specific for each dialog



// Used for storing sort info for persistence between sessions.
BOOL ReadRegistrySortInfo(LPIAB lpIAB, LPSORT_INFO lpSortInfo);
BOOL WriteRegistrySortInfo(LPIAB lpIAB, SORT_INFO SortInfo);

// Constructs a localized display name from individual pieces
BOOL SetLocalizedDisplayName(
                    LPTSTR lpszFirstName,
                    LPTSTR lpszMiddleName,
                    LPTSTR lpszLastName,
                    LPTSTR lpszCompanyName,
                    LPTSTR lpszNickName,
                    LPTSTR * lppszBuf,
                    ULONG  ulszBuf,
                    BOOL   bDNbyLN,
                    LPTSTR lpTemplate,
                    LPTSTR * lppszRetBuf);


// Callback for setting all the children windows to default GUI font ..
#define PARENT_IS_DIALOG 0 // We treat dialog children differently from window children
#define PARENT_IS_WINDOW 1 // so need these LPARAM values to differentiate..
STDAPI_(BOOL) SetChildDefaultGUIFont(HWND hWndChild, LPARAM lParam);


// Used for populating the Combo box with LDAP server names ...
HRESULT PopulateContainerList(  LPADRBOOK lpIAB,
                                HWND hWndLV,
                                LPTSTR lpszSelection,
                                LPTSTR lptszPreferredSelection);


// Used for freeing the associated structure in each container List Views
void FreeLVItemParam(HWND hWndLV);


// Gets the EntryID of the current container ...
void GetCurrentContainerEID(HWND hWndLV,
                            LPULONG lpcbContEID,
                            LPENTRYID * lppContEID);


// Shows the LDAP search dialog and creates a restriction
HRESULT HrShowSearchDialog(LPADRBOOK lpIAB,
                           HWND hWndParent,
                           LPADRPARM_FINDINFO lpAPFI,
                           LPLDAPURL lplu,
                           LPSORT_INFO lpSortInfo);


// Gets contents from an LDAP search and container
HRESULT HrSearchAndGetLDAPContents(
                            LDAP_SEARCH_PARAMS LDAPsp,
                            LPTSTR lpAdvFilter,
                            HWND hWndList,
                            LPADRBOOK lpIAB,
                            SORT_INFO SortInfo,
                            LPRECIPIENT_INFO * lppContentsList);

// Gets contents from a WAB local store container
HRESULT HrGetWABContents(   HWND  hWndList,
                            LPADRBOOK lpIAB,
                            LPSBinary lpsbContainer,
                            SORT_INFO SortInfo,
                            LPRECIPIENT_INFO * lppContentsList);


// Shows UI to modify current list of servers
HRESULT HrShowDirectoryServiceModificationDlg(HWND hWndParent, LPIAB lpIAB);

// Creates a new blank mailuser object
HRESULT HrCreateNewObject(LPADRBOOK lpIAB,
                        LPSBinary lpsbContainer,
                        ULONG ulObjectType,
                        ULONG ulFlags,
                        LPMAPIPROP * lppPropObj);

// Generic message box displayer ...
int ShowMessageBox(HWND hWndParent, int MsgId, int ulFlags);
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...);


// atoi converter
int my_atoi(LPTSTR lpsz);

// Reads the default registry LDAP country name
BOOL ReadRegistryLDAPDefaultCountry(LPTSTR szCountry, DWORD cchCountry, LPTSTR szCountryCode, DWORD cchCountryCode);

#ifdef OLD_STUFF
// Fills a drop down list with the LDAP country names
void FillComboLDAPCountryNames(HWND hWndCombo);
// Writes the defaule country name to the registry
BOOL WriteRegistryLDAPDefaultCountry(LPTSTR szCountry);
#endif //OLD_STUFF

// Looks at Combo and ListView and determines which options to enable or disable
void GetCurrentOptionsState(HWND hWndCombo,
                            HWND hWndLV,
                            LPBOOL lpbState);

// Adds selected LDAP items to the Address Book
HRESULT HrAddToWAB( LPADRBOOK   lpIAB,
                    HWND hWndLV,
                    LPFILETIME lpftLast);


// Coolbar creating function ...
HWND CreateCoolBar(LPBWI lpbwi, HWND hwndParent);


// Directory Services Proeprties property sheet
HRESULT HrShowDSProps(HWND hWndParent,LPTSTR ptszAcct, LPTSTR *pptszName, BOOL bAddNew);


// Saves the modeless dialog size and position to registry for persistence
BOOL WriteRegistryPositionInfo(LPIAB lpIAB, LPABOOK_POSCOLSIZE  lpABPosColSize, LPTSTR szKey);


// Retrieves the modeless dialog size and position to registry for persistence
BOOL ReadRegistryPositionInfo(LPIAB lpIAB, LPABOOK_POSCOLSIZE  lpABPosColSize, LPTSTR szKey);


// Processes the nmcustomdraw message from the list view
LRESULT ProcessLVCustomDraw(HWND hWnd, LPARAM lParam, BOOL bIsDialog);


// Quick Filter for list view
void DoLVQuickFilter(   LPADRBOOK lpIAB,
                        HWND hWndEdit,
                        HWND hWndLV,
                        LPSORT_INFO lpSortInfo,
                        ULONG ulFlags,
                        int nMinLen,
                        LPRECIPIENT_INFO * lppContentsList);

// Sets the objects name in the properties window title
void SetWindowPropertiesTitle(HWND hDlg, LPTSTR lpszName);

void SCS(HWND hwndParent);


// Copies an items (partial) contents into the clipboard
HRESULT HrCopyItemDataToClipboard(HWND hWnd, LPADRBOOK lpIAB, HWND hWndLV);


// Gets the items data and puts it all into 1 long string
HRESULT HrGetLVItemDataString(LPADRBOOK lpIAB, HWND hWndLV, int iItemIndex, LPTSTR * lppszData);

LPTSTR FormatAllocFilter(int StringID1, LPCTSTR lpFilter1,
  int StringID2, LPCTSTR lpFilter2,
  int StringID3, LPCTSTR lpFilter3);


// Shellexecutes a "mailto" to selected entry ...
HRESULT HrSendMailToSelectedContacts(HWND hWndLV, LPADRBOOK lpIAB, int nExtEmail);


// Show certificate properties
//HRESULT HrShowCertProps(HWND   hWndParent,
//                        LPCERT_DISPLAY_PROPS lpCDP);

// Shows the Help About dialog box
INT_PTR CALLBACK HelpAboutDialogProc(  HWND hDlg,
                                       UINT    message,
                                       WPARAM  wParam,
                                       LPARAM  lParam);


// Helps truncate DBCS strings correctly
ULONG TruncatePos(LPTSTR lpsz, ULONG nMaxLen);

// Local WAB search
HRESULT HrDoLocalWABSearch( IN  HANDLE hPropertyStore,
                            IN  LPSBinary lpsbCont,
                            IN  LDAP_SEARCH_PARAMS LDAPsp,
                            OUT LPULONG lpulFoundCount,
                            OUT LPSBinary * lprgsbEntryIDs );


// Adds a non-wab entry to the wab
HRESULT HrEntryAddToWAB(    LPADRBOOK lpIAB,
                            HWND hWndParent,
                            ULONG cbInputEID,
                            LPENTRYID lpInputEID,
                            ULONG * lpcbOutputEID,
                            LPENTRYID * lppOutputEID);


//  Deciphers a vCard File and then shows one off details on it
HRESULT HrShowOneOffDetailsOnVCard(  LPADRBOOK lpIAB,
                                     HWND hWnd,
                                     LPTSTR szvCardFile);

// Checks if the current locale needs Ruby Support
BOOL bIsRubyLocale();

void FreeRecipList(LPRECIPIENT_INFO * lppList);

void SetSBinary(LPSBinary lpsb, ULONG cb, LPBYTE lpb);


HRESULT HrProcessLDAPUrl(LPADRBOOK lpIAB,   HWND hWnd,
                         ULONG ulFlags,     LPTSTR szLDAPUrl,
                         LPMAILUSER * lppMailUser);

HRESULT VCardRetrieve(LPADRBOOK lpIAB,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPSTR lpszBuf,
                      LPMAILUSER * lppMailUser);

HRESULT VCardCreate(  LPADRBOOK lpIAB,
                      HWND hWndParent,
                      ULONG ulFlags,
                      LPTSTR lpszFileName,
                      LPMAILUSER lpMailUser);

//void ShellUtil_RunClientRegCommand(HWND hwnd, LPCTSTR pszClient);
HRESULT HrShellExecInternetCall(LPADRBOOK lpIAB, HWND hWndLV);


// Open a vCard and add it to the wab based on file name
HRESULT OpenAndAddVCard(LPBWI lpbwi, LPTSTR szVCardFile);


// removes illegal chars from potential file names
void TrimIllegalFileChars(LPTSTR sz);

// DistList prop sheets
//
INT_PTR CreateDLPropertySheet( HWND hwndOwner,
                           LPDL_INFO lpPropArrayInfo);


// Copies truncated version of Src to Dest
int CopyTruncate(LPTSTR szDest, LPTSTR szSrc, int nMaxLen);

// Adds an item's parent's eid to the item
HRESULT AddFolderParentEIDToItem(LPIAB lpIAB,
                                 ULONG cbFolderEntryID,
                                 LPENTRYID lpFolderEntryID,
                                 LPMAPIPROP lpMU, ULONG cbEID, LPENTRYID lpEID);

// Adds an item's eid to its parent
HRESULT AddItemEIDToFolderParent(  LPIAB lpIAB,
                                   ULONG cbFolderEntryId,
                                   LPENTRYID lpFolderEntryId,
                                   ULONG cbEID, LPENTRYID lpEID);

// Adds the specified entry to the specified WAB Profile Folder
HRESULT AddEntryToFolder(LPADRBOOK lpIAB,
                         LPMAPIPROP lpMailUser,
                        ULONG cbFolderEntryId,
                        LPENTRYID lpFolderEntryId,
                        DWORD cbEID,
                        LPENTRYID lpEID);

// imports another WAB file
HRESULT HrImportWABFile(HWND hWnd, LPADRBOOK lpIAB, ULONG ulFlags, LPTSTR lpszFileName);

LPRECIPIENT_INFO GetItemFromLV(HWND hWndLV, int iItem);

// determines what the UI icon for the entry should be..
int GetWABIconImage(LPRECIPIENT_INFO lpItem);

// 
// Functions related to using Outlook store
BOOL SetRegistryUseOutlook(BOOL bUseOutlook);
BOOL bUseOutlookStore();
BOOL bCheckForOutlookWABDll(LPTSTR lpszDllPath, DWORD cchDllPath);


// Functions used in managing rt-click extensions
void FreeActionItemList(LPIAB lpIAB);
HRESULT HrUpdateActionItemList(LPIAB lpIAB);
LRESULT ProcessActionCommands(LPIAB lpIAB, HWND  hWndLV, 
                              HWND  hWnd, UINT  uMsg, WPARAM  wParam, LPARAM lParam);
void AddExtendedMenuItems(LPADRBOOK lpIAB, HWND hWndLV, HMENU hMenuAction, BOOL bUpdateStatus, BOOL bAddSendMailItems);
void AddExtendedSendMailToItems(LPADRBOOK lpIAB, HWND hWndLV, HMENU hMenuAction, BOOL bAddItems);
void GetContextMenuExtCommandString(LPIAB lpIAB, int uCmd, LPTSTR sz, ULONG cbsz);


// Stuff to do with GetMe / SetMe
HRESULT HrGetMeObject(LPADRBOOK lpIAB, ULONG ulFlags, DWORD * lpdwAction, SBinary * lpsbEID, ULONG_PTR ulParam);
HRESULT HrSetMeObject(LPADRBOOK lpIAB, ULONG ulFlags, SBinary sbEID, ULONG_PTR ulParam);

// Stuff to do with the print and abort import dialog
void CreateShowAbortDialog(HWND hWndParent, int idsTitle, int idsIcon, int ProgMax, int ProgCurrent);
void CloseAbortDlg();
BOOL CALLBACK FAbortProc(HDC hdcPrn, INT nCode);
void SetPrintDialogMsg(int idsMsg, int idsFormat, LPTSTR lpszMsg);
INT_PTR CALLBACK FAbortDlgProc(HWND hwnd, UINT msg,WPARAM wp, LPARAM lp);
BOOL bTimeToAbort();

HRESULT HrSaveHotmailSyncInfoOnDeletion(LPADRBOOK lpAdrBook, LPSBinary lpEID);
HRESULT HrAssociateOneOffGroupMembersWithContacts(LPADRBOOK lpAdrBook, 
                                                  LPSBinary lpsbGroupEID,
                                                  LPDISTLIST lpDistList);

// Stuff used in adding extension property pages to the WAB Prop Sheets
//
typedef HRESULT (_ADDPROPPAGES_) (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, int * lpnPage);
typedef _ADDPROPPAGES_  FAR *LPFNADDPAGES;

BOOL CALLBACK AddPropSheetPageProc( HPROPSHEETPAGE hpage, LPARAM lParam );
void FreePropExtList(LPEXTDLLINFO lpList);
HRESULT GetExtDisplayInfo(LPIAB lpIAB, LPPROP_ARRAY_INFO lpPropArrayInfo, BOOL fReadOnly, BOOL bMailUser);
BOOL ChangedExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo, BOOL bChanged);
void FreeExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo);

#ifdef COLSEL_MENU 
BOOL ColSel_PropTagToString( ULONG ulPropTag, LPTSTR lpszString, ULONG cchSize);
#endif // COLSEL_MENU 

BOOL IsWindowOnScreen(LPRECT lprc); // determines if window is onscreen
BOOL IsHTTPMailEnabled(LPIAB lpIAB);

/*********************************************************************/

#ifdef WIN16 // Need WINAPI for 16 bits
typedef BOOL WINAPI (_INITCOMMONCONTROLSEX_)(LPINITCOMMONCONTROLSEX lpiccex);
typedef _INITCOMMONCONTROLSEX_ FAR *LP_INITCOMMONCONTROLSEX;

typedef HPROPSHEETPAGE WINAPI (_CREATEPROPERTYSHEETPAGE_)(PROPSHEETPAGE * lppsp); 
typedef _CREATEPROPERTYSHEETPAGE_ FAR * LP_CREATEPROPERTYSHEETPAGE;
 
typedef BOOL WINAPI (_IMAGELIST_DRAW_)(HIMAGELIST himl, int i, HDC hdcDst,int x, int y, UINT fStyle);
typedef _IMAGELIST_DRAW_ FAR * LPIMAGELIST_DRAW;

typedef BOOL WINAPI (_IMAGELIST_DESTROY_)(HIMAGELIST himl);
typedef _IMAGELIST_DESTROY_ FAR * LPIMAGELIST_DESTROY;

typedef HIMAGELIST WINAPI (_IMAGELIST_LOADIMAGE_)(HINSTANCE hi, LPTSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
typedef _IMAGELIST_LOADIMAGE_ FAR *LPIMAGELIST_LOADIMAGE;

typedef COLORREF WINAPI (_IMAGELIST_SETBKCOLOR_)(HIMAGELIST himl, COLORREF clrBk);
typedef _IMAGELIST_SETBKCOLOR_ FAR *LPIMAGELIST_SETBKCOLOR;

typedef BOOL WINAPI (_TRACKMOUSEEVENT_)(LPTRACKMOUSEEVENT lpEventTrack);
typedef _TRACKMOUSEEVENT_ FAR *LP_TRACKMOUSEEVENT;

typedef int WINAPI (_PROPERTYSHEET_)(LPCPROPSHEETHEADER lppsph);
typedef _PROPERTYSHEET_ FAR *LPPROPERTYSHEET;
#else  // WIN16
typedef BOOL (_INITCOMMONCONTROLSEX_)(LPINITCOMMONCONTROLSEX lpiccex);
typedef _INITCOMMONCONTROLSEX_ FAR *LP_INITCOMMONCONTROLSEX;

/*
typedef HPROPSHEETPAGE (_CREATEPROPERTYSHEETPAGE_)(PROPSHEETPAGE * lppsp); 
typedef _CREATEPROPERTYSHEETPAGE_ FAR * LP_CREATEPROPERTYSHEETPAGE;
*/
typedef HPROPSHEETPAGE (_CREATEPROPERTYSHEETPAGE_A_)(LPCPROPSHEETPAGEA lppsp);
typedef HPROPSHEETPAGE (_CREATEPROPERTYSHEETPAGE_W_)(LPCPROPSHEETPAGEW lppsp);

typedef _CREATEPROPERTYSHEETPAGE_A_ FAR * LP_CREATEPROPERTYSHEETPAGE_A;
typedef _CREATEPROPERTYSHEETPAGE_W_ FAR * LP_CREATEPROPERTYSHEETPAGE_W;
 
typedef BOOL (_IMAGELIST_DRAW_)(HIMAGELIST himl, int i, HDC hdcDst,int x, int y, UINT fStyle);
typedef _IMAGELIST_DRAW_ FAR * LPIMAGELIST_DRAW;

typedef BOOL (_IMAGELIST_DESTROY_)(HIMAGELIST himl);
typedef _IMAGELIST_DESTROY_ FAR * LPIMAGELIST_DESTROY;

/*
typedef HIMAGELIST (_IMAGELIST_LOADIMAGE_)(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
typedef _IMAGELIST_LOADIMAGE_ FAR *LPIMAGELIST_LOADIMAGE;
*/

typedef HIMAGELIST (_IMAGELIST_LOADIMAGE_A_)(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
typedef HIMAGELIST (_IMAGELIST_LOADIMAGE_W_)(HINSTANCE hi, LPCWSTR lpbmp,int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

typedef _IMAGELIST_LOADIMAGE_A_ FAR *LPIMAGELIST_LOADIMAGE_A;
typedef _IMAGELIST_LOADIMAGE_W_ FAR *LPIMAGELIST_LOADIMAGE_W;

typedef COLORREF (_IMAGELIST_SETBKCOLOR_)(HIMAGELIST himl, COLORREF clrBk);
typedef _IMAGELIST_SETBKCOLOR_ FAR *LPIMAGELIST_SETBKCOLOR;

typedef BOOL (_TRACKMOUSEEVENT_)(LPTRACKMOUSEEVENT lpEventTrack);
typedef _TRACKMOUSEEVENT_ FAR *LP_TRACKMOUSEEVENT;

/*
typedef int (_PROPERTYSHEET_)(LPCPROPSHEETHEADER lppsph);
typedef _PROPERTYSHEET_ FAR *LPPROPERTYSHEET;
*/
typedef INT_PTR (_PROPERTYSHEET_A_)(LPCPROPSHEETHEADERA lppsphA); 
typedef INT_PTR (_PROPERTYSHEET_W_)(LPCPROPSHEETHEADERW lppsphW);

typedef _PROPERTYSHEET_A_ FAR *LPPROPERTYSHEET_A;
typedef _PROPERTYSHEET_W_ FAR *LPPROPERTYSHEET_W;
#endif

BOOL InitCommonControlLib(void);
ULONG DeinitCommCtrlClientLib(void);
BOOL __fastcall IsSpace(LPTSTR lpChar);
/*********************************************************************/

// The following messages are used for shutting down the WAB when the user changes to modify the locale
// so that the new set of WAB resources can be brought in ..
// These are used in conjunction with MLLoadLibrary 
#define PUI_OFFICE_COMMAND      (WM_USER + 0x0901)
#define PLUGUI_CMD_SHUTDOWN		0 // wParam value
#define PLUGUI_CMD_QUERY		1 // wParam value
#define OFFICE_VERSION_9		9 // standardized value to return for Office 9 apps

typedef struct _PLUGUI_INFO
{
	unsigned uMajorVersion : 8;	// Used to indicate App;s major version number
	unsigned uOleServer : 1;		// BOOL, TRUE if this is an OLE process
	unsigned uUnused : 23;		// not used
} PLUGUI_INFO;

typedef union _PLUGUI_QUERY
{
	UINT uQueryVal;
	PLUGUI_INFO PlugUIInfo;
} PLUGUI_QUERY;
// End of Pluggable UI section

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_cflct.h ===
// ui_cflct.h
//
// definitions for WAB synchronization conflict resolution dialog
//
#include "imnxport.h"
#include "imnact.h"

#ifndef __UI_CFLCT_H__
#define __UI_CFLCT_H__

#ifdef __cplusplus
extern "C"{
#endif 

typedef enum {
    CONFLICT_IGNORE = 0,
    CONFLICT_SERVER,
    CONFLICT_CLIENT
}CONFLICT_DECISION;

#define CONFLICT_DECISION_COUNT 28

typedef struct HTTPCONFLICTINFO
{
    BOOL                    fContainsSkip;
    LPHTTPCONTACTINFO       pciServer;
    LPHTTPCONTACTINFO       pciClient;
    CONFLICT_DECISION       rgcd[CONFLICT_DECISION_COUNT];
}HTTPCONFLICTINFO, *LPHTTPCONFLICTINFO;


BOOL    ResolveConflicts(HWND hwnd, LPHTTPCONFLICTINFO prgConflicts, DWORD cConflicts);
BOOL    ChooseHotmailServer(HWND hwnd, IImnEnumAccounts *pEnumAccts, LPSTR pszAccountName, DWORD cchAccountName);

#ifdef __cplusplus
}
#endif 


#endif //__UI_CFLCT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_addr.h ===
#ifndef _UI_ADDRS_H_
#define _UI_ADDRS_H_

HRESULT HrShowAddressUI(IN  LPADRBOOK   lpIAB,
                        IN  HANDLE      hPropertyStore,
					    IN  ULONG_PTR * lpulUIParam,
					    IN  LPADRPARM   lpAdrParms,
					    IN  LPADRLIST  *lppAdrList);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_abort.c ===
/*
-
-   AbortDlgProc stuff
*
*/
#include "_apipch.h"

typedef struct _AbortInfo
{
    int idsTitle;
    int nProgMax;
    int nProgCurrent;
    int nIconID;
} ABORT_INFO, * LPABORT_INFO;

/*
-
-   CreateShowAbortDialog
*
*/
void CreateShowAbortDialog(HWND hWndParent, int idsTitle, int idIcon, int ProgMax, int ProgCurrent)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPABORT_INFO lpAI = NULL;

    pt_bPrintUserAbort = FALSE;

    lpAI = LocalAlloc(LMEM_ZEROINIT, sizeof(ABORT_INFO));
    if(!lpAI)
        return;

    lpAI->idsTitle = idsTitle;
    lpAI->nProgMax = ProgMax;
    lpAI->nProgCurrent = ProgCurrent;
    lpAI->nIconID = idIcon;

    // Create and Show the Print Cancel dialog
    pt_hWndPrintAbortDlg = CreateDialogParam(  hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_PRINTCANCEL), hWndParent, 
                                            FAbortDlgProc, (LPARAM) lpAI);

    ShowWindow(pt_hWndPrintAbortDlg, SW_SHOWNORMAL);

    UpdateWindow(pt_hWndPrintAbortDlg);
}

/*
-
-   CloseAbortDlg
*
*/
void CloseAbortDlg()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    if (pt_hWndPrintAbortDlg)
    {
        LPABORT_INFO lpAI = (LPABORT_INFO) GetWindowLongPtr(pt_hWndPrintAbortDlg, DWLP_USER);
        if(lpAI)
        {
            SendDlgItemMessage(pt_hWndPrintAbortDlg, IDC_PROGRESS, PBM_SETPOS, (WPARAM) lpAI->nProgMax+1, 0);
            SetWindowLongPtr(pt_hWndPrintAbortDlg, DWLP_USER, 0);
            LocalFree(lpAI);
        }
        DestroyWindow(pt_hWndPrintAbortDlg);
        pt_hWndPrintAbortDlg=NULL;
    }
}

/*
 *        FAbortProc
 *
 *        Purpose:
 *            This function loops for messages and sends them off to the
 *            Printing Abort dialog box as needed. This gives other Windows
 *            programs a chance to run as well as the user the opportunity to
 *            abort the printing.
 *
 *        Returns:
 *            FALSE if the user aborted the printing
 */
BOOL CALLBACK FAbortProc(HDC hdcPrn, INT nCode)
{
    MSG    msg;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    while (!pt_bPrintUserAbort && PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (    !pt_hWndPrintAbortDlg ||
                !IsDialogMessage(pt_hWndPrintAbortDlg, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return !pt_bPrintUserAbort;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
//  SetPrintDialogMsg - Sets the status message on the print cancel dialog
//
//  idMsg - string resource identifier of the message to print
//  lpszMsg - if idMsg is 0, we look to this for string text
//
////////////////////////////////////////////////////////////////////////////////////////////
void SetPrintDialogMsg(int idsMsg, int idsFormat, LPTSTR lpszMsg)
{
    TCHAR szBuf[MAX_UI_STR];
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPTSTR lpMsg = NULL;

    szBuf[0]='\0';
    if(idsMsg)
        LoadString(hinstMapiX, idsMsg, szBuf, CharSizeOf(szBuf));
    else if(idsFormat)
    {
        TCHAR szName[MAX_DISPLAY_NAME_LENGTH];
        LPTSTR lpName = NULL;

        LoadString(hinstMapiX, idsFormat, szBuf, CharSizeOf(szBuf));

        // Truncate the name if it is greater than 32 characters ...
        CopyTruncate(szName, lpszMsg, MAX_DISPLAY_NAME_LENGTH);
        lpName = szName;

        FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szBuf, 0, 0,
                      (LPTSTR)&lpMsg,     // output buffer
                      0, (va_list *)&lpName);
        if(lpMsg)
            StrCpyN(szBuf, lpMsg, ARRAYSIZE(szBuf));
    }
    else if(lpszMsg)
        StrCpyN(szBuf, lpszMsg, ARRAYSIZE(szBuf));
    
    if(lstrlen(szBuf))
        SetDlgItemText(pt_hWndPrintAbortDlg, IDC_PRINTCANCEL_STATIC_STATUS, szBuf);

    UpdateWindow(pt_hWndPrintAbortDlg);
    UpdateWindow(GetDlgItem(pt_hWndPrintAbortDlg, IDC_PRINTCANCEL_STATIC_STATUS));

    {
        int uPos = (int) SendDlgItemMessage(pt_hWndPrintAbortDlg, IDC_PROGRESS, PBM_GETPOS, 0, 0);
        LPABORT_INFO lpAI = (LPABORT_INFO) GetWindowLongPtr(pt_hWndPrintAbortDlg, DWLP_USER);
        if(lpAI && uPos < lpAI->nProgMax)
            SendDlgItemMessage(pt_hWndPrintAbortDlg, IDC_PROGRESS, PBM_STEPIT, 0, 0);
    }

    if(lpMsg)
    {
        IF_WIN32(LocalFreeAndNull(&lpMsg);)
        IF_WIN16(FormatMessageFreeMem(lpMsg);)
    }

    return;
}



/*
 *        FAbortDlgProc
 *
 *        Purpose:
 *            This function handles the messages for the Printing Abort dialog.
 *            Should an abort be initiated, fUserAbort is set to TRUE
 *
 *        Arguments:
 *            hwnd            handle of dialog window
 *            message            the message
 *            wParam            the wParam
 *            lParam            the lParam
 *
 *        Returns:
 *            To the DefDialogProc(), TRUE for messages handled, FALSE for those
 *            not handled, or only noted.
 */
INT_PTR CALLBACK FAbortDlgProc(HWND hwnd, UINT msg,WPARAM wp, LPARAM lp)
{
    if(msg==WM_INITDIALOG)
    {
        LPABORT_INFO lpAI = (LPABORT_INFO) lp;
        if(lpAI)
        {
            TCHAR sz[MAX_PATH];
            HWND hWndProgress = GetDlgItem(hwnd, IDC_PROGRESS);
            SetWindowLongPtr(hwnd, DWLP_USER, lp);
            if(lpAI->idsTitle)
            {
                LoadString(hinstMapiX, lpAI->idsTitle, sz, CharSizeOf(sz));
                SetWindowText(hwnd, sz);
            }
            if(lpAI->nIconID)
            {
                HICON hIcon = LoadIcon(hinstMapiX,MAKEINTRESOURCE(lpAI->nIconID));
                SendDlgItemMessage(hwnd, IDC_STATIC_PROGRESS_ICON, STM_SETICON, (WPARAM) (HANDLE)hIcon, 0);
                UpdateWindow(GetDlgItem(hwnd, IDC_STATIC_PROGRESS_ICON));
            }
            SendMessage(hWndProgress, PBM_SETRANGE, 0, MAKELPARAM(0, lpAI->nProgMax+1));
            SendMessage(hWndProgress, PBM_SETSTEP, (WPARAM) 1, 0);
            SendMessage(hWndProgress, PBM_SETPOS, (WPARAM) lpAI->nProgCurrent, 0);
        }
        EnableMenuItem(GetSystemMenu(hwnd, FALSE), SC_CLOSE, MF_GRAYED);
        //CenterDialog(hwnd);

        return TRUE;
    }
    else if(msg==WM_COMMAND)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        LPABORT_INFO lpAI = (LPABORT_INFO) GetWindowLongPtr(hwnd, DWLP_USER);
        if(lpAI)
        {
            SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_SETPOS, (WPARAM) lpAI->nProgMax+1, 0);
            LocalFree(lpAI);
            SetWindowLongPtr(hwnd, DWLP_USER, 0);
        }
        pt_bPrintUserAbort = TRUE;
        return TRUE;
    }

    return FALSE;
}

/*
-
-   bTimeToAbort
*
*/
BOOL bTimeToAbort()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    return ( pt_bPrintUserAbort || !FAbortProc(NULL, 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_abook.c ===
////////////////////////////////////////////////////////////////////////////////////////
//
//
//  UI_ABOOK.C - contains code for the Browse mode Overlapped Window address book view
//
//  Developers: VikramM     5/96
//
////////////////////////////////////////////////////////////////////////////////////////
#include "_apipch.h"
#include "hotsync.h"
#include "htmlhelp.h"
#include <mirror.h>

extern HINSTANCE ghCommCtrlDLLInst;

extern const LPTSTR  lpszRegPositionKeyValueName;

extern BOOL bIsPasteData();
extern HRESULT HrPasteData(LPBWI lpbwi);
extern void AddFolderListToMenu(HMENU hMenu, LPIAB lpIAB);

const static LPTSTR szWABMigRegPathKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wabmig.exe");
const static LPTSTR szWABExeRegPathKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe");
const LPTSTR szWABMIG = TEXT("wabmig.exe");
const LPTSTR szWABExe = TEXT("wab.exe");
const TCHAR szEXPORT[] = TEXT("/export");
const TCHAR szIMPORT[] = TEXT("/import");
const TCHAR szEXPORTwProfileParam[]=TEXT("/export+/pid:%s+/file:%s");
const TCHAR szIMPORTwProfileParam[]=TEXT("/import+/pid:%s+/file:%s");

// This struct helps in identifying contact folders and groups and in navigating
// around them
//
void FillTreeView(LPBWI lpbwi, HWND hWndTV, LPSBinary lpsbSelection);
void UpdateTVGroupSelection(HWND hWndTV, LPSBinary lpsbSelectEID);
void GetCurrentSelectionEID(LPBWI lpbwi, HWND hWndTV, LPSBinary * lppsbEID, ULONG * lpulObjectType, BOOL bTopMost);
void ClearTreeViewItems(HWND hWndTV);
void UpdateLV(LPBWI lpbwi);
void UpdateListViewContents(LPBWI lpbwi, LPSBinary lpsbEID, ULONG ulObjectType);
void ViewCurrentGroupProperties(LPBWI lpbwi, LPFILETIME lpftLast);
BOOL bIsFocusOnTV(LPBWI lpbwi);
BOOL bIsSelectedTVContainer(LPBWI lpbwi);
BOOL SplitterHitTest(HWND hWndT, LPARAM lParam);
void DragSplitterBar(LPBWI lpbwi, HWND hwnd, HWND hWndT, LPARAM lParam);
HRESULT FillListFromGroup(LPADRBOOK lpIAB, ULONG cbGroupEntryID,  LPENTRYID lpGroupEntryID, LPTSTR lpszName, ULONG cchName, LPRECIPIENT_INFO * lppList);

extern LPIMAGELIST_DESTROY          gpfnImageList_Destroy;

// extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW;

extern ULONG GetToolbarButtonWidth();

void RemoveCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast);
HRESULT RemoveCurrentFolder(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast);
void RemoveSelectedItemsFromCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast, BOOL bRemoveFromWAB);
void RemoveSelectedItemsFromListView(HWND hWndLV, LPRECIPIENT_INFO *lppList);
LRESULT ProcessTreeViewMessages(LPBWI lpbwi, HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam, LPFILETIME lpftLast);
#ifdef COLSEL_MENU
BOOL UpdateOptionalColumns( LPBWI lpbwi, ULONG iColumn );
#endif // COLSEL_MENU
// Initial Window Size
#define INIT_WINDOW_W  500
#define INIT_WINDOW_H  375

// Minimum Window Size - presently constrained
#define MIN_WINDOW_W	300
#define MIN_WINDOW_H	200

BOOL fOleInit = FALSE;

//
// Some IDs for the Button Bar
//

// Address Book Window Class Name
LPTSTR g_szClass =  TEXT("WABBrowseView");


// Function ProtoTypes

LRESULT CALLBACK AddressBookWndProc(HWND   hWnd,UINT   uMsg,WPARAM   wParam,LPARAM lParam);
void CreateAddressBookChildren(LPBWI lpbwi, HWND hWnd);
void ResizeAddressBookChildren(LPBWI lpbwi, HWND hWndParent);
HWND CreateListViewAddrBook (HWND hWndParent);
void InitChildren(LPBWI lpbwi, HWND hWnd);
void SetListViewStyle(LPBWI lpbwi, int MenuID);
void CleanUpGlobals(LPBWI lpbwi);
HRESULT HrFolderProperties(HWND hWndParent, LPIAB lpIAB, LPSBinary lpsbEID, LPWABFOLDER lpParentFolder, LPSBinary lpsbNew);

//void TabToNextItem();

LRESULT ProcessListViewMessages(LPBWI lpbwi, HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam);

LRESULT EnforceMinSize(LPBWI lpbwi, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

LRESULT CALLBACK SubClassedProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

void RefreshListView(LPBWI lpbwi, LPFILETIME lpftLast);

STDAPI_(BOOL) FindABWindowProc( HWND hWndToLookAt, LPARAM lParam);

void UpdateSortMenus(LPBWI lpbwi, HWND hWnd);

void UpdateToolbarAndMenu(LPBWI lpbwi);

void UpdatePrintMenu(HWND hWnd);
void UpdateOutlookMenus(HWND hWnd);
void UpdateCustomColumnMenuText(HWND hWnd);
void UpdateViewFoldersMenu(LPBWI lpbwi, HWND hWnd);
void UpdateSwitchUsersMenu(HWND hWnd, LPIAB lpIAB);

//LPFNABSDI lpfnAccelerateMessages;
BOOL STDMETHODCALLTYPE fnAccelerateMessages(ULONG_PTR ulUIParam, LPVOID lpvmsg);

void SetPreviousSessionPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB);

void SaveCurrentPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB);

void Handle_WM_MENSELECT (LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam );
void Handle_WM_INITMENUPOPUP(HWND hWnd, LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam );

void UpdateTooltipTextBuffer(LPBWI lpbwi, int nItem);
void InitMultiLineToolTip(LPBWI lpbwi, HWND hWndParent);
void FillTooltipInfo(LPBWI lpbwi, LPTOOLINFO lpti);
int HitTestLVSelectedItem(LPBWI lpbwi);
BOOL bCheckIfOnlyGroupsSelected(HWND hWndLV);

void DestroyImageLists(LPBWI lpbwi);

#define WAB_TOOLTIP_TIMER_ID   888
#define WAB_TOOLTIP_TIMER_TIMEOUT   750 // milliseconds


HRESULT HrExportWAB(HWND hWnd, LPBWI lpbwi);
void HrShowOptionsDlg(HWND hWndParent);

//$$ extern void UIOLEUninit();
void UIOLEUninit()
{
    if(fOleInit)
    {
        OleUninitialize();
        fOleInit = FALSE;
    }
}

void UIOLEInit()
{
    if(!fOleInit)
    {
        OleInitialize(NULL);
        fOleInit = TRUE;
    }
}

//$$
//
// LocalFreeSBinary - frees a locally alloced SBinary struct
//
//
void LocalFreeSBinary(LPSBinary lpsb)
{
    if(lpsb)
    {
        if(lpsb->lpb)
            LocalFree(lpsb->lpb);
        LocalFree(lpsb);
    }
}

//$$
/*----------------------------------------------------------------------*/
//
// RunWABApp - runs the import-export tool based on the registered path
//       if regesitered path is not found, shell execs ...
//
/*----------------------------------------------------------------------*/
void RunWABApp(HWND hWnd, LPTSTR szKey, LPTSTR szExeName, LPTSTR szParam)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szPathExpand[MAX_PATH];
    DWORD  dwType = 0;
    ULONG  cbData = CharSizeOf(szPath);
    HKEY hKey = NULL;
    LONG lRes = 0;

    *szPath = '\0';
    *szPathExpand = '\0';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey))
        lRes = RegQueryValueEx( hKey,  TEXT(""), NULL, &dwType, (LPBYTE) szPath, &cbData);

    if (REG_EXPAND_SZ == dwType) 
    {
        ExpandEnvironmentStrings(szPath, szPathExpand, CharSizeOf(szPathExpand));
        StrCpyN(szPath, szPathExpand, ARRAYSIZE(szPath));
    }

    if(hKey) RegCloseKey(hKey);

    if(!lstrlen(szPath))
        StrCpyN(szPath, szExeName, ARRAYSIZE(szPath));

    ShellExecute(hWnd,  TEXT("open"), szPath, szParam, NULL, SW_SHOWNORMAL);
}

//$$
/*----------------------------------------------------------------------*/
//
// StatusBarMessage - puts a message in the status bar
//
/*----------------------------------------------------------------------*/
void StatusBarMessage(LPBWI lpbwi, LPTSTR lpsz)
{
    SetWindowText(bwi_hWndSB, lpsz);
    UpdateWindow(bwi_hWndSB);
    return;
}

//$$
/*----------------------------------------------------------------------*/
//
// ShowLVCountinStatusBar - puts a message in the status bar
//
/*----------------------------------------------------------------------*/
void ShowLVCountinStatusBar(LPBWI lpbwi)
{
    TCHAR sz[MAX_UI_STR];
    TCHAR szString[MAX_UI_STR];
    LoadString(hinstMapiX, idsStatusBarCount, szString, ARRAYSIZE(szString));
    wnsprintf(sz, ARRAYSIZE(sz), szString, ListView_GetItemCount(bwi_hWndListAB));
    StatusBarMessage(lpbwi, sz);
    return;
}

//$$*------------------------------------------------------------------------
//| IAddrBook::Advise::OnNotify handler
//|
//*------------------------------------------------------------------------
ULONG AdviseOnNotify(LPVOID lpvContext, ULONG cNotif, LPNOTIFICATION lpNotif)
{
    LPBWI lpbwi = (LPBWI) lpvContext;

    DebugTrace( TEXT("=== AdviseOnNotify ===\n"));
    if(bwi_bDeferNotification)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        if(!pt_bIsWABOpenExSession)
        {
            DebugTrace( TEXT("=== Advise Defered ===\n"));
            bwi_bDeferNotification = FALSE;
            return S_OK;
        }
    }
    if(!bwi_bDontRefreshLV)
    {
        DebugTrace( TEXT("=== Calling RefreshListView ===\n"));
        HrGetWABProfiles(bwi_lpIAB);
        RefreshListView(lpbwi, NULL);
    }

    return S_OK;
}

/*
-
-   GetSelectedUserFolder - returns a pointer to the selected User Folder if any
*       If the selection is on a sub-folder, gets the parent User folder for that folder
*
*/
LPWABFOLDER GetSelectedUserFolder(LPBWI lpbwi)
{
    ULONG ulObjectType = 0;
    LPSBinary lpsbEID = NULL;
    LPWABFOLDER lpFolder = NULL;
    //if(bIsSelectedTVContainer(lpbwi))
    {
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, TRUE);
        if(bIsWABSessionProfileAware(bwi_lpIAB))
            lpFolder = FindWABFolder(bwi_lpIAB, lpsbEID, NULL, NULL);
    }
    LocalFreeSBinary(lpsbEID);
    return (lpFolder && lpFolder->lpProfileID) ? lpFolder : NULL;
}

/*
-   RemoveUpdateSelection - Updates the selected TV Item when a deletion is done
-
*
*/
void RemoveUpdateSelection(LPBWI lpbwi)
{
    HTREEITEM hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(bwi_hWndTV);
    if(TreeView_GetParent(bwi_hWndTV, hItem))
        hItem = TreeView_GetParent(bwi_hWndTV, hItem);
    else
        hItem = TreeView_GetNextSibling(bwi_hWndTV, hItem);
    if(!hItem)
        hItem = TreeView_GetRoot(bwi_hWndTV);
    TreeView_SelectItem(bwi_hWndTV, hItem);
    bwi_hti = NULL;
}

/*
-   CreateWindowTitle - if we don't have a passed in caption, create a title 
-       If there is a current user, add the user's name to the title
-       Returns LocalAlloced stuff that needs to be freed
-
*/
LPTSTR CreateWindowTitle(LPIAB lpIAB)
{
    LPTSTR lpTitle = NULL;
    TCHAR szTitle[MAX_PATH];
    LPTSTR lpsz = NULL;

    szTitle[0] = 0;
    if(bIsThereACurrentUser(lpIAB))
    {
        LPTSTR lpsz = lpIAB->szProfileName;
        LoadString(hinstMapiX, idsCaptionWithText, szTitle, ARRAYSIZE(szTitle));
        FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szTitle, 0, 0, (LPTSTR) &lpTitle, 0, (va_list *)&lpsz);
    }

    if(!lpTitle || !lstrlen(lpTitle))
    {
        DWORD cchSize = (lstrlen(szTitle)+1);

        LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szTitle, ARRAYSIZE(szTitle));
        if(lpTitle = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize))
            StrCpyN(lpTitle, szTitle, cchSize);
    }

    return lpTitle;
}

//$$*------------------------------------------------------------------------
//| Main call to create, activate address book overlapped-window
//|
//*------------------------------------------------------------------------
HWND hCreateAddressBookWindow(LPADRBOOK lpAdrBook, HWND hWndParent, LPADRPARM lpAdrParms)
{
    WNDCLASS  wc;
    HWND hWnd = NULL;
    HMENU hMenu = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPBWI lpbwi = NULL;
    LPTSTR lpTitle = NULL;
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    LPTSTR szCaption = (lpAdrParms->ulFlags & MAPI_UNICODE) ? // <note> assumes UNICODE defined
                        (LPWSTR)lpAdrParms->lpszCaption :
                        ConvertAtoW((LPSTR)lpAdrParms->lpszCaption);
    DWORD dwExStyle = WS_EX_NOPARENTNOTIFY | WS_EX_CONTROLPARENT;

    if(IS_BIDI_LOCALIZED_SYSTEM())
    {
        dwExStyle |= RTL_MIRRORED_WINDOW;
    }
    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst)
        goto out;

    //
    // We want each thread to only have one address book window - so we do an
    // enum thread windows and look for our address book window
    // If we find it - we set focus to it - if we dont find it
    // we go ahead and create a new one for this thread ...
    //


    // Is this window we found related to my thread?
    EnumThreadWindows(	GetCurrentThreadId(),
    					FindABWindowProc,
    					(LPARAM) &hWnd);

    if (IsWindow(hWnd))
    {
    	//Perhaps the window was hidden .. show it
    	//if (!IsWindowVisible(hWnd))
    	// ShowWindow(hWnd,SW_NORMAL | SW_RESTORE);

        // SetWindowPos(hWnd, HWND_TOP,0,0,0,0,SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
        
        if(IsWindowEnabled(hWnd))
        {
            SetActiveWindow(hWnd);
            // [PaulHi] 12/1/98  Raid #58527
            // The window may also be minimized.
            if ( IsIconic(hWnd) )
                ShowWindow(hWnd, SW_RESTORE);
        }
        else
        {
            HWND hWndC = GetLastActivePopup(hWnd);
            SetForegroundWindow(hWndC);
        }

    	{
    		// The previous instance of the Dialog might have had a different caption
    		// so we update the caption
            LPBWI lpbwi = (LPBWI) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    		if(szCaption)
    			SetWindowText(hWnd,szCaption);
            if(lpbwi)
            {
    		    bwi_bDontRefreshLV = TRUE;
                RefreshListView(lpbwi,NULL);
                bwi_bDontRefreshLV = FALSE;
            }
    		goto out;
    	}
    }

    lpbwi = LocalAlloc(LMEM_ZEROINIT, sizeof(BWI));
    if(!lpbwi)
    {
        DebugTrace( TEXT("LocalAlloc failed\n"));
        goto out;
    }

    TrimSpaces(szCaption);
    lpTitle = (szCaption && lstrlen(szCaption)) ? szCaption : CreateWindowTitle(lpIAB);

    //
    // if we're here, we didnt succeed in finding or displaying the window
    //

    wc.style           = 0L;
    wc.lpfnWndProc     = AddressBookWndProc;
    wc.cbClsExtra      = 0;
    wc.cbWndExtra      = 0;
    wc.hInstance       = hinstMapiXWAB; //NULL;
    wc.hIcon           = LoadIcon(hinstMapiX,MAKEINTRESOURCE(IDI_ICON_ABOOK));;
    wc.hCursor         = NULL;
    wc.hbrBackground   = (HBRUSH) (COLOR_BTNFACE+1);
    wc.lpszMenuName    = NULL;
    wc.lpszClassName   = g_szClass;

    if(!RegisterClass(&wc))
    {
    	DebugPrintError(( TEXT("Attempt to register class failed: %d!\n"),GetLastError()));
    }

    // In windows95 there is no way of telling wether or not the WindowClass is
    // already registered. Hence we should go ahead and try to create the window
    // anyway making sure to trap the errors.
    // (The above is really needed for Athena - which runs on the system Explorer thread
    // and never really shuts down till the system is shut off - as a result the WndClass
    // registration above would continue to exist and RegisterClass would fail due
    // to  TEXT("incorrect parameters") .. so we let this play on ..

    hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_AB));
    
    if (!hMenu)
    {
    	DebugPrintError(( TEXT("LoadMenu failed: %x\n"),GetLastError()));
    	goto out;
    }

    // Clean any garbage from previous sessions
    CleanUpGlobals(lpbwi);
    bwi_lpfnDismiss = NULL;
    bwi_lpvDismissContext = NULL;

#ifndef WIN16 // WIN16FF : disable until ldap16.dll is available.
    if (bwi_lpAdrBook)
    {
        ReleasePropertyStore(bwi_lpIAB->lpPropertyStore);
    	bwi_lpAdrBook->lpVtbl->Release(bwi_lpAdrBook);
    	bwi_lpAdrBook = NULL;
        bwi_lpIAB = NULL;
        pt_lpIAB = NULL;
    }
#else
    bwi_lpAdrBook = NULL;
    bwi_lpIAB = NULL;
#endif // !WIN16

    // we need this pointer ....
    if (!bwi_lpAdrBook)
    {
    	bwi_lpAdrBook = lpAdrBook;
        bwi_lpIAB = (LPIAB)bwi_lpAdrBook;
    	UlAddRef(bwi_lpAdrBook);
        OpenAddRefPropertyStore(NULL, bwi_lpIAB->lpPropertyStore);
        pt_lpIAB = lpAdrBook;
    }

    HrAllocAdviseSink(&AdviseOnNotify, (LPVOID) lpbwi, &(bwi_lpAdviseSink));

    DebugTrace( TEXT("WAB Window Title is \"%s\"\n"),lpTitle?lpTitle:szEmpty);

    {

        if(IS_BIDI_LOCALIZED_SYSTEM())
        {
            dwExStyle |= RTL_MIRRORED_WINDOW;
        }
        
        hWnd = CreateWindowEx( dwExStyle,
                                 g_szClass,
                                 lpTitle ? lpTitle : szEmpty,
                                 WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                                 CW_USEDEFAULT,
                                 CW_USEDEFAULT,
                                 INIT_WINDOW_W,
                                 INIT_WINDOW_H,
                                 NULL,		
                                 hMenu,			
                                 hinstMapiXWAB,	
                                 (LPVOID)lpbwi);

        if (!hWnd)
        {
    	    DebugPrintError(( TEXT("Ok. CreateWindowEx failed. Ugh.\n")));
            if (bwi_lpAdrBook)
    	    {
                ReleasePropertyStore(bwi_lpIAB->lpPropertyStore);
    		    bwi_lpAdrBook->lpVtbl->Release(bwi_lpAdrBook);
    		    bwi_lpAdrBook = NULL;
                bwi_lpIAB = NULL;
    	    }
    	    goto out;
        }

        // Set up the menu markers on the sort menus ...
        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, TRUE);
        SetColumnHeaderBmp(bwi_hWndListAB, bwi_SortInfo);
        
        // Update folders before redoing any other menu since removing folders
        // changes the order number of the other items
        UpdateSortMenus(lpbwi, hWnd);


        // **IMPORTANT**
        // These 4 calls are position based removals so order of calling them functions is important
        UpdateSwitchUsersMenu(hWnd, bwi_lpIAB);
        UpdateViewFoldersMenu(lpbwi, hWnd);
        UpdatePrintMenu(hWnd);
        UpdateOutlookMenus(hWnd);
        //////////////////////////////////////////////////////////////////////////////////

        UpdateCustomColumnMenuText(hWnd);


        IF_WIN32(ShowWindow(hWnd,SW_SHOWDEFAULT);)
        IF_WIN16(ShowWindow(hWnd,SW_SHOW);)

        if(lpAdrParms->ulFlags & DIALOG_SDI)
        {
            lpAdrParms->lpfnABSDI = &fnAccelerateMessages;
            bwi_lpfnDismiss = lpAdrParms->lpfnDismiss;
            bwi_lpvDismissContext = lpAdrParms->lpvDismissContext;
        }

        // load the accelrator table ...
        pt_hAccTable = LoadAccelerators(hinstMapiX,	 TEXT("WabUIAccel"));

        // repainting everything ...
        RedrawWindow(   hWnd,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
        //populate the window
        bwi_bDontRefreshLV = TRUE;
        RefreshListView(lpbwi,NULL);
        bwi_bDontRefreshLV = FALSE;

    }
out:

    if(lpTitle != szCaption)
        LocalFree(lpTitle);
    if(szCaption != lpAdrParms->lpszCaption)
        LocalFreeAndNull(&szCaption);

    return (hWnd);
}

#if WINVER < 0X0500
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#endif // WS_EX_LAYOUTRTL

//$$
//
//
void ShowToolbarItemMenu(LPBWI lpbwi, HWND hWndTools, int tbitem, int lvtb)
{
    // We're going to pop up the Action sub-menu - need to align it
    // neatly with the bottom of the toolbar
    RECT rc = {0}, rcButton = {0};
    LPARAM lp;
    SendMessage(hWndTools, TB_GETITEMRECT, (WPARAM)tbitem, (LPARAM)&rcButton);
    GetWindowRect(bwi_hWndBB, &rc);
    lp = MAKELPARAM((GetWindowLong(bwi_hWndBB, GWL_EXSTYLE) & WS_EX_LAYOUTRTL)? rc.right - rcButton.left : rc.left + rcButton.left, rc.top + rcButton.bottom);
    ShowLVContextMenu(  lvtb, bwi_hWndListAB, NULL, lp, NULL, bwi_lpAdrBook, bwi_hWndTV);
}

//$$
//*------------------------------------------------------------------------
//| AddressBookWndProx:
//|
//*------------------------------------------------------------------------
LRESULT CALLBACK AddressBookWndProc(HWND   hWnd,
                                    UINT   uMsg,
                                    WPARAM   wParam,
                                    LPARAM lParam)
{
    static UINT uTimer = 0;
    static FILETIME ftLast = {0};
// HBRUSH to draw STATIC control's background
    IF_WIN16(static HBRUSH hBrushBack;)
    static BOOL bMouseDrag = FALSE;
    LPBWI lpbwi = (LPBWI) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    switch(uMsg)
    {
        // OE5 HACK. Do not use these WM_USER values in the WAB wndproc
        // OE subclasses the WAB to do some modal voodoo in common\ipab.cpp
        // if needs to send these private messages.
        // case WM_USER + 10666:
        // case WM_USER + 10667:
            //break;

#ifdef HM_GROUP_SYNCING
        case WM_USER_SYNCGROUPS:
            // We don't want the user to have to select the HM account for both passes, so use 
            // the TLS stored account ID if it is available.
            HrSynchronize(hWnd, bwi_lpAdrBook, lpPTGData->lptszHMAccountId, TRUE);    // Sync group contacts
            break;
#endif

        case WM_INITMENUPOPUP:
            Handle_WM_INITMENUPOPUP(hWnd, lpbwi, uMsg, wParam, lParam);
            break;

        case WM_MENUSELECT:
            Handle_WM_MENSELECT(lpbwi, uMsg, wParam, lParam);
            break;

		case WM_MOUSEMOVE:
			if(SplitterHitTest(bwi_hWndSplitter, lParam))
				SetCursor(LoadCursor(NULL, IDC_SIZEWE));
			break;

		case WM_LBUTTONDOWN:
			if(SplitterHitTest(bwi_hWndSplitter, lParam))
			{
				DragSplitterBar(lpbwi, hWnd, bwi_hWndSplitter, lParam);
			}
			break;

        case WM_COMMAND:
            {
                switch(GET_WM_COMMAND_ID(wParam, lParam))
                {
                default:
                    if(GET_WM_COMMAND_ID(wParam, lParam) >= IDM_VIEW_FOLDERS1 &&
                        GET_WM_COMMAND_ID(wParam, lParam) <= IDM_VIEW_FOLDERS1 + MAX_VIEW_FOLDERS)
                    {
                        LPWABFOLDER lpFolder = bwi_lpIAB->lpWABFolders;
                        if(lpFolder)
                        {
                            int nCmdID = GET_WM_COMMAND_ID(wParam, lParam);
                            LPSBinary lpsb = NULL;
                            while(lpFolder)
                            {
                                if(nCmdID == lpFolder->nMenuCmdID)
                                    break;
                                lpFolder = lpFolder->lpNext;
                            }

                            if(lpFolder)
                            {
                                if(!HR_FAILED(HrUpdateFolderInfo((bwi_lpIAB), &lpFolder->sbEID, 
                                                    FOLDER_UPDATE_SHARE, !lpFolder->bShared, NULL)))
                                {
                                    HrGetWABProfiles((bwi_lpIAB));
                                }
                                if(!IsWindowVisible(bwi_hWndTV))
                                    PostMessage(hWnd, WM_COMMAND, (WPARAM) IDM_VIEW_GROUPSLIST, 0);
                            }
                            if(bwi_lpUserFolder)
                                bwi_lpUserFolder = NULL;

                            //UpdateViewFoldersMenu(lpbwi, hWnd);
                            // Refresh the UI
                            GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsb, NULL, FALSE);
                            bwi_bDontRefreshLV = TRUE;
                            RefreshListView(lpbwi,&ftLast);
                            UpdateLV(lpbwi);
                            UpdateTVGroupSelection(bwi_hWndTV, lpsb);
                            bwi_bDontRefreshLV = FALSE;
                            LocalFreeSBinary(lpsb);
                        }
                    }                    
#ifdef COLSEL_MENU 
                    else if ((GET_WM_COMMAND_ID(wParam, lParam) > IDR_MENU_LVCONTEXTMENU_COLSEL) && 
                        (GET_WM_COMMAND_ID(wParam, lParam) <= (IDR_MENU_LVCONTEXTMENU_COLSEL + MAX_VIEW_COLSEL)))
                    {
                        BOOL rVal = FALSE;
                        TCHAR szBuf[MAX_PATH];
                        ULONG iCol = lpbwi->iSelColumn;
                        ULONG ulCmdId = GET_WM_COMMAND_ID(wParam, lParam);
                        ULONG iTagSel = (ulCmdId - IDR_MENU_LVCONTEXTMENU_COLSEL - 1);
                        LONG lr = 0;
                        HMENU hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDR_MENU_LVCONTEXTMENU_COLSEL));
                        HMENU hSubMenu = GetSubMenu(hMenu, 0);
                        MENUITEMINFO mii;
                        if( hMenu && hSubMenu )
                        {
                            mii.fMask = MIIM_TYPE;
                            mii.dwTypeData = szBuf;
                            mii.cch = CharSizeOf( szBuf );
                            mii.cbSize = sizeof (MENUITEMINFO);
                            if ( !GetMenuItemInfo( hSubMenu, iTagSel, TRUE, &mii) )
                            {                       
                                DebugTrace( TEXT("cannot get info : %d\n"), GetLastError() );
                                rVal = TRUE;
                            }
                            else
                            {
                                if( iCol == colHomePhone || iCol == colOfficePhone)
                                {
                                    if( iCol == colHomePhone )
                                    {
                                        PR_WAB_CUSTOMPROP1 = MenuToPropTagMap[iTagSel];
                                        StrCpyN(szCustomProp1, szBuf, ARRAYSIZE(szCustomProp1));
                                        UpdateOptionalColumns( lpbwi, colHomePhone );
                                    }                            
                                    else
                                    {
                                        PR_WAB_CUSTOMPROP2 = MenuToPropTagMap[iTagSel];
                                        StrCpyN(szCustomProp2, szBuf, ARRAYSIZE(szCustomProp2));
                                        UpdateOptionalColumns( lpbwi, colOfficePhone );
                                    }
                                    UpdateLV( lpbwi );
                                    UpdateSortMenus(lpbwi, hWnd);
                                    UpdateCustomColumnMenuText(hWnd);
                                }
                            }
                        }
                        else
                        {                            
                            DebugTrace( TEXT("LoadMenu failed: %d\n"), GetLastError());
                            rVal = TRUE;
                        }
                        DestroyMenu(hMenu);
                        return rVal;
                    }
#endif //COLSEL_MENU 
                    else
                    {
                        LRESULT fRet = FALSE;
                        bwi_hti = NULL; 
                        bwi_bDontRefreshLV = TRUE;
                        fRet = ProcessActionCommands(bwi_lpIAB, bwi_hWndListAB, 
                                                      hWnd, uMsg, wParam, lParam);
                        bwi_bDontRefreshLV = FALSE;
                        return fRet;
                    }
                    break;

                case IDM_EDIT_SETME:
                    {
                        SBinary sb = {0};
                        HrSetMeObject(bwi_lpAdrBook, MAPI_DIALOG, sb, (ULONG_PTR)hWnd);
                    }
                    break;

                case IDM_FILE_EXIT:
                    SendMessage(hWnd,WM_CLOSE,0,0L);
    			    return 0;
                    break;

                case IDC_ABOOK_STATIC_QUICK_FIND:
                    SetFocus(bwi_hWndEditQF);
                    break;

    		    case IDC_BB_NEW:
                    ShowToolbarItemMenu(lpbwi, bwi_hWndTools, tbNew, lvToolBarNewEntry);
                    break;

                case IDC_BB_ACTION:
                    // OE 63674
                    // When the Print button is hidden (thanks to idsLangPrintingOn==0)
                    // The enumeration item tbAction is off by 1
                    ShowToolbarItemMenu(lpbwi, bwi_hWndTools, bPrintingOn ? tbAction : tbAction - 1, lvToolBarAction);
                    break;

                case IDM_FILE_SENDMAIL:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_SENDMAIL:
                    bwi_bDontRefreshLV = TRUE;
                    /*
                    if(bIsFocusOnTV(lpbwi) && !bIsSelectedTVContainer(lpbwi))
                    {
                        LPSBinary lpsbEID = NULL;
                        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);
                        if(lpsbEID && lpsbEID->lpb)
                        {
                            HrSendMailToSingleContact(hWnd, bwi_lpIAB, lpsbEID->cb, (LPENTRYID)lpsbEID->lpb);
                            LocalFreeSBinary(lpsbEID);
                        }
                    }
                    else
                    */
                   HrSendMailToSelectedContacts(bwi_hWndListAB, bwi_lpAdrBook, 0);
                    bwi_hti = NULL;
                    bwi_bDontRefreshLV = FALSE;
                    break;

    		    case IDC_BB_DELETE:
    		    case IDM_FILE_DELETE:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_DELETE:
                    bwi_bDontRefreshLV = TRUE;
                    // if focus is on the treeview, remove the group from the treeview
                    if(bIsFocusOnTV(lpbwi))
                    {
                        if(!bIsSelectedTVContainer(lpbwi))
                        {
                            RemoveCurrentGroup(lpbwi, hWnd, &ftLast);
                            bwi_bDeferNotification = TRUE;
                            SetFocus(bwi_hWndTV);
                        }
                        else
                        {
                            if(!HR_FAILED(RemoveCurrentFolder(lpbwi, hWnd, &ftLast)))
                            {
                                UpdateLV(lpbwi);
                                //UpdateViewFoldersMenu(lpbwi, hWnd);
                                SetFocus(bwi_hWndTV);
                                bwi_bDeferNotification = TRUE;
                            }
                        }
                        bwi_hti = NULL;
                    }
                    else
                    {
                        // Focus is on the ListView
                        // If we're looking at the root AB - remove from addressbook
                        // If we're looking at some group, remove entries from group
                        bwi_hti = NULL; // if this wasnt a context-initiated action on the tree view, dont trust the hti setting
                        if(!bIsSelectedTVContainer(lpbwi))
                        {
                            // a group is selected .. remove from the group .. unless
                            // the shift key is pressed which means remove from the 
                            // address book
                            if(GetKeyState(VK_SHIFT) & 0x80)
                                RemoveSelectedItemsFromCurrentGroup(lpbwi, hWnd, &ftLast, TRUE);
                            else
                                RemoveSelectedItemsFromCurrentGroup(lpbwi, hWnd, &ftLast, FALSE);
                            bwi_hti = NULL;
                            bwi_bDontRefreshLV = TRUE;
	                        RefreshListView(lpbwi,&ftLast);
                            bwi_bDontRefreshLV = FALSE;
                            bwi_bDeferNotification = TRUE;
                        }
                        else // Container selected - remove selected items from the container
                        {
                            DeleteSelectedItems(bwi_hWndListAB, (LPADRBOOK)bwi_lpAdrBook, bwi_lpIAB->lpPropertyStore->hPropertyStore, &ftLast);
                            bwi_hti = NULL;
                            bwi_bDontRefreshLV = TRUE;
	                        RefreshListView(lpbwi,&ftLast);
                            bwi_bDontRefreshLV = FALSE;
                            bwi_bDeferNotification = TRUE;
                        }
                        SetFocus(bwi_hWndListAB);
                    }
                    bwi_hti = NULL;
				    UpdateToolbarAndMenu(lpbwi);
                    bwi_bDontRefreshLV = FALSE;
    			    return 0;
    			    break;

                case IDM_FILE_NEWFOLDER:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_NEWFOLDER:
                    bwi_bDontRefreshLV = TRUE;
                    {
                        LPWABFOLDER lpParent = GetSelectedUserFolder(lpbwi);
                        LPSBinary lpNew = NULL;
                        SBinary sbNewFolder = {0}, sbParent = {0};
                        if(lpParent)
                            SetSBinary(&sbParent, lpParent->sbEID.cb, lpParent->sbEID.lpb);
                        HrFolderProperties(hWnd, bwi_lpIAB, NULL, lpParent, &sbNewFolder);
                        if(sbNewFolder.lpb)
                            lpNew = &sbNewFolder;
                        else if(lpParent)
                            lpNew = &sbParent;
                        //UpdateViewFoldersMenu(lpbwi, hWnd);
                        if(!IsWindowVisible(bwi_hWndTV))
                            PostMessage(hWnd, WM_COMMAND, (WPARAM) IDM_VIEW_GROUPSLIST, 0);
                        HrGetWABProfiles(bwi_lpIAB);
                        RefreshListView(lpbwi, NULL);
                        if(lpNew && lpNew->cb)
                            UpdateTVGroupSelection(bwi_hWndTV, lpNew);
                        LocalFreeAndNull((LPVOID *) (&(sbParent.lpb)));
                        LocalFreeAndNull((LPVOID *) (&(sbNewFolder.lpb)));
                    }
                    bwi_bDontRefreshLV = FALSE;
                    bwi_bDeferNotification = TRUE;
                    bwi_hti = NULL;
                    break;

    		    case IDM_FILE_NEWGROUP:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_NEWGROUP:
    		    //case IDC_BB_NEW_GROUP:
                    {
                        ULONG cbEID = 0;
                        LPENTRYID lpEID = NULL;
                        HRESULT hr = S_OK;
                        bwi_bDontRefreshLV = TRUE;
    			        hr = AddNewObjectToListViewEx(bwi_lpAdrBook, bwi_hWndListAB, bwi_hWndTV, bwi_hti,
                                                    NULL, MAPI_DISTLIST,
                                                    &bwi_SortInfo, &bwi_lpContentsList, &ftLast,
                                                    &cbEID, &lpEID);
                        if(hr != MAPI_E_USER_CANCEL)
                        {
                            bwi_hti = NULL;
                            RefreshListView(lpbwi,&ftLast);
                            if(cbEID && lpEID && IsWindowVisible(bwi_hWndTV))
                            {
                                SBinary sbEID = {cbEID, (LPBYTE)lpEID };
                                UpdateTVGroupSelection(bwi_hWndTV,&sbEID);
                                FreeBufferAndNull(&lpEID);
                            }
                        }
                        bwi_bDontRefreshLV = FALSE;
                        //bwi_bDeferNotification = TRUE;
                        UpdateToolbarAndMenu(lpbwi);
                    }
    			    break;

    		    case IDM_FILE_NEWCONTACT:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_NEWCONTACT:
                    bwi_bDontRefreshLV = TRUE;
    			    AddNewObjectToListViewEx( bwi_lpAdrBook, bwi_hWndListAB, bwi_hWndTV, bwi_hti,
                                                NULL, MAPI_MAILUSER,
                                                &bwi_SortInfo, &bwi_lpContentsList, &ftLast,NULL,NULL);
                    //RefreshListView(lpbwi,&ftLast);
                    bwi_hti = NULL;
                    //bwi_bDeferNotification = TRUE;
                    bwi_bDontRefreshLV = FALSE;
                    UpdateToolbarAndMenu(lpbwi);
    			    break;

                case IDM_TOOLS_OPTIONS:
                    HrShowOptionsDlg(hWnd);
                    break;
                
                case IDM_TOOLS_SYNCHRONIZE_NOW:
#ifdef HM_GROUP_SYNCING
                    HrSynchronize(hWnd, bwi_lpAdrBook, NULL, FALSE);    // Sync mail contacts
#else
                    HrSynchronize(hWnd, bwi_lpAdrBook, NULL);
#endif
                    break;

                case IDM_FILE_DIRECTORY_SERVICE:
                    HrShowDirectoryServiceModificationDlg(hWnd, bwi_lpIAB);
                    break;


                case IDC_BB_PRINT:
                case IDM_FILE_PRINT:
                    if(bPrintingOn)
                    {
                        TCHAR szBuf[MAX_PATH];
                        bwi_bDontRefreshLV = TRUE;
                        LoadString(hinstMapiX, idsPrintStatusBarMessage, szBuf, ARRAYSIZE(szBuf));
                        StatusBarMessage(lpbwi, szBuf);
                        HrPrintItems(hWnd, bwi_lpAdrBook, bwi_hWndListAB, bwi_SortInfo.bSortByLastName);
                        ShowLVCountinStatusBar(lpbwi);
                        bwi_hti = NULL;
                        bwi_bDontRefreshLV = FALSE;
                    }
                    break;

                case IDM_EDIT_COPY:
                        bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_COPY:
                    {
                        LPIWABDATAOBJECT lpIWABDataObject = NULL;
                        bwi_bDontRefreshLV = TRUE;
                        HrCreateIWABDataObject((LPVOID)lpbwi, bwi_lpAdrBook, bwi_hWndListAB, &lpIWABDataObject, 
                                                TRUE,bCheckIfOnlyGroupsSelected(bwi_hWndListAB));
                        if(lpIWABDataObject)
                        {
                            bwi_lpIWABDragDrop->m_bSource = TRUE;
                            OleSetClipboard((LPDATAOBJECT) lpIWABDataObject);
                            bwi_lpIWABDragDrop->m_bSource = FALSE;
                            lpIWABDataObject->lpVtbl->Release(lpIWABDataObject);
                        }
                        //HrCopyItemDataToClipboard(hWnd, bwi_lpAdrBook, bwi_hWndListAB);
                        bwi_hti = NULL;
                        bwi_bDontRefreshLV = FALSE;
                    }
                    break;

                case IDM_EDIT_PASTE:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
                case IDM_LVCONTEXT_PASTE:
                    {
                        LPDATAOBJECT lpDataObject = NULL;
                        bwi_bDontRefreshLV = TRUE;
                        if(bIsPasteData())
                        {
                            if(S_OK == HrPasteData(lpbwi))
                                UpdateLV(lpbwi);
                        }
                        //HrCopyItemDataToClipboard(hWnd, bwi_lpAdrBook, bwi_hWndListAB);
                        bwi_hti = NULL;
                        bwi_bDontRefreshLV = FALSE;
                    }
                    break;

    		    case IDC_BB_FIND:
    		    case IDM_EDIT_FIND:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_FIND:
                    bwi_bDontRefreshLV = TRUE;
                    HrShowSearchDialog((LPADRBOOK) bwi_lpAdrBook,
                                        bwi_hWndAB,
                                        (LPADRPARM_FINDINFO) NULL,
                                        (LPLDAPURL) NULL,
                                        &(bwi_SortInfo));
                    bwi_hti = NULL;
                    RefreshListView(lpbwi,&ftLast);
                    bwi_bDeferNotification = TRUE;
                    bwi_bDontRefreshLV = FALSE;
                    UpdateToolbarAndMenu(lpbwi);
                    SetFocus(bwi_hWndListAB);
    			    break;

    		    case IDM_EDIT_SELECTALL:
                    {
                        int index = 0;
                        int iTotal = ListView_GetItemCount(bwi_hWndListAB);
                        if (iTotal > 0)
                        {
                            for(index=0;index<iTotal;index++)
                            {
                                ListView_SetItemState ( bwi_hWndListAB,  // handle to listview
    							                        index,			// index to listview item
    							                        LVIS_SELECTED,  // item state
    							                        LVIS_SELECTED); // mask
                            }
                        }

                    }
    			    break;


                case IDM_HELP_ADDRESSBOOKHELP:
                    WABHtmlHelp(hWnd,  TEXT("%SYSTEMROOT%\\help\\wab.chm>iedefault"), 
                        HH_DISPLAY_TOPIC, (DWORD_PTR) (LPCSTR)  TEXT("wab_welcome.htm"));
    			    break;

    		    case IDM_HELP_ABOUTADDRESSBOOK:
                    DialogBox(  hinstMapiX,
                                MAKEINTRESOURCE(IDD_DIALOG_ABOUT),
                                hWnd,
                                HelpAboutDialogProc);
                    break;

                case IDM_FILE_SWITCHUSERS:
                    HrLogonAndGetCurrentUserProfile(hWnd, bwi_lpIAB, TRUE, FALSE);
                    break;

                case IDM_FILE_SHOWALLCONTENTS:
                    RunWABApp(hWnd, szWABExeRegPathKey, szWABExe, TEXT("/all"));
                    break;

                case IDM_NOTIFY_REFRESHUSER:
                    {
                        LPTSTR lpTitle = CreateWindowTitle(bwi_lpIAB);
                        SetWindowText(hWnd, lpTitle);
                        LocalFreeAndNull(&lpTitle);
                        ReadWABCustomColumnProps(bwi_lpIAB);
                        UpdateOptionalColumns( lpbwi, colHomePhone );
                        UpdateOptionalColumns( lpbwi, colOfficePhone );
                        ReadRegistrySortInfo(bwi_lpIAB,&bwi_SortInfo);
                        RefreshListView(lpbwi, NULL);
                        if(bIsThereACurrentUser(bwi_lpIAB))
                        {
                            LPSBinary lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;
                            UpdateTVGroupSelection(bwi_hWndTV, lpsbSelection);
                        }
                    }
                    break;

    		    case IDM_FILE_PROPERTIES:
                    // bobn: brianv says we have to take this out...
                    /*if(bwi_nCount == 2)
                    {
                        if( (GetKeyState(VK_CONTROL) & 0x80) &&
                            (GetKeyState(VK_MENU)  & 0x80) &&
                            (GetKeyState(VK_SHIFT) & 0x80))
                        {
                            SCS(hWnd);
                            break;
                        }
                    }
                    else
                        bwi_nCount = 0;*/
    		    case IDC_BB_PROPERTIES:
                    bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
    		    case IDM_LVCONTEXT_PROPERTIES:
                    bwi_bDontRefreshLV = TRUE;
                    if(bIsFocusOnTV(lpbwi))
                    {
                        ViewCurrentGroupProperties(lpbwi, &ftLast);
                        bwi_bDeferNotification = TRUE;
                    }
                    else
    			    {
    				    HRESULT hr = HrShowLVEntryProperties(bwi_hWndListAB, WAB_ONEOFF_NOADDBUTTON, bwi_lpAdrBook, &ftLast);
                        bwi_hti = NULL;
                        if(hr == MAPI_E_OBJECT_CHANGED)
                        {
                            bwi_bDeferNotification = TRUE;
                            // resort the display
                            SendMessage(bwi_hWndListAB, WM_SETREDRAW, FALSE, 0);
                            SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, TRUE);
                            SendMessage(bwi_hWndListAB, WM_SETREDRAW, TRUE, 0);
                        }
                        bwi_bDontRefreshLV = FALSE;
    				    return 0;
    			    }
                    bwi_bDontRefreshLV = FALSE;
    			    break;


    		    case IDM_VIEW_REFRESH:
                    bwi_bDontRefreshLV = TRUE;
                    bwi_hti = NULL;
                    HrGetWABProfiles(bwi_lpIAB);
    			    RefreshListView(lpbwi,&ftLast);
                    bwi_bDontRefreshLV = FALSE;
    			    return 0;
    			    break;


                case IDM_VIEW_STATUSBAR:
                    if (IsWindowVisible(bwi_hWndSB))
                    {
    				    //hide it
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_STATUSBAR,MF_BYCOMMAND | MF_UNCHECKED);
    				    ShowWindow(bwi_hWndSB, SW_HIDE);
    			    }
    			    else
    			    {
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_STATUSBAR,MF_BYCOMMAND | MF_CHECKED);
    				    ShowWindow(bwi_hWndSB, SW_NORMAL);
    				    //special case repainting to workaround a repaint bug ...
    				    InvalidateRect(bwi_hWndListAB,NULL,TRUE);
                        ShowLVCountinStatusBar(lpbwi);
                    }
    	            ResizeAddressBookChildren(lpbwi, hWnd);
                    break;

    		    case IDM_VIEW_TOOLBAR:
    			    if (IsWindowVisible(bwi_hWndBB))
    			    {
    				    //hide it
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_TOOLBAR,MF_BYCOMMAND | MF_UNCHECKED);
    				    ShowWindow(bwi_hWndBB, SW_HIDE);
    			    }
    			    else
    			    {
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_TOOLBAR,MF_BYCOMMAND | MF_CHECKED);
    				    ShowWindow(bwi_hWndBB, SW_NORMAL);
    				    //special case repainting to workaround a repaint bug ...
    				    InvalidateRect(bwi_hWndListAB,NULL,TRUE);
    				    InvalidateRect(bwi_hWndTV,NULL,TRUE);
    			    }
    	            ResizeAddressBookChildren(lpbwi, hWnd);
    			    break;

                case IDM_VIEW_GROUPSLIST:
    			    if (IsWindowVisible(bwi_hWndTV))
    			    {
    				    //hide it
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_GROUPSLIST,MF_BYCOMMAND | MF_UNCHECKED);
    				    ShowWindow(bwi_hWndTV, SW_HIDE);
    				    ShowWindow(bwi_hWndSplitter, SW_HIDE);
                        InvalidateRect(bwi_hWndStaticQF, NULL, TRUE);
                        // If this is a user based session, we want the hidden focus to be on the user's
                        // folder not on the Shared Contacts
                        if(bIsThereACurrentUser(bwi_lpIAB))
                        {
                            LPSBinary lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;
                            UpdateTVGroupSelection(bwi_hWndTV, lpsbSelection);
                        }
                        else
                        {
                            // Set the selection to the root address book so we see the file
                            // contents just as if we dont have a treeview at all
                            HTREEITEM hItem = TreeView_GetSelection(bwi_hWndTV);
                            HTREEITEM hRoot = TreeView_GetRoot(bwi_hWndTV);
                            if(hItem != hRoot)
                                TreeView_SelectItem(bwi_hWndTV, hRoot);
                        }
    			    }
    			    else
    			    {
    				    CheckMenuItem(GetMenu(hWnd),IDM_VIEW_GROUPSLIST,MF_BYCOMMAND | MF_CHECKED);
    				    ShowWindow(bwi_hWndTV, SW_NORMAL);
    				    ShowWindow(bwi_hWndSplitter, SW_NORMAL);
    				    //special case repainting to workaround a repaint bug ...
    				    //InvalidateRect(bwi_hWndListAB,NULL,TRUE);
    				    //InvalidateRect(bwi_hWndTV,NULL,TRUE);
    			    }
    	            ResizeAddressBookChildren(lpbwi, hWnd);
                    SaveCurrentPosition(lpbwi, hWnd,bwi_hWndListAB,bwi_hWndBB,bwi_hWndSB);
                    break;

                case IDM_VIEW_SORTBY_DISPLAYNAME:
                case IDM_VIEW_SORTBY_EMAILADDRESS:
                case IDM_VIEW_SORTBY_BUSINESSPHONE:
                case IDM_VIEW_SORTBY_HOMEPHONE:
                    {
                        //Assuming the above ids are in sequential order ...
                        int iCol = LOWORD(wParam) - IDM_VIEW_SORTBY_DISPLAYNAME;
                        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, iCol, &bwi_SortInfo, FALSE);
                        UpdateSortMenus(lpbwi, hWnd);
                    }
                    break;


                case IDM_VIEW_SORTBY_FIRSTNAME:
                    bwi_SortInfo.bSortByLastName = FALSE;
                    goto DoSortMenuStuff;
                case IDM_VIEW_SORTBY_LASTNAME:
                    // bobn: brianv says we have to take this out...
                    /*if(bwi_nCount == 1)
                        bwi_nCount++;
                    else
                        bwi_nCount = 0;*/
                    bwi_SortInfo.bSortByLastName = TRUE;
                    goto DoSortMenuStuff;
                case IDM_VIEW_SORTBY_DESCENDING:
                    bwi_SortInfo.bSortAscending = FALSE;
                    goto DoSortMenuStuff;
                case IDM_VIEW_SORTBY_ASCENDING:
                    bwi_SortInfo.bSortAscending = TRUE;
                    DoSortMenuStuff:
                        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, 0, &bwi_SortInfo, TRUE);
                        UpdateSortMenus(lpbwi, hWnd);
                    break;


    		    // miscellanous styles for the list view control
                case IDM_VIEW_LARGEICON:
                    // bobn: brianv says we have to take this out...
                    /*if(bwi_nCount == 0)
                        bwi_nCount++;*/
                case IDM_VIEW_SMALLICON:
                case IDM_VIEW_LIST:
                case IDM_VIEW_DETAILS:
                    SetListViewStyle(lpbwi, LOWORD(wParam));
    			    CheckMenuRadioItem(	GetMenu(hWnd),
    								    IDM_VIEW_LARGEICON,
    								    IDM_VIEW_DETAILS,
    								    LOWORD(wParam),
    								    MF_BYCOMMAND);
    			    return 0;
                    break;

    		    case IDC_EDIT_QUICK_FIND:
    			    switch(HIWORD(wParam)) //check the notification code
    			    {
    			    case EN_CHANGE: //edit box changed
    					DoLVQuickFind(bwi_hWndEditQF,bwi_hWndListAB);
/*                            if(bwi_bDoQuickFilter)
                            {
                                DoLVQuickFilter(bwi_lpAdrBook,
                                                bwi_hWndEditQF,
                                                bwi_hWndListAB,
                                                &bwi_SortInfo,
                                                AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL,
                                                1,
                                                &bwi_lpContentsList);

                                ShowLVCountinStatusBar(lpbwi);
                            }
*/
    				    break;
    			    }
    			    break;

                case IDM_TOOLS_EXPORT_WAB:
                    HrExportWAB(hWnd, lpbwi);
                    break;

                case IDM_TOOLS_EXPORT_OTHER:
                case IDM_TOOLS_IMPORT_OTHER:
                    {
                        // if there is a current user, then we let wabmig.exe automatically
                        // loginto the current user in the WAB .. else we need to send the filename etc
                        //
                        BOOL bImport = (GET_WM_COMMAND_ID(wParam, lParam) == IDM_TOOLS_IMPORT_OTHER);
                        TCHAR szParam[MAX_PATH * 2];
                        
                        if(bIsThereACurrentUser(bwi_lpIAB))
                        {
                            StrCpyN(szParam, bImport ? szIMPORT : szEXPORT, ARRAYSIZE(szParam));
                        }
                        else
                        {
                            LPTSTR lpWABFile = NULL, lpProfileID = szEmpty;
                            lpWABFile = GetWABFileName( bwi_lpIAB->lpPropertyStore->hPropertyStore, FALSE);
                            if(!lpWABFile || !lstrlen(lpWABFile))
                                lpWABFile = szEmpty;
                            wnsprintf(szParam, ARRAYSIZE(szParam), (bImport ? szIMPORTwProfileParam : szEXPORTwProfileParam), 
                                    szEmpty, lpWABFile);
                        }
                        RunWABApp(hWnd, szWABMigRegPathKey, szWABMIG, szParam);
                    }
                    break;


                case IDM_TOOLS_IMPORT_WAB:
                    bwi_bDontRefreshLV = TRUE;
                    //bwi_bDeferNotification = TRUE;
                    HrImportWABFile(hWnd, bwi_lpAdrBook, MAPI_DIALOG, NULL);
                    bwi_bDontRefreshLV = FALSE;
                    RefreshListView(lpbwi, &ftLast);
                    break;

    #ifdef VCARD
                case IDM_TOOLS_EXPORT_VCARD:
                    bwi_bDontRefreshLV = TRUE;
                    VCardExportSelectedItems(bwi_hWndListAB, bwi_lpAdrBook);
                    bwi_bDontRefreshLV = FALSE;
                    return(0);

                case IDM_TOOLS_IMPORT_VCARD:
                    OpenAndAddVCard(lpbwi, NULL);
                    return(0);
    #endif
                }
            }
    		break;

       case WM_TIMER:
           {
               // Check if we need to refresh
               switch(wParam)
               {
                   /*
               case WAB_REFRESH_TIMER:
                    if (    CheckChangedWAB(bwi_lpIAB->lpPropertyStore, &ftLast))
                    {
                        if(!bwi_bDontRefreshLV)
                            RefreshListView(lpbwi,&ftLast);
                        return(0);
                    }
                    else
                    {
                        return(DefWindowProc(hWnd,uMsg,wParam,lParam));
                    }
                    break;
                    */
               case WAB_TOOLTIP_TIMER_ID:
                   {
                        if(GetActiveWindow() == hWnd)
                        {
                            // We seem to get the message anytime the mouse is sitting idle on the
                            // list view - or when the selection changes between items
                            if(bwi_tt_bActive)
                            {
                                // The tooltip is already active
                                // Get the item index number of the item under the mouse
                                //
                                int nItem = HitTestLVSelectedItem(lpbwi);

                                if(nItem != bwi_tt_iItem)
                                {
                                    bwi_tt_bShowTooltip = FALSE;
                                    bwi_tt_iItem = nItem;
                                }
                                else
                                {
                                    if(!bwi_tt_bShowTooltip)
                                    {
                                        // if this is an item other than the previous item
                                        // we update the tooltip and move it
                                        TOOLINFO ti = {0};

                                        bwi_tt_bShowTooltip = TRUE;

                                        bwi_tt_iItem = nItem;

                                        FillTooltipInfo(lpbwi, &ti);
                                        bwi_tt_szTipText[0]='\0';
                                        ti.lpszText = szEmpty;

                                        // There is a case where nItem transitions from valid to
                                        // invalid (-1) item. Cover that case too.
                                        if(nItem != -1)
                                            UpdateTooltipTextBuffer(lpbwi, nItem);

                                        // Set the tooltip text to  TEXT("") - this will hide the tooltip
                                        ToolTip_UpdateTipText(bwi_hWndTT, (LPARAM)&ti);

                                        if(nItem != -1)
                                        {
                                            POINT pt;
                                            // Move the tooltip
                                            GetCursorPos(&pt);
                                            SendMessage(bwi_hWndTT,TTM_TRACKPOSITION,0,(LPARAM)MAKELPARAM(pt.x+15,pt.y+15));

                                            // Set the new text to the tooltip
                                            ti.lpszText = bwi_tt_szTipText;
                                            ToolTip_UpdateTipText(bwi_hWndTT,(LPARAM)&ti);
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // reset the tooltip text ...
                            if(bwi_tt_bActive)
                            {
                                //set the tooltip text to empty
                                TOOLINFO ti = {0};
                                FillTooltipInfo(lpbwi, &ti);
                                ti.lpszText = szEmpty; //LPSTR_TEXTCALLBACK;
                                ToolTip_UpdateTipText(bwi_hWndTT, (LPARAM)&ti);
                                bwi_tt_iItem = -1;
                            }
                        }
                   }
                   break;
               }
           }
           break;

    	case WM_GETMINMAXINFO:
    		//enforce a minimum size for sanity
    		return EnforceMinSize(lpbwi, hWnd, uMsg, wParam, lParam);
    		break;

        case PUI_OFFICE_COMMAND:
            // WAB should not shut down if it is running as part of some other process .. it should only shut down if 
            // it is running in a seperate process ..
            // To find out if we were invoked by wab.exe, check the cached guidPSExt on the LPIAB object
            if(memcmp(&bwi_lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)))
            {
                DebugTrace( TEXT("Ignoring the Plug_UI command...\n"));
                return 0;
            }

            // We get this message when user switches his locale and IE tells us it wants us to shut down
            if(wParam == PLUGUI_CMD_QUERY)
            {
                PLUGUI_QUERY pq;

                pq.uQueryVal = 0; // initialize
                pq.PlugUIInfo.uMajorVersion = OFFICE_VERSION_9; // Value filled in by Apps
                pq.PlugUIInfo.uOleServer = FALSE;              // Value filled in by Apps

                return (pq.uQueryVal); // The state of the App
            }
            // for any others parameters, including PLUGUI_CMD_SHUTDOWN
            // fall to close application

    	case WM_CLOSE:
            {
                BOOL bDragDrop = FALSE;

                if(bwi_lpIWABDragDrop)
			    {
                    bDragDrop = TRUE;
				    RevokeDragDrop(bwi_hWndListAB);
				    RevokeDragDrop(bwi_hWndTV);
				    CoLockObjectExternal((LPUNKNOWN) bwi_lpIWABDragDrop, FALSE, TRUE);
				    bwi_lpIWABDragDrop->lpVtbl->Release(bwi_lpIWABDragDrop);
				    bwi_lpIWABDragDrop = NULL;
			    }

                bwi_bDontRefreshLV = TRUE;

                ClearTreeViewItems(bwi_hWndTV);
                ListView_DeleteAllItems(bwi_hWndListAB);

                //
                // Save the sort info to the registry
                //
                WriteRegistrySortInfo(bwi_lpIAB, bwi_SortInfo);
                SaveCurrentPosition(lpbwi, hWnd,bwi_hWndListAB,bwi_hWndBB,bwi_hWndSB);
                if(bwi_lpfnDismiss)
                {
                    (*bwi_lpfnDismiss)((ULONG_PTR) hWnd, (LPVOID) bwi_lpvDismissContext);
                    bwi_lpfnDismiss = NULL;
                }
                bwi_lpvDismissContext = NULL;
    		    DestroyWindow(hWnd);
                // In case the search window was every shown and the LDAP Client DLL was
                // initialized, we deinitialize it just once to save time, when this
                // window shuts down ...
                {
                    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    DeinitLDAPClientLib();
                    SetCursor(hOldCur);
                }
                OleFlushClipboard();

    		    return 0;
            }
    		break;


        case WM_DESTROY:
            {
                int i = 0;
                LPPTGDATA lpPTGData=GetThreadStoragePointer();

                bwi_lpIAB->hWndBrowse = NULL;

                if(bwi_lpAdviseSink)
                {
                    bwi_lpAdrBook->lpVtbl->Unadvise(bwi_lpAdrBook, bwi_ulAdviseConnection);
                    bwi_lpAdviseSink->lpVtbl->Release(bwi_lpAdviseSink);
                    bwi_lpAdviseSink = NULL;
                    bwi_ulAdviseConnection = 0;
                }

                if (bwi_lpAdrBook)
    		    {
                    ReleasePropertyStore(bwi_lpIAB->lpPropertyStore);
    			    bwi_lpAdrBook->lpVtbl->Release(bwi_lpAdrBook);
    			    bwi_lpAdrBook = NULL;
                    bwi_lpIAB = NULL;
                    pt_lpIAB = NULL;
    		    }

                if (bwi_tt_TooltipTimer)
                    KillTimer(hWnd, bwi_tt_TooltipTimer);

                if (uTimer)
                    KillTimer(hWnd, uTimer);

                if(bwi_hWndAB)
                    DestroyMenu(GetMenu(bwi_hWndAB));


                // reset subclassed procs
                for(i=0;i<s_Max;i++)
                {
    	            SetWindowLongPtr (bwi_s_hWnd[i], GWLP_WNDPROC, (LONG_PTR) bwi_fnOldProc[i]);
                }

                DestroyImageLists(lpbwi);
                CleanUpGlobals(lpbwi);

                LocalFree(lpbwi);
                lpbwi = NULL;
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM) NULL);

                // Delete background brush, WIN16 specific.
                IF_WIN16(DeleteObject(hBrushBack);)
            }
            break;



        case WM_CREATE:
            {
                lpbwi = (LPBWI) ((LPCREATESTRUCT) lParam)->lpCreateParams;
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM) lpbwi);
                bwi_hWndAB = hWnd;
                bwi_lpIAB->hWndBrowse = hWnd;
                CreateAddressBookChildren(lpbwi, hWnd);
    		    InitChildren(lpbwi, hWnd);
                ReadRegistrySortInfo(bwi_lpIAB,&bwi_SortInfo);
                SetPreviousSessionPosition(lpbwi, hWnd, bwi_hWndListAB, bwi_hWndBB,bwi_hWndSB);
                SetColumnHeaderBmp(bwi_hWndListAB, bwi_SortInfo);

                // Tooltip Timer
                bwi_tt_TooltipTimer = SetTimer(hWnd,
                                        WAB_TOOLTIP_TIMER_ID,
                                        WAB_TOOLTIP_TIMER_TIMEOUT,
                                        NULL);

                if(bwi_lpAdviseSink)
                {
                    // Register for notifications
                    bwi_lpAdrBook->lpVtbl->Advise(  bwi_lpAdrBook, 0, NULL, fnevObjectModified, 
                                                bwi_lpAdviseSink, &bwi_ulAdviseConnection); 
                }

/*
                // UI Refresh timer
                uTimer = SetTimer(hWnd,     // handle of window for timer messages
                  WAB_REFRESH_TIMER,          // timer identifier
                  WAB_REFRESH_TIMEOUT,        // time-out value
                  NULL);                      // address of timer procedure
*/
                // Create default background brush, WIN16 only
                IF_WIN16(hBrushBack = CreateSolidBrush (GetSysColor (COLOR_BTNFACE)) ;)

				HrCreateIWABDragDrop(&bwi_lpIWABDragDrop);
				if(bwi_lpIWABDragDrop)
				{
                    bwi_lpIWABDragDrop->m_lpv = (LPVOID) lpbwi;
                    UIOLEInit();
					CoLockObjectExternal((LPUNKNOWN) bwi_lpIWABDragDrop, TRUE, FALSE);
					RegisterDragDrop(bwi_hWndListAB, (LPDROPTARGET) bwi_lpIWABDragDrop->lpIWABDropTarget);
					RegisterDragDrop(bwi_hWndTV, (LPDROPTARGET) bwi_lpIWABDragDrop->lpIWABDropTarget);
				}
                {
                    LPPTGDATA lpPTGData=GetThreadStoragePointer();
                    if(pt_bFirstRun)
                        pt_bFirstRun = FALSE;
                }
            }
            if(bIsThereACurrentUser(bwi_lpIAB))
                UpdateTVGroupSelection(bwi_hWndTV, &(bwi_lpIAB->lpWABCurrentUserFolder->sbEID));
            break;


        case WM_SIZE:
            ResizeAddressBookChildren(lpbwi, hWnd);
            break;


    	case WM_KEYDOWN:
            {
    		    switch(wParam)
    		    {
    		    case VK_TAB:
    			    SetFocus(bwi_s_hWnd[bwi_iFocus]);
    			    return 0;
    			    break;

    		    case VK_ESCAPE:
                    SendMessage(hWnd,WM_CLOSE,0,0L);
    			    return 0;
                    break;
    		    }
            }
    		break;


        case WM_NOTIFY:
    		switch((int) wParam)
    		{
    		case IDC_LISTVIEW:
    			return ProcessListViewMessages(lpbwi, hWnd,uMsg,wParam,lParam);
    			break;
            case IDC_TREEVIEW:
    			return ProcessTreeViewMessages(lpbwi, hWnd,uMsg,wParam,lParam, &ftLast);
                break;
    		}
            switch(((LPNMHDR) lParam)->code)
            {
            case TTN_POP:
                {
                    // Need to turn off the hot item
                    // Find the first selected item in the list view
                    //int nItem = ListView_GetNextItem(bwi_hWndListAB, -1, LVNI_SELECTED);
                    ListView_SetHotItem(bwi_hWndListAB, -1); //nItem);
                }
                break;

            case TTN_SHOW:
                {
                    // Set the hot item
                    ListView_SetHotItem(bwi_hWndListAB, bwi_tt_iItem);
                }
                break;

            case TTN_NEEDTEXT:
                {
                    LPTOOLTIPTEXT lpttt;
                    int nItem = HitTestLVSelectedItem(lpbwi);
                    DebugPrintTrace(( TEXT("Tooltip NeedText\n")));
                    lpttt = (LPTOOLTIPTEXT) lParam;
                    if (nItem != -1)
                    {
                        UpdateTooltipTextBuffer(lpbwi, nItem);
                        lpttt->lpszText = bwi_tt_szTipText;
                    }
                    else
                        lpttt->lpszText = szEmpty;
                }
                break;
            }
    		break;


    	case WM_SETTINGCHANGE:
            // [PaulHi] 3/17/99  Raid 68541  Redraw window with new system settings
            // [PaulHi] 4/19/99 Recompute the font sizes, in case they changed.
            // Fonts used for bolding list items
            DeleteFonts();
            InitFonts();
            // Fonts used for all children windows
            if(pt_hDefFont)
            {
                DeleteObject(pt_hDefFont);
                pt_hDefFont = NULL;
            }
            if(pt_hDlgFont)
            {
                DeleteObject(pt_hDlgFont);
                pt_hDlgFont = NULL;
            }
            EnumChildWindows(hWnd,
                SetChildDefaultGUIFont,
                (LPARAM) PARENT_IS_WINDOW);
            InvalidateRect(hWnd, NULL, TRUE);
            ResizeAddressBookChildren(lpbwi, hWnd);
            // Drop through...
        case WM_SYSCOLORCHANGE:
            {
    		    //Forward any system changes to the list view
		        SendMessage(bwi_hWndListAB, uMsg, wParam, lParam);
		        SetColumnHeaderBmp(bwi_hWndListAB, bwi_SortInfo);
    		    SendMessage(bwi_hWndBB, uMsg, wParam, lParam);
            }
    		break;

#ifndef WIN16 // Disable CONTEXTMENU here.
              // All context menu will be handled notify handler.
    	case WM_CONTEXTMENU:
            {
                if ((HWND)wParam == bwi_hWndListAB)
                {                    
#ifdef COLSEL_MENU 
                    HWND hHeader = ListView_GetHeader(bwi_hWndListAB);
                    POINT pointScreen, pointHeader;
                    DWORD dwPos;
                    char szClass[50];
                    dwPos = GetMessagePos();
                    pointScreen.x = LOWORD(dwPos);
                    pointScreen.y = HIWORD(dwPos);
                    if ( hHeader )
                    {                      
                        HD_HITTESTINFO hdhti;
                        pointHeader = pointScreen;
                        ScreenToClient( hHeader, &pointHeader) ;
                        hdhti.pt = pointHeader;
                        SendMessage( hHeader, HDM_HITTEST, (WPARAM)(0), 
                            (LPARAM)(HD_HITTESTINFO FAR *)&hdhti);                        
                        if( hdhti.flags == HHT_ONHEADER && 
                            (hdhti.iItem == colHomePhone || hdhti.iItem == colOfficePhone) )
                        {
                            lpbwi->iSelColumn = hdhti.iItem;
                            ShowLVContextMenu( lvMainABHeader, bwi_hWndListAB,
                                               NULL, lParam, (LPVOID)IntToPtr(hdhti.iItem), bwi_lpAdrBook, bwi_hWndTV); 
                        }
                        else
                        {
#endif // COLSEL_MENU 
                            ShowLVContextMenu(  lvMainABView,
                                bwi_hWndListAB,
                                NULL, lParam,
                                NULL, bwi_lpAdrBook, bwi_hWndTV);
#ifdef COLSEL_MENU 
                        }
                    }
#endif // COLSEL_MENU 
                }
                else if((HWND)wParam==bwi_hWndTV)
                {
                    HTREEITEM hti = NULL;
                    if(lParam == -1)
                        hti = TreeView_GetSelection(bwi_hWndTV);
                    else
                    {
                        TV_HITTESTINFO tvhti;
                        POINT pt = {LOWORD(lParam), HIWORD(lParam)};
                        ScreenToClient(bwi_hWndTV, &pt);
                        tvhti.pt = pt;
                        hti = TreeView_HitTest(bwi_hWndTV, &tvhti);
                    }
                    
                    if (hti == NULL)
                        return 0;
                    
                    TreeView_SelectDropTarget(bwi_hWndTV, hti);
                    
                    // cache the selected item for later processing 
                    bwi_hti = hti;
                    bwi_lpUserFolder = GetSelectedUserFolder(lpbwi);
                    
                    if(!ShowLVContextMenu(  lvMainABTV,
                        bwi_hWndListAB,
                        NULL, lParam,
                        (LPVOID) bwi_lpUserFolder, bwi_lpAdrBook, bwi_hWndTV))
                    {
                        bwi_hti = NULL;
                    }
                    
                    TreeView_SelectDropTarget(bwi_hWndTV, NULL);
                }
                else
                    return DefWindowProc(hWnd,uMsg,wParam,lParam);
            }
            break;
#endif // !WIN16
            
#ifdef WIN16 // Change Static controls background color
		case WM_CTLCOLOR:
			switch(HIWORD(lParam)) {
            	case CTLCOLOR_STATIC:

                /* Set background to btnface color */
                SetBkColor((HDC) wParam,GetSysColor (COLOR_BTNFACE) );
				return (DWORD)hBrushBack;
        	}
        	return NULL;
#endif
        default:
#ifndef WIN16 // WIN16 doesn't support MSWheel.
            if((g_msgMSWheel && uMsg == g_msgMSWheel) 
//                || uMsg == WM_MOUSEWHEEL
                )
            {
                if(bIsFocusOnTV(lpbwi))
                    SendMessage(bwi_hWndTV, uMsg, wParam, lParam);
                else
                    SendMessage(bwi_hWndListAB, uMsg, wParam, lParam);
                break;
            }
#endif // !WIN16
            return DefWindowProc(hWnd,uMsg,wParam,lParam);
    }

    return 0;
}



//$$
//*------------------------------------------------------------------------
//| CreateAddressBookChildren:
//|
//*------------------------------------------------------------------------
void CreateAddressBookChildren(LPBWI lpbwi, HWND hWndParent)
{
	HINSTANCE hinst = hinstMapiXWAB;
    TCHAR szBuf[MAX_PATH];
    HDC hdc = GetDC(hWndParent);
    int i;
    HFONT hFnt = GetStockObject(DEFAULT_GUI_FONT);
    SIZE size;
#ifdef WIN16
    // Remove bold.
    LOGFONT lf;

    GetObject(hFnt, sizeof(LOGFONT), &lf);
    lf.lfWeight = FW_NORMAL;
    DeleteObject(hFnt);
    LoadString(hinstMapiX, idsDefaultDialogFace, lf.lfFaceName, CharSizeOf(lf.lfFaceName));
    hFnt = CreateFontIndirect(&lf);
#endif


    bwi_hWndBB = CreateCoolBar(lpbwi, hWndParent);


    bwi_hWndSB = CreateWindowEx( 0,
                                STATUSCLASSNAME,
                                szEmpty,
                                WS_CHILD /*| WS_BORDER */| WS_VISIBLE | SBS_SIZEGRIP,
                                0,0,0,0,
                                hWndParent,
                                (HMENU) IDC_STATUSBAR,
                                hinst,
                                NULL);
    SendMessage(bwi_hWndSB, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

    bwi_hWndTV = CreateWindowEx( WS_EX_CLIENTEDGE,
                                WC_TREEVIEW,
                                (LPTSTR) NULL,
                                WS_VISIBLE | WS_CHILD | TVS_HASLINES | TVS_LINESATROOT |
                                TVS_HASBUTTONS | TVS_SHOWSELALWAYS | WS_BORDER,
                                0,0,
                                150, //default width
                                CW_USEDEFAULT,
                                hWndParent,
                                (HMENU) IDC_TREEVIEW,
                                hinst,
                                NULL);
    SendMessage(bwi_hWndTV, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);


	{
#ifndef WIN16
		WNDCLASSEX wc = {0};
#else
		WNDCLASS   wc = {0};
#endif



		bwi_hWndSplitter = CreateWindowEx(0,
										 TEXT("STATIC"),
										szEmpty,
										WS_CHILD | WS_VISIBLE,
										CW_USEDEFAULT,
										CW_USEDEFAULT,
										CW_USEDEFAULT,
										CW_USEDEFAULT,
										hWndParent,
										(HMENU) IDC_SPLITTER,
										hinst,
										NULL);
		SendMessage(bwi_hWndSplitter, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

	}

    bwi_hWndTT = CreateWindowEx( 0,
                                TOOLTIPS_CLASS,
                                (LPTSTR) NULL,
                                TTS_ALWAYSTIP,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                CW_USEDEFAULT,
                                hWndParent,
                                (HMENU) NULL, //IDC_TOOLTIP,
                                hinst,
                                NULL);
    SendMessage(bwi_hWndTT, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);

    // Create main list view
    bwi_hWndListAB = CreateWindowEx (
                               WS_EX_CLIENTEDGE,
                               WC_LISTVIEW,                            // list view class
                               szEmpty,                                 // no default text
                               WS_TABSTOP | WS_HSCROLL | WS_VSCROLL |
    						   WS_VISIBLE | WS_CHILD | //WS_BORDER |
    						   LVS_REPORT | LVS_SHOWSELALWAYS |
    						   //LVS_AUTOARRANGE |
    						   WS_EX_CLIENTEDGE,   // styles
                               0, 0, 0, 0,
                               hWndParent,
                               (HMENU) IDC_LISTVIEW,
                               hinst,
                               NULL);

    //ListView_SetExtendedListViewStyle(bwi_hWndListAB, LVS_EX_HEADERDRAGDROP);

    // create caption for quick find edit box
    ZeroMemory(&size, sizeof(size));
    LoadString(hinstMapiX, idsQuickFindCaption, szBuf, CharSizeOf(szBuf));
    GetTextExtentPoint32(hdc, szBuf, lstrlen(szBuf), &size);

    bwi_hWndStaticQF = CreateWindow(   TEXT("STATIC"),
                                    szBuf,
                                    WS_TABSTOP | WS_CHILD | WS_VISIBLE,
                                    0,0,size.cx,size.cy,
                                    hWndParent,
                                    (HMENU) IDC_STATIC_QUICK_FIND,
                                    hinst,
                                    NULL);
#if 0 // Disable temporarily untile comctlie.dll export this.
#ifdef WIN16
    Ctl3dSubclassCtl(bwi_hWndStaticQF);
#endif
#endif
    SendMessage(bwi_hWndStaticQF, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);
    UpdateWindow(bwi_hWndStaticQF);

    // create quick find edit box
    bwi_hWndEditQF = CreateWindowEx(  WS_EX_CLIENTEDGE,
                                     TEXT("EDIT"),
                                    NULL,
                                    WS_TABSTOP | WS_CHILD | WS_VISIBLE |
                                    ES_AUTOHSCROLL | ES_LEFT | ES_AUTOVSCROLL ,
                                    0,0,
                                    size.cx,size.cy+4,
                                    hWndParent,
                                    (HMENU) IDC_EDIT_QUICK_FIND,
                                    hinst,
                                    NULL);
#if 0 // Disable temporarily untile comctlie.dll export this.
#ifdef WIN16
    Ctl3dSubclassCtl(bwi_hWndEditQF);
#endif
#endif
    SendMessage(bwi_hWndEditQF, WM_SETFONT, (WPARAM) hFnt, (LPARAM) TRUE);
    SendMessage(bwi_hWndEditQF, EM_SETLIMITTEXT,(WPARAM) MAX_DISPLAY_NAME_LENGTH-1,0);



    if (hdc) ReleaseDC(hWndParent,hdc);

    // Sub class some of the controls
    bwi_s_hWnd[s_EditQF] = bwi_hWndEditQF;
    bwi_s_hWnd[s_ListAB] = bwi_hWndListAB;
    bwi_s_hWnd[s_TV]		= bwi_hWndTV;

    for(i=0;i<s_Max;i++)
    {
    	bwi_fnOldProc[i] = (WNDPROC) SetWindowLongPtr (bwi_s_hWnd[i], GWLP_WNDPROC, (LONG_PTR) SubClassedProc);
    }

    SetFocus(bwi_hWndEditQF);

    return;
}





//$$/////////////////////////////////////////////////////////////
//
// ResizeAddressBookChildren(HWND hWndParent)
//
//	Resizing and moving around
//
///////////////////////////////////////////////////////////////
void ResizeAddressBookChildren(LPBWI lpbwi, HWND hWndParent)
{
    RECT rc, rc1;
    int BBx,BBy,BBw,BBh;
    int SBx,SBy,SBw,SBh;
    int QFx,QFy,QFw,QFh;
    int EDx,EDy,EDw,EDh;
    int LVx,LVy,LVw,LVh;
    TCHAR szBuf[MAX_PATH];
    HDC hdc;
    SIZE  size;
	RECT rcTV;
    int TVx=0, TVy=0, TVw=0, TVh=0;
	int TCKx = 0, TCKy=0, TCKw=0, TCKh=0;

    // calculate button, static, and edit sizes from the font.
    hdc = GetDC(hWndParent);

    GetClientRect(hWndParent,&rc);

    GetChildClientRect(bwi_hWndBB,&rc1);

    // Button Bars coordinates
    BBx = BBy = 0; BBw = rc.right; BBh = rc1.bottom - rc1.top;

    if (IsWindowVisible(bwi_hWndBB))
    	MoveWindow(bwi_hWndBB, BBx, BBy,BBw, BBh,TRUE);
    else
    	BBw = BBh = 0;
    if (IsWindowVisible(bwi_hWndTV))
    {
	    GetChildClientRect(bwi_hWndTV, &rcTV);
        TVx = 0;
        TVw = rcTV.right - rcTV.left;
	    TCKx = TVw;
	    TCKw = BORDER;
    }

    // Quick Find labels coordinates
    GetTextExtentPoint32(hdc, szBuf, GetWindowText(bwi_hWndStaticQF, szBuf, CharSizeOf(szBuf)), &size);
    QFx = TVx + TVw + BORDER;
    QFy = BBy+BBh+BORDER;
    QFw = size.cx;
    QFh = size.cy;

    //Edit Box coordinates
    EDx = QFx+QFw+CONTROL_SPACING;
    EDy = QFy;
    QFy += 2;
    GetChildClientRect(bwi_hWndEditQF,&rc1);
    EDh = rc1.bottom - rc1.top;
    EDw = QFw;

    //List View Dimensions
    LVx = TVx + TVw + BORDER;
    LVy = EDy+EDh+BORDER;
    LVw = rc.right - rc.left;// - 2*BORDER;
    LVh = rc.bottom - LVy;// - BORDER;

    // [PaulHi] 3/17/99  Raid 68541
    // We can't just set the status bar height to 14 because in large mode Windows will 
    // draw outside the status bar window (very ugly).  We want the status bar to be
    // smaller than system default so we (safely) subtract six pixels from the height.
    SBx = 0;
    SBh = GetSystemMetrics(SM_CYCAPTION) - 4;
    SBh = (SBh > 0) ? SBh : 14;
    SBy = rc.bottom - SBh;
    SBw = rc.right - rc.left;

    if(IsWindowVisible(bwi_hWndSB))
        LVh = LVh - SBh - 2*BORDER;
    TVy = QFy;
    TVh = rc.bottom - TVy; 
    if(IsWindowVisible(bwi_hWndSB))
        TVh = TVh - SBh - 2*BORDER;
    LVw = LVw - BORDER - TVw;
    if (IsWindowVisible(bwi_hWndTV))
    {
	    TCKy = TVy;
	    TCKh = TVh;
    }

    {
    	HDWP hdwp = BeginDeferWindowPos(6);

    	MoveWindow(bwi_hWndEditQF, EDx, EDy, EDw, EDh, TRUE);

		MoveWindow(bwi_hWndStaticQF, QFx, QFy, QFw, QFh, TRUE);

    	MoveWindow(bwi_hWndListAB, LVx, LVy, LVw, LVh, TRUE);

    	MoveWindow(bwi_hWndSB, SBx, SBy, SBw, SBh, TRUE);

    	if (IsWindowVisible(bwi_hWndTV))
        {
    	    MoveWindow(bwi_hWndTV, TVx, TVy, TVw, TVh, TRUE);
    	    MoveWindow(bwi_hWndSplitter, TCKx, TCKy, TCKw, TCKh, TRUE);
        }

    	EndDeferWindowPos(hdwp);

    }

    ReleaseDC(hWndParent, hdc);

	return;
}




//$$/////////////////////////////////////////////////////////////
//
// Initialize the kid windows
//
///////////////////////////////////////////////////////////////
void InitChildren(LPBWI lpbwi, HWND hWndParent)
{

    HrInitListView(bwi_hWndListAB, LVS_REPORT, TRUE);

    InitMultiLineToolTip(lpbwi, hWndParent);

    {
        HIMAGELIST hSmall = gpfnImageList_LoadImage(   hinstMapiX, 	
                                    MAKEINTRESOURCE(IDB_BITMAP_SMALL),
                                    //(LPCTSTR) ((DWORD) ((WORD) (IDB_BITMAP_SMALL))),
                                    S_BITMAP_WIDTH,
                                    0,
                                    RGB_TRANSPARENT,
                                    IMAGE_BITMAP, 	
                                    0);

        // Associate the image lists with the list view control.
    	TreeView_SetImageList (bwi_hWndTV, hSmall, TVSIL_NORMAL);

        //FillTreeView(bwi_hWndTV, NULL);
    }
    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hWndParent,
                        SetChildDefaultGUIFont,
                        (LPARAM) PARENT_IS_WINDOW);


    SendMessage(hWndParent,WM_COMMAND,IDM_VIEW_DETAILS,0);

    bwi_bDoQuickFilter = TRUE;

    SetFocus(bwi_hWndEditQF);

}





//$$/////////////////////////////////////////////////////////////
//
// Change list views styles and possibly menus also
//
///////////////////////////////////////////////////////////////
void SetListViewStyle(LPBWI lpbwi, int MenuID)
{
    DWORD dwStyle = GetWindowLong(bwi_hWndListAB,GWL_STYLE);
    BOOL bUseCurrentSortSettings = FALSE;

    // Right now we just change the style here
    // later on we can update the menu etc. to reflect the style and

    switch(MenuID)
    {
            case IDM_VIEW_DETAILS:
                if((dwStyle & LVS_TYPEMASK) != LVS_REPORT)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_REPORT);
                break;
            case IDM_VIEW_SMALLICON:
                if((dwStyle & LVS_TYPEMASK) != LVS_SMALLICON)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_SMALLICON);
                break;
            case IDM_VIEW_LARGEICON:
                if((dwStyle & LVS_TYPEMASK) != LVS_ICON)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_ICON);
                break;
            case IDM_VIEW_LIST:
                if((dwStyle & LVS_TYPEMASK) != LVS_LIST)
                    SetWindowLong(bwi_hWndListAB,GWL_STYLE,(dwStyle & ~LVS_TYPEMASK) | LVS_LIST);
                break;
    }

    {
        //
        // If we are not in details view, we dont really want to be able to sort
        // by phone number and email address .. hence we disable those menu
        // options under certain conditions ...
        //
        HMENU hMenuMain = GetMenu(bwi_hWndAB);
        HMENU hMenuView = GetSubMenu(hMenuMain,idmView);
        int nDiff = idmViewMax - GetMenuItemCount(hMenuView); // in case stuff was deleted off this menu
        HMENU hMenu = GetSubMenu(hMenuView, idmSortBy - nDiff);

        if (MenuID == IDM_VIEW_DETAILS)
        {
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_EMAILADDRESS,MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_BUSINESSPHONE,MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_HOMEPHONE,MF_BYCOMMAND | MF_ENABLED);
        }
        else
        {
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_EMAILADDRESS,MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_BUSINESSPHONE,MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hMenu,IDM_VIEW_SORTBY_HOMEPHONE,MF_BYCOMMAND | MF_GRAYED);
        }
    }

    if (MenuID != IDM_VIEW_DETAILS)
    {
        SORT_INFO SortTmp = bwi_SortInfo;
        //hack
        SendMessage(bwi_hWndListAB, WM_SETREDRAW, (WPARAM) FALSE, 0);
        bUseCurrentSortSettings = FALSE;
        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, bUseCurrentSortSettings);
        bwi_SortInfo = SortTmp;
        bwi_SortInfo.iOldSortCol = colDisplayName;
        bUseCurrentSortSettings = TRUE;
        SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, bUseCurrentSortSettings);
        SendMessage(bwi_hWndListAB, WM_SETREDRAW, (WPARAM) TRUE, 0);
    }

    UpdateSortMenus(lpbwi, bwi_hWndAB);


    return;
}


//$$/////////////////////////////////////////////////////////////
//
// Resets the globals in case someone drops by again
//
///////////////////////////////////////////////////////////////
void CleanUpGlobals(LPBWI lpbwi)
{
    if (bwi_lpContentsList)
        FreeRecipList(&bwi_lpContentsList);

    bwi_hWndListAB = NULL;
    bwi_hWndBB = NULL;
    bwi_hWndSB = NULL;
    bwi_hWndEditQF =NULL;
    bwi_hWndStaticQF = NULL;
    bwi_hWndAB = NULL;
    bwi_hWndTT = NULL;
    bwi_tt_bActive = FALSE;
    bwi_tt_iItem = -1;
    bwi_tt_szTipText[0]='\0';
    bwi_tt_TooltipTimer = 0;

	bwi_hWndTV = NULL;
	bwi_hWndSplitter = NULL;
    bwi_bDontRefreshLV = FALSE;
    ReadRegistrySortInfo(bwi_lpIAB, &bwi_SortInfo);

    return;

}

/*
-   bCheckIfOnlyGroupsSelected
-
-   Returns TRUE if all the selected items in the ListView are only Groups (no Contacts)
*
*/
BOOL bCheckIfOnlyGroupsSelected(HWND hWndLV)
{
    int nSelected = ListView_GetSelectedCount(hWndLV);
    int iItemIndex = -1;

    if(nSelected <= 0)
        return FALSE;
    
    while((iItemIndex = ListView_GetNextItem(hWndLV, iItemIndex, LVNI_SELECTED))!= -1)
    {
        // Get the entryid of the selected item
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
        if(lpItem && lpItem->ulObjectType == MAPI_MAILUSER)
            return FALSE;
    }

    return TRUE;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Processes messages for the list view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessListViewMessages(LPBWI lpbwi, HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
    HWND hWndAddr = pNm->hdr.hwndFrom;

    switch(pNm->hdr.code)
    {        
    case LVN_COLUMNCLICK:
        SortListViewColumn(bwi_lpIAB, hWndAddr, pNm->iSubItem, &bwi_SortInfo, FALSE);
        UpdateSortMenus(lpbwi, bwi_hWndAB);
        break;

    case LVN_KEYDOWN:
        UpdateToolbarAndMenu(lpbwi);
        switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
        {
        case VK_DELETE:
            SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_DELETE, 0);
            return 0;
            break;
    	case VK_RETURN:
    		SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
            return 0;
        }
        break;

    //case LVN_ITEMCHANGED:
    case NM_CLICK:
    case NM_RCLICK:
        {
            UpdateToolbarAndMenu(lpbwi);
#ifdef WIN16 // Context menu handler for WIN16           
            if( pNm->hdr.code == NM_RCLICK && pNm->hdr.hwndFrom == bwi_hWndListAB)
            {                
                    POINT pt;                   
                    GetCursorPos(&pt);
                    ShowLVContextMenu( lvMainABView,
                        bwi_hWndListAB,
                        NULL, //bwi_hWndCombo,
                        MAKELPARAM(pt.x, pt.y),
                        NULL,
                        bwi_lpAdrBook, bwi_hWndTV);
            }
#endif // WIN16
        }
    break;

    case NM_SETFOCUS:
        UpdateToolbarAndMenu(lpbwi);
    	break;

    case NM_DBLCLK:
        SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
        return 0;
        break;

    case NM_CUSTOMDRAW:
        return ProcessLVCustomDraw(NULL, lParam, FALSE);
        break;

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        {
            DWORD dwEffect = 0;
            LPIWABDATAOBJECT lpIWABDataObject = NULL;
            bwi_bDontRefreshLV = TRUE; // prevent refreshes as this action is based on the selection
            HrCreateIWABDataObject((LPVOID) lpbwi, bwi_lpAdrBook, bwi_hWndListAB, &lpIWABDataObject, 
                                    FALSE,bCheckIfOnlyGroupsSelected(bwi_hWndListAB));
            if(lpIWABDataObject)
            {
                bwi_lpIWABDragDrop->m_bSource = TRUE;
                DoDragDrop( (LPDATAOBJECT) lpIWABDataObject,
                            (LPDROPSOURCE) bwi_lpIWABDragDrop->lpIWABDropSource,
                            DROPEFFECT_COPY | DROPEFFECT_MOVE,
                            &dwEffect);
                bwi_lpIWABDragDrop->m_bSource = FALSE;
                lpIWABDataObject->lpVtbl->Release(lpIWABDataObject);
            }
            RefreshListView(lpbwi, NULL);
            bwi_bDontRefreshLV = FALSE; // prevent refreshes as this action is based on the selection
        }
        return 0;
        break;
    }


    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


//$$/////////////////////////////////////////////////////////////////////////
//
//
//
///////////////////////////////////////////////////////////////////////////
LRESULT EnforceMinSize(LPBWI lpbwi, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPPOINT lppt = (LPPOINT)lParam;			// lParam points to array of POINTs
    RECT rc1, rc2;

    if(lpbwi)
    {
        if(bwi_hWndEditQF)
        {
    	    GetWindowRect(bwi_hWndEditQF,&rc1);
    	    GetWindowRect(bwi_hWndStaticQF,&rc2);
    	    lppt[3].x  = rc1.right-rc1.left + rc2.right-rc2.left + 2*BORDER;		// Set minimum width
    	    lppt[3].y  = MIN_WINDOW_H;		// Set minimum height
        }
    }
    return DefWindowProc(hWnd, uMsg, wParam, lParam);

}

//$$
//*------------------------------------------------------------------------
//| RefreshListView
//|
//| lpftLast - WAB file time at last update
//*------------------------------------------------------------------------
void RefreshListView(LPBWI lpbwi, LPFILETIME lpftLast)
{
    ULONG ulObjectType = 0;
    LPSBinary lpsbEID = NULL;

    bwi_hti = NULL;
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
    //if(lpsbEID) //root item can have a null entryid - so we default to that item if NULL or err
    {
        // Refresh the groups list
        FillTreeView(lpbwi, bwi_hWndTV, lpsbEID);
        LocalFreeSBinary(lpsbEID);
    }


    // Update the wab file write time so the timer doesn't
    // catch this change and refresh.
    //if (lpftLast) {
    //    CheckChangedWAB(bwi_lpIAB->lpPropertyStore, lpftLast);
    //}

    UpdateSortMenus(lpbwi, bwi_hWndAB);

    UpdateToolbarAndMenu(lpbwi);

    //DoLVQuickFind(bwi_hWndEditQF,bwi_hWndListAB);

    bwi_bDoQuickFilter = FALSE;
    SetWindowText(bwi_hWndEditQF,szEmpty);
    bwi_bDoQuickFilter = TRUE;

    SendMessage(bwi_hWndListAB, WM_SETREDRAW, TRUE, 0L);

    return;
}


//$$
//*------------------------------------------------------------------------
//| SubClassedProc - to subclass child controls
//|
//*------------------------------------------------------------------------
LRESULT CALLBACK SubClassedProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{

    LPBWI lpbwi = (LPBWI) GetWindowLongPtr(GetParent(hWnd), GWLP_USERDATA);

    IF_WIN32(int i = GetWindowLong(hWnd, GWL_ID);)
    IF_WIN16(int i = GetWindowWord(hWnd, GWW_ID);)

    switch(i)
    {
    case IDC_EDIT_QUICK_FIND:
    	i = s_EditQF;
    	break;
    case IDC_LISTVIEW:
    	i = s_ListAB;
        break;
    case IDC_TREEVIEW:
    	i = s_TV;
        break;
    }

    switch (iMsg)
    {
    case WM_KEYDOWN:
    	switch(wParam)
    	{
    	case VK_TAB:
            {
                int max = s_Max;
                if(!IsWindowVisible(bwi_hWndTV)) max--;
        		SetFocus(bwi_s_hWnd[(i + ((GetKeyState(VK_SHIFT) < 0) ? (max-1) : 1)) % (max)]);
            }
    		break;
    	case VK_ESCAPE:
    		SendMessage(bwi_hWndAB,WM_CLOSE,0,0L);
            return 0;
    		break;
    	case VK_RETURN:
    		if (i==s_EditQF)
    			SetFocus(bwi_s_hWnd[(i + ((GetKeyState(VK_SHIFT) < 0) ? (s_Max-1) : 1)) % (s_Max)]);
    		break;
    	}
    	break;

    case WM_CHAR:
    	if (i==s_EditQF  || i==s_TV)
    	{
    		if ((wParam==VK_RETURN) || (wParam==VK_TAB))
    			return 0; //prevents irritating beeps
    	}
    	break;

    case WM_SETFOCUS:
    	bwi_iFocus = i;
    	break;

    case WM_LBUTTONDBLCLK:
        if(i==s_TV)
        {
            SendMessage(bwi_hWndAB, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
            return FALSE;
        }
        break;
    }

    return CallWindowProc(bwi_fnOldProc[i],hWnd,iMsg,wParam,lParam);

}



//$$
//*------------------------------------------------------------------------
//| FindABWindowProc:
//|
//*------------------------------------------------------------------------
STDAPI_(BOOL) FindABWindowProc( HWND hWndToLookAt, LPARAM lParam)
{
    HWND * lphWndTmp = (HWND *) lParam;
    
    TCHAR szBuf[MAX_PATH];

    
    // yuk - need a better way to do this - TBD
    if (*lphWndTmp == NULL)
    {
    	GetClassName(hWndToLookAt, szBuf, CharSizeOf(szBuf));
    	if(!lstrcmpi(g_szClass,szBuf))
    	{
    		// Found our man
    		*lphWndTmp = hWndToLookAt;
    		return FALSE;
    	}
    }
    return TRUE;
}


//$$
//*------------------------------------------------------------------------
//| CallBack used by client to send accelerators to us
//|
//*------------------------------------------------------------------------
BOOL STDMETHODCALLTYPE fnAccelerateMessages(ULONG_PTR ulUIParam, LPVOID lpvmsg)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL bRet = FALSE;
    if(lpvmsg && pt_hAccTable /*&& IsDialogMessage((HWND) ulUIParam,lpvmsg)*/)
    {
        bRet =  TranslateAcceleratorW((HWND) ulUIParam,	// handle of destination window
                                     pt_hAccTable,	        // handle of accelerator table
                                    (LPMSG) lpvmsg 	    // address of structure with message
                                );
    }
    return bRet;
}



//$$
//*------------------------------------------------------------------------
//| Updates the menu item markings whenever we sort ...
//|
//*------------------------------------------------------------------------
void UpdateSortMenus(LPBWI lpbwi, HWND hWnd)
{
    int id;

    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuView = GetSubMenu(hMenuMain,idmView);
    int nDiff = idmViewMax - GetMenuItemCount(hMenuView); // in case stuff was deleted off this menu
    HMENU hMenu = GetSubMenu(hMenuView, idmSortBy - nDiff);

    BOOL bRet;
    //
    // There are several menus to update here ...
    // Sort by  TEXT("Column")
    // Sort by FirstName or LastName
    // Sort Ascending or descending

    switch(bwi_SortInfo.iOldSortCol)
    {
    case colDisplayName:
        id = IDM_VIEW_SORTBY_DISPLAYNAME;
        break;
    case colEmailAddress:
        id = IDM_VIEW_SORTBY_EMAILADDRESS;
        break;
    case colOfficePhone:
        id = IDM_VIEW_SORTBY_BUSINESSPHONE;
        break;
    case colHomePhone:
        id = IDM_VIEW_SORTBY_HOMEPHONE;
        break;
    }
    bRet = CheckMenuRadioItem(	hMenu,
    				IDM_VIEW_SORTBY_DISPLAYNAME,
    				IDM_VIEW_SORTBY_HOMEPHONE,
    				id,
    				MF_BYCOMMAND);


    if (id!=IDM_VIEW_SORTBY_DISPLAYNAME)
    {
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_LASTNAME,MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_FIRSTNAME,MF_BYCOMMAND | MF_GRAYED);
    }
    else
    {
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_LASTNAME,MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem(hMenu,IDM_VIEW_SORTBY_FIRSTNAME,MF_BYCOMMAND | MF_ENABLED);
    }

    id = (bwi_SortInfo.bSortByLastName) ? IDM_VIEW_SORTBY_LASTNAME : IDM_VIEW_SORTBY_FIRSTNAME;

    bRet = CheckMenuRadioItem(	hMenu,
    				IDM_VIEW_SORTBY_FIRSTNAME,
    				IDM_VIEW_SORTBY_LASTNAME,
    				id,
    				MF_BYCOMMAND);

    id = (bwi_SortInfo.bSortAscending) ? IDM_VIEW_SORTBY_ASCENDING : IDM_VIEW_SORTBY_DESCENDING;

    bRet = CheckMenuRadioItem(	hMenu,
    				IDM_VIEW_SORTBY_ASCENDING,
    				IDM_VIEW_SORTBY_DESCENDING,
    				id,
    				MF_BYCOMMAND);


    return;
}

///////////////////////////////////////////////////////////////////////////
//
// Updates the toolbar based on the contents of the list box
//
//
///////////////////////////////////////////////////////////////////////////
void UpdateToolbarAndMenu(LPBWI lpbwi)
{

    //
    // Toolbar Button States
    //
    // Y: Enabled
    // N: Disabled
    //
    //                  non-Empty-WAB   Empty-WAB   non-EmptyLDAP   EmptyLDAP
    // New                  Y               Y           N               N
    // Properties           Y               N           Y               N
    // Delete               Y               N           N               N
    // Search               Y               Y           Y               Y
    // Add to WAB           N               N           Y               N
    // Print                Y               N           Y               N
    // SendMail             Y               N           Y               N

    BOOL bState[tbMAX];
    int i;

	// if the current focus is on a group, all the above can be selected
	// else depends on the list view

    if(bIsFocusOnTV(lpbwi))
	{
		for(i=0;i<tbMAX;i++)
			bState[i] = TRUE;
		// if there are no items in this group, tag it so
		if(ListView_GetItemCount(bwi_hWndListAB) <= 0)
			bState[tbPrint] = /*bState[tbAction] =*/ FALSE;

		// [PaulHi] 11/23/98  Raid #12453
		// Allow pasting into the Tree View
        // bState[tbCopy] = bState[tbPaste] = FALSE;
		bState[tbCopy] = FALSE;
		bState[tbPaste] = bIsPasteData();
	}
	else
    {
        GetCurrentOptionsState( NULL, bwi_hWndListAB, bState);
    }
    
//    if( (bDoesThisWABHaveAnyUsers(bwi_lpIAB)) &&
//        TreeView_GetSelection(bwi_hWndTV) == TreeView_GetRoot(bwi_hWndTV))
//        bState[tbNewFolder] = FALSE;

    // Set the toolbar button states
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_NEW,(LPARAM) MAKELONG(bState[tbNew], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_PROPERTIES,(LPARAM) MAKELONG(bState[tbProperties], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_DELETE,(LPARAM) MAKELONG(bState[tbDelete], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_FIND,(LPARAM) MAKELONG(bState[tbFind], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_PRINT,(LPARAM) MAKELONG(bState[tbPrint], 0));
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_ACTION,(LPARAM) MAKELONG(bState[tbAction], 0));

#ifdef WIN16 // WIN16FF:Disable find button of coolbar. Find is not beta1 feature
    SendMessage(bwi_hWndBB,WM_PRVATETOOLBARENABLE,(WPARAM) IDC_BB_FIND,(LPARAM)MAKELONG(0, 0));
#endif

    //
    // We also need to synchronize the menus with the toolbar ...
    //

    {
        HMENU hMenuMain = GetMenu(bwi_hWndAB);
        HMENU hMenuSub = GetSubMenu(hMenuMain,idmFile);
        UINT  uiFlag[tbMAX];

        for(i=0;i<tbMAX;i++)
            uiFlag[i] = (bState[i] ? MF_ENABLED : MF_GRAYED);

        EnableMenuItem(hMenuSub,IDM_FILE_NEWCONTACT,MF_BYCOMMAND | uiFlag[tbNewEntry]);
        EnableMenuItem(hMenuSub,IDM_FILE_NEWGROUP,  MF_BYCOMMAND | uiFlag[tbNewGroup]);
        EnableMenuItem(hMenuSub,IDM_FILE_NEWFOLDER, MF_BYCOMMAND | uiFlag[tbNewFolder]);
        EnableMenuItem(hMenuSub,IDM_FILE_DELETE,    MF_BYCOMMAND | uiFlag[tbDelete]);
        EnableMenuItem(hMenuSub,IDM_FILE_PROPERTIES,MF_BYCOMMAND | uiFlag[tbProperties]);
        //EnableMenuItem(hMenuSub,IDM_FILE_ADDTOWAB,  MF_BYCOMMAND | uiFlag[tbAddToWAB]);
        //EnableMenuItem(hMenuSub,IDM_FILE_SENDMAIL,  MF_BYCOMMAND | uiFlag[tbAction]);
    
        if(bPrintingOn)
            EnableMenuItem(hMenuSub,IDM_FILE_PRINT,  MF_BYCOMMAND | uiFlag[tbPrint]);

        hMenuSub = GetSubMenu(hMenuMain,idmEdit);
        EnableMenuItem(hMenuSub,IDM_EDIT_COPY,  MF_BYCOMMAND | uiFlag[tbCopy]);
        EnableMenuItem(hMenuSub,IDM_EDIT_PASTE,  MF_BYCOMMAND | uiFlag[tbPaste]);
#ifdef WIN16 // WIN16FF:FIND is not beta1 feature
        EnableMenuItem(hMenuSub,IDM_EDIT_FIND,  MF_BYCOMMAND | MF_GRAYED);
#else
        EnableMenuItem(hMenuSub,IDM_EDIT_FIND,  MF_BYCOMMAND | uiFlag[tbFind]);
#endif

        //hMenuSub = GetSubMenu(hMenuMain,idmTools);
    }

    ShowLVCountinStatusBar(lpbwi);

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// SaveCurrentPosition
//
// Saves the modeless dialog window position and the list view column sizes ...
//
//////////////////////////////////////////////////////////////////////////////////
void SaveCurrentPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    int i;
    RECT rect;

    //
    // First read the previous settings from the registry so we dont
    // overwrite something if we dont need to ...
    //
    ReadRegistryPositionInfo(bwi_lpIAB, &ABPosColSize, lpszRegPositionKeyValueName);

    {
        WINDOWPLACEMENT wpl = {0};
        wpl.length = sizeof(WINDOWPLACEMENT);

        // This call tells us the window state and normal size and position
        GetWindowPlacement(hWnd, &wpl);

        // There seems to be a bug in GetWindowPlacement that
        // doesnt account for various taskbars on the screen when
        // returning the Window's Normal Position .. as a result
        // the stored coordinates won't be accurate. Instead, we'll
        // use those coordinates only if the window is maximized or
        // minimized - otherwise we will use the GetWindowRect
        // coordinates.

        // Get the screen position of this window
        GetWindowRect(hWnd, &(ABPosColSize.rcPos));

        if(wpl.showCmd != SW_SHOWNORMAL)
        {
            ABPosColSize.rcPos = wpl.rcNormalPosition;
        }
    }

    // Check the current List View Style
    ABPosColSize.dwListViewStyle = GetWindowLong(hWndLV, GWL_STYLE);

    if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_REPORT )
    {
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_DETAILS;
        // get column widths only if this is the details style otherwise
        // not ...
        for(i=0; i<NUM_COLUMNS; i++)
        {
            int nCol = ListView_GetColumnWidth(hWndLV, i);
            if(nCol!=0)
                ABPosColSize.nColWidth[i] = nCol;
        }
    }
    else if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_SMALLICON )
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_SMALLICON;
    else if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_ICON )
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_LARGEICON;
    else if( (ABPosColSize.dwListViewStyle & LVS_TYPEMASK) == LVS_LIST )
        ABPosColSize.nListViewStyleMenuID = IDM_VIEW_LIST;

    if (IsWindowVisible(hWndTB))
    	ABPosColSize.bViewToolbar = TRUE;
    else
    	ABPosColSize.bViewToolbar = FALSE;

    if (IsWindowVisible(hWndSB))
    	ABPosColSize.bViewStatusBar = TRUE;
    else
    	ABPosColSize.bViewStatusBar = FALSE;

    {
        if (IsWindowVisible(bwi_hWndTV))
    	    ABPosColSize.bViewGroupList = TRUE;
        else
    	    ABPosColSize.bViewGroupList = FALSE;
    }
    ListView_GetColumnOrderArray(hWndLV, NUM_COLUMNS, ABPosColSize.colOrderArray);        
    GetWindowRect( bwi_hWndTV, &rect );
    ABPosColSize.nTViewWidth = rect.right - rect.left;
    WriteRegistryPositionInfo(bwi_lpIAB, &ABPosColSize,lpszRegPositionKeyValueName);

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// SetPreviousSessionPosition
//
// Sets the modeless dialog window position and the list view column sizes based on
//  the previous sessions parameters ...
//
//////////////////////////////////////////////////////////////////////////////////
void SetPreviousSessionPosition(LPBWI lpbwi, HWND hWnd, HWND hWndLV, HWND hWndTB, HWND hWndSB)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    int i;
    RECT rect;

    ABPosColSize.bViewGroupList =TRUE; // Off by default

    if(ReadRegistryPositionInfo(bwi_lpIAB, &ABPosColSize, lpszRegPositionKeyValueName))
    {
        rect.left = ABPosColSize.rcPos.left;
        rect.top =  ABPosColSize.rcPos.top;
        rect.right = ABPosColSize.rcPos.right;
        rect.bottom = ABPosColSize.rcPos.bottom;
        if( IsWindowOnScreen( &rect ) )                      
        {
            MoveWindow(hWnd,
                   ABPosColSize.rcPos.left,
                   ABPosColSize.rcPos.top,
                   ABPosColSize.rcPos.right-ABPosColSize.rcPos.left,
                   ABPosColSize.rcPos.bottom-ABPosColSize.rcPos.top,
                   FALSE);
        }

        for(i=0; i<NUM_COLUMNS; i++)
        {
            if(ABPosColSize.nColWidth[i]!=0)
                ListView_SetColumnWidth(hWndLV, i, ABPosColSize.nColWidth[i]);
        }

    	if(ABPosColSize.bViewToolbar == FALSE)
        {
    		//hide it
    		CheckMenuItem(GetMenu(hWnd),IDM_VIEW_TOOLBAR,MF_BYCOMMAND | MF_UNCHECKED);
    		ShowWindow(hWndTB, SW_HIDE);
        }

    	if(ABPosColSize.bViewStatusBar == FALSE)
        {
    		//hide it
    		CheckMenuItem(GetMenu(hWnd),IDM_VIEW_STATUSBAR,MF_BYCOMMAND | MF_UNCHECKED);
    		ShowWindow(hWndSB, SW_HIDE);
        }
        GetWindowRect( bwi_hWndTV, &rect );
        if( ABPosColSize.nTViewWidth != 0 )
            MoveWindow( bwi_hWndTV, rect.left, rect.top, ABPosColSize.nTViewWidth, rect.bottom - rect.top, FALSE );
    	ResizeAddressBookChildren(lpbwi, hWnd);//,SIZE_RESTORED);

        if (ABPosColSize.nListViewStyleMenuID != 0)
        {
            SetListViewStyle(lpbwi, ABPosColSize.nListViewStyleMenuID);
    		CheckMenuRadioItem(	GetMenu(hWnd),
    							IDM_VIEW_LARGEICON,
    							IDM_VIEW_DETAILS,
    							ABPosColSize.nListViewStyleMenuID,
    							MF_BYCOMMAND);

        }

        {
            int nTotal=0,nColSum=0;
            // the previous version did not have the column order setting, so if the
            // values are incorrect reset them
            for(i=0;i<NUM_COLUMNS;i++)
            {
                nTotal += ABPosColSize.colOrderArray[i];
                nColSum += i;
            }
            if(nColSum != nTotal)
            {
                for(i=0;i<NUM_COLUMNS;i++)
                    ABPosColSize.colOrderArray[i] = i;
            }

        }
        ListView_SetColumnOrderArray(hWndLV, NUM_COLUMNS, ABPosColSize.colOrderArray);

    }

    if(ABPosColSize.bViewGroupList == FALSE)
    {
    	//hide it
    	CheckMenuItem(GetMenu(hWnd),IDM_VIEW_GROUPSLIST,MF_BYCOMMAND | MF_UNCHECKED);
    	ShowWindow(bwi_hWndTV, SW_HIDE);
    	ShowWindow(bwi_hWndSplitter, SW_HIDE);
        InvalidateRect(bwi_hWndStaticQF, NULL, TRUE);
        // folder not on the Shared Contacts
        if(bIsThereACurrentUser(bwi_lpIAB))
        {
            LPSBinary lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;
            UpdateTVGroupSelection(bwi_hWndTV, lpsbSelection);
        }
        else
        {
            // Set the selection to the root address book so we see the file
            // contents just as if we dont have a treeview at all
            TreeView_SelectItem(bwi_hWndTV, TreeView_GetRoot(bwi_hWndTV));
        }
    }

    return;
}

#define MAX_TOOLTIP_LENGTH  300
#define TOOLTIP_INITTIME    5000 //milliseconds
#define TOOLTIP_TIME        8000 //milliseconds

//$$/////////////////////////////////////////////////////////////////////////////
//
// void UpdateTooltipTextBuffer - Updates the text in the buffer for the tooltip
//
////////////////////////////////////////////////////////////////////////////////
void UpdateTooltipTextBuffer(LPBWI lpbwi, int nItem)
{

    LPTSTR lpszData = NULL;

    bwi_tt_iItem = nItem;
    bwi_tt_szTipText[0]='\0';

    HrGetLVItemDataString(bwi_lpAdrBook, bwi_hWndListAB, nItem, &lpszData);

    if(lpszData)
    {
        if (CharSizeOf(bwi_tt_szTipText) < (lstrlen(lpszData)+1))
        {
            LPTSTR lpsz = TEXT(" ...");
            ULONG nLen = TruncatePos(lpszData, CharSizeOf(bwi_tt_szTipText) - lstrlen(lpsz) - 1);
            CopyMemory(bwi_tt_szTipText, lpszData, sizeof(TCHAR)*nLen);
            bwi_tt_szTipText[nLen]='\0';
            StrCatBuff(bwi_tt_szTipText,lpsz, ARRAYSIZE(bwi_tt_szTipText));
        }
        else
            StrCpyN(bwi_tt_szTipText, lpszData, ARRAYSIZE(bwi_tt_szTipText));
    }

    LocalFreeAndNull(&lpszData);

    return;
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// void InitMultiLineTooltip - initializes the multiline tooltip for the list view
// control
//
////////////////////////////////////////////////////////////////////////////////
void InitMultiLineToolTip(LPBWI lpbwi, HWND hWndParent)
{
    TOOLINFO ti = {0};
    bwi_tt_bActive = FALSE;
    bwi_tt_iItem = -1;
    bwi_tt_szTipText[0]='\0';
    FillTooltipInfo(lpbwi, &ti);
    SendMessage(bwi_hWndTT, TTM_SETMAXTIPWIDTH, 0, (LPARAM) MAX_TOOLTIP_LENGTH);
    ToolTip_AddTool(bwi_hWndTT, (LPARAM) (LPTOOLINFO) &ti);
    SendMessage(bwi_hWndTT, TTM_SETDELAYTIME, (WPARAM) TTDT_INITIAL, (LPARAM) TOOLTIP_INITTIME);
    SendMessage(bwi_hWndTT, TTM_SETDELAYTIME, (WPARAM) TTDT_RESHOW, (LPARAM) TOOLTIP_INITTIME);
    SendMessage(bwi_hWndTT, TTM_SETDELAYTIME, (WPARAM) TTDT_AUTOPOP, (LPARAM) TOOLTIP_TIME);
    SendMessage(bwi_hWndTT, TTM_ACTIVATE, (WPARAM) TRUE, 0);
    if(!bwi_tt_bActive)
    {
        // if the tooltip is not active, activate it
        TOOLINFO ti = {0};
        FillTooltipInfo(lpbwi, &ti);
        ti.lpszText = szEmpty; //LPSTR_TEXTCALLBACK;
        ToolTip_UpdateTipText(bwi_hWndTT, (LPARAM)&ti);
        SendMessage(bwi_hWndTT, TTM_TRACKACTIVATE,(WPARAM)TRUE,(LPARAM)&ti);
        bwi_tt_bActive = TRUE;
    }

    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// void FillTooltipInfo - initializes the tooltip structure for making updates or
//  modifications to the tooltips
//
////////////////////////////////////////////////////////////////////////////////
void FillTooltipInfo(LPBWI lpbwi, LPTOOLINFO lpti)
{
    lpti->cbSize = sizeof(TOOLINFO);
    lpti->hwnd = bwi_hWndAB;
    lpti->uId = (UINT_PTR) bwi_hWndListAB;
    lpti->hinst = hinstMapiX;
    lpti->uFlags = TTF_IDISHWND | TTF_SUBCLASS;// | TTF_ABSOLUTE | TTF_TRACK;
    lpti->lpszText = szEmpty;//LPSTR_TEXTCALLBACK;
    lpti->lParam = 0;
    return;
}



//$$/////////////////////////////////////////////////////////////////////////////
//
// int HitTestLVSelectedItem() - Gets the item index number of the item exactly under
// the mouse - further selects the item if it isnt selected
//
////////////////////////////////////////////////////////////////////////////////
int HitTestLVSelectedItem(LPBWI lpbwi)
{
    POINT pt;
    RECT rc;
    int nItemIndex = -1;
    LV_HITTESTINFO lht = {0};

    GetCursorPos(&pt);
    GetWindowRect(bwi_hWndListAB, &rc);

    lht.pt.x = pt.x - rc.left;
    lht.pt.y = pt.y - rc.top;

    ListView_HitTest(bwi_hWndListAB, &lht);

    if(lht.iItem != -1)
        nItemIndex = lht.iItem;

    return nItemIndex;
}


/***********************************************************
    Handle_WM_INITMENUPOPUP
    
      Handles any popup menu's we need to modify ..

***********************************************************/
void Handle_WM_INITMENUPOPUP (HWND hWnd, LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam )
{
    HMENU hMenuPopup = (HMENU) uParam;
    UINT  uPos = (UINT) LOWORD(lParam);
    BOOL  fSysMenu = (BOOL) HIWORD(lParam);

    // Look at the first item on the menu to identify it
    UINT uID = GetMenuItemID(hMenuPopup, 0);

    if(uID == IDM_FILE_SENDMAIL) // this is the Tools | Action Menu
    {
        AddExtendedMenuItems(bwi_lpAdrBook, bwi_hWndListAB, 
                             hMenuPopup, TRUE, 
                             (!bIsFocusOnTV(lpbwi))); // this is the condition for updating SendMailTo
    }
    else
    if(uID == IDM_EDIT_COPY)
    {
        UpdateToolbarAndMenu(lpbwi);
    }
    else
    if(uID == IDM_FILE_NEWCONTACT)
    {
        if(bDoesThisWABHaveAnyUsers(bwi_lpIAB))
            UpdateViewFoldersMenu(lpbwi, hWnd);
    }

    UpdateSynchronizeMenus(hMenuPopup, bwi_lpIAB);

/*
    else if(uID == IDM_FILE_NEWCONTACT)
    {
        if(!bIsThereACurrentUser(bwi_lpIAB))
            EnableMenuItem(hMenuPopup, IDM_FILE_SWITCHUSERS, MF_GRAYED | MF_BYCOMMAND);
    }
*/
}


/***********************************************************
   The Handle_WM_MENSELECT function below is a pared down
   cheezy sample to figure out the ID of the currently selected
   menu. It returns 0 if a popup menu is selected, -1 of no menu
   is selected (i.e. closed), and a positive nonzero value
   if a menu item is selected.
***********************************************************/
void Handle_WM_MENSELECT (LPBWI lpbwi, UINT message, WPARAM uParam, LPARAM lParam )
{
    UINT   nStringID = 0;
    TCHAR sz[MAX_UI_STR];

    UINT   fuFlags = (UINT)HIWORD(uParam) & 0xffff;
    UINT   uCmd    = (UINT)LOWORD(uParam);
    HMENU  hMenu   = (HMENU)lParam;

    nStringID = 0;

    sz[0] = TEXT('\0');

    if (fuFlags == 0xffff && hMenu == NULL)     // Menu has been closed
        nStringID = (UINT)-1;
    else if (fuFlags & MFT_SEPARATOR)           // Ignore separators
        nStringID = 0;
    else if (fuFlags & MF_POPUP)                // Popup menu
    {
        nStringID = 0;
        if (fuFlags & MF_SYSMENU)               // System menu
            nStringID = 0;
    }  // for MF_POPUP
    else                                        // Must be a command item
    {
        switch(uCmd)
        {
        case IDC_BB_PRINT:
        case IDM_FILE_PRINT:
            nStringID = idsPrintMenu;
            break;

        case IDM_VIEW_GROUPSLIST:
            nStringID = idsGroupListMenu;
            break;

        case IDM_HELP_ABOUTADDRESSBOOK:
            nStringID = idsAboutMenu;
            break;

        case IDM_LVCONTEXT_NEWCONTACT:
        case IDM_FILE_NEWCONTACT:
            nStringID = idsMenuNewContact;
            break;

        case IDM_LVCONTEXT_NEWGROUP:
        case IDM_FILE_NEWGROUP:
            nStringID = idsMenuNewGroup;
            break;

        case IDM_LVCONTEXT_NEWFOLDER:
        case IDM_FILE_NEWFOLDER:
            nStringID = idsMenuNewFolder;
            break;

        case IDM_LVCONTEXT_COPY:
        case IDM_EDIT_COPY:
            nStringID = idsMenuCopy;
            break;

        case IDM_LVCONTEXT_PASTE:
        case IDM_EDIT_PASTE:
            nStringID = idsMenuPaste;
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDM_FILE_PROPERTIES:
            nStringID = idsMenuProperties;
            break;

        case IDM_LVCONTEXT_DELETE:
        case IDM_FILE_DELETE:
            nStringID = idsMenuDeleteRemove;
            break;

        //case IDM_FILE_ADDTOWAB:
        //case IDM_LVCONTEXT_ADDTOWAB:
        //    nStringID = idsMenuAddToWAB;
        //    break;

        case IDM_LVCONTEXT_FIND:
        case IDM_EDIT_FIND:
            nStringID = idsMenuFind;
            break;

        case IDM_FILE_DIRECTORY_SERVICE:
            nStringID = idsMenuDirectoryService;
            break;

        case IDM_FILE_SWITCHUSERS:
            nStringID = idsMenuSwitchUser;
            break;

        case IDM_FILE_SHOWALLCONTENTS:
            nStringID = idsMenuShowAllContents;
            break;

        case IDM_FILE_EXIT:
            nStringID = idsMenuExit;
            break;

        case IDM_EDIT_SELECTALL:
            nStringID = idsMenuSelectAll;
            break;

        case IDM_VIEW_TOOLBAR:
            nStringID = idsMenuViewToolbar;
            break;

        case IDM_VIEW_STATUSBAR:
            nStringID = idsMenuViewStatusBar;
            break;

        case IDM_VIEW_LARGEICON:
            nStringID = idsMenuLargeIcon;
            break;


        case IDM_VIEW_SMALLICON:
            nStringID = idsMenuSmallIcon;
            break;

        case IDM_VIEW_LIST:
            nStringID = idsMenuList;
            break;

        case IDM_VIEW_DETAILS:
            nStringID = idsMenuDetails;
            break;

        case IDM_VIEW_SORTBY_DISPLAYNAME:
            nStringID = idsMenuDisplayName;
            break;

        case IDM_VIEW_SORTBY_EMAILADDRESS:
            nStringID = idsMenuEmail;
            break;

        case IDM_VIEW_SORTBY_BUSINESSPHONE:
            nStringID = idsMenuBusinessPhone;
            break;

        case IDM_VIEW_SORTBY_HOMEPHONE:
            nStringID = idsMenuHomePhone;
            break;

        case IDM_VIEW_SORTBY_FIRSTNAME:
            nStringID = idsMenuFirstName;
            break;

        case IDM_VIEW_SORTBY_LASTNAME:
            nStringID = idsMenuLastName;
            break;

        case IDM_VIEW_SORTBY_ASCENDING:
            nStringID = idsMenuAscending;
            break;

        case IDM_VIEW_SORTBY_DESCENDING:
            nStringID = idsMenuDescending;
            break;

        case IDM_VIEW_REFRESH:
            nStringID = idsMenuRefresh;
            break;

        case IDM_TOOLS_IMPORT_WAB:
            nStringID = idsMenuImportWAB;
            break;

        case IDM_TOOLS_IMPORT_VCARD:
            nStringID = idsMenuImportVcard;
            break;

        case IDM_TOOLS_IMPORT_OTHER:
            nStringID = idsMenuImportOther;
            break;

        case IDM_TOOLS_EXPORT_OTHER:
            nStringID = idsMenuExportOther;
            break;

        case IDM_TOOLS_EXPORT_WAB:
            nStringID = idsMenuExportWAB;
            break;

        case IDM_TOOLS_EXPORT_VCARD:
            nStringID = idsMenuExportVcard;
            break;

        case IDM_HELP_ADDRESSBOOKHELP:
            nStringID = idsMenuHelp;
            break;

        case IDM_EDIT_SETME:
            nStringID = idsMenuEditProfile;
            break;

        default:
            nStringID = 0;
            GetContextMenuExtCommandString(bwi_lpIAB, uCmd, sz, CharSizeOf(sz));
            break;
        }
    }

    if (nStringID > 0)
    {
       LoadString(hinstMapiX, nStringID, sz, ARRAYSIZE(sz));
    }

    StatusBarMessage(lpbwi, sz);

    return;
}



//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Fills a lpList from the contents of a given group
// If lpList is NULL, ignores that parameter
// If lpszName is NULL, ignores that parameter
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT FillListFromGroup(
                        LPADRBOOK lpAdrBook,
                        ULONG cbGroupEntryID, 
                        LPENTRYID lpGroupEntryID,
                        LPTSTR lpszName,
                        ULONG cchName,
                        LPRECIPIENT_INFO * lppList)
{
	ULONG ulcPropCount;
    LPSPropValue lpPropArray = NULL;
    ULONG j;
	HRESULT hr = E_FAIL;
    LPRECIPIENT_INFO lpInfo = NULL;

    hr = HrGetPropArray( lpAdrBook, NULL,
                    cbGroupEntryID, (LPENTRYID) lpGroupEntryID,
                    MAPI_UNICODE,
                    &ulcPropCount, &lpPropArray);
    if (HR_FAILED(hr))
        goto exit;

    if(lppList && *lppList)
        FreeRecipList(lppList);

    for(j=0;j<ulcPropCount;j++)
    {
        // We are ignoring PR_WAB_DL_ONEOFFS here since we don't want to show OneOffs
        if( lpPropArray[j].ulPropTag==PR_WAB_DL_ENTRIES  && lppList )
        {
            ULONG k;

            // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
            for (k = 0; k < lpPropArray[j].Value.MVbin.cValues; k++)
            {
                ULONG cbEID = lpPropArray[j].Value.MVbin.lpbin[k].cb;
                {
                    LPENTRYID lpEID = (LPENTRYID)lpPropArray[j].Value.MVbin.lpbin[k].lpb;

                    // we don't want one-offs showing up in the UI because all kinds of problems start happening
                    // when these one-offs are dragged and dropped
                    // A doublecheck here not really needed in 99% cases
                    if(WAB_ONEOFF == IsWABEntryID(cbEID, lpEID, NULL, NULL, NULL, NULL, NULL))
                        continue;

                    ReadSingleContentItem( lpAdrBook,cbEID, (LPENTRYID)lpEID, &lpInfo);
                    if(lpInfo)
                    {
						lpInfo->lpNext = *lppList;
                        if(*lppList)
							(*lppList)->lpPrev = lpInfo;
                        *lppList = lpInfo;
                    }
                }
            }
        }
        else if (lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
        {
            if(lpszName)
                StrCpyN(lpszName, lpPropArray[j].Value.LPSZ, cchName);
        }
    }

    hr = S_OK;

exit:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return(hr);

}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// UpdateListViewContents(lpsbEID)
//
// Updates the displayed list in the list view based on the entry id of the selected
// TreeView item
//
//////////////////////////////////////////////////////////////////////////////////////////
void UpdateListViewContents(LPBWI lpbwi, LPSBinary lpsbEID, ULONG ulObjectType)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if( (ulObjectType == MAPI_ABCONT && (pt_bIsWABOpenExSession || bIsWABSessionProfileAware(bwi_lpIAB)))//a folder and it's outlook or profiles are enabled 
        || !lpsbEID || !lpsbEID->cb || !lpsbEID->lpb )// or no container entryid 
    {
        HrGetWABContents(   bwi_hWndListAB,
                            bwi_lpAdrBook,
                            lpsbEID,
                            bwi_SortInfo,
                            &(bwi_lpContentsList));
    }
    else if(ulObjectType == MAPI_DISTLIST )
    {
		if(!HR_FAILED(  FillListFromGroup(  
                            bwi_lpAdrBook,
                            lpsbEID->cb,
                            (LPENTRYID) lpsbEID->lpb,
							NULL,
                            0,
							&(bwi_lpContentsList))))
        {
		    int nSelectedItem = ListView_GetNextItem(bwi_hWndListAB, -1, LVNI_SELECTED);

			if(nSelectedItem < 0)
				nSelectedItem = 0;

            ListView_DeleteAllItems(bwi_hWndListAB);
            if (!HR_FAILED(HrFillListView(	bwi_hWndListAB,
										    bwi_lpContentsList)))
	        {
                SendMessage(bwi_hWndListAB, WM_SETREDRAW, FALSE, 0);
                SortListViewColumn(bwi_lpIAB, bwi_hWndListAB, colDisplayName, &bwi_SortInfo, TRUE);
                SendMessage(bwi_hWndListAB, WM_SETREDRAW, TRUE, 0);
            }

			if(nSelectedItem >= ListView_GetItemCount(bwi_hWndListAB))
				nSelectedItem = ListView_GetItemCount(bwi_hWndListAB)-1;
		    LVSelectItem(bwi_hWndListAB, nSelectedItem);

        }
    }

    ShowLVCountinStatusBar(lpbwi);

    return;
}
                    

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// UpdateTVGroupSelection(HWND hWndTV, lpsbSelectEID)
//
// Updates the selected item on the TreeView to point to the item having the given
// entryid
//
//////////////////////////////////////////////////////////////////////////////////////////
void UpdateTVGroupSelection(HWND hWndTV, LPSBinary lpsbSelectEID)
{

    // search for the specified group and select it ..
    HTREEITEM hRoot = TreeView_GetRoot(hWndTV);

    if(!lpsbSelectEID || !lpsbSelectEID->cb || !lpsbSelectEID->lpb)
    {
        //if(!bIsSelectedTVContainer(lpbwi))
            TreeView_SelectItem(hWndTV, hRoot); //Select the Address Book
    }
    else
    {
        BOOL bSet = FALSE;
        TV_ITEM tvI = {0};

        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        while(hRoot && !bSet)
        {
            HTREEITEM hItem = TreeView_GetChild(hWndTV, hRoot);

            tvI.hItem = hRoot;
            TreeView_GetItem(hWndTV, &tvI);
            if(tvI.lParam)
            {
                LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
                if( lptvStuff && lptvStuff->lpsbEID && lptvStuff->lpsbEID->cb &&
                    !memcmp(lptvStuff->lpsbEID->lpb,lpsbSelectEID->lpb,lpsbSelectEID->cb))
                {
                    TreeView_SelectItem(hWndTV, hRoot); 
                    break;
                }
            }
            while(hItem)
            {
                tvI.hItem = hItem;
                TreeView_GetItem(hWndTV, &tvI);
                if(tvI.lParam)
                {
                    LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
                    
                    if( lptvStuff && lptvStuff->lpsbEID && lptvStuff->lpsbEID->cb &&
                        !memcmp(lptvStuff->lpsbEID->lpb,lpsbSelectEID->lpb,lpsbSelectEID->cb))
                    {
                        bSet = TRUE;
                        TreeView_SelectItem(hWndTV, hItem); //Select the Address Book
                        break;
                    }
                }
                hItem = TreeView_GetNextSibling(hWndTV, hItem);
            }
            hRoot = TreeView_GetNextSibling(hWndTV, hRoot);
        }
    }
    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the currently selected tree view item is a container item
// Returns true if it is a container item .. this way we can distinguish between 
// groups and folders/containers
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL bIsSelectedTVContainer(LPBWI lpbwi)
{
    HTREEITEM hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(bwi_hWndTV);
    TV_ITEM tvI = {0};
    tvI.mask = TVIF_PARAM | TVIF_HANDLE;
    tvI.hItem = hItem;
    TreeView_GetItem(bwi_hWndTV, &tvI);
    if(tvI.lParam)
        return (((LPTVITEM_STUFF)tvI.lParam)->ulObjectType==MAPI_ABCONT);
    return TRUE;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Checks if the focus is on the TreeView or not
//
//////////////////////////////////////////////////////////////////////////////////////////
BOOL bIsFocusOnTV(LPBWI lpbwi)
{
    return( IsWindowVisible(bwi_hWndTV) && (bwi_iFocus == s_TV));
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Gets EntryID of CurrentSelection
// lpcbEID, lppEID should be MAPIFreeBuffered
//
//  bTopMost means that get the EntryID of the topmost parent of a given selection in case the
//      selection is on a sub-item
//
//////////////////////////////////////////////////////////////////////////////////////////
void GetCurrentSelectionEID(LPBWI lpbwi, HWND hWndTV, LPSBinary * lppsbEID, ULONG * lpulObjectType, BOOL bTopMost)
{
    HTREEITEM hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(hWndTV);
    TV_ITEM tvI = {0};
    LPSBinary lpsbEID = NULL;

    if(!lppsbEID)
        return;

    *lppsbEID = NULL;

    if(bTopMost)
    {
        HTREEITEM hParent = NULL;
        while(hParent = TreeView_GetParent(hWndTV, hItem))
            hItem = hParent;
    }

    tvI.mask = TVIF_PARAM | TVIF_HANDLE;
    tvI.hItem = hItem;
    if(TreeView_GetItem(hWndTV, &tvI))
    {
        if(tvI.lParam)
        {
            LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
            if(lptvStuff)
            {
                if(lptvStuff->lpsbEID)
                {
                    lpsbEID = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
                    if(lpsbEID)
                    {
                        if(lptvStuff->lpsbEID->cb)
                            SetSBinary(lpsbEID, lptvStuff->lpsbEID->cb, lptvStuff->lpsbEID->lpb);
                        *lppsbEID = lpsbEID;
                    }
                    if(lpulObjectType)
                        *lpulObjectType = lptvStuff->ulObjectType;
                }
            }
        }
    }
    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Removes specified group from WAB
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrRemoveEntryFromWAB(LPIAB lpIAB, ULONG cbEID, LPENTRYID lpEID)
{
	HRESULT hr = hrSuccess;
    ULONG cbWABEID = 0;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpWABCont = NULL;
    ULONG ulObjType;
    SBinaryArray SBA;
    SBinary SB;


    hr = lpIAB->lpVtbl->GetPAB(lpIAB,&cbWABEID,&lpWABEID);
    if(HR_FAILED(hr))
        goto out;

    hr = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                  cbWABEID,     // size of EntryID to open
                                  lpWABEID,     // EntryID to open
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpWABCont);
    if(HR_FAILED(hr))
        goto out;

                    
    SB.cb = cbEID;
    SB.lpb = (LPBYTE) lpEID;

    SBA.cValues = 1;
    SBA.lpbin = &SB;

    hr = lpWABCont->lpVtbl->DeleteEntries(
                                        lpWABCont,
                                        (LPENTRYLIST) &SBA,
                                        0);
    if(HR_FAILED(hr))
        goto out;

out:
    if(lpWABCont)
        UlRelease(lpWABCont);
    
    if(lpWABEID)
        FreeBufferAndNull(&lpWABEID);

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////////
//
// FreeTVItemLParam
//
//
////////////////////////////////////////////////////////////////////////////////////////
void FreeTVItemLParam(HWND hWndTV, HTREEITEM hItem)
{
    TV_ITEM tvI = {0};
    tvI.mask = TVIF_PARAM | TVIF_HANDLE;
    tvI.hItem = hItem;

    TreeView_GetItem(hWndTV, &tvI);
    if(tvI.lParam)
    {
        LPTVITEM_STUFF lptvi = (LPTVITEM_STUFF) tvI.lParam;
        if(lptvi)
        {
            // if(lptvi->ulObjectType==MAPI_DISTLIST) //only free this for groups
            LocalFreeSBinary(lptvi->lpsbEID);
            LocalFree(lptvi);
        }
    }
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ClearTreeViewItems - Clears the treeview of all its items
//
//////////////////////////////////////////////////////////////////////////////////////////
void FreeTreeNode(HWND hWndTV, HTREEITEM hItem)
{
    HTREEITEM hTemp = NULL;

    if(!hItem)
        return;

    FreeTVItemLParam(hWndTV, hItem);

    hTemp = TreeView_GetChild(hWndTV, hItem);
    while(hTemp)
    {
        FreeTreeNode(hWndTV, hTemp);
        hTemp = TreeView_GetNextSibling(hWndTV, hTemp);
    }
}

void ClearTreeViewItems(HWND hWndTV)
{
    // Go through all the items and clear their lParams which we allocated earlier
    HTREEITEM hRoot = TreeView_GetRoot(hWndTV);
    while(hRoot)
    {
        FreeTreeNode(hWndTV, hRoot);
        hRoot = TreeView_GetNextSibling(hWndTV, hRoot);
    }
    TreeView_DeleteAllItems(hWndTV);
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// RemoveCurrentGroup - removes the currently selected group from the WAB
//
//////////////////////////////////////////////////////////////////////////////////////////
void RemoveCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast)
{
    HRESULT hr = E_FAIL;

    // Warn the user if they really want to do this ?
    if(IDYES == ShowMessageBox( hWnd, idsRemoveGroupFromAB, MB_ICONEXCLAMATION | MB_YESNO ) )
    {
        LPSBinary lpsbEID = NULL;
        // Get the entryid of this group
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);

        if(lpsbEID)
        {
            HTREEITEM hItem = NULL;

            // Delete the group contact from the WAB
            hr = HrRemoveEntryFromWAB(bwi_lpIAB, lpsbEID->cb, (LPENTRYID)lpsbEID->lpb);
        
            if(HR_FAILED(hr))
                ShowMessageBox(hWnd, idsRemoveGroupError, MB_ICONEXCLAMATION | MB_OK);

            // Remove selection from the current group
            RemoveUpdateSelection(lpbwi);

            // Update all
            bwi_bDontRefreshLV = TRUE;
            RefreshListView(lpbwi, lpftLast);
            bwi_bDontRefreshLV = FALSE;

            LocalFreeSBinary(lpsbEID);
        }
    }
}



//$$////////////////////////////////////////////////////////////////////////////////////////
//
// RemoveCurrentFolder - removes the currently selected folder and all its contents from the WAB
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT RemoveCurrentFolder(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    HRESULT hr = E_FAIL;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;
    ULONG i, j, cValues= 0;
    SBinary sb = {0};
    LPSBinary lpsbEID = NULL;
    LPIAB lpIAB = bwi_lpIAB;

    // Get the entryid of this folder
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);

    if( !lpsbEID || !lpsbEID->cb || !lpsbEID->lpb || // can't delete root item
        (lpIAB->lpWABCurrentUserFolder && (lpsbEID->cb==lpIAB->lpWABCurrentUserFolder->sbEID.cb) && //can't delete the current users folder
            !memcmp(lpsbEID->lpb, lpIAB->lpWABCurrentUserFolder->sbEID.lpb, lpsbEID->cb) ) )
    {
        ShowMessageBox(hWnd, idsCannotDelete, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }

    // ignore deletions to folders in non-profile mode ...
    if(!bIsWABSessionProfileAware(bwi_lpIAB) || pt_bIsWABOpenExSession)
        goto out;

    // Warn the user if they really want to do this ?
    if(IDYES == ShowMessageBox( hWnd, idsRemoveFolderFromAB, MB_ICONEXCLAMATION | MB_YESNO ) )
    {
        if(lpsbEID && lpsbEID->cb && lpsbEID->lpb) // can't delete root item
        {
            HTREEITEM hItem = NULL;
            // Open the group and read its contents
            if(!HR_FAILED(hr = ReadRecord( bwi_lpIAB->lpPropertyStore->hPropertyStore, 
                                            lpsbEID, 0, &cValues, &lpPropArray)))
            {
                for(i=0;i<cValues;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_ENTRIES)
                    {
                        for(j=0;j<lpPropArray[i].Value.MVbin.cValues;j++)
                        {
                            hr = HrRemoveEntryFromWAB(bwi_lpIAB, 
                                            lpPropArray[i].Value.MVbin.lpbin[j].cb,
                                            (LPENTRYID)lpPropArray[i].Value.MVbin.lpbin[j].lpb);
                        }
                    }
                }

                // Delete the group contact from the WAB
                hr = DeleteRecord( bwi_lpIAB->lpPropertyStore->hPropertyStore, lpsbEID);
        
                if(HR_FAILED(hr) && hr!=MAPI_E_INVALID_ENTRYID)
                    ShowMessageBox(hWnd, idsRemoveFolderError, MB_ICONEXCLAMATION | MB_OK);

                // Remove selection from the current group
                RemoveUpdateSelection(lpbwi);
                // Update all
                bwi_bDontRefreshLV = TRUE;
                HrGetWABProfiles(bwi_lpIAB);
                RefreshListView(lpbwi, lpftLast);
                bwi_bDontRefreshLV = FALSE;
            }
            ReadRecordFreePropArray(NULL, cValues, &lpPropArray);
        }
    }
out:
    LocalFreeSBinary(lpsbEID);
    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
// RemovesSelectedItems from the listview
//
//	lpList is the ContentsList associated with the ListView which needs
//		to be kept updated
//
//////////////////////////////////////////////////////////////////////////////////////////
void RemoveSelectedItemsFromListView(HWND hWndLV, LPRECIPIENT_INFO * lppList)
{

    int iItemIndex = 0;
    
    if(ListView_GetSelectedCount(hWndLV) <= 0)
        goto exit;

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    // Start removing from the bottom up
    iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
    
    while(iItemIndex != -1)
    {
        // Get the entryid of the selected item
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
        if(lpItem)
        {
            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;
            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;
			if(lppList && *lppList == lpItem)
				*lppList = lpItem->lpNext;
            FreeRecipItem(&lpItem);
        }
        ListView_DeleteItem(hWndLV, iItemIndex);
        iItemIndex = ListView_GetNextItem(hWndLV, iItemIndex-1, LVNI_SELECTED);
    }

    SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
exit:
    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Removes selected items from the group and the WAB, if specified
//
//////////////////////////////////////////////////////////////////////////////////////////
void RemoveSelectedItemsFromCurrentGroup(LPBWI lpbwi, HWND hWnd, LPFILETIME lpftLast, BOOL bRemoveFromWAB)
{
    // We want to remove the selected items from the current group and also
    // remove them from the ListView ...
    LPSBinary lpsbEID = NULL;
    ULONG ulcValues = 0;
    LPSPropValue lpPropArray = NULL;
    HRESULT hr = S_OK;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType = 0;
    ULONG i,j;
    ULONG ulDLEntriesIndex = 0;
    int id = (bRemoveFromWAB) ? idsRemoveSelectedFromGroupAndAB : idsRemoveSelectedFromGroup;

    if( ListView_GetSelectedCount(bwi_hWndListAB) <= 0)
        goto exit;

    if(IDNO == ShowMessageBox(hWnd, id, MB_ICONEXCLAMATION | MB_YESNO))
        goto exit;

    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, NULL, FALSE);

    if(!lpsbEID)
        goto exit;

    if (HR_FAILED(hr = bwi_lpAdrBook->lpVtbl->OpenEntry(bwi_lpAdrBook,
                                                    lpsbEID->cb,    // cbEntryID
                                                    (LPENTRYID)lpsbEID->lpb,    // entryid
                                                    NULL,         // interface
                                                    MAPI_MODIFY,                // ulFlags
                                                    &ulObjType,       // returned object type
                                                    (LPUNKNOWN *)&lpMailUser)))
    {
        // Failed!  Hmmm.
        DebugTraceResult( TEXT("Address: IAB->OpenEntry:"), hr);
        goto exit;
    }

    Assert(lpMailUser);

    if (HR_FAILED(hr = lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    NULL,   // lpPropTagArray
                                                    MAPI_UNICODE,            // ulFlags
                                                    &ulcValues,     // how many properties were there?
                                                    &lpPropArray)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto exit;
    }

    // Scan these props for the PR_WAB_DL_ENTRIES
    // We ignore PR_WAB_DL_ONEOFFS here because technically you can't have one-offs in the Browse view therefore
    // should never need to delete OneOffs in this function
    for(i=0;i<ulcValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES)
        {
            ulDLEntriesIndex = i;
            break;
        }
    }

    if(!ulDLEntriesIndex)
        goto exit;


    {
        // cycle through the list view items entryids
        int iItemIndex = ListView_GetNextItem(bwi_hWndListAB, -1, LVNI_SELECTED);
        while(iItemIndex != -1)
        {
            // Get the entryid of the selected item
            ULONG cbItemEID = 0;
            LPENTRYID lpItemEID = NULL;
            LPRECIPIENT_INFO lpItem = GetItemFromLV(bwi_hWndListAB, iItemIndex);
            if(lpItem)
            {
                RemovePropFromMVBin(lpPropArray,
                                    ulcValues,
                                    ulDLEntriesIndex,
                                    (LPVOID) lpItem->lpEntryID,
                                    lpItem->cbEntryID);
                if(bRemoveFromWAB)
                {
                    // Delete the group contact from the WAB
                    // Note; This is very inefficient - we should ideally create a 
                    //  SBinaryArray and call deleteentries all at once
                    //  We'll leave that for some later time <TBD> <BUGBUG>
                    hr = HrRemoveEntryFromWAB(bwi_lpIAB, lpItem->cbEntryID, lpItem->lpEntryID);
                }
            }
            iItemIndex = ListView_GetNextItem(bwi_hWndListAB, iItemIndex, LVNI_SELECTED);
        }
    }

    // Knock out the PR_WAB_DL_ENTRIES property so we can overwrite it
    {
        if (HR_FAILED(hr = lpMailUser->lpVtbl->DeleteProps(lpMailUser,
                                                           (LPSPropTagArray) &tagaDLEntriesProp,
                                                            NULL)))
        {
            DebugTraceResult( TEXT("IAB->DeleteProps:"), hr);
            goto exit;
        }

    }
    if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                    ulcValues,     
                                                    lpPropArray,
                                                    NULL)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto exit;
    }

    if(HR_FAILED(hr = lpMailUser->lpVtbl->SaveChanges(lpMailUser, KEEP_OPEN_READONLY)))
    {
        DebugTraceResult( TEXT("SaveChanges failed: "), hr);
        goto exit;
    }

    // update the file stamp
    //if (lpftLast) {
    //    CheckChangedWAB(bwi_lpIAB->lpPropertyStore, lpftLast);
    //}
    bwi_bDeferNotification = TRUE;

    RemoveSelectedItemsFromListView(bwi_hWndListAB, &bwi_lpContentsList);

exit:

    if(lpsbEID)
        LocalFreeSBinary(lpsbEID);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    if(lpMailUser)
        lpMailUser->lpVtbl->Release(lpMailUser);
    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Shows properties on the currently selected group or folder
//
//////////////////////////////////////////////////////////////////////////////////////////
void ViewCurrentGroupProperties(LPBWI lpbwi, LPFILETIME lpftLast)
{
    LPSBinary lpsbEID = NULL;
    HWND hWnd = GetParent(bwi_hWndTV);
    ULONG ulObjectType = 0;
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
    if(lpsbEID && (ulObjectType==MAPI_DISTLIST))
    { 
        bwi_lpAdrBook->lpVtbl->Details(	bwi_lpAdrBook,
									(PULONG_PTR) &hWnd,
									NULL,
									NULL,
									lpsbEID->cb,
									(LPENTRYID)lpsbEID->lpb,
									NULL,
									NULL,
									NULL,
									0);
        // if the item name changed, update it
        {
            LPRECIPIENT_INFO lpInfo = NULL;
            ReadSingleContentItem( bwi_lpAdrBook,
                                   lpsbEID->cb,
                                   (LPENTRYID) lpsbEID->lpb,
                                   &lpInfo);
            if(lpInfo)
            {
                TV_ITEM tvi = {0};
                tvi.hItem = bwi_hti ? bwi_hti : TreeView_GetSelection(bwi_hWndTV);
                tvi.mask = TVIF_HANDLE;
                TreeView_GetItem(bwi_hWndTV, &tvi);
                tvi.mask |= TVIF_TEXT;
                tvi.pszText = lpInfo->szDisplayName;
                tvi.cchTextMax = lstrlen(tvi.pszText)+1;
                TreeView_SetItem(bwi_hWndTV, &tvi);
                FreeRecipItem(&lpInfo);
            }
            

        }

		UpdateListViewContents(lpbwi, lpsbEID, ulObjectType);
		// Update the wab file write time so the timer doesn't
		// catch this change and refresh.
		//if (lpftLast) {
		//	CheckChangedWAB(bwi_lpIAB->lpPropertyStore, lpftLast);
		//}
        bwi_bDeferNotification = TRUE;

	}
    else if(lpsbEID //&& lpsbEID->cb && lpsbEID->lpb 
            && (ulObjectType==MAPI_ABCONT) 
            && bIsWABSessionProfileAware(bwi_lpIAB))
    {
        // view properties on the folder entry
        if(!HR_FAILED(HrFolderProperties(GetParent(bwi_hWndTV), bwi_lpIAB, lpsbEID, NULL, NULL)))
        {
            //UpdateViewFoldersMenu(lpbwi, hWnd);
            RefreshListView(lpbwi,lpftLast);
        }
    }

    if(lpsbEID)
        LocalFreeSBinary(lpsbEID);

    return;
}
//$$////////////////////////////////////////////////////////////////////////////////////////
//
// Processes messages for the TREE view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessTreeViewMessages(LPBWI lpbwi, HWND hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam, LPFILETIME lpftLast)
{

    NM_TREEVIEW * pNm = (NM_TREEVIEW *)lParam;

    switch(pNm->hdr.code)
    {
    case NM_SETFOCUS:
        UpdateToolbarAndMenu(lpbwi);
    	break;

    case TVN_KEYDOWN:
        //UpdateToolbarAndMenu(lpbwi);
        switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
        {
        case VK_DELETE:
            SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_DELETE, 0);
            return 0;
            break;
    	case VK_RETURN:
    		SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FILE_PROPERTIES, 0);
            return 0;
        }
        break;

	case TVN_SELCHANGEDW:
    case TVN_SELCHANGEDA:
        {
            if(!bwi_bDontRefreshLV)
                UpdateLV(lpbwi);
	        UpdateToolbarAndMenu(lpbwi);
        }
    	break;
    }


    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

BOOL SplitterHitTest(HWND hWndT, LPARAM lParam)
{
	LONG xPos = LOWORD(lParam);
	LONG yPos = HIWORD(lParam);
	RECT rc;
    if(!IsWindowVisible(hWndT))
        return FALSE;
	GetChildClientRect(hWndT, &rc);
	if(	(xPos <= rc.right) && (xPos >= rc.left) && 
		(yPos <= rc.bottom) && (yPos >= rc.top) )
		return TRUE;
	else
		return FALSE;
}



/////////////////////////////////////////
// Stolen (essentially) from COMMCTRL
HBITMAP FAR PASCAL CreateDitherBitmap(COLORREF crFG, COLORREF crBG)
{
    PBITMAPINFO pbmi;
    HBITMAP hbm;
    HDC hdc;
    int i;
    long patGray[8];
    DWORD rgb;

    pbmi = (PBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * 16));
    if (!pbmi)
        return NULL;

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 8;
    pbmi->bmiHeader.biHeight = 8;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = BI_RGB;

    rgb = crBG;
    pbmi->bmiColors[0].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[0].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[0].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[0].rgbReserved = 0;

    rgb = crFG;
    pbmi->bmiColors[1].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[1].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[1].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[1].rgbReserved = 0;


    /* initialize the brushes */

    for (i = 0; i < 8; i++)
       if (i & 1)
           patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray
       else
           patGray[i] = 0x5555AAAAL;   //  0x11114444L; // lighter gray

    hdc = GetDC(NULL);

    // REVIEW: We cast am array of long to (BYTE const *). Is it ok for Win32?
    hbm = CreateDIBitmap(hdc, &pbmi->bmiHeader, CBM_INIT,
                         (BYTE const *)patGray, pbmi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);

    LocalFree(pbmi);

    return hbm;
}

// Stolen (essentially) from COMMCTRL
HBRUSH FAR PASCAL CreateDitherBrush(COLORREF crFG, COLORREF crBG)
{
	HBITMAP hbm;
	HBRUSH hbrRet = NULL;

	hbm = CreateDitherBitmap(crFG, crBG);
	if (hbm)
	{
		hbrRet = CreatePatternBrush(hbm);
		DeleteObject(hbm);
	}

	return(hbrRet);
}
//////////////////////////////////////////

// Stolen from Athena
void DragSplitterBar(LPBWI lpbwi, HWND hwnd, HWND hWndT, LPARAM lParam)
{
	MSG msg;
	int x, y, dx, dy;
	RECT rcSplitter;
	RECT rc;
    HDC hdc;
    LONG lStyle;
    HBRUSH hbrDither, hbrOld;
    int nAccel = 2;

    lStyle = GetWindowLong(hwnd, GWL_STYLE);
    SetWindowLong(hwnd, GWL_STYLE, (lStyle & ~WS_CLIPCHILDREN));

	GetChildClientRect(hWndT, &rcSplitter);
	//GetWindowRect(hWndT, &rcSplitter);
	x = rcSplitter.left;
	y = rcSplitter.top;
    dx = rcSplitter.right - rcSplitter.left;
    dy = rcSplitter.bottom - rcSplitter.top;

	GetWindowRect(hwnd, &rc);
	
    hdc = GetDC(hwnd);
	hbrDither = CreateDitherBrush(RGB(255, 255, 255), RGB(0, 0, 0));
	if (hbrDither)
        hbrOld = (HBRUSH)SelectObject(hdc, (HGDIOBJ)hbrDither);

    // split bar loop...
    PatBlt(hdc, x, y, dx, dy, PATINVERT);

    SetCapture(hwnd);

    while (GetMessage(&msg, NULL, 0, 0))
    {
	    if (	msg.message == WM_LBUTTONUP || 
				msg.message == WM_LBUTTONDOWN ||
				msg.message == WM_RBUTTONDOWN)
            break;

        if (GetCapture() != hwnd)
        {
            msg.message = WM_RBUTTONDOWN; // treat as cancel
            break;
        }

        if (	msg.message == WM_KEYDOWN || 
				msg.message == WM_SYSKEYDOWN ||
				(msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST) )
        {
            if (msg.message == WM_KEYDOWN)
            {
                nAccel = 4;

                if (msg.wParam == VK_LEFT)
                {
                    msg.message = WM_MOUSEMOVE;
                    msg.pt.x -= nAccel/2;
                }
				else if (msg.wParam == VK_RIGHT)
                {
                    msg.message = WM_MOUSEMOVE;
                    msg.pt.x += nAccel/2;
                }
                else if (	msg.wParam == VK_RETURN ||
		                    msg.wParam == VK_ESCAPE)
                {
                    break;
                }

                if (msg.pt.x > rc.right)
                    msg.pt.x = rc.right;

                if (msg.pt.x <  rc.left)
                    msg.pt.x = rc.left;

                SetCursorPos(msg.pt.x, msg.pt.y);
            }

            if (msg.message == WM_MOUSEMOVE)
            {
                int lo, hi;

                if (msg.pt.x > rc.right)
                    msg.pt.x = rc.right;
                if (msg.pt.x <  rc.left)
                    msg.pt.x = rc.left;

                ScreenToClient(hwnd, &msg.pt);

                // Clip out the parts we don't want so
                // that we do a single PatBlt (less
                // flicker for small movements).
                if (x < msg.pt.x)
                {
                    lo = x;
                    hi = msg.pt.x;
                }
                else
	            {
					lo = msg.pt.x;
					hi = x;
                }

				if (hi < lo+dx)
                {
	                ExcludeClipRect(hdc, hi, y, lo+dx, y+dy);
                }
                else
                {
	                ExcludeClipRect(hdc, lo+dx, y, hi, y+dy);
                }

                // Erase the old and draw the new in one draw.
                PatBlt(hdc, lo, y, hi-lo+dx, dy, PATINVERT);
                SelectClipRgn(hdc, NULL);

                x = msg.pt.x;
            }
        }
        else
        {
            DispatchMessage(&msg);
        }
    }

    ReleaseCapture();

    // erase old
    PatBlt(hdc, x, y, dx, dy, PATINVERT);

    if (hbrDither)
    {
        if (hbrOld)
            SelectObject(hdc, hbrOld);
        DeleteObject(hbrDither);
    }
    ReleaseDC(hwnd, hdc);

    SetWindowLong(hwnd, GWL_STYLE, lStyle);

    if (msg.wParam != VK_ESCAPE && msg.message != WM_RBUTTONDOWN && msg.message != WM_CAPTURECHANGED)
    {
		RECT rcTV;
		GetChildClientRect(bwi_hWndTV, &rcTV);

		MoveWindow(bwi_hWndTV, rcTV.left, rcTV.top, x, rcTV.bottom - rcTV.top, TRUE);

		ResizeAddressBookChildren(lpbwi, hwnd);

    	InvalidateRect( bwi_hWndSplitter,NULL,TRUE);
    	InvalidateRect( bwi_hWndEditQF,NULL,TRUE);
    	InvalidateRect( bwi_hWndStaticQF,NULL,TRUE);
    	InvalidateRect( hwnd,NULL,TRUE);
		RedrawWindow(	hwnd, NULL, NULL,
						RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW | RDW_UPDATENOW );
		RedrawWindow(	bwi_hWndEditQF, NULL, NULL,
						RDW_ERASE | RDW_INVALIDATE | RDW_ERASENOW | RDW_UPDATENOW );
    }

    return;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// Opens a VCard and adds it to the WAB and to the Current group
//	szVCardFIle can be a NULL in which case we open the OpenFile dialog
//
//////////////////////////////////////////////////////////////////////////////////
HRESULT OpenAndAddVCard(LPBWI lpbwi, LPTSTR szVCardFile)
{
	HRESULT hr = S_OK;
    LPSPropValue lpProp  = NULL;

	hr = VCardImport(bwi_hWndAB, bwi_lpAdrBook, szVCardFile, &lpProp);

    // if the above failed, then the lpProp will have nothing in it
    // in cases where there are multiple nested vcards, the error could
    // be from one vcard, but the rest may have imported .. if they
    // imported successfully then lpProp will have something in it ..
    // so use lpProp instead of hr ..
    if(lpProp)
	{
        if(HR_FAILED(hr))
            hr = MAPI_W_ERRORS_RETURNED;

		bwi_bDontRefreshLV = TRUE;
		if(lpProp && PROP_TYPE(lpProp->ulPropTag) == PT_MV_BINARY)
		{
			if(!bIsSelectedTVContainer(lpbwi))
			{
                LPSBinary lpsbEIDGroup = NULL;
                ULONG ulObjectType = 0;
                bwi_hti = NULL; // if this wasnt a context-initiated action, dont trust the hti setting
				GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEIDGroup, &ulObjectType, FALSE);
                if(lpsbEIDGroup)
                {
                    ULONG i = 0;
                    for(i=0;i<lpProp->Value.MVbin.cValues;i++)
                    {
				        hr = AddEntryToContainer(bwi_lpAdrBook, ulObjectType,
								        lpsbEIDGroup->cb, (LPENTRYID) lpsbEIDGroup->lpb,
								        lpProp->Value.MVbin.lpbin[i].cb,
								        (LPENTRYID) lpProp->Value.MVbin.lpbin[i].lpb);
                    }
                }
			}
		}
		FreeBufferAndNull(&lpProp);
		bwi_bDontRefreshLV = FALSE;
    	// if updated and showing PAB, refresh list
		SendMessage(bwi_hWndAB, WM_COMMAND, (WPARAM) IDM_VIEW_REFRESH, 0);
	}

	return hr;
}



//$$
//  Updates the switch-user's menu if this is not a wab.exe initiated call
//
//
void UpdateSwitchUsersMenu(HWND hWnd, LPIAB lpIAB)
{
    if( memcmp(&lpIAB->guidPSExt, &MPSWab_GUID_V4, sizeof(GUID)) ||
        !bIsThereACurrentUser(lpIAB) || !bAreWABAPIProfileAware(lpIAB))
    {
        HMENU hMenuMain = GetMenu(hWnd);
        HMENU hMenuFile = GetSubMenu(hMenuMain,idmFile);
        // Need to remove the print and the seperator
	RemoveMenu(hMenuFile, idmFSep5, MF_BYPOSITION);
	RemoveMenu(hMenuFile, idmAllContents, MF_BYPOSITION);
	RemoveMenu(hMenuFile, idmSwitchUsers, MF_BYPOSITION);
        DrawMenuBar(hWnd);
    }
}


//$$
//
// Turns of the print menu if requested to do so
//
//
void UpdatePrintMenu(HWND hWnd)
{
    if(!bPrintingOn)
    {
        HMENU hMenuMain = GetMenu(hWnd);
        HMENU hMenuFile = GetSubMenu(hMenuMain,idmFile);
        
        // Need to remove the print and the seperator
        RemoveMenu(hMenuFile, idmFSep4, MF_BYPOSITION);
        RemoveMenu(hMenuFile, idmPrint, MF_BYPOSITION);

        DrawMenuBar(hWnd);
    }
    return;
}

/*
-
- UpdateViewFoldersMenu
-
*
*
*/
void UpdateViewFoldersMenu(LPBWI lpbwi, HWND hWnd)
{
#ifdef FUTURE
    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuFile = GetSubMenu(hMenuMain,idmFile);
    HMENU hMenu = GetSubMenu(hMenuFile, idmFolders);
    LPIAB lpIAB = bwi_lpIAB;
    int i = 0;

    // If profiles are not enabled or there are no subfolders, remove the folder option completely
    if(!bDoesThisWABHaveAnyUsers(lpIAB))
    {
        // remove all folder options:

        // Remove the Folders option from the View Menu
        RemoveMenu(hMenuFile, idmSepFolders, MF_BYPOSITION); 
        RemoveMenu(hMenuFile, idmFolders, MF_BYPOSITION); 
        goto out;
    }
    else 
    {
        // removing screws up numbering and svrewss up access to other folders
        // so just disable
        EnableMenuItem(hMenuFile, idmSepFolders, MF_BYPOSITION | (lpIAB->lpWABFolders ? MF_ENABLED : MF_GRAYED)); 
        EnableMenuItem(hMenuFile, idmFolders, MF_BYPOSITION | (lpIAB->lpWABFolders ? MF_ENABLED : MF_GRAYED)); 
        if(lpIAB->lpWABFolders)
            AddFolderListToMenu(hMenu, lpIAB);
        goto out;
    }

    // if there is only 1 folder in the wab and this is the shared folder
    // then disable the folder item because there is nothing to be done
    //if( !bIsThereACurrentUser(lpIAB) )
    //{
    //    EnableMenuItem(hMenuView, idmFolders, MF_BYPOSITION | MF_GRAYED); 
    //    goto out;
    //}


out:
#endif // FUTURE
    return;
}


//$$
//  UpdateOutlookMenus
//
//  Some menus are not accessible when running from outlook
//
//  Tools | Options Menu should not be accessible from WAB when
//  outlook is in Full MAPI mode because then Outlook doesnt use 
//  WAB and we dont want to give the option to the user of 
//  switching to the WAB
//
void UpdateOutlookMenus(HWND hWnd)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    BOOL bNoOptions = TRUE;
    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuFile = NULL;
    HMENU hMenu = NULL;

    if( pt_bIsWABOpenExSession && 
        lpfnAllocateBufferExternal &&                           // **ASSUMPTION** that Outlook always
        lpfnAllocateMoreExternal && lpfnFreeBufferExternal)     // passes in memory allocators ..!!! 
    {
/*
        hMenuFile = GetSubMenu(hMenuMain, idmFile);

        {
            // Need to remove the import AddressBook and Export Addressbook options
            hMenu = GetSubMenu(hMenuFile, idmImport);
            RemoveMenu(hMenu, IDM_TOOLS_IMPORT_OTHER, MF_BYCOMMAND); 
            hMenu = GetSubMenu(hMenuFile, idmExport);
            RemoveMenu(hMenu, IDM_TOOLS_EXPORT_OTHER, MF_BYCOMMAND); 
            RemoveMenu(hMenu, IDM_TOOLS_EXPORT_WAB, MF_BYCOMMAND); 
        }
*/
/*
        // [PaulHi] 12/18/98  Raid #62640
        // Disable the Import/Export menu items before anything is removed and
        // order gets messed up.
        EnableMenuItem(hMenuFile, idmImport, MF_GRAYED | MF_BYPOSITION);
        EnableMenuItem(hMenuFile, idmExport, MF_GRAYED | MF_BYPOSITION);

        //Also remove New Folder menu
        RemoveMenu(hMenuFile, IDM_FILE_NEWFOLDER, MF_BYCOMMAND);
*/
    }
    else
    {
        // Not called from Outlook ...
        // check if Outlook is using the WAB .. if it isnt, we dont want
        // to show the Tools Options menu
        //
        HKEY hKey = NULL;
        LPTSTR lpReg =  TEXT("Software\\Microsoft\\Office\\8.0\\Outlook\\Setup");
        LPTSTR lpOMI =  TEXT("MailSupport");
        BOOL bUsingWAB = FALSE;

        if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, lpReg, 0, KEY_READ, &hKey))
        {
            DWORD dwType = 0, dwSize = sizeof(DWORD), dwData = 0;
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpOMI, NULL, &dwType, (LPBYTE)&dwData, &dwSize))
            {
                if(dwType == REG_DWORD && dwData == 0)
                    bUsingWAB = TRUE;
            }
        }

        if(hKey)
            RegCloseKey(hKey);

        bNoOptions = !bUsingWAB;
    }

    // [PaulHi] 1/4/99  The pt_bIsWABOpenExSession variable is mis-named.  This 
    // boolean used to be true only if the WAB was opened from WABOpenEx, i.e, 
    // by Outlook using the Outlook store.  However, this boolean is now true in
    // the case where the WAB is open from WABOpen but still uses the Outlook 
    // store because it is in "shared mode", i.e., the use outlook store registry
    // setting is true.
    if(pt_bIsWABOpenExSession)
    {
        //Also remove New Folder menu
        hMenuFile = GetSubMenu(hMenuMain, idmFile);

        // [PaulHi] 1/4/99  Raid #64016
        // Disable the Import/Export menu items before anything is removed and
        // order gets messed up.
        // This is similar to Raid #62640 except we need to disable import/export
        // WHENEVER the WAB is opened to use the Outlook store since it doesn't
        // know how to import/export Outlook store information.
        EnableMenuItem(hMenuFile, idmImport, MF_GRAYED | MF_BYPOSITION);
        EnableMenuItem(hMenuFile, idmExport, MF_GRAYED | MF_BYPOSITION);

        RemoveMenu(hMenuFile, IDM_FILE_NEWFOLDER, MF_BYCOMMAND);

        // [PaulHi] 3/22/99  Raid 73457  Remove the Profile... Edit menu item
        // since profiles are turned off when in Outlook mode
        hMenu = GetSubMenu(hMenuMain, idmEdit);
        RemoveMenu(hMenu, IDM_EDIT_SETME, MF_BYCOMMAND);    // Profile... menu item
        RemoveMenu(hMenu, 5, MF_BYPOSITION);                // Seperator
    }

    if(bNoOptions)
    {
        // Hide the tools options option
        //
        hMenuFile = GetSubMenu(hMenuMain,idmTools);

        // Need to remove the second-last and third-last items
        RemoveMenu(hMenuFile, 3, MF_BYPOSITION); //Seperator
        RemoveMenu(hMenuFile, 2, MF_BYPOSITION); //Options

        DrawMenuBar(hWnd);
    }

    return;
}


void UpdateCustomColumnMenuText(HWND hWnd)
{
    HMENU hMenuMain = GetMenu(hWnd);
    HMENU hMenuView = GetSubMenu(hMenuMain, idmView);
    int nDiff = idmViewMax - GetMenuItemCount(hMenuView); // in case stuff was deleted off this menu
    HMENU hMenu = GetSubMenu(hMenuView, idmSortBy - nDiff);
    MENUITEMINFO mii = {0};

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_STRING;

    if(PR_WAB_CUSTOMPROP1 && lstrlen(szCustomProp1))
    {
        mii.dwTypeData = (LPTSTR) szCustomProp1;
        mii.cch = lstrlen(szCustomProp1) + 1;
        SetMenuItemInfo(hMenu, 3, TRUE, &mii);        
    }
    if(PR_WAB_CUSTOMPROP2 && lstrlen(szCustomProp2))
    {
        mii.dwTypeData = (LPVOID) szCustomProp2;
        mii.cch = lstrlen(szCustomProp2) + 1;
        SetMenuItemInfo(hMenu, 2, TRUE, &mii);
    }
    DrawMenuBar(hWnd);
    return;
}


//$$
// bCheckForOutlook
// Checks if the Outlook Contact Store is available
//
// If this is an outlook session, this is true by default
// Otherwise hunt for presence of outlwab.dll
//
BOOL bCheckForOutlook()
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    if(pt_bIsWABOpenExSession)
        return TRUE;

    // Not an outlook session ..
    // Look for OutlWAB.Dll 
    return bCheckForOutlookWABDll(NULL, 0);
}

//$$
//
// Dialog proc for the options dialog
//
/*//$$************************************************************************
//
//  fnSearch - Search Dialog Proc
//
**************************************************************************/
INT_PTR CALLBACK fnOptionsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            if(!bCheckForOutlook()) //<TBD> - No Outlook 98 is installed
            {
                // Disable the Outlook option
                EnableWindow(GetDlgItem(hDlg, IDC_OPTIONS_RADIO_OUTLOOK), FALSE);
                SendMessage(hDlg, WM_COMMAND, (WPARAM) MAKEWPARAM(IDC_OPTIONS_RADIO_WAB, BN_CLICKED), (LPARAM) GetDlgItem(hDlg, IDC_OPTIONS_RADIO_WAB));
                if(bUseOutlookStore()) // make sure reg says false .. not true
                    SetRegistryUseOutlook(FALSE);
            }
            else
            {
                // Correct type of Outlook is installed
                int id = bUseOutlookStore() ? IDC_OPTIONS_RADIO_OUTLOOK : IDC_OPTIONS_RADIO_WAB;
                SendMessage(hDlg, WM_COMMAND, 
                        (WPARAM) MAKEWPARAM(id, BN_CLICKED), 
                        (LPARAM) GetDlgItem(hDlg, id));
            }
        }

        // [PaulHi] Be sure to set the child window fonts
        EnumChildWindows(hDlg, SetChildDefaultGUIFont, (LPARAM)PARENT_IS_DIALOG);
        return TRUE;
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            // Check which option button is checked
            {
                BOOL bOriginal = bUseOutlookStore();
                BOOL bCurrent = IsDlgButtonChecked(hDlg, IDC_OPTIONS_RADIO_OUTLOOK);
                SetRegistryUseOutlook(bCurrent);
                if(bCurrent != bOriginal)
                    ShowMessageBox(hDlg, idsStoreChangeOnRestart, MB_ICONINFORMATION | MB_OK);
            }
            // fall thru
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        case IDC_OPTIONS_RADIO_WAB:
            CheckRadioButton(hDlg,
                            IDC_OPTIONS_RADIO_OUTLOOK,
                            IDC_OPTIONS_RADIO_WAB,
                            IDC_OPTIONS_RADIO_WAB);	
            break;

        case IDC_OPTIONS_RADIO_OUTLOOK:
            CheckRadioButton(hDlg,
                            IDC_OPTIONS_RADIO_OUTLOOK,
                            IDC_OPTIONS_RADIO_WAB,
                            IDC_OPTIONS_RADIO_OUTLOOK);	
            break;
        }
        break;
    }

    return FALSE;
}

//$$
//
// Shows the options dialog 
//
void HrShowOptionsDlg(HWND hWndParent)
{
    BOOL bChange = FALSE;
    INT_PTR nRetVal = DialogBoxParam( hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_OPTIONS),
		         hWndParent, fnOptionsDlgProc, (LPARAM) &bChange);
}

//$$////////////////////////////////////////////////////////////////////////////
//
// AddTVItem
//
// Adds an item to the Tree View - item can be folder/container or group
//
////////////////////////////////////////////////////////////////////////////////
HTREEITEM AddTVItem(HWND hWndTV, LPTSTR lpszName,  HTREEITEM hParentItem, HTREEITEM htiAfter,
               LPSBinary lpsbParentEID, LPSBinary lpEID, ULONG ulObjectType)
{
    TV_ITEM tvI = {0};
    TV_INSERTSTRUCT tvIns = {0};
    LPTVITEM_STUFF lptvStuff = NULL;
    HTREEITEM htiRet = NULL;
    int img = 0;

    if(ulObjectType == MAPI_DISTLIST)
        img = imageDistList;
    else
    {
        if(!lpEID || !lpEID->cb || !lpEID->lpb)
            img = imageAddressBook;
        else
            img = imageFolderClosed;
    }

    tvI.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    tvI.iImage = img;
    tvI.iSelectedImage = (img == imageFolderClosed) ? imageFolderOpen : img;
    tvI.pszText = lpszName;
    tvI.cchTextMax = lstrlen(tvI.pszText);

    lptvStuff = LocalAlloc(LMEM_ZEROINIT, sizeof(TVITEM_STUFF));
    if(!lptvStuff)
        goto out;

    lptvStuff->ulObjectType = ulObjectType;

    if(lpEID)
    {
        LPSBinary lpsbEID = NULL;
        lpsbEID = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary));
        if(lpsbEID)
        {
            if(lpEID->cb)
                SetSBinary(lpsbEID, lpEID->cb, lpEID->lpb);
            lptvStuff->lpsbEID = lpsbEID;
        }
    }

    lptvStuff->lpsbParent = lpsbParentEID;
    lptvStuff->hItemParent = hParentItem;

    tvI.lParam = (LPARAM) lptvStuff;

    tvIns.item = tvI;
    tvIns.hInsertAfter = htiAfter;
    tvIns.hParent = hParentItem;
    
    htiRet = TreeView_InsertItem(hWndTV, &tvIns);

    /* Uncomment this to make the top level folders show up in bold
    if(htiRet && !hParentItem)
    {
        TVITEM tvi = {0};
        tvi.mask = TVIF_STATE;
        tvi.state = tvi.stateMask = TVIS_BOLD;
        tvi.hItem = htiRet;
        TreeView_SetItem(hWndTV, &tvi);
    }*/
out:
    return htiRet;
}

//$$///////////////////////////////////////////////////////////////////////////
//
// AddTVFolderGroup
// 
// Add a group under a contact folder in the TV
//
///////////////////////////////////////////////////////////////////////////////
HTREEITEM AddTVFolderGroup(LPBWI lpbwi, HWND hWndTV, HTREEITEM hParentItem, LPSBinary lpsbParentEID, LPSBinary lpsbEID)
{
	TCHAR szBufName[MAX_UI_STR];

    if(!lpsbEID || !lpsbEID->cb || !lpsbEID->lpb)
        return NULL;

    // Get the name of this group
	if(HR_FAILED(FillListFromGroup( bwi_lpAdrBook,
                            lpsbEID->cb, (LPENTRYID) lpsbEID->lpb,									
                            szBufName, ARRAYSIZE(szBufName), NULL)))
        return NULL;

    return AddTVItem( hWndTV, szBufName, 
               hParentItem, TVI_SORT,
               lpsbParentEID, lpsbEID,
               MAPI_DISTLIST);
}

//$$///////////////////////////////////////////////////////////////////////////////
//
// FillTreeView
//
// Fill the TreeView with Contact Folders and groups as appropriate
//
//      lpsbSelection - entryid of item to select after filling
//
///////////////////////////////////////////////////////////////////////////////////
void FillTreeView(LPBWI lpbwi, HWND hWndTV, LPSBinary lpsbSelection)
{
    // Way to do this
    //
    // If this is the WAB, just add an AddressBook item to the top of the list
    // otherwise if this is Outlook, get a list of all the contact folders and
    // add them to the Root of the TV.
    //
    // Then go through the list of contact folders and for each one, add the groups
    // at the next level
    // We cache the TVITEM_STUFF info on each item, contact folder or group
    //
    HTREEITEM hItem = NULL;    
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = bwi_lpIAB;
    int nDepth = 0;

    bwi_bDontRefreshLV = TRUE;

    SendMessage(hWndTV, WM_SETREDRAW, (WPARAM) FALSE, 0);

    ClearTreeViewItems(hWndTV);

    EnterCriticalSection(&lpIAB->cs);


    // Check if this is an outlook session
    if( pt_bIsWABOpenExSession || bIsWABSessionProfileAware(lpIAB) )
    {
	    ULONG iolkci, colkci;
	    OlkContInfo *rgolkci;
        HTREEITEM htiTopLevel = NULL;

        colkci = pt_bIsWABOpenExSession ? lpIAB->lpPropertyStore->colkci : lpIAB->cwabci;
	    Assert(colkci);
        rgolkci = pt_bIsWABOpenExSession ? lpIAB->lpPropertyStore->rgolkci : lpIAB->rgwabci;
	    Assert(rgolkci);

        // Add the multiple folders here
        // Since each folder is added under the first item, we start last first
        // to preserve the folder order.
        if(pt_bIsWABOpenExSession)
        {
            do
            {
                iolkci = colkci-1;
                htiTopLevel = AddTVItem(  hWndTV, rgolkci[iolkci].lpszName, NULL, TVI_FIRST, NULL, 
                            (iolkci==0/*&& pt_bIsWABOpenExSession*/) ? NULL : rgolkci[iolkci].lpEntryID,
                            MAPI_ABCONT);
                colkci--;
            } while(colkci!=0);
        }
        else
        {
            // WAB Profiles ..
            // We want to add the first item ( TEXT("All Contacts")) at the top and all user folders
            // at the same level and all ordinary folders under the user level folders
            LPWABFOLDER lpFolder = (bIsThereACurrentUser(lpIAB) ? lpIAB->lpWABCurrentUserFolder : lpIAB->lpWABUserFolders);
            
            // With a given user, we only add that users folder
            // Without a given user we add everyones folders

            // if there are no user folders at all then we don't have user's configured and
            // all folders should show up at the top level
            if(!lpFolder)
                lpFolder = lpIAB->lpWABFolders;

            while(lpFolder)
            {
                LPWABFOLDERLIST lpFolderList = lpFolder->lpFolderList;
                htiTopLevel = AddTVItem(hWndTV, lpFolder->lpFolderName, NULL, TVI_SORT, NULL, &lpFolder->sbEID, MAPI_ABCONT);
                while(lpFolderList)
                {
                    // Don't show Shared Folders under the user-folders .. shared folders will be
                    // shown under the PAB folder
                    if(!lpFolderList->lpFolder->bShared)
                        AddTVItem(hWndTV, lpFolderList->lpFolder->lpFolderName, htiTopLevel, TVI_SORT, NULL, &lpFolderList->lpFolder->sbEID, MAPI_ABCONT);
                    lpFolderList = lpFolderList->lpNext;
                }
                TreeView_Expand(hWndTV, htiTopLevel, TVE_EXPAND);

                if(lpIAB->lpWABCurrentUserFolder)
                    break;
                lpFolder=lpFolder->lpNext;
            }
            // Add the Virtual PAB item to the top of the list so we can sort the others
            htiTopLevel = AddTVItem(hWndTV, rgolkci[0].lpszName, NULL, TVI_FIRST, NULL, rgolkci[0].lpEntryID, MAPI_ABCONT);
            // add all the SHARED folders under the root item
            lpFolder = lpIAB->lpWABFolders;
            while(lpFolder)
            {
                if(lpFolder->bShared)
                    AddTVItem(hWndTV, lpFolder->lpFolderName, htiTopLevel, TVI_SORT, NULL, &lpFolder->sbEID, MAPI_ABCONT);
                lpFolder=lpFolder->lpNext;
            }
            //if(!bIsThereACurrentUser(lpIAB) && !bDoesThisWABHaveAnyUsers(lpIAB))
            TreeView_Expand(hWndTV, htiTopLevel, TVE_EXPAND);
        }
    }
    else
    {
        TCHAR sz[MAX_PATH];
        *sz = '\0';
        LoadString(hinstMapiX, idsContacts/*IDS_ADDRBK_CAPTION*/, sz, ARRAYSIZE(sz));
        AddTVItem( hWndTV, sz, NULL, TVI_FIRST, NULL, NULL, MAPI_ABCONT);
    }

    //TreeView_SortChildren(hWndTV, NULL, 0);

    // Now we have all the contact folders at the root level ..
    // we can now add the groups under each folder
    hItem = TreeView_GetRoot(hWndTV);
    
    //if(bDoesThisWABHaveAnyUsers(lpIAB)) // don't populate any groups under the Root Item if Users exist
    //    hItem = TreeView_GetNextSibling(hWndTV, hItem);
    while(hItem)
    {
        TV_ITEM tvI = {0};
        // Find all the Groups in this folder
        tvI.mask = TVIF_PARAM | TVIF_HANDLE;
        tvI.hItem = hItem;
        if(TreeView_GetItem(hWndTV, &tvI))
        {
            if(tvI.lParam && ((LPTVITEM_STUFF)tvI.lParam)->ulObjectType==MAPI_ABCONT)
            {
                LPTVITEM_STUFF lptvStuff = (LPTVITEM_STUFF) tvI.lParam;
                SPropertyRestriction PropRes = {0};
		        SPropValue sp = {0};
                HRESULT hr = S_OK;
                ULONG ulCount = 0;
                LPSBinary rgsbEntryIDs = NULL;

                sp.ulPropTag = PR_OBJECT_TYPE;
		        sp.Value.l = MAPI_DISTLIST;

                PropRes.ulPropTag = PR_OBJECT_TYPE;
                PropRes.relop = RELOP_EQ;
                PropRes.lpProp = &sp;

                if(!HR_FAILED(hr = FindRecords(   lpIAB->lpPropertyStore->hPropertyStore,
							        lptvStuff->lpsbEID, 0, TRUE, &PropRes,
                                    &ulCount,&rgsbEntryIDs)))
                {
                    ULONG i;
                    for(i=0;i<ulCount;i++)
                        AddTVFolderGroup(lpbwi, hWndTV, hItem, lptvStuff->lpsbEID, &(rgsbEntryIDs[i]));

                    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulCount, rgsbEntryIDs);
                }
            }
        }

        TreeView_SortChildren(hWndTV, hItem, 0);
        
        // Start at the top level, look for children, 
        // if no children, look for next sibling,
        // if no sibling, look for parent's sibling
        {
            HTREEITEM hTemp = NULL;
            if(nDepth < 1) // Assumes we only have 2 levels of folders - this way we don't look at the third level which may only have groups
                hTemp = TreeView_GetChild(hWndTV, hItem);
            if(hTemp)
                nDepth++;
            else
                hTemp = TreeView_GetNextSibling(hWndTV, hItem);
            if(!hTemp)
            {
                if(hTemp = TreeView_GetParent(hWndTV, hItem))
                {
                    nDepth--;
                    hTemp = TreeView_GetNextSibling(hWndTV, hTemp);
                }
            }
            hItem = hTemp;
        }
    }

    if(!lpsbSelection && bIsThereACurrentUser(bwi_lpIAB))
        lpsbSelection = &bwi_lpIAB->lpWABCurrentUserFolder->sbEID;

    UpdateTVGroupSelection(hWndTV, lpsbSelection);

    //if(!lpsbSelection || !lpsbSelection->cb || !lpsbSelection->lpb)
    {
        LPSBinary lpsb = NULL;
        //UpdateListViewContents(lpbwi, &sb, MAPI_ABCONT);
        ULONG ulObjectType;
        GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsb, &ulObjectType, FALSE);
        UpdateListViewContents(lpbwi, lpsb, ulObjectType);
        LocalFreeSBinary(lpsb);
    }

    SendMessage(hWndTV, WM_SETREDRAW, (WPARAM) TRUE, 0);

    bwi_bDontRefreshLV = FALSE;
    
    LeaveCriticalSection(&lpIAB->cs);

    {
        // if there is only a single item in the tree view, remove the haslines style
        // as it looks pretty strange..
        //
        DWORD dwStyle = GetWindowLong(hWndTV, GWL_STYLE);
        int nCount = TreeView_GetCount(hWndTV);
        if(nCount > 1)
            dwStyle |= TVS_HASLINES;
        else
            dwStyle &= ~TVS_HASLINES;
        SetWindowLong(hWndTV, GWL_STYLE, dwStyle);
    }

    return;
}



typedef struct _FolderInfo
{
    BOOL bIsReadOnly;       // Sets DLG ctrls to readonly
    BOOL bIsShared;         // Indicates if shared
    BOOL bForceShared;      // Indicates that shared-checkbox should be shared and non-modifiable
    LPTSTR lpsz;            // Folder name (in and out param)
    LPTSTR lpszOldName;     // Old name so we can track name changes
    LPTSTR lpszOwnerName;   // Person who created this folder
    LPIAB lpIAB;
    LPSBinary lpsbEID;      // EID of the folder
    LPWABFOLDER lpParentFolder; // Parent folder this folder will be associated with
    SBinary sbNew;          // returned new EID of new folder
} FINFO, * LPFINFO;

//$$
/* 
-   fnFolderDlgProc
-
*   Dialog proc for the Folder dialog
*
*/
INT_PTR CALLBACK fnFolderDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            LPFINFO lpfi = (LPFINFO) lParam;
            LPTSTR lpsz = lpfi->lpsz;
            HWND hWndCheck = GetDlgItem(hDlg, IDC_FOLDER_CHECK_SHARE);
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) lpfi); //Save this for future reference
            SendMessage(GetDlgItem(hDlg,IDC_FOLDER_EDIT_NAME), EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR-1,0);
            if(lpsz && lstrlen(lpsz))
                SetDlgItemText(hDlg, IDC_FOLDER_EDIT_NAME, lpsz);
            CheckDlgButton(hDlg, IDC_FOLDER_CHECK_SHARE, (lpfi->bIsShared ? BST_CHECKED : BST_UNCHECKED));
            if(lpfi->lpszOwnerName)
            {
                TCHAR sz[MAX_PATH];
                TCHAR szTmp[MAX_PATH], *lpszTmp;
                *sz = '\0';
                GetDlgItemText(hDlg, IDC_FOLDER_STATIC_CREATEDBY, sz, CharSizeOf(sz));
                if(sz && lstrlen(sz))
                {
                    LPTSTR lpsz = NULL;
                    CopyTruncate(szTmp, lpfi->lpszOwnerName, MAX_PATH - 1);
                    lpszTmp = szTmp;

                    if(FormatMessage(  FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                    sz, 0, 0, (LPTSTR) &lpsz, 0, (va_list *)&lpszTmp))
                    {
                        SetDlgItemText(hDlg, IDC_FOLDER_STATIC_CREATEDBY, lpsz);
                        LocalFree(lpsz);
                        ShowWindow(GetDlgItem(hDlg, IDC_FOLDER_STATIC_CREATEDBY), SW_SHOWNORMAL);
                    }
                    
                }
            }
            if(lpfi->bIsReadOnly)
            {
                SendDlgItemMessage(hDlg, IDC_FOLDER_EDIT_NAME, EM_SETREADONLY, (WPARAM) TRUE, 0);
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                EnableWindow(hWndCheck, FALSE);
                SendMessage(hDlg, DM_SETDEFID, IDCANCEL, 0);
                SetFocus(GetDlgItem(hDlg,IDCANCEL));
            }
            else
                SetFocus(GetDlgItem(hDlg,IDC_FOLDER_EDIT_NAME));
            if(lpfi->bForceShared)
            {
                CheckDlgButton(hDlg, IDC_FOLDER_CHECK_SHARE, BST_CHECKED);
                EnableWindow(hWndCheck, FALSE);
            }
            if(!bDoesThisWABHaveAnyUsers(lpfi->lpIAB))
            {
                // there are no users configured so hide the sharing option
                EnableWindow(hWndCheck, FALSE);
                ShowWindow(hWndCheck, SW_HIDE);
            }


        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: 
            switch(LOWORD(wParam))
            { //update title as necessary
            case IDC_FOLDER_EDIT_NAME:
                {
                    TCHAR szBuf[MAX_UI_STR];
                    if(GetWindowText((HWND) lParam,szBuf,CharSizeOf(szBuf)))
	                    SetWindowPropertiesTitle(hDlg, szBuf);
                }
                break;
            }
            break;
        }
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            // Check that text is filled in
            {
                TCHAR sz[MAX_UI_STR];
                GetDlgItemText(hDlg, IDC_FOLDER_EDIT_NAME, sz, CharSizeOf(sz));
                if(!lstrlen(sz))
                {
                    ShowMessageBox(hDlg, idsAddFolderName, MB_ICONINFORMATION | MB_OK);
                    return FALSE;
                }
                else
                {
                    LPFINFO lpfi = (LPFINFO) GetWindowLongPtr(hDlg,DWLP_USER); 
                    LPTSTR lpsz = lpfi->lpsz;
                    HRESULT hr = S_OK;
                    BOOL bShared = IsDlgButtonChecked(hDlg, IDC_FOLDER_CHECK_SHARE);

                    if(lpfi->lpsbEID && sz) //existing entry
                    {
                        ULONG ulFlags = 0;
                        // Did the name change or sharing info changed
                        if(lstrcmp(sz, lpfi->lpszOldName)!=0)
                            ulFlags |= FOLDER_UPDATE_NAME;
                        if(lpfi->bIsShared!=bShared)
                            ulFlags |= FOLDER_UPDATE_SHARE;
                        
                        if(ulFlags)
                        {
                            if(!HR_FAILED(hr = HrUpdateFolderInfo(lpfi->lpIAB, lpfi->lpsbEID, ulFlags, bShared, sz)))
                            {
                                //reload the profiles so that this is updated
                                HrGetWABProfiles(lpfi->lpIAB);
                            }
                        }
                    }
                    else
                    {
                        // if we're here we have a valid folder name ..
                        hr = HrCreateNewFolder( lpfi->lpIAB, sz, 
                                                lstrlen(lpfi->lpIAB->szProfileID)?lpfi->lpIAB->szProfileID:NULL, 
                                                FALSE, lpfi->lpParentFolder, bShared, &lpfi->sbNew);
                    }
                    if(HR_FAILED(hr))
                    {
                        if(hr == MAPI_E_COLLISION)
                            ShowMessageBox(hDlg, idsEntryAlreadyInWAB, MB_ICONINFORMATION | MB_OK);
                        else
                            ShowMessageBox(hDlg, idsCouldNotSelectUser, MB_ICONEXCLAMATION | MB_OK);
                        return FALSE;
                    }

                }
            }
            EndDialog(hDlg, IDOK);
            break;
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;
        }
        break;
    }

    return FALSE;
}

/*
-   HrFolderProperties 
-
*   if FolderEID is NULL,    
*   Creates a newfolder, adds it to the current profile, updates the UI
*   in TreeView and in the View | Folders menu ...
*   else opens properties on the folder so user can change the name
*   if desired
*
*   lpsbEID - NULL if creating a new folder else EID of folder to view
*   lpParentFolder - User folder under which this is being created
*   lpsbnew - return EID of newly created folder
*/
HRESULT HrFolderProperties(HWND hWndParent, LPIAB lpIAB, LPSBinary lpsbEID, 
                           LPWABFOLDER lpParentFolder, LPSBinary lpsbNew)
{

    HRESULT hr = S_OK;
    int nRetVal;
    TCHAR sz[MAX_UI_STR];
    LPTSTR lpsz = NULL;
    FINFO fi = {0};

    fi.lpszOwnerName = NULL;

    *sz = '\0';
    if(lpsbEID)
    {
        LPWABFOLDER lpFolder  = FindWABFolder(lpIAB, lpsbEID, NULL, NULL);
        if( (!lpsbEID->cb && !lpsbEID->lpb) )
            fi.bIsShared = TRUE;
        if( (!lpsbEID->cb && !lpsbEID->lpb) ||
            (lpFolder && lpFolder->lpProfileID && lstrlen(lpFolder->lpProfileID)) )
            fi.bIsReadOnly = TRUE;
        if(lpFolder)
        {
            StrCpyN(sz, lpFolder->lpFolderName, ARRAYSIZE(sz));
            fi.lpszOldName = lpFolder->lpFolderName;
            fi.bIsShared = lpFolder->bShared;
            fi.lpszOwnerName = lpFolder->lpFolderOwner;
        }
        else
        {
            LoadString(hinstMapiX, idsSharedContacts/*idsAllContacts*/, sz, ARRAYSIZE(sz));
        }
    }
    else
    {
        // this is a new folder ..
        // if it doesn't have a parent and userfolders are already configured then it's being created
        // in the shared folders in which case we should force the shared-folder option
        if(bDoesThisWABHaveAnyUsers(lpIAB) && !lpParentFolder)
            fi.bForceShared = TRUE;
    }
    fi.lpsz = sz;
    fi.lpIAB = lpIAB;
    fi.lpsbEID  = lpsbEID;
    fi.lpParentFolder = lpParentFolder;

    nRetVal = (int) DialogBoxParam( hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_FOLDER),
		                     hWndParent, fnFolderDlgProc, (LPARAM) &fi);
    if(nRetVal == IDCANCEL)
    {
        hr = MAPI_E_USER_CANCEL;
        goto out;
    }

    if(lpsbNew)
        SetSBinary(lpsbNew, fi.sbNew.cb, fi.sbNew.lpb);
out:
    LocalFreeAndNull((LPVOID *) (&fi.sbNew.lpb));
    return hr;
}


/*
-   UpdateLV
-
*   Refreshes the list view based on the current selection
*
*/
void UpdateLV(LPBWI lpbwi)
{
    ULONG ulObjectType = 0;
    LPSBinary lpsbEID = NULL;
    bwi_hti = NULL;
    GetCurrentSelectionEID(lpbwi, bwi_hWndTV, &lpsbEID, &ulObjectType, FALSE);
    UpdateListViewContents(lpbwi, lpsbEID, ulObjectType);
    LocalFreeSBinary(lpsbEID);
    bwi_bDeferNotification = TRUE;
}

#ifdef COLSEL_MENU 
/**
This function will update the listview and write the selected custom column selections out
to the registry.
*/
BOOL UpdateOptionalColumns( LPBWI lpbwi, ULONG iColumn )
{
    LVCOLUMN lvCol = {0}; 
    HKEY hKey = NULL;
    LPTSTR lpszColTitle = (iColumn == colHomePhone ) ? szCustomProp1 : szCustomProp2;        
    ULONG ulProp = (iColumn == colHomePhone ) ? PR_WAB_CUSTOMPROP1 : PR_WAB_CUSTOMPROP2;
    DWORD cbProp = 0;
    LPIAB lpIAB = bwi_lpIAB;
    HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
    DWORD dwDisposition = 0;
    BOOL fRet = FALSE;
    TCHAR szBuf[MAX_PATH];

    if( iColumn != colHomePhone && iColumn != colOfficePhone )
        goto exit;

    LoadString(hinstMapiX, lprgAddrBookColHeaderIDs[iColumn], szBuf, ARRAYSIZE(szBuf));
    lvCol.mask = LVCF_TEXT;
    lvCol.pszText = (lpszColTitle && lstrlen(lpszColTitle))? lpszColTitle : szBuf;
    if( !ListView_SetColumn( bwi_hWndListAB, iColumn, &lvCol ) )
    {
        DebugTrace( TEXT("could not setcolumntext: %x\n"), GetLastError() );
        goto exit;
    }
    if(ulProp)
    {
        // begin registry stuff
        if (ERROR_SUCCESS != RegCreateKeyEx(hKeyRoot, lpNewWABRegKey, 0,      //reserved
                                            NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                            NULL, &hKey, &dwDisposition))
        {
            goto exit;
        }
        cbProp = sizeof( ULONG );
        if(ERROR_SUCCESS != RegSetValueEx(  hKey, 
                                            (iColumn == colHomePhone ? szPropTag1 : szPropTag2), 
                                            0, REG_DWORD, (LPBYTE)&ulProp, cbProp))
            goto exit;
    }
    fRet = TRUE;
exit:
    if(hKey)
        RegCloseKey(hKey);
    return fRet;
}

#endif // COLSEL_MENU 


/*
-   HrExportWAB
-
*   Supposed to export data out of the .WAB into another .wab file.
*   Ideally, user should be able to specify an existing WAB file and  TEXT("push") data
*   into that file from this file.
*   Instead, we do a cheesy implementation here where we let the user specify a file name to
*   create and we then just copy the current .WAB file to the new file name
*   
*   Obviously this method doesn't work when WAB is sharing the Outlook store and in that
*   case we remove this option from the Menu
*
*/
extern BOOL PromptForWABFile(HWND hWnd, LPTSTR szFile, DWORD cchSizeFile, BOOL bOpen);

HRESULT HrExportWAB(HWND hWnd, LPBWI lpbwi)
{
    HRESULT hr = E_FAIL;
    TCHAR szFile[MAX_PATH];
    HCURSOR hOldC = NULL;

    if (!PromptForWABFile(hWnd, szFile, ARRAYSIZE(szFile), FALSE))
    {
        hr = MAPI_E_USER_CANCEL;
        goto out;
    }

    //Check if file already exists ..
    if(0xFFFFFFFF != GetFileAttributes(szFile))
    {
        // Ask user if they want to overwrite
        if(IDNO == ShowMessageBoxParam(hWnd,
                                    IDE_VCARD_EXPORT_FILE_EXISTS,
                                    MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND,
                                    szFile))
        {
            hr = MAPI_E_USER_CANCEL;
            goto out;
        }
    }
    
    hOldC = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Still here, means go ahead and copy the current .wab file to the new place ...
    if(!CopyFile(GetWABFileName(bwi_lpIAB->lpPropertyStore->hPropertyStore,FALSE), szFile, FALSE))
    {
        DebugTrace( TEXT("WAB File export failed: %d\n"), GetLastError());
        goto out;
    }

    if(hOldC)
    {
        SetCursor(hOldC);
        hOldC = NULL;
    }
    ShowMessageBoxParam(hWnd, idsWABExportSuccess, MB_OK | MB_ICONEXCLAMATION, szFile);

    hr = S_OK;
out:
    if(HR_FAILED(hr) && hr!=MAPI_E_USER_CANCEL)
        ShowMessageBox(hWnd, idsExportError, MB_OK | MB_ICONEXCLAMATION);

    if(hOldC)
        SetCursor(hOldC);
    return hr;
}



void DestroyImageLists(LPBWI lpbwi)
{
    HIMAGELIST  hImageList;

    if (NULL == gpfnImageList_Destroy)
        return;

    if (IsWindow(bwi_hWndTools))
    {
        // Destroy Image Lists created in ui_clbar.cpp's InitToolbar()
        hImageList = (HIMAGELIST) SendMessage(bwi_hWndTools, TB_GETIMAGELIST, 0, 0);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);

        hImageList = (HIMAGELIST) SendMessage(bwi_hWndTools, TB_GETHOTIMAGELIST, 0, 0);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);

        hImageList = (HIMAGELIST) SendMessage(bwi_hWndTools, TB_GETDISABLEDIMAGELIST, 0, 0);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);
    }

    if (IsWindow(bwi_hWndTV))
    {
        // Destroy Image Lists created in ui_abook.c's InitChildren()
        hImageList = TreeView_GetImageList (bwi_hWndTV, TVSIL_NORMAL);
        if (NULL != hImageList)
            gpfnImageList_Destroy(hImageList);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_addr.c ===
/*--------------------------------------------------------------
*
*
*   ui_addr.c - contains stuff for showing the :Address UI
*
*
*
*
*
*
*
--------------------------------------------------------------*/
#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;

#define SET_UNICODE_STR(lp1,lp2,lpAdrParms)   if(lpAdrParms->ulFlags & MAPI_UNICODE)\
                                                  lp1 = (LPWSTR)lp2;                      \
                                              else                                        \
                                                  lp1 = ConvertAtoW((LPSTR)lp2);          \

#define FREE_UNICODE_STR(lp1,lp2)   if(lp1 != lp2) LocalFreeAndNull(&lp1);

typedef struct _AddressParms
{
    LPADRBOOK   lpIAB;              //Stores a pointer to the ADRBOOK object
    LPADRPARM   lpAdrParms;         //AdrParms structure passed into Address
    LPADRLIST   *lppAdrList;        //AdrList of input names
    HANDLE      hPropertyStore;     //pointer to the property store
    int         DialogState;        //Identifies the ongoing function
    LPRECIPIENT_INFO lpContentsList;//Contains a list of entries in the contents structure
    LPRECIPIENT_INFO lpListTo;      //Entries in the To Well
    LPRECIPIENT_INFO lpListCC;      //Entries in the CC well
    LPRECIPIENT_INFO lpListBCC;     //Entries in the BCC well
    SORT_INFO  SortInfo;            //Contains current sort info
    int        nContextID;      //identifies which list view called the context menu
    BOOL       bDontRefresh;    //Used to ensure that nothing refreshes during modal operations
    BOOL       bLDAPinProgress;
    HCURSOR    hWaitCur;
    int        nRetVal;
    LPMAPIADVISESINK lpAdviseSink;
    ULONG       ulAdviseConnection;
    BOOL        bDeferNotification; // Used to defer next notification request
    HWND        hDlg;
    HWND        hWndAddr;
}   ADDRESS_PARMS, *LPADDRESS_PARMS;


enum _lppAdrListReturnedProps
{
    propPR_DISPLAY_NAME,
    propPR_ENTRYID,
    propPR_RECIPIENT_TYPE,
    TOTAL_ADRLIST_PROPS
};


static DWORD rgAddrHelpIDs[] =
{
    IDC_ADDRBK_EDIT_QUICKFIND,      IDH_WAB_PICK_RECIP_TYPE_NAME,
    IDC_ADDRBK_STATIC_CONTENTS,     IDH_WAB_PICK_RECIP_NAME_LIST,
    IDC_ADDRBK_LIST_ADDRESSES,      IDH_WAB_PICK_RECIP_NAME_LIST,
    IDC_ADDRBK_BUTTON_PROPS,        IDH_WAB_PICK_RECIP_NAME_PROPERTIES,
    IDC_ADDRBK_BUTTON_NEW,          IDH_WAB_PICK_RECIP_NAME_NEW,
    IDC_ADDRBK_BUTTON_TO,           IDH_WAB_PICK_RECIP_NAME_TO_BUTTON,
    IDC_ADDRBK_BUTTON_CC,           IDH_WAB_PICK_RECIP_NAME_CC_BUTTON,
    IDC_ADDRBK_BUTTON_BCC,          IDH_WAB_PICK_RECIP_NAME_BCC_BUTTON,
    IDC_ADDRBK_LIST_TO,             IDH_WAB_PICK_RECIP_NAME_TO_LIST,
    IDC_ADDRBK_LIST_CC,             IDH_WAB_PICK_RECIP_NAME_CC_LIST,
    IDC_ADDRBK_LIST_BCC,            IDH_WAB_PICK_RECIP_NAME_BCC_LIST,
    IDC_ADDRBK_BUTTON_DELETE,       IDH_WAB_PICK_RECIP_NAME_DELETE,
    IDC_ADDRBK_BUTTON_NEWGROUP,     IDH_WAB_PICK_RECIP_NAME_NEW_GROUP,
    IDC_ADDRBK_STATIC_RECIP_TITLE,  IDH_WAB_COMM_GROUPBOX,
    IDC_ADDRBK_BUTTON_FIND,         IDH_WAB_PICK_RECIP_NAME_FIND,
    IDC_ADDRBK_COMBO_CONT,          IDH_WAB_GROUPS_CONTACTS_FOLDER,
    0,0
};

// forward declarations

INT_PTR CALLBACK fnAddress(HWND    hDlg,
                           UINT    message,
                           WPARAM  wParam,
                           LPARAM  lParam);


BOOL SetAddressBookUI(HWND hDlg,
                      LPADDRESS_PARMS lpAP);

void FillListFromCurrentContainer(HWND hDlg, LPADDRESS_PARMS lpAP);

BOOL FillWells(HWND hDlg, LPADRLIST lpAdrList, LPADRPARM lpAdrParms, LPRECIPIENT_INFO * lppListTo, LPRECIPIENT_INFO * lppListCC, LPRECIPIENT_INFO * lppListBCC);

BOOL ListDeleteItem(HWND hDlg, int CtlID, LPRECIPIENT_INFO * lppList);

BOOL ListAddItem(HWND hDlg, HWND hWndAddr, int CtlID, LPRECIPIENT_INFO * lppList, ULONG RecipientType);

void UpdateLVItems(HWND hWndLV,LPTSTR lpszName);

void ShowAddrBkLVProps(LPIAB lpIAB, HWND hDlg, HWND hWndAddr, LPADDRESS_PARMS lpAP, LPFILETIME lpftLast);

HRESULT HrUpdateAdrListEntry(	LPADRBOOK	lpIAB,
								LPENTRYID	lpEntryID,
								ULONG cbEntryID,
                                ULONG ulFlags,
								LPADRLIST * lppAdrList);

enum _AddressDialogReturnValues
{
    ADDRESS_RESET = 0,  //Blank initialization value
    ADDRESS_CANCEL,
    ADDRESS_OK,
};


//$$/////////////////////////////////////////////////////////////////////////////////////////
//
// FillContainerCombo - Fills the container combo with container names
//
/////////////////////////////////////////////////////////////////////////////////////////////
void FillContainerCombo(HWND hWndCombo, LPIAB lpIAB)
{
	ULONG iolkci, colkci;
	OlkContInfo *rgolkci;
    int nPos, nDefault=0;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    
    // Clear out the combo
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

	Assert(lpIAB);

    EnterCriticalSection(&lpIAB->cs);
    if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware(lpIAB))
    {
        colkci = pt_bIsWABOpenExSession ? lpIAB->lpPropertyStore->colkci : lpIAB->cwabci;
	    Assert(colkci);
        rgolkci = lpIAB->lpPropertyStore->colkci ? lpIAB->lpPropertyStore->rgolkci : lpIAB->rgwabci;
	    Assert(rgolkci);

        // Add the multiple folders here
        for(iolkci = 0; iolkci < colkci; iolkci++)
        {
            nPos = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) rgolkci[iolkci].lpszName);
            if(nPos != CB_ERR)
                SendMessage(hWndCombo, CB_SETITEMDATA, (WPARAM)nPos, (LPARAM) (DWORD_PTR)(iolkci==0 ? NULL : rgolkci[iolkci].lpEntryID));
            if( bIsThereACurrentUser(lpIAB) && 
                !lstrcmpi(lpIAB->lpWABCurrentUserFolder->lpFolderName, rgolkci[iolkci].lpszName) &&//folder names are unique
                nPos != CB_ERR)
            {
                nDefault = nPos;
            }
        }
    }
    LeaveCriticalSection(&lpIAB->cs);
    SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nDefault, 0);
}



//$$*------------------------------------------------------------------------
//| IAddrBook::Advise::OnNotify handler
//|
//*------------------------------------------------------------------------
ULONG AddrAdviseOnNotify(LPVOID lpvContext, ULONG cNotif, LPNOTIFICATION lpNotif)
{
    LPADDRESS_PARMS lpAP = (LPADDRESS_PARMS) lpvContext;

    DebugTrace( TEXT("+++ AddrAdviseOnNotify ===\n"));

    if(lpAP->bDeferNotification)
    {
        DebugTrace( TEXT("+++ Advise Defered ===\n"));
        lpAP->bDeferNotification = FALSE;
        return S_OK;
    }
    if(!lpAP->bDontRefresh)
    {
        DebugTrace( TEXT("+++ Calling FillListFromCurrentContainer ===\n"));
        FillListFromCurrentContainer(lpAP->hDlg, lpAP);
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////
//
// ShowAddressUI - does some parameter checking and calls the PropertySheets
//
//
//
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowAddressUI(IN  LPADRBOOK   lpIAB,
                        IN  HANDLE      hPropertyStore,
					    IN  ULONG_PTR * lpulUIParam,
					    IN  LPADRPARM   lpAdrParms,
					    IN  LPADRLIST  *lppAdrList)
{
    HRESULT hr = E_FAIL;
    //ADDRESS_PARMS AP = {0};
    LPADDRESS_PARMS lpAP = NULL;
    TCHAR szBuf[MAX_UI_STR];

    HWND hWndParent = NULL;
    int nRetVal = 0;
    int DialogState = 0;

    //Addref the AdrBook object to make sure it stays valid throughout ..
    // Remember to release before leaving ...
    // NOTE: Must be before any jumps to out!
    UlAddRef(lpIAB);

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if (lpulUIParam)
        hWndParent = (HWND) *lpulUIParam;

    if ( // Can't pick-user with wells
        ((lpAdrParms->ulFlags & ADDRESS_ONE) && (lpAdrParms->cDestFields != 0)) ||
         // cDestFields has limited for tier 0.5
        (lpAdrParms->cDestFields > 3) ||
         // Cant pick user without an input lpAdrList
        //((lpAdrParms->ulFlags & ADDRESS_ONE) && (*lppAdrList == NULL)) ||
        ((lpAdrParms->ulFlags & DIALOG_SDI) && (lpAdrParms->cDestFields != 0)) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    //
    // The possible states of this dialog box are
    // 1. Select recipients Wells shown, returns an AdrList of picked up entries, Cant delete entries
    // 2. Select a single user, No wells shown, single selection, cannot delete, must have input Adrlist
    // 3. Open for browsing only, multiple selection, can create delete, create, view details

    // Determine what the dialog state is
    if (lpAdrParms->cDestFields > 0)
    {
        //lpAP->DialogState = STATE_SELECT_RECIPIENTS;
        DialogState = STATE_SELECT_RECIPIENTS;
    }
    else if (lpAdrParms->ulFlags & ADDRESS_ONE)
    {
        DialogState = STATE_PICK_USER;
    }
    else if (lpAdrParms->ulFlags & DIALOG_MODAL)
    {
        DialogState = STATE_BROWSE_MODAL;
    }
    else if (lpAdrParms->ulFlags & DIALOG_SDI)
    {
        DialogState = STATE_BROWSE;
    }


	if (DialogState == STATE_BROWSE)
	{
		// Show the browse window and leave
		//
		HWND hWndAB = NULL;
		hWndAB = hCreateAddressBookWindow(	lpIAB,
											hWndParent,
											lpAdrParms);
		if (hWndAB)
        {
            *lpulUIParam = (ULONG_PTR) hWndAB;
			hr = S_OK;
        }
		goto out;

	}

    lpAP = LocalAlloc(LMEM_ZEROINIT, sizeof(ADDRESS_PARMS));

	if (!lpAP)
	{
		hr = MAPI_E_NOT_ENOUGH_MEMORY;
		goto out;
	}

	lpAP->DialogState = DialogState;


    lpAP->lpIAB = lpIAB;
    lpAP->lpAdrParms = lpAdrParms;
    lpAP->lppAdrList = lppAdrList;
    lpAP->hPropertyStore = hPropertyStore;

    ReadRegistrySortInfo((LPIAB)lpIAB, &(lpAP->SortInfo));

    lpAP->lpContentsList = NULL;

    lpAP->bDontRefresh = FALSE;

    lpAP->bLDAPinProgress = FALSE;
    lpAP->hWaitCur = NULL;

    HrAllocAdviseSink(&AddrAdviseOnNotify, (LPVOID) lpAP, &(lpAP->lpAdviseSink));

    nRetVal = (int) DialogBoxParam( hinstMapiX,
                              MAKEINTRESOURCE(IDD_DIALOG_ADDRESSBOOK),
                              hWndParent,
                              fnAddress,
                              (LPARAM) lpAP);
    switch(nRetVal)
    {
    case -1: //some error occured
        hr = E_FAIL;
        break;
    case ADDRESS_CANCEL:
        hr = MAPI_E_USER_CANCEL;
        break;
    case ADDRESS_OK:
    default:
        hr = S_OK;
        break;
    }

    if(lpAP->lpAdviseSink)
    {
        lpAP->lpIAB->lpVtbl->Unadvise(lpAP->lpIAB, lpAP->ulAdviseConnection);
        lpAP->lpAdviseSink->lpVtbl->Release(lpAP->lpAdviseSink);
        lpAP->lpAdviseSink = NULL;
        lpAP->ulAdviseConnection = 0;
    }

out:

    lpIAB->lpVtbl->Release(lpIAB);

    LocalFreeAndNull(&lpAP);
    return hr;
}


#define lpAP_lppContentsList    (&(lpAP->lpContentsList))
#define lpAP_lppListTo          (&(lpAP->lpListTo))
#define lpAP_lppListCC          (&(lpAP->lpListCC))
#define lpAP_lppListBCC         (&(lpAP->lpListBCC))
#define lpAP_bDontRefresh       (lpAP->bDontRefresh)
#define _hWndAddr               lpAP->hWndAddr


//$$/////////////////////////////////////////////////////////////////////////////
//
// GetCurrentComboSelection - Get the current selection from the combo 
//
/////////////////////////////////////////////////////////////////////////////////
LPSBinary GetCurrentComboSelection(HWND hWndCombo)
{
    int nPos = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    LPSBinary lpsbCont = NULL;

    if(nPos == CB_ERR)
        nPos = 0;
    lpsbCont = (LPSBinary) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) nPos, 0);
    if(CB_ERR == (DWORD_PTR) lpsbCont)
        lpsbCont = NULL;

    return lpsbCont;
}
//$$/////////////////////////////////////////////////////////////////////////////
//
// FillListFromCurrentContainer - Get the selection from the combo and fill it
//
/////////////////////////////////////////////////////////////////////////////////
void FillListFromCurrentContainer(HWND hDlg, LPADDRESS_PARMS lpAP)
{
    HWND hWndAddr = GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES);
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPSBinary lpsbCont = NULL;

    if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB))
    {
        HWND hWndCombo = GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT);
        int nPos = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

        if(nPos != CB_ERR)
        {
            // Refill the combo in case the folder list changed
            FillContainerCombo(hWndCombo, (LPIAB)lpAP->lpIAB);
            nPos = (int) SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nPos, 0);
        }
        lpsbCont = GetCurrentComboSelection(hWndCombo);
    }

    HrGetWABContents(   hWndAddr,
                        lpAP->lpIAB, lpsbCont,
                        lpAP->SortInfo, lpAP_lppContentsList);
}


extern BOOL APIENTRY_16 fnFolderDlgProc(HWND hDlg, UINT message, UINT wParam, LPARAM lParam);


/////////////////////////////////////////////////////////////////////////////////
//
// fnAddress - the PropertySheet Message Handler
//
//
//
/////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK fnAddress(HWND    hDlg,
                           UINT    message,
                           WPARAM  wParam,
                           LPARAM  lParam)
{
    static FILETIME ftLast = {0};

    LPADDRESS_PARMS lpAP = (LPADDRESS_PARMS ) GetWindowLongPtr(hDlg,DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference
        lpAP = (LPADDRESS_PARMS) lParam;

        lpAP->hWndAddr = GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES);
        lpAP->hDlg = hDlg;
        lpAP_bDontRefresh = FALSE;

        lpAP->nContextID = IDC_ADDRBK_LIST_ADDRESSES;

        SetAddressBookUI(hDlg,lpAP);

        // if this is a pick-user dialog, need to have the names by
        // first name so we can find the closest match ..
        if(lpAP->DialogState == STATE_PICK_USER)
            (lpAP->SortInfo).bSortByLastName = FALSE;


        FillListFromCurrentContainer(hDlg, lpAP);


        if (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
        {
            FillWells(hDlg,*(lpAP->lppAdrList),(lpAP->lpAdrParms),lpAP_lppListTo,lpAP_lppListCC,lpAP_lppListBCC);

            // we want to highlight the first item in the list
            if (ListView_GetItemCount(_hWndAddr) > 0)
                LVSelectItem( _hWndAddr, 0);
        }
        else if (lpAP->DialogState == STATE_PICK_USER &&
                 *(lpAP->lppAdrList) )
        {
            // if this is a pick user dialog, then try to match the supplied name to the
            // closest entry in the List Box
            if (ListView_GetItemCount(_hWndAddr) > 0)
            {
                LPTSTR lpszDisplayName = NULL;
                ULONG i;

                // Scan only the first entry in the lpAdrList for a display name
                for(i=0;i< (*(lpAP->lppAdrList))->aEntries[0].cValues;i++)
                {
                    ULONG ulPropTag = PR_DISPLAY_NAME;
                    if(!(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE))
                        ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
                    if((*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].ulPropTag == ulPropTag)
                    {
                        SET_UNICODE_STR(lpszDisplayName, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ,lpAP->lpAdrParms);
                        break;
                    }
                }

                if (lpszDisplayName)
                {
                    // We have Something to search for
                    TCHAR szBuf[MAX_UI_STR];
                    ULONG nLen;
                    LV_FINDINFO lvF = {0};

                    // Typically, we are not going to get a full match ...
                    // Instead we want to make a partial match on disply name.
                    // The ListViewFindItem does an exact partial match if the supplied
                    // string matches the first few entries of an existing item
                    // Hence, to obtain a semi-partial match, we start with the
                    // original Display Name working our way backwards from last
                    // character to first character until we get a match or run
                    // out of characters.

                    int iItemIndex = -1;
                    nLen = lstrlen(lpszDisplayName);

                    if (nLen >= CharSizeOf(szBuf))
                        nLen = CharSizeOf(szBuf)-1;
                    lvF.flags = LVFI_PARTIAL | LVFI_STRING;

                    while((nLen > 0) && (iItemIndex == -1))
                    {
                        nLen = TruncatePos(lpszDisplayName, nLen);
                        if (nLen==0) break;

                        CopyMemory(szBuf, lpszDisplayName, sizeof(TCHAR)*nLen);
                        szBuf[nLen] = '\0';

                        lvF.psz = szBuf;
                        iItemIndex = ListView_FindItem(_hWndAddr,-1, &lvF);

                        nLen--;
                    }

                    // Set focus to the selected item or to the first item in the list

                    if (iItemIndex < 0) iItemIndex = 0;

					LVSelectItem(_hWndAddr, iItemIndex);

                    FREE_UNICODE_STR(lpszDisplayName, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ);
                }
            }
        }

        if(lpAP->lpAdviseSink)
        {
            // Register for notifications
            lpAP->lpIAB->lpVtbl->Advise(lpAP->lpIAB, 0, NULL, fnevObjectModified, 
                                        lpAP->lpAdviseSink, &lpAP->ulAdviseConnection); 
        }

        if (ListView_GetSelectedCount(_hWndAddr) <= 0)
            LVSelectItem(_hWndAddr, 0);
        
        // if we want the user to pick something actively, we disable OK until they click on something 
        // or do something specific ..
        if( lpAP->DialogState == STATE_PICK_USER )
        {
            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE); 
            SendMessage (hDlg, DM_SETDEFID, IDCANCEL, 0);
        }

        SetFocus(GetDlgItem(hDlg,IDC_ADDRBK_EDIT_QUICKFIND));
        return FALSE;
//        return TRUE;
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(_hWndAddr, message, wParam, lParam);
        SetColumnHeaderBmp(_hWndAddr, lpAP->SortInfo);
		break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgAddrHelpIDs );
        break;

    case WM_SETCURSOR:
        if (lpAP->bLDAPinProgress)
        {
            SetCursor(lpAP->hWaitCur);
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, MAKELONG(TRUE, 0));
            return(TRUE);
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case CBN_SELCHANGE:
            FillListFromCurrentContainer(hDlg, lpAP);
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        default:
            if (lpAP->nContextID != -1)
            {
                LRESULT fRet = FALSE;
                lpAP_bDontRefresh = TRUE;
                fRet = ProcessActionCommands((LPIAB) lpAP->lpIAB,_hWndAddr, 
                                             hDlg, message, wParam, lParam);
                lpAP_bDontRefresh = FALSE;
                return fRet;
            }
            break;


        case IDC_ADDRBK_BUTTON_DELETE:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
                lpAP_bDontRefresh = TRUE;
                DeleteSelectedItems(_hWndAddr, lpAP->lpIAB, lpAP->hPropertyStore, &ftLast);
                lpAP->bDeferNotification = TRUE;
                lpAP_bDontRefresh = FALSE;
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_DELETE:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
                switch(lpAP->nContextID)
                {
                case IDC_ADDRBK_LIST_ADDRESSES:
                    lpAP_bDontRefresh = TRUE;
                    DeleteSelectedItems(_hWndAddr, lpAP->lpIAB, lpAP->hPropertyStore, &ftLast);
                    lpAP->bDeferNotification = TRUE;
                    lpAP_bDontRefresh = FALSE;
                    break;
                case IDC_ADDRBK_LIST_TO:
                    ListDeleteItem(hDlg, IDC_ADDRBK_LIST_TO, lpAP_lppListTo);
                    break;
                case IDC_ADDRBK_LIST_CC:
                    ListDeleteItem(hDlg, IDC_ADDRBK_LIST_CC, lpAP_lppListCC);
                    break;
                case IDC_ADDRBK_LIST_BCC:
                    ListDeleteItem(hDlg, IDC_ADDRBK_LIST_BCC, lpAP_lppListBCC);
                    break;
                default:
                    break;
                }
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_COPY:
            lpAP_bDontRefresh = TRUE;
            HrCopyItemDataToClipboard(hDlg, lpAP->lpIAB, GetDlgItem(hDlg,lpAP->nContextID));
            lpAP_bDontRefresh = FALSE;
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDC_ADDRBK_BUTTON_PROPS:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
                if (lpAP->nContextID != -1)
                {
                    lpAP_bDontRefresh = TRUE;
                    ShowAddrBkLVProps((LPIAB)lpAP->lpIAB, hDlg, GetDlgItem(hDlg, lpAP->nContextID), lpAP, &ftLast);
                    lpAP->bDeferNotification = TRUE;
                    lpAP_bDontRefresh = FALSE;
                }
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

/* Uncomment to enable NEW_FOLDER functionality from this dialog

        case IDM_LVCONTEXT_NEWFOLDER:
            {
                TCHAR sz[MAX_UI_STR];
                LPTSTR lpsz = NULL;
                *sz = '\0';
                if( IDCANCEL  != DialogBoxParam( hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_FOLDER),
		                                 hDlg, fnFolderDlgProc, (LPARAM) sz)
                    && lstrlen(sz)) 
                {
                    // if we're here we have a valid folder name ..
                    if(!HR_FAILED(HrCreateNewFolder((LPIAB)lpAP->lpIAB, sz, NULL, FALSE, NULL, NULL)))
                    {
                        int i,nTotal;
                        HWND hWndC = GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT);
                        // Fill in the Combo with the container names
                        FillContainerCombo(hWndC, (LPIAB)lpAP->lpIAB);
                        nTotal = SendMessage(hWndC, CB_GETCOUNT, 0, 0);
                        if(nTotal != CB_ERR)
                        {
                            // Find the item we just added in the combo and set the sel on it
                            TCHAR szC[MAX_UI_STR];
                            for(i=0;i<nTotal;i++)
                            {
                                *szC = '\0';
                                SendMessage(hWndC, CB_GETLBTEXT, (WPARAM) i, (LPARAM) szC);
                                if(!lstrcmpi(sz, szC))
                                {
                                    SendMessage(hWndC, CB_SETCURSEL, (WPARAM) i, 0);
                                    break;
                                }
                            }
                        }
                        FillListFromCurrentContainer(hDlg, lpAP);
                    }
                }
            }
            break;
*/

        case IDM_LVCONTEXT_NEWCONTACT:
        case IDC_ADDRBK_BUTTON_NEW:
            // only difference between contact and group is the object being added
        case IDM_LVCONTEXT_NEWGROUP:
        case IDC_ADDRBK_BUTTON_NEWGROUP:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG cbEID = 0;
                LPENTRYID lpEID = NULL;
                int nID = GET_WM_COMMAND_ID(wParam, lParam);
                ULONG ulObjType = (nID == IDM_LVCONTEXT_NEWCONTACT || nID == IDC_ADDRBK_BUTTON_NEW) ? MAPI_MAILUSER : MAPI_DISTLIST;
                LPSBinary lpsbContEID = NULL;

                if(bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB))
                    lpsbContEID = GetCurrentComboSelection(GetDlgItem(hDlg,IDC_ADDRBK_COMBO_CONT));

                lpAP->bLDAPinProgress = TRUE;
                lpAP_bDontRefresh = TRUE;

                AddNewObjectToListViewEx(   lpAP->lpIAB, _hWndAddr, NULL, NULL, 
                                            lpsbContEID,
                                            ulObjType,
                                            &(lpAP->SortInfo), lpAP_lppContentsList, &ftLast, &cbEID, &lpEID);

                FreeBufferAndNull(&lpEID);
                SetFocus(_hWndAddr);
                lpAP->bDeferNotification = TRUE;
                lpAP_bDontRefresh = FALSE;
                lpAP->bLDAPinProgress = FALSE;
            }
			break;


        case IDM_LVCONTEXT_ADDWELL1:
        case IDC_ADDRBK_BUTTON_TO:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG ulMapiTo = MAPI_TO;
                lpAP->bLDAPinProgress = TRUE;
                if ((lpAP->lpAdrParms->cDestFields > 0) && (lpAP->lpAdrParms->lpulDestComps))
                {
                    ulMapiTo = lpAP->lpAdrParms->lpulDestComps[0];
                }
                if(ListAddItem(hDlg, _hWndAddr, IDC_ADDRBK_LIST_TO, lpAP_lppListTo, ulMapiTo))
                    SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_ADDWELL2:
        case IDC_ADDRBK_BUTTON_CC:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG ulMapiCC = MAPI_CC;
                lpAP->bLDAPinProgress = TRUE;
                if ((lpAP->lpAdrParms->cDestFields > 0) && (lpAP->lpAdrParms->lpulDestComps))
                {
                    ulMapiCC = lpAP->lpAdrParms->lpulDestComps[1];
                }
                if(ListAddItem(hDlg, _hWndAddr, IDC_ADDRBK_LIST_CC, lpAP_lppListCC, ulMapiCC))
                    SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_ADDWELL3:
        case IDC_ADDRBK_BUTTON_BCC:
            if(!lpAP->bLDAPinProgress)
            {
                ULONG ulMapiBCC = MAPI_BCC;
                lpAP->bLDAPinProgress = TRUE;
                if ((lpAP->lpAdrParms->cDestFields > 0) && (lpAP->lpAdrParms->lpulDestComps))
                {
                    ulMapiBCC = lpAP->lpAdrParms->lpulDestComps[2];
                }
                if(ListAddItem(hDlg, _hWndAddr, IDC_ADDRBK_LIST_BCC, lpAP_lppListBCC, ulMapiBCC))
                    SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
                lpAP->bLDAPinProgress = FALSE;
            }
            break;

        case IDM_LVCONTEXT_FIND:
        case IDC_ADDRBK_BUTTON_FIND:
            if(!lpAP->bLDAPinProgress)
            {
                ADRPARM_FINDINFO apfi = {0};
                LPADRPARM_FINDINFO lpapfi = NULL;
                ULONG ulOldFlags = lpAP->lpAdrParms->ulFlags;
                lpAP->bLDAPinProgress = TRUE;

				apfi.DialogState = lpAP->DialogState;

                if (lpAP->DialogState==STATE_SELECT_RECIPIENTS)
                {
                    apfi.lpAdrParms = lpAP->lpAdrParms;
                    apfi.lppTo = lpAP_lppListTo;
                    apfi.lppCC = lpAP_lppListCC;
                    apfi.lppBCC = lpAP_lppListBCC;
                    lpapfi = &apfi;
                }
				else if (lpAP->DialogState == STATE_PICK_USER)
				{
                    TCHAR sz[MAX_UI_STR];
					LPTSTR lpsz = NULL;

                    LoadString(hinstMapiX, idsPickUserSelect, sz, CharSizeOf(sz));
                    lpsz = (LPTSTR) sz;

                    apfi.lpAdrParms = lpAP->lpAdrParms;
					apfi.lpAdrParms->cDestFields = 1;
					apfi.lpAdrParms->lppszDestTitles = &lpsz; // <TBD> use resource
                    apfi.lpAdrParms->ulFlags |= MAPI_UNICODE;
					apfi.cbEntryID = 0;
					apfi.lpEntryID = NULL;
					apfi.nRetVal = 0;
                    lpapfi = &apfi;
					{
						// Setup the Find persistent info to show the name we are trying to resolve
						ULONG i;
					    LPPTGDATA lpPTGData=GetThreadStoragePointer();
						for(i=0;i<ldspMAX;i++)
						{
                            pt_LDAPsp.szData[i][0] = TEXT('\0');
						}
                        if(*(lpAP->lppAdrList))
                        {
						    for(i=0;i<(*(lpAP->lppAdrList))->aEntries[0].cValues;i++)
						    {
                                ULONG ulPropTag = PR_DISPLAY_NAME;
                                if(!(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE))
                                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
							    if ((*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].ulPropTag == ulPropTag)
							    {
                                    LPTSTR lpTitle = NULL;
                                    SET_UNICODE_STR(lpTitle, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ,lpAP->lpAdrParms);
                                    StrCpyN(pt_LDAPsp.szData[ldspDisplayName], lpTitle, ARRAYSIZE(pt_LDAPsp.szData[ldspDisplayName]));
                                    FREE_UNICODE_STR(lpTitle, (*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ);
								    break;
							    }
						    }
                        }
					}
				}

                //lpAP_bDontRefresh = TRUE;
                HrShowSearchDialog(lpAP->lpIAB,
                                   hDlg,
                                   lpapfi,
                                   (LPLDAPURL) NULL,
                                   &(lpAP->SortInfo));

                //lpAP_bDontRefresh = FALSE;
                lpAP->bLDAPinProgress = FALSE;

                // reset
                lpAP->lpAdrParms->ulFlags = ulOldFlags;

                if (lpAP->DialogState == STATE_PICK_USER)
				{
					// Reset these fake values
					lpAP->lpAdrParms->cDestFields = 0;
					lpAP->lpAdrParms->lppszDestTitles = NULL; // <TBD> use resource

					// If the above dialog was CANCELed or CLOSEd, we dont do anything
					// If the above dialog was closed with the Use button, then we basically
					// have the person we were looking for .. we will just return that name
					// and EntryID because that is all we need to return
					if((lpapfi->nRetVal == SEARCH_USE) &&
						lpapfi->lpEntryID &&
						lpapfi->cbEntryID)
					{
                        HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

                        // Prevent the user from doing anything on this window ..
                        EnableWindow(hDlg, FALSE);

						// Figure out what to do here ...
						// We could add a hidden item to the listview, select it and send
						// an ok message to the dialog which would then do the needful.
						if(HR_FAILED(HrUpdateAdrListEntry(	
											lpAP->lpIAB,
											lpapfi->lpEntryID,
											lpapfi->cbEntryID,
                                            (lpAP->lpAdrParms->ulFlags & MAPI_UNICODE)?MAPI_UNICODE:0,
											lpAP->lppAdrList)))
						{
							lpAP->nRetVal = -1;
						}
						else
						{
							lpAP->nRetVal = ADDRESS_OK;
						}
						LocalFreeAndNull(&(lpapfi->lpEntryID));
                        lpapfi->cbEntryID = 0;
						// Since we've done our processing, we'll fall thru to
						// the cancel dialog
                        SetCursor(hOldCur);
				        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_ADDRBK_BUTTON_CANCEL, 0);
					}

				}

            }
            break;


		case IDC_ADDRBK_EDIT_QUICKFIND:
            if(!lpAP->bLDAPinProgress)
            {
                lpAP->bLDAPinProgress = TRUE;
			    switch(HIWORD(wParam)) //check the notification code
			    {
			    case EN_CHANGE: //edit box changed
    /***/
				    DoLVQuickFind((HWND)lParam,_hWndAddr);
    /***
                    DoLVQuickFilter(lpAP->lpIAB,
                                    (HWND)lParam,
                                    _hWndAddr,
                                    &(lpAP->SortInfo),
                                    AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL,
                                    1,
                                    lpAP_lppContentsList);
    ***/
				    break;
			    }
                lpAP->bLDAPinProgress = FALSE;
            }
			break;

        case IDOK:
        case IDC_ADDRBK_BUTTON_OK:
            if(!lpAP->bLDAPinProgress)
            {
            HCURSOR hOldCur;

            lpAP->nRetVal = ADDRESS_OK;

            lpAP->hWaitCur = LoadCursor(NULL, IDC_WAIT);
            hOldCur = SetCursor(lpAP->hWaitCur);
            lpAP->bLDAPinProgress = TRUE;
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, MAKELONG(TRUE, 0));

            //ShowWindow(hDlg, SW_HIDE);

            //EnableWindow(hDlg, FALSE);
            //SetWindowPos(hDlg, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);

            EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_FIND), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_CC), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_BCC), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC), FALSE);
            EnableWindow(_hWndAddr, FALSE);

            //
            //  Do  TEXT("OK") stuff here and then Fall Thru to the cancel stuff
            // in PSN_RESET where we clean up
            //

            // if the ADDRESS_ONE flag was set we're supposed to return the
            // selected entry
            //
            // else if wells were displayed we return the recipients in the AdrList
            //
            // else we dont change the AdrList ..
            //

            if (lpAP->DialogState == STATE_PICK_USER)
            {
                // We have been asked to return an entry in the LpAdrList,
                // we dont care about recipient type - just Display Name and EntryID

                // First check if anything is selected at all
                int iItemIndex = ListView_GetNextItem(_hWndAddr,-1,LVNI_SELECTED);
                if (iItemIndex != -1)
                {
                    LPRECIPIENT_INFO lpItem = GetItemFromLV(_hWndAddr, iItemIndex);
                    if (lpItem)
                    {
						if(HR_FAILED(HrUpdateAdrListEntry(	
											lpAP->lpIAB,
											lpItem->lpEntryID,
											lpItem->cbEntryID,
                                            (lpAP->lpAdrParms->ulFlags & MAPI_UNICODE)?MAPI_UNICODE:0,
											lpAP->lppAdrList)))
						{
							lpAP->nRetVal = -1;
						}
                    }
                }
            }
            else if ((lpAP->DialogState==STATE_SELECT_RECIPIENTS) && ((*lpAP_lppListTo)||(*lpAP_lppListCC)||(*lpAP_lppListBCC)))
            {
                //
                //if user selected something in the TO/CC wells, we want to return
                //a relevant AdrList back ...
                //
                ULONG ulcEntryCount = 0;
                LPRECIPIENT_INFO lpItem = NULL;

                //
                // get a count of how many elements we need to return
                //
                lpItem = (*lpAP_lppListTo);
                while(lpItem)
                {
                    ulcEntryCount++;
                    lpItem = lpItem->lpNext;
                }

                lpItem = (*lpAP_lppListCC);
                while(lpItem)
                {
                    ulcEntryCount++;
                    lpItem = lpItem->lpNext;
                }

                lpItem = (*lpAP_lppListBCC);
                while(lpItem)
                {
                    ulcEntryCount++;
                    lpItem = lpItem->lpNext;
                }

                if (ulcEntryCount != 0)
                {
                    ULONG nIndex = 0;
                    LPADRENTRY lpAdrEntryTemp = NULL;
                    LPADRLIST lpAdrList = NULL;
                    SCODE sc;
                    BOOL bProcessingCC = FALSE;

                    //
                    // if there was something in the passed in AdrList, free it and
                    // create a new list
                    //

                    if(!FAILED(sc = MAPIAllocateBuffer(    sizeof(ADRLIST) + ulcEntryCount * sizeof(ADRENTRY),
                                                &lpAdrList)))
                    {
                        lpAdrList->cEntries = ulcEntryCount;

                        nIndex = 0;

                        // Start getting items from the TO list
                        lpItem = (*lpAP_lppListTo);

                        while(nIndex < ulcEntryCount)
                        {
                            if (lpItem == NULL)
                            {
                                if (bProcessingCC == FALSE)
                                {
                                    lpItem = (*lpAP_lppListCC);
                                    bProcessingCC = TRUE;
                                }
                                else
                                    lpItem = (*lpAP_lppListBCC);
                            }

                            if (lpItem != NULL)
                            {
                                LPSPropValue rgProps = NULL;
                                ULONG cValues = 0;
                                LPSPropValue lpPropArrayNew = NULL;
                                ULONG cValuesNew = 0;
                                LPTSTR lpszTemp = NULL;
                                LPVOID lpbTemp = NULL;
                                ULONG i = 0;
                                SCODE sc;
                                HRESULT hr = hrSuccess;

                                //reset hr
                                hr = hrSuccess;


                                // We are walking through our linked lists representing the TO and CC
                                // selected recipients. We want to return proper set of existing props
                                // for all the resolved users and the passed in set of props for the
                                // unresolved user. Hence we compare to see what we can get for each
                                // individual user. For unresolved users, the only distinctive criteria is
                                // their display name .. we have no other information .. <TBD> this is
                                // problematic because if there are 2 entries in the input adrlist with the
                                // same unresolved display name, even if they have difference rgPropVals
                                // we might end up giving them identical ones back .... what to do .. <TBD>


                                // Items that have entry ids are resolved ... items that dont have entryids
                                // are not resolved ...

                                if (lpItem->cbEntryID != 0) 
                                {
                                    // if this was an item from the original list .. we dont really
                                    // want to mess with it irrespective of whether it is a resolved
                                    // or unresolved entry.
                                    // However, if this is a new entry, then we want to get its
                                    // minimum props from the store ...

                                    if (lpItem->ulOldAdrListEntryNumber == 0)
                                    {

                                        //resolved entry
                                        hr = HrGetPropArray(lpAP->lpIAB,
                                                            (LPSPropTagArray) &ptaResolveDefaults,
                                                            lpItem->cbEntryID,
                                                            lpItem->lpEntryID,
                                                            (lpAP->lpAdrParms->ulFlags & MAPI_UNICODE) ? MAPI_UNICODE : 0,
                                                            &cValues,
                                                            &rgProps);
                                    }
                                    else
                                    {
                                        rgProps = NULL;
                                        cValues = 0;
                                    }

                                    if (!HR_FAILED(hr))
                                    {
                                        if(lpItem->ulOldAdrListEntryNumber != 0)
                                        {
                                            ULONG index = lpItem->ulOldAdrListEntryNumber - 1; //remember the increment-by-one ..

                                            // This is from the original entry list ...
                                            // We want to merge the newly generated properties with the old
                                            // original properties .. the original properties will include a
                                            // PR_RECIPIENT_TYPE (or this entry would have been rejected)

                                            sc = ScMergePropValues( (*(lpAP->lppAdrList))->aEntries[index].cValues,
                                                                    (*(lpAP->lppAdrList))->aEntries[index].rgPropVals,
                                                                    cValues,
                                                                    rgProps,
                                                                    &cValuesNew,
                                                                    &lpPropArrayNew);

                                            if (sc != S_OK)
                                            {
                                                // If errors then dont merge .. just take the temp set of props
                                                // in rgProps
                                                if (lpPropArrayNew)
                                                    MAPIFreeBuffer(lpPropArrayNew);
                                                lpPropArrayNew = rgProps;
                                                cValuesNew = cValues;
                                                lpAP->nRetVal = -1;
                                            }
                                            else
                                            {
                                                // merged successfully, discard the temp sets of props
                                                if (rgProps)
                                                    MAPIFreeBuffer(rgProps);
                                            }
                                        }
                                        else
                                        {
                                            // totally new item
                                            // we have to give it a valid PR_RECIPIENT_TYPE
                                            // so create a new one and merge it with the above props
                                            SPropValue Prop = {0};
                                            Prop.ulPropTag = PR_RECIPIENT_TYPE;
                                            Prop.Value.l = lpItem->ulRecipientType;

                                            sc = ScMergePropValues( 1,
                                                                    &Prop,
                                                                    cValues,
                                                                    rgProps,
                                                                    &cValuesNew,
                                                                    &lpPropArrayNew);
                                            if (sc != S_OK)
                                            {
                                                // oops this failed
                                                if (lpPropArrayNew)
                                                    MAPIFreeBuffer(lpPropArrayNew);
                                                lpPropArrayNew = NULL;
                                                lpAP->nRetVal = -1;
                                            }

                                            //free rgProps
                                            if (rgProps)
                                                MAPIFreeBuffer(rgProps);

                                        } // end have previous adr list items

                                        // [PaulHi] 2/15/99  Make sure that the new property string
                                        // values are converted to ANSI if our client is non-UNICODE.
                                        if ( !FAILED(sc) && !(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE) && lpPropArrayNew )
                                        {
                                            sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cValuesNew, 0);
                                            if (FAILED(sc))
                                            {
                                                if (lpPropArrayNew)
                                                    MAPIFreeBuffer(lpPropArrayNew);
                                                lpPropArrayNew = NULL;
                                                lpAP->nRetVal = -1;
                                            }
                                        }

                                    } // end GetProps succeeded
                                }
                                else
                                {
                                    // this is an unresolved entry
                                    // we need to get its original sets of props from the original AdrList
                                    if (lpItem->ulOldAdrListEntryNumber == 0)
                                    {
                                        // ouch - this kind of error shouldnt have happened
                                        DebugPrintError(( TEXT("Address: Unresolved entry has no index number!!!\n")));
                                        lpAP->nRetVal = -1; //error code
                                    }
                                    else
                                    {
                                        ULONG cb = 0;
                                        ULONG index = lpItem->ulOldAdrListEntryNumber - 1; //remember to decrement the +1 increment

                                        cValuesNew = (*(lpAP->lppAdrList))->aEntries[index].cValues;
                                        // copy over the props from our old array into a new one
                                        if (!(FAILED(sc = ScCountProps(   cValuesNew,
                                                                        (*(lpAP->lppAdrList))->aEntries[index].rgPropVals,
                                                                        &cb))))
                                        {
                                            if (!(FAILED(sc = MAPIAllocateBuffer(cb, &lpPropArrayNew))))
                                            {

                                                if (FAILED(sc = ScCopyProps(    cValuesNew,
                                                                                (*(lpAP->lppAdrList))->aEntries[index].rgPropVals,
                                                                                lpPropArrayNew,
                                                                                NULL)))
                                                {
                                                    DebugPrintError(( TEXT("Address: ScCopyProps fails!!!\n")));
                                                    lpAP->nRetVal = -1;
                                                }
                                            }
                                            else
                                            {
                                                lpAP->nRetVal = -1;
                                            }
                                        }
                                        else
                                        {
                                            lpAP->nRetVal = -1;
                                        }
                                    }
                                }
                                // At this point, if we've still got no errors,
                                // we should have a valid lpPropArrayNew and cValuesNew which we should
                                // be able to add to our new AdrList
                                if (lpAP->nRetVal != -1)
                                {
                                    lpAdrList->aEntries[nIndex].cValues = cValuesNew;
                                    lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
                                }
                                else
                                {
                                    // some error
                                    if (lpPropArrayNew)
                                    {
                                        MAPIFreeBuffer(lpPropArrayNew);
                                        lpPropArrayNew = NULL;
                                    }
                                }

                                lpItem = lpItem->lpNext;
                                nIndex++;
                            }
                        }

                        if (*(lpAP->lppAdrList))
                        {
                            FreePadrlist(*(lpAP->lppAdrList));
                        }

                        *(lpAP->lppAdrList) = lpAdrList;

                    }
                }




            }
            else if ((lpAP->DialogState==STATE_SELECT_RECIPIENTS) && ((*lpAP_lppListTo)==NULL) && ((*lpAP_lppListCC)==NULL) && ((*lpAP_lppListBCC)==NULL))
            {
                // we were asked to select recipients but if these pointers are null
                // then the user deleted the entries in the wells and we thus dont
                // want to return anything. So free the lpaddrlist
                // and make it NULL

                if (*(lpAP->lppAdrList))
                {
                    // Bug 27483 - dont NULL the lpAdrList - just set cEntries to 0
                    ULONG iEntry = 0;
                    for (iEntry = 0; iEntry < (*(lpAP->lppAdrList))->cEntries; iEntry++) 
                    {
                        MAPIFreeBuffer((*(lpAP->lppAdrList))->aEntries[iEntry].rgPropVals);
                    }
                    (*(lpAP->lppAdrList))->cEntries = 0;
                }
            }

            //
            // Save the sort info to the registry
            //
            if(lpAP->DialogState != STATE_PICK_USER)
                WriteRegistrySortInfo((LPIAB)lpAP->lpIAB, lpAP->SortInfo);

            lpAP->bLDAPinProgress = FALSE;
            lpAP->hWaitCur = NULL;
            SetCursor(hOldCur);
            }
            // fall thru to cleanup code

        case IDCANCEL:
        case IDC_ADDRBK_BUTTON_CANCEL:
            if(!lpAP->bLDAPinProgress)
            {
                if ((lpAP->nRetVal != ADDRESS_OK) && // Are we falling thru from above ??
                    (lpAP->nRetVal != -1) ) // or did someone trigger an error above ??
                {
                    // if not ..
                    lpAP->nRetVal = ADDRESS_CANCEL;
                }

                if ((*lpAP_lppContentsList))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_ADDRESSES),
                                    lpAP_lppContentsList);

                if ((*lpAP_lppListTo))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO),
                                    lpAP_lppListTo);

                if ((*lpAP_lppListCC))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC),
                                    lpAP_lppListCC);

                if ((*lpAP_lppListBCC))
                    ClearListView(  GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC),
                                    lpAP_lppListBCC);

                lpAP->bLDAPinProgress = FALSE;

                EndDialog(hDlg,lpAP->nRetVal);

                return TRUE;
            }
            break;

        }
        break;

    case WM_CLOSE:
        //treat it like a cancel button
        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_ADDRBK_BUTTON_CANCEL, 0);
        break;

	case WM_CONTEXTMENU:
        {
            int id = GetDlgCtrlID((HWND)wParam);
            //
            //This call to the context menu may generate any one of several
            //command messages - for properties and for delete, we need to
            //know which List View initiated the command ...
            //
            lpAP->nContextID = id;
            switch(id)
            {
            case IDC_ADDRBK_LIST_ADDRESSES:
                if (lpAP->DialogState == STATE_BROWSE_MODAL)
    			    ShowLVContextMenu(  lvDialogModalABContents,
                                        (HWND)wParam,
                                        NULL, //GetDlgItem(hDlg, IDC_ADDRBK_COMBO_SHOWNAMES),
                                        lParam,
                                        (LPVOID) lpAP->lpAdrParms,
                                        lpAP->lpIAB, NULL);
                else
    			    ShowLVContextMenu(  lvDialogABContents,
                                        (HWND)wParam,
                                        NULL, //GetDlgItem(hDlg, IDC_ADDRBK_COMBO_SHOWNAMES),
                                        lParam,
                                        (LPVOID) lpAP->lpAdrParms,
                                        lpAP->lpIAB, NULL);
                break;

            case IDC_ADDRBK_LIST_TO:
    			ShowLVContextMenu(lvDialogABTo,(HWND)wParam, NULL, lParam, NULL,lpAP->lpIAB, NULL);
                break;
            case IDC_ADDRBK_LIST_BCC:
    			ShowLVContextMenu(lvDialogABCC,(HWND)wParam, NULL, lParam, NULL,lpAP->lpIAB, NULL);
                break;
            case IDC_ADDRBK_LIST_CC:
    			ShowLVContextMenu(lvDialogABBCC,(HWND)wParam, NULL, lParam, NULL,lpAP->lpIAB, NULL);
                break;
            default:
                //reset it ..
                lpAP->nContextID = -1;
                WABWinHelp((HWND) wParam,
                        g_szWABHelpFileName,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR)(LPVOID) rgAddrHelpIDs );
                break;
            }
        }
        break;


    case WM_NOTIFY:
        {
            LV_DISPINFO * pLvdi = (LV_DISPINFO *)lParam;
            NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;

            switch((int) wParam)
            {
            case IDC_ADDRBK_LIST_TO:
            case IDC_ADDRBK_LIST_CC:
            case IDC_ADDRBK_LIST_BCC:
                switch(((LV_DISPINFO *)lParam)->hdr.code)
                {
                case LVN_KEYDOWN:
                    switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                    {
                    case VK_DELETE:
                        if ((int) wParam == IDC_ADDRBK_LIST_TO)
                            ListDeleteItem(hDlg, (int) wParam, lpAP_lppListTo);
                        else if ((int) wParam == IDC_ADDRBK_LIST_CC)
                            ListDeleteItem(hDlg, (int) wParam, lpAP_lppListCC);
                        else
                            ListDeleteItem(hDlg, (int) wParam, lpAP_lppListBCC);
                        break;
                    }
                    break;

                case NM_SETFOCUS:
                    lpAP->nContextID = GetDlgCtrlID(((NM_LISTVIEW *)lParam)->hdr.hwndFrom);
                    break;

                case NM_DBLCLK:
                    //properties of the item ...
                    lpAP->nContextID = GetDlgCtrlID(((NM_LISTVIEW *)lParam)->hdr.hwndFrom);
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDM_LVCONTEXT_PROPERTIES, 0);
                    break;

	            case NM_CUSTOMDRAW:
                    return ProcessLVCustomDraw(hDlg, lParam, TRUE);
                    break;
                }
                break;


            case IDC_ADDRBK_LIST_ADDRESSES:

                switch(pLvdi->hdr.code)
                {
                case LVN_KEYDOWN:
                    switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                    {
                    case VK_DELETE:
                        if (lpAP->DialogState == STATE_BROWSE_MODAL)
                            SendMessage(hDlg, WM_COMMAND, IDC_ADDRBK_BUTTON_DELETE, 0);
                        break;
                    }
                    break;

                case LVN_COLUMNCLICK:
                    SortListViewColumn((LPIAB)lpAP->lpIAB, pNm->hdr.hwndFrom, pNm->iSubItem, &(lpAP->SortInfo), FALSE);
                    break;

                case NM_CLICK:
                case NM_RCLICK:
                    if(lpAP->DialogState == STATE_PICK_USER)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        if (iItemIndex == -1)
                        {
                            //Nothing is selected .. dont let them say OK
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),FALSE);
                            SendMessage (hDlg, DM_SETDEFID, IDCANCEL, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),TRUE);
                            SendMessage (hDlg, DM_SETDEFID, IDOK, 0);
                        }
                    }

                    break;

                case NM_SETFOCUS:
                    lpAP->nContextID = GetDlgCtrlID(pNm->hdr.hwndFrom);
                    if(lpAP->DialogState == STATE_PICK_USER)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        if (iItemIndex == -1)
                        {
                            //Nothing is selected .. dont let them say OK
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),FALSE);
                            SendMessage (hDlg, DM_SETDEFID, IDCANCEL, 0);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/),TRUE);
                            SendMessage (hDlg, DM_SETDEFID, IDOK, 0);
                        }
                    }
                    break;

                case NM_DBLCLK:
                    {
                        //if an entry is selected - do this - otherwise dont do anything
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        if (iItemIndex == -1)
                            break;
                        {
                            //DWORD dwDefId = SendMessage(hDlg, DM_GETDEFID, 0, 0);
                            //if(dwDefId)
                            //    SendMessage(hDlg, WM_COMMAND, (WPARAM) LOWORD(dwDefId), 0);
                            SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_ADDRBK_BUTTON_TO + lpAP->lpAdrParms->nDestFieldFocus, 0);
                        }
                    }
                    break;

	            case NM_CUSTOMDRAW:
                    return ProcessLVCustomDraw(hDlg, lParam, TRUE);
                    break;
                }
                break;

            }
        }
        break;

    default:
        if( (g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            if(GetFocus() == GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO))
                SendMessage(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO), message, wParam, lParam);
            else if(GetFocus() == GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC))
                SendMessage(GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC), message, wParam, lParam);
            else if(GetFocus() == GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC))
                SendMessage(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO), message, wParam, lParam);
            else
                SendMessage(_hWndAddr, message, wParam, lParam);
        }
        break;

    }

    return FALSE;

}

/////////////////////////////////////////////////////////////////////////////////
//
// ListAddItem - Adds an item to the wells
//
//  hDlg - HWND of parent
//  hWndAddr - HWND of source ListView from which the item will be added
//  CtlID - control ID of the target list view
//  lppList - Item list corresponding to the target list view to which this item will be appended
//  RecipientType - Specified recipient type to tag the new item with
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ListAddItem(HWND hDlg, HWND hWndAddr, int CtlID, LPRECIPIENT_INFO * lppList, ULONG RecipientType)
{
    BOOL bRet = FALSE;
    int iItemIndex = 0;
    HWND hWndList = GetDlgItem(hDlg,CtlID);


    iItemIndex = ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED);
    if (iItemIndex != -1)
    {
        int iLastIndex = 0;
        do
        {
            // otherwise get the entry id of this thing
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndAddr, iItemIndex);
            if (lpItem)
            {
                LV_ITEM lvI;
                LPRECIPIENT_INFO lpNew = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));

                if(!lpNew)
                {
                    DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                    goto out;
                }

                lpNew->ulObjectType = lpItem->ulObjectType;
                StrCpyN(lpNew->szDisplayName, lpItem->szDisplayName, ARRAYSIZE(lpNew->szDisplayName));
                StrCpyN(lpNew->szByFirstName, lpItem->szByFirstName, ARRAYSIZE(lpNew->szByFirstName));
                StrCpyN(lpNew->szByLastName, lpItem->szByLastName, ARRAYSIZE(lpNew->szByLastName));
                StrCpyN(lpNew->szEmailAddress, lpItem->szEmailAddress, ARRAYSIZE(lpNew->szEmailAddress));
                StrCpyN(lpNew->szHomePhone, lpItem->szHomePhone, ARRAYSIZE(lpNew->szHomePhone));
                StrCpyN(lpNew->szOfficePhone, lpItem->szOfficePhone, ARRAYSIZE(lpNew->szOfficePhone));
                lpNew->bHasCert = lpItem->bHasCert;
                lpNew->ulRecipientType = RecipientType;
                lpNew->ulOldAdrListEntryNumber = 0; //Flag this as not from the original AdrList
                if (lpItem->cbEntryID)
                {
                    lpNew->cbEntryID = lpItem->cbEntryID;
                    lpNew->lpEntryID = LocalAlloc(LMEM_ZEROINIT, lpItem->cbEntryID);
                    if(!lpNew->lpEntryID)
                    {
                        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                        LocalFree(lpNew);
                        goto out;
                    }
                    CopyMemory(lpNew->lpEntryID,lpItem->lpEntryID,lpItem->cbEntryID);
                }

                lpNew->lpNext = (*lppList);
                if (*lppList)
                    (*lppList)->lpPrev = lpNew;
                lpNew->lpPrev = NULL;
                (*lppList) = lpNew;

                lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                lvI.state = 0;
                lvI.stateMask = 0;
                lvI.iSubItem = 0;
                lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;

                lvI.iImage = GetWABIconImage(lpNew);

                // now fill in the List
                lvI.iItem = ListView_GetItemCount(hWndList);
                lvI.pszText = lpNew->szDisplayName;
                lvI.lParam = (LPARAM) lpNew;
                ListView_InsertItem(hWndList, &lvI);
                ListView_EnsureVisible(hWndList,ListView_GetItemCount(hWndList)-1,FALSE);
            }
            iLastIndex = iItemIndex;
            // Get next selected item ...
            iItemIndex = ListView_GetNextItem(hWndAddr,iLastIndex,LVNI_SELECTED);
        } while (iItemIndex != -1);
        //SetFocus(hWndAddr);
    }
    else
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEMS_ADD, MB_ICONEXCLAMATION);
        goto out;
    }

    if((ListView_GetItemCount(hWndList) > 0) &&
        (ListView_GetSelectedCount(hWndList) <= 0))
        LVSelectItem(hWndList, 0);

    bRet = TRUE;

out:
    return bRet;

}

/////////////////////////////////////////////////////////////////////////////////
//
// ListDeleteItem - deletes an item from the Wells - unlike the Address COntents list we
// make sure to delete it here because we want the linked lists to only have valid entries
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL ListDeleteItem(HWND hDlg, int CtlID, LPRECIPIENT_INFO * lppList)
{
    BOOL bRet = TRUE;
    LPRECIPIENT_INFO lpItem = NULL;
    HWND hWndAddr =  GetDlgItem(hDlg,CtlID);
    int iItemIndex=0;

    iItemIndex = ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED);
    if (iItemIndex != -1)
    {
        int iLastItem = 0;
        do
        {
            // otherwise get the entry id of this thing
            lpItem = GetItemFromLV(hWndAddr, iItemIndex);
            if (lpItem)
            {
                // remove this item from our linked list of arrays
                // if this is the first item in the list then handle that special case too

                if ((*lppList) == lpItem)
                    (*lppList) = lpItem->lpNext;
                if (lpItem->lpNext)
                    lpItem->lpNext->lpPrev = lpItem->lpPrev;
                if (lpItem->lpPrev)
                    lpItem->lpPrev->lpNext = lpItem->lpNext;

                // we need to update our display
                ListView_DeleteItem(hWndAddr,iItemIndex);
                //UpdateWindow(hWndAddr);

                FreeRecipItem(&lpItem);
            }
            iLastItem = iItemIndex;
            // Get next selected item ...
            iItemIndex = ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED);
        }while (iItemIndex != -1);

        // select the previous or next item ...
        if (iLastItem >= ListView_GetItemCount(hWndAddr))
            iLastItem = ListView_GetItemCount(hWndAddr) - 1;
		LVSelectItem(hWndAddr, iLastItem);
    }
    SetFocus(hWndAddr);

    return bRet;

}


/////////////////////////////////////////////////////////////////////////////////
//
// FillWells - Dismembers the lpAdrList to create the To and CC wells
//
//  Scans the AdrEntry Structures in the LpAdrList, looks at PR_RECIPIENT_TYPE,
//      ignores entries which it cant understand ... creates a temporary linked
//      list of To and CC recipient lists which are used to populate the
//      To and CC List boxes
//
/////////////////////////////////////////////////////////////////////////////////
BOOL FillWells(HWND hDlg, LPADRLIST lpAdrList, LPADRPARM lpAdrParms, LPRECIPIENT_INFO * lppListTo, LPRECIPIENT_INFO * lppListCC, LPRECIPIENT_INFO * lppListBCC)
{
    BOOL bRet = FALSE;
    LPRECIPIENT_INFO lpNew = NULL;
    LPADRENTRY lpAdrEntry = NULL;
    ULONG i=0,j=0,nLen=0;
    int index=0;
    LV_ITEM lvI;
    HWND hWndAddr = NULL;
    ULONG ulMapiTo = MAPI_TO;
    ULONG ulMapiCC = MAPI_CC;
    ULONG ulMapiBCC = MAPI_BCC;
    BOOL bUnicode = (lpAdrParms->ulFlags & MAPI_UNICODE);

    *lppListTo = NULL;
    *lppListCC = NULL;
    *lppListBCC = NULL;

    if (lpAdrList == NULL) //nothing to do
    {
        bRet = TRUE;
        goto out;
    }

    //
    // The Input AdrParms structure has a lpulDestComps field that lets the
    // caller specify his own recipient types. If this is missing, we are supposed
    // to use the default recipient types.
    //
            if ((lpAdrParms->cDestFields > 0) && (lpAdrParms->lpulDestComps))
            {
                ULONG i=0;
                for (i=0;i<lpAdrParms->cDestFields;i++)
                {
                    switch(i)
                    {
                    case 0:
                        ulMapiTo = lpAdrParms->lpulDestComps[i];
                        break;
                    case 1:
                        ulMapiCC = lpAdrParms->lpulDestComps[i];
                        break;
                    case 2:
                        ulMapiBCC = lpAdrParms->lpulDestComps[i];
                        break;
                    }
                }
            }



    for(i=0; i < lpAdrList->cEntries; i++)
    {
        lpAdrEntry = &(lpAdrList->aEntries[i]);
        if (lpAdrEntry->cValues != 0)
        {
            TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];
            ULONG ulRecipientType = 0;
            ULONG ulObjectType = 0;
            ULONG cbEntryID = 0;
            BOOL bHasCert = FALSE;
            LPENTRYID lpEntryID = NULL;
            szBuf[0]='\0';

            for(j=0;j<lpAdrEntry->cValues;j++)
            {
                ULONG ulPropTag = lpAdrEntry->rgPropVals[j].ulPropTag;
                
                if(!bUnicode && PROP_TYPE(ulPropTag) == PT_STRING8)
                    ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_UNICODE);

                switch(ulPropTag)
                {
                case(PR_DISPLAY_NAME):
                    {
                        LPTSTR lpNameW = NULL;
                        SET_UNICODE_STR(lpNameW, lpAdrEntry->rgPropVals[j].Value.LPSZ,lpAdrParms);
                        nLen = CopyTruncate(szBuf, lpNameW, MAX_DISPLAY_NAME_LENGTH);
                        FREE_UNICODE_STR(lpNameW, lpAdrEntry->rgPropVals[j].Value.LPSZ);
                    }
                    break;
                case(PR_RECIPIENT_TYPE):
                    ulRecipientType = lpAdrEntry->rgPropVals[j].Value.l;
                    break;
                case(PR_OBJECT_TYPE):
                    ulObjectType = lpAdrEntry->rgPropVals[j].Value.l;
                    break;
                case(PR_ENTRYID):
                    cbEntryID = lpAdrEntry->rgPropVals[j].Value.bin.cb;
                    lpEntryID = (LPENTRYID) lpAdrEntry->rgPropVals[j].Value.bin.lpb;
                    break;
                case PR_USER_X509_CERTIFICATE:
                    bHasCert = TRUE;
                    break;
                }
            }


            if (lstrlen(szBuf) && ((ulRecipientType == ulMapiBCC) || (ulRecipientType == ulMapiTo) || (ulRecipientType == ulMapiCC)))
            {
                lpNew = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
                if(!lpNew)
                {
                    DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                    goto out;
                }

                // ***NOTE***
                // Store this index number, ie 1st item in AdrList is 1, then 2, 3, so on
                // we do a plus 1 here because 0 value means it wasnt passed in and thus the
                // minimum valid value is 1
                lpNew->ulOldAdrListEntryNumber = i+1;

                lpNew->bHasCert = bHasCert;
                StrCpyN(lpNew->szDisplayName,szBuf,ARRAYSIZE(lpNew->szDisplayName));
                lpNew->ulRecipientType = ulRecipientType;
                lpNew->ulObjectType = ulObjectType;

                if (cbEntryID != 0)
                {
                    lpNew->cbEntryID = cbEntryID;
                    lpNew->lpEntryID = LocalAlloc(LMEM_ZEROINIT,cbEntryID);
                    if(!lpNew->lpEntryID)
                    {
                        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                        goto out;
                    }
                    CopyMemory(lpNew->lpEntryID,lpEntryID,cbEntryID);
                }

                if (ulRecipientType == ulMapiTo)
                {
                    lpNew->lpNext = *lppListTo;
                    if (*lppListTo)
                        (*lppListTo)->lpPrev = lpNew;
                    lpNew->lpPrev = NULL;
                    *lppListTo = lpNew;
                }
                else if (ulRecipientType == ulMapiCC)
                {
                    lpNew->lpNext = *lppListCC;
                    if (*lppListCC)
                        (*lppListCC)->lpPrev = lpNew;
                    lpNew->lpPrev = NULL;
                    *lppListCC = lpNew;
                }
                else if (ulRecipientType == ulMapiBCC)
                {
                    lpNew->lpNext = *lppListBCC;
                    if (*lppListBCC)
                        (*lppListBCC)->lpPrev = lpNew;
                    lpNew->lpPrev = NULL;
                    *lppListBCC = lpNew;
                }
            }

        }
    }

    lvI.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvI.state = 0;
    lvI.stateMask = 0;
    lvI.iSubItem = 0;
    lvI.cchTextMax = MAX_DISPLAY_NAME_LENGTH;

    for(i=0;i<3;i++)
    {
        switch(i)
        {
        case 0:
            lpNew = *lppListTo;
            break;
        case 1:
            lpNew = *lppListCC;
            break;
        case 2:
            lpNew = *lppListBCC;
            break;
        }

        hWndAddr = GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO+i);
        index = 0;
        while(lpNew)
        {
            lvI.iItem = index;
            lvI.pszText = lpNew->szDisplayName;
            lvI.lParam = (LPARAM) lpNew;

            lvI.iImage = GetWABIconImage(lpNew);

            ListView_InsertItem(hWndAddr, &lvI);

            index++;
            lpNew = lpNew->lpNext;
        }
    }

    // We will highlight the first item in any filled list box
    // because basically that looks good when tabbing through them ...
    for(i=0;i<lpAdrParms->cDestFields;i++)
    {
        HWND hWndLV = GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO+i);

        if (ListView_GetItemCount(hWndLV) > 0)
            LVSelectItem(hWndLV,0);
    }


    bRet = TRUE;

out:

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////////
//
// SetAddressBookUI - juggles the address book UI in response to various parameters
//
//      This function will probably be more complex with each tier
//
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetAddressBookUI(HWND hDlg,
                      LPADDRESS_PARMS lpAP)
{
    BOOL bRet = FALSE;
    //LV_COLUMN lvC;
    RECT rc, rc1, rc2;
    POINT ptLU1,ptRB1;
    int nButtonsVisible = 0;
    int nButtonSpacing = 7;
    int nButtonWidth = 0;
    ULONG nLen = 0;
    TCHAR szBuf[MAX_UI_STR*4];
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    HWND hWndListAddresses = GetDlgItem(hDlg, IDC_ADDRBK_LIST_ADDRESSES);

    LPTSTR szCaption = NULL;

    SET_UNICODE_STR(szCaption, lpAP->lpAdrParms->lpszCaption,lpAP->lpAdrParms);

    if(!szCaption || !lstrlen(szCaption))
    {
        LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szBuf, CharSizeOf(szBuf));
        szCaption = szBuf;
    }
    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB))
    {
        // Fill in the Combo with the container names
        FillContainerCombo(GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT), (LPIAB)lpAP->lpIAB);
    }
    else
    {
        HWND hWndCombo = GetDlgItem(hDlg, IDC_ADDRBK_COMBO_CONT);
        EnableWindow(hWndCombo, FALSE);
        ShowWindow(hWndCombo, SW_HIDE);

        // resize the listview to take place of the hidden combo
        GetWindowRect(hWndCombo,&rc2);
        GetWindowRect(hWndListAddresses,&rc);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);       
        ptLU1.x = rc2.left;
        ptLU1.y = rc2.top;
        ptRB1.x = rc.right;
        ptRB1.y = rc.bottom;
        MoveWindow(hWndListAddresses,ptLU1.x,ptLU1.y,(ptRB1.x - ptLU1.x), (ptRB1.y - ptLU1.y), TRUE);
    }

    //
    // There are only two states that need configuration -
    //  Pick User - in which we have to hide the wells
    // and
    //  Select Recipients, in which we have to hide the wells
    //  as per the input criteria and resize accordingly and
    //  also set the labels based on the input criteria
    //
    if (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
    {
        SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_TO, 0);

        // in case the nDestFieldFocus parameter is supplied, use it ..
        if (
            (lpAP->lpAdrParms->nDestFieldFocus < lpAP->lpAdrParms->cDestFields))
        {
            if (lpAP->lpAdrParms->nDestFieldFocus == 1)
                SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_CC, 0);
            else if (lpAP->lpAdrParms->nDestFieldFocus == 2)
                SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_BCC, 0);
        }
    }
    else if (lpAP->DialogState == STATE_PICK_USER)
        SendMessage (hDlg, DM_SETDEFID, IDOK/*IDC_ADDRBK_BUTTON_OK*/, 0);
    else if (lpAP->DialogState == STATE_BROWSE_MODAL)
        SendMessage (hDlg, DM_SETDEFID, IDC_ADDRBK_BUTTON_PROPS, 0);

    // Set the window caption
    if (szCaption)
        SetWindowText(hDlg,szCaption);

    // Set the caption over the destination wells
    if (lpAP->lpAdrParms->lpszDestWellsTitle)
    {
        LPWSTR lpTitle = NULL; // <note> assumes UNICODE defined
        SET_UNICODE_STR(lpTitle,lpAP->lpAdrParms->lpszDestWellsTitle,lpAP->lpAdrParms);
        SetDlgItemText(hDlg,IDC_ADDRBK_STATIC_RECIP_TITLE,lpTitle);
        FREE_UNICODE_STR(lpTitle, lpAP->lpAdrParms->lpszDestWellsTitle);
    }

    if (lpAP->DialogState == STATE_PICK_USER &&
        *(lpAP->lppAdrList) )
    {
        ULONG i=0;
        LPTSTR lpszRecipName = NULL;

        //Get the user whose name we are trying to find
        for(i=0;i<(*(lpAP->lppAdrList))->aEntries[0].cValues;i++)
        {
            ULONG ulPropTag = PR_DISPLAY_NAME;
            if(!(lpAP->lpAdrParms->ulFlags & MAPI_UNICODE))
                ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
            if ((*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].ulPropTag == ulPropTag)
            {
                SET_UNICODE_STR(lpszRecipName,(*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ,lpAP->lpAdrParms);
                break;
            }
        }

        if(lpszRecipName)
        {
            LPTSTR lpszBuffer = NULL;
            TCHAR szTmp[MAX_PATH], *lpszTmp;

			LoadString(hinstMapiX, IDS_ADDRBK_RESOLVE_CAPTION, szBuf, CharSizeOf(szBuf));

            CopyTruncate(szTmp, lpszRecipName, MAX_PATH - 1);
            lpszTmp = szTmp;

            if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                szBuf,
                                0,0, //ignored
                                (LPTSTR) &lpszBuffer,
                                MAX_UI_STR,
                                (va_list *)&lpszTmp))
            {
                // if the display name is too long, it doesnt show up properly in the UI ..
                // so we will purposely limit the visible portion to 64 characters - arbitarily defined limit..
                szBuf[0]='\0';
                nLen = CopyTruncate(szBuf, lpszBuffer, 2 * MAX_DISPLAY_NAME_LENGTH);

                LocalFreeAndNull(&lpszBuffer);
            }

            //Increase the size of the static control to = what the Contents List width will be
            GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS),&rc2);
            GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),&rc);
            //
            //This api working in both mirrored and unmirrored windows.
            //
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);            
            ptLU1.x = rc2.left;
            ptLU1.y = rc2.top;
            ptRB1.x = rc.right;
            ptRB1.y = rc2.bottom;
            MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS),ptLU1.x,ptLU1.y,(ptRB1.x - ptLU1.x), (ptRB1.y - ptLU1.y), TRUE);

            SetDlgItemText(hDlg,IDC_ADDRBK_STATIC_CONTENTS,szBuf);

            FREE_UNICODE_STR(lpszRecipName,(*(lpAP->lppAdrList))->aEntries[0].rgPropVals[i].Value.LPSZ);
        }

    }


    if (lpAP->DialogState == STATE_PICK_USER)
    {
        // If ADDRESS_ONE has been selected, then make the IDC_ADDRBK_LIST_ADDRESSES
        // single selection only
        DWORD dwStyle;
        dwStyle = GetWindowLong(hWndListAddresses, GWL_STYLE);
        SetWindowLong(hWndListAddresses, GWL_STYLE, dwStyle | LVS_SINGLESEL);
    }

    if ((lpAP->DialogState == STATE_PICK_USER)||(lpAP->DialogState == STATE_BROWSE_MODAL))
    {
        int i = 0;
        // Dont show wells which means we have to do some rearranging
        //  * Hide the wells and the To, CC, BCC buttons
        //  * Resize the IDC_ADDRBK_LIST_ADDRESSES to fill the whole dialog
        //  * Move the 3 buttons below it to the left side of the dialog
        //

        // Get the dimensions of the ToListBox
        GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),&rc2);
        GetWindowRect(hWndListAddresses,&rc);
        //
        //This api works for in both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
        ptLU1.x = rc.left;
        ptLU1.y = rc.top;
        ptRB1.x = rc2.right;
        ptRB1.y = rc.bottom;

        MoveWindow(hWndListAddresses,ptLU1.x,ptLU1.y,(ptRB1.x - ptLU1.x), (ptRB1.y - ptLU1.y), TRUE);

        for(i=0;i<3;i++)
        {
            ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_TO + i), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO + i), SW_HIDE);
        }

        ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_STATIC_RECIP_TITLE), SW_HIDE); //  TEXT("Message Recipients") label

    }

    // other things to do

    // Load Headers for List box
    GetWindowRect(hWndListAddresses,&rc);
	HrInitListView(hWndListAddresses, LVS_REPORT, TRUE);

    GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS),&rc2);
    nButtonsVisible = 2;

    nButtonWidth = (rc2.right - rc2.left);

    // get the new coordinates of the 1st visible button
    //
    //This api working in both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc2, 2);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU1.x = rc.left;
    ptLU1.y = rc2.top;
    ptRB1.x = ptLU1.x + nButtonWidth;
    ptRB1.y = rc2.bottom;

    MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);
    ptLU1.x += nButtonWidth + nButtonSpacing;
    ptRB1.x = ptLU1.x + nButtonWidth;
    if (lpAP->DialogState == STATE_BROWSE_MODAL)
    {
        MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEWGROUP),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);
        ptLU1.x += nButtonWidth + nButtonSpacing;
        ptRB1.x = ptLU1.x + nButtonWidth;
    }
    else
    {
        // The NewGroup button is visible only in the DialogModalView
        EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_NEWGROUP), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_NEWGROUP), SW_HIDE);
    }
    MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);
    ptLU1.x += nButtonWidth + nButtonSpacing;
    ptRB1.x = ptLU1.x + nButtonWidth;
    MoveWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_DELETE),ptLU1.x,ptLU1.y,nButtonWidth, (ptRB1.y - ptLU1.y), TRUE);


    // The delete button is visible only in the DialogModalView
    if (lpAP->DialogState != STATE_BROWSE_MODAL)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_DELETE), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_DELETE), SW_HIDE);
    }

    //
    // We now need to customize this window if we are selecting
    // recipients ...
    //
    if (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
    {
        // We need to see which wells are visible and
        // then we need to resize the buttons based on their captions
        //
        int i=0;
        int nLen=0;
        int cDF = lpAP->lpAdrParms->cDestFields;
        int iLeft=0,iTop=0;

        SIZE size={0};
        ULONG MaxWidth=0;
        ULONG maxHeightPerLV = 0;
        HWND hw;
        HDC hdc=GetDC(hDlg);

        if (lpAP->lpAdrParms->lppszDestTitles)
        {
            for(i=0; i < cDF; i++)
            {
                LPTSTR lpTitle = NULL;
                ULONG Len = 0;
                SET_UNICODE_STR(lpTitle,lpAP->lpAdrParms->lppszDestTitles[i],lpAP->lpAdrParms);
                if(!lpTitle)
                    continue;
                Len = lstrlen(lpTitle);
                if (Len > CharSizeOf(szBuf) - 4)
                {
                    ULONG iLen = TruncatePos(lpTitle, CharSizeOf(szBuf) - 4);
                    CopyMemory(szBuf,lpTitle,iLen*sizeof(TCHAR));
                    szBuf[iLen] = '\0';
                }
                else
                {
                    StrCpyN(szBuf,lpTitle,ARRAYSIZE(szBuf));
                }
                StrCatBuff(szBuf,szArrow,ARRAYSIZE(szBuf));
                if (lstrlen(szBuf) >= nLen)
                {
                    nLen = lstrlen(szBuf);
                    GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                    MaxWidth = size.cx;
                }
                // Set the new text
                SetDlgItemText(hDlg,IDC_ADDRBK_BUTTON_TO+i,szBuf);
                FREE_UNICODE_STR(lpTitle,lpAP->lpAdrParms->lppszDestTitles[i]);
            }

        }

        ReleaseDC(hDlg,hdc);

        if (MaxWidth == 0)
        {
            //get the default width
            GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO),&rc1);
            MaxWidth = rc1.right - rc1.left;
        }

        //Get the maximum allowable height per well
        GetWindowRect(hWndListAddresses,&rc);
        GetChildClientRect(hWndListAddresses, &rc);
        GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW),&rc1);
        GetChildClientRect(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW), &rc1);
        maxHeightPerLV = (rc1.bottom-rc.top - (cDF - 1)*CONTROL_SPACING)/cDF;
        iTop = rc.top;

        for(i=0;i<cDF;i++)
        {
            hw = GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO + i);

            // resize the buttons to fit the text
            GetWindowRect(hw,&rc1);
            GetChildClientRect(hw,&rc1);
            MoveWindow(hw,rc1.left,iTop,MaxWidth,rc1.bottom - rc1.top,FALSE);

            iLeft = rc1.left + MaxWidth + 2*CONTROL_SPACING;

            // Move the list boxes to accomodate the resized buttons
            hw = GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO + i);
            GetWindowRect(hw, &rc1);
            GetChildClientRect(hw, &rc1);
            MoveWindow(hw,iLeft,iTop,rc1.right-iLeft,maxHeightPerLV,FALSE);

            ListView_SetExtendedListViewStyle(hw,LVS_EX_FULLROWSELECT);

            iTop += maxHeightPerLV + CONTROL_SPACING;

        }

        //Move the label over the wells and restrict it's size
        hw = GetDlgItem(hDlg,IDC_ADDRBK_STATIC_RECIP_TITLE);
        GetWindowRect(hw, &rc2);
        GetChildClientRect(hw, &rc2);
        if(pt_bIsWABOpenExSession || bIsWABSessionProfileAware((LPIAB)lpAP->lpIAB)) // need to move this to the same height as combo
        {
            int ht = rc2.bottom - rc2.top;
            rc2.bottom = rc.top - CONTROL_SPACING;
            rc2.top = rc2.bottom - ht;
        }
        MoveWindow(hw,iLeft,rc2.top,rc1.right-iLeft,rc2.bottom-rc2.top,FALSE);


        // Now we have the position and width of the list boxes .. need to get their height
        if (cDF!=3) //if not the default preset position, reposition
        {
            switch(cDF)
            {
            case 1:
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_CC), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_CC), SW_HIDE);
            case 2:
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_BUTTON_BCC), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ADDRBK_LIST_BCC), SW_HIDE);
                break;
            }

        }

        for(i=0;i<cDF;i++)
            HrInitListView(GetDlgItem(hDlg, IDC_ADDRBK_LIST_TO + i), LVS_REPORT, FALSE);

/***
        // Add a column to the To,CC,BCC List Boxes
        GetWindowRect(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),&rc);

        lvC.mask = LVCF_FMT | LVCF_WIDTH;// | LVCF_TEXT;
        lvC.fmt = LVCFMT_LEFT;
        lvC.cx = (rc.right - rc.left)-20;
        lvC.iSubItem = 0;
        lvC.pszText = NULL; // TEXT(" 'TO'  Recipients");

        ListView_InsertColumn(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO),lvC.iSubItem, &lvC);
        ListView_InsertColumn(GetDlgItem(hDlg,IDC_ADDRBK_LIST_CC),lvC.iSubItem, &lvC);
        ListView_InsertColumn(GetDlgItem(hDlg,IDC_ADDRBK_LIST_BCC),lvC.iSubItem, &lvC);
/***/
        for (i=0;i<cDF;i++)
        {
            ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO+i), SW_SHOWNORMAL);
            UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_TO+i));
            ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO+i), SW_SHOWNORMAL);
            UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_TO+i));
        }
    }

    // The window is taking too long to display with several 100 entries in the
    // property store ... so we force all the contents to visible so that we
    // can view the fill contents ...
    //ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES), SW_SHOWNORMAL);
    //UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_PROPS));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_NEW));
    ShowWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDOK/*IDC_ADDRBK_BUTTON_OK*/));
    ShowWindow(GetDlgItem(hDlg,IDCANCEL/*IDC_ADDRBK_BUTTON_CANCEL*/), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDCANCEL/*IDC_ADDRBK_BUTTON_CANCEL*/));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_CONTENTS));
    ShowWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_15), SW_SHOWNORMAL);
    UpdateWindow(GetDlgItem(hDlg,IDC_ADDRBK_STATIC_15));
    ShowWindow(hDlg,SW_SHOWNORMAL);
    UpdateWindow(hDlg);


    {
//        HICON hIcon = LoadIcon(hinstMapiX,MAKEINTRESOURCE(IDI_ICON_FIND));
        // associate the icon with the button.
//        SendMessage(GetDlgItem(hDlg,IDC_ADDRBK_BUTTON_FIND),BM_SETIMAGE,(WPARAM)IMAGE_ICON,(LPARAM)(HANDLE)hIcon);
    }
    bRet = TRUE;

    if( szCaption != lpAP->lpAdrParms->lpszCaption &&
        szCaption != szBuf)
        LocalFreeAndNull(&szCaption);

    return bRet;
}


//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// UpdateLVItems ....
//      When we call properties on an object, its props can change ...
//      Since the particular user may appear in any of the 4 list views,
//      we have to make sure that all views are updated for that entry
//
///////////////////////////////////////////////////////////////////////////////////////////////
void UpdateLVItems(HWND hWndLV,LPTSTR lpszName)
{
    // We have the handle to the list view initiating the Properties call
    // We know the old name to look for
    //
    // We know which item is selected - we can get its entryid and lParam
    // We then search all the list views for the old display name
    // if the old display name matches, we compare the entry id
    // if the entryid matches, then we update that item ...

    int iItemIndex = 0, iLastItemIndex = 0;
    LPRECIPIENT_INFO lpOriginalItem;
    ULONG i=0;
    ULONG nCount = 0;
    int id = 0;
    HWND hDlg = GetParent(hWndLV);
    HWND hw = NULL;
    LV_FINDINFO lvf={0};

    if ( (ListView_GetSelectedCount(hWndLV) != 1) ||
         (lpszName == NULL) )
    {
        goto out;
    }

    iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

    lpOriginalItem = GetItemFromLV(hWndLV, iItemIndex);

    if(!lpOriginalItem)
        goto out;


    // There can be upto 4 list view boxes in the view, each of which can
    // contain a displayed copy of this item ..
    // We want to go through all 4 and update all entries that match this item

    // Our strategy is to search for each and every item that
    // matches the display name - check its entry ID and if
    // the entry ID matches, update it ...

    lvf.flags = LVFI_STRING;
    lvf.psz = lpszName;

    for(i=0;i<4;i++)
    {
        switch(i)
        {
        case 0:
            id = IDC_ADDRBK_LIST_ADDRESSES;
            break;
        case 1:
            id = IDC_ADDRBK_LIST_TO;
            break;
        case 2:
            id = IDC_ADDRBK_LIST_CC;
            break;
        case 3:
            id = IDC_ADDRBK_LIST_BCC;
            break;
        }

        hw = GetDlgItem(hDlg,id);

        // if its hidden, ignore it
        if (!IsWindowVisible(hw))
            continue;

        // if its empty, ignore it
        nCount = ListView_GetItemCount(hw);
        if (nCount <= 0)
            continue;

        // The contents list view wont have duplicates so ignore it if its the original
        if ((id == IDC_ADDRBK_LIST_ADDRESSES) &&
            (hw == hWndLV))
            continue;

        // see if we can find the matching items
        iLastItemIndex = -1;
        iItemIndex = ListView_FindItem(hw,iLastItemIndex,&lvf);
        while (iItemIndex != -1)
        {
            // inspect this item
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
            if (lpItem && (lpItem->cbEntryID != 0) && (lpOriginalItem->cbEntryID == lpItem->cbEntryID))
            {
                if(!memcmp(lpOriginalItem->lpEntryID,lpItem->lpEntryID,lpItem->cbEntryID))
                {
                    // this is the same item ... update it
                    if (lstrcmpi(lpItem->szDisplayName,lpOriginalItem->szDisplayName))
                    {
                        ListView_SetItemText(hw,iItemIndex,colDisplayName,lpOriginalItem->szDisplayName);
                        StrCpyN(lpItem->szDisplayName,lpOriginalItem->szDisplayName,ARRAYSIZE(lpItem->szDisplayName));
                    }

                    if (lstrcmpi(lpItem->szEmailAddress,lpOriginalItem->szEmailAddress))
                    {
                        ListView_SetItemText(hw,iItemIndex,colEmailAddress,lpOriginalItem->szEmailAddress);
                        StrCpyN(lpItem->szEmailAddress,lpOriginalItem->szEmailAddress,ARRAYSIZE(lpItem->szEmailAddress));
                    }

                    if (lstrcmpi(lpItem->szHomePhone,lpOriginalItem->szHomePhone))
                    {
                        ListView_SetItemText(hw,iItemIndex,colHomePhone,lpOriginalItem->szHomePhone);
                        StrCpyN(lpItem->szHomePhone,lpOriginalItem->szHomePhone,ARRAYSIZE(lpItem->szHomePhone));
                    }

                    if (lstrcmpi(lpItem->szOfficePhone,lpOriginalItem->szOfficePhone))
                    {
                        ListView_SetItemText(hw,iItemIndex,colOfficePhone,lpOriginalItem->szOfficePhone);
                        StrCpyN(lpItem->szOfficePhone,lpOriginalItem->szOfficePhone,ARRAYSIZE(lpItem->szOfficePhone));
                    }

                    if (lstrcmpi(lpItem->szByFirstName,lpOriginalItem->szByFirstName))
                        StrCpyN(lpItem->szByFirstName,lpOriginalItem->szByFirstName,ARRAYSIZE(lpItem->szByFirstName));

                    if (lstrcmpi(lpItem->szByLastName,lpOriginalItem->szByLastName))
                        StrCpyN(lpItem->szByLastName,lpOriginalItem->szByLastName,ARRAYSIZE(lpItem->szByLastName));
                }
            }

            iLastItemIndex = iItemIndex;
            iItemIndex = ListView_FindItem(hw,iLastItemIndex,&lvf);
        }
    }
out:
    return;
}


//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// ShowAddrBkLVProps ....
//
///////////////////////////////////////////////////////////////////////////////////////////////
void ShowAddrBkLVProps(LPIAB lpIAB, HWND hDlg, HWND hWndAddr,LPADDRESS_PARMS lpAP, LPFILETIME lpftLast)
{
    // get the display name of this item
    TCHAR szName[MAX_DISPLAY_NAME_LENGTH];
    szName[0]='\0';
    if (ListView_GetSelectedCount(hWndAddr) == 1)
    {
        ListView_GetItemText(   hWndAddr,
                                ListView_GetNextItem(hWndAddr,-1,LVNI_SELECTED),
                                0,
                                szName,
                                CharSizeOf(szName));
    }
    if( (MAPI_E_OBJECT_CHANGED == HrShowLVEntryProperties(hWndAddr, 0, lpAP->lpIAB, lpftLast)) &&
        (szName) &&
        (lpAP->DialogState == STATE_SELECT_RECIPIENTS)
      )
    {
        // if the entry has changed and we have multiple list views visible,
        // we need to update all instances of the entry in all the list views
        //
        UpdateLVItems(hWndAddr,szName);
        SortListViewColumn(lpIAB, GetDlgItem(hDlg,IDC_ADDRBK_LIST_ADDRESSES), colDisplayName, &(lpAP->SortInfo), TRUE);

    }
    SetFocus(hWndAddr);

}



//$$///////////////////////////////////////////////////////////////////////////////////////////
//
// HrUpdateAdrListEntry ....
//
//	When returning from a PickUser operation, updates the 
//	entry in the lpAdrList with the newly found item
//
//  ulFLags 0 or MAPI_UNICODE passed down to GetProps
//
//  Returns: Hr
//
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrUpdateAdrListEntry(	LPADRBOOK	lpIAB,
								LPENTRYID	lpEntryID,
								ULONG cbEntryID,
                                ULONG ulFlags,
								LPADRLIST * lppAdrList)
{

    LPSPropValue rgProps = NULL;
    ULONG cValues = 0;
    LPSPropValue lpPropArrayNew = NULL;
    ULONG cValuesNew = 0;
    LPTSTR lpszTemp = NULL;
    LPVOID lpbTemp = NULL;
    ULONG i = 0;
    SCODE sc;
	HRESULT hr = E_FAIL;

	if (!lppAdrList || !lpEntryID || !lpIAB || !cbEntryID)
		goto out;

    hr = HrGetPropArray(lpIAB,
                        (LPSPropTagArray) &ptaResolveDefaults,
                        cbEntryID,
                        lpEntryID,
                        ulFlags,
                        &cValues,
                        &rgProps);
    if (!HR_FAILED(hr))
    {

        if(!*lppAdrList)
        {
            // Allocate one ..
            LPADRLIST lpAdrList = NULL;

            sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY),
                                    &lpAdrList);

            if(FAILED(sc))
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto out;
            }

            *lppAdrList = lpAdrList;
            (*lppAdrList)->cEntries = 1;
            (*lppAdrList)->aEntries[0].ulReserved1 = 0;
            (*lppAdrList)->aEntries[0].cValues = 0;
            (*lppAdrList)->aEntries[0].rgPropVals = NULL;
        }

        //Merge the new list with the old list
        sc = ScMergePropValues( (*lppAdrList)->aEntries[0].cValues,
                                (*lppAdrList)->aEntries[0].rgPropVals,
                                cValues,
                                rgProps,
                                &cValuesNew,
                                &lpPropArrayNew);
        if (sc == S_OK)
        {
            // if OK replace the lpspropvalue array
            // if not we havent changed anything
            (*lppAdrList)->aEntries[0].cValues = cValuesNew;
            if((*lppAdrList)->aEntries[0].rgPropVals)
                MAPIFreeBuffer((*lppAdrList)->aEntries[0].rgPropVals);
            (*lppAdrList)->aEntries[0].rgPropVals = lpPropArrayNew;
        }
        else
        {
            // If errors Free up the allocated memory
            if (lpPropArrayNew)
                MAPIFreeBuffer(lpPropArrayNew);
			hr = E_FAIL;
        }

    }

    // we free this anyway whether the above succeeded or not
    if (rgProps)
        MAPIFreeBuffer(rgProps);

out:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_clbar.c ===
#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;
// extern LPIMAGELIST_LOADIMAGE    gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A     gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W     gpfnImageList_LoadImageW;


#define TBARCONTAINERCLASS TEXT("WABTBarContainerClass")

#undef  FCIDM_TOOLBAR
#define FCIDM_CONTAINER    4876
#define FCIDM_TOOLBAR       4876
#define CBIDX_TOOLS         4877

#define TB_BMP_CX       26
#define TB_BMP_CY       20
#define MAX_TB_WIDTH    80

enum _ImageLists
{
    IMLIST_DEFAULT=0,
    IMLIST_HOT,
    IMLIST_DISABLED,
    imlMax
};

HDC m_hdc = NULL;

LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void AddTools(LPBWI lpbwi, HWND hWndToolParent);
BOOL LoadToolNames(TCHAR *szTools);

#ifdef TOOLBAR_BACK
void OnPaint(HWND hwnd,HBITMAP hbm,HDC hdc);
#endif

void InitToolbar(   HWND hwnd,
                    UINT nBtns, TBBUTTON *ptbb,
                    TCHAR *pStrings, int cx,
                    int cy, int cxMax,
                    int idBmp,
                    int nNumColors);



/////******************************************************************************/
/////******************************************************************************/
/////******************************************************************************/
#ifdef TOOLBAR_BACK
HRESULT LoadBackBitmap()
{
    HRESULT hr = E_FAIL;
    HBITMAP     hbmSave;
    UINT        n;
    COLORREF    clrFace;
    UINT        i;
    RGBQUAD     rgbTable[256];
    RGBQUAD     rgbFace;
    HDC         m_hdc = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if (m_hbmBack)
    {
        DeleteObject(m_hbmBack);
        m_hbmBack = NULL;
    }
    if (m_hpalBkgnd)
    {
        DeleteObject(m_hpalBkgnd);
        m_hpalBkgnd = NULL;
    }

    m_hdc = CreateCompatibleDC(NULL);

    if (GetDeviceCaps(m_hdc, RASTERCAPS) & RC_PALETTE)
        m_hpalBkgnd = CreateHalftonePalette(m_hdc);


    m_hbmBack = (HBITMAP) LoadImage(hinstMapiX, MAKEINTRESOURCE(IDB_BITMAP_HBG),
                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION);

    if (!m_hbmBack)
        goto out;

    clrFace = GetSysColor(COLOR_BTNFACE);

    if (clrFace == RGB(192,192,192))
    {
        // no mapping needed
        hr = S_OK;
        goto out;
    }

    hbmSave = (HBITMAP)SelectObject(m_hdc, m_hbmBack);
    n = GetDIBColorTable(m_hdc, 0, 256, rgbTable);

    rgbFace.rgbRed   = GetRValue(clrFace);
    rgbFace.rgbGreen = GetGValue(clrFace);
    rgbFace.rgbBlue  = GetBValue(clrFace);

    for (i = 0; i < n; i++)
    {
        rgbTable[i].rgbRed   = (rgbTable[i].rgbRed   * rgbFace.rgbRed  ) / 192;
        rgbTable[i].rgbGreen = (rgbTable[i].rgbGreen * rgbFace.rgbGreen) / 192;
        rgbTable[i].rgbBlue  = (rgbTable[i].rgbBlue  * rgbFace.rgbBlue ) / 192;
    }

    SetDIBColorTable(m_hdc, 0, n, rgbTable);
    SelectObject(m_hdc, hbmSave);

    hr = S_OK;

out:
    if(m_hdc)
        DeleteDC(m_hdc);
    return(hr);
}
#endif
/////******************************************************************************/
/////******************************************************************************/
/////******************************************************************************/
HWND CreateCoolBar(LPBWI lpbwi, HWND hwndParent)
{
    DWORD                   dwcbData = 0;
    DWORD                   dwType = 0;
    IF_WIN32(WNDCLASSEX              wc;)
    IF_WIN16(WNDCLASS                wc;)

    HWND hWnd = NULL;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst)
        goto out;


#ifndef WIN16
    wc.cbSize = sizeof(WNDCLASSEX);

    if (!GetClassInfoEx(hinstMapiXWAB, TBARCONTAINERCLASS, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = SizableWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hinstMapiXWAB;
        wc.hCursor          = 0;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = TBARCONTAINERCLASS;
        wc.hIcon            = NULL;
        wc.hIconSm          = NULL;

        RegisterClassEx(&wc);
    }
#else
    if (!GetClassInfo(hinstMapiXWAB, TBARCONTAINERCLASS, &wc))
    {
        wc.style            = 0;
        wc.lpfnWndProc      = SizableWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = hinstMapiXWAB;
        wc.hCursor          = 0;
        wc.hbrBackground    = (HBRUSH) (COLOR_3DFACE + 1);
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = TBARCONTAINERCLASS;
        wc.hIcon            = NULL;

        RegisterClass(&wc);
    }
#endif


#ifdef TOOLBAR_BACK
    LoadBackBitmap();
#endif


    hWnd = CreateWindowEx(  0,//WS_EX_STATICEDGE,
                            TBARCONTAINERCLASS,
                            NULL,
                            WS_VISIBLE | WS_CHILD |
                            WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                            0,
                            0,
                            100,
                            36,
                            hwndParent,
                            (HMENU) FCIDM_CONTAINER,
                            hinstMapiXWAB,
                            (LPVOID)lpbwi);

    if (!hWnd)
    {
        DebugPrintError(( TEXT("CreateCoolBar: Show CreateWindow(TBARCONTAINERCLASS) failed")));
        goto out;
    }


    AddTools(lpbwi, hWnd);

    RedrawWindow(   hWnd,
                    NULL,
                    NULL,
                    RDW_INVALIDATE  | RDW_ERASE | RDW_ALLCHILDREN);

out:

    return hWnd;
}

#define MAX_TB_BUTTONS  6

/////******************************************************************************
/////******************************************************************************
ULONG GetToolbarButtonWidth()
{
    ULONG ulMax = 0;
    TCHAR szBuf[MAX_UI_STR];

    LoadString(hinstMapiX, idsToolbarMaxButtonWidth, szBuf, CharSizeOf(szBuf));
    ulMax = my_atoi(szBuf);

    if( (ulMax<=0)  ||  (ulMax>250) )
        ulMax = MAX_TB_WIDTH;

    return ulMax;
}

/////******************************************************************************
void AddTools(LPBWI lpbwi, HWND hWndToolParent)
{
    TCHAR szToolsText[(MAX_UI_STR + 2) * MAX_TB_BUTTONS];
    int nMaxButtons = MAX_TB_BUTTONS;
    HWND hWndTools = NULL;

#ifndef WIN16
    TBBUTTON tbExplorer[] =
    {
        { 0, IDC_BB_NEW,    TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 },
        { 1, IDC_BB_PROPERTIES,   TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 1 },
        { 2, IDC_BB_DELETE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 2 },
        { 3, IDC_BB_FIND,         TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 3 },
        { 4, IDC_BB_PRINT,        TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 4 },
        { 5, IDC_BB_ACTION,       TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 5 },
    };
#else  // !WIN16
    TBBUTTON tbExplorer[] =
    {
        { 0, IDC_BB_NEW,    TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
        { 1, IDC_BB_PROPERTIES,   TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 1 },
        { 2, IDC_BB_DELETE,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 2 },
        { 3, IDC_BB_FIND,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 3 },
        { 4, IDC_BB_PRINT,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 4 },
        { 5, IDC_BB_ACTION,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 5 },
    };
#endif // !WIN16

    if(!bPrintingOn)
        nMaxButtons--;

    if(!bPrintingOn)
        tbExplorer[4] = tbExplorer[5];

    // create tools window
    hWndTools = CreateWindowEx(    WS_EX_TOOLWINDOW,
                                    TOOLBARCLASSNAME,
                                    NULL,
                                    WS_CHILD | WS_VISIBLE | //WS_EX_TRANSPARENT |
                                    TBSTYLE_FLAT |  /*TBSTYLE_TOOLTIPS | TBSTYLE_TRANSPARENT |*/
                                    WS_CLIPCHILDREN |
                                    WS_CLIPSIBLINGS |
                                    CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                    CCS_NORESIZE,
                                    2,
                                    2,
                                    100,
                                    36,
                                    hWndToolParent,
                                    (HMENU) FCIDM_TOOLBAR,
                                    hinstMapiXWAB,
                                    NULL);

    if (!hWndTools)
    {
        DebugPrintError(( TEXT("AddTools: CITB:Show CreateWindow(TOOLBAR) failed")));
        goto out;
    }

    bwi_hWndTools = hWndTools;

    LoadToolNames(szToolsText);

    {
        // Check the current color resolution - if it is more than 256 colors we want
        // to use the high-color bitmaps
        int nNumColors = 0;
        HDC hDC = GetDC(NULL);

        nNumColors = GetDeviceCaps(hDC, BITSPIXEL);

        InitToolbar(    hWndTools,
                        nMaxButtons,
                        tbExplorer,
                        szToolsText,
                        TB_BMP_CX,
                        TB_BMP_CY,
                        GetToolbarButtonWidth(),
                        (nNumColors > 8) ? IDB_COOLBAR_DEFHI : IDB_COOLBAR_DEFAULT,
                        nNumColors);

        ReleaseDC(NULL, hDC);
    }



out:
    return;
}

/////******************************************************************************
/////******************************************************************************
/////******************************************************************************

BOOL LoadToolNames(TCHAR *szTools)
{
    int i;

    for (i = 0; i < MAX_TB_BUTTONS; i++)
    {
        LoadString(hinstMapiX, idsButton0 + i, szTools, MAX_UI_STR);
        szTools += lstrlen(szTools) + 1;
    }
    *szTools = TEXT('\0');
    return(TRUE);
}

/////******************************************************************************
/////******************************************************************************
/////******************************************************************************

void InitToolbar(   HWND hwnd,
                    UINT nBtns,
                    TBBUTTON *ptbb,
                    TCHAR *pStrings,
                    int cx,
                    int cy,
                    int cxMax,
                    int idBmp,
                    int nNumColors)
{
    HIMAGELIST phiml[imlMax];

    int nRows = 2;

    int i;

    for (i = 0; i < imlMax; i++)
    {
        UINT uFlags = LR_DEFAULTCOLOR;
        if (nNumColors > 8 && i != IMLIST_DISABLED)
            uFlags |= LR_CREATEDIBSECTION|LR_LOADMAP3DCOLORS;
        phiml[i] = gpfnImageList_LoadImage( hinstMapiX,
                                        MAKEINTRESOURCE(idBmp + i),
                                        //(LPCTSTR) ((DWORD) ((WORD) (idBmp + i))),
                                        cx,
                                        0,
                                        RGB(255,0,255),
                                        IMAGE_BITMAP,
                                        uFlags);
    }

    // this tells the toolbar what version we are
    SendMessage(hwnd, TB_BUTTONSTRUCTSIZE,    sizeof(TBBUTTON), 0);

    SendMessage(hwnd, TB_SETMAXTEXTROWS,      nRows, 0L);
    SendMessage(hwnd, TB_SETBITMAPSIZE,       0,     MAKELONG(cx, cy));
    SendMessage(hwnd, TB_SETIMAGELIST,        0,     (LPARAM) phiml[IMLIST_DEFAULT]);
    SendMessage(hwnd, TB_SETHOTIMAGELIST,     0,     (LPARAM) phiml[IMLIST_HOT]);
    SendMessage(hwnd, TB_SETDISABLEDIMAGELIST,0,     (LPARAM) phiml[IMLIST_DISABLED]);
    ToolBar_AddString(hwnd, (LPARAM) pStrings);
    ToolBar_AddButtons(hwnd, nBtns, (LPARAM) ptbb);
    SendMessage(hwnd, TB_SETBUTTONWIDTH,      0,     MAKELONG(0, cxMax));

    //Reset the toolbar container height to match the toolbars height
    {
        RECT rcTB, rcParent;
        HWND hwndParent = GetParent(hwnd);
        SendMessage(hwnd,TB_GETITEMRECT,0,(LPARAM) &rcTB);
        GetWindowRect(hwndParent,&rcParent);
        MoveWindow(hwndParent,rcParent.left, rcParent.top, rcParent.right - rcParent.left, rcTB.bottom-rcTB.top + 4,TRUE);
    }
}


/////******************************************************************************
/////******************************************************************************
/////******************************************************************************

LRESULT CALLBACK SizableWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch(uMsg)
    {
        case WM_CREATE:
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM) ((LPCREATESTRUCT) lParam)->lpCreateParams);
            break; 

        case WM_SETTINGCHANGE:
        case WM_SYSCOLORCHANGE:
            {
                LPBWI lpbwi = (LPBWI)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                SendMessage(bwi_hWndTools, uMsg, wParam, lParam);
            }
#ifdef TOOLBAR_BACK
            LoadBackBitmap();
#endif
            RedrawWindow(hwnd, NULL, NULL, RDW_ALLCHILDREN);
            break;


        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
            // We must swallow these messages to avoid infinite SendMessage
            break;


        case WM_NOTIFY:
            // We must swallow these messages to avoid infinite SendMessage
            //return(OnNotify((LPNMHDR) lParam));
            break;

//        case WM_PAINT:
//            break;

        case WM_ERASEBKGND:
            //
            // The TBSTYLE_FLAT toolbar cheats a little - to draw the
            // background bitmap, we have to draw the bitmap in the
            // WM_ERASEBKGND message. Then the toolbar draws a frame
            // around the selected button - when the mouse is removed from
            // the selected button, the toolbar sends us a
            // WM_ERASEBKGND again - but this time the corresponding
            // hdc is the hdc of the Toolbar and not of the child window.
            // So we **must** use this given hdc to redraw the background
            // bitmap, this time onto the toolbar, thus cleaning it up.

#ifdef TOOLBAR_BACK
            OnPaint(hwnd, m_hbmBack, (HDC) wParam);
            return TRUE;
#else
            {
                RECT rc;
                GetClientRect(hwnd, &rc);
                if(!DrawEdge((HDC) wParam, &rc, EDGE_ETCHED, BF_RECT))
                    DebugPrintError(( TEXT("Drawedge failed: %u\n"),GetLastError()));
            }
#endif
            break;

        case WM_SIZE:
            {
                LPBWI lpbwi = (LPBWI)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                RECT rc,rc1;
                GetClientRect(hwnd, &rc);
                GetChildClientRect(bwi_hWndTools, &rc1);
                if(bwi_hWndTools)
                    MoveWindow(bwi_hWndTools, rc1.left, rc1.top, rc.right-rc.left-4, rc.bottom-rc.top-4, TRUE);
                {
                    HDC hdc = GetDC(hwnd);
#ifdef TOOLBAR_BACK
                    OnPaint(hwnd, m_hbmBack, hdc);
#else
                    {
                        RECT rc;
                        GetClientRect(hwnd, &rc);
                        if(!DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT))
                            DebugPrintError(( TEXT("Drawedge failed: %u\n"),GetLastError()));
                    }
#endif
                    ReleaseDC(hwnd,hdc);
                }
            }
            break;

        case WM_DESTROY:
#ifdef TOOLBAR_BACK
            if (m_hbmBack)
            {
                DeleteObject(m_hbmBack);
                m_hbmBack = NULL;
            }
            if (m_hpalBkgnd)
            {
                DeleteObject(m_hpalBkgnd);
                m_hpalBkgnd = NULL;
            }
#endif
            break;

        case WM_COMMAND:
            //OnCommand(wParam, lParam);
            SendMessage(GetParent(hwnd),uMsg,wParam,lParam);
            break;

        case WM_PRVATETOOLBARENABLE:
            {
                LPBWI lpbwi = (LPBWI)GetWindowLongPtr(hwnd, GWLP_USERDATA);
                SendMessage(bwi_hWndTools, TB_ENABLEBUTTON, wParam, lParam);
            }
            break;

        case WM_PALETTECHANGED:
            RedrawWindow(   hwnd,
                            NULL,
                            NULL,
                            RDW_INVALIDATE  | RDW_ERASE | RDW_ALLCHILDREN);
            break;


        default:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

    return 0L;
}




#ifdef TOOLBAR_BACK
void OnPaint(HWND hwnd,HBITMAP hbm, HDC hdc)
{
//    HDC hdc;
    PAINTSTRUCT ps;
    HDC hdcMem;
    HBITMAP hbmMemOld;
    HPALETTE hpalOld = NULL;
    RECT rc;
    BITMAP bm;

    int cxIndent = 3;
    int cyIndent = 3;
    int nTop = 0;
    int nLeft = 0;
    int nButton = 0;
    int i=0;

    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    // Get the size of the background bitmap
    GetObject(hbm, sizeof(BITMAP), (LPVOID) &bm);
    GetClientRect(hwnd, &rc);

    BeginPaint(hwnd, &ps);

    if(hdc)
    {

        hdcMem = CreateCompatibleDC(hdc);

        if (m_hpalBkgnd)
        {
            hpalOld = SelectPalette(hdc, m_hpalBkgnd, TRUE);
            RealizePalette(hdc);
        }

        hbmMemOld = (HBITMAP) SelectObject(hdcMem, (HGDIOBJ) hbm);

        nTop = 0;
        nLeft = 0;

        while (nLeft < rc.right)
        {
            BitBlt(hdc, nLeft, nTop, bm.bmWidth, bm.bmHeight, hdcMem, 0,
                   0, SRCCOPY);
            nLeft += bm.bmWidth;
        }

        {
            if(!DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT))
                DebugPrintError(("Drawedge failed: %u\n",GetLastError()));
        }

        if (hpalOld != NULL)
            SelectPalette(hdc, hpalOld, TRUE);

        SelectObject(hdcMem, hbmMemOld);

        DeleteDC(hdcMem);
    } // if hdc...

    EndPaint(hwnd, &ps);

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_clbar.h ===
////////////////////////////////////////////////////////////////////////////////
//
// Header for adding stuff related to new rebar control ...
//
////////////////////////////////////////////////////////////////////////////////
#ifndef __UI_CLBAR_H_
#define __UI_CLBAR_H_



//Toolbar stuff
//#define TBSTYLE_FLAT            0x0800
//#define TBSTYLE_TRANSPARENT     0x1000
//#define TB_SETMAXTEXTROWS       (WM_USER + 60)
//#define TB_SETHOTIMAGELIST      (WM_USER + 52)
//#define TB_SETDISABLEDIMAGELIST (WM_USER + 54)
//#define TB_SETBUTTONWIDTH       (WM_USER + 59)

#define NO_COMMCTRL_SHLWAPI

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_ext.c ===
/**********************************************************************************
*
*
*   ui_ext.C - contains functions for handling/creating the extension property 
*           sheets to the wab property sheets
*
*   Created - 9/97 - vikramm
*
**********************************************************************************/
#include "_apipch.h"

static const TCHAR szExtDisplayMailUser[] = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\MailUser");
static const TCHAR szExtDisplayDistList[] = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\DistList");

DEFINE_GUID(CLSID_DsPropertyPages, 
            0xd45d530,  0x764b, 0x11d0, 0xa1, 0xca, 0x0, 0xaa, 0x0, 0xc1, 0x6e, 0x65);

//$$/////////////////////////////////////////////////////////////////////////////
//
// AddPropSheetPageProc
//
// CallBack from the Extension Sheets Prop Sheet creation function
//
/////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK AddPropSheetPageProc( HPROPSHEETPAGE hpage, LPARAM lParam )
{
    LPPROP_ARRAY_INFO lpPropArrayInfo = (LPPROP_ARRAY_INFO) lParam;
    HPROPSHEETPAGE * lphTemp = NULL;
    int i = 0;
    BOOL bNTDSExt = IsEqualGUID(&lpPropArrayInfo->guidExt, &CLSID_DsPropertyPages); //special casing for NTDS extensions
    int nPages = bNTDSExt ? lpPropArrayInfo->nNTDSPropSheetPages : lpPropArrayInfo->nPropSheetPages;
    HPROPSHEETPAGE * lph = bNTDSExt ? lpPropArrayInfo->lphNTDSpages : lpPropArrayInfo->lphpages;

    if(!hpage)
        return FALSE;
    
    // Grow the lpPropArrayInfo->lphpages array
    lphTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(HPROPSHEETPAGE) * (nPages+1));
    if(!lphTemp)
        return FALSE;

    // really inefficient
    if(lph)
    {
        for(i=0;i<nPages;i++)
        {
            lphTemp[i] = lph[i];
        }
        LocalFree(lph);
    }
    if(bNTDSExt)
    {
        lpPropArrayInfo->lphNTDSpages = lphTemp;
        lpPropArrayInfo->lphNTDSpages[lpPropArrayInfo->nNTDSPropSheetPages] = hpage;
        lpPropArrayInfo->nNTDSPropSheetPages++;
    }
    else
    {
        lpPropArrayInfo->lphpages = lphTemp;
        lpPropArrayInfo->lphpages[lpPropArrayInfo->nPropSheetPages] = hpage;
        lpPropArrayInfo->nPropSheetPages++;
    }

    
    return TRUE;
}
 
//$$////////////////////////////////////////////////////////////////////
//
//  HrGetExtDLLInfo
//
//  Enumerate all the registered DLL names and Function procs from the 
//  registry
//
//  bMailUser - if true, look for mailuser extensions 
//            - if false, look for distlist extensions
////////////////////////////////////////////////////////////////////////
HRESULT HrGetExtDLLInfo(LPEXTDLLINFO * lppList, ULONG * lpulCount, BOOL bMailUser, LPGUID lpguidPSExt)
{

    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;
    DWORD dwIndex = 0, dwSize = 0;
    LPTSTR lpReg = NULL;
    LPEXTDLLINFO lpList = NULL;
    ULONG ulCount = 0;

    if(!lppList || !lpulCount)
        goto out;

    *lppList = NULL;
    *lpulCount = 0;

    lpReg = (LPTSTR) (bMailUser ? szExtDisplayMailUser : szExtDisplayDistList);

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    lpReg,
                                    0, KEY_READ,
                                    &hKey))
    {
        goto out;
    }


    {
        TCHAR szGUIDName[MAX_PATH];
        DWORD dwGUIDIndex = 0, dwGUIDSize = CharSizeOf(szGUIDName), dwType = 0;

        *szGUIDName = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwGUIDIndex, 
                                            szGUIDName, &dwGUIDSize, 
                                            0, &dwType, 
                                            NULL, NULL))
        {
            // The values under this entry are all GUIDs
            // Read the GUID string and translate it into a GUID
            //
            GUID guidTmp = {0};
            WCHAR szW[MAX_PATH];
            StrCpyN(szW, szGUIDName, ARRAYSIZE(szW));
            if( lstrlen(szW) && !(HR_FAILED(hr = CLSIDFromString(szW, &guidTmp))) )
            {
                // Some applications may not want to see their property sheet extensions displayed
                // unless they have invoked the WAB. These applications can provide a GUID identifying 
                // them which will be compared to the extension GUIDs. If the GUID has a Data Value of
                // "1" this means it should only be loaded on-demand ..

                // First check the data Value
                TCHAR sz[32];
                DWORD dw = CharSizeOf(sz), dwT = 0;
                if(ERROR_SUCCESS == RegQueryValueEx(hKey, szGUIDName, NULL, &dwT,  (LPBYTE) sz, &dw))
                {
                    if( !lstrcmpi(sz,  TEXT("1"))   // this one wants to be loaded on demand only
                        && memcmp(&guidTmp, lpguidPSExt, sizeof(GUID)) ) //but guid doesnt match
                    {
                        goto endwhile;
                    }
                }
                {
                    LPEXTDLLINFO lpTemp = LocalAlloc(LMEM_ZEROINIT, sizeof(EXTDLLINFO));
                    if(!lpTemp)
                    {
                        hr = MAPI_E_NOT_ENOUGH_MEMORY;
                        goto out;
                    }
                    CopyMemory(&(lpTemp->guidPropExt), &guidTmp, sizeof(GUID));
                    lpTemp->bMailUser = bMailUser;
                    lpTemp->lpNext = lpList;
                    lpList = lpTemp;
                    ulCount++;
                }
            }
endwhile:
            dwGUIDIndex++;
            *szGUIDName = '\0';
            dwGUIDSize = CharSizeOf(szGUIDName);
        }
    }

    *lppList = lpList;
    *lpulCount = ulCount;
    hr = S_OK;
out:
    if(hKey)
        RegCloseKey(hKey);

    return hr;
}

BOOL fPropExtCoinit = FALSE;

//$$//////////////////////////////////////////////////////////////////////
//
// UninitExtInfo
//
//
//////////////////////////////////////////////////////////////////////////
void UninitExtInfo()
{
    if(fPropExtCoinit)
    {
        CoUninitialize();
        fPropExtCoinit = FALSE;
    }
}

//$$///////////////////////////////////////////////////////////////////
//
// FreePropExtList
//
///////////////////////////////////////////////////////////////////////
void FreePropExtList(LPEXTDLLINFO lpList)
{
    LPEXTDLLINFO lpTemp = lpList;
    while(lpList)
    {
        lpList = lpTemp->lpNext;
        SafeRelease(lpTemp->lpWABExtInit);
        SafeRelease(lpTemp->lpPropSheetExt);
        LocalFree(lpTemp);
        lpTemp = lpList;
    }
}

//$$///////////////////////////////////////////////////////////////////
//
// GetExtDisplayInfo
//
// Gets all the requisite info for the extended property pages
//
// fReadOnly - specifies if all prop sheet controls should be readonly
// fMailUser - true for contact, false for group
//
///////////////////////////////////////////////////////////////////////
HRESULT GetExtDisplayInfo(LPIAB lpIAB,
                          LPPROP_ARRAY_INFO lpPropArrayInfo,
                          BOOL fReadOnly,
                          BOOL bMailUser)
{
    ULONG i=0, nDLLs = 0;
    HRESULT hr = E_FAIL;
    LPEXTDLLINFO lpList = NULL, lpDLL = NULL;

    if(!lpIAB->lpPropExtDllList)
    {
        // There can be seperate registered entries for MailUsers and for DistLists
        // We will read everything and collate it into 1 large list

        LPEXTDLLINFO lpListMU = NULL, lpListDL = NULL;
        ULONG nDllsMU = 0, nDllsDL = 0;
        HRESULT hrMU = S_OK, hrDL = S_OK;

        // Get the list of registered DLL names for MailUsers
        //
        hrMU = HrGetExtDLLInfo(&lpListMU, &nDllsMU, TRUE, &lpIAB->guidPSExt);
        hrDL = HrGetExtDLLInfo(&lpListDL, &nDllsDL, FALSE, &lpIAB->guidPSExt);

        if( (!lpListMU && !lpListDL) || 
            !(nDllsDL + nDllsMU)     ||
            (HR_FAILED(hrMU) && HR_FAILED(hrDL)) )
        {
            hr = E_FAIL;
            goto out;
        }

        if(lpListMU)
        {
            lpIAB->lpPropExtDllList = lpListMU;
            while(lpListMU->lpNext)
                lpListMU = lpListMU->lpNext;
            lpListMU->lpNext = lpListDL;
        }
        else
            lpIAB->lpPropExtDllList = lpListDL;

        lpIAB->nPropExtDLLs = nDllsDL + nDllsMU;
    }

    lpList = lpIAB->lpPropExtDllList;
    nDLLs = lpIAB->nPropExtDLLs;

    lpPropArrayInfo->lpWED = LocalAlloc(LMEM_ZEROINIT, sizeof(WABEXTDISPLAY));
    if(!lpPropArrayInfo->lpWED)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpPropArrayInfo->lpWED->lpWABObject = (LPWABOBJECT) ((LPIAB)lpPropArrayInfo->lpIAB)->lpWABObject;
    lpPropArrayInfo->lpWED->lpAdrBook = lpPropArrayInfo->lpIAB;
    lpPropArrayInfo->lpWED->lpPropObj = lpPropArrayInfo->lpPropObj;
    lpPropArrayInfo->lpWED->fReadOnly = fReadOnly;
    lpPropArrayInfo->lpWED->fDataChanged = FALSE;

    if(lpPropArrayInfo->lpLDAPURL && lstrlen(lpPropArrayInfo->lpLDAPURL))
    {
        lpPropArrayInfo->lpWED->ulFlags |= WAB_DISPLAY_LDAPURL;
        lpPropArrayInfo->lpWED->lpsz = lpPropArrayInfo->lpLDAPURL;
        lpPropArrayInfo->lpWED->ulFlags |= MAPI_UNICODE;
        if(lpPropArrayInfo->bIsNTDSURL)
            lpPropArrayInfo->lpWED->ulFlags |= WAB_DISPLAY_ISNTDS;
    }

    if (CoInitialize(NULL) == S_FALSE) 
    {
        CoUninitialize(); // Already initialized, undo the extra.
    }
    else
        fPropExtCoinit = TRUE;

    lpDLL = lpList;
    for(i=0;i<nDLLs;i++)
    {
        if(lpDLL)
        {
            if(lpDLL->bMailUser==bMailUser)
            {
                if(!lpDLL->lpPropSheetExt || !lpDLL->lpWABExtInit)
                {
                    LPSHELLPROPSHEETEXT lpShellPropSheetExt = NULL;

                    hr = CoCreateInstance(  &(lpDLL->guidPropExt), 
                                            NULL, 
                                            CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                            &IID_IShellPropSheetExt, 
                                            (LPVOID *)&(lpDLL->lpPropSheetExt));
                    if(lpDLL->lpPropSheetExt && !HR_FAILED(hr))
                    {
                        hr = lpDLL->lpPropSheetExt->lpVtbl->QueryInterface(lpDLL->lpPropSheetExt,
                                                                &IID_IWABExtInit,
                                                                (LPVOID *)&(lpDLL->lpWABExtInit));
                        if(HR_FAILED(hr) || !lpDLL->lpWABExtInit)
                        {
                            SafeRelease(lpDLL->lpPropSheetExt);
                        }
                    }
                }

                if(lpDLL->lpPropSheetExt && lpDLL->lpWABExtInit)
                {
                    lpPropArrayInfo->guidExt = lpDLL->guidPropExt;

                    hr = lpDLL->lpWABExtInit->lpVtbl->Initialize(   lpDLL->lpWABExtInit,
                                                                    lpPropArrayInfo->lpWED);
                    if(!HR_FAILED(hr))
                    {
                        hr = lpDLL->lpPropSheetExt->lpVtbl->AddPages(lpDLL->lpPropSheetExt,
                                                                    &AddPropSheetPageProc, 
                                                                    (LPARAM) lpPropArrayInfo);
                    }
                }
            }
            lpDLL = lpDLL->lpNext;
        }
    }

    //lpPropArrayInfo->lpExtList = lpList;
    lpList = NULL;

    hr = S_OK;

out:
    if(lpList)
        FreePropExtList(lpList);

    return hr;
}


//$$//////////////////////////////////////////////////////////////////////
//
// FreeExtDisplayInfo 
//
//
//////////////////////////////////////////////////////////////////////////
void FreeExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo)
{
    if(lpPropArrayInfo->lpExtList)
        FreePropExtList(lpPropArrayInfo->lpExtList);
    if(lpPropArrayInfo->lpWED)
        LocalFree(lpPropArrayInfo->lpWED);
    if(lpPropArrayInfo->lphpages)
        LocalFree(lpPropArrayInfo->lphpages);
    //UninitExtInfo();
    return;
}


//$$/////////////////////////////////////////////////////////////////////
//
// ChangedExtDisplayInfo
//
// Returns true if the info changed on any of the prop sheets
//
/////////////////////////////////////////////////////////////////////////
BOOL ChangedExtDisplayInfo(LPPROP_ARRAY_INFO lpPropArrayInfo, BOOL bChanged)
{
    if(lpPropArrayInfo->lpWED && lpPropArrayInfo->lpWED->fDataChanged)
            return TRUE;
    return bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_detls.h ===
#ifndef _DETAILS_H_
#define _DETAILS_H_


HRESULT HrShowDetails(  LPADRBOOK   lpIAB,
                        HWND        hWndParent,
                        HANDLE      hPropertyStore,
                        ULONG       cbContEID,
                        LPENTRYID   lpContEID,
                        ULONG       *lpcbEntryID,
                        LPENTRYID   *lppEntryID,
                        LPMAPIPROP  lpPropObj,      // [optional] IN:IMAPIProp object
                        ULONG       ulFlags,
                        ULONG       ulObjectType,
                        BOOL        *lpbChangesMade);


HRESULT HrShowOneOffDetails(    LPADRBOOK lpAdrBook,
                                HWND    hWndParent,
                                ULONG   cbEntryID,
                                LPENTRYID   lpEntryID,
                                ULONG ulObjectType,
                                LPMAPIPROP lpPropObj, // [optional] IN:IMAPIProp object
                                LPTSTR szLDAPUrl,
                                ULONG   ulFlags);

// Flags used for showing the NewEntry and Details from the same dialog box
#define SHOW_DETAILS    0x00000001
#define SHOW_NEW_ENTRY  0x00000010
#define SHOW_ONE_OFF    0x00000100
#define SHOW_OBJECT     0x00001000  // HrShowDetails of an object


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_pwd.c ===
#define COBJMACROS
#include <_apipch.h>
#include <wab.h>
#define COBJMACROS
#include "resource.h"
#include "objbase.h"
#include "ui_pwd.h"
#include "commctrl.h"
#include "winuser.h"
#include "windowsx.h"
#include "imnxport.h"


// =====================================================================================
// Prototypes
// =====================================================================================
INT_PTR CALLBACK PasswordDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void PasswordDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify);
void PasswordDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
void PasswordDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode);
BOOL PasswordDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam);
extern VOID CenterDialog(HWND hwndDlg);

#define FIsStringEmpty(s)   (*s == 0)
#define ISFLAGSET(_dw, _f)           (BOOL)(((_dw) & (_f)) == (_f))

// --------------------------------------------------------------------------------
// HANDLE_COMMAND - Used in a WindowProc to simplify handling of WM_COMMAND messages
// --------------------------------------------------------------------------------
#define HANDLE_COMMAND(hwnd, id, hwndCtl, codeNotify, fn) \
                case (id): { (fn)((HWND)(hwnd), (HWND)(hwndCtl), (UINT)(codeNotify)); break; }

// =====================================================================================
// HrGetPassword
// =====================================================================================
HRESULT HrGetPassword (HWND hwndParent, LPPASSINFO lpPassInfo)
{
    // Locals
    HRESULT     hr = S_OK;
    INT         nResult;

    // Check Params
    AssertSz (lpPassInfo,  TEXT("NULL Parameter"));
    AssertSz (lpPassInfo->lpszPassword && lpPassInfo->lpszAccount && lpPassInfo->lpszServer &&
              (lpPassInfo->fRememberPassword == TRUE || lpPassInfo->fRememberPassword == FALSE),  TEXT("PassInfo struct was not inited correctly."));

    // Display Dialog Box
    nResult = (INT) DialogBoxParam (hinstMapiX, MAKEINTRESOURCE (iddPassword), hwndParent, PasswordDlgProc, (LPARAM)lpPassInfo);
    if (nResult == IDCANCEL)
        hr = S_FALSE;

    // Done
    return hr;
}

// =====================================================================================
// PasswordDlgProc
// =====================================================================================
INT_PTR CALLBACK PasswordDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG (hwndDlg, WM_INITDIALOG, PasswordDlgProc_OnInitDialog);
		HANDLE_MSG (hwndDlg, WM_COMMAND,    PasswordDlgProc_OnCommand);
	}

	return 0;
}

// =====================================================================================
// OnInitDialog
// =====================================================================================
BOOL PasswordDlgProc_OnInitDialog (HWND hwndDlg, HWND hwndFocus, LPARAM lParam)
{
    // Locals
    LPPASSINFO          lpPassInfo = NULL;
    TCHAR               szServer[CCHMAX_ACCOUNT_NAME];

	// Center
	CenterDialog (hwndDlg);

    // Make foreground
    SetForegroundWindow (hwndDlg);

    // Get Pass info struct
    lpPassInfo = (LPPASSINFO)lParam;
    if (lpPassInfo == NULL)
    {
        Assert (FALSE);
        return 0;
    }

    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)lpPassInfo);

	// Default
    Edit_LimitText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->cbMaxAccount);
    Edit_LimitText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->cbMaxPassword);

    // Set Defaults
    Edit_SetText (GetDlgItem (hwndDlg, IDS_SERVER), lpPassInfo->lpszServer);
    Edit_SetText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->lpszAccount);
    Edit_SetText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->lpszPassword);
    CheckDlgButton (hwndDlg, IDCH_REMEMBER, lpPassInfo->fRememberPassword);
    if (lpPassInfo->fAlwaysPromptPassword)
        EnableWindow(GetDlgItem(hwndDlg, IDCH_REMEMBER), FALSE);

    // Set Focus
    if (!FIsStringEmpty(lpPassInfo->lpszAccount))
        SetFocus (GetDlgItem (hwndDlg, IDE_PASSWORD));

    // Done
	return FALSE;
}

// =====================================================================================
// OnCommand
// =====================================================================================
void PasswordDlgProc_OnCommand (HWND hwndDlg, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
		HANDLE_COMMAND(hwndDlg, IDCANCEL, hwndCtl, codeNotify, PasswordDlgProc_OnCancel);		
		HANDLE_COMMAND(hwndDlg, IDOK, hwndCtl, codeNotify, PasswordDlgProc_OnOk);		
	}
	return;
}

// =====================================================================================
// OnCancel
// =====================================================================================
void PasswordDlgProc_OnCancel (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
	EndDialog (hwndDlg, IDCANCEL);
}

// =====================================================================================
// OnOk
// =====================================================================================
void PasswordDlgProc_OnOk (HWND hwndDlg, HWND hwndCtl, UINT uNotifyCode)
{
    // Locals
    LPPASSINFO lpPassInfo = NULL;

    lpPassInfo = (LPPASSINFO)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (lpPassInfo == NULL)
    {
        Assert (FALSE);
        EndDialog (hwndDlg, IDOK);
        return;
    }

    Edit_GetText (GetDlgItem (hwndDlg, IDE_ACCOUNT), lpPassInfo->lpszAccount, lpPassInfo->cbMaxAccount);
    Edit_GetText (GetDlgItem (hwndDlg, IDE_PASSWORD), lpPassInfo->lpszPassword, lpPassInfo->cbMaxPassword);
    lpPassInfo->fRememberPassword = IsDlgButtonChecked (hwndDlg, IDCH_REMEMBER);

    EndDialog (hwndDlg, IDOK);
}



//***************************************************************************
// Function: PromptUserForPassword
//
// Purpose:
//   This function prompts the user with a password dialog and returns the
// results to the caller.
//
// Arguments:
//   LPINETSERVER pInetServer [in/out] - provides default values for username
//     and password, and allows us to save password to account if user asks us
//     to. User-supplied username and password are saved to this structure
//     for return to the caller.
//   HWND hwnd [in] - parent hwnd to be used for password dialog.
//
// Returns:
//   TRUE if user pressed  TEXT("OK") on dialog, FALSE if user pressed  TEXT("CANCEL").
//***************************************************************************
BOOL PromptUserForPassword(LPINETSERVER pInetServer, HWND hwnd)
{
    PASSINFO pi = {0};
    HRESULT hrResult;
    BOOL bReturn;

    Assert(NULL != hwnd);

    // Initialize variables
    hrResult = S_OK;
    bReturn = FALSE;

    // Setup PassInfo Struct
    ZeroMemory (&pi, sizeof (PASSINFO));
    pi.cbMaxAccount = sizeof(pInetServer->szUserName);
    pi.cbMaxPassword = sizeof(pInetServer->szPassword);
    pi.lpszServer = ConvertAtoW(pInetServer->szAccount);    // We don't modify this in the dialog
    {
        LPWSTR  lpwszAccount;
        LPWSTR  lpwszPassword;

        pi.lpszAccount = LocalAlloc(LMEM_ZEROINIT, pi.cbMaxAccount);
        pi.lpszPassword = LocalAlloc(LMEM_ZEROINIT, pi.cbMaxPassword);

        // Convert to Unicode strings
        lpwszAccount = ConvertAtoW(pInetServer->szUserName);
        lpwszPassword = ConvertAtoW(pInetServer->szPassword);

        if (lpwszAccount && pi.lpszAccount)
            StrCpyN((pi.lpszAccount), lpwszAccount, (pi.cbMaxAccount / sizeof(WCHAR)));
        if (lpwszPassword && pi.lpszPassword)
        {
            StrCpyN((pi.lpszPassword), lpwszPassword, (pi.cbMaxPassword / sizeof(WCHAR)));
            ZeroMemory(lpwszPassword, (lstrlenW(lpwszPassword) * sizeof(lpwszPassword[0])));
        }

        LocalFreeAndNull(&lpwszAccount);
        LocalFreeAndNull(&lpwszPassword);
    }
    pi.fRememberPassword = !ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);
    pi.fAlwaysPromptPassword = ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD);

    // Prompt for password
    hrResult = HrGetPassword (hwnd, &pi);
    if (S_OK == hrResult) 
    {
        IImnAccount *pAcct;
        IImnAccountManager2 *pAcctMgr = NULL;

        // Update the INET server structure.  Must convert back to ANSI
        {
            LPSTR   lpszAccount = ConvertWtoA(pi.lpszAccount);
            LPSTR   lpszPassword = ConvertWtoA(pi.lpszPassword);

            // If the conversion from Wide to ANSI overflows the pInetServer string
            // buffers then we must fail.
            if (lpszAccount)
            {
                if (lstrlenA(lpszAccount) < (int)(pi.cbMaxAccount))
                    StrCpyNA(pInetServer->szUserName, lpszAccount, ARRAYSIZE(pInetServer->szUserName));
                else
                    hrResult = TYPE_E_BUFFERTOOSMALL;
            }
            if (lpszPassword)
            {
                if (lstrlenA(lpszPassword) < (int)(pi.cbMaxPassword))
                    StrCpyNA(pInetServer->szPassword, lpszPassword, ARRAYSIZE(pInetServer->szPassword));
                else
                    hrResult = TYPE_E_BUFFERTOOSMALL;
                ZeroMemory(lpszPassword, (lstrlenA(lpszPassword) * sizeof(lpszPassword[0])));
            }
            
            LocalFreeAndNull(&lpszAccount);
            LocalFreeAndNull(&lpszPassword);
        }

        if (SUCCEEDED(hrResult = InitAccountManager(NULL, &pAcctMgr, NULL)))
        {
            // User wishes to proceed. Save account and password info
    
            hrResult = pAcctMgr->lpVtbl->FindAccount(pAcctMgr, AP_ACCOUNT_NAME, pInetServer->szAccount, &pAcct);
            if (SUCCEEDED(hrResult)) 
            {
                // I'll ignore error results here, since not much we can do about 'em
                pAcct->lpVtbl->SetPropSz(pAcct, AP_HTTPMAIL_USERNAME, pInetServer->szUserName);
                if (pi.fRememberPassword)
                    pAcct->lpVtbl->SetPropSz(pAcct, AP_HTTPMAIL_PASSWORD, pInetServer->szPassword);
                else
                    pAcct->lpVtbl->SetProp(pAcct, AP_HTTPMAIL_PASSWORD, NULL, 0);

                pAcct->lpVtbl->SaveChanges(pAcct);
                pAcct->lpVtbl->Release(pAcct);
            }
            // don't release the lpAcctMgr since the WAB maintains a global reference.
        }
    
        bReturn = TRUE;
    }

    Assert(SUCCEEDED(hrResult));
    if (pi.lpszPassword && pi.cbMaxPassword)
        ZeroMemory(pi.lpszPassword, pi.cbMaxPassword);
    LocalFreeAndNull(&(pi.lpszPassword));
    LocalFreeAndNull(&(pi.lpszAccount));
    LocalFreeAndNull(&(pi.lpszServer));
    ZeroMemory(&pi, sizeof(pi));

    return bReturn;
} // PromptUserForPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_detls.c ===
/**********************************************************************************
*
*
*   Details.C - contains functions for the Details dialog
*
*
*
*
*
*
*
**********************************************************************************/

#include "_apipch.h"

#define _CRYPTDLG_
#define EDIT_LEN        MAX_UI_STR*2
#define MAX_EDIT_LEN    MAX_BUF_STR*2

#define IDC_TRIDENT_WINDOW  9903

extern BOOL bDNisByLN;

extern HINSTANCE ghCommCtrlDLLInst;

// extern LPPROPERTYSHEET gpfnPropertySheet;
// extern LPIMAGELIST_LOADIMAGE  gpfnImageList_LoadImage;
// extern LP_CREATEPROPERTYSHEETPAGE gpfnCreatePropertySheetPage;
extern LPPROPERTYSHEET_A            gpfnPropertySheetA;
extern LPPROPERTYSHEET_W            gpfnPropertySheetW;
extern LPIMAGELIST_LOADIMAGE_A      gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W      gpfnImageList_LoadImageW;
extern LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA;
extern LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW;

extern HRESULT HandleSaveChangedInsufficientDiskSpace(HWND hWnd, LPMAILUSER lpMailUser);
extern BOOL GetOpenFileName(LPOPENFILENAME pof);
extern BOOL GetSaveFileName(LPOPENFILENAME pof);
extern BOOL bIsIE401OrGreater();
extern void ChangeLocaleBasedTabOrder(HWND hWnd, int nPropSheet);

const LPTSTR szInternetCallKey = TEXT("Software\\Clients\\Internet Call");
const LPTSTR szCallto = TEXT("callto://");
const LPTSTR szHTTP = TEXT("http://");


/*  Context-Sensitive Help IDs

    The following is a giant list of Control IDs and corresponding Help IDs for
    all the controls on all the property sheets .. when adding new prop sheets
    just append your controls to the bottom of the list
    */
static DWORD rgDetlsHelpIDs[] =
{
    IDC_DETAILS_PERSONAL_FRAME_NAME,        IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_PERSONAL_FRAME_EMAIL,       IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_STATIC_FIRSTNAME,  IDH_WAB_CONTACT_PROPS_FIRST,
    IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME,    IDH_WAB_CONTACT_PROPS_FIRST,
    IDC_DETAILS_PERSONAL_STATIC_LASTNAME,   IDH_WAB_CONTACT_PROPS_LAST,
    IDC_DETAILS_PERSONAL_EDIT_LASTNAME,     IDH_WAB_CONTACT_PROPS_LAST,
    IDC_DETAILS_PERSONAL_STATIC_MIDDLENAME, IDH_WAB_MIDDLE_NAME,
    IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME,   IDH_WAB_MIDDLE_NAME,
    IDC_DETAILS_PERSONAL_STATIC_NICKNAME,   IDH_WAB_NICKNAME,
    IDC_DETAILS_PERSONAL_EDIT_NICKNAME,     IDH_WAB_NICKNAME,
    IDC_DETAILS_PERSONAL_STATIC_DISPLAYNAME,IDH_WAB_PERSONAL_NAME_DISPLAY,
    IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, IDH_WAB_PERSONAL_NAME_DISPLAY,
    IDC_DETAILS_PERSONAL_STATIC_TITLE,      IDH_WAB_CONTACT_PROPS_TITLE,
    IDC_DETAILS_PERSONAL_EDIT_TITLE,        IDH_WAB_CONTACT_PROPS_TITLE,
    IDC_DETAILS_PERSONAL_STATIC_CAPTION3,   IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL,     IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL,   IDH_WAB_ADD_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_LIST,              IDH_WAB_EMAIL_NAME_LIST,
    IDC_DETAILS_PERSONAL_BUTTON_REMOVE,     IDH_WAB_DELETE_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT, IDH_WAB_DEFAULT_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_EDIT,       IDH_WAB_EDIT_EMAIL_NAME,
    IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB,   IDH_WAB_DIRSERV_ADDADDRESS,
    IDC_DETAILS_PERSONAL_CHECK_RICHINFO,    IDH_WAB_PROPERTIES_SEND_USING_PLAIN_TEXT,

    IDC_DETAILS_HOME_STATIC_ADDRESS,        IDH_WAB_HOME_ADDRESS,
    IDC_DETAILS_HOME_EDIT_ADDRESS,          IDH_WAB_HOME_ADDRESS,
    IDC_DETAILS_HOME_STATIC_CITY,           IDH_WAB_HOME_CITY,
    IDC_DETAILS_HOME_EDIT_CITY,             IDH_WAB_HOME_CITY,
    IDC_DETAILS_HOME_STATIC_STATE,          IDH_WAB_HOME_STATE,
    IDC_DETAILS_HOME_EDIT_STATE,            IDH_WAB_HOME_STATE,
    IDC_DETAILS_HOME_STATIC_ZIP,            IDH_WAB_HOME_ZIP,
    IDC_DETAILS_HOME_EDIT_ZIP,              IDH_WAB_HOME_ZIP,
    IDC_DETAILS_HOME_STATIC_COUNTRY,        IDH_WAB_HOME_COUNTRY,
    IDC_DETAILS_HOME_EDIT_COUNTRY,          IDH_WAB_HOME_COUNTRY,
    IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS,  IDH_WAB_BUSINESS_DEFAULTBOX, 
    IDC_DETAILS_HOME_BUTTON_MAP,            IDH_WAB_BUSINESS_VIEWMAP,
    IDC_DETAILS_HOME_STATIC_WEB,            IDH_WAB_HOMEPAGE,
    IDC_DETAILS_HOME_EDIT_URL,              IDH_WAB_HOMEPAGE,
    IDC_DETAILS_HOME_BUTTON_URL,            IDH_WAB_HOMEPAGE_BUTTON,
    IDC_DETAILS_HOME_STATIC_PHONE,          IDH_WAB_BUS_PHONE,
    IDC_DETAILS_HOME_EDIT_PHONE,            IDH_WAB_BUS_PHONE,
    IDC_DETAILS_HOME_STATIC_FAX,            IDH_WAB_BUS_FAX,
    IDC_DETAILS_HOME_EDIT_FAX,              IDH_WAB_BUS_FAX,
    IDC_DETAILS_HOME_STATIC_CELLULAR,       IDH_WAB_BUS_CELLULAR,
    IDC_DETAILS_HOME_EDIT_CELLULAR,         IDH_WAB_BUS_CELLULAR,
    IDC_DETAILS_HOME_COMBO_GENDER,          IDH_WAB_HOME_GENDER,

    IDC_DETAILS_BUSINESS_STATIC_COMPANY,    IDH_WAB_BUS_COMPANY,
    IDC_DETAILS_BUSINESS_EDIT_COMPANY,      IDH_WAB_BUS_COMPANY,
    IDC_DETAILS_BUSINESS_STATIC_ADDRESS,    IDH_WAB_BUS_ADDRESS,
    IDC_DETAILS_BUSINESS_EDIT_ADDRESS,      IDH_WAB_BUS_ADDRESS,
    IDC_DETAILS_BUSINESS_STATIC_CITY,       IDH_WAB_BUS_CITY,
    IDC_DETAILS_BUSINESS_EDIT_CITY,         IDH_WAB_BUS_CITY,
    IDC_DETAILS_BUSINESS_STATIC_STATE,      IDH_WAB_BUS_STATE,
    IDC_DETAILS_BUSINESS_EDIT_STATE,        IDH_WAB_BUS_STATE,
    IDC_DETAILS_BUSINESS_STATIC_ZIP,        IDH_WAB_BUS_ZIP,
    IDC_DETAILS_BUSINESS_EDIT_ZIP,          IDH_WAB_BUS_ZIP,
    IDC_DETAILS_BUSINESS_STATIC_COUNTRY,    IDH_WAB_BUS_COUNTRY,
    IDC_DETAILS_BUSINESS_EDIT_COUNTRY,      IDH_WAB_BUS_COUNTRY,
    IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS,  IDH_WAB_BUSINESS_DEFAULTBOX,
    IDC_DETAILS_BUSINESS_BUTTON_MAP,        IDH_WAB_BUSINESS_VIEWMAP,
    IDC_DETAILS_BUSINESS_STATIC_JOBTITLE,   IDH_WAB_BUS_TITLE,
    IDC_DETAILS_BUSINESS_EDIT_JOBTITLE,     IDH_WAB_BUS_TITLE,
    IDC_DETAILS_BUSINESS_STATIC_DEPARTMENT, IDH_WAB_BUS_DEPT,
    IDC_DETAILS_BUSINESS_EDIT_DEPARTMENT,   IDH_WAB_BUS_DEPT,
    IDC_DETAILS_BUSINESS_STATIC_OFFICE,     IDH_WAB_BUS_OFFICE,
    IDC_DETAILS_BUSINESS_EDIT_OFFICE,       IDH_WAB_BUS_OFFICE,
    IDC_DETAILS_BUSINESS_STATIC_PHONE,      IDH_WAB_BUS_PHONE,
    IDC_DETAILS_BUSINESS_EDIT_PHONE,        IDH_WAB_BUS_PHONE,
    IDC_DETAILS_BUSINESS_STATIC_FAX,        IDH_WAB_BUS_FAX,
    IDC_DETAILS_BUSINESS_EDIT_FAX,          IDH_WAB_BUS_FAX,
    IDC_DETAILS_BUSINESS_STATIC_PAGER,      IDH_WAB_BUS_PAGER,
    IDC_DETAILS_BUSINESS_EDIT_PAGER,        IDH_WAB_BUS_PAGER,
    IDC_DETAILS_BUSINESS_STATIC_IPPHONE,    IDH_WAB_BUSINESS_IPPHONE,
    IDC_DETAILS_BUSINESS_EDIT_IPPHONE,      IDH_WAB_BUSINESS_IPPHONE,

    IDC_DETAILS_BUSINESS_STATIC_WEB,        IDH_WAB_HOMEPAGE,
    IDC_DETAILS_BUSINESS_EDIT_URL,          IDH_WAB_HOMEPAGE,
    IDC_DETAILS_BUSINESS_BUTTON_URL,        IDH_WAB_HOMEPAGE_BUTTON,

    IDC_DETAILS_NOTES_STATIC_NOTES,         IDH_WAB_NOTES,
    IDC_DETAILS_NOTES_EDIT_NOTES,           IDH_WAB_NOTES,
    IDC_DETAILS_NOTES_STATIC_NOTES_GROUP,   IDH_WAB_OTHER_GROUP_MEMBERSHIP,
    IDC_DETAILS_NOTES_EDIT_GROUPS,          IDH_WAB_OTHER_GROUP_MEMBERSHIP,
    IDC_DETAILS_NOTES_FRAME_FOLDER,         IDH_WAB_OTHER_FOLDER,
    IDC_DETAILS_NOTES_STATIC_FOLDER,        IDH_WAB_OTHER_FOLDER,

    IDC_DETAILS_CERT_FRAME,                 IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_CERT_LIST,                  IDH_WAB_PROPERTIES_CERTIFICATES,
    IDC_DETAILS_CERT_BUTTON_PROPERTIES,     IDH_WAB_PROPERTIES_PROPERTIES,
    IDC_DETAILS_CERT_BUTTON_REMOVE,         IDH_WAB_PROPERTIES_REMOVE,
    IDC_DETAILS_CERT_BUTTON_SETDEFAULT,     IDH_WAB_PROPERTIES_SETASDEFAULT,
    IDC_DETAILS_CERT_BUTTON_IMPORT,         IDH_WAB_PROPERTIES_IMPORT,
    IDC_DETAILS_CERT_BUTTON_EXPORT,         IDH_WAB_PROPERTIES_EXPORT,
    IDC_DETAILS_CERT_COMBO,                 IDH_WAB_CERTIFICATES_SELECT_EMAIL_ADDRESS,
    IDC_DETAILS_CERT_STATIC2,               IDH_WAB_CERTIFICATES_SELECT_EMAIL_ADDRESS,

    IDC_DETAILS_NTMTG_FRAME_SERVERS,        IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_NTMTG_FRAME_SERVERS2,       IDH_WAB_COMM_GROUPBOX,
    IDC_DETAILS_NTMTG_STATIC_CAPTION2,      IDH_WAB_CONFERENCE_SELECT_ADDRESS,
    IDC_DETAILS_NTMTG_COMBO_EMAIL,          IDH_WAB_CONFERENCE_SELECT_ADDRESS,
    IDC_DETAILS_NTMTG_BUTTON_CALL,          IDH_WAB_CONFERENCE_CALL_NOW,
    IDC_DETAILS_NTMTG_STATIC_CAPTION3,      IDH_WAB_CONFERENCE_SERVER_NAME,
    IDC_DETAILS_NTMTG_EDIT_ADDSERVER,       IDH_WAB_CONFERENCE_SERVER_NAME,
    IDC_DETAILS_NTMTG_BUTTON_ADDSERVER,     IDH_WAB_CONFERENCE_ADD_SERVER,
    IDC_DETAILS_NTMTG_BUTTON_EDIT,          IDH_WAB_CONFERENCE_EDIT_SERVER,
    IDC_DETAILS_NTMTG_BUTTON_REMOVE,        IDH_WAB_CONFERENCE_REMOVE_SERVER,
    IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT,    IDH_WAB_CONFERENCE_SET_DEFAULT,
    IDC_DETAILS_NTMTG_BUTTON_SETBACKUP,     IDH_WAB_CONFERENCE_SET_BACKUP,
    IDC_DETAILS_NTMTG_LIST_SERVERS,         IDH_WAB_CONFERENCE_SERVER_LIST,

    IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB,    IDH_WAB_DIRSERV_ADDADDRESS,

    IDC_DETAILS_SUMMARY_STATIC_NAME,        IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_EMAIL,       IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_HOMEPHONE,   IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_PAGER,       IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_CELLULAR,    IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSPHONE, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSFAX, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_JOBTITLE,    IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_DEPARTMENT,  IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_OFFICE,      IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_COMPANYNAME, IDH_WAB_SUMMARY,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB, IDH_WAB_SUMMARY,

    IDC_DETAILS_ORG_STATIC_MANAGER,         IDH_WAB_ORGANIZATION_MANAGER,
    IDC_DETAILS_ORG_LIST_MANAGER,           IDH_WAB_ORGANIZATION_MANAGER,
    IDC_DETAILS_ORG_STATIC_REPORTS,         IDH_WAB_ORGANIZATION_REPORTS,
    IDC_DETAILS_ORG_LIST_REPORTS,           IDH_WAB_ORGANIZATION_REPORTS,

    IDC_DETAILS_FAMILY_STATIC_SPOUSE,       IDH_WAB_PERSONAL_SPOUSE,
    IDC_DETAILS_FAMILY_EDIT_SPOUSE,         IDH_WAB_PERSONAL_SPOUSE,
    IDC_DETAILS_FAMILY_STATIC_CHILDREN,     IDH_WAB_PERSONAL_CHILDREN,
    IDC_DETAILS_FAMILY_LIST_CHILDREN,       IDH_WAB_PERSONAL_CHILDREN,
    IDC_DETAILS_FAMILY_BUTTON_ADDCHILD,     IDH_WAB_PERSONAL_ADD,
    IDC_DETAILS_FAMILY_BUTTON_EDITCHILD,    IDH_WAB_PERSONAL_EDIT,
    IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD,  IDH_WAB_PERSONAL_REMOVE,
    IDC_DETAILS_FAMILY_STATIC_BIRTHDAY,     IDH_WAB_PERSONAL_BIRTHDAY,
    IDC_DETAILS_FAMILY_STATIC_ANNIVERSARY,  IDH_WAB_PERSONAL_ANNIVERSARY,
    IDC_DETAILS_FAMILY_DATE_BIRTHDAY,       IDH_WAB_PERSONAL_BIRTHDAY,
    IDC_DETAILS_FAMILY_DATE_ANNIVERSARY,    IDH_WAB_PERSONAL_ANNIVERSARY,


    0,0
};



/* 
    
    Structs for Filling in data in the PropSheets

    When filling in IDs into each property sheet, we do a GetProps on the displayed
    object for the specific Props needed for each page .. we then use the returned
    data to fill in the current prop sheet ..
    Named properties need some special handling since we can't pre-allocate them into the structs -
    the named properties need to be added prior to using them
    Non-string properties may also need special handling
  */


  /* -- Summary TAB info --*/
#define MAX_SUMMARY_ID 13

int rgSummaryIDs[] = 
{
    IDC_DETAILS_SUMMARY_STATIC_NAME,
    IDC_DETAILS_SUMMARY_STATIC_EMAIL,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSPHONE,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSFAX,
    IDC_DETAILS_SUMMARY_STATIC_HOMEPHONE,
    IDC_DETAILS_SUMMARY_STATIC_PAGER,
    IDC_DETAILS_SUMMARY_STATIC_CELLULAR,
    IDC_DETAILS_SUMMARY_STATIC_JOBTITLE,
    IDC_DETAILS_SUMMARY_STATIC_DEPARTMENT,
    IDC_DETAILS_SUMMARY_STATIC_OFFICE,
    IDC_DETAILS_SUMMARY_STATIC_COMPANYNAME,
    IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB,
    IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB,
};

static const SizedSPropTagArray(MAX_SUMMARY_ID + 2, ptaUIDetlsPropsSummary) = 
{
    MAX_SUMMARY_ID + 2,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_COMPANY_NAME,
        PR_BUSINESS_HOME_PAGE,
        PR_PERSONAL_HOME_PAGE,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
    }
};

/* -- Personal/Name TAB info --*/

/*
 * [PaulHi] 4/8/99  Since the personal property sheet contains global properties
 * (i.e., the Ruby properties ... PR_WAB_YOMI_LASTNAME, PR_WAB_YOMI_FIRSTNAME), 
 * this tag array cannot be static.
static const SizedSPropTagArray(12, ptaUIDetlsPropsPersonal)=
{
    12,
    {
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_CONTACT_ADDRTYPES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
        PR_GIVEN_NAME,
        PR_SURNAME,
        PR_MIDDLE_NAME,
        PR_NICKNAME,
        PR_SEND_INTERNET_ENCODING,
        PR_DISPLAY_NAME_PREFIX
    }
};
*/

/* -- Home TAB info --*/
static SizedSPropTagArray(10, ptaUIDetlsPropsHome)=
{
    10,
    {
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_COUNTRY,
        PR_PERSONAL_HOME_PAGE,
        PR_HOME_TELEPHONE_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_NULL,    /*PR_WAB_POSTALID*/
    }
};

/* -- Business TAB info --*/
static SizedSPropTagArray(15, ptaUIDetlsPropsBusiness)=
{
    15,
    {
        PR_BUSINESS_ADDRESS_STREET,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_HOME_PAGE,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_COMPANY_NAME,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_NULL,    /*PR_WAB_IPPHONE*/
        PR_NULL,    /*PR_WAB_POSTALID*/

    }
};

/* -- Notes TAB info --*/
static const SizedSPropTagArray(1, ptaUIDetlsPropsNotes)=
{
    1,
    {
        PR_COMMENT,
    }
};

/* -- Digital ID TAB info --*/
static const SizedSPropTagArray(1, ptaUIDetlsPropsCert)=
{
    1,
    {
        PR_USER_X509_CERTIFICATE,
    }
};

/* -- Family TAB info --*/
static const SizedSPropTagArray(5, ptaUIDetlsPropsFamily)=
{
    5,
    {
        PR_SPOUSE_NAME,
        PR_CHILDRENS_NAMES,
        PR_GENDER,
        PR_BIRTHDAY,
        PR_WEDDING_ANNIVERSARY,
    }
};



enum _ImgEmail
{
    imgNotDefaultEmail=0,
    imgDefaultEmail,
    imgChild
};

typedef struct _EmailItem
{
    TCHAR szDisplayText[EDIT_LEN*2];
    TCHAR szEmailAddress[EDIT_LEN];
    TCHAR szAddrType[EDIT_LEN];
    BOOL  bIsDefault;

} EMAIL_ITEM, * LPEMAIL_ITEM;


typedef struct _ServerItem
{
    LPTSTR lpServer;
    LPTSTR lpEmail;
} SERVER_ITEM, * LPSERVER_ITEM;


enum _CertValidity
{
    imgCertValid=0,
    imgCertInvalid
};


enum _ListViewType
{
    LV_EMAIL=0,
    LV_CERT,
    LV_SERVER,
    LV_KIDS
};


// forward declarations
LRESULT CALLBACK RubySubClassedProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int CreateDetailsPropertySheet(HWND hwndOwner,LPPROP_ARRAY_INFO lpPropArrayInfo);

INT_PTR CALLBACK fnSummaryProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnPersonalProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnHomeProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnBusinessProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnNotesProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnCertProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnTridentProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnConferencingProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnOrgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnFamilyProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);

void FillComboWithEmailAddresses(LPPROP_ARRAY_INFO lpPai, HWND hWndCombo, int * lpnDefault);
void SetBackupServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce);
void SetDefaultServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce);
BOOL FillPersonalDetails(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL FillHomeBusinessNotesDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL FillCertTridentConfDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL FillFamilyDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade);
BOOL GetDetailsFromUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai , BOOL bSomethingChanged, int nPropSheet, LPSPropValue * lppPropArray, LPULONG lpulcPropCount);
BOOL SetDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, ULONG ulOperationType,int nPropSheet);

void CreateDateTimeControl(HWND hDlg, int idFrame, int idControl);
void AddLVNewChild(HWND hDlg, LPTSTR lpName);

void ShowExpediaMAP(HWND hDlg, LPMAPIPROP lpPropObj, BOOL bHome);
// [PaulHi] 4/5/99  Raid 57504  Enable the View Map button(s) for all locales.
// [PaulHi] 6/17/99 Raid 80805  Disable the View Map button again for various locales.
void ShowHideMapButton(HWND hWndButton);

HRESULT HrInitDetlsListView(HWND hWndLV, DWORD dwStyle, int nLVType);
void FreeLVParams(HWND hWndLV, int LVType);
void SetLVDefaultEmail( HWND hWndLV, int iItemIndex);
void AddLVEmailItem(HWND    hWndLV, LPTSTR  lpszEmailAddress, LPTSTR  lpszAddrType);
BOOL DeleteLVEmailItem(HWND hWndLV, int iItemIndex);
void ShowURL(HWND hWnd, int id, LPTSTR lpURL);
void SetHTTPPrefix(HWND hDlg, int id);
int AddNewEmailEntry(HWND hDlg, BOOL bShowCancelButton);
void SetDetailsWindowTitle(HWND hDlg, BOOL bModifyDisplayNameField);
void ShowRubyNameEntryDlg(HWND hDlg, LPPROP_ARRAY_INFO lpPai);

void SetComboDNText(HWND hDlg, LPPROP_ARRAY_INFO lpPAI, BOOL bAddAll, LPTSTR szTxt);
void FreeCertList(LPCERT_ITEM * lppCItem);

HRESULT HrSetCertInfoInUI(HWND hDlg, LPSPropValue lpPropMVCert, LPPROP_ARRAY_INFO lpPai);
BOOL AddLVCertItem(HWND hWndLV, LPCERT_ITEM lpCItem, BOOL bCheckForDups);
void SetLVDefaultCert( HWND hWndLV,int iItemIndex);
BOOL DeleteLVCertItem(HWND hWndLV, int iItemIndex, LPPROP_ARRAY_INFO lpPAI);
void ShowCertProps(HWND hDlg, HWND hWndLV, BOOL * lpBool);
BOOL ImportCert(HWND hDlg, LPPROP_ARRAY_INFO lpPai);
BOOL ExportCert(HWND hDlg);
void UpdateCertListView(HWND hDlg, LPPROP_ARRAY_INFO lpPai);

//HRESULT KillTrustInSleazyFashion(HWND hWndLV, int iItem);
void LocalFreeServerItem(LPSERVER_ITEM lpSI);
HRESULT HrAddEmailToObj(LPPROP_ARRAY_INFO lpPai, LPTSTR szEmail, LPTSTR szAddrType);


//$$/////////////////////////////////////////////////////////////////
//
// Ensure lower case character
//
/////////////////////////////////////////////////////////////////////
TCHAR lowercase(TCHAR ch) {
    if (ch >= 'A' && ch <= 'Z') {
        ch = ch + ('a' - 'A');
    }
    return(ch);
}

//$$///////////////////////////////////////////////////////////////////
//
// bIsHttpPrefix(LPTSTR szBuf) - verify that the URL is http: not file://fdisk.exe
//
//$$///////////////////////////////////////////////////////////////////
BOOL bIsHttpPrefix(LPTSTR szBuf)
{
    // SECURITY: make sure it's http:
    if (lstrlen(szBuf) > 5)
    {
        if (lowercase(szBuf[0]) == 'h' &&
            lowercase(szBuf[1]) == 't' &&
            lowercase(szBuf[2]) == 't' &&
            lowercase(szBuf[3]) == 'p' &&
            lowercase(szBuf[4]) == ':')
        {
            return TRUE;
        }
        else
        {
            // BUGBUG: Susan Higgs wants a dialog here, but BruceK thinks
            // it's superfluous.  If people are nice to each other, we should
            // not ever get here.  I regard this as a last ditch line of
            // security to keep ruthless people from exploiting our use
            // of ShellExecute.
            DebugTrace( TEXT("Whoa!  Somebody's put something other than a web page in the web page slot!  %sf\n"), szBuf);
        }
    }
    return FALSE;
}


// TBD - merge these two functions HrShowDetails and HrShowOneOffDetails

//$$///////////////////////////////////////////////////////////////////
//
// HrShowOneOffDetails - shows read-onlydetails for one-off addresses
//
//
//  We either pass in a cbEntryID-lpEntryID combination or
//      we pass in a ulcValues-lpPropArray combination or
//      we pass in a lpPropObj to display
//
//  If we are displaying one-off props on a LDAP URL result, the LDAP
//  URL is also added so that it can be piped into extension prop sheets
//  that need the LDAP URL information
//
//////////////////////////////////////////////////////////////////////
HRESULT HrShowOneOffDetails(    LPADRBOOK lpAdrBook,
                                HWND    hWndParent,
                                ULONG   cbEntryID,
                                LPENTRYID   lpEntryID,
                                ULONG ulObjectType,
                                LPMAPIPROP lpPropObj,
                                LPTSTR szLDAPURL,
                                ULONG   ulFlags)
{
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cValues = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG i=0;
    PROP_ARRAY_INFO PropArrayInfo = {0};

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if(ulFlags & WAB_ONEOFF_NOADDBUTTON)
    {
        ulFlags &= ~WAB_ONEOFF_NOADDBUTTON;
        PropArrayInfo.ulFlags |= DETAILS_HideAddToWABButton;
    }

    if ( ((!lpEntryID) && (!lpPropObj)) ||
         (ulFlags != SHOW_ONE_OFF))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(cbEntryID && lpEntryID)
    {
        // if this is a one-off address, do an open entry and then a get props to
        // get an lpPropArray from this guy ...

        if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                        cbEntryID,    // cbEntryID
                                                        lpEntryID,    // entryid
                                                        NULL,         // interface
                                                        0,                // ulFlags
                                                        &(PropArrayInfo.ulObjectType),
                                                        (LPUNKNOWN *)&(PropArrayInfo.lpPropObj) )))
        {
            // Failed!  Hmmm.
            if((HR_FAILED(hr)) && (MAPI_E_USER_CANCEL != hr))
            {
                int ids;
                UINT flags = MB_OK | MB_ICONEXCLAMATION;

                switch(hr)
                {
                case MAPI_E_UNABLE_TO_COMPLETE:
                case MAPI_E_AMBIGUOUS_RECIP:
                    ids = idsLDAPAmbiguousRecip;
                    break;
                case MAPI_E_NOT_FOUND:
                    ids = idsLDAPSearchNoResults;
                    break;
                case MAPI_E_NO_ACCESS:
                    ids = idsLDAPAccessDenied;
                    break;
                case MAPI_E_TIMEOUT:
                    ids = idsLDAPSearchTimedOut;
                    break;
                case MAPI_E_NETWORK_ERROR:
                    ids = idsLDAPCouldNotFindServer;
                    break;
                default:
                    ids = idsEntryNotFound;
                    break;
                }

                ShowMessageBox(  hWndParent, ids, flags);
            }
            goto out;
        }
    }
    else
    {
        PropArrayInfo.ulObjectType = ulObjectType;
        PropArrayInfo.lpPropObj = lpPropObj;
    }


    if (HR_FAILED(hr = PropArrayInfo.lpPropObj->lpVtbl->GetProps(PropArrayInfo.lpPropObj,
                                        NULL, MAPI_UNICODE,
                                        &cValues,     // how many properties were there?
                                        &lpPropArray)))
    {
        goto out;
    }

    if (cValues == 0)
    {
        // nothing to show
        hr = E_FAIL;
        goto out;
    }
    else
        PropArrayInfo.ulFlags |= DETAILS_ShowSummary;

    PropArrayInfo.lpIAB = lpAdrBook;

    //Now we can call the property sheets ...
    PropArrayInfo.cbEntryID = 0;    //this will be ignored for one-offs
    PropArrayInfo.lpEntryID = NULL;
    PropArrayInfo.bSomethingChanged = FALSE;

    for(i=0;i<TOTAL_PROP_SHEETS;i++)
        PropArrayInfo.bPropSheetOpened[i] = FALSE;

    PropArrayInfo.ulOperationType = SHOW_ONE_OFF;
    PropArrayInfo.nRetVal = DETAILS_RESET;

    if(InitCryptoLib())
        PropArrayInfo.ulFlags |= DETAILS_ShowCerts;

    // Do we show the org tab ?
    for(i=0;i<cValues;i++)
    {
        if( lpPropArray[i].ulPropTag == PR_WAB_MANAGER ||
            lpPropArray[i].ulPropTag == PR_WAB_REPORTS )
        {
            PropArrayInfo.ulFlags |= DETAILS_ShowOrg;
            break;
        }
    }

    // Check if we need to show the Trident Pane
#ifndef WIN16 // WIN16FF
    for(i=0;i<cValues;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_WAB_LDAP_LABELEDURI)
        {
            if(lstrlen(lpPropArray[i].Value.LPSZ) &&
               bIsHttpPrefix((LPTSTR)lpPropArray[i].Value.LPSZ) )
            {
                // We have the correct property, now check - do we have Trident installed
                // on this machine ???
                hr = HrNewWABDocHostObject(&(PropArrayInfo.lpIWABDocHost));
                if(!HR_FAILED(hr) && PropArrayInfo.lpIWABDocHost)
                {
                    // Check to see if we can load IE4 and whether its the right
                    // version of IE4 .. <TBD> this should actually be a global so we
                    // dont do this for each entry ...
                    // <TBD> dont hardcode these strings ..
                    LPDLLGETVERSIONPROCOE lpfnDllGetVersionProc = NULL;
                    HINSTANCE hTrident = LoadLibrary( TEXT("shdocvw.dll"));
                    if(hTrident)
                    {
                        lpfnDllGetVersionProc = (LPDLLGETVERSIONPROCOE) GetProcAddress(hTrident, "DllGetVersion");
                        if(lpfnDllGetVersionProc)
                        {
                            // Check the version number
                            DLLVERSIONINFO dvi = {0};
                            dvi.cbSize = sizeof(dvi);
                            lpfnDllGetVersionProc(&dvi);
                            // we are looking for IE4 version 4.71.0544.1 or more
                            if( dvi.dwMajorVersion > 4 ||
                                (dvi.dwMajorVersion == 4 && dvi.dwMinorVersion >= 71 && dvi.dwBuildNumber >= 544))
                            {
                                PropArrayInfo.ulFlags |= DETAILS_ShowTrident;
                            }
                        }
                        FreeLibrary(hTrident);
                    }
                }
            }
            break;
        }
    }
#endif

    // if this is an ldap entry, turn the ldap entryid into an ldapurl and pass that
    // to the extension prop sheets .. this enables the NTDS prop sheets to appropriately 
    // display themselves ..
    if( cbEntryID && lpEntryID )
    {
        LPTSTR lpURL = NULL;
        CreateLDAPURLFromEntryID(cbEntryID, lpEntryID, &lpURL, &PropArrayInfo.bIsNTDSURL);
        PropArrayInfo.lpLDAPURL = lpURL;
    }
    else
        PropArrayInfo.lpLDAPURL = szLDAPURL;

    GetExtDisplayInfo((LPIAB)lpAdrBook, &PropArrayInfo, TRUE, TRUE);

    if (CreateDetailsPropertySheet(hWndParent,&PropArrayInfo) == -1)
    {
        // Something failed ...
        hr = E_FAIL;
        goto out;
    }

    //  This was a read only operation so we dont care for the results ...
    //  so nothing more to do ....
    if(PropArrayInfo.nRetVal == DETAILS_ADDTOWAB)
    {
        ULONG cbEID = 0, cbPABEID = 0;
        LPENTRYID lpEID = NULL, lpPABEID = NULL;

        // We need to strip out the PR_WAB_LDAP_LABELEDURI prop and the
        // old entryid if it exists
        for(i=0;i<cValues;i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_WAB_LDAP_LABELEDURI:
                // remove the ldap url from this object
            case PR_ENTRYID:
                lpPropArray[i].ulPropTag = PR_NULL;
                break;
            }
            if(lpPropArray[i].ulPropTag == PR_WAB_MANAGER ||
               lpPropArray[i].ulPropTag == PR_WAB_REPORTS )
                 lpPropArray[i].ulPropTag = PR_NULL;
        }

        if(!HR_FAILED(hr = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbPABEID, &lpPABEID)))
        {
            hr = HrCreateNewEntry(  lpAdrBook,
                                    hWndParent,
                                    MAPI_MAILUSER,   //MAILUSER or DISTLIST
                                    cbPABEID, lpPABEID, 
                                    MAPI_ABCONT,//container entryid
                                    CREATE_CHECK_DUP_STRICT,
                                    TRUE,
                                    cValues,
                                    lpPropArray,
                                    &cbEID,
                                    &lpEID);
        }

        if(lpPABEID)
            MAPIFreeBuffer(lpPABEID);
        if(lpEID)
            MAPIFreeBuffer(lpEID);
    }

out:

    if(PropArrayInfo.lpLDAPURL && PropArrayInfo.lpLDAPURL!=szLDAPURL)
        LocalFree(PropArrayInfo.lpLDAPURL);

    LocalFreeAndNull(&PropArrayInfo.lpszOldName);

    FreeExtDisplayInfo(&PropArrayInfo);

    if(PropArrayInfo.szDefaultServerName)
        LocalFree(PropArrayInfo.szDefaultServerName);

    if(PropArrayInfo.szBackupServerName)
        LocalFree(PropArrayInfo.szBackupServerName);

    if(PropArrayInfo.lpIWABDocHost)
        (PropArrayInfo.lpIWABDocHost)->lpVtbl->Release(PropArrayInfo.lpIWABDocHost);

    if(PropArrayInfo.lpPropObj && !lpPropObj)
        PropArrayInfo.lpPropObj->lpVtbl->Release(PropArrayInfo.lpPropObj);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return hr;
}



//$$/////////////////////////////////////////////////////////////////
//
//  HrShowDetails - shows details/new entry UI
//
//  lpIAB           -   lpAdrBook object
//  hWndParent      -   hWnd of parent
//  hPropertyStore  - Handle to property store (can be retrieved from lpIAB)
//  cbEIDContainer  - EntryID of container in which to create the entry
//  lpEIDContainer  - EntryID of container in which to create the entry
//  lppEntryID      - entry id of object to display .. if a new object,
//                      contains the lpentryid of the created object
//  lpPropObj       - sometimes used in lieu of the entryid .. useful for
//                      adding objects like vCards and LDAP entries which have
//                      an object but dont currently exist in the WAB
//  ulFlags         - unused
//  lpbChangesMade  - Indicates if object was modified or not
//
///////////////////////////////////////////////////////////////////
HRESULT HrShowDetails(  LPADRBOOK   lpIAB,
                        HWND        hWndParent,
                        HANDLE      hPropertyStore,
                        ULONG       cbEIDContainer,
                        LPENTRYID   lpEIDContainer,
                        ULONG       *lpcbEntryID,
                        LPENTRYID   *lppEntryID,
                        LPMAPIPROP  lpPropObj,      // [optional] IN:IMAPIProp object
                        ULONG       ulFlags,
                        ULONG       ulObjectType,
                        BOOL    *   lpbChangesMade)
{
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;

    ULONG cbpta = 0;
    ULONG ulNumOldProps = 0;

    ULONG cbEntryID = 0;
    LPENTRYID lpEntryID = NULL;

    int     nRet = 0, nRetVal = 0;
    ULONG i = 0, j = 0, k = 0;
    PROP_ARRAY_INFO PropArrayInfo = {0};
    BOOL bChanges = FALSE;

    ULONG nMaxSheets = 0;

    DebugPrintTrace(( TEXT("----------\nHrShowDetails Entry\n")));

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if(lppEntryID)
        lpEntryID = *lppEntryID;

    if (lpcbEntryID)
        cbEntryID = *lpcbEntryID;


    if (    (!(ulFlags & SHOW_OBJECT) && hPropertyStore == NULL) ||
            ( (ulFlags & SHOW_DETAILS) && (lpEntryID == NULL)) ||
            ( (ulFlags & SHOW_OBJECT) && (lpPropObj == NULL)))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    if(cbEntryID && lpEntryID)
    {
        PropArrayInfo.cbEntryID = cbEntryID;
        PropArrayInfo.lpEntryID = LocalAlloc(LMEM_ZEROINIT, cbEntryID);

        CopyMemory(PropArrayInfo.lpEntryID, lpEntryID, cbEntryID);
        PropArrayInfo.ulFlags |= DETAILS_ShowSummary;
    }
    else if (ulFlags & SHOW_DETAILS)
    {
        // cant show details without a valid entryid
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    *lpbChangesMade = FALSE;

    if (ulFlags & SHOW_DETAILS)
    {
        if (HR_FAILED(hr = lpIAB->lpVtbl->OpenEntry(lpIAB,
                                                    cbEntryID,    // cbEntryID
                                                    lpEntryID,    // entryid
                                                    NULL,         // interface
                                                    MAPI_BEST_ACCESS,                // ulFlags
                                                    &(PropArrayInfo.ulObjectType),
                                                    (LPUNKNOWN *)&(PropArrayInfo.lpPropObj) )))
        {
            // Failed!  Hmmm.
            goto out;
        }
    }
    else if (ulFlags & SHOW_OBJECT)
    {
        Assert(lpPropObj);
        PropArrayInfo.lpPropObj = lpPropObj;
        PropArrayInfo.ulObjectType = ulObjectType;
    }
    else
    {
        SBinary sb = {0};
        sb.cb = cbEIDContainer;
        sb.lpb = (LPBYTE) lpEIDContainer;
        if(HR_FAILED(hr = HrCreateNewObject(    lpIAB,
                                                &sb,
                                                ulObjectType,
                                                0,
                                                &(PropArrayInfo.lpPropObj))))
        {
            goto out;
        }
        PropArrayInfo.ulObjectType = ulObjectType;
        PropArrayInfo.cbEntryID = 0;
        PropArrayInfo.lpEntryID = NULL;
        PropArrayInfo.ulFlags |= DETAILS_DNisFMLName;
    }

    PropArrayInfo.lpIAB = lpIAB;

    nMaxSheets = (ulObjectType == MAPI_DISTLIST) ? propDLMax : TOTAL_PROP_SHEETS;

    for(i=0;i<nMaxSheets;i++)
        PropArrayInfo.bPropSheetOpened[i] = FALSE;

    PropArrayInfo.ulOperationType = ulFlags;
    PropArrayInfo.nRetVal = DETAILS_RESET;
    PropArrayInfo.bSomethingChanged = FALSE;

    if(InitCryptoLib())
        PropArrayInfo.ulFlags |= DETAILS_ShowCerts;

    // Never show trident for regular people - only for LDAP contacts
    // PropArrayInfo.bShowTrident = FALSE;

    GetExtDisplayInfo((LPIAB) lpIAB, &PropArrayInfo, FALSE, (ulObjectType == MAPI_MAILUSER));

    if(ulObjectType == MAPI_MAILUSER)
    {
        if (CreateDetailsPropertySheet(hWndParent,&PropArrayInfo) == -1)
        {
            // Something failed ...
            hr = E_FAIL;
            goto out;
        }
    }
    else
    {
        if (CreateDLPropertySheet(hWndParent,&PropArrayInfo) == -1)
        {
            // Something failed ...
            hr = E_FAIL;
            goto out;
        }
    }

    if (PropArrayInfo.nRetVal == DETAILS_CANCEL)
    {
        hr = MAPI_E_USER_CANCEL;
        goto out;
    }

    bChanges = PropArrayInfo.bSomethingChanged;

    /*
    if(!bChanges)
    {
        for(i=0;i<nMaxSheets;i++)
        {
            if(PropArrayInfo.bPropSheetOpened[i])
            {
                // The returned prop array is not null
                // or the sheet was opened (which should return something) but
                // the returned array is null (which means every thing on that
                // particular sheet has been deleted).

                bChanges = TRUE;
                break;
            }
        }
    }
    */

    if(!bChanges && PropArrayInfo.lpWED)
    {
        if(PropArrayInfo.lpWED->fDataChanged)
        {
            bChanges = TRUE;
        }
    }

    if (!bChanges) goto out;

    // if its an object, dont save changes yet
    if(!(ulFlags & SHOW_OBJECT))
    {
        // Bug: 56220 - a retail-only bug in which for some reason the ObjAccess flag on
        // Groups gets reset to IPROP_READONLY which causes a write failure. I can't figure out
        // the cause for the problem but as a temporary solution, I'm forcing the access flag to
        // say READWRITE and everythng works fine then. Note that if we're at this code point, then
        // the object flag will ALWAYS be READWRITE anyway
        ((LPMailUser)PropArrayInfo.lpPropObj)->ulObjAccess = IPROP_READWRITE;

        hr = (PropArrayInfo.lpPropObj)->lpVtbl->SaveChanges( (PropArrayInfo.lpPropObj),               // this
                                            KEEP_OPEN_READWRITE);
        if(hr == MAPI_E_NOT_ENOUGH_DISK)
                hr = HandleSaveChangedInsufficientDiskSpace( hWndParent,
                                                            (LPMAILUSER) PropArrayInfo.lpPropObj);
        *lpbChangesMade = TRUE;
    }

    // if we want entryids back, make sure we get them
    {
        if(lppEntryID && lpcbEntryID && !*lppEntryID && !*lpcbEntryID)
        {
            LPSPropValue lpSPV = NULL;
            ULONG ulSPV = 0;
            if(!HR_FAILED(hr = (PropArrayInfo.lpPropObj)->lpVtbl->GetProps(PropArrayInfo.lpPropObj,
                                                                          (LPSPropTagArray)&ptaEid, MAPI_UNICODE,
                                                                          &ulSPV, &lpSPV)))
            {
                if(lpSPV[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID)
                {
                    sc = MAPIAllocateBuffer(lpSPV[ieidPR_ENTRYID].Value.bin.cb, lppEntryID);
                    if(!sc)
                    {
                        *lpcbEntryID = lpSPV[ieidPR_ENTRYID].Value.bin.cb;
                        CopyMemory(*lppEntryID, lpSPV[ieidPR_ENTRYID].Value.bin.lpb, *lpcbEntryID);
                    }
                }
                MAPIFreeBuffer(lpSPV);
            }
        }
    }

    hr = S_OK;

out:
    FreeExtDisplayInfo(&PropArrayInfo);

    LocalFreeAndNull(&PropArrayInfo.lpszOldName);

    if(PropArrayInfo.szDefaultServerName)
        LocalFree(PropArrayInfo.szDefaultServerName);

    if(PropArrayInfo.szBackupServerName)
        LocalFree(PropArrayInfo.szBackupServerName);

    if(PropArrayInfo.lpEntryID)
        LocalFree(PropArrayInfo.lpEntryID);

    if(PropArrayInfo.lpPropObj && !lpPropObj)
        PropArrayInfo.lpPropObj->lpVtbl->Release(PropArrayInfo.lpPropObj);

    return hr;
}




/*//$$***************************************************************************
*    FUNCTION: CreateDetailsPropertySheet(HWND)
*
*    PURPOSE:  Creates the Details property sheet
*
****************************************************************************/
int CreateDetailsPropertySheet(HWND hwndOwner,
                               LPPROP_ARRAY_INFO lpPropArrayInfo)
{
    PROPSHEETPAGE psp[TOTAL_PROP_SHEETS];
    PROPSHEETHEADER psh;
    //TCHAR szBuf[TOTAL_PROP_SHEETS][MAX_UI_STR];
    LPTSTR * szBuf = NULL;
    TCHAR szBuf2[MAX_UI_STR];
    ULONG ulProp = 0;
    ULONG ulTotal = 0;
    HPROPSHEETPAGE * lph = NULL;
    ULONG ulCount = 0;
    int i = 0;
    int nRet = 0;
    BOOL bRet = FALSE;
    // If it's an NTDS entry and we have the requisite prop sheets, then we are going to hide the 
    // WAB's version of the prop sheets and show the NTDS ones upfront instead
    //
    //  NTDS folks want us to hide the following: personal, home, business and other
    //      
    BOOL bShowNTDSProps = ( lpPropArrayInfo->nNTDSPropSheetPages && 
                            lpPropArrayInfo->lphNTDSpages &&
                            lpPropArrayInfo->bIsNTDSURL);

    ulTotal = TOTAL_PROP_SHEETS // Predefined ones +
            + lpPropArrayInfo->nPropSheetPages 
            + lpPropArrayInfo->nNTDSPropSheetPages;

    if(!(szBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*TOTAL_PROP_SHEETS)))
        goto out;
    for(i=0;i<TOTAL_PROP_SHEETS;i++)
    {
        if(!(szBuf[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_UI_STR)))
            goto out;
    }
    
    lph = LocalAlloc(LMEM_ZEROINIT, sizeof(HPROPSHEETPAGE) * ulTotal);
    if(!lph)
        goto out;

    psh.nStartPage = 0;

    //
    // Initialize info for the various property sheets
    //
    if( (lpPropArrayInfo->ulFlags & DETAILS_ShowSummary) && !bShowNTDSProps )
    {
        // Personal
        psp[propSummary].dwSize = sizeof(PROPSHEETPAGE);
        psp[propSummary].dwFlags = PSP_USETITLE;
        psp[propSummary].hInstance = hinstMapiX;
        psp[propSummary].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_SUMMARY);
        psp[propSummary].pszIcon = NULL;
        psp[propSummary].pfnDlgProc = fnSummaryProc;
        LoadString(hinstMapiX, idsDetailsSummaryTitle, szBuf[propSummary], MAX_UI_STR);
        psp[propSummary].pszTitle = szBuf[propSummary];
        psp[propSummary].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propSummary]));
        if(lph[ulCount])
            ulCount++;

        // Start page is personal page
        psh.nStartPage = propSummary;
    }

    if(!bShowNTDSProps)
    {
        // Personal
        // Check if this is Japan/China/Korea and use the RUBY personal prop sheet instead
        if(bIsRubyLocale())
            lpPropArrayInfo->ulFlags |= DETAILS_UseRubyPersonal;

        psp[propPersonal].dwSize = sizeof(PROPSHEETPAGE);
        psp[propPersonal].dwFlags = PSP_USETITLE;
        psp[propPersonal].hInstance = hinstMapiX;
        psp[propPersonal].pszTemplate = MAKEINTRESOURCE((lpPropArrayInfo->ulFlags & DETAILS_UseRubyPersonal) ? IDD_DETAILS_PERSONAL_RUBY : IDD_DETAILS_PERSONAL);
        psp[propPersonal].pszIcon = NULL;
        psp[propPersonal].pfnDlgProc = fnPersonalProc;
        LoadString(hinstMapiX, idsName, szBuf[propPersonal], MAX_UI_STR);
        psp[propPersonal].pszTitle = szBuf[propPersonal];
        psp[propPersonal].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propPersonal]));

        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        // Home
        psp[propHome].dwSize = sizeof(PROPSHEETPAGE);
        psp[propHome].dwFlags = PSP_USETITLE;
        psp[propHome].hInstance = hinstMapiX;
        psp[propHome].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_HOME);
        psp[propHome].pszIcon = NULL;
        psp[propHome].pfnDlgProc = fnHomeProc;
        LoadString(hinstMapiX, idsDetailsHomeTitle, szBuf[propHome], MAX_UI_STR);
        psp[propHome].pszTitle = szBuf[propHome];
        psp[propHome].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propHome]));
        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        // Business
        psp[propBusiness].dwSize = sizeof(PROPSHEETPAGE);
        psp[propBusiness].dwFlags = PSP_USETITLE;
        psp[propBusiness].hInstance = hinstMapiX;
        psp[propBusiness].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_BUSINESS);
        psp[propBusiness].pszIcon = NULL;
        psp[propBusiness].pfnDlgProc = fnBusinessProc;
        LoadString(hinstMapiX, idsDetailsBusinessTitle, szBuf[propBusiness], MAX_UI_STR);
        psp[propBusiness].pszTitle = szBuf[propBusiness];
        psp[propBusiness].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propBusiness]));
        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        psp[propFamily].dwSize = sizeof(PROPSHEETPAGE);
        psp[propFamily].dwFlags = PSP_USETITLE;
        psp[propFamily].hInstance = hinstMapiX;
        psp[propFamily].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_FAMILY);
        psp[propFamily].pszIcon = NULL;
        psp[propFamily].pfnDlgProc = fnFamilyProc;
        LoadString(hinstMapiX, idsDetailsPersonalTitle, szBuf[propFamily], MAX_UI_STR);
        psp[propFamily].pszTitle = szBuf[propFamily];
        psp[propFamily].lParam = (LPARAM) lpPropArrayInfo;
        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propFamily]));
        if(lph[ulCount])
            ulCount++;
    }

    if(!bShowNTDSProps)
    {
        // Notes
        psp[propNotes].dwSize = sizeof(PROPSHEETPAGE);
        psp[propNotes].dwFlags = PSP_USETITLE;
        psp[propNotes].hInstance = hinstMapiX;
        psp[propNotes].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_NOTES);
        psp[propNotes].pszIcon = NULL;
        psp[propNotes].pfnDlgProc = fnNotesProc;
        LoadString(hinstMapiX, idsDetailsNotesTitle, szBuf[propNotes], MAX_UI_STR);
        psp[propNotes].pszTitle = szBuf[propNotes];
        psp[propNotes].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propNotes]));
        if(lph[ulCount])
            ulCount++;
    }

    if(bShowNTDSProps) //now insert the NTDS props at this point instead of the above lot..
    {
        // Now do the extended props if any
        for(i=0;i<lpPropArrayInfo->nNTDSPropSheetPages;i++)
        {
            if(lpPropArrayInfo->lphNTDSpages)
            {
                lph[ulCount] = lpPropArrayInfo->lphNTDSpages[i];
                ulCount++;
            }
        }
    }

    // Conferencing
    psp[propConferencing].dwSize = sizeof(PROPSHEETPAGE);
    psp[propConferencing].dwFlags = PSP_USETITLE;
    psp[propConferencing].hInstance = hinstMapiX;
    psp[propConferencing].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_NTMTG);
    psp[propConferencing].pszIcon = NULL;
    psp[propConferencing].pfnDlgProc = fnConferencingProc;
    {
        TCHAR sz[MAX_PATH];
        LONG cbSize = CharSizeOf(sz);
        *sz='\0';
        if(RegQueryValue(HKEY_LOCAL_MACHINE, szInternetCallKey, sz, &cbSize) == ERROR_SUCCESS
           && lstrlen(sz)
           && !lstrcmpi(sz,TEXT("Microsoft NetMeeting")))
        {
            StrCpyN(szBuf[propConferencing], TEXT("NetMeeting"), MAX_UI_STR);
        }
        else
            LoadString(hinstMapiX, idsDetailsConferencingTitle, szBuf[propConferencing], MAX_UI_STR);
    }
    psp[propConferencing].pszTitle = szBuf[propConferencing];
    psp[propConferencing].lParam = (LPARAM) lpPropArrayInfo;

    lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[propConferencing]));
    if(lph[ulCount])
        ulCount++;


    ulProp = propConferencing + 1;


    if(lpPropArrayInfo->ulFlags & DETAILS_ShowCerts)
    {
        // Certificates
        psp[ulProp].dwSize = sizeof(PROPSHEETPAGE);
        psp[ulProp].dwFlags = PSP_USETITLE;
        psp[ulProp].hInstance = hinstMapiX;
        psp[ulProp].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_CERT);
        psp[ulProp].pszIcon = NULL;
        psp[ulProp].pfnDlgProc = fnCertProc;
        LoadString(hinstMapiX, idsDetailsCertTitle, szBuf[propCert], MAX_UI_STR);
        psp[ulProp].pszTitle = szBuf[propCert];
        psp[ulProp].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[ulProp]));
        if(lph[ulCount])
            ulCount++;

        ulProp++;
    }


    if( !bShowNTDSProps &&
        (lpPropArrayInfo->ulFlags & DETAILS_ShowOrg) )
    {
        // Organization
        psp[ulProp].dwSize = sizeof(PROPSHEETPAGE);
        psp[ulProp].dwFlags = PSP_USETITLE;
        psp[ulProp].hInstance = hinstMapiX;
        psp[ulProp].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_ORG);
        psp[ulProp].pszIcon = NULL;
        psp[ulProp].pfnDlgProc = fnOrgProc;
        LoadString(hinstMapiX, idsDetailsOrgTitle, szBuf[propOrg], MAX_UI_STR);
        psp[ulProp].pszTitle = szBuf[propOrg];
        psp[ulProp].lParam = (LPARAM) lpPropArrayInfo;

        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[ulProp]));
        if(lph[ulCount])
            ulCount++;

        ulProp++;
    }


    if(lpPropArrayInfo->ulFlags & DETAILS_ShowTrident)
    {
        // Trident sheet
        psp[ulProp].dwSize = sizeof(PROPSHEETPAGE);
        psp[ulProp].dwFlags = PSP_USETITLE;
        psp[ulProp].hInstance = hinstMapiX;
        psp[ulProp].pszTemplate = MAKEINTRESOURCE(IDD_DETAILS_TRIDENT);
        psp[ulProp].pszIcon = NULL;
        psp[ulProp].pfnDlgProc = fnTridentProc;
        LoadString(hinstMapiX, idsDetailsTridentTitle, szBuf[propTrident], MAX_UI_STR);
        psp[ulProp].pszTitle = szBuf[propTrident];
        psp[ulProp].lParam = (LPARAM) lpPropArrayInfo;
        
        lph[ulCount] = gpfnCreatePropertySheetPage(&(psp[ulProp]));
        if(lph[ulCount])
        {
            // Start page is trident page
            psh.nStartPage = ulCount;
            ulCount++;
        }

        lpPropArrayInfo->ulTridentPageIndex = ulProp;
        ulProp++;
    }


    // Now do the extended props if any
    for(i=0;i<lpPropArrayInfo->nPropSheetPages;i++)
    {
        if(lpPropArrayInfo->lphpages)
        {
            lph[ulCount] = lpPropArrayInfo->lphpages[i];
            ulCount++;
        }
    }

/*** US dialogs get truncated on FE OSes .. we want the comctl to fix the truncation
     but this is only implemented in IE4.01 and beyond .. the problem with this being 
     that wab is specifically compiled with the IE = 0x0300 so we're not pulling in the
     correct flag from the commctrl header .. so we will define the flag here and pray
     that commctrl never changes it ***/
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
/***                                ***/

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW;
    if(bIsIE401OrGreater())
        psh.dwFlags |= PSH_USEPAGELANG;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, IDS_DETAILS_CAPTION, szBuf2, CharSizeOf(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = ulCount; // ulProp //sizeof(psp) / sizeof(PROPSHEETPAGE);

    psh.phpage = lph;

    nRet = (int) gpfnPropertySheet(&psh);

    bRet = TRUE;
out:
    LocalFreeAndNull((LPVOID*)&lph);

    if(szBuf)
    {
        for(i=0;i<TOTAL_PROP_SHEETS;i++)
            LocalFreeAndNull(&(szBuf[i]));
        LocalFreeAndNull((LPVOID*)&szBuf);
    }
    return nRet;
}

/*  Filling in the Data in a Prop Sheet

        Since most props handled in the UI are string props, and it's just a 
        matter of doing SetText/GetText with the data on the appropriate edit
        control, we create control-property pairs of edit-controls and string props 
        and use them to fill in props in a simple loop

        Non string props and named props end up needing special handling
  */

typedef struct _tagIDProp
{
    ULONG ulPropTag;
    int   idCtl;

} ID_PROP;


// Control IDs corresponding to the Personal property sheet

ID_PROP idPropPersonal[]=
{
    {PR_DISPLAY_NAME,   IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME},
    {PR_GIVEN_NAME,     IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME},
    {PR_SURNAME,        IDC_DETAILS_PERSONAL_EDIT_LASTNAME},
    {PR_MIDDLE_NAME,    IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME},
    {PR_NICKNAME,       IDC_DETAILS_PERSONAL_EDIT_NICKNAME},
    {PR_DISPLAY_NAME_PREFIX, IDC_DETAILS_PERSONAL_EDIT_TITLE},
    {0,                 IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL},
    {PR_NULL/*YOMI_LAST*/,IDC_DETAILS_PERSONAL_STATIC_RUBYLAST},
    {PR_NULL/*YOMI_FIRST*/,IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST}
};
const ULONG idPropPersonalCount = 9;



// Control IDs corresponding to the Home property sheet

ID_PROP idPropHome[]=
{
    {PR_HOME_ADDRESS_STREET,             IDC_DETAILS_HOME_EDIT_ADDRESS},
    {PR_HOME_ADDRESS_CITY,               IDC_DETAILS_HOME_EDIT_CITY},
    {PR_HOME_ADDRESS_POSTAL_CODE,        IDC_DETAILS_HOME_EDIT_ZIP},
    {PR_HOME_ADDRESS_STATE_OR_PROVINCE,  IDC_DETAILS_HOME_EDIT_STATE},
    {PR_HOME_ADDRESS_COUNTRY,            IDC_DETAILS_HOME_EDIT_COUNTRY},
    {PR_PERSONAL_HOME_PAGE,              IDC_DETAILS_HOME_EDIT_URL},
    {PR_HOME_TELEPHONE_NUMBER,           IDC_DETAILS_HOME_EDIT_PHONE},
    {PR_HOME_FAX_NUMBER,                 IDC_DETAILS_HOME_EDIT_FAX},
    {PR_CELLULAR_TELEPHONE_NUMBER,       IDC_DETAILS_HOME_EDIT_CELLULAR},
    {PR_NULL/*PR_WAB_POSTALID*/,         IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS},
};
#define idPropHomePostalID     9 // since POSTALID is dynamically generated prop, it needs to be reset anytime the array is used
const ULONG idPropHomeCount = 10;


// Control IDs corresponding to the Business property sheet

ID_PROP idPropBusiness[]=
{
    {PR_BUSINESS_ADDRESS_STREET,         IDC_DETAILS_BUSINESS_EDIT_ADDRESS},
    {PR_BUSINESS_ADDRESS_CITY,           IDC_DETAILS_BUSINESS_EDIT_CITY},
    {PR_BUSINESS_ADDRESS_POSTAL_CODE,    IDC_DETAILS_BUSINESS_EDIT_ZIP},
    {PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,  IDC_DETAILS_BUSINESS_EDIT_STATE},
    {PR_BUSINESS_ADDRESS_COUNTRY,        IDC_DETAILS_BUSINESS_EDIT_COUNTRY},
    {PR_BUSINESS_HOME_PAGE,              IDC_DETAILS_BUSINESS_EDIT_URL},
    {PR_BUSINESS_TELEPHONE_NUMBER,       IDC_DETAILS_BUSINESS_EDIT_PHONE},
    {PR_BUSINESS_FAX_NUMBER,             IDC_DETAILS_BUSINESS_EDIT_FAX},
    {PR_PAGER_TELEPHONE_NUMBER,          IDC_DETAILS_BUSINESS_EDIT_PAGER},
    {PR_COMPANY_NAME,                    IDC_DETAILS_BUSINESS_EDIT_COMPANY},
    {PR_TITLE,                           IDC_DETAILS_BUSINESS_EDIT_JOBTITLE},
    {PR_DEPARTMENT_NAME,                 IDC_DETAILS_BUSINESS_EDIT_DEPARTMENT},
    {PR_OFFICE_LOCATION,                 IDC_DETAILS_BUSINESS_EDIT_OFFICE},
    {PR_NULL/*PR_WAB_IPPHONE*/,          IDC_DETAILS_BUSINESS_EDIT_IPPHONE},
    {PR_NULL/*PR_WAB_POSTALID*/,         IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS},
};
#define idPropBusIPPhone    13 // since PR_WAB_IPPHONE is dynamically generated prop, it needs to be reset anytime the array is used
#define idPropBusPostalID   14 // since POSTALID is dynamically generated prop, it needs to be reset anytime the array is used
const ULONG idPropBusinessCount = 15;


// Control IDs corresponding to the Notes property sheet
ID_PROP idPropNotes[] =
{
    {PR_COMMENT,    IDC_DETAILS_NOTES_EDIT_NOTES} //PR_COMMENT
};
const ULONG idPropNotesCount = 1;

// Control IDs corresponding to the Family property sheet
ID_PROP idPropFamily[] = 
{
    {PR_SPOUSE_NAME, IDC_DETAILS_FAMILY_EDIT_SPOUSE},
    {PR_GENDER, IDC_DETAILS_HOME_COMBO_GENDER},
    {PR_BIRTHDAY, IDC_DETAILS_FAMILY_DATE_BIRTHDAY},
    {PR_WEDDING_ANNIVERSARY, IDC_DETAILS_FAMILY_DATE_ANNIVERSARY},
    {PR_CHILDRENS_NAMES, IDC_DETAILS_FAMILY_LIST_CHILDREN}
};
const ULONG idPropFamilyCount = 5;


/*  
    A list of all the buttons on all the propsheets .. this is mostly used to render the buttons
    disabled when reading read-only data (such as vCards and LDAP)
    */
ULONG idSetReadOnlyControls[] = {
    IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL,
    IDC_DETAILS_PERSONAL_BUTTON_REMOVE,
    IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT,
    IDC_DETAILS_PERSONAL_BUTTON_EDIT,
    IDC_DETAILS_HOME_BUTTON_URL,
    IDC_DETAILS_BUSINESS_BUTTON_URL,
    IDC_DETAILS_CERT_BUTTON_PROPERTIES,
    IDC_DETAILS_CERT_BUTTON_REMOVE,
    IDC_DETAILS_CERT_BUTTON_SETDEFAULT,
    IDC_DETAILS_CERT_BUTTON_IMPORT,
    IDC_DETAILS_CERT_BUTTON_EXPORT,
    IDC_DETAILS_NTMTG_BUTTON_ADDSERVER,
    IDC_DETAILS_NTMTG_BUTTON_EDIT,
    IDC_DETAILS_NTMTG_BUTTON_REMOVE,
    IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT,
    IDC_DETAILS_NTMTG_BUTTON_SETBACKUP,
    IDC_DETAILS_NTMTG_COMBO_EMAIL,
    IDC_DETAILS_NTMTG_LIST_SERVERS,
    IDC_DETAILS_NTMTG_EDIT_ADDSERVER,
    IDC_DETAILS_FAMILY_EDIT_SPOUSE,
    IDC_DETAILS_FAMILY_LIST_CHILDREN,
    IDC_DETAILS_FAMILY_BUTTON_ADDCHILD,
    IDC_DETAILS_FAMILY_BUTTON_EDITCHILD,
    IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD,
    IDC_DETAILS_FAMILY_DATE_BIRTHDAY,
    IDC_DETAILS_FAMILY_DATE_ANNIVERSARY,
    IDC_DETAILS_HOME_COMBO_GENDER,
    IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS,
    IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS,
    IDC_DETAILS_PERSONAL_LIST,
    IDC_DETAILS_PERSONAL_CHECK_RICHINFO,
    IDC_DETAILS_CERT_LIST,
    IDC_DETAILS_CERT_COMBO,

};
const ULONG idSetReadOnlyCount = 33;



/*//$$***************************************************************************
*    FUNCTION: SetDetailsUI
*
*    PURPOSE:  Generic function that is used for doing the legwork for preparing
*           the prop sheet to receive the data. This will include setting the text limits
*           rendering controls read-only etc. Most of the propsheets call this same
*           function since there is a lot of common work for each property sheet.
*           To add future prop sheets, you can extend this function or you can just
*           write your own...
*
****************************************************************************/
BOOL SetDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, ULONG ulOperationType, int nPropSheet)
{
    ULONG i =0;
    ID_PROP * lpidProp = NULL;
    ULONG idCount = 0;

    switch(nPropSheet)
    {
    case propPersonal:
        //Check the send-plain text check box on the UI off by default
        CheckDlgButton(hDlg, IDC_DETAILS_PERSONAL_CHECK_RICHINFO, BST_UNCHECKED);
        // Initialize the list view
        lpPai->hWndDisplayNameField = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);
        HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), LVS_REPORT, LV_EMAIL);
        if (ulOperationType == SHOW_ONE_OFF)
        {
            EnableWindow(lpPai->hWndDisplayNameField , FALSE);
            EnableWindow(GetDlgItem(GetParent(hDlg), IDOK), FALSE);
        }
        lpidProp = idPropPersonal;
        idCount = idPropPersonalCount;
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),FALSE);
        SendMessage(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME),
                    CB_LIMITTEXT, (WPARAM) EDIT_LEN, 0);
        if(lpPai->ulFlags & DETAILS_UseRubyPersonal)
        {
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST, szEmpty);
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST, szEmpty);

            // [PaulHi] 3/29/99 Subclass the first and last name edit boxes.  The
            // static Ruby fields will be updated automatically.
            // Only do this for Japanese locales.
            if (GetUserDefaultLCID() == 0x0411)
            {
                HWND    hWndEdit;
                WNDPROC OldWndProc = NULL;

                hWndEdit = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME);
                Assert(hWndEdit);
                OldWndProc = (WNDPROC)SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (LONG_PTR)RubySubClassedProc);
                Assert(GetWindowLongPtr(hWndEdit, GWLP_USERDATA) == 0);
                SetWindowLongPtr(hWndEdit, GWLP_USERDATA, (LONG_PTR)OldWndProc);

                hWndEdit = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME);
                Assert(hWndEdit);
                OldWndProc = (WNDPROC)SetWindowLongPtr(hWndEdit, GWLP_WNDPROC, (LONG_PTR)RubySubClassedProc);
                Assert(GetWindowLongPtr(hWndEdit, GWLP_USERDATA) == 0);
                SetWindowLongPtr(hWndEdit, GWLP_USERDATA, (LONG_PTR)OldWndProc);
            }
        }
        break;

    case propHome:
        lpidProp = idPropHome;
        idCount = idPropHomeCount;
        lpidProp[idPropHomePostalID].ulPropTag = PR_WAB_POSTALID;
        ShowHideMapButton(GetDlgItem(hDlg, IDC_DETAILS_HOME_BUTTON_MAP));
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_HOME_EDIT_PHONE), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_HOME_EDIT_FAX), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_HOME_EDIT_CELLULAR), (HIMC) NULL);
        break;

    case propBusiness:
        lpidProp = idPropBusiness;
        idCount = idPropBusinessCount;
        lpidProp[idPropBusIPPhone].ulPropTag = PR_WAB_IPPHONE;
        lpidProp[idPropBusPostalID].ulPropTag = PR_WAB_POSTALID;

        ShowHideMapButton(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_BUTTON_MAP));
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_PHONE), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_FAX), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_PAGER), (HIMC) NULL);
        ImmAssociateContext(GetDlgItem(hDlg, IDC_DETAILS_BUSINESS_EDIT_IPPHONE), (HIMC) NULL);
        break;

    case propNotes:
        lpidProp = idPropNotes;
        idCount = idPropNotesCount;
        break;

    case propFamily:
        lpidProp = idPropFamily;
        idCount = idPropFamilyCount;
        {   // Gender Combo stuff
            TCHAR szBuf[MAX_PATH];
            HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_HOME_COMBO_GENDER);
            SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);
            for(i=0;i<3;i++)
            {
                LoadString(hinstMapiX, idsGender+i, szBuf, CharSizeOf(szBuf));
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
            }
            SendMessage(hWndCombo, CB_SETCURSEL, 0, 0); //default is unspecified gender
        }
        //Need to create the month date controls for this dialog
        CreateDateTimeControl(hDlg, IDC_STATIC_BIRTHDAY, IDC_DETAILS_FAMILY_DATE_BIRTHDAY);
        CreateDateTimeControl(hDlg, IDC_STATIC_ANNIVERSARY, IDC_DETAILS_FAMILY_DATE_ANNIVERSARY);
        //Setup the ListView for the children's names
        HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN), LVS_REPORT, LV_KIDS);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_FAMILY_BUTTON_EDITCHILD),FALSE);
        break;

    case propCert:
        HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST), LVS_REPORT, LV_CERT);
        lpidProp = NULL;
        idCount = 0;
        break;

    case propTrident:
        if (ulOperationType != SHOW_ONE_OFF)
        {
            HWND hwnd = GetDlgItem(hDlg, IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB);
            EnableWindow(hwnd, FALSE);
            ShowWindow(hwnd, SW_HIDE);
        }
        lpidProp = NULL;
        idCount = 0;
        break;

    case propConferencing:
        // If there is a Internet Call client installed, enable CallNow
        // else disable it
        {
            LONG cbSize = 0;
            if(RegQueryValue(HKEY_LOCAL_MACHINE, szInternetCallKey, NULL, &cbSize) == ERROR_SUCCESS && cbSize >= 1)
                EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CALL), TRUE);
            else
                EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CALL), FALSE);

            HrInitDetlsListView(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS), LVS_REPORT, LV_SERVER);
            lpPai->hWndComboConf = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL);

            lpPai->nDefaultServerIndex = -1;
            lpPai->nBackupServerIndex = -1;
            lpPai->cchDefaultServerName = MAX_UI_STR;
            lpPai->szDefaultServerName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lpPai->cchDefaultServerName));
            lpPai->cchBackupServerName = MAX_UI_STR;
            lpPai->szBackupServerName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lpPai->cchBackupServerName));
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_EDIT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_REMOVE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETBACKUP), FALSE);
        }
        break;
    }

    if(lpidProp && idCount)
    {

        //Set max input limits on the edit fields
        for(i=0;i<idCount;i++)
        {
            ULONG ulLen = EDIT_LEN; //512
            HWND hWndC= GetDlgItem(hDlg,lpidProp[i].idCtl);
            if(!hWndC)
                continue;
            // Some fields need to be longer than others ...
            switch(lpidProp[i].idCtl)
            {
            case IDC_DETAILS_HOME_EDIT_URL:
            case IDC_DETAILS_BUSINESS_EDIT_URL:
            case IDC_DETAILS_NOTES_EDIT_NOTES:
                ulLen = MAX_EDIT_LEN-MAX_DISPLAY_NAME_LENGTH; // ~2K
                break;
            case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS: //make exceptions for non-string props
            case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            case IDC_DETAILS_HOME_COMBO_GENDER:
                continue;
                break;
            }
            SendMessage(hWndC,EM_SETLIMITTEXT,(WPARAM) ulLen,0);
            if (ulOperationType == SHOW_ONE_OFF) // Make all the controls readonly
                SendMessage(hWndC,EM_SETREADONLY,(WPARAM) TRUE,0);
        }

    }

    if(nPropSheet == propHome)
        SetHTTPPrefix(hDlg, IDC_DETAILS_HOME_EDIT_URL);
    else if(nPropSheet == propBusiness)
        SetHTTPPrefix(hDlg, IDC_DETAILS_BUSINESS_EDIT_URL);

    if (ulOperationType == SHOW_ONE_OFF)
    {
        // Make all the readonlyable controls readonly
        for(i=0;i<idSetReadOnlyCount;i++)
        {
            switch(idSetReadOnlyControls[i])
            {
            case IDC_DETAILS_HOME_BUTTON_URL:
            case IDC_DETAILS_BUSINESS_BUTTON_URL:
                break;
            default:
                {
                    HWND hWnd = GetDlgItem(hDlg,idSetReadOnlyControls[i]);
                    if(hWnd)
                        EnableWindow(hWnd,FALSE);
                }
                break;
            }
        }
    }

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg, SetChildDefaultGUIFont, (LPARAM) 0);


    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//  RubySubClassedProc
//
//  Subclassed window proc for the Ruby static edit fields.  Used to provide
//  IME support.
///////////////////////////////////////////////////////////////////////////////
#define CCHMAX_RUBYSIZE 1024

LRESULT CALLBACK RubySubClassedProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    WNDPROC OldWndProc = (WNDPROC)GetWindowLongPtr(hWnd, GWLP_USERDATA);
    HIMC    hIMC;
    WCHAR   wszTemp[CCHMAX_RUBYSIZE];
    WCHAR   wszRuby[CCHMAX_RUBYSIZE];
    HWND    hWndParent;
    LONG    lId;
    HWND    hWndRuby = NULL;

    Assert(OldWndProc);

    switch (uMsg)
    {
    case WM_IME_COMPOSITION:
        if ( (hIMC = ImmGetContext(hWnd)) )
        {
            // IME does not include zero terminating character
            ZeroMemory(wszTemp, sizeof(wszTemp));
            ZeroMemory(wszRuby, sizeof(wszRuby));

            ImmGetCompositionStringW(hIMC, GCS_RESULTREADSTR, wszTemp, (sizeof(WCHAR) * (CCHMAX_RUBYSIZE-1)));
            // This subclassing only takes place for Japanese systems (lcid = 0x0411).
            LCMapString(0x0411, LCMAP_FULLWIDTH | LCMAP_HIRAGANA, wszTemp, lstrlen(wszTemp), wszRuby, CCHMAX_RUBYSIZE-1);
            ImmReleaseContext(hWnd, hIMC);

            // Set either the first or last name ruby field, depending on which edit control
            // this is.
            hWndParent = GetParent(hWnd);
            Assert(hWndParent);
            lId = (LONG)GetWindowLongPtr(hWnd, GWL_ID);

            switch (lId)
            {
            case IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME:
                hWndRuby = GetDlgItem(hWndParent, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST);
                break;

            case IDC_DETAILS_PERSONAL_EDIT_LASTNAME:
                hWndRuby = GetDlgItem(hWndParent, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST);
                break;

            default:
                Assert(0);  // What the heck did we subclass if not the two Ruby fields above?
                break;
            }

            if (hWndRuby)
            {
                BOOL    bDoConcat = TRUE;
                DWORD   dwStartSel = 0;
                DWORD   dwEndSel = 0;

                // If we have selected text in the edit field or it is empty then 
                // start over in Ruby field
                SendMessage(hWnd, EM_GETSEL, (WPARAM)&dwStartSel, (LPARAM)&dwEndSel);
                GetWindowText(hWnd, wszTemp, (CCHMAX_RUBYSIZE-1));
                if ( (dwEndSel > dwStartSel) || ((*wszTemp) == '\0') )
                    bDoConcat = FALSE;
                
                // Concatenate the text to what already exists in the Ruby field
                if (bDoConcat)
                {
                    GetWindowText(hWndRuby, wszTemp, (CCHMAX_RUBYSIZE-1));

                    if ( (lstrlen(wszTemp) + lstrlen(wszRuby) + 1) < CCHMAX_RUBYSIZE )
                    {
                        StrCatBuff(wszTemp, wszRuby, ARRAYSIZE(wszTemp));
                        SetWindowText(hWndRuby, wszTemp);
                        break;
                    }
                }

                // Default
                SetWindowText(hWndRuby, wszRuby);
            }
        }
        break;

    }   // end switch(uMsg)

    return CallWindowProc(OldWndProc, hWnd, uMsg, wParam, lParam);
}

/*//$$***************************************************************************
*    FUNCTION: FillCertComboWithEmailAddresses(hDlg, lpPai);
*
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
*   szEmail - if an email address is specified that exists in the
*       combo, that email address is selected
*
****************************************************************************/
void FillCertComboWithEmailAddresses(HWND hDlg, LPPROP_ARRAY_INFO lpPai, LPTSTR szEmail)
{
    HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_CERT_COMBO);
    TCHAR sz[MAX_UI_STR];
    int nDefault = 0;

    FillComboWithEmailAddresses(lpPai, hWndCombo, &nDefault);

    if( lpPai->ulOperationType != SHOW_ONE_OFF &&
        SendMessage(hWndCombo, CB_GETCOUNT, 0, 0) > 0 &&
        SendMessage(hWndCombo, CB_GETCOUNT, 0, 0) != CB_ERR ) 
        EnableWindow(hWndCombo, TRUE);

    // Append the item [None - certificates without e-mail addresses]
    // to this list
    *sz = '\0';

    LoadString(hinstMapiX, idsCertsWithoutEmails, sz, CharSizeOf(sz));

    // *** NOTE ***
    // This item should always be the last item in the combo - several
    // places in this file work on that assumption
    //
    if(lstrlen(sz))
        SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) sz);

    if(szEmail)
    {
        // Set focus to a specific email address
        int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
        if(lstrlen(szEmail))
        {
            int i;
            for(i=0;i<nCount-1;i++)
            {
                int nLen = (int)SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM)i, 0);
                if (nLen != CB_ERR)
                {
                    LPTSTR psz = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen + 1));
                    if (psz)
                    {
                        psz[0] = 0;
                        SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM) psz);
                        if( lstrlen(psz) &&
                            !lstrcmpi(psz, szEmail))
                        {
                            LocalFreeAndNull(&psz);
                            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) i, 0);
                            break;
                        }
                        LocalFreeAndNull(&psz);
                    }
                }
            }
        }
        else
        {
            // passed in an empty email string which means we have just imported
            // a cert without an email address which means set the focus to the
            // last item in the combo
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nCount-1, 0);
        }
    }
    else
        SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nDefault, 0);
}



//$$//////////////////////////////////////////////////////////////////////////////
//
// bVerifyRequiredData
//
// Checks that all the required data for a given prop sheet is filled in,
// If not, returns FALSE and ID of control to set focus on
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bVerifyRequiredData(HWND hDlg,
                         LPPROP_ARRAY_INFO lpPai,
                         int nPropSheet,
                         int * lpCtlID)
{
    TCHAR szBuf[2 * MAX_UI_STR];
    ULONG ulSzBuf = CharSizeOf(szBuf);

    //
    // First check the required property (which is the GroupName)
    //
    *lpCtlID = 0;
    szBuf[0]='\0';

    switch (nPropSheet)
    {
    case propPersonal:
        // We need to check that all the required properties are filled in ...
        // For now all we really want a display Name

        szBuf[0] = '\0';
        GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if (lstrlen(szBuf) == 0)
        {
            // Nothing in the display name field ..
            // Try to populate the field with the various info.
            // If we are successful in populating the field, we'll pick the first
            // entry as the default display name
            // If we are unsuccessful in picking something, we will stop and warn the
            // user
            HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);
            int nItemCount = 0;
            SetComboDNText(hDlg, lpPai, TRUE, NULL);
            nItemCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
            if(nItemCount == 0)
            {
                //still nothing , warn and abort
                ShowMessageBox(GetParent(hDlg), IDS_DETAILS_MESSAGE_FIRST_LAST_REQUIRED, MB_ICONEXCLAMATION | MB_OK);
                *lpCtlID = IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME;
                return FALSE;
            }
            else
            {
                //Get the combo current selection which will be item 0
                SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) 0, (LPARAM) szBuf);
            }
        }

        break;
    }
    return TRUE;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
// bUpdateOldPropTagArray
//
// For each prop sheet that is accessed, we will update the list of old prop tags
// for that sheet so that the old props can be knocked out of existing mailuser objects
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bUpdateOldPropTagArray(LPPROP_ARRAY_INFO lpPai, int nIndex)
{
    LPSPropTagArray lpta = NULL;

    SizedSPropTagArray(14, ptaUIDetlsPropsPersonal)=
    {
        14,
        {
            PR_DISPLAY_NAME,
            PR_EMAIL_ADDRESS,
            PR_ADDRTYPE,
            PR_CONTACT_EMAIL_ADDRESSES,
            PR_CONTACT_ADDRTYPES,
            PR_CONTACT_DEFAULT_ADDRESS_INDEX,
            PR_GIVEN_NAME,
            PR_SURNAME,
            PR_MIDDLE_NAME,
            PR_NICKNAME,
            PR_SEND_INTERNET_ENCODING,
            PR_DISPLAY_NAME_PREFIX,
            PR_WAB_YOMI_FIRSTNAME,
            PR_WAB_YOMI_LASTNAME
        }
    };

    switch(nIndex)
    {
        case propPersonal:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsPersonal;
            break;
        case propHome:
            ptaUIDetlsPropsHome.aulPropTag[idPropHomePostalID]  = PR_WAB_POSTALID;
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsHome;
            break;
        case propBusiness:
            ptaUIDetlsPropsBusiness.aulPropTag[idPropBusIPPhone]   = PR_WAB_IPPHONE;
            ptaUIDetlsPropsBusiness.aulPropTag[idPropBusPostalID]  = PR_WAB_POSTALID;
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsBusiness;
            break;
        case propNotes:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsNotes;
            break;
        case propCert:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsCert;
            break;
        case propConferencing:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsConferencing;
            break;
        case propFamily:
            lpta = (LPSPropTagArray) &ptaUIDetlsPropsFamily;
            break;
    }

    if(!lpta)
        return TRUE;

    if(lpPai->lpPropObj && lpPai->bSomethingChanged)
    {
        // Knock out these old props from the PropObject
        if( (lpPai->lpPropObj)->lpVtbl->DeleteProps( (lpPai->lpPropObj),lpta,NULL))
            return FALSE;
    }

    return TRUE;
}


/*
-
-   bGetHomeBusNotesInfo - Gets data from the Home/Business/Notes fields
-
*/
BOOL bGetHomeBusNotesInfo(HWND hDlg, LPPROP_ARRAY_INFO lpPai,
                          int nPropSheet, ID_PROP * lpidProp, ULONG idPropCount,
                          LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    // The idea is to first count all the properties that have non-zero values
    // Then create a lpPropArray of that size and fill in the text from the props ..
    //
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS:
            if(lpPai->ulFlags & DETAILS_DefHomeChanged)
                ulNotEmptyCount++;
            continue;
            break;
        case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            if(lpPai->ulFlags & DETAILS_DefBusChanged)
                ulNotEmptyCount++;
            continue;
            break;
        }
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
            ulNotEmptyCount++;
        // if its just the default prefix, ignore
        if( ((lpidProp[i].idCtl == IDC_DETAILS_HOME_EDIT_URL) ||
             (lpidProp[i].idCtl == IDC_DETAILS_BUSINESS_EDIT_URL)) &&
             (lstrcmpi(szHTTP, szBuf)==0))
             ulNotEmptyCount--;

    }

    if (ulNotEmptyCount == 0)
    {
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
    {
        DebugTrace(( TEXT("Error allocating memory\n")));
        goto out;
    }

   ulIndex = 0; //now we reuse this variable as an index

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS:
        case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            continue;
            break;
        }

        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);

        if( ((lpidProp[i].idCtl == IDC_DETAILS_HOME_EDIT_URL) ||
             (lpidProp[i].idCtl == IDC_DETAILS_BUSINESS_EDIT_URL)) &&
             (lstrcmpi(szHTTP, szBuf)==0))
             continue;

        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
        {
            ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
            lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;
            sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));

            if (sc!=S_OK)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                goto out;
            }
            StrCpyN(lpPropArray[ulIndex].Value.LPSZ,szBuf,nLen/sizeof(TCHAR));
            ulIndex++;
        }
    }
    if(nPropSheet == propHome)
    {
        if(lpPai->ulFlags & DETAILS_DefHomeChanged)
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_POSTALID;
            lpPropArray[ulIndex].Value.l = (IsDlgButtonChecked(hDlg, IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS)) ?
                                            ADDRESS_HOME : ADDRESS_NONE;
            ulIndex++;
        }
    }
    else if(nPropSheet == propBusiness)
    {
        if(lpPai->ulFlags & DETAILS_DefBusChanged)
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_POSTALID;
            lpPropArray[ulIndex].Value.l = (IsDlgButtonChecked(hDlg, IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS)) ?
                                            ADDRESS_WORK : ADDRESS_NONE;
            ulIndex++;
        }
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    return bRet;
}


/*
-   bGetPersonalInfo
-   Get Data from Personal Prop sheet
*
*/
BOOL bGetPersonalInfo(  HWND hDlg, LPPROP_ARRAY_INFO lpPai, 
                        ID_PROP * lpidProp, ULONG idPropCount,
                        LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;
    ULONG ulcProps = 0;
    LPSPropValue rgProps = NULL;

    HWND hWndLV = NULL;
    TCHAR szConf[MAX_UI_STR];

    SizedSPropTagArray(1, ptaIC) = {1, PR_SEND_INTERNET_ENCODING};

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, (LPSPropTagArray)&ptaIC, 
                                                    MAPI_UNICODE, &ulcProps, &rgProps)))
        goto out;

    szBuf[0] = '\0';
    hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
    
    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, (LPTSTR)szBuf, ulSzBuf);
    TrimSpaces(szBuf);
    if (lstrlen(szBuf) == 0)
    {
        // Nothing in the display name field ..
        // Try to populate the field with the various info.
        // If we are successful in populating the field, we'll pick the first
        // entry as the default display name
        // If we are unsuccessful in picking something, we will stop and warn the
        // user
        HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);
        int nItemCount = 0;

        SetComboDNText(hDlg, lpPai, TRUE, NULL);
        nItemCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
        if(nItemCount && nItemCount != CB_ERR)
        {
            //Get the combo current selection which will be item 0
            SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) 0, (LPARAM) szBuf);
        }
    }

    ulNotEmptyCount = 0;
    for(i=0;i<idPropCount;i++)
    {
        HWND hWndC = GetDlgItem(hDlg, lpidProp[i].idCtl);
        if(!hWndC)
            continue;
        szBuf[0]='\0'; //reset
        if(GetWindowText(hWndC, szBuf, ulSzBuf))
		{
			TrimSpaces(szBuf);
			if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
				ulNotEmptyCount++;
		}
    }


    if ((ulNotEmptyCount == 0) &&
        (ListView_GetItemCount(hWndLV) <= 0)) // Bug 14274 - werent looking for an email address before bailing out ..
    {
        // This prop sheet is empty ... ignore it
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    ulcPropCount++;      //  We create an entryid

    if(ListView_GetItemCount(hWndLV) > 0)
        ulcPropCount += 5;  // +1 for email1_address,
                            // +1 for addrtype,
                            // +1 for contact_email_addresses,
                            // +1 for contact_addrtypes
                            // +1 for contact_default_index,

    ulcPropCount++; //Add one for the PR_SEND_INTERNET_ENCODING property

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
    {
        DebugPrintError(( TEXT("Error allocating memory\n")));
        goto out;
    }

    ulIndex = 0;

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        HWND hWndC = GetDlgItem(hDlg, lpidProp[i].idCtl);
        if(!hWndC)
            continue;
        szBuf[0]='\0'; //reset
        GetWindowText(hWndC, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if(lstrlen(szBuf))
        {
            if(lpidProp[i].idCtl == IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST)
                lpidProp[i].ulPropTag = PR_WAB_YOMI_FIRSTNAME;
            else if(lpidProp[i].idCtl == IDC_DETAILS_PERSONAL_STATIC_RUBYLAST)
                lpidProp[i].ulPropTag = PR_WAB_YOMI_LASTNAME;

            if(lpidProp[i].ulPropTag) //some text
            {
                ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
                lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;

                sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));
                if (sc!=S_OK)
                {
                    DebugPrintError(( TEXT("Error allocating memory\n")));
                    goto out;
                }
                StrCpyN(lpPropArray[ulIndex].Value.LPSZ,szBuf,nLen/sizeof(TCHAR));
                ulIndex++;
            }
        }
    }

    // TBD - write code for getting all the other props

    // if this is a new entry, we want to give it a blank PR_ENTRYID property
    // else we want to set its PR_ENTRYID property
    lpPropArray[ulIndex].ulPropTag = PR_ENTRYID;

    if (lpPai->cbEntryID == 0)
    {
        lpPropArray[ulIndex].Value.bin.cb = 0;
        lpPropArray[ulIndex].Value.bin.lpb = NULL;
    }
    else
    {
        lpPropArray[ulIndex].Value.bin.cb = lpPai->cbEntryID;
        sc = MAPIAllocateMore(lpPai->cbEntryID, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.bin.lpb)));
        if (sc!=S_OK)
        {
            DebugPrintError(( TEXT("Error allocating memory\n")));
            goto out;
       }

        CopyMemory(lpPropArray[ulIndex].Value.bin.lpb,lpPai->lpEntryID,lpPai->cbEntryID);
    }

    ulIndex++;

    szConf[0] = TEXT('\0');

    // Check if we need to change the COnf_server_email_index prop
    if(lpPai->hWndComboConf)
    {
        GetWindowText(lpPai->hWndComboConf, szConf, CharSizeOf(szConf));
        TrimSpaces(szConf);
    }

    if(ListView_GetItemCount(hWndLV) > 0)
    {
        // Find out how many elements we need to add
        ULONG nEmailCount = ListView_GetItemCount(hWndLV);

        // we'll use the following as indexes for lpPropArray
        ULONG nMVEmailAddress = ulIndex++;//ulIndex+0;
        ULONG nMVAddrTypes =    ulIndex++;//ulIndex+1;
        ULONG nEmailAddress =   ulIndex++;//ulIndex+2;
        ULONG nAddrType =       ulIndex++;//ulIndex+3;
        ULONG nDefaultIndex =   ulIndex++;//ulIndex+4;

        lpPropArray[nEmailAddress].ulPropTag = PR_EMAIL_ADDRESS;
        lpPropArray[nAddrType].ulPropTag = PR_ADDRTYPE;
        lpPropArray[nDefaultIndex].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
        lpPropArray[nMVEmailAddress].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
        lpPropArray[nMVAddrTypes].ulPropTag = PR_CONTACT_ADDRTYPES;

        // initialize before using ...
        lpPropArray[nMVEmailAddress].Value.MVSZ.cValues = 0;
        lpPropArray[nMVEmailAddress].Value.MVSZ.LPPSZ = NULL;
        lpPropArray[nMVAddrTypes].Value.MVSZ.cValues = 0;
        lpPropArray[nMVAddrTypes].Value.MVSZ.LPPSZ = NULL;

        // For thetime being just null them all
        for(i=0;i<nEmailCount;i++)
        {
            LV_ITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            if (ListView_GetItem(hWndLV, &lvi))
            {
                LPEMAIL_ITEM lpEItem = (LPEMAIL_ITEM) lvi.lParam;

                if(HR_FAILED(hr = AddPropToMVPString(
                                            lpPropArray,
                                            ulcPropCount,
                                            nMVEmailAddress,
                                            lpEItem->szEmailAddress)))
                {
                    DebugPrintError(( TEXT("AddPropToMVString Email failed: %x"),hr));
                    goto out;
                }

                if(HR_FAILED(hr = AddPropToMVPString(
                                            lpPropArray,
                                            ulcPropCount,
                                            nMVAddrTypes,
                                            lpEItem->szAddrType)))
                {
                    DebugPrintError(( TEXT("AddPropToMVString AddrType failed: %x"),hr));
                    goto out;
                }

                if(lpEItem->bIsDefault)
                {
                    ULONG cchSize;

                    // For the default e-mail ... set all the other props
                    lpPropArray[nDefaultIndex].Value.l = i;

                    cchSize = lstrlen(lpEItem->szEmailAddress)+1;
                    sc = MAPIAllocateMore(  sizeof(TCHAR)*cchSize,
                                            lpPropArray,
                                            (LPVOID *) (&(lpPropArray[nEmailAddress].Value.LPSZ)));
                    if(FAILED(sc))
                    {
                        DebugPrintError(( TEXT("MApiAllocateMore failed\n")));
                        hr = ResultFromScode(sc);
                        goto out;
                    }
                    StrCpyN(lpPropArray[nEmailAddress].Value.LPSZ,lpEItem->szEmailAddress,cchSize);

                    cchSize = lstrlen(lpEItem->szAddrType)+1;
                    sc = MAPIAllocateMore(  sizeof(TCHAR)*cchSize,
                                            lpPropArray,
                                            (LPVOID *) (&(lpPropArray[nAddrType].Value.LPSZ)));
                    if(FAILED(sc))
                    {
                        DebugPrintError(( TEXT("MApiAllocateMore failed\n")));
                        hr = ResultFromScode(sc);
                        goto out;
                    }
                    StrCpyN(lpPropArray[nAddrType].Value.LPSZ,lpEItem->szAddrType,cchSize);

                } // if bIsDefault...
            } // if LV_GetItem ...
        } // for i = ...

    } // if LV_GetItemCount ...

    // Add the PR_SEND_INTERNET_ENCODING property
    lpPropArray[ulIndex].ulPropTag = PR_SEND_INTERNET_ENCODING;
    lpPropArray[ulIndex].Value.l = 0;

    // The PR_SEND_INTERNET_ECODING is a bit mask of several flags and we dont want
    // to loose any information that was in the original set of bits so we get it again
    if(rgProps[0].ulPropTag == PR_SEND_INTERNET_ENCODING)
    {
        //Check the check box on the UI
        lpPropArray[ulIndex].Value.l = rgProps[0].Value.l;
    }

    lpPropArray[ulIndex].Value.l &= ~BODY_ENCODING_MASK; //BODY_ENCODING_HTML;
    if(IsDlgButtonChecked(hDlg, IDC_DETAILS_PERSONAL_CHECK_RICHINFO) != BST_CHECKED)
        lpPropArray[ulIndex].Value.l |= BODY_ENCODING_TEXT_AND_HTML; //BODY_ENCODING_HTML;

    ulIndex++;

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    FreeBufferAndNull(&rgProps);
    return bRet;
}


/*
-   bGetConferencingInfo
-   Get Data from Conferencing Prop sheet
*
*/
BOOL bGetConferencingInfo(  HWND hDlg, LPPROP_ARRAY_INFO lpPai, 
                        LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nItemCount = ListView_GetItemCount(hWndLV);
    TCHAR szEmail[MAX_UI_STR];
    ULONG ulcProps = 0;
    LPSPropValue rgProps = NULL;

    SizedSPropTagArray(1, ptaCf) = {1, PR_WAB_CONF_SERVERS};

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, (LPSPropTagArray)&ptaCf, 
                                                    MAPI_UNICODE, &ulcProps, &rgProps)))
        goto out;

    // For the conferencing tab, we need to save 4 properties
    //  Conferencing Server Names
    //  Default Index
    //  Backup Index
    //  Email Address Index
    //
    ulNotEmptyCount = 0;

    if(nItemCount > 0)
    {
        ulNotEmptyCount += 2; // CONF_SERVERS and DEFAULT_INDEX

       if(lpPai->nBackupServerIndex != -1)
            ulNotEmptyCount++;
    }

    if (ulNotEmptyCount == 0)
    {
        // This prop sheet is empty ... ignore it
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
        goto out;

    ulIndex = 0; //now we reuse this variable as an index

    if(nItemCount > 0)
    {
        TCHAR * szCalltoStr = NULL; //szCalltoStr[MAX_UI_STR * 3];
        ULONG cchCalltoStr = MAX_UI_STR*3;
        ULONG i,j;

        if (szCalltoStr = LocalAlloc(LMEM_ZEROINIT, cchCalltoStr*sizeof(TCHAR)))
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_CONF_SERVERS;
            lpPropArray[ulIndex].Value.MVSZ.cValues = 0;
            lpPropArray[ulIndex].Value.MVSZ.LPPSZ = NULL;

            // first scan the original prop array for any PR_SERVERS props that
            // we didnt touch - retain those props witout losing them

            {
                j = 0; //index of PR_WAB_CONF_SERVERS prop
                if(rgProps[j].ulPropTag == PR_WAB_CONF_SERVERS)
                {
                    LPSPropValue lpProp = &(rgProps[j]);
                    for(i=0;i<lpProp->Value.MVSZ.cValues; i++)
                    {
                        LPTSTR lp = lpProp->Value.MVSZ.LPPSZ[i];
                        TCHAR sz[32];
                        int iLenCallto = lstrlen(szCallto);
                        if(!SubstringSearch(lp, TEXT("://")))
                            continue;
                        if(lstrlen(lp) < iLenCallto)
                            continue;

                        if (StrCmpNI(lp, szCallto, iLenCallto))
                        {
                            // Not a callto string .. retain it
                            if(HR_FAILED(hr = AddPropToMVPString( lpPropArray, ulcPropCount, ulIndex, lp)))
                            {
                                DebugPrintError(( TEXT("AddPropToMVString Conf server %s failed: %x"),lp, hr));
                                goto out;
                            }
                        }
                    }
                }
            }
            for(i=0;i< (ULONG) nItemCount; i++)
            {
                szBuf[0]='\0';
                szEmail[0] = '\0';
                {
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_PARAM;
                    lvi.iItem = i; lvi.iSubItem = 0;
                    ListView_GetItem(hWndLV, &lvi);
                    if(lvi.lParam)
                    {
                        LPSERVER_ITEM lpSI = (LPSERVER_ITEM) lvi.lParam;

                        if(lpSI->lpServer)
                            StrCpyN(szBuf, lpSI->lpServer, ulSzBuf);
                        if(lpSI->lpEmail)
                            StrCpyN(szEmail, lpSI->lpEmail, ARRAYSIZE(szEmail));
                    }
                }

                if(lstrlen(szBuf) && lstrlen(szEmail))
                {
                    StrCpyN(szCalltoStr, szCallto, cchCalltoStr);
                    StrCatBuff(szCalltoStr, szBuf, cchCalltoStr);
                    StrCatBuff(szCalltoStr, TEXT("/"), cchCalltoStr);
                    StrCatBuff(szCalltoStr, szEmail, cchCalltoStr);
                    if(HR_FAILED(hr = AddPropToMVPString( lpPropArray, ulcPropCount, ulIndex, szCalltoStr)))
                    {
                        DebugPrintError(( TEXT("AddPropToMVString Conf server %s failed: %x"),szCalltoStr, hr));
                        goto out;
                    }
                }
            }
            LocalFreeAndNull(&szCalltoStr);
        }

        ulIndex++;
        lpPropArray[ulIndex].ulPropTag = PR_WAB_CONF_DEFAULT_INDEX;
        lpPropArray[ulIndex].Value.l = (ULONG) lpPai->nDefaultServerIndex;

        ulIndex++;

        if(lpPai->nBackupServerIndex != -1)
        {
            lpPropArray[ulIndex].ulPropTag = PR_WAB_CONF_BACKUP_INDEX;
            lpPropArray[ulIndex].Value.l = (ULONG) lpPai->nBackupServerIndex;
            ulIndex++;
        }
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    FreeBufferAndNull(&rgProps);
    return bRet;
}

/*
- bGetFamilyInfo - get's info back from the Family Prop
-
*/
BOOL bGetFamilyInfo(HWND hDlg, LPPROP_ARRAY_INFO lpPai, 
                    ID_PROP * lpidProp, ULONG idPropCount,
                    LPSPropValue * lppPropArray, ULONG * lpulcPropCount)
{
    ULONG ulSzBuf = 4*MAX_BUF_STR;
    LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
    BOOL bRet = FALSE;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    ULONG i = 0;
    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
    SYSTEMTIME st = {0};
    short int nSel = 0;
	int nCount = 0;

    //The biggest field in the UI is about 2K length - just to be safe we want about 4K
    // in this buffer so we need to allocate it dynamically
    if(!szBuf)
    {
        DebugTrace(( TEXT("LocalAlloc failed to allocate memory\n")));
        return FALSE;
    }

    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_FAMILY_LIST_CHILDREN:
            if( lpPai->ulFlags & DETAILS_ChildrenChanged ||
                ListView_GetItemCount(hWndLV) > 0)
                ulNotEmptyCount++;
            continue;
            break;
        case IDC_DETAILS_FAMILY_DATE_BIRTHDAY:
        case IDC_DETAILS_FAMILY_DATE_ANNIVERSARY:
            {
                SYSTEMTIME st = {0};
                if( lpPai->ulFlags & DETAILS_DateChanged ||
                    GDT_VALID == SendDlgItemMessage(hDlg, lpidProp[i].idCtl, DTM_GETSYSTEMTIME, 0, (LPARAM) &st))
                    ulNotEmptyCount++;
            }
            continue;
        case IDC_DETAILS_HOME_COMBO_GENDER:
            if( lpPai->ulFlags & DETAILS_GenderChanged ||
                SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_GETCURSEL, 0, 0)>0 )
                ulNotEmptyCount++;
            continue;
            break;
        }
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
            ulNotEmptyCount++;
    }

    if (ulNotEmptyCount == 0)
    {
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);
    if (sc!=S_OK)
    {
        DebugTrace(( TEXT("Error allocating memory\n")));
        goto out;
    }

   ulIndex = 0; //now we reuse this variable as an index

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        switch(lpidProp[i].idCtl)
        {
        case IDC_DETAILS_FAMILY_DATE_BIRTHDAY:
        case IDC_DETAILS_FAMILY_DATE_ANNIVERSARY:
        case IDC_DETAILS_HOME_COMBO_GENDER:
        case IDC_DETAILS_FAMILY_LIST_CHILDREN:
            continue;
            break;
        }

        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, ulSzBuf);
        TrimSpaces(szBuf);

        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
        {
            ULONG nLen = sizeof(TCHAR)*(lstrlen(szBuf)+1);
            lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;
            sc = MAPIAllocateMore(nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));
            if (sc!=S_OK)
            {
                DebugTrace( TEXT("Error allocating memory\n"));
                goto out;
            }
            StrCpyN(lpPropArray[ulIndex].Value.LPSZ,szBuf,nLen/sizeof(TCHAR));
            ulIndex++;
        }
    }

    // Get the Gender data
    //
    nCount = ListView_GetItemCount(hWndLV);
    if(lpPai->ulFlags & DETAILS_ChildrenChanged || nCount>0)
    {
        ULONG ulCount = 0;
        if(nCount > 0)
        {
            lpPropArray[ulIndex].ulPropTag = PR_CHILDRENS_NAMES;
            sc = MAPIAllocateMore(nCount * sizeof(LPTSTR), lpPropArray, (LPVOID *)&(lpPropArray[ulIndex].Value.MVSZ.LPPSZ));
            if (sc!=S_OK)
            {
                DebugTrace( TEXT("Error allocating memory\n"));
                goto out;
            }
            for(i=0;i<(ULONG)nCount;i++)
            {
                *szBuf = '\0';
                ListView_GetItemText(hWndLV, i, 0, szBuf, ulSzBuf);
                if(szBuf && lstrlen(szBuf))
                {
                    ULONG cchSize=lstrlen(szBuf)+1;
                    sc = MAPIAllocateMore(sizeof(TCHAR)*cchSize, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.MVSZ.LPPSZ[ulCount])));
                    if (sc!=S_OK)
                    {
                        DebugTrace( TEXT("Error allocating memory\n"));
                        goto out;
                    }
                    StrCpyN(lpPropArray[ulIndex].Value.MVSZ.LPPSZ[ulCount], szBuf, cchSize);
                    ulCount++;
                }
            }
            lpPropArray[ulIndex].Value.MVSZ.cValues = ulCount;
            ulIndex++;
        }

    }
    nSel = (short int) SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_GETCURSEL, 0, 0);
    if(nSel == CB_ERR)
        nSel = 0;
    if(lpPai->ulFlags & DETAILS_GenderChanged || nSel>0)
    {
        lpPropArray[ulIndex].ulPropTag = PR_GENDER;
        lpPropArray[ulIndex].Value.i = nSel;
        ulIndex++;
    }

    if(GDT_VALID == SendDlgItemMessage(hDlg, IDC_DETAILS_FAMILY_DATE_BIRTHDAY, DTM_GETSYSTEMTIME, 0, (LPARAM) &st))
    {
        lpPropArray[ulIndex].ulPropTag = PR_BIRTHDAY;
        SystemTimeToFileTime(&st, (FILETIME *) (&lpPropArray[ulIndex].Value.ft));
        ulIndex++;
    }

    if(GDT_VALID == SendDlgItemMessage(hDlg, IDC_DETAILS_FAMILY_DATE_ANNIVERSARY, DTM_GETSYSTEMTIME, 0, (LPARAM) &st))
    {
        lpPropArray[ulIndex].ulPropTag = PR_WEDDING_ANNIVERSARY;
        SystemTimeToFileTime(&st, (FILETIME *) (&lpPropArray[ulIndex].Value.ft));
        ulIndex++;
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulIndex;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    LocalFreeAndNull(&szBuf);
    return bRet;
}


//$$//////////////////////////////////////////////////////////////////////////////
//
//  GetDetails from UI - reads the UI for its parameters and verifies that
//  all required fields are set.
//
//////////////////////////////////////////////////////////////////////////////////
BOOL GetDetailsFromUI(  HWND hDlg, LPPROP_ARRAY_INFO lpPai ,
                        BOOL bSomethingChanged, int nPropSheet,
                        LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    BOOL bRet = TRUE;
    ULONG i = 0;

    LPSPropValue lpPropArray = NULL;
    ULONG ulcPropCount = 0,ulIndex=0;

    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = hrSuccess;

    if (!bSomethingChanged)
    {
        bRet = TRUE;
        goto out;
    }

    *lppPropArray = NULL;
    *lpulcPropCount = 0;

    DebugTrace( TEXT("GetDetailsFromUI: %d\n"),nPropSheet);

    switch(nPropSheet)
    {
    case propHome:
        idPropCount = idPropHomeCount;
        lpidProp = idPropHome;
        lpidProp[idPropHomePostalID].ulPropTag = PR_WAB_POSTALID;
        goto GetProp;
    case propBusiness:
        idPropCount = idPropBusinessCount;
        lpidProp = idPropBusiness;
        lpidProp[idPropBusIPPhone].ulPropTag = PR_WAB_IPPHONE;
        lpidProp[idPropBusPostalID].ulPropTag = PR_WAB_POSTALID;
        goto GetProp;
    case propNotes:
        idPropCount = idPropNotesCount;
        lpidProp = idPropNotes;
GetProp:
        bRet = bGetHomeBusNotesInfo(hDlg, lpPai, nPropSheet, 
                        lpidProp, idPropCount,lppPropArray, lpulcPropCount);
        break;
/***********/
    case propPersonal:
        bRet = bGetPersonalInfo(hDlg, lpPai, idPropPersonal, idPropPersonalCount, lppPropArray, lpulcPropCount);
        break; // case propPersonal
/***********/
    case propCert:
        // There is only 1 property, PR_USER_X509_CERTIFICATE
        if(lpPai->lpCItem)
        {
            if(HR_FAILED(HrSetCertsFromDisplayInfo( lpPai->lpCItem, lpulcPropCount, lppPropArray)))
                bRet = FALSE;
        }
        break;
/***********/
    case propConferencing:
        bRet = bGetConferencingInfo(hDlg, lpPai,lppPropArray, lpulcPropCount);
        break;
/***********/
    case propFamily:
        bRet = bGetFamilyInfo(hDlg, lpPai, idPropFamily, idPropFamilyCount, lppPropArray, lpulcPropCount);
        break;
    }

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }

    return bRet;
}

//$$//////////////////////////////////////////////////////////////////////////
//
// bUpdatePropArray
//
// Updates the prop array info for each sheet that is stored in the globaly accessible
// pointer
//
//////////////////////////////////////////////////////////////////////////////
BOOL bUpdatePropArray(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet)
{
    BOOL bRet = TRUE;
    ULONG cValues = 0;
    LPSPropValue rgPropVals = NULL;
    if (lpPai->ulOperationType != SHOW_ONE_OFF)
    {
        bUpdateOldPropTagArray(lpPai, nPropSheet);

        lpPai->bSomethingChanged = ChangedExtDisplayInfo(lpPai, lpPai->bSomethingChanged);

        if(lpPai->bSomethingChanged)
        {
            bRet = GetDetailsFromUI(   hDlg, lpPai, lpPai->bSomethingChanged, nPropSheet, &rgPropVals, &cValues);
            if(cValues && rgPropVals)
            {
#ifdef DEBUG
                _DebugProperties(rgPropVals, cValues, TEXT("GetDetails from UI\n"));
#endif
                lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, cValues, rgPropVals, NULL);
            }
        }
    }
    FreeBufferAndNull(&rgPropVals);
    return bRet;
}




#define lpPAI ((LPPROP_ARRAY_INFO) pps->lParam)
#define lpbSomethingChanged (&(lpPAI->bSomethingChanged))

/*//$$***********************************************************************
*    FUNCTION: fnPersonalProc
*
*    PURPOSE:  Callback function for handling the PERSONAL property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnPersonalProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        ChangeLocaleBasedTabOrder(hDlg, contactPersonal);
        SetDetailsUI(hDlg,lpPAI, lpPAI->ulOperationType,propPersonal);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), message, wParam, lParam);
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
               g_szWABHelpFileName,
               HELP_WM_HELP,
               (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
               g_szWABHelpFileName,
               HELP_CONTEXTMENU,
               (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case CBN_DROPDOWN:
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME:
                SetComboDNText(hDlg, lpPAI, TRUE, NULL);
                break;
            }
            break;

        case CBN_SELCHANGE:
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME:
                {
                    int nSel = (int) SendDlgItemMessage(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, CB_GETCURSEL, 0, 0);
                    if(nSel != CB_ERR)
                    {
                        int nLen = (int) SendDlgItemMessage(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, CB_GETLBTEXTLEN, (WPARAM)nSel, 0);
                        if(nLen != CB_ERR)
                        {
                            LPTSTR lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen + 1));
                            if(lpsz)
                            {   
                                SendDlgItemMessage(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, CB_GETLBTEXT, (WPARAM)nSel, (LPARAM)lpsz);
                                SetWindowPropertiesTitle(GetParent(hDlg), lpsz);
                                if (lpbSomethingChanged) //some edit box changed - dont care which
                                   (*lpbSomethingChanged) = TRUE;
                                LocalFreeAndNull(&lpsz);
                            }
                        }
                    }
                }
                break;
            }
            break;

        case CBN_EDITCHANGE:
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME:
                if(!(lpPAI->ulFlags & DETAILS_ProgChange) )
                {
                    lpPAI->ulFlags &= ~DETAILS_DNisFMLName;
                    lpPAI->ulFlags &= ~DETAILS_DNisNickName;
                    lpPAI->ulFlags &= ~DETAILS_DNisCompanyName;
                }
                {
                    TCHAR szBuf[MAX_UI_STR];
                    szBuf[0]='\0';
                    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, szBuf, CharSizeOf(szBuf));
                    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                    if (lpbSomethingChanged) //some edit box changed - dont care which
                        (*lpbSomethingChanged) = TRUE;
                }
                break;
            }
            break;

        case EN_CHANGE:
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged) //some edit box changed - dont care which
                (*lpbSomethingChanged) = TRUE;
            switch(LOWORD(wParam))
            {
            case IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL:
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL),TRUE);
                SendMessage(hDlg, DM_SETDEFID, IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL, 0);
                return 0;
                break;

            case IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME:
            case IDC_DETAILS_PERSONAL_EDIT_LASTNAME:
            case IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME:
                // if there is nothing in the display name field (new contact)
                // and we are typing here, update the display name
                //TCHAR szBuf[2];
                //int nText = GetWindowText(lpPAI->hWndDisplayNameField, szBuf, CharSizeOf(szBuf));
                if(lpPAI->ulFlags & DETAILS_DNisFMLName)// || !nText)
                {
                    lpPAI->ulFlags |= DETAILS_ProgChange;
                    SetDetailsWindowTitle(hDlg, TRUE);
                    lpPAI->ulFlags &= ~DETAILS_ProgChange;
                }

                // [PaulHi] 4/8/99
                // If the text in the edit box was deleted then also delete the corresponding
                // Ruby field text
                if(lpPAI->ulFlags & DETAILS_UseRubyPersonal)
                {
                    HWND    hWndEdit = GetDlgItem(hDlg, LOWORD(wParam));
                    HWND    hWndRuby = NULL;
                    WCHAR   wszTemp[EDIT_LEN];

                    Assert(hWndEdit);

                    GetWindowText(hWndEdit, wszTemp, EDIT_LEN);
                    if (*wszTemp == '\0')
                    {
                        // Clear either the first or last name ruby field, depending on which 
                        // edit control this is.
                        switch (LOWORD(wParam))
                        {
                        case IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME:
                            hWndRuby = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST);
                            break;

                        case IDC_DETAILS_PERSONAL_EDIT_LASTNAME:
                            hWndRuby = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST);
                            break;

                        default:
                            break;
                        }

                        if (hWndRuby)
                            SetWindowText(hWndRuby, szEmpty);
                    }
                }

                break;

            case IDC_DETAILS_PERSONAL_EDIT_NICKNAME:
                {
                    if(lpPAI->ulFlags & DETAILS_DNisNickName)
                    {
                        TCHAR szBuf[MAX_UI_STR];
                        szBuf[0]='\0';
                        GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_NICKNAME, szBuf, CharSizeOf(szBuf));
                        lpPAI->ulFlags |= DETAILS_ProgChange;
                        SetComboDNText(hDlg, lpPAI, FALSE, szBuf);
                        lpPAI->ulFlags &= ~DETAILS_ProgChange;
                    }
                    else
                        SetComboDNText(hDlg, lpPAI, TRUE, NULL);

                }
                break;


            default:
                break;
            }
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_PERSONAL_BUTTON_RUBY:
            ShowRubyNameEntryDlg(hDlg, lpPAI);
            break;

        case IDC_DETAILS_PERSONAL_CHECK_RICHINFO:
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    SetLVDefaultEmail( hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;
                }

            }
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_EDIT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    HWND hWndEditLabel;
                    int index = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                    SetFocus(hWndLV);
                    hWndEditLabel = ListView_EditLabel(hWndLV, index);
                    // Set Text Limit on this Edit Box
                    SendMessage(hWndEditLabel, EM_LIMITTEXT, EDIT_LEN, 0);
                }

            }
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_REMOVE:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);
                if(ListView_GetSelectedCount(hWndLV)>=1)
                {
                    BOOL bSetNewDefault = FALSE;
                    int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    while(iItemIndex != -1)
                    {
                        BOOL bRet = FALSE;
                        bRet = DeleteLVEmailItem(hWndLV,iItemIndex);
                        if (!bSetNewDefault)
                            bSetNewDefault = bRet;
                        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    }

                    if (bSetNewDefault && (ListView_GetItemCount(hWndLV) > 0))
                        SetLVDefaultEmail(hWndLV, 0);

                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;

                    if (ListView_GetItemCount(hWndLV) <= 0)
                    {
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),FALSE);
                        SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
                        return FALSE;
                    }
                    else
                    {
                        //make sure something is selected
                        if(ListView_GetSelectedCount(hWndLV) <= 0)
                            LVSelectItem(hWndLV,0);
                    }
                }

            }
            break;

        case IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL:
            AddNewEmailEntry(hDlg,FALSE);
            return FALSE;
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillPersonalDetails(hDlg, lpPAI, propPersonal, lpbSomethingChanged);
            if(lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                // Since items to this list view can be added from certs and conf panes,
                // update this everytime the focus somes back to us
                if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST)) > 0)
                {
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),TRUE);
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),TRUE);
                }
            }
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                // check if there is some pending email entry
                if(IDCANCEL == AddNewEmailEntry(hDlg,TRUE))
                {
                    //abort this ok
                    SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            bUpdatePropArray(hDlg, lpPAI, propPersonal);
            FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),LV_EMAIL);
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                int CtlID = 0; //used to determine which required field in the UI has not been set
                ULONG ulcPropCount = 0;
                if(!bVerifyRequiredData(hDlg, lpPAI, propPersonal, &CtlID))
                {
                    SetFocus(GetDlgItem(hDlg,CtlID));
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            //bUpdatePropArray(hDlg, lpPAI, propPersonal);
            //FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),LV_EMAIL);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if(lpPAI->ulFlags & DETAILS_EditingEmail) //cancel any email editing else it faults #30235
            {
                ListView_EditLabel(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), -1);
                lpPAI->ulFlags &= ~DETAILS_EditingEmail;
            }
            FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),LV_EMAIL);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;

        case LVN_BEGINLABELEDITA:
        case LVN_BEGINLABELEDITW:
            {
                // We are editing a email address in teh list box
                // We need to get:
                //      item index number
                //      item lParam
                //      edit box hWnd
                // and replace the text with the actual email address
                HWND hWndLV = ((NMHDR FAR *)lParam)->hwndFrom;
                LV_ITEM lvi = ((LV_DISPINFO FAR *) lParam)->item;
                if (lvi.iItem >= 0)
                {
                    HWND hWndLVEdit = NULL;
                    LPEMAIL_ITEM lpEItem = NULL;
                    if (lvi.mask & LVIF_PARAM)
                    {
                        lpEItem = (LPEMAIL_ITEM) lvi.lParam;
                    }
                    else
                    {
                        lvi.mask |= LVIF_PARAM;
                        if (ListView_GetItem(hWndLV, &lvi))
                            lpEItem = (LPEMAIL_ITEM) lvi.lParam;
                    }
                    if (!lpEItem)
                        return TRUE; //prevents editing

                    hWndLVEdit = ListView_GetEditControl(hWndLV);

                    if (!hWndLVEdit)
                        return TRUE;

                    lpPAI->ulFlags |= DETAILS_EditingEmail;

                    SendMessage(hWndLVEdit, WM_SETTEXT, 0, (LPARAM) lpEItem->szEmailAddress);//lpText);

                    return FALSE;
                }

            }
            return TRUE;
            break;

        case LVN_ENDLABELEDITA:
        case LVN_ENDLABELEDITW:
            {
                // We get the text from the edit box and put it in the item data
                BOOL bRet = FALSE;
                HWND hWndLV = ((NMHDR FAR *)lParam)->hwndFrom;
                LV_ITEM lvi = ((LV_DISPINFO FAR *) lParam)->item;
                LPWSTR lpW = NULL;
                LPSTR lpA = NULL;
                if(!g_bRunningOnNT) //on Win9x we will get an LV_ITEMA, not a LV_ITEMW
                {
                    lpA = (LPSTR)lvi.pszText;
                    lpW = ConvertAtoW(lpA);
                    lvi.pszText = lpW;
                }
                if ((lvi.iItem >= 0) && lvi.pszText && (lstrlen(lvi.pszText)))
                {
                    LV_ITEM lviActual = {0};
                    LPEMAIL_ITEM lpEItem = NULL;
                    BOOL bSetDefault = FALSE;
                    LPTSTR lpText = lvi.pszText;
                    LPTSTR lpszEmailAddress = NULL; 
                    if(!IsInternetAddress(lpText, &lpszEmailAddress))
                    {
                        if(IDNO == ShowMessageBox(GetParent(hDlg), idsInvalidInternetAddress, MB_ICONEXCLAMATION | MB_YESNO))
                        {
                            bRet = TRUE;
                            goto endN;
                        }
                    }

                    // bobn, Raid 87496, IsInternetAddress can correctly leave lpszEmailAddress NULL
                    // if it returns false.  If the user said to use it, we need to set it accordingly.
                    if(!lpszEmailAddress)
                        lpszEmailAddress = lpText;

                    lviActual.mask = LVIF_PARAM | LVIF_TEXT;
                    lviActual.iItem = lvi.iItem;

                    if (ListView_GetItem(hWndLV, &lviActual))
                        lpEItem = (LPEMAIL_ITEM) lviActual.lParam;

                    if (!lpEItem)
                    {
                        bRet = TRUE;
                        goto endN;
                    }

                    StrCpyN(lpEItem->szEmailAddress, lpszEmailAddress, ARRAYSIZE(lpEItem->szEmailAddress));
                    StrCpyN(lpEItem->szDisplayText, lpszEmailAddress, ARRAYSIZE(lpEItem->szDisplayText));
                    lviActual.pszText = lpszEmailAddress;

                    // Throw away any display name that may have been entered here.

                    bSetDefault = lpEItem->bIsDefault;
                    lpEItem->bIsDefault = FALSE; //this will be set again in SetLVDefaultEmail function

                    ListView_SetItem(hWndLV, &lviActual);
                    if (bSetDefault)
                        SetLVDefaultEmail(hWndLV, lvi.iItem);

                    lpPAI->ulFlags &= ~DETAILS_EditingEmail;

                    bRet = FALSE;
                }
endN:
                LocalFreeAndNull(&lpW);
                if(!g_bRunningOnNT)
                    ((LV_DISPINFO FAR *) lParam)->item.pszText = (LPWSTR)lpA; // reset it as we found it
                return bRet;
            }
            return TRUE;
            break;

        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_PERSONAL_LIST:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    if (ListView_GetSelectedCount(pNm->hdr.hwndFrom) == 1)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        SetLVDefaultEmail(pNm->hdr.hwndFrom, iItemIndex);
                        if (lpbSomethingChanged)
                            (*lpbSomethingChanged) = TRUE;
                    }
                }
                break;
            }
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DETAILS_PERSONAL_LIST:
                {
		            NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
		            if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		            {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			            return TRUE;
		            }
		            else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
		            {
                        LPEMAIL_ITEM lpEItem = (LPEMAIL_ITEM) pnmcd->lItemlParam;

                        if (lpEItem)
                        {
			                if(lpEItem->bIsDefault)
			                {
				                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
				                return TRUE;
			                }
#ifdef WIN16 // Set font
                            else
                            {
                                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIcon));
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
                                return TRUE;
                            }
#endif
                        }
		            }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }
                break;
	        }
            break;

        }
        break; //WM_NOTIFY

    default:
#ifndef WIN16 // WIN16 doesn't support MSWheel.
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST), message, wParam, lParam);
        }
#endif
        break;

    } //switch


    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnHomeProc
*
*    PURPOSE:  Callback function for handling the HOME property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnHomeProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propHome);
        ChangeLocaleBasedTabOrder(hDlg, contactHome);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
               g_szWABHelpFileName,
               HELP_WM_HELP,
               (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND)wParam,
               g_szWABHelpFileName,
               HELP_CONTEXTMENU,
               (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        {
            int nCmd = GET_WM_COMMAND_ID(wParam, lParam);
            switch(nCmd)
            {
            case IDC_DETAILS_HOME_CHECK_DEFAULTADDRESS:
                if (lpbSomethingChanged)
                    (*lpbSomethingChanged) = TRUE;
                lpPAI->ulFlags |= DETAILS_DefHomeChanged;
                break;
            case IDCANCEL:
                // This is a windows bug that prevents ESC canceling prop sheets
                // which have MultiLine Edit boxes KB: Q130765
                SendMessage(GetParent(hDlg),message,wParam,lParam);
                break;
            case IDC_DETAILS_HOME_BUTTON_MAP:
                bUpdatePropArray(hDlg, lpPAI, propHome); // update the props from the fields onto the prop-object
                ShowExpediaMAP(hDlg, lpPAI->lpPropObj, TRUE);
                break;

            case IDC_DETAILS_HOME_BUTTON_URL:
                ShowURL(hDlg, IDC_DETAILS_HOME_EDIT_URL,NULL);
                break;
            }
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillHomeBusinessNotesDetailsUI(hDlg, lpPAI, propHome, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propHome);
            lpPAI->ulFlags &= ~DETAILS_DefHomeChanged; //reset flag
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propHome);
            // in case any of the extended props changed, we need to mark this flag so we wont lose data
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}




/*//$$***********************************************************************
*    FUNCTION: fnBusinessProc
*
*    PURPOSE:  Callback function for handling the BUSINESS property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnBusinessProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        ChangeLocaleBasedTabOrder(hDlg, contactBusiness);
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propBusiness);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
//        (*lpbSomethingChanged) = FALSE;
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_BUSINESS_CHECK_DEFAULTADDRESS:
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            lpPAI->ulFlags |= DETAILS_DefBusChanged;
            break;
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_DETAILS_BUSINESS_BUTTON_MAP:
            bUpdatePropArray(hDlg, lpPAI, propBusiness); // update the props from the fields onto the prop-object
            ShowExpediaMAP(hDlg, lpPAI->lpPropObj, FALSE);
            break;

        case IDC_DETAILS_BUSINESS_BUTTON_URL:
            ShowURL(hDlg, IDC_DETAILS_BUSINESS_EDIT_URL,NULL);
            break;
        
        case IDC_DETAILS_BUSINESS_EDIT_COMPANY:
            if(lpPAI->ulFlags & DETAILS_DNisCompanyName)
            {
                TCHAR szBuf[MAX_UI_STR];
                szBuf[0]='\0';
                GetDlgItemText(hDlg, IDC_DETAILS_BUSINESS_EDIT_COMPANY, szBuf, CharSizeOf(szBuf));
                SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                lpPAI->ulFlags |= DETAILS_ProgChange;
                SetWindowText(lpPAI->hWndDisplayNameField, szBuf);
                lpPAI->ulFlags &= ~DETAILS_ProgChange;
            }
            break;
        }
        break;



    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillHomeBusinessNotesDetailsUI(hDlg, lpPAI, propBusiness, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propBusiness);
            lpPAI->ulFlags &= ~DETAILS_DefBusChanged;
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propBusiness);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}


/*//$$***********************************************************************
*    FUNCTION: fnNotesProc
*
*    PURPOSE:  Callback function for handling the NOTES property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnNotesProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propNotes);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
//        (*lpbSomethingChanged) = FALSE;
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillHomeBusinessNotesDetailsUI(hDlg, lpPAI, propNotes, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propNotes);
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propNotes);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}

/*//$$***********************************************************************
*    FUNCTION: fnCertProc
*
*    PURPOSE:  Callback function for handling the Certificates property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnCertProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propCert);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam, lParam))
        {
        case CBN_SELCHANGE:
            UpdateCertListView(hDlg, lpPAI);
            break;

        }
        switch(LOWORD(wParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_DETAILS_CERT_BUTTON_PROPERTIES:
            {
            ShowCertProps(hDlg, GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST), NULL);
            }
            break;

        case IDC_DETAILS_CERT_BUTTON_SETDEFAULT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    SetLVDefaultCert( hWndLV, ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED));
                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;
                }
                else if(ListView_GetSelectedCount(hWndLV) <= 0)
                {
                    ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION | MB_OK);
                }

            }
            break;

        case IDC_DETAILS_CERT_BUTTON_REMOVE:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
                if(ListView_GetSelectedCount(hWndLV)>=1)
                {
                    BOOL bSetNewDefault = FALSE;
                    int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    while(iItemIndex != -1)
                    {
                        BOOL bRet = FALSE;
//                        KillTrustInSleazyFashion(hWndLV, iItemIndex);
                        bRet = DeleteLVCertItem(hWndLV,iItemIndex, lpPAI);
                        if (!bSetNewDefault)
                            bSetNewDefault = bRet;

                        iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    }

                    if (bSetNewDefault && (ListView_GetItemCount(hWndLV) > 0))
                        SetLVDefaultCert(hWndLV, 0);

                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;

                    if (ListView_GetItemCount(hWndLV) <= 0)
                    {
                        SetFocus(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_IMPORT));
                        EnableWindow(hWndLV,FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_REMOVE),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_SETDEFAULT),FALSE);
                        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),FALSE);
                        return FALSE;
                    }
                    else
                    {
                        //make sure something is selected
                        if(ListView_GetSelectedCount(hWndLV) <= 0)
                            LVSelectItem(hWndLV,0);
                    }
                }
                else
                {
                    ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION | MB_OK);
                }

            }
            break;

        case IDC_DETAILS_CERT_BUTTON_IMPORT:
            if(ImportCert(hDlg, lpPAI))
            {
                if (lpbSomethingChanged)
                    (*lpbSomethingChanged) = TRUE;
            }
            break;

        case IDC_DETAILS_CERT_BUTTON_EXPORT:
            ExportCert(hDlg);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillCertTridentConfDetailsUI(hDlg, lpPAI, propCert, lpbSomethingChanged);
            //FillCertComboWithEmailAddresses(hDlg, lpPAI, NULL);
            //UpdateCertListView(hDlg, lpPAI);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propCert);
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST));
            //lpPAI->lpCItem = NULL;
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propCert);
            //FreeLVParams(GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST),LV_CERT);
            FreeCertList(&(lpPAI->lpCItem));
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            FreeCertList(&(lpPAI->lpCItem));
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;


        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_CERT_LIST:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    if (ListView_GetSelectedCount(pNm->hdr.hwndFrom) == 1)
                    {
                        int iItemIndex = ListView_GetNextItem(pNm->hdr.hwndFrom,-1,LVNI_SELECTED);
                        SetLVDefaultCert(pNm->hdr.hwndFrom, iItemIndex);
                        if (lpbSomethingChanged)
                            (*lpbSomethingChanged) = TRUE;
                    }
                }
                break;
            }
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DETAILS_CERT_LIST:
                {
		            NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
		            if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		            {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			            return TRUE;
		            }
		            else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
		            {
                        LPCERT_ITEM lpItem = (LPCERT_ITEM) pnmcd->lItemlParam;

                        if (lpItem)
                        {
			                if(lpItem->lpCDI->bIsDefault)
			                {
				                SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
				                return TRUE;
			                }
                        }
		            }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }
                break;
	        }
            break;

        } //WM_NOTIFY

        return TRUE;
    }

    return bRet;

}



/*//$$***********************************************************************
*
*    FUNCTION: HrInitDetlsListView
*
*    PURPOSE:  Initializes the Email Address List View
*
****************************************************************************/
HRESULT HrInitDetlsListView(HWND hWndLV, DWORD dwStyle, int nLVType)
{
    HRESULT hr=hrSuccess;
    LV_COLUMN lvC;               // list view column structure
    DWORD dwLVStyle;
	RECT rc;
	HIMAGELIST hSmall = NULL;
	ULONG nCols=0;
	ULONG index=0;
    int nBmp=0;
    TCHAR sz[MAX_PATH];

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    if(nLVType == LV_EMAIL)
        nBmp = IDB_DEFAULT_EMAIL;
    else if(nLVType == LV_CERT)
        nBmp = IDB_CERT_VALID_INVALID;
    else if(nLVType == LV_KIDS)
        nBmp = IDB_DEFAULT_EMAIL;
    else
        nBmp = 0;

	ListView_SetExtendedListViewStyle(hWndLV,   LVS_EX_FULLROWSELECT);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(( dwLVStyle & LVS_TYPEMASK) != dwStyle)
        SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_TYPEMASK) | dwStyle);


    if(nBmp)
    {
	    hSmall = gpfnImageList_LoadImage( hinstMapiX,
                                        MAKEINTRESOURCE(nBmp),
                                        //(LPCTSTR) ((DWORD) ((WORD) (nBmp))),
                                        S_BITMAP_WIDTH,
                                        0,
                                        RGB_TRANSPARENT,
                                        IMAGE_BITMAP,
                                        0);
	
	    // Associate the image lists with the list view control.
	    ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);
    }

	GetWindowRect(hWndLV,&rc);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column
	lvC.cx = rc.right - rc.left - 20; //TBD
	lvC.pszText = NULL;

    if(nLVType == LV_SERVER)
    {
        lvC.mask |= LVCF_TEXT;
        lvC.cx /= 2;
        LoadString(hinstMapiX, idsConfServer, sz, CharSizeOf(sz));
        lvC.pszText = sz;
    }

    lvC.iSubItem = 0;

    if (ListView_InsertColumn (hWndLV, 0, &lvC) == -1)
	{
		DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
		hr = E_FAIL;
		goto out;
	}

    // if this is the conferencing server item, add another prop
    if(nLVType == LV_SERVER)
    {
        LoadString(hinstMapiX, idsConfEmail, sz, CharSizeOf(sz));
        lvC.pszText = sz;
        if (ListView_InsertColumn (hWndLV, 1, &lvC) == -1)
	    {
		    DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
		    hr = E_FAIL;
		    goto out;
	    }

    }

out:
    return hr;
}

/*//$$***********************************************************************
*
*    FUNCTION: FreeLVParams
*
*    PURPOSE:  Frees the memory allocated to the ListView item lParams
*
****************************************************************************/
void FreeLVParams(HWND hWndLV, int LVType)
{
    int iItemIndex = ListView_GetItemCount(hWndLV);

    while(iItemIndex > 0)
    {
        if(LVType == LV_EMAIL)
            DeleteLVEmailItem(hWndLV, iItemIndex-1);
        else if(LVType == LV_CERT)
            DeleteLVCertItem(hWndLV, iItemIndex-1, NULL);

        iItemIndex = ListView_GetItemCount(hWndLV);
    }


    return;
}


//$$
BOOL DeleteLVEmailItem(HWND hWndLV, int iItemIndex)
{
    LV_ITEM lvi;
    LPEMAIL_ITEM lpEItem;
    BOOL bDeletedDefault = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iItemIndex;

    ListView_GetItem(hWndLV, &lvi);
    lpEItem = (LPEMAIL_ITEM) lvi.lParam;

    if (lpEItem->bIsDefault)
        bDeletedDefault = TRUE;

    LocalFreeAndNull(&lpEItem);

    ListView_DeleteItem(hWndLV, lvi.iItem);

    return bDeletedDefault;

}


///$$/////////////////////////////////////////////////////////////////////////
//
// AddLVEmailItem - Adds an email address to the personal tab list view
//
// lpszAddrType can be NULL in which case a default one of type SMTP will be used
//
//////////////////////////////////////////////////////////////////////////////
void AddLVEmailItem(HWND    hWndLV,
                    LPTSTR  lpszEmailAddress,
                    LPTSTR  lpszAddrType)
{
    LV_ITEM lvi = {0};
    TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];
    ULONG nLen;
    LPEMAIL_ITEM lpEItem = NULL;

    if (!lpszEmailAddress)
        goto out;

    lpEItem = LocalAlloc(LMEM_ZEROINIT, sizeof(EMAIL_ITEM));
    if (!lpEItem)
    {
        DebugPrintError(( TEXT("AddLVEmailItem: Out of Memory\n")));
        goto out;
    }

    lpEItem->bIsDefault = FALSE;

    nLen = lstrlen(lpszEmailAddress) + 1;
    if (nLen > EDIT_LEN)
    {
        ULONG iLen = TruncatePos(lpszEmailAddress, EDIT_LEN - 1);
        CopyMemory(lpEItem->szEmailAddress,lpszEmailAddress,sizeof(TCHAR)*iLen);
        lpEItem->szEmailAddress[iLen] = '\0';
    }
    else
    {
        StrCpyN(lpEItem->szEmailAddress,lpszEmailAddress, ARRAYSIZE(lpEItem->szEmailAddress));
    }

    StrCpyN(lpEItem->szDisplayText,lpEItem->szEmailAddress, ARRAYSIZE(lpEItem->szDisplayText));

    if(!lpszAddrType)
    {
        StrCpyN(szBuf, szSMTP, ARRAYSIZE(szBuf));
        lpszAddrType = szBuf;
    }

    nLen = lstrlen(lpszAddrType) + 1;
    if (nLen > EDIT_LEN)
    {
        ULONG iLen = TruncatePos(lpszAddrType, EDIT_LEN - 1);
        CopyMemory(lpEItem->szAddrType,lpszAddrType,sizeof(TCHAR)*iLen);
        lpEItem->szAddrType[iLen] = '\0';
    }
    else
    {
        StrCpyN(lpEItem->szAddrType,lpszAddrType,ARRAYSIZE(lpEItem->szAddrType));
    }

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.pszText = lpEItem->szDisplayText;
    lvi.cchTextMax = MAX_UI_STR;
    lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;
    lvi.iImage = imgNotDefaultEmail;
    lvi.lParam = (LPARAM) lpEItem;

    ListView_InsertItem(hWndLV, &lvi);

    if (ListView_GetItemCount(hWndLV) == 1)
    {
        // only one item in here .. we will take the liberty of making it the
        // default one ...
        SetLVDefaultEmail(hWndLV, 0);
    }

out:
    return;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// SetLVDefaultEmail - Makes an email entry the default one ...
//
//////////////////////////////////////////////////////////////////////////////
void SetLVDefaultEmail( HWND hWndLV,
                        int iItemIndex)
{
    int nCount = ListView_GetItemCount(hWndLV);
    int i;
    LPEMAIL_ITEM lpEItem = NULL;
    TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];

    if (iItemIndex >= nCount)
        goto out;

    for(i=0; i<nCount; i++)
    {
        // At amy given point of time one and only one entry in the
        // list view is the default one ...
        // So we want to reset the previous default and set the new one
        //
        LV_ITEM lvi = {0};
        lvi.iItem = i;
        lvi.mask = LVIF_PARAM;
        if(!ListView_GetItem(hWndLV, &lvi))
            goto out;
        lpEItem = (LPEMAIL_ITEM) lvi.lParam;
        if (lpEItem->bIsDefault)
        {
            // This was the default entry - if its the same one we are setting
            // do nothing ...
            if (i == iItemIndex)
                goto out;

            // else reset this entry ...
            lpEItem->bIsDefault = FALSE;
            lvi.iImage = imgNotDefaultEmail;
            lvi.pszText = lpEItem->szEmailAddress;
            lvi.mask = LVIF_PARAM | LVIF_IMAGE | LVIF_TEXT;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            ListView_SetItem(hWndLV, &lvi);
        }
        if (iItemIndex == i)
        {
            //This is the item we want to modify ..
            lpEItem->bIsDefault = TRUE;
            lvi.iImage = imgDefaultEmail;

            StrCpyN(lpEItem->szDisplayText,lpEItem->szEmailAddress,ARRAYSIZE(lpEItem->szDisplayText));
            LoadString(hinstMapiX, idsDefaultEmail, szBuf, CharSizeOf(szBuf));
            StrCatBuff(lpEItem->szDisplayText, TEXT("  "), ARRAYSIZE(lpEItem->szDisplayText));
            StrCatBuff(lpEItem->szDisplayText, szBuf, ARRAYSIZE(lpEItem->szDisplayText));

            lvi.pszText = lpEItem->szDisplayText;
            lvi.mask = LVIF_PARAM | LVIF_IMAGE | LVIF_TEXT;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            ListView_SetItem(hWndLV, &lvi);
        }
    }

    LVSelectItem(hWndLV, iItemIndex);

out:
    return;
}

#ifdef WIN16 // Enable DDE to communicate IE.
#include <ddeml.h>

static char cszIEAppName[] = "IEXPLORE";
static char cszIEDDEOpenURL[] = "WWW_OpenURL";
static char cszIEDDEActivate[] = "WWW_Activate";

static char cszIEIniFile[] = "iexplore.ini";
static char cszIEIniSectMain[] = "Main";
static char cszIEIniKeyStart[] = "Home Page";
static char cszIEIniKeySearch[] = "Search Page";
static char cszIEReadNews[] = "news:*";

static char cszIEBinName[] = "iexplore.exe";
static char cszIERegHtm[] = ".htm";
static char cszRegShellOpen[] = "shell\\open\\command";

static HDDEDATA CALLBACK  DdeCallback( UINT uType, UINT uFmt, HCONV hConv,
          HSZ hSz1, HSZ hSz2, HDDEDATA hData, DWORD dwData1, DWORD dwData2 )
{
   return( (HDDEDATA)NULL );
}

#define TIME_WAIT_DDE   10000   // waiting for 10 sec, and if doesn't return,
                                // assumes News is configured correctly.

void RunBrowser(LPCSTR cszURL, BOOL bCheckRet )
{
   if ( GetModuleHandle( cszIEBinName ) == NULL )
   {
//
// FIND & RUN IEXPLORE
//
// Try to find the browser in the Mail's directory
      char  szPath[_MAX_PATH*2+1];
      char  *pPtr, *pSlash = NULL;;
      HKEY  hKey;
      LONG  cbPath;
      char  szRegPath[_MAX_PATH];

      GetModuleFileName( hinstMapiXWAB, szPath, _MAX_PATH );
      for ( pPtr = szPath;  *pPtr;  pPtr = AnsiNext( pPtr ) )
         if ( *pPtr == '\\' )
         {
            pSlash = pPtr;
         }
      if ( pSlash != NULL )
      {
         _fstrcpy( pSlash+1, cszIEBinName );
         _fstrcat( szPath, " " );
         _fstrcat( szPath, cszURL );

         if ( WinExec( szPath, SW_SHOWNORMAL ) >= 32 )
         {
            return;
         }
      }

// Try to find system default browser from the registry
      _fstrcpy( szRegPath, cszIERegHtm );
      while ( RegOpenKey( HKEY_CLASSES_ROOT, szRegPath, &hKey ) == ERROR_SUCCESS )
      {
         LONG lReg;
         cbPath = CharSizeOf( szPath );
         lReg = RegQueryValue( hKey, cszRegShellOpen, szPath, &cbPath );
         RegCloseKey( hKey );
         if ( lReg == ERROR_SUCCESS )
         {
            char  *pFmt = _fstrstr( szPath, "%1" );
            if ( pFmt != NULL )
            {
               _fstrcpy( pFmt, cszURL );
               *pFmt = '\0';
            }
            else
            {
               // Can this case happen???
               _fstrcat( szPath, " " );
               _fstrcat( szPath, cszURL );
            }

            if ( WinExec( szPath, SW_SHOWNORMAL ) >= 32 )
            {
               return;
            }
            else
               break;
         }
         else
         {
            cbPath = CharSizeOf( szRegPath );
            if ( RegQueryValue( HKEY_CLASSES_ROOT, szRegPath,
                                szRegPath, &cbPath ) != ERROR_SUCCESS )
               break;
         }
      }
// Insert proper messagebox here
//      MessageBox( IDS_NOT_FOUND_IEXPLORE );
      return;
   }
   else
   {
//
// CALL IEXPLORE DDE
//
      if ((GetWinFlags() & WF_PMODE) != 0 )     // None-Protected Mode
      {
         DWORD  idInst = 0L;
         FARPROC  lpDdeProc = MakeProcInstance( (FARPROC)DdeCallback, hinstMapiXWAB );

         if ( DdeInitialize( &idInst, (PFNCALLBACK)lpDdeProc,
                             APPCMD_CLIENTONLY,
                             0L ) == DMLERR_NO_ERROR )
         {
            HSZ   hszAppName = DdeCreateStringHandle( idInst, cszIEAppName, CP_WINANSI );
            char  szParam[256];
            HSZ   hszParam;
// Activate IE
            HSZ  hszTopic = DdeCreateStringHandle( idInst, cszIEDDEActivate, CP_WINANSI );
            HCONV  hConv = DdeConnect( idInst, hszAppName, hszTopic, (PCONVCONTEXT)NULL );

            DdeFreeStringHandle( idInst, hszTopic );
            if ( hConv != NULL )
            {
               wnsprintf( szParam, ARRAYSIZE(szParam), "0x%lX,0x%lX", 0xFFFFFFFF, 0L );
               hszParam = DdeCreateStringHandle( idInst, szParam, CP_WINANSI );
               DdeClientTransaction( NULL, 0L, hConv, hszParam, CF_TEXT,
                                     XTYP_REQUEST, TIMEOUT_ASYNC, NULL );
               DdeFreeStringHandle( idInst, hszParam );
               DdeDisconnect( hConv );
            }

// Request to open URL
            hszTopic   = DdeCreateStringHandle( idInst, cszIEDDEOpenURL, CP_WINANSI );
            hConv = DdeConnect( idInst, hszAppName, hszTopic, (PCONVCONTEXT)NULL );
            DdeFreeStringHandle( idInst, hszTopic );
            if ( hConv != NULL )
            {
               HSZ hszParam;
               HDDEDATA hDDE;

               wnsprintf( szParam, ARRAYSIZE(szParam), "\"%s\",,0x%lX,0x%lX,,,", cszURL, 0xFFFFFFFF, 0L );
               hszParam = DdeCreateStringHandle( idInst, szParam, CP_WINANSI );
               hDDE = DdeClientTransaction( NULL, 0L, hConv, hszParam,
                                   CF_TEXT, XTYP_REQUEST, TIME_WAIT_DDE, NULL );
               if ( bCheckRet && ( hDDE != NULL ) )
               {
                  long  lRet;
                  DdeGetData( hDDE, &lRet, sizeof( lRet ), 0 );
                  DdeFreeDataHandle( hDDE );
                  if ( lRet == -5L )
                  {
/*
// Insert Error message.
                     CString  strErr, strTmp;
                     strErr.LoadString( IDS_DDE_NEWS_NOT_READY1 );
                     strTmp.LoadString( IDS_DDE_NEWS_NOT_READY2 );
                     strErr += strTmp;
                     MessageBox( strErr, NULL, MB_ICONINFORMATION | MB_OK );
*/
                     ;
                  }
               }
               DdeFreeStringHandle( idInst, hszParam );
               DdeDisconnect( hConv );
            }

            DdeFreeStringHandle( idInst, hszAppName );
            DdeUninitialize( idInst );
         }

         FreeProcInstance( lpDdeProc );
      }
   }
}
#endif // WIN16



//$$/////////////////////////////////////////////////////////////////
//
// Launches explorer with the URL to show it ...
//
/////////////////////////////////////////////////////////////////////
void ShowURL(HWND hWnd, int id, LPTSTR lpURL)
{
    TCHAR szBuf[MAX_EDIT_LEN];
    LPTSTR lp = NULL;

    if(!lpURL)
    {
        //get the text in the dialog
        szBuf[0] = 0;
        GetDlgItemText(hWnd, id, szBuf, CharSizeOf(szBuf));
        TrimSpaces(szBuf);
        //if its blank, exit
        if(!lstrlen(szBuf))
            return;
        lpURL = szBuf;
    }

    // if its just the default prefix, ignore
    if(lstrcmpi(szHTTP, lpURL)!=0)
    {
        if(!bIsHttpPrefix(lpURL))
        {
            ULONG cchSize=lstrlen(lpURL)+lstrlen(szHTTP)+1;
            //append the http:// prefix before shellexecing
            lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
            if (lp)
            {
                StrCpyN(lp, szHTTP, cchSize);
                StrCatBuff(lp, szBuf, cchSize);
            }
        }

        IF_WIN32(ShellExecute(hWnd,  TEXT("open"), (lp ? lp : lpURL), NULL, NULL, SW_SHOWNORMAL);)
        IF_WIN16(RunBrowser((lp ? lp : lpURL), FALSE);) // Need DDE routine to invoke IEXPLORE.

        if(lp)
            LocalFree(lp);
    }
}



//$$/////////////////////////////////////////////////////////////////
//
// Sets the  TEXT("http://") prefix in the URL edit fields if user doesnt
// anything in there ....
//
///////////////////////////////////////////////////////////////////
void SetHTTPPrefix(HWND hDlg, int id)
{
    TCHAR szBuf[MAX_EDIT_LEN];

    // Check to see if anything is filled in ...
    GetDlgItemText(hDlg, id, szBuf, CharSizeOf(szBuf));

    TrimSpaces(szBuf);

    if (lstrlen(szBuf))
        return;

    StrCpyN(szBuf,szHTTP,ARRAYSIZE(szBuf));
    SetDlgItemText(hDlg, id, szBuf);

    return;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// AddNewEmailEntry - Adds text from Email edit box to the list box
//
// bShowCancelButton - lets us specify whether to show a dialog with a cancel
//                  button
//
// returns IDYES, IDNO or IDCANCEL
//
//////////////////////////////////////////////////////////////////////////////
int AddNewEmailEntry(HWND hDlg, BOOL bShowCancelButton)
{
    int nRet = IDYES;
    TCHAR szBuf[EDIT_LEN];
    LPTSTR lpszEmailAddress = szBuf;
    GetDlgItemText( hDlg,
                    IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL,
                    szBuf,
                    CharSizeOf(szBuf));

    TrimSpaces(szBuf);

    if(!lstrlen(szBuf))
        goto out;

    if(!IsInternetAddress(szBuf, &lpszEmailAddress))
    {
        // Check if this is invalid because of high bytes or something else
        // (Need to warn user about entering DBCS email addresses)
        LPTSTR lpsz = szBuf;
        BOOL bHighBits = FALSE;
        while (*lpsz)
        {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (*lpsz >= 0x0080)
            {
                bHighBits = TRUE;
                break;
            }
            lpsz++;
        }

        if(bHighBits)
        {
            ShowMessageBox(GetParent(hDlg), idsInvalidDBCSInternetAddress, MB_ICONEXCLAMATION | MB_OK);
            SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
            goto out;
        }
        else
        {
            // some other casue for error
            int nFlag = (bShowCancelButton ? MB_YESNOCANCEL : MB_YESNO);
            nRet = ShowMessageBox(GetParent(hDlg), idsInvalidInternetAddress, MB_ICONEXCLAMATION | nFlag);
            if(IDYES != nRet)
            {
                SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));
                goto out;
            }
        }
    }

    // Add the text to the list box
    AddLVEmailItem( GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST),
                    lpszEmailAddress,
                    NULL);

    // If there is no display name and there was one specified in the entered address,
    // add a display name.
    if (szBuf != lpszEmailAddress) {    // then there was a DisplayName specified in the entered email address
        TCHAR szBuf2[16];   // big enough to rule out likely leading spaces.  Doesn't have to fit entire DN.

        szBuf2[0] = '\0';
        GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME, szBuf2, CharSizeOf(szBuf2));
        TrimSpaces(szBuf2);
        if (lstrlen(szBuf2) == 0) {
            // No display name, set one
            SetComboDNText(hDlg, NULL, FALSE, szBuf);   // Set the DN
        }
    }


    //Cleanout the edit control
    SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL, szEmpty);

    //Disable the add new button
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_ADDEMAIL),FALSE);

    // enable/disable other buttons
    if(ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST)) > 0)
    {
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),TRUE);
    }

    // Set the focus to the email edit field
    SetFocus(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_EDIT_ADDEMAIL));

    // Set the default id to the OK button
    SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);

    nRet = IDYES;

out:
    return nRet;
}


//$$///////////////////////////////////////////////////////////////
//
//  SetDetailsWindowTitle - creates a display name and sets it in
//  the title
//
///////////////////////////////////////////////////////////////////
void SetDetailsWindowTitle(HWND hDlg, BOOL bModifyDisplayNameField)
{
    TCHAR szFirst[MAX_UI_STR];
    TCHAR szLast[MAX_UI_STR];
    TCHAR szMiddle[MAX_UI_STR];
    TCHAR * szBuf = NULL;//szBuf[MAX_BUF_STR];

    if(!(szBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*MAX_BUF_STR)))
        return;

    szFirst[0] = szMiddle[0] = szLast[0] = '\0';

    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, szFirst, CharSizeOf(szFirst));
    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME, szLast, CharSizeOf(szLast));
    GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME, szMiddle, CharSizeOf(szMiddle));

    szBuf[0]='\0';
    {
        LPTSTR lpszTmp = szBuf;
        SetLocalizedDisplayName(szFirst,
                                szMiddle,
                                szLast,
                                NULL,
                                NULL,
                                (LPTSTR *) &lpszTmp, //&szBuf,
                                MAX_BUF_STR,
                                bDNisByLN,
                                NULL,
                                NULL);
    }

    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);

    if (bModifyDisplayNameField)
    {
        SetComboDNText(hDlg, NULL, FALSE, szBuf);
        //SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_DISPLAYNAME, szBuf);
    }
    LocalFreeAndNull(&szBuf);
}

//$$///////////////////////////////////////////////////////////////
//
//  UpdateCertListView - fills the cert lv with certinfo, based on current
//      listview selection
//
///////////////////////////////////////////////////////////////////
void UpdateCertListView(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    HWND hWndLV = GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST);
    HWND hWndCombo = GetDlgItem(hDlg,IDC_DETAILS_CERT_COMBO);
    TCHAR szEmail[MAX_UI_STR];
    LPCERT_ITEM lpCItem = lpPai->lpCItem;
    int nSel = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    int nCountCerts = 0;
    BOOL * lpbAddCert = NULL;
    BOOL bShowOrphanCerts = FALSE;

    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_REMOVE),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_SETDEFAULT),FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),FALSE);

    *szEmail = '\0';
    if(!GetWindowText(hWndCombo, szEmail, CharSizeOf(szEmail)))
		goto out;

    if(!nCount || !lpCItem || !lstrlen(szEmail))
        goto out;


    nCountCerts = 0;
    while(lpCItem)
    {
        nCountCerts++;
        lpCItem = lpCItem->lpNext;
    }

    if(!nCountCerts)
        goto out;

    // Clear the list view ....
    ListView_DeleteAllItems(hWndLV);

    // we will have this bool array that we can use to mark which cert to
    // add and which not to add
    lpbAddCert = LocalAlloc(LMEM_ZEROINIT, nCountCerts*sizeof(BOOL));

    if(!lpbAddCert)
        goto out;

    // if the selection is in the last item in the list, then we only
    // show orphan certs ..
    // Orphan certs are certs without email addresses or with email addresses
    // that dont match anything in the current contacts properties ...
    //
    if(nSel == nCount - 1)
        bShowOrphanCerts = TRUE;

    lpCItem = lpPai->lpCItem;
    nCountCerts = 0;

    if(!bShowOrphanCerts)
    {
        // we only need to look at the e-mail address of each cert and match it to
        // the currently selected email address
        while(lpCItem)
        {
            if( lpCItem->lpCDI && lpCItem->lpCDI->lpszEmailAddress &&
                lstrlen(lpCItem->lpCDI->lpszEmailAddress ) &&
                !lstrcmpi(szEmail, lpCItem->lpCDI->lpszEmailAddress) )
            {
                lpbAddCert[nCountCerts] = TRUE; // Add this cert
            }

            nCountCerts++;
            lpCItem = lpCItem->lpNext;
        }
    }
    else
    {
        // Scan all the certs and find the ones that dont match anything
        while(lpCItem)
        {
            int i;

            lpbAddCert[nCountCerts] = TRUE; // Add this cert

            for(i=0;i<nCount-1;i++) // nCount = # e-mail addresses + 1
            {
                int nLen = (int)SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM)i, 0);
                if (nLen != CB_ERR)
                {
                    LPTSTR pszEmail = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen + 1));
                    if (pszEmail)
                    {
                        pszEmail[0] = 0;
                        SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM) pszEmail);

                        if( lpCItem->lpCDI && lpCItem->lpCDI->lpszEmailAddress &&
                            lstrlen(lpCItem->lpCDI->lpszEmailAddress ) &&
                            !lstrcmpi(pszEmail, lpCItem->lpCDI->lpszEmailAddress) )
                        {
                            // There is a match
                            lpbAddCert[nCountCerts] = FALSE; // Dont add this cert
                        }
                        LocalFreeAndNull(&pszEmail);
                    }
                }
            }
            nCountCerts++;
            lpCItem = lpCItem->lpNext;
        }
    }


    lpCItem = lpPai->lpCItem;
    nCountCerts = 0;


    while(lpCItem)
    {
        if(lpbAddCert[nCountCerts])
            AddLVCertItem(  hWndLV, lpCItem, TRUE);

        nCountCerts++;
        lpCItem = lpCItem->lpNext;
    }

out:
    if(ListView_GetItemCount(hWndLV)>0)
    {
        if(lpPai->ulOperationType != SHOW_ONE_OFF)
        {
            EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_REMOVE),TRUE);
            EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_SETDEFAULT),TRUE);
        }
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),TRUE);
    }

    if(lpbAddCert)
        LocalFree(lpbAddCert);

    return;

}

//$$
//
// Init the CertItem struct from an existing lpCDI struct
//
//  bImporting - if we are importing a new cert - tests it to see if it can be matched to
//              the current contact and if it can't, prompts user
//
BOOL AddNewCertItem(HWND hDlg, LPCERT_DISPLAY_INFO lpCDI, LPPROP_ARRAY_INFO lpPai, BOOL bImporting)
{
    int nLen = 0;
    BOOL bRet= FALSE;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
    LPCERT_ITEM lpCItem = NULL;
    BOOL bMatchFound = FALSE;

    // 96/12/20 markdu  BUG 13029  Check for duplicates before adding.
    if(bImporting)
    {
        int i, nCount;

        // Go through all the lpCDI structs in the listview elements and
        // see if any is a match with the new item
        nCount = ListView_GetItemCount(hWndLV);
        for(i=0;i<nCount;i++)
        {
            LV_ITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            if (ListView_GetItem(hWndLV, &lvi))
            {
                LPCERT_ITEM lpItem = (LPCERT_ITEM) lvi.lParam;
                if (CertCompareCertificate(X509_ASN_ENCODING, lpItem->lpCDI->pccert->pCertInfo,
                                           lpCDI->pccert->pCertInfo))
                {
                    // This cert is already in the list.  Select it.
                    ShowMessageBox(hDlg, idsCertAlreadyExists,
                                MB_ICONINFORMATION | MB_OK);
                    SetFocus(hWndLV);
                    LVSelectItem(hWndLV, i);
                    bRet = TRUE;
                    // Free lpCDI here or we will leak it ...
                    FreeCertdisplayinfo(lpCDI);
                    goto out;
                }
            }
        }
    }

    if(bImporting && lpCDI->lpszEmailAddress && lstrlen(lpCDI->lpszEmailAddress))
    {
        // Check the e-mail address of this certificate with the ones we already have
        // Warn if we cant find it
        HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_CERT_COMBO);
        TCHAR szEmail[MAX_PATH];
        int i, nCount;
        nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);

        if(nCount > 1)
        {
            // Go thru all the email addresses in the combo box
            for(i= 0;i<nCount -1; i++)
            {
                int nLen;

                nLen = (int)SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM)i, 0);
                if (nLen != CB_ERR)
                {
                    LPTSTR pszEmail = (LPTSTR)LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen + 1));
                    if (pszEmail)
                    {
                        pszEmail[0] = '\0';
                        SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM) pszEmail);
                        if( lpCDI->lpszEmailAddress && lstrlen(pszEmail) &&
                            !lstrcmpi(pszEmail, lpCDI->lpszEmailAddress))
                        {
                            LocalFreeAndNull(&pszEmail);
                            bMatchFound = TRUE;
                            break;
                        }
                        LocalFreeAndNull(&pszEmail);
                    }
                }
            }
        }

        if(!bMatchFound)
        {
            switch(ShowMessageBoxParam(hDlg, idsImportCertNoEmail, MB_ICONEXCLAMATION | MB_YESNOCANCEL,
                    lpCDI->lpszDisplayString, lpCDI->lpszEmailAddress))
            {
            case IDCANCEL: // cancel this import
                bRet = TRUE;
                // Free lpCDI here or we will leak it ...
                FreeCertdisplayinfo(lpCDI);
                goto out;
                break;
            case IDYES: // Add the email address of this contact to the list of email addresses
                HrAddEmailToObj(lpPai, lpCDI->lpszEmailAddress, (LPTSTR)szSMTP);
                FillCertComboWithEmailAddresses(hDlg, lpPai, lpCDI->lpszEmailAddress);
                break;
            case IDNO: // do nothing just add this certificate
                break;
            }
        }
    }

    if( bImporting &&
        (!lpCDI->lpszEmailAddress || !lstrlen(lpCDI->lpszEmailAddress)) )
    {
        FillCertComboWithEmailAddresses(hDlg, lpPai, szEmpty); //szEmpty forces combo to switch to the  TEXT("none") option
    }

    lpCItem = LocalAlloc(LMEM_ZEROINIT, sizeof(CERT_ITEM));

    if (!lpCItem)
        goto out;

    lpCItem->lpCDI = lpCDI;
    lpCItem->pcCert = CertDuplicateCertificateContext(lpCDI->pccert);
    lpCItem->lpPrev = NULL;

    nLen = lstrlen(lpCDI->lpszDisplayString) + 1;
    if (nLen > MAX_PATH)
    {
        ULONG iLen = TruncatePos(lpCDI->lpszDisplayString, MAX_PATH - 1);
        lpCDI->lpszDisplayString[iLen] = '\0';
    }

    StrCpyN(lpCItem->szDisplayText, lpCDI->lpszDisplayString, ARRAYSIZE(lpCItem->szDisplayText));

    lpCItem->lpNext = lpPai->lpCItem;
    if(lpPai->lpCItem)
        lpPai->lpCItem->lpPrev = lpCItem;
    lpPai->lpCItem = lpCItem;

    bRet = TRUE;
out:
    return bRet;

}
//$$///////////////////////////////////////////////////////////////
//
//  SetCertInfoInUI - fills the cert lv with certinfo, if any exists
//
///////////////////////////////////////////////////////////////////
HRESULT HrSetCertInfoInUI(HWND   hDlg,
                     LPSPropValue   lpPropMVCert,
                     LPPROP_ARRAY_INFO lpPai)
{
    HRESULT hr = E_FAIL; 
    LPCERT_DISPLAY_INFO lpCDI = NULL, lpTemp = NULL;

    if(!lpPropMVCert)
        goto out;

    if(!lpPai->lpCItem)
    {
        if(HR_FAILED(HrGetCertsDisplayInfo(hDlg, lpPropMVCert, &lpCDI)))
            goto out;

        if(!lpCDI)
        {
            hr = MAPI_E_NOT_FOUND;
            goto out;
        }
        lpTemp = lpCDI;
        while(lpTemp)
        {

            AddNewCertItem(hDlg, lpTemp, lpPai, FALSE);

            lpTemp = lpTemp->lpNext;
        }
    }


    UpdateCertListView(hDlg, lpPai);

    hr = S_OK; 

out:
    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// AddLVcertItem - adds an item to the certificates list view
//
//
////////////////////////////////////////////////////////////////////////////////////
BOOL AddLVCertItem(HWND hWndLV, LPCERT_ITEM lpCItem, BOOL bCheckForDups)
{
    LV_ITEM lvi = {0};
    ULONG nLen;
    BOOL bRet = FALSE;

    if(!lpCItem)
        goto out;

    // 96/12/20 markdu  BUG 13029  Check for duplicates before adding.
    if (TRUE == bCheckForDups)
    {
        int i, nCount;

        // Go through all the lpCDI structs in the listview elements and
        // see if any is a match with the new item
        nCount = ListView_GetItemCount(hWndLV);
        for(i=0;i<nCount;i++)
        {
            LV_ITEM lvi = {0};
            lvi.mask = LVIF_PARAM;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            if (ListView_GetItem(hWndLV, &lvi))
            {
                LPCERT_ITEM lpItem = (LPCERT_ITEM) lvi.lParam;
                if (CertCompareCertificate(X509_ASN_ENCODING, lpItem->lpCDI->pccert->pCertInfo,
                                           lpCItem->lpCDI->pccert->pCertInfo))
                {
                    // This cert is already in the list.  Select it.
                    SetFocus(hWndLV);
                    LVSelectItem(hWndLV, i);
                    goto out;
                }
            }
        }
    }


    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvi.pszText = lpCItem->lpCDI->bIsDefault ? lpCItem->szDisplayText : lpCItem->lpCDI->lpszDisplayString;
    lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;

    if(!lpCItem->lpCDI->bIsExpired && !lpCItem->lpCDI->bIsRevoked && lpCItem->lpCDI->bIsTrusted)
        lvi.iImage = imgCertValid;
    else
        lvi.iImage = imgCertInvalid;

    lvi.lParam = (LPARAM) lpCItem;

    {
        int nIndex = ListView_InsertItem(hWndLV, &lvi);
        if (ListView_GetItemCount(hWndLV) == 1)
        {
            // only one item in here .. we will take the liberty of making it the
            // default one ...
            SetLVDefaultCert(hWndLV, 0);
        }
        else if(lpCItem->lpCDI->bIsDefault)
        {
            SetLVDefaultCert(hWndLV, nIndex);
        }

        // Select the cert we just added.
        SetFocus(hWndLV);
        LVSelectItem(hWndLV, nIndex);
    }
    bRet = TRUE;

out:
    return TRUE;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// SetLVDefaultCert - Makes an cert entry the default one ...
//
//////////////////////////////////////////////////////////////////////////////
void SetLVDefaultCert( HWND hWndLV,
                        int iItemIndex)
{
    int nCount = ListView_GetItemCount(hWndLV);
    int i;
    LPCERT_ITEM lpItem = NULL;
    TCHAR szBuf[MAX_DISPLAY_NAME_LENGTH];

    if (iItemIndex >= nCount)
        goto out;

    for(i=0; i<nCount; i++)
    {
        // At amy given point of time one and only one entry in the
        // list view is the default one ...
        // So we want to reset the previous default and set the new one
        //
        LV_ITEM lvi = {0};
        lvi.iItem = i;
        lvi.mask = LVIF_PARAM;
        if(!ListView_GetItem(hWndLV, &lvi))
            goto out;
        lpItem = (LPCERT_ITEM) lvi.lParam;
        if (lpItem->lpCDI->bIsDefault)
        {
            // This was the default entry - if its
            // not the same one as the one we are setting,
            // reset the default
            if (i != iItemIndex)
            {
                // else reset this entry ...
                lpItem->lpCDI->bIsDefault = FALSE;
                lvi.pszText = lpItem->lpCDI->lpszDisplayString;
                lvi.mask = LVIF_PARAM | LVIF_TEXT;
                lvi.iItem = i;
                lvi.iSubItem = 0;
                ListView_SetItem(hWndLV, &lvi);
            }
        }
        if (iItemIndex == i)
        {
            //This is the item we want to modify ..
            lpItem->lpCDI->bIsDefault = TRUE;
            StrCpyN(lpItem->szDisplayText,lpItem->lpCDI->lpszDisplayString, ARRAYSIZE(lpItem->szDisplayText));
            LoadString(hinstMapiX, idsDefaultCert, szBuf, CharSizeOf(szBuf));
            StrCatBuff(lpItem->szDisplayText, szBuf, ARRAYSIZE(lpItem->szDisplayText));

            lvi.pszText = lpItem->szDisplayText;
            lvi.mask = LVIF_PARAM | LVIF_TEXT;
            lvi.iItem = i;
            lvi.iSubItem = 0;
            ListView_SetItem(hWndLV, &lvi);
        }
    }

    LVSelectItem(hWndLV, iItemIndex);

out:
    return;
}

extern HRESULT HrGetTrustState(HWND hwndParent, PCCERT_CONTEXT pcCert, DWORD *pdwTrust);

//$$/////////////////////////////////////////////////////////////////////////
//
// ShowCertProps - Shows props for a cert
//
//////////////////////////////////////////////////////////////////////////////
void ShowCertProps(HWND hDlg, HWND hWndLV, BOOL * lpBool)
{
    DWORD dwTrust = 0;
    int nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
    LV_ITEM lvi;
    LPCERT_ITEM lpItem;
    BOOL bDeletedDefault = FALSE;
    BOOL bOldTrusted;
    LPSTR   oidPurpose = szOID_PKIX_KP_EMAIL_PROTECTION;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = nIndex;

    if(ListView_GetItem(hWndLV, &lvi))
    {
        lpItem = (LPCERT_ITEM) lvi.lParam;
        if(lpItem)
        {
            if(lpItem->pcCert == NULL)
            {
                Assert(lpItem->pcCert);
                return;
            }

            // Only one thing is user changable in the cert UI - the trust info
            // So we will track that piece of info
            // User can change dwTrust and consequently, bIsTrusted can also change
            // which needs to be uppdated in the UI check mark

            bOldTrusted = lpItem->lpCDI->bIsTrusted;

            {
                CERT_VIEWPROPERTIES_STRUCT_A cvps = {0};

                cvps.dwSize = sizeof(CERT_VIEWPROPERTIES_STRUCT);
                cvps.hwndParent = hDlg;
                cvps.hInstance = hinstMapiX;
                cvps.pCertContext = lpItem->pcCert;
                cvps.arrayPurposes = &oidPurpose;
                cvps.cArrayPurposes = 1;
                cvps.nStartPage = 1; // go directly to details page
                cvps.dwFlags = CM_NO_NAMECHANGE;

                CertViewPropertiesA(&cvps);
            }

            // Determine if the trust changed or not
            if (FAILED(HrGetTrustState(hDlg, lpItem->pcCert, &(lpItem->lpCDI->dwTrust))))
            {
                lpItem->lpCDI->dwTrust = CERT_VALIDITY_NO_TRUST_DATA;
            }

            if (0 == lpItem->lpCDI->dwTrust)
                lpItem->lpCDI->bIsTrusted = TRUE;
            else
                lpItem->lpCDI->bIsTrusted = FALSE;

            //N2 if the trust changes, we need to check trust again...
            if (bOldTrusted != lpItem->lpCDI->bIsTrusted)
            {
                LV_ITEM lvi = {0};

                // Update the displayed graphic next to the cert.
                lvi.mask = LVIF_IMAGE;
                lvi.iItem = nIndex;
                lvi.iSubItem = 0;
                if(!lpItem->lpCDI->bIsExpired && !lpItem->lpCDI->bIsRevoked && lpItem->lpCDI->bIsTrusted)
                    lvi.iImage = imgCertValid;
                else
                    lvi.iImage = imgCertInvalid;
                ListView_SetItem(hWndLV, &lvi);
            }
            if(lpBool)
                *lpBool = TRUE;
        }
    }
    else if(ListView_GetSelectedCount(hWndLV) <= 0)
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_ICONEXCLAMATION | MB_OK);
    }

    return;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// DeleteLVCertItem - Makes an cert entry the default one ...
//
//////////////////////////////////////////////////////////////////////////////
BOOL DeleteLVCertItem(HWND hWndLV, int iItemIndex, LPPROP_ARRAY_INFO lpPai)
{
    LV_ITEM lvi;
    LPCERT_ITEM lpItem;
    BOOL bDeletedDefault = FALSE;

    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = iItemIndex;

    if(ListView_GetItem(hWndLV, &lvi))
    {
        lpItem = (LPCERT_ITEM) lvi.lParam;

        if(lpItem)
        {
            if (lpItem->lpCDI->bIsDefault)
                bDeletedDefault = TRUE;

            if(lpItem->lpCDI->lpNext)
                lpItem->lpCDI->lpNext->lpPrev = lpItem->lpCDI->lpPrev;

            if(lpItem->lpCDI->lpPrev)
                lpItem->lpCDI->lpPrev->lpNext = lpItem->lpCDI->lpNext;

            FreeCertdisplayinfo(lpItem->lpCDI);

            if (lpItem->pcCert)
                CertFreeCertificateContext(lpItem->pcCert);

            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;

            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;

            if(lpPai && lpPai->lpCItem == lpItem)
                lpPai->lpCItem = lpItem->lpNext;

            LocalFree(lpItem);

            ListView_DeleteItem(hWndLV, lvi.iItem);
        }
    }
    return bDeletedDefault;
}


const TCHAR szCertFilter[] =  TEXT("*.p7c;*.p7b;*.cer");
const TCHAR szAllFilter[] =  TEXT("*.*");
const TCHAR szCERFilter[] =  TEXT("*.cer");
const TCHAR szCERExt[] =  TEXT("ext");


//$$////////////////////////////////////////////////////////////////////////
////
//// ImportCert - imports a cert from file and then adds it into the list view
////
////
////////////////////////////////////////////////////////////////////////////
BOOL ImportCert(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_UI_STR];

    // we need to get a file name after poping the file open dialog
    // Then we need to decode it
    // Then we need to add it to the list view

    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_CERT_FILE_SPEC,
                                        szCertFilter,
                                        IDS_ALL_FILE_SPEC,
                                        szAllFilter,
                                        0,
                                        NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CharSizeOf(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    LoadString(hinstMapiX, idsCertImportTitle, szBuf, CharSizeOf(szBuf));
    ofn.lpstrTitle = szBuf;
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL; 
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;


    if (GetOpenFileName(&ofn))
    {
        LPCERT_DISPLAY_INFO lpCDI = NULL;
        LPCERT_ITEM lpCItem = NULL;
        if(!HR_FAILED(HrImportCertFromFile( szFileName,
				                            &lpCDI)))
        {
            if(!AddNewCertItem(hDlg, lpCDI, lpPai, TRUE))
                goto out;

            UpdateCertListView(hDlg, lpPai);
        }
        else
        {
            ShowMessageBoxParam(hDlg, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFileName);
            goto out;
        }
    }
    else
        goto out;


    bRet = TRUE;

out:
    LocalFreeAndNull(&lpFilter);
    return bRet;
}


//$$////////////////////////////////////////////////////////////////////////
////
//// ExportCert - exports a cert to a file
////
////
////////////////////////////////////////////////////////////////////////////
BOOL ExportCert(HWND hDlg)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[MAX_UI_STR];
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);

    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(IDS_CER_FILE_SPEC,
                                        szCERFilter,
                                        IDS_ALL_FILE_SPEC,
                                        szAllFilter,
                                        0,
                                        NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");


    // we need to get a file name after poping the file open dialog
    // Then we need to save the cert to the file name

    // First make sure only one entry is selected for exporting
    if(ListView_GetSelectedCount(hWndLV) > 1)
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_ACTION, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }
    else if (ListView_GetSelectedCount(hWndLV) <= 0)
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = CharSizeOf(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    LoadString(hinstMapiX, idsCertExportTitle, szBuf, CharSizeOf(szBuf));
    ofn.lpstrTitle = szBuf;
    ofn.Flags = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = szCERExt;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;


    if (GetSaveFileName(&ofn))
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        lvi.iSubItem = 0;
        if (ListView_GetItem(hWndLV, &lvi))
        {
            LPCERT_ITEM lpItem = (LPCERT_ITEM) lvi.lParam;
            HrExportCertToFile( szFileName, lpItem->lpCDI->pccert, NULL, NULL, FALSE);
        }
        else
            goto out;
    }
    else
        goto out;


    bRet = TRUE;

out:
    return bRet;
}

//$$////////////////////////////////////////////////////////////////////////////////
//
//  Sets the display name in the Combo box
//
//  hDlg - handle of Personal Pane
//  lppai - proparrayinfo struct
//  bAddAll - determines whether to fill the combo with all the values or not
//  szTxt - txt to put in the edit field part of the combo. if bAddAll=TRUE,
//      dont need szTxt.
//
////////////////////////////////////////////////////////////////////////////////////
void SetComboDNText(HWND hDlg, LPPROP_ARRAY_INFO lppai, BOOL bAddAll, LPTSTR szTxt)
{
    HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_COMBO_DISPLAYNAME);

    if(!bAddAll)
    {
        if(szTxt == NULL)
            szTxt = szEmpty;
        // just add the current string to the combo
        SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);
        SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szTxt);
        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
        SetWindowText(hWndCombo, szTxt);
    }
    else
    {
        // Populates the drop down list with all other names ...
        TCHAR * szFirst = NULL;//szFirst[MAX_UI_STR*2];
        TCHAR * szMiddle = NULL;//[MAX_UI_STR*2];
        TCHAR * szLast = NULL;//[MAX_UI_STR*2];
        TCHAR * szDisplay = NULL;//[MAX_UI_STR*2];
        ULONG nLen = MAX_UI_STR*2;
        szFirst = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
        szLast = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
        szMiddle = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));
        szDisplay = LocalAlloc(LMEM_ZEROINIT, nLen*sizeof(TCHAR));

        if(szFirst && szLast && szMiddle && szDisplay)
        {
            szFirst[0] = szLast[0] = szMiddle[0] = szDisplay[0] = '\0';

            // First get the current text and save it ...
            GetWindowText(hWndCombo, szDisplay, nLen);

            // Clear out combo and add the display name again
            SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

            if(lstrlen(szDisplay))
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szDisplay);

            // Get the localized F/M/L name from F/M/L fields
            // If the localized name does not match the display name, add it
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, szFirst, nLen);
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME, szLast, nLen);
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_MIDDLENAME, szMiddle, nLen);

            {
                ULONG ulSzBuf = MAX_BUF_STR;
                LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*ulSzBuf);
                LPTSTR lpszTmp = szBuf;

                if(szBuf) // Get the localized Display Name and reverse localized display name
                {
                    if(SetLocalizedDisplayName( szFirst, szMiddle, szLast,
                                                NULL, // Company Name (not needed)
                                                NULL, // Nick Name (not needed here)
                                                (LPTSTR *) &lpszTmp, //&szBuf,
                                                ulSzBuf, bDNisByLN, 
                                                bDNisByLN ? szResourceDNByCommaLN : szResourceDNByLN,
                                                NULL))
                    {
                        if(lstrlen(szBuf) && lstrcmp(szBuf, szDisplay))
                            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    }
                    szBuf[0] = TEXT('\0');
                    if(SetLocalizedDisplayName( szFirst, szMiddle, szLast,
                                                NULL, // Company Name (not needed)
                                                NULL, // Nick Name (not needed here)
                                                (LPTSTR *) &lpszTmp, //&szBuf,
                                                ulSzBuf, !bDNisByLN, NULL, NULL))
                    {
                        if(lstrlen(szBuf) && lstrcmp(szBuf, szDisplay))
                            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    }
                    szBuf[0] = TEXT('\0');
                    if(SetLocalizedDisplayName( szFirst, szMiddle, szLast,
                                                NULL, // Company Name (not needed)
                                                NULL, // Nick Name (not needed here)
                                                (LPTSTR *) &lpszTmp, //&szBuf,
                                                ulSzBuf, bDNisByLN, NULL, NULL))
                    {
                        if(lstrlen(szBuf) && lstrcmp(szBuf, szDisplay))
                            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
                    }
                    LocalFreeAndNull(&szBuf);
                }
            }

            // Get the NickName and if its different add it to this list
            szFirst[0]='\0';
            GetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_NICKNAME, szFirst, nLen);
            if(lstrlen(szFirst) && lstrcmp(szFirst, szDisplay))
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szFirst);

            // Get the Company name and if its different add it to the list
            szFirst[0]='\0';
            {
                ULONG i;
                ULONG ulcPropCount = 0;
                LPSPropValue lpPropArray = NULL;
                SizedSPropTagArray(1, ptaDN) = {1, PR_COMPANY_NAME};
                if(!HR_FAILED(lppai->lpPropObj->lpVtbl->GetProps(lppai->lpPropObj,
                                                        (LPSPropTagArray)&ptaDN, 
                                                        MAPI_UNICODE,
                                                        &ulcPropCount,
                                                        &lpPropArray)))
                {
                    if(lpPropArray[0].ulPropTag == PR_COMPANY_NAME)
                        StrCpyN(szFirst, lpPropArray[0].Value.LPSZ, nLen);
                }
                if(lpPropArray)
                    MAPIFreeBuffer(lpPropArray);
            }

            if(lstrlen(szFirst) && lstrcmp(szFirst, szDisplay))
                SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szFirst);

            SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
            SetWindowText(hWndCombo, szDisplay);
        }
        LocalFreeAndNull(&szFirst);
        LocalFreeAndNull(&szLast);
        LocalFreeAndNull(&szMiddle);
        LocalFreeAndNull(&szDisplay);
    }

    //SendMessage(hWndCombo, WM_SETREDRAW, (WPARAM) TRUE, 0);
    UpdateWindow(hWndCombo);

    return;
}



//$$////////////////////////////////////////////////////////////////////////////////
//
//  HrShowOneOffDetailsOnVCard
//
//  Deciphers a vCard File and then shows one off details on it
//
//
////////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowOneOffDetailsOnVCard(  LPADRBOOK lpAdrBook,
                                     HWND hWnd,
                                     LPTSTR szvCardFile)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile = NULL;
    LPMAILUSER lpMailUser = NULL;
    LPSTR lpBuf = NULL, lpVCardStart = NULL;
    LPSTR lpVCard = NULL, lpNext = NULL;

    if(!VCardGetBuffer(szvCardFile, NULL, &lpBuf) && hWnd) //no message if no hwnd
    {
        // couldn't open file.
        ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR,
                            MB_ICONEXCLAMATION, szvCardFile);
        goto out;
    }

    lpVCardStart = lpBuf;

    // Loop through showing all the nested vCards one by one ..
    while(VCardGetNextBuffer(lpVCardStart, &lpVCard, &lpNext) && lpVCard)
    {
        // Step 1 - see if we can get a mailuser object out of this file
        if(!HR_FAILED(hr = VCardRetrieve( lpAdrBook, hWnd, MAPI_DIALOG, szvCardFile,
                                        lpVCard, &lpMailUser)))
        {
            // Step 2 - Show one-off details on this entry
            if(!HR_FAILED(hr = HrShowOneOffDetails(   lpAdrBook, hWnd, 0, NULL,
                                MAPI_MAILUSER, (LPMAPIPROP) lpMailUser, NULL, SHOW_ONE_OFF)))
            {
                if(lpMailUser)
                    lpMailUser->lpVtbl->Release(lpMailUser);
                if(hr == MAPI_E_USER_CANCEL)
                    break;
            }
        }

        lpVCard = NULL;
        lpVCardStart = lpNext;
    }


out:
    LocalFreeAndNull(&lpBuf);
    return hr;
}
/*
HRESULT KillTrustInSleazyFashion(HWND hWndLV, int iItem)
{
    LV_ITEM         lvi = {0};
    HRESULT         hr = E_FAIL;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;

    if (ListView_GetItem(hWndLV, &lvi))
    {
    }

    return hr;
}
*/


/*//$$***********************************************************************
*    FUNCTION: fnTridentProc
*
*    PURPOSE:  Callback function for handling the Trident property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnTridentProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
            SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType, propTrident);
            FillCertTridentConfDetailsUI(hDlg, lpPAI, propTrident, lpbSomethingChanged);
            return TRUE;
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_TRIDENT_BUTTON_ADDTOWAB:
            lpPAI->nRetVal = DETAILS_ADDTOWAB;
            SendMessage(GetParent(hDlg), WM_COMMAND, (WPARAM) IDCANCEL, 0);
            break;

        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_APPLY:         //ok
            // in case any of the extended props changed, we need to mark this flag so we wont lose data
            if(lpbSomethingChanged)
                (*lpbSomethingChanged) = ChangedExtDisplayInfo(lpPAI, (*lpbSomethingChanged));

            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;

}



//$$//////////////////////////////////////////////////////////////////////////
//
// SetDefaultServer(hDlg, lpPai)
//
//  iSelectedItem - the item index to which we should set the Default or Backup
//  bForce - forcibly set the Index to the one specified by iSelectedItem
//      if FALSE, chooses any unused index value
//
/////////////////////////////////////////////////////////////////////////////
void SetDefaultServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nCount = ListView_GetItemCount(hWndLV);
    TCHAR sz[MAX_PATH];
    TCHAR szTmp[MAX_PATH];
    int oldIndex = lpPai->nDefaultServerIndex;



    if(iSelectedItem == -1)
    {
        iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        if(iSelectedItem < 0)
            return; // nothing selected ..
    }


    if(iSelectedItem == lpPai->nBackupServerIndex)
    {
        if(!bForce)
        {
            if(nCount >= 2)
            {
                int nTmp = 0;
                while(nTmp == iSelectedItem && nTmp < nCount)
                    nTmp++;
                iSelectedItem = nTmp;
            }
        }
    }

    // replace the old value of the def index item if applicable
    if(lpPai->nDefaultServerIndex >= 0 && lpPai->szDefaultServerName && lstrlen(lpPai->szDefaultServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, lpPai->szDefaultServerName);
        lpPai->szDefaultServerName[0] = TEXT('\0');
    }

    // replace the old backup item text if we are reseting the backup item
    if((lpPai->nBackupServerIndex == iSelectedItem) &&
       lpPai->nBackupServerIndex >= 0 && lpPai->szBackupServerName && lstrlen(lpPai->szBackupServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nBackupServerIndex, 0, lpPai->szBackupServerName);
        lpPai->szBackupServerName[0] = TEXT('\0');
    }

    lpPai->nDefaultServerIndex = iSelectedItem;

    // Now that we have unique indexes for Default and Server Indexes
    //  append  TEXT("Default") and  TEXT("Backup") to these names

    {
        sz[0] = TEXT('\0');
        szTmp[0] = TEXT('\0');
        ListView_GetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, sz, CharSizeOf(sz));
        StrCpyN(lpPai->szDefaultServerName, sz, lpPai->cchDefaultServerName);
        LoadString(hinstMapiX, idsDefaultServer, szTmp, CharSizeOf(szTmp));
        StrCatBuff(sz,  TEXT(" "), ARRAYSIZE(sz));
        StrCatBuff(sz, szTmp, ARRAYSIZE(sz));
        ListView_SetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, sz);
    }

    if(lpPai->nBackupServerIndex == iSelectedItem)
    {
        // Update this backup item
        SetBackupServer(hDlg, lpPai, oldIndex, FALSE);
    }
}


//$$//////////////////////////////////////////////////////////////////////////
//
// SetBackupServer(hDlg, lpPai) - set backup server if possible to do so
//
//  iSelectedItem - the item index to which we should set the Default or Backup
//  bForce - forcibly set the Index to the one specified by iSelectedItem
//      if FALSE, chooses any unused index value
//
/////////////////////////////////////////////////////////////////////////////
void SetBackupServer(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int iSelectedItem, BOOL bForce)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nCount = ListView_GetItemCount(hWndLV);
    TCHAR sz[MAX_PATH];
    TCHAR szTmp[MAX_PATH];
    int oldIndex = lpPai->nBackupServerIndex;

    if(iSelectedItem != -1)
    {
        if(nCount <= 1) // cant overwrite the default to skip
            return;
    }
    else
    {
        iSelectedItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
        if(iSelectedItem < 0)
            return; // nothing selected ..
    }


    if(iSelectedItem == lpPai->nDefaultServerIndex)
    {
        if(nCount <= 1)
            return;
        else
        {
            if(!bForce)
            {
                int nTmp = 0;
                while(nTmp == iSelectedItem && nTmp < nCount)
                    nTmp++;
                iSelectedItem = nTmp;
            }
        }
    }

    // replace the old value of the def index item if its being overwritten
    if((lpPai->nDefaultServerIndex == iSelectedItem) &&
       lpPai->nDefaultServerIndex >= 0 && lpPai->szDefaultServerName && lstrlen(lpPai->szDefaultServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nDefaultServerIndex, 0, lpPai->szDefaultServerName);
        lpPai->szDefaultServerName[0] = TEXT('\0');
    }

    // replace the old backup item text if we are reseting the backup item
    if(lpPai->nBackupServerIndex >= 0 && lpPai->szBackupServerName && lstrlen(lpPai->szBackupServerName))
    {
        ListView_SetItemText(hWndLV, lpPai->nBackupServerIndex, 0, lpPai->szBackupServerName);
        lpPai->szBackupServerName[0] = TEXT('\0');
    }

    lpPai->nBackupServerIndex = iSelectedItem;

    {
        sz[0] = TEXT('\0');
        szTmp[0] = TEXT('\0');
        ListView_GetItemText(hWndLV, lpPai->nBackupServerIndex, 0, sz, CharSizeOf(sz));
        StrCpyN(lpPai->szBackupServerName, sz, lpPai->cchBackupServerName);
        LoadString(hinstMapiX, idsBackupServer, szTmp, CharSizeOf(szTmp));
        StrCatBuff(sz,  TEXT(" "), ARRAYSIZE(sz));
        StrCatBuff(sz, szTmp, ARRAYSIZE(sz));
        ListView_SetItemText(hWndLV, lpPai->nBackupServerIndex, 0, sz);
    }

    if(lpPai->nDefaultServerIndex == iSelectedItem)
    {
        // Update this backup item
        SetDefaultServer(hDlg, lpPai, oldIndex, FALSE);
    }
}



//$$//////////////////////////////////////////////////////////////////////////
//
// UpdateServerLVButtons(hDlg);
//
/////////////////////////////////////////////////////////////////////////////
void UpdateServerLVButtons(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    int nCount = ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS));

    if(lpPai->ulOperationType == SHOW_ONE_OFF)
        nCount = 0;

    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_EDIT), (nCount > 0) ? TRUE : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_REMOVE), (nCount > 0) ? TRUE : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT), (nCount > 0) ? TRUE : FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_SETBACKUP), (nCount > 1) ? TRUE : FALSE);

}

//$$//////////////////////////////////////////////////////////////////////////
//
// FillComboWithEmailAddresses(HWND hWndLV, HWND hWndCombo);
//
/////////////////////////////////////////////////////////////////////////////
void FillComboWithEmailAddresses(LPPROP_ARRAY_INFO lpPai, HWND hWndCombo, int * lpnDefault)
{
    ULONG i,j;
    ULONG ulcProps = 0;
    LPSPropValue lpProps = NULL;
    int nSel = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    TCHAR szBuf[MAX_UI_STR];
    BOOL bMatch = FALSE;
    BOOL bFound = FALSE;
    ULONG nEmail = 0xFFFFFFFF;

    enum _EmailProps
    {
        eCEmailAddr=0,
        eCEmailIndex,
        eCEmail,
        eMax
    };

    SizedSPropTagArray(eMax, ptaE) =
    {
        eMax,
        {
            PR_CONTACT_EMAIL_ADDRESSES,
            PR_CONTACT_DEFAULT_ADDRESS_INDEX,
            PR_EMAIL_ADDRESS
        }
    };
    *szBuf = '\0';
    GetWindowText(hWndCombo, szBuf, CharSizeOf(szBuf));


    // Delete all the combo contents
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, 
                                                    (LPSPropTagArray)&ptaE, 
                                                    MAPI_UNICODE,
                                                    &ulcProps, &lpProps)))
        return;

    // Check if the PR_CONTACT_EMAIL_ADDRESSES already exists ..
    // if it does, tag the email onto it
    // if it doesnt and there is no pr_email_address, we create both
    // else if there is PR_EMAIL address then we cretae contact_email_addresses

    if(lpProps[eCEmailAddr].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
    {
        bFound = TRUE;
        for(j=0;j<lpProps[eCEmailAddr].Value.MVSZ.cValues;j++)
        {
            SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) lpProps[eCEmailAddr].Value.MVSZ.LPPSZ[j]);
            if(!lstrcmp(szBuf, lpProps[eCEmailAddr].Value.MVSZ.LPPSZ[j]))
            {   
                bMatch = TRUE;
                nSel = j;
            }
        }
    }
    if( lpProps[eCEmailIndex].ulPropTag == PR_CONTACT_DEFAULT_ADDRESS_INDEX)
    {
        if(lpnDefault)
            *lpnDefault = lpProps[eCEmailIndex].Value.l;
    }
    if(lpProps[eCEmail].ulPropTag == PR_EMAIL_ADDRESS)
        nEmail = eCEmail;

    // if there is no Contact_Email_Addresses but there is an email_address
    if(!bFound && nEmail != 0xFFFFFFFF)
    {
        SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) lpProps[nEmail].Value.LPSZ);
        if(!lstrcmp(szBuf, lpProps[nEmail].Value.LPSZ))
        {
            bMatch = TRUE;
            nSel = 0;
        }
    }

    if(bMatch)
        SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nSel, 0);
    else if(lstrlen(szBuf))
    {
        // make sure this is not the     [None .. ] string
        TCHAR sz[MAX_PATH];
        LoadString(hinstMapiX, idsCertsWithoutEmails, sz, CharSizeOf(sz));
        if(lstrcmpi(sz, szBuf))
        {
            int nPos = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) szBuf);
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM) nPos, 0);
        }
    }

    SetWindowText(hWndCombo, szBuf);

    MAPIFreeBuffer(lpProps);

}

/*
-   ClearConfLV
-
*   Clears out the info alloced into the conferencing list view
*/
void ClearConfLV(HWND hDlg)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
    int nItemCount = ListView_GetItemCount(hWndLV), i = 0;
    for(i=0;i< nItemCount; i++)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i; lvi.iSubItem = 0;
        ListView_GetItem(hWndLV, &lvi);
        if(lvi.lParam)
            LocalFreeServerItem((LPSERVER_ITEM) lvi.lParam);
    }
    ListView_DeleteAllItems(hWndLV);
}


/*//$$***********************************************************************
*    FUNCTION: fnConferencingProc
*
*    PURPOSE:  Callback function for handling the Conferencing property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnConferencingProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        // [PaulHi] EnumChildWindows needs to be called BEFORE SetDetails in this case
        // because it sets list view column strings.  SetDetails calls EnumChildWindows
        // at the end but this is too late.
        // @todo - Instead of callinge EnumChildWindows twice just call it at the 
        // begninning of SetDetails.  Don't want to change the code that much now right
        // before RTM.
        EnumChildWindows(hDlg, SetChildDefaultGUIFont, (LPARAM)0);
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType, propConferencing);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;
        break;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE:
            if(LOWORD(wParam) == IDC_DETAILS_NTMTG_EDIT_ADDSERVER)
            {
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_BUTTON_ADDSERVER),TRUE);
                SendMessage(hDlg, DM_SETDEFID, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, 0);
                return 0;
                break;
            }
        case CBN_EDITCHANGE:
        case CBN_SELCHANGE:
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDC_DETAILS_NTMTG_BUTTON_CALL:
            // basically shell-exec a  TEXT("callto") command here
            // The format of the  TEXT("Callto") protocol is
            //      callto://servername/emailalias
            //
            {
                TCHAR * szCalltoURL = NULL;//szCalltoURL[MAX_UI_STR*2];
                ULONG cchCalltoURL=MAX_UI_STR*2;
                TCHAR szEmail[MAX_UI_STR];
                TCHAR szServer[MAX_UI_STR];
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                if(szCalltoURL = LocalAlloc(LMEM_ZEROINIT, cchCalltoURL*sizeof(TCHAR)))
                {
                    int nItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    {
                        LV_ITEM lvi = {0};
                        lvi.iItem = nItem;
                        lvi.iSubItem = 0;
                        lvi.mask = LVIF_PARAM;
                        ListView_GetItem(hWndLV, &lvi);

                        if(lvi.lParam)
                        {
                            StrCpyN(szServer, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpServer, ARRAYSIZE(szServer));
                            StrCpyN(szEmail, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpEmail, ARRAYSIZE(szEmail));
                        }
                        else
                        {
                            szServer[0] = TEXT('\0');
                            szEmail[0] = TEXT('\0');
                        }
                    }
                    if(lstrlen(szServer) && lstrlen(szEmail))
                    {
                        StrCpyN(szCalltoURL, szCallto, cchCalltoURL);
                        StrCatBuff(szCalltoURL, szServer, cchCalltoURL);
                        StrCatBuff(szCalltoURL, TEXT("/"), cchCalltoURL);
                        StrCatBuff(szCalltoURL, szEmail, cchCalltoURL);
                        ShellExecute(hDlg,  TEXT("open"), szCalltoURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                    else
                        ShowMessageBox(hDlg, idsIncompleteConfInfo, MB_OK | MB_ICONINFORMATION);
                    LocalFreeAndNull(&szCalltoURL);
                }
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                LVSelectItem(hWndLV, lpPAI->nConfEditIndex);
                lpPAI->ulFlags &= ~DETAILS_EditingConf;
                ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT), SW_HIDE);
                lpPAI->nConfEditIndex = -1;
                SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szEmpty);
                SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmpty);
                {
                    TCHAR sz[MAX_PATH];
                    LoadString(hinstMapiX, idsConfAdd, sz, CharSizeOf(sz));
                    SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, sz);
                }
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_ADDSERVER:
            {
                TCHAR szBuf[MAX_UI_STR], szEmail[MAX_UI_STR];
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szBuf, CharSizeOf(szBuf));
                TrimSpaces(szBuf);
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmail, CharSizeOf(szEmail));
                TrimSpaces(szEmail);
                if(!lstrlen(szBuf) || !lstrlen(szEmail))
                    ShowMessageBox(hDlg, idsIncompleteConfInfo, MB_OK | MB_ICONEXCLAMATION);
                else
                {
                    LV_ITEM lvi = {0};
                    LPSERVER_ITEM lpSI = (LPSERVER_ITEM) LocalAlloc(LMEM_ZEROINIT, sizeof(SERVER_ITEM));
                    ULONG cch = lstrlen(szBuf)+1;
                    LPTSTR lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cch);
                    ULONG cchE = lstrlen(szEmail)+1;
                    LPTSTR lpE = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchE);
                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                    if(lp && lpE && lpSI)
                    {
                        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
                        StrCpyN(lp, szBuf, cch);
                        StrCpyN(lpE, szEmail, cchE);
                        lpSI->lpServer = lp;
                        lpSI->lpEmail = lpE;
                        lvi.lParam = (LPARAM) lpSI;
                        if(lpPAI->ulFlags & DETAILS_EditingConf)
                            lvi.iItem = lpPAI->nConfEditIndex;
                        else
                            lvi.iItem = ListView_GetItemCount(hWndLV);
                        lvi.cchTextMax = MAX_UI_STR;
                        lvi.iSubItem = 0;
                        lvi.pszText = szBuf;
                        ListView_InsertItem(hWndLV, &lvi);
            	        ListView_SetItemText (hWndLV, lvi.iItem, 1, szEmail);
                        SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szEmpty);
                        SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmpty);
                        if(lpPAI->ulFlags & DETAILS_EditingConf)
                        {
                            LV_ITEM lvii = {0};
                            lvii.mask = LVIF_PARAM;
                            lvii.iItem = lvi.iItem+1; lvii.iSubItem = 0;
                            ListView_GetItem(hWndLV, &lvii);
                            if(lvii.lParam)
                                LocalFreeServerItem((LPSERVER_ITEM) lvii.lParam);
                            ListView_DeleteItem(hWndLV, lvii.iItem);
                            if(lvi.iItem == lpPAI->nDefaultServerIndex)
                                StrCpyN(lpPAI->szDefaultServerName,lp,lpPAI->cchDefaultServerName);
                            else if(lvi.iItem == lpPAI->nBackupServerIndex)
                                StrCpyN(lpPAI->szBackupServerName,lp,lpPAI->cchBackupServerName);
                            SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT, 0);
                        }
                        LVSelectItem(hWndLV, lvi.iItem);
                        SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
                        SetDefaultServer(hDlg, lpPAI, lpPAI->nDefaultServerIndex, TRUE);
                        SetBackupServer(hDlg, lpPAI, lpPAI->nBackupServerIndex, FALSE);
                        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
                    }
                    EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_BUTTON_ADDSERVER),FALSE);
                    SetFocus(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_EDIT_ADDSERVER));
                }
                UpdateWindow(hWndLV);
                if (lpbSomethingChanged)
                    (*lpbSomethingChanged) = TRUE;
                UpdateServerLVButtons(hDlg, lpPAI);
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_EDIT:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    HWND hWndEditLabel;
                    int nItem = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    {
                        LV_ITEM lvi = {0};
                        lvi.iItem = nItem;
                        lvi.iSubItem = 0;
                        lvi.mask = LVIF_PARAM;
                        ListView_GetItem(hWndLV, &lvi);
                        if(lvi.lParam)
                        {
                            SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpServer);
                            SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, (LPTSTR) ((LPSERVER_ITEM)lvi.lParam)->lpEmail);
                            // Remove these items from the ListView
                            SetFocus(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER));
                            SendMessage(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER), EM_SETSEL, 0, -1);
                            lpPAI->ulFlags |= DETAILS_EditingConf;
                            lpPAI->nConfEditIndex = nItem;
                            ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT), SW_SHOW);
                            {
                                TCHAR sz[MAX_PATH];
                                LoadString(hinstMapiX, idsConfUpdate, sz, CharSizeOf(sz));
                                SetDlgItemText(hDlg, IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, sz);
                            }
                        }
                    }
                }
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_REMOVE:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
                int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                if(iItemIndex != -1)
                {
                    BOOL bDef = (iItemIndex == lpPAI->nDefaultServerIndex) ? TRUE : FALSE;
                    BOOL bBck = (iItemIndex == lpPAI->nBackupServerIndex) ? TRUE : FALSE;

                    if((lpPAI->ulFlags&DETAILS_EditingConf) && (iItemIndex==lpPAI->nConfEditIndex))
                        SendMessage(hDlg, WM_COMMAND, (WPARAM)IDC_DETAILS_NTMTG_BUTTON_CANCELEDIT, 0);

                    {
                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_PARAM;
                        lvi.iItem = iItemIndex; lvi.iSubItem = 0;
                        ListView_GetItem(hWndLV, &lvi);
                        if(lvi.lParam)
                            LocalFreeServerItem((LPSERVER_ITEM) lvi.lParam);
                    }
                    ListView_DeleteItem(hWndLV, iItemIndex);
                    if(ListView_GetSelectedCount(hWndLV) <= 0)
                        LVSelectItem(hWndLV, (iItemIndex <= 0) ? iItemIndex : iItemIndex-1);
                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;

                    if(iItemIndex < lpPAI->nDefaultServerIndex)
                        lpPAI->nDefaultServerIndex--;

                    if(iItemIndex < lpPAI->nBackupServerIndex)
                        lpPAI->nBackupServerIndex--;

                    if(bDef)
                    {
                        lpPAI->nDefaultServerIndex = -1;
                        lpPAI->szDefaultServerName[0] = TEXT('\0');
                        SetDefaultServer(hDlg, lpPAI, -1, FALSE);
                    }

                    if(bBck)
                    {
                        lpPAI->nBackupServerIndex = -1;
                        lpPAI->szBackupServerName[0] = TEXT('\0');
                        SetBackupServer(hDlg, lpPAI, -1, FALSE);
                    }

                    if (lpbSomethingChanged)
                        (*lpbSomethingChanged) = TRUE;
                }
                UpdateServerLVButtons(hDlg, lpPAI);
            }
            break;

        case IDC_DETAILS_NTMTG_BUTTON_SETDEFAULT:
            SetDefaultServer(hDlg, lpPAI, -1, TRUE);
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case IDC_DETAILS_NTMTG_BUTTON_SETBACKUP:
            SetBackupServer(hDlg, lpPAI, -1, TRUE);
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;


        }
        break;

    default:
#ifndef WIN16 // WIN16 doesn't support MSWheel.
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS), message, wParam, lParam);
        }
#endif // !WIN16
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            FillCertTridentConfDetailsUI(hDlg, lpPAI, propConferencing, lpbSomethingChanged);
            // if this is a readonly entry and there is no data in the listview,
            // disable the call now button
            if( lpPAI->ulOperationType == SHOW_ONE_OFF &&
                ListView_GetItemCount(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS)) <= 0)
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_NTMTG_BUTTON_CALL), FALSE);
            UpdateServerLVButtons(hDlg, lpPAI);
            //FillComboWithEmailAddresses(lpPAI, lpPAI->hWndComboConf, NULL);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            // In case there is something sitting in the edit boxes, add it to the lv
            //
            {
                TCHAR szBuf[MAX_UI_STR], szEmail[MAX_UI_STR];
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_EDIT_ADDSERVER, szBuf, CharSizeOf(szBuf));
                TrimSpaces(szBuf);
                GetDlgItemText(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL, szEmail, CharSizeOf(szEmail));
                TrimSpaces(szEmail);
                if(lstrlen(szBuf) && lstrlen(szEmail))
                    SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_DETAILS_NTMTG_BUTTON_ADDSERVER, 0);
            }
            bUpdatePropArray(hDlg, lpPAI, propConferencing);
            ClearConfLV(hDlg);
            break;

        case PSN_APPLY:         //ok
            //bUpdatePropArray(hDlg, lpPAI, propConferencing);
            //ClearConfLV(hDlg);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if(lpPAI->ulFlags & DETAILS_EditingEmail) //cancel any editing else it faults #30235
                ListView_EditLabel(GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS), -1);
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            ClearConfLV(hDlg);
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DETAILS_NTMTG_LIST_SERVERS:
                {
		            NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
		            if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		            {
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			            return TRUE;
		            }
		            else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
		            {
                        if( pnmcd->dwItemSpec == (DWORD) lpPAI->nDefaultServerIndex ||
                            pnmcd->dwItemSpec == (DWORD) lpPAI->nBackupServerIndex )
                        {
				            SelectObject(((NMLVCUSTOMDRAW*)lParam)->nmcd.hdc, GetFont(fntsSysIconBold));
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NEWFONT);
				            return TRUE;
                        }
		            }
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
                    return TRUE;
                }
                break;
	        }
            break;

        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_NTMTG_LIST_SERVERS:
            SetDefaultServer(hDlg, lpPAI, -1, TRUE);
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
              break;
            }
            break;
        }
        return TRUE;
    }

    return bRet;

}

/*//$$***********************************************************************
*    FUNCTION: AddLVLDAPURLEntry
*
*    PURPOSE:  Takes an LDAP URL, converts it to a MailUser and adds the
*               MailUser to the List View
*
****************************************************************************/
void AddLVLDAPURLEntry(LPADRBOOK lpAdrBook, HWND hWndLV, LPTSTR lpszLDAPURL)
{
    LPMAILUSER lpMailUser = NULL;

    HrProcessLDAPUrl(lpAdrBook, GetParent(hWndLV),
                    WABOBJECT_LDAPURL_RETURN_MAILUSER,
                    lpszLDAPURL,
                    &lpMailUser);
    if(lpMailUser)
    {
        LPSPropValue lpPropArray = NULL;
        ULONG ulcProps = 0;
        if(!HR_FAILED(lpMailUser->lpVtbl->GetProps(lpMailUser,
                                                    NULL, MAPI_UNICODE,
                                                    &ulcProps, &lpPropArray)))
        {
            LPRECIPIENT_INFO lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		    if (lpItem)
            {
                GetRecipItemFromPropArray(ulcProps, lpPropArray, &lpItem);
                if(lpItem)
                    AddSingleItemToListView(hWndLV, lpItem);
            }
            MAPIFreeBuffer(lpPropArray);
        }
        lpMailUser->lpVtbl->Release(lpMailUser);
    }
}

/*//$$***********************************************************************
*    FUNCTION: FillOrgData
*
*    PURPOSE:  Fills in LDAP data in the Org prop sheets
*
****************************************************************************/
void FillOrgData(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    HWND hWndLVManager = GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_MANAGER);
    HWND hWndLVReports = GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_REPORTS);

    ULONG i,j;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPA = NULL;

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
    enum _org
    {
        oReports=0,
        oManager,
        oMax
    };
    SizedSPropTagArray(oMax, ptaOrg) = 
    {
        oMax,
        {
            PR_WAB_REPORTS,
            PR_WAB_MANAGER
        }
    };
    if(!HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj,
                                                    (LPSPropTagArray)&ptaOrg, 
                                                    MAPI_UNICODE,
                                                    &ulcPropCount, &lpPA)))
    {
        if(lpPA[oReports].ulPropTag == PR_WAB_REPORTS)
        {
            for(j=0;j<lpPA[oReports].Value.MVSZ.cValues;j++)
            {
                AddLVLDAPURLEntry(lpPai->lpIAB, hWndLVReports, lpPA[oReports].Value.MVSZ.LPPSZ[j]);
            }
        }
        if(lpPA[oManager].ulPropTag == PR_WAB_MANAGER)
        {
            AddLVLDAPURLEntry(lpPai->lpIAB, hWndLVManager, lpPA[oManager].Value.LPSZ);
        }
    }

    if(ListView_GetItemCount(hWndLVManager) > 0)
        LVSelectItem(hWndLVManager, 0);
    else
        EnableWindow(hWndLVManager, FALSE);

    if(ListView_GetItemCount(hWndLVReports) > 0)
        LVSelectItem(hWndLVReports, 0);
    else
        EnableWindow(hWndLVReports, FALSE);


    if(lpPA)
        MAPIFreeBuffer(lpPA);

    SetCursor(hOldCur);
}



/*//$$***********************************************************************
*
*    FUNCTION: FreeOrgLVData
*
*    PURPOSE:  Frees the Data from the Org LVs
*
****************************************************************************/
void FreeOrgLVData(HWND hWndLV)
{
    int i=0, nCount=ListView_GetItemCount(hWndLV);
    for(i=0;i<nCount;i++)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        ListView_GetItem(hWndLV, &lvi);
        if(lvi.lParam)
        {
            LPRECIPIENT_INFO lpItem = (LPRECIPIENT_INFO) lvi.lParam;
            FreeRecipItem(&lpItem);
        }
    }
}



/*//$$***********************************************************************
*    FUNCTION: fnOrgProc
*
*    PURPOSE:  Callback function for handling the Organization Prop Sheets
*
****************************************************************************/
INT_PTR CALLBACK fnOrgProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        HrInitListView(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_MANAGER), LVS_REPORT, FALSE);
        HrInitListView(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_REPORTS), LVS_REPORT, FALSE);
        UpdateWindow(hDlg);
        FillOrgData(hDlg, lpPAI);
        return TRUE;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_APPLY:         //ok
            lpPAI->nRetVal = DETAILS_OK;
        case PSN_RESET:         //cancel
            FreeOrgLVData(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_MANAGER));
            FreeOrgLVData(GetDlgItem(hDlg, IDC_DETAILS_ORG_LIST_REPORTS));
            if (lpPAI->nRetVal == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;


        // if enter pressed ...
        case LVN_KEYDOWN:
            if(((LV_KEYDOWN FAR *) lParam)->wVKey != VK_RETURN)
                break;
            // else fall thru
        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DETAILS_ORG_LIST_MANAGER:
            case IDC_DETAILS_ORG_LIST_REPORTS:
                {
                    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
                    if (ListView_GetSelectedCount(pNm->hdr.hwndFrom) == 1)
		                HrShowLVEntryProperties(pNm->hdr.hwndFrom, 0, lpPAI->lpIAB,NULL);
                }
                break;
            }
            break;
        } //WM_NOTIFY
        return TRUE;
    }
    return bRet;
}

void LocalFreeServerItem(LPSERVER_ITEM lpSI)
{
    if(lpSI)
    {
        if(lpSI->lpServer)
            LocalFree((LPVOID) lpSI->lpServer);
        if(lpSI->lpEmail)
            LocalFree((LPVOID) lpSI->lpEmail);
        LocalFree((LPVOID) lpSI);
    }
}



/*//$$***********************************************************************
*    FUNCTION: fnSummaryProc
*
*
****************************************************************************/
void UpdateSummaryInfo(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    ULONG cValues = 0, i = 0, j = 0;
    LPSPropValue lpPropArray = NULL;
    BOOL bFoundEmail    = FALSE;
    BOOL bFoundHomeURL  = FALSE;
    BOOL bFoundBusURL   = FALSE;
    ULONG ulPropTag;
    HWND hURLBtn;

    if(!lpPai->lpPropObj)
        goto out;

    if (HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj,
                                        (LPSPropTagArray) &ptaUIDetlsPropsSummary, MAPI_UNICODE,
                                        &cValues,     
                                        &lpPropArray)))
    {
        goto out;
    }

    for(i=0;i<MAX_SUMMARY_ID;i++)
    {
        SetDlgItemText(hDlg, rgSummaryIDs[i], szEmpty);
        for(j=0;j<cValues;j++)
        {
            ulPropTag = lpPropArray[j].ulPropTag;
            if( ulPropTag == PR_DISPLAY_NAME)
            {
                SetWindowPropertiesTitle(GetParent(hDlg), lpPropArray[j].Value.LPSZ);
            }
            if(ulPropTag == ((LPSPropTagArray) &ptaUIDetlsPropsSummary)->aulPropTag[i])
            {
                if(ulPropTag == PR_EMAIL_ADDRESS)
                    bFoundEmail = TRUE;
                else if(ulPropTag == PR_PERSONAL_HOME_PAGE )
                    bFoundHomeURL = TRUE;
                else if( ulPropTag == PR_BUSINESS_HOME_PAGE )
                    bFoundBusURL = TRUE;

                SetDlgItemText(hDlg, rgSummaryIDs[i], lpPropArray[j].Value.LPSZ);
                break;
            }
        }
    }
        
    hURLBtn = GetDlgItem( hDlg, IDC_DETAILS_HOME_BUTTON_URL);
    if( bFoundHomeURL )
    {
        // enable and show button
        ShowWindow(hURLBtn, SW_SHOW);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(TRUE), (LPARAM)(0) ); 
    }
    else
    {
        // hide and disable button
        ShowWindow(hURLBtn, SW_HIDE);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(FALSE), (LPARAM)(0) );
    }
        
    hURLBtn = GetDlgItem( hDlg, IDC_DETAILS_BUSINESS_BUTTON_URL);
    if( bFoundBusURL )
    {
        // enable and show button
                
        ShowWindow(hURLBtn, SW_SHOW);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(TRUE), (LPARAM)(0) );        
    }
    else
    {
        // hide and disable button                
        ShowWindow(hURLBtn, SW_HIDE);
        SendMessage(hURLBtn, WM_ENABLE, (WPARAM)(FALSE), (LPARAM)(0) );
    }
    
    if(!bFoundEmail)
    {
        // Look for Contact_Email_Addresses and DefaultIndex
        ULONG nEmails = 0xFFFFFFFF, nDef = 0xFFFFFFFF;
        for(i=0;i<cValues;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                nEmails = i;
            if(lpPropArray[i].ulPropTag == PR_CONTACT_DEFAULT_ADDRESS_INDEX)
                nDef = i;
        }
        if(nEmails != 0xFFFFFFFF)
            SetDlgItemText( hDlg, IDC_DETAILS_SUMMARY_STATIC_EMAIL,
                            lpPropArray[nEmails].Value.MVSZ.LPPSZ[(nDef != 0xFFFFFFFF ? lpPropArray[nDef].Value.l : 0)]);
    }

out:
    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return;
}

/*//$$***********************************************************************
*    FUNCTION: fnSummaryProc
*
*
****************************************************************************/
INT_PTR CALLBACK fnSummaryProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            EnumChildWindows(   hDlg, SetChildDefaultGUIFont, (LPARAM) 0);
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            pps = (PROPSHEETPAGE *) lParam;
            if (lpPAI->ulOperationType != SHOW_ONE_OFF ||
                lpPAI->ulFlags & DETAILS_HideAddToWABButton)
            {
                HWND hwnd = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB);
                EnableWindow(hwnd, FALSE);
                ShowWindow(hwnd, SW_HIDE);
            }
            if (lpPAI->ulOperationType == SHOW_ONE_OFF)
                EnableWindow(GetDlgItem(GetParent(hDlg), IDOK), FALSE);
            return TRUE;
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_PERSONAL_BUTTON_ADDTOWAB:
            lpPAI->nRetVal = DETAILS_ADDTOWAB;
            SendMessage(GetParent(hDlg), WM_COMMAND, (WPARAM) IDCANCEL, 0);
            break;
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        case IDC_DETAILS_HOME_BUTTON_URL:
            ShowURL(hDlg, IDC_DETAILS_SUMMARY_STATIC_PERSONALWEB,NULL);
            break;
        case IDC_DETAILS_BUSINESS_BUTTON_URL:
            ShowURL(hDlg, IDC_DETAILS_SUMMARY_STATIC_BUSINESSWEB,NULL);
            break;
        }
        break;


    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            UpdateSummaryInfo(hDlg, lpPAI);
            break;

        case PSN_APPLY:         //ok
            // in case any of the extended props changed, we need to mark this flag so we wont lose data
            if(lpbSomethingChanged)
                (*lpbSomethingChanged) = ChangedExtDisplayInfo(lpPAI, (*lpbSomethingChanged));
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            break;

        case PSN_RESET:         //cancel
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }
        return TRUE;
    }

    return bRet;

}



/*//$$***************************************************************************
*    FUNCTION: FillPersonalDetails(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillPersonalDetails(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    LPTSTR lpszDisplayName = NULL, lpszFirstName = NULL, lpszLastName = NULL;
    LPTSTR lpszMiddleName = NULL, lpszNickName = NULL, lpszCompanyName = NULL;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;
    BOOL bRichInfo = FALSE;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    SizedSPropTagArray(14, ptaUIDetlsPropsPersonal)=
    {
        14,
        {
            PR_DISPLAY_NAME,
            PR_EMAIL_ADDRESS,
            PR_ADDRTYPE,
            PR_CONTACT_EMAIL_ADDRESSES,
            PR_CONTACT_ADDRTYPES,
            PR_CONTACT_DEFAULT_ADDRESS_INDEX,
            PR_GIVEN_NAME,
            PR_SURNAME,
            PR_MIDDLE_NAME,
            PR_NICKNAME,
            PR_SEND_INTERNET_ENCODING,
            PR_DISPLAY_NAME_PREFIX,
            PR_WAB_YOMI_FIRSTNAME,
            PR_WAB_YOMI_LASTNAME
        }
    };

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, 
                                        (LPSPropTagArray)&ptaUIDetlsPropsPersonal, 
                                        MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[nPropSheet] = TRUE;

    // Check the check box on the UI for whether this contact can receive rich email messages
    for(i=0;i<ulcPropCount;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_SEND_INTERNET_ENCODING)
        {
            //Check the check box on the UI if no value is chosen for BODY_ENCODING_HTML
            // Bug 2285: wabtags.h had the wrong tag for BODY_ENCODING_HTML .. it was set to
            // be the same as BODY_ENCODING_TEXT_AND_HTML instead .. hence for backward compatibility
            // we have to also check for BODY_ENCODING_TEXT_AND_HTML here and then when
            // saving have to set it back to BODY_ENCODING_HTML ..

            int id = (lpPropArray[i].Value.l & BODY_ENCODING_HTML ||
                      lpPropArray[i].Value.l & BODY_ENCODING_TEXT_AND_HTML)
                      ? BST_UNCHECKED : BST_CHECKED;
            CheckDlgButton(hDlg, IDC_DETAILS_PERSONAL_CHECK_RICHINFO, id);
            bRichInfo = TRUE;
            break;
        }
    }
    // if we didnt find the PR_SEND_INTERNET_ENCODING, we want to force a save on this contact
    // if the contact is writable ...
    if(!bRichInfo && lpPai->ulOperationType != SHOW_ONE_OFF)
        *lpbChangesMade = TRUE;

    for(i=0;i<ulcPropCount;i++)
    {
        switch(lpPropArray[i].ulPropTag)
        {
        case PR_DISPLAY_NAME:
            lpszDisplayName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_GIVEN_NAME:
            lpszFirstName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_SURNAME:
            lpszLastName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_MIDDLE_NAME:
            lpszMiddleName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_NICKNAME:
            lpszNickName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_COMPANY_NAME:
            lpszCompanyName = lpPropArray[i].Value.LPSZ;
            break;
        }
    }

    /*
    *
    * At this point we always have a display name. We need to track how this
    *   display name relates to F/M/L/Nick/Company
    *
    * So we check if
    *   Display Name == Nick Name
    *   Display Name == Company Name
    *   Display Name == FML
    */

    // Check if Display Name was created from First Middle Last
    if( (lpszFirstName && lstrlen(lpszFirstName)) ||
        (lpszMiddleName && lstrlen(lpszMiddleName)) ||
        (lpszLastName && lstrlen(lpszLastName))   )
    {
        ULONG ulSzBuf = 4*MAX_BUF_STR;
        LPTSTR szBuf = LocalAlloc(LMEM_ZEROINIT, ulSzBuf*sizeof(TCHAR));
        LPTSTR lpszTmp = szBuf;

        if(!szBuf)
            goto out;

        if(!SetLocalizedDisplayName(lpszFirstName,
                                    lpszMiddleName,
                                    lpszLastName,
                                    NULL, // Company Name (not needed)
                                    NULL, // Nick Name (not needed here)
                                    (LPTSTR *) &lpszTmp, //&szBuf,
                                    ulSzBuf,
                                    bDNisByLN,
                                    NULL,
                                    NULL))
        {
            //TBD - do we really want to fail here .. ???
            LocalFreeAndNull(&szBuf);
            DebugPrintTrace(( TEXT("SetLocalizedDisplayName failed\n")));
            goto out;
        }

        if(lpszDisplayName && szBuf && !lstrcmp(lpszDisplayName, szBuf))
            lpPai->ulFlags |= DETAILS_DNisFMLName;
        else
            lpPai->ulFlags &= ~DETAILS_DNisFMLName;

        LocalFreeAndNull(&szBuf);
    }

    // if DN was not created from FML ..
    if(!(lpPai->ulFlags & DETAILS_DNisFMLName) )
    {
        // Check if DN == NickName
        if(lpszNickName)
        {
            if(!lstrlen(lpszDisplayName))
                lpszDisplayName = lpszNickName;

            if(!lstrcmp(lpszDisplayName, lpszNickName))
                lpPai->ulFlags |= DETAILS_DNisNickName;
            else
                lpPai->ulFlags &= ~DETAILS_DNisNickName;
        }

        // Check if DN == Company Name
        if(lpszCompanyName)
        {
            if(!lstrlen(lpszDisplayName))
                lpszDisplayName = lpszCompanyName;

            if(!lstrcmp(lpszDisplayName, lpszCompanyName))
                lpPai->ulFlags |= DETAILS_DNisCompanyName;
            else
                lpPai->ulFlags &= ~DETAILS_DNisCompanyName;
        }
    }
    else
    {
        lpPai->ulFlags &= ~DETAILS_DNisNickName;
        lpPai->ulFlags &= ~DETAILS_DNisCompanyName;
    }

    // if DN is none of the above and there is no FML,
    // parse the DN into F and L
    //
    if (    !lpszFirstName &&
            !lpszLastName &&
            !lpszMiddleName &&
            !(lpPai->ulFlags & DETAILS_DNisCompanyName) &&
            !(lpPai->ulFlags & DETAILS_DNisNickName) )
    {
        bChangesMade = ParseDisplayName(
                            lpszDisplayName,
                            &lpszFirstName,
                            &lpszLastName,
                            NULL,       // lpvRoot
                            &lpBuffer); // lppLocalFree

        lpPai->ulFlags |= DETAILS_DNisFMLName;
    }

    // Set the Dialog title to reflect the display name
    SetWindowPropertiesTitle(GetParent(hDlg), lpszDisplayName ? lpszDisplayName : szEmpty);

    //////////////////////////
    // A very inefficient and lazy way of filling the UI
    // but works for now
    //
    for(i=0;i<idPropPersonalCount;i++)
    {
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpPropArray[j].ulPropTag == idPropPersonal[i].ulPropTag)
                SetDlgItemText(hDlg, idPropPersonal[i].idCtl, lpPropArray[j].Value.LPSZ);
        }
    }

    // Add the Yomi prop data
    for(j=0;j<ulcPropCount;j++)
    {
        if(lpPropArray[j].ulPropTag == PR_WAB_YOMI_FIRSTNAME)
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST, lpPropArray[j].Value.LPSZ);
        if(lpPropArray[j].ulPropTag == PR_WAB_YOMI_LASTNAME)
            SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_STATIC_RUBYLAST, lpPropArray[j].Value.LPSZ);
    }

    // Overwrite the first last name with out pre calculated values
    if (lpszFirstName)
        SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, lpszFirstName);
    if (lpszLastName)
        SetDlgItemText(hDlg, IDC_DETAILS_PERSONAL_EDIT_LASTNAME, lpszLastName);

    // Fill the Combo
    SetComboDNText(hDlg, NULL, FALSE, lpszDisplayName);

    {
        //
        // Now we fill in the Email addresses .. bunch of cases can exist in here
        // Single email, multiple email, no email etc ...
        //
        // First we search for all the props we need to fill in the email structure
        //
        LPSPropValue lpPropEmail = NULL;
        LPSPropValue lpPropAddrType = NULL;
        LPSPropValue lpPropMVEmail = NULL;
        LPSPropValue lpPropMVAddrType = NULL;
        LPSPropValue lpPropDefaultIndex = NULL;
        BOOL bDefaultSet = FALSE;
        HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_PERSONAL_LIST);

        for(i=0;i<ulcPropCount;i++)
        {
            switch(lpPropArray[i].ulPropTag)
            {
            case PR_EMAIL_ADDRESS:
                lpPropEmail = &(lpPropArray[i]);
                break;
            case PR_ADDRTYPE:
                lpPropAddrType = &(lpPropArray[i]);
                break;
            case PR_CONTACT_EMAIL_ADDRESSES:
                lpPropMVEmail = &(lpPropArray[i]);
                break;
            case PR_CONTACT_ADDRTYPES:
                lpPropMVAddrType = &(lpPropArray[i]);
                break;
            case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
                lpPropDefaultIndex = &(lpPropArray[i]);
                break;
            }
        }

        // Assumption:
        // We must have a email address to work with even if we dont have
        // multiple email addresses
        if(lpPropEmail || lpPropMVEmail)
        {
            if(lpPropMVEmail)
            {
                // Assert(lpPropMVAddrType);

                //Assume, if this is present, so is MVAddrType, and defaultindex
                for(i=0;i<lpPropMVEmail->Value.MVSZ.cValues;i++)
                {
                    AddLVEmailItem( hWndLV,
                                    lpPropMVEmail->Value.MVSZ.LPPSZ[i],
                                    lpPropMVAddrType ? ((lpPropMVAddrType->Value.MVSZ.cValues > i) ? 
                                    lpPropMVAddrType->Value.MVSZ.LPPSZ[i] : (LPTSTR)szSMTP) : (LPTSTR)szSMTP);

                    if ( lpPropDefaultIndex && (i == (ULONG) lpPropDefaultIndex->Value.l) )
                    {
                        // This is the default one so set it ...
                        SetLVDefaultEmail(  hWndLV, i );
                    }
                }
            }
            else
            {
                LPTSTR lpszAddrType = NULL;
                // we dont have multi-valued props yet - lets use the
                // single valued ones and tag a change so that the record is
                // updated ...
                if (lpPropAddrType)
                    lpszAddrType = lpPropAddrType->Value.LPSZ;

                AddLVEmailItem( hWndLV,
                                lpPropEmail->Value.LPSZ,
                                lpszAddrType);

                // Flag that changes occured ...
                bChangesMade = TRUE;
            }

            if((ListView_GetItemCount(hWndLV)>0)&&(lpPai->ulOperationType != SHOW_ONE_OFF))
            {
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_REMOVE),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_SETDEFAULT),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_PERSONAL_BUTTON_EDIT),TRUE);
            }
        }
    }

    if(!*lpbChangesMade)
        *lpbChangesMade = bChangesMade;

    bRet = TRUE;

out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}

/*//$$***************************************************************************
*    FUNCTION: FillHomeBusinessNotesDetailsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillHomeBusinessNotesDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[nPropSheet] = TRUE;

    switch(nPropSheet)
    {
/************/
    case propHome:
        idPropCount = idPropHomeCount;
        lpidProp = idPropHome;
        lpidProp[idPropHomePostalID].ulPropTag = PR_WAB_POSTALID;
        goto FillProp;
/************/
    case propBusiness:
        idPropCount = idPropBusinessCount;
        lpidProp = idPropBusiness;
        lpidProp[idPropBusIPPhone].ulPropTag = PR_WAB_IPPHONE;
        lpidProp[idPropBusPostalID].ulPropTag = PR_WAB_POSTALID;
        goto FillProp;
/************/
    case propNotes:
        {
            // See if this is a folder member and update the folder name on this tab
            BOOL bParent = FALSE;
            if( lpPai->ulOperationType != SHOW_DETAILS )
            {
                SetDlgItemText(hDlg, IDC_DETAILS_NOTES_STATIC_FOLDER, szEmpty);
            }
            else
            {
                for(i=0;i<ulcPropCount;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_WAB_FOLDER_PARENT || lpPropArray[i].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP)
                    {
                        LPSBinary lpsbParent = &(lpPropArray[i].Value.MVbin.lpbin[0]);
                        LPWABFOLDER lpWABFolder = FindWABFolder((LPIAB)lpPai->lpIAB, lpsbParent, NULL, NULL);
                        if(lpWABFolder) // note if we didnt find the folder then the default  TEXT("Shared Contacts") name works fine
                        {
                            SetDlgItemText(hDlg, IDC_DETAILS_NOTES_STATIC_FOLDER, lpWABFolder->lpFolderName);
                            bParent = TRUE;
                        }
                        break;
                    }
                }
            }
            if(!bParent && !bDoesThisWABHaveAnyUsers((LPIAB)lpPai->lpIAB))
            {
                TCHAR sz[MAX_PATH];
                LoadString(hinstMapiX, idsContacts, sz, CharSizeOf(sz));
                SetDlgItemText(hDlg, IDC_DETAILS_NOTES_STATIC_FOLDER, sz);
            }

            // Find out all the groups in which this contact is a member ...
            //
            // if this is not a known entry id but is still non NULL ..
            //
            if( (0 == IsWABEntryID(lpPai->cbEntryID, lpPai->lpEntryID, NULL,NULL,NULL, NULL, NULL)) &&
                lpPai->cbEntryID && lpPai->lpEntryID)
            {
                // Only do this for WAB contacts
                TCHAR szBuf[MAX_BUF_STR];
                SPropertyRestriction PropRes = {0};
		        SPropValue sp = {0};
                HRESULT hr = E_FAIL;
                ULONG ulcCount = 0;
                LPSBinary rgsbEntryIDs = NULL;

		        sp.ulPropTag = PR_OBJECT_TYPE;
		        sp.Value.l = MAPI_DISTLIST;

                PropRes.ulPropTag = PR_OBJECT_TYPE;
                PropRes.relop = RELOP_EQ;
                PropRes.lpProp = &sp;

                szBuf[0] = TEXT('\0');

				// BUGBUG <JasonSo>: Need to pass in the current container here...
                hr = FindRecords(   ((LPIAB)lpPai->lpIAB)->lpPropertyStore->hPropertyStore,
									NULL, 0, TRUE, &PropRes, &ulcCount, &rgsbEntryIDs);

                if(!HR_FAILED(hr) && ulcCount)
                {
                    // Open all the groups and look at their contents
                    ULONG i,j,k;

                    for(i=0;i<ulcCount;i++)
                    {
                        ULONG ulcValues = 0;
                        LPSPropValue lpProps = NULL;
                        LPTSTR lpszName = NULL;

                        hr = HrGetPropArray(lpPai->lpIAB, NULL,
                                        rgsbEntryIDs[i].cb, (LPENTRYID) rgsbEntryIDs[i].lpb,
                                        MAPI_UNICODE,
                                        &ulcValues, &lpProps);
                        if(HR_FAILED(hr))
                            continue;

                        for(j=0;j<ulcValues;j++)
                        {
                            if (lpProps[j].ulPropTag == PR_DISPLAY_NAME)
                            {
                                lpszName = lpProps[j].Value.LPSZ;
                                break;
                            }
                        }

                        for(j=0;j<ulcValues;j++)
                        {
                            if(lpProps[j].ulPropTag == PR_WAB_DL_ENTRIES)
                            {
                                // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
                                for (k = 0; k < lpProps[j].Value.MVbin.cValues; k++)
                                {
                                    ULONG cbEID = lpProps[j].Value.MVbin.lpbin[k].cb;
                                    LPENTRYID lpEID = (LPENTRYID) lpProps[j].Value.MVbin.lpbin[k].lpb;
                                    if (cbEID == lpPai->cbEntryID) // <TBD> we should be checking if its a wab entryid
                                                                   // but we'll just compare sizes for now ...
                                    {
                                        if(!memcmp(lpPai->lpEntryID, lpEID, cbEID))
                                        {
                                            if( (lstrlen(szCRLF) + lstrlen(szBuf) + lstrlen(lpszName) + 1)<CharSizeOf(szBuf))
                                            {
                                                StrCatBuff(szBuf, lpszName, ARRAYSIZE(szBuf));
                                                StrCatBuff(szBuf, szCRLF, ARRAYSIZE(szBuf));
                                                break;
                                            }
                                        }
                                    }
                                }
                                break; // just wanted to look at PR_WAB_DL_ENTRIES
                            }
                        } // for (j...

                        if(lpProps)
                            MAPIFreeBuffer(lpProps);

                    } // for(i...

                } ///if ..

                FreeEntryIDs(((LPIAB)lpPai->lpIAB)->lpPropertyStore->hPropertyStore,
                             ulcCount,
                             rgsbEntryIDs);

                if(lstrlen(szBuf))
                    SetDlgItemText(hDlg, IDC_DETAILS_NOTES_EDIT_GROUPS, szBuf);

            }
        }
        idPropCount = idPropNotesCount;
        lpidProp = idPropNotes;

/************/
FillProp:
        // A very inefficient and lazy way of filling the UI
        for(i=0;i<idPropCount;i++)
        {
            for(j=0;j<ulcPropCount;j++)
            {
                if(lpPropArray[j].ulPropTag == lpidProp[i].ulPropTag)
                {
                    if(lpidProp[i].ulPropTag == PR_GENDER)
                    {
                        SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_SETCURSEL,
                                (WPARAM) lpPropArray[j].Value.i, 0);
                    }
                    else
                    if( lpidProp[i].ulPropTag == PR_WAB_POSTALID )
                    {
                        if(nPropSheet == propHome)
                            CheckDlgButton( hDlg, lpidProp[i].idCtl, 
                                            (lpPropArray[j].Value.l == ADDRESS_HOME)?BST_CHECKED:BST_UNCHECKED);
                        else if(nPropSheet == propBusiness)
                            CheckDlgButton( hDlg, lpidProp[i].idCtl, 
                                            (lpPropArray[j].Value.l == ADDRESS_WORK)?BST_CHECKED:BST_UNCHECKED);
                    }
                    else
                        SetDlgItemText(hDlg, lpidProp[i].idCtl, lpPropArray[j].Value.LPSZ);
                }
            }

        }
        break;
    }

    bRet = TRUE;
out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}


/*
-   FreeCertList - Frees the list of certificate items in memory
-
*
*/
void FreeCertList(LPCERT_ITEM * lppCItem)
{
    LPCERT_ITEM lpItem = NULL;
    if(!lppCItem)
        return;
    lpItem = *lppCItem;
    while(lpItem)
    {
        *lppCItem = lpItem->lpNext;
        FreeCertdisplayinfo(lpItem->lpCDI);
        if (lpItem->pcCert)
            CertFreeCertificateContext(lpItem->pcCert);
        LocalFree(lpItem);
        lpItem = *lppCItem;
    }
    *lppCItem = NULL;
}


/*//$$***************************************************************************
*    FUNCTION: FillCertTridentConfDetailsUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillCertTridentConfDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[nPropSheet] = TRUE;

    switch(nPropSheet)
    {
    case propCert:
        {
            //
            // Now we fill in the Certificate information
            // Cases that can exist are
            // - no certificates
            // - certificates
            //
            // First we search for all the props we need to fill in the email structure
            //
            LPSPropValue lpPropMVCert = NULL;
            BOOL bDefaultSet = FALSE;
            HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_CERT_LIST);
            HRESULT hr = S_OK;
            for(i=0;i<ulcPropCount;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_USER_X509_CERTIFICATE)
                {
                    lpPropMVCert = &(lpPropArray[i]);
                    break;
                }
            }
            // Fill the combo with email addresses
            FillCertComboWithEmailAddresses(hDlg, lpPai, NULL);
            hr = HrSetCertInfoInUI(hDlg, lpPropMVCert, lpPai);
            if(hr == MAPI_E_NOT_FOUND && lpPropMVCert)
            {
                // The cert prop seems to contain bogus data .. need to nuke it
                // 48750 : if there is no cert data, dont show a cert icon ..
                // Problem is that we're not entirely sure that just because we couldnt
                // interpret the data that it's invalid, what if there is aata we don't interpret .. ?
            }
            if(lpPropMVCert)
            {
                // Enable the combo, the properties button, and the export button
                //EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_LIST),TRUE);
                EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_COMBO),TRUE);
                //EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_PROPERTIES),TRUE);
                //EnableWindow(GetDlgItem(hDlg,IDC_DETAILS_CERT_BUTTON_EXPORT),TRUE);
            }
        }
        break;
/************/
    case propTrident:
        {
            HrInit(lpPai->lpIWABDocHost, hDlg, IDC_TRIDENT_WINDOW, dhbNone);
            {
                ULONG i;
                LPTSTR lp = NULL, lpURL = NULL, lpLabel = NULL;
                // Find the labeledURI property and parse it
                // This string property contains a URL followed by spaces followed by the label (RFC 2079)
                for(i=0;i<ulcPropCount;i++)
                {
                    if(lpPropArray[i].ulPropTag == PR_WAB_LDAP_LABELEDURI)
                    {
                        // isolate the URL and the label
                        // The URL is followed by spaces
                        lpURL = lp = lpPropArray[i].Value.LPSZ;
                        while(lp && *lp)
                        {
                            if (IsSpace(lp))
                            {
                                lpLabel = CharNext(lp);
                                *lp = '\0';
                                break;
                            }
                            else
                                lp = CharNext(lp);
                        }
                        // The above is the URL
                        // Label starts at first non space char
                        while(lpLabel && IsSpace(lpLabel))
                            lpLabel = CharNext(lpLabel);
                    }
                    // Since the trident pane is shown first, update the windows title
                    if(lpPropArray[i].ulPropTag == PR_DISPLAY_NAME)
                    {
                        lp = lpPropArray[i].Value.LPSZ;
                        if(lstrlen(lp))
                            SetWindowPropertiesTitle(GetParent(hDlg), lp);
                    }
                }
                if(lpLabel && lstrlen(lpLabel))
                    SetDlgItemText(hDlg, IDC_DETAILS_TRIDENT_STATIC_CAPTION, lpLabel);
                if(lpURL && lstrlen(lpURL))
                {
                    if(HR_FAILED(HrLoadURL(lpPai->lpIWABDocHost, lpURL)))
                    {
                        // remove this property sheet and set the focus to the first prop sheet
                        PropSheet_RemovePage(hDlg,lpPai->ulTridentPageIndex,NULL);
                        PropSheet_SetCurSel(hDlg, NULL, 0);
                    }
                    else
                        EnableWindow(GetDlgItem(GetParent(hDlg), IDOK), FALSE);
                }
            }
        }
        break;
/************/
    case propConferencing:
        {
            HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_LIST_SERVERS);
            HWND hWndCombo = GetDlgItem(hDlg, IDC_DETAILS_NTMTG_COMBO_EMAIL);

            FillComboWithEmailAddresses(lpPai, hWndCombo, NULL);

            // Fill in the conferencing related properties
            for(j=0;j<ulcPropCount;j++)
            {
                if(lpPropArray[j].ulPropTag == PR_WAB_CONF_SERVERS)
                {
                    LPSPropValue lpProp = &(lpPropArray[j]);
                    for(i=0;i<lpProp->Value.MVSZ.cValues; i++)
                    {
                        if(lstrlen(lpProp->Value.MVSZ.LPPSZ[i]) < lstrlen(szCallto))
                            continue; //ignore this one

                        // if this is a callto
                        if(!StrCmpNI(lpProp->Value.MVSZ.LPPSZ[i], szCallto, lstrlen(szCallto)))
                        {
                            LV_ITEM lvi = {0};
                            LPSERVER_ITEM lpSI = LocalAlloc(LMEM_ZEROINIT, sizeof(SERVER_ITEM));
                            if(lpSI)
                            {
                                ULONG cch = lstrlen(lpProp->Value.MVSZ.LPPSZ[i])+1;
                                LPTSTR lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cch);
                                ULONG cchEmail = lstrlen(lpProp->Value.MVSZ.LPPSZ[i])+1;
                                LPTSTR lpEmail = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchEmail);
                                if(lp && lpEmail)
                                {
                                    lvi.mask = LVIF_TEXT | LVIF_PARAM;
                                    StrCpyN(lp,lpProp->Value.MVSZ.LPPSZ[i],cch);
                                    *lpEmail = '\0';

                                    {
                                        // isolate just the server name by terminating
                                        // at the next '/'
                                        LPTSTR lp1 = lp + lstrlen(szCallto);
                                        StrCpyN(lp, lp1, cch);
                                        lp1 = lp;
                                        while(lp1 && *lp1 && *lp1!='/')
                                            lp1 = CharNext(lp1);
                                        if(*lp1 == '/')
                                        {
                                            StrCpyN(lpEmail, lp1+1, cchEmail);
                                            *lp1 = '\0';
                                        }
                                        // Now lpEmail contains the email text ...
                                        // Walk along lpEmail till we hit the next /,?.or \0 and terminate
                                        lp1 = lpEmail;
                                        while(lp1 && *lp1 && *lp1!='/' && *lp1!='?')
                                            lp1 = CharNext(lp1);
                                        if(*lp1 == '/' || *lp1 == '?')
                                            *lp1 = '\0';
                                    }
                                    lvi.pszText = lp;
                                    lpSI->lpServer = lp;
                                    lpSI->lpEmail = lpEmail;
                                    lvi.lParam = (LPARAM) lpSI;
                                    lvi.cchTextMax = lstrlen(lp)+1;
                                    lvi.iItem = ListView_GetItemCount(hWndLV);
                                    lvi.iSubItem = 0;
                                    ListView_InsertItem(hWndLV, &lvi);
                                    ListView_SetItemText(hWndLV, lvi.iItem, 1, lpEmail);
                                }
                            }
                        }
                    }
                    LVSelectItem(hWndLV, 0);
                    break;
                }
            }
            for(j=0;j<ulcPropCount;j++)
            {
                if(lpPropArray[j].ulPropTag == PR_WAB_CONF_BACKUP_INDEX)
                {
                    lpPai->nBackupServerIndex = lpPropArray[j].Value.l;
                    lpPai->szBackupServerName[0] = TEXT('\0');
                    SetBackupServer(hDlg, lpPai, lpPai->nBackupServerIndex, FALSE);
                }
                else if(lpPropArray[j].ulPropTag == PR_WAB_CONF_DEFAULT_INDEX)
                {
                    lpPai->nDefaultServerIndex = lpPropArray[j].Value.l;
                    lpPai->szDefaultServerName[0] = TEXT('\0');
                    SetDefaultServer(hDlg, lpPai, lpPai->nDefaultServerIndex, TRUE);
                }
            }

            // For LDAP servers we will have a single item in PR_SERVERS and no default, backup etc
            // So if there is a single item available, force the default setting
            if(ListView_GetItemCount(hWndLV) == 1 && lpPai->nDefaultServerIndex == -1)
            {
                LV_ITEM lvi = {0};
                lvi.mask = LVIF_PARAM;
                lvi.iItem = 0;
                if(ListView_GetItem(hWndLV, &lvi) && lvi.lParam)
                {
                    LPSERVER_ITEM lpSI = (LPSERVER_ITEM) lvi.lParam;
                    lpPai->nDefaultServerIndex = 0;
                    StrCpyN(lpPai->szDefaultServerName, lpSI->lpServer, lpPai->cchDefaultServerName);
                    SetDefaultServer(hDlg, lpPai, lpPai->nDefaultServerIndex, TRUE);
                }
            }
        }
        break;
    }

    bRet = TRUE;
out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}

/*
-   HrAddEmailToObj
-   Adds a single Email to the PropObj
*
*
*/
HRESULT HrAddEmailToObj(LPPROP_ARRAY_INFO lpPai, LPTSTR szEmail, LPTSTR szAddrType)
{
    ULONG ulcProps = 0, i =0;
    LPSPropValue lpProps = 0;
    HRESULT hr = S_OK;
    ULONG nMVEmailAddress = NOT_FOUND, nMVAddrTypes = NOT_FOUND, nEmailAddress = NOT_FOUND;
    ULONG nAddrType = NOT_FOUND, nDefaultIndex = NOT_FOUND;

    if(HR_FAILED(hr = lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,
                                                    &ulcProps, &lpProps)))
        goto out;

    // Check if the PR_CONTACT_EMAIL_ADDRESSES already exists ..
    // if it does, tag the email onto it
    // if it doesnt and there is no pr_email_address, we create both
    // else if there is PR_EMAIL address then we cretae contact_email_addresses

    for(i=0;i<ulcProps;i++)
    {
        switch(lpProps[i].ulPropTag)
        {
        case PR_EMAIL_ADDRESS:
            nEmailAddress = i;
            break;
        case PR_ADDRTYPE:
            nAddrType = i;
            break;
        case PR_CONTACT_EMAIL_ADDRESSES:
            nMVEmailAddress = i;
            break;
        case PR_CONTACT_ADDRTYPES:
            nMVAddrTypes = i;
            break;
        case PR_CONTACT_DEFAULT_ADDRESS_INDEX:
            nDefaultIndex = i;
            break;
        }
    }

    // if no e-mail address, just add the given prop as e-mail address and in mv e-mail addresses
    if(nEmailAddress == NOT_FOUND)
    {
        SPropValue spv[5];
        spv[0].ulPropTag = PR_EMAIL_ADDRESS;
        spv[0].Value.LPSZ = szEmail;
        spv[1].ulPropTag = PR_ADDRTYPE;
        spv[1].Value.LPSZ = szAddrType;
        spv[2].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
        spv[2].Value.MVSZ.cValues = 1;
        spv[2].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));
        if(spv[2].Value.MVSZ.LPPSZ)
            spv[2].Value.MVSZ.LPPSZ[0] = szEmail;
        spv[3].ulPropTag = PR_CONTACT_ADDRTYPES;
        spv[3].Value.MVSZ.cValues = 1;
        spv[3].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR));
        if(spv[3].Value.MVSZ.LPPSZ)
            spv[3].Value.MVSZ.LPPSZ[0] = szAddrType;
        spv[4].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
        spv[4].Value.l = 0;
        hr = lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, 5, (LPSPropValue)&spv, NULL);
        if(spv[2].Value.MVSZ.LPPSZ)
            LocalFree(spv[2].Value.MVSZ.LPPSZ);
        if(spv[3].Value.MVSZ.LPPSZ)
            LocalFree(spv[3].Value.MVSZ.LPPSZ);
        goto out;
    }
    else
    if(nMVEmailAddress == NOT_FOUND)
    {
        // we have an e-mail address but no contact-email-addresses
        // so we will need to create the contact e-mail addresses
        SPropValue spv[3];
        spv[0].ulPropTag = PR_CONTACT_EMAIL_ADDRESSES;
        spv[0].Value.MVSZ.cValues = 2;
        spv[0].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);
        if(spv[0].Value.MVSZ.LPPSZ)
        {
            spv[0].Value.MVSZ.LPPSZ[0] = lpProps[nEmailAddress].Value.LPSZ;
            spv[0].Value.MVSZ.LPPSZ[1] = szEmail;
        }
        spv[1].ulPropTag = PR_CONTACT_ADDRTYPES;
        spv[1].Value.MVSZ.cValues = 2;
        spv[1].Value.MVSZ.LPPSZ = LocalAlloc(LMEM_ZEROINIT, sizeof(LPTSTR)*2);
        if(spv[1].Value.MVSZ.LPPSZ)
        {
            spv[1].Value.MVSZ.LPPSZ[0] = (nAddrType == NOT_FOUND) ? (LPTSTR)szSMTP : lpProps[nAddrType].Value.LPSZ;
            spv[1].Value.MVSZ.LPPSZ[1] = szAddrType;
        }
        spv[2].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
        spv[2].Value.l = 0;
        hr = lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, 3, (LPSPropValue)&spv, NULL);
        if(spv[0].Value.MVSZ.LPPSZ)
            LocalFree(spv[0].Value.MVSZ.LPPSZ);
        if(spv[1].Value.MVSZ.LPPSZ)
            LocalFree(spv[1].Value.MVSZ.LPPSZ);
        goto out;
    }
    else
    {
        // tag on the new props to the end of the existing contact_address_types
        if(HR_FAILED(hr = AddPropToMVPString(lpProps,ulcProps, nMVEmailAddress, szEmail)))
        {
            DebugPrintError(( TEXT("AddPropToMVString Email failed: %x"),hr));
            goto out;
        }

        if(HR_FAILED(hr = AddPropToMVPString(lpProps, ulcProps, nMVAddrTypes, szAddrType)))
        {
            DebugPrintError(( TEXT("AddPropToMVString AddrType failed: %x"),hr));
            goto out;
        }
        hr = lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, ulcProps, lpProps, NULL);
    }
    
out:
    FreeBufferAndNull(&lpProps);
    return hr;
}

/*
-   ShowHideMapButton
-
*   The Expedia maps only work for US addresses right now .. therefore, if the current system locale
*   is not English-US, we will hide the button since we can't deal with international stuff just yet
*/
void ShowHideMapButton(HWND hWndButton)
{
    LCID lcid = GetUserDefaultLCID();
    
    switch (lcid)
    {
    case 0x0804: //chinese
    // case 0x0c04: //chinese - hongkong
    case 0x0411: //japanese
    case 0x0412: //korean
    case 0x0404: //taiwan
        EnableWindow(hWndButton, FALSE);
        ShowWindow(hWndButton, SW_HIDE);
        break;
    }
}

/*
-   ShowExpediaMAP
-   if there is sufficient address info in the supplied prop-obj, generate an expedia URL and shell exec it
*   Expedia currently handles US addresses differently from international ones so need to figure that one out <TBD>
*   bHome - TRUE if this is a home address
*/

// All spaces need to be replaced by '+'s
//
// Next two strings moved to resources
// const LPTSTR szExpediaTemplate =  TEXT("http://www.expediamaps.com/default.asp?Street=%1&City=%2&State=%4&Zip=%3");
// const LPTSTR szExpediaIntlTemplate =  TEXT("http://www.expediamaps.com/default.asp?Place=%2,%5"); //city,country
enum
{ 
    prStreet=0,
    prCity,
    prZip,
    prState,
    prCountry,
    prAddressMax,
};
void ShowExpediaMAP(HWND hDlg, LPMAPIPROP lpPropObj, BOOL bHome)
{
    ULONG ulcProps = 0;
    LPSPropValue lpProps = NULL;
    LPSPropTagArray lpta = (bHome ? (LPSPropTagArray)&ptaUIDetlsPropsHome : (LPSPropTagArray)&ptaUIDetlsPropsBusiness);

    if(!HR_FAILED(lpPropObj->lpVtbl->GetProps(  lpPropObj, lpta, MAPI_UNICODE, &ulcProps, &lpProps)))
    {
        LPTSTR lp[prAddressMax], lpURL = NULL;
        ULONG i,j, ulCount = 0;
        BOOL bUSAddress = FALSE;

        for(i=0;i<prAddressMax;i++)
        {
            if(lpProps[i].ulPropTag == lpta->aulPropTag[i])
            {
                ulCount++;
                lp[i] = lpProps[i].Value.LPSZ;
                // we need to replace all the spaces in these strings with '+'
                {
                    LPTSTR lpTemp = lp[i];
                    // need to knock out CRLFs
                    while(lpTemp && *lpTemp)
                    {
                        if(*lpTemp == '\r')
                        {
                            *lpTemp = '\0';
                            break;
                        }
                        lpTemp = CharNext(lpTemp);
                    }
                    lpTemp = lp[i];

                    while(lpTemp && *lpTemp)
                    {
                        if(IsSpace(lpTemp))
                        {
                            LPTSTR lpTemp2 = lpTemp;
                            lpTemp = CharNext(lpTemp);
                            *lpTemp2 = '+';
                            if(lpTemp != lpTemp2+1)
                                StrCpyN(lpTemp2+1, lpTemp, lstrlen(lpTemp)+1);
                            lpTemp = lpTemp2;
                        }
                        lpTemp = CharNext(lpTemp);
                    }
                }
            }
            else
                lp[i] = szEmpty;
        }
        // <TBD> - Determine if this address is a US address or not ..
        if( !lstrlen(lp[prCountry]) || //no country - assume it's US
            !lstrcmpi(lp[prCountry], TEXT("US")) ||
            !lstrcmpi(lp[prCountry], TEXT("U.S.")) ||
            !lstrcmpi(lp[prCountry], TEXT("USA")) ||
            !lstrcmpi(lp[prCountry], TEXT("U.S.A.")) ||
            !lstrcmpi(lp[prCountry], TEXT("America")) ||
            !lstrcmpi(lp[prCountry], TEXT("United States")) ||
            !lstrcmpi(lp[prCountry], TEXT("United States of America")) )
        {
            bUSAddress = TRUE;
        }
        if( (bUSAddress && (!lstrlen(lp[prStreet]) || ulCount<2)) ||
            (!bUSAddress && !lstrlen(lp[prCity]) && !lstrlen(lp[prCountry])) )
        {
            ShowMessageBox(hDlg, idsInsufficientAddressInfo, MB_ICONINFORMATION);
        }
        else
        {
            TCHAR szText[MAX_BUF_STR] = {0};
            TCHAR *pchWorldAddr = NULL;
            LoadString(hinstMapiX, bUSAddress ? idsExpediaURL : idsExpediaIntlURL, szText, MAX_BUF_STR);

            if(!bUSAddress )
            {
                //IE6 we need to change a little string for World map in Expedia
                ULONG cchWorldAddr = lstrlen(lp[prStreet]) + lstrlen(lp[prCity]) + 
                    lstrlen(lp[prState]) + lstrlen(lp[prCountry]) + 20;
                if(pchWorldAddr = LocalAlloc(LMEM_ZEROINIT, cchWorldAddr*sizeof(pchWorldAddr[0]))) // we need add also space and  commas
                {
                    BOOL fAddComma = FALSE;

/*                    if(lstrlen(lp[prStreet]))
                    {
                        StrCatBuff(pchWorldAddr, lp[prStreet], cchWorldAddr);
                        fAddComma = TRUE;
                    }*/

                    if(lstrlen(lp[prCity]))
                    {
                        if(fAddComma)
                            StrCatBuff(pchWorldAddr, TEXT(", "), cchWorldAddr);
                        StrCatBuff(pchWorldAddr, lp[prCity], cchWorldAddr);
                        fAddComma = TRUE;

                    }

                    if(lstrlen(lp[prState]))
                    {
                        if(fAddComma)
                            StrCatBuff(pchWorldAddr, TEXT(", "), cchWorldAddr);
                        StrCatBuff(pchWorldAddr, lp[prState], cchWorldAddr);
                        fAddComma = TRUE;

                    }
                    if(lstrlen(lp[prCountry]))
                    {
                        if(fAddComma)
                            StrCatBuff(pchWorldAddr, TEXT(", "), cchWorldAddr);
                        StrCatBuff(pchWorldAddr, lp[prCountry], cchWorldAddr);
                        fAddComma = TRUE;

                    }

                }
                lp[prCountry] = pchWorldAddr;
            }

            if (  FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
		                	      FORMAT_MESSAGE_ALLOCATE_BUFFER |
			                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                  szText,
			                      0,                    // stringid
			                      0,                    // dwLanguageId
			                      (LPTSTR)&lpURL,     // output buffer
			                      0,               
			                      (va_list *)lp))
            {
                //LPTSTR lpProperURL = NULL;
                //DWORD dw = lstrlen(lpURL)*3+1;
                DebugTrace( TEXT("Expedia URL: %s\n"),lpURL);
                //Need to canoncolize this URL just in case it has unsafe characters in it
                /*
                if(lpProperURL = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*dw)) // 3times bigger should be big enough
                {
                    if(!InternetCanonicalizeUrlA(lpURL, lpProperURL, &dw, 0))
                        DebugTrace( TEXT("Error converting URL:%d\n"),GetLastError());
                    if(lpProperURL && lstrlen(lpProperURL))
                    {
                        LocalFree(lpURL);
                        lpURL = lpProperURL;
                    }
                }
                */
                ShowURL(hDlg, 0, lpURL);
                LocalFreeAndNull(&lpURL);
                if(pchWorldAddr)
                    LocalFreeAndNull(&pchWorldAddr);
            }
        }
        MAPIFreeBuffer(lpProps);
    }
}   



/*//$$***********************************************************************
*    FUNCTION: fnRubyProc
*
-   WinProc for the RUBY dialog that lets the user enter the ruby first and last name
*
****************************************************************************/
enum 
{
    sFirst=0,
    sLast,
    sYomiFirst,
    sYomiLast,
    sMax
};

int rgIdPropPersonalRuby[] = 
{
    IDC_DETAILS_PERSONAL_EDIT_FIRSTNAME, 
    IDC_DETAILS_PERSONAL_EDIT_LASTNAME, 
    IDC_DETAILS_PERSONAL_STATIC_RUBYFIRST, 
    IDC_DETAILS_PERSONAL_STATIC_RUBYLAST, 
};

int rgIdPropRubyDlg[] = 
{
    IDC_RUBY_EDIT_FIRSTNAME,
    IDC_RUBY_EDIT_LASTNAME,
    IDC_RUBY_EDIT_YOMIFIRSTNAME,
    IDC_RUBY_EDIT_YOMILASTNAME,
};


INT_PTR CALLBACK fnRubyProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            LPTSTR * sz = (LPTSTR *) lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            EnumChildWindows(   hDlg, SetChildDefaultGUIFont, (LPARAM) 0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_YOMIFIRSTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_YOMILASTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_FIRSTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            SendMessage(GetDlgItem(hDlg,IDC_RUBY_EDIT_LASTNAME),EM_SETLIMITTEXT,(WPARAM) EDIT_LEN,0);
            {
                int i = 0;
                for(i=0;i<sMax;i++)
                {
                    if(lstrlen(sz[i]))
                        SetDlgItemText(hDlg, rgIdPropRubyDlg[i], sz[i]);
                }
            }
        }
        return TRUE;
        break;

/***
    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;
/****/

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:
            {
                LPTSTR * sz = (LPTSTR *) GetWindowLongPtr(hDlg, DWLP_USER);
                int i =0;
                for(i=0;i<sMax;i++)
                {
                    if(!GetDlgItemText(hDlg, rgIdPropRubyDlg[i], sz[i], EDIT_LEN))
                        sz[i][0] = TEXT('\0');
                }
            }
            EndDialog(hDlg, TRUE);
            break;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        }
        break;
    }
    return FALSE;
}


/*
-   ShoWRubyNameEntryDlg
-
*   Let's the user enter Ruby First and Ruby Last names
*
*/
void ShowRubyNameEntryDlg(HWND hDlg, LPPROP_ARRAY_INFO lpPai)
{
    LPTSTR sz[sMax];
    int i=0;
    for(i=0;i<sMax;i++) //Read the data off the person tab
    {
        if(sz[i] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*EDIT_LEN))
        {
            sz[i][0] = TEXT('\0');
            GetDlgItemText(hDlg, rgIdPropPersonalRuby[i], sz[i], EDIT_LEN);
        }
    }

    if(DialogBoxParam(hinstMapiX, MAKEINTRESOURCE(IDD_DIALOG_RUBY),
                    hDlg, fnRubyProc, (LPARAM)sz))
    {
        for(i=0;i<sMax;i++) // put it back in the personal tab
        {
            SetDlgItemText(hDlg, rgIdPropPersonalRuby[i], sz[i]);
            LocalFree(sz[i]);
        }
        lpPai->bSomethingChanged = TRUE;
    }
}




/*//$$***************************************************************************
*    FUNCTION: FillFamilyDetailsUI(HWND)
*
*    PURPOSE:  Fills in the data in the family tab
*
****************************************************************************/
BOOL FillFamilyDetailsUI(HWND hDlg, LPPROP_ARRAY_INFO lpPai, int nPropSheet, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0, k =0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    LPVOID lpBuffer = NULL;

    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(HR_FAILED(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, 
                                        (LPSPropTagArray)&ptaUIDetlsPropsFamily, 
                                        MAPI_UNICODE,
                                        &ulcPropCount, &lpPropArray)))
        goto out;

    lpPai->ulFlags |= DETAILS_Initializing;

    // Set the flag that this sheet was opened
    lpPai->bPropSheetOpened[propFamily] = TRUE;

    idPropCount = idPropFamilyCount;
    lpidProp = idPropFamily;

    // A very inefficient and lazy way of filling the UI
    for(i=0;i<idPropCount;i++)
    {
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpPropArray[j].ulPropTag == lpidProp[i].ulPropTag)
            {
                switch(lpidProp[i].ulPropTag)
                {
                case PR_GENDER:
                    SendDlgItemMessage(hDlg, IDC_DETAILS_HOME_COMBO_GENDER, CB_SETCURSEL,
                            (WPARAM) lpPropArray[j].Value.i, 0);
                    break;
                case PR_BIRTHDAY:
                case PR_WEDDING_ANNIVERSARY:
                    {
                        SYSTEMTIME st = {0};
                        FileTimeToSystemTime((FILETIME *) (&lpPropArray[j].Value.ft), &st);
                        SendDlgItemMessage(hDlg, lpidProp[i].idCtl,DTM_SETSYSTEMTIME, 
                                            (WPARAM) GDT_VALID, (LPARAM) &st);
                    }
                    break;
                case PR_CHILDRENS_NAMES:
                    for(k=0;k<lpPropArray[j].Value.MVSZ.cValues;k++)
                        AddLVNewChild(hDlg, lpPropArray[j].Value.MVSZ.LPPSZ[k]);
                    break;
                default:
                    SetDlgItemText(hDlg, lpidProp[i].idCtl, lpPropArray[j].Value.LPSZ);
                }
            }
        }
    }

    bRet = TRUE;
out:
    if(lpBuffer)
        LocalFreeAndNull(&lpBuffer);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    lpPai->ulFlags &= ~DETAILS_Initializing;

    return bRet;
}

/*
-   AddLVNewChild
-
-   Adds a new child to the list of children
-   Basically we will add an item called  TEXT("New Child") and then 
-   force an in-place edit on that item
-
-   It would be nice to have some image associated with this ListView, eg a Boy/Girl image
-   but that means having to cache seperate Boy/Girl data which would be a pain ..
-   
*
*/
void AddLVNewChild(HWND hDlg, LPTSTR lpName)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
    LV_ITEM lvi = {0};
    TCHAR szBuf[MAX_PATH];
    ULONG nLen;
    int nPos;
    LoadString(hinstMapiX, idsNewChild, szBuf, CharSizeOf(szBuf));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;
    lvi.pszText = lpName ? lpName : szBuf;
    lvi.cchTextMax = MAX_PATH;
    lvi.iItem = ListView_GetItemCount(hWndLV);
    lvi.iSubItem = 0;
    lvi.iImage = imgChild+(lvi.iItem%3);//just add a little color by using more than 1 different colored image
    nPos = ListView_InsertItem(hWndLV, &lvi);
    LVSelectItem(hWndLV, nPos);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_BUTTON_EDITCHILD), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD), TRUE);
    return;
}



/*//$$***********************************************************************
*    FUNCTION: fnFamilyProc
*
*    PURPOSE:  Callback function for handling the Family property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnFamilyProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        lpPAI->ulFlags |= DETAILS_Initializing;
        SetDetailsUI(hDlg, lpPAI, lpPAI->ulOperationType,propFamily);
        lpPAI->ulFlags &= ~DETAILS_Initializing;
        return TRUE;

    case WM_DESTROY:
        bRet = TRUE;
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDetlsHelpIDs );
        break;

    case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDetlsHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case CBN_SELCHANGE: //gender combo
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            lpPAI->ulFlags |= DETAILS_GenderChanged;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case EN_CHANGE: //some edit box changed - dont care which
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DETAILS_FAMILY_BUTTON_ADDCHILD:
            lpPAI->ulFlags |= DETAILS_ChildrenChanged;
            AddLVNewChild(hDlg, NULL);
            SendMessage(hDlg, WM_COMMAND, (WPARAM)IDC_DETAILS_FAMILY_BUTTON_EDITCHILD, 0);
            break;
        case IDC_DETAILS_FAMILY_BUTTON_EDITCHILD:
            lpPAI->ulFlags |= DETAILS_ChildrenChanged;
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
                SetFocus(hWndLV);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    int index = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                    HWND hWndEditLabel = ListView_EditLabel(hWndLV, index);
                    //SendMessage(hWndEditLabel, EM_LIMITTEXT, MAX_PATH, 0);
                }
            }
            break;
        case IDC_DETAILS_FAMILY_BUTTON_REMOVECHILD:
            lpPAI->ulFlags |= DETAILS_ChildrenChanged;
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN);
                if(ListView_GetSelectedCount(hWndLV)==1)
                {
                    int index = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED);
                    ListView_DeleteItem(hWndLV, index);
                    if(index >= ListView_GetItemCount(hWndLV))
                        index--;
                    LVSelectItem(hWndLV, index);
                }
            }
            break;
// [PaulHi] 12/4/98  Raid #58940
// This fix causes the system to go into an infinite message loop (stack overflow
// crash on intenational Win9X machines) with DBCS.  The fnPersonalProc property 
// sheet also doesn't handle this WM_COMMAND message, probably for the same reason.
// ESC still works correctly on this property sheet.
#if 0
/*
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
*/
#endif
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case DTN_DATETIMECHANGE: //change in the Month-Date-Time control
            if(lpPAI->ulFlags & DETAILS_Initializing)
                break;
            lpPAI->ulFlags |= DETAILS_DateChanged;
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            break;

        case LVN_BEGINLABELEDITA:
        case LVN_BEGINLABELEDITW:
            lpPAI->ulFlags |= DETAILS_EditingChild;
            break;

        case LVN_ENDLABELEDITA:
        case LVN_ENDLABELEDITW:
            {
                // After the user finishes editing the children's name, 
                HWND hWndLV = ((NMHDR FAR *)lParam)->hwndFrom;
                LV_ITEM lvi = ((LV_DISPINFO FAR *) lParam)->item;
                // if this is Win9x .. we'llget an LV_ITEMA here .. else a LV_ITEMW
                LPWSTR lpW = NULL;
                LPSTR lpA = NULL;
                if(!g_bRunningOnNT)
                {
                    lpA = (LPSTR)lvi.pszText;
                    lpW = ConvertAtoW(lpA);
                    lvi.pszText = lpW;
                }
                lpPAI->ulFlags &= ~DETAILS_EditingChild;
                if ((lvi.iItem >= 0) && lvi.pszText && (lstrlen(lvi.pszText)))
                {
                    ListView_SetItem(hWndLV, &lvi);
                }
                LocalFreeAndNull(&lpW);
                if(!g_bRunningOnNT)
                    ((LV_DISPINFO FAR *) lParam)->item.pszText = (LPWSTR)lpA; // reset it as we found it
            }
            break;

        case PSN_SETACTIVE:     //initialize
            FillFamilyDetailsUI(hDlg, lpPAI, propFamily, lpbSomethingChanged);
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropArray(hDlg, lpPAI, propFamily);
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN));
            lpPAI->ulFlags &= ~DETAILS_GenderChanged;
            lpPAI->ulFlags &= ~DETAILS_DateChanged;
            lpPAI->ulFlags &= ~DETAILS_ChildrenChanged;
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            if(lpPAI->ulFlags & DETAILS_EditingChild) 
            {
                ListView_EditLabel(GetDlgItem(hDlg, IDC_DETAILS_FAMILY_LIST_CHILDREN), -1);
                lpPAI->ulFlags &= ~DETAILS_EditingChild;
            }
            if (lpPAI->nRetVal  == DETAILS_RESET)
                lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }

        return TRUE;
    }

    return bRet;
}


/*
-   CreateDateTimePickerControl
-
*
*  Description: Creates and initializes the control on the specified window. The controls destination
*				size is that of the static rectangle IDC_CONTROL_RECT
*  Parameters: idFrame - a dummy static used in the dialog layout to set a size and position for the new control
*                   The original static is hidden 
*               idControl - the Control ID to assign to the control
*
*               We also need to make sure that the tab order stays sane, 
*  Returns: none 
*/
void CreateDateTimeControl(HWND hDlg, int idFrame, int idControl)
{
	RECT rectControl;
	SIZE sizeControl;
    HWND hWndDP = NULL;
    HWND hWndFrame = GetDlgItem(hDlg,idFrame);
	// Get bounding rectangle of control and convert to client coordinates
	GetWindowRect(hWndFrame,&rectControl);
    MapWindowPoints(NULL, hDlg, (LPPOINT) &rectControl, 2);
	
	sizeControl.cx = rectControl.right-rectControl.left;
	sizeControl.cy = rectControl.bottom-rectControl.top;
    // Do not use ScreenToClient(), use MapWindowPoints for mirroring.
    //	ScreenToClient(hDlg,&pointControl);

	// Create control which starts at pointControl extends to sizeControl
	// >> Start control specific
	hWndDP =  CreateWindowEx(   WS_EX_CLIENTEDGE,
                                DATETIMEPICK_CLASS,
                                NULL,
                                WS_CHILD|WS_VISIBLE|WS_TABSTOP|DTS_SHORTDATEFORMAT|DTS_SHOWNONE,
                                rectControl.left,
                                rectControl.top,
                        		sizeControl.cx,
                                sizeControl.cy,
                                hDlg,
                                (HMENU)IntToPtr(idControl), // control identifier
                                hinstMapiXWAB,
                                NULL);

	// Check if control was created
	if(hWndDP)
	{
        TCHAR szFormat[MAX_PATH];
        SYSTEMTIME st = {0};
        LoadString(hinstMapiX, idsDateTimeFormat, szFormat, CharSizeOf(szFormat));
        SendMessage(hWndDP, DTM_SETFORMAT, 0, (LPARAM)szFormat);
        SendMessage(hWndDP, DTM_SETSYSTEMTIME, (WPARAM) GDT_NONE, (LPARAM) &st);

        SetWindowPos(hWndDP, hWndFrame,0,0,0,0,SWP_NOSIZE | SWP_NOMOVE);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_dl.c ===
/**********************************************************************************
*
*
*   DL.C - contains functions for the DL dialog
*
*
*
*
*
*
*
**********************************************************************************/

#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;
// extern LPPROPERTYSHEET        gpfnPropertySheet;
// extern LP_CREATEPROPERTYSHEETPAGE gpfnCreatePropertySheetPage;

extern LPPROPERTYSHEET_A            gpfnPropertySheetA;
extern LP_CREATEPROPERTYSHEETPAGE_A gpfnCreatePropertySheetPageA;
extern LPPROPERTYSHEET_W            gpfnPropertySheetW;
extern LP_CREATEPROPERTYSHEETPAGE_W gpfnCreatePropertySheetPageW;

extern LPTSTR szHTTP;
extern BOOL bIsHttpPrefix(LPTSTR szBuf);
extern void ShowURL(HWND hWnd, int id,LPTSTR lpURL);
extern void ShowExpediaMAP(HWND hDlg, LPMAPIPROP lpPropObj, BOOL bHome);
extern void ShowHideMapButton(HWND hWndButton);
extern void SetHTTPPrefix(HWND hDlg, int id);
extern BOOL bIsIE401OrGreater();
extern ChangeLocaleBasedTabOrder(HWND hDlg, int nPropSheet);

static DWORD rgDLHelpIDs[] =
{
    IDC_DISTLIST_EDIT_GROUPNAME,    IDH_WAB_GROUPNAME,
    IDC_DISTLIST_STATIC_GROUPNAME,  IDH_WAB_GROUPNAME,
    IDC_DISTLIST_EDIT_NOTES,        IDH_WAB_NOTES,
    IDC_DISTLIST_STATIC_NOTES,      IDH_WAB_NOTES,
    IDC_DISTLIST_LISTVIEW,          IDH_WAB_GROUP_NAME_LIST,
    IDC_DISTLIST_FRAME_MEMBERS,     IDH_WAB_GROUP_NAME_LIST,
    IDC_DISTLIST_BUTTON_ADD,        IDH_WAB_ADD_GROUP_MEMBERS,
    IDC_DISTLIST_BUTTON_REMOVE,     IDH_WAB_DELETE_GROUP_MEMBERS,
    IDC_DISTLIST_BUTTON_PROPERTIES, IDH_WAB_GROUP_PROPERTIES,
    IDC_DISTLIST_BUTTON_ADDNEW,     IDH_WAB_ADD_NEW_GROUP_CONTACTS,

    IDC_DISTLIST_STATIC_COUNT,      IDH_WAB_ADD_NEW_GROUP_CONTACTS,
    IDC_DISTLIST_STATIC_ADD,        IDH_WAB_ADD_NEW_GROUP_CONTACTS,
    IDC_DISTLIST_STATIC_ADDNAME,    IDH_WAB_GROUP_NAME,
    IDC_DISTLIST_EDIT_ADDNAME,      IDH_WAB_GROUP_NAME,
    IDC_DISTLIST_STATIC_ADDEMAIL,   IDH_WAB_GROUP_EMAIL,
    IDC_DISTLIST_EDIT_ADDEMAIL,     IDH_WAB_GROUP_EMAIL,
    IDC_DISTLIST_BUTTON_ADDUPDATE,  IDH_WAB_GROUP_UPDATE,
    IDC_DISTLIST_BUTTON_UPDATECANCEL,     IDH_WAB_GROUP_CANCEL_EDIT,
    IDD_DISTLIST_OTHER,             IDH_WAB_ADD_NEW_GROUP_CONTACTS,
    IDC_DISTLIST_STATIC_STREET,     IDH_WAB_DETAILS_ADDRESS,
    IDC_DISTLIST_EDIT_ADDRESS,      IDH_WAB_DETAILS_ADDRESS,
    IDC_DISTLIST_STATIC_CITY,       IDH_WAB_DETAILS_CITY,
    IDC_DISTLIST_EDIT_CITY,         IDH_WAB_DETAILS_CITY,
    IDC_DISTLIST_STATIC_STATE,      IDH_WAB_DETAILS_STATE,
    IDC_DISTLIST_EDIT_STATE,        IDH_WAB_DETAILS_STATE,
    IDC_DISTLIST_STATIC_ZIP,        IDH_WAB_DETAILS_ZIP,
    IDC_DISTLIST_EDIT_ZIP,          IDH_WAB_DETAILS_ZIP,
    IDC_DISTLIST_STATIC_COUNTRY,    IDH_WAB_DETAILS_COUNTRY,
    IDC_DISTLIST_EDIT_COUNTRY,      IDH_WAB_DETAILS_COUNTRY,
    IDC_DISTLIST_STATIC_PHONE,      IDH_WAB_DETAILS_PHONE,
    IDC_DISTLIST_EDIT_PHONE,        IDH_WAB_DETAILS_PHONE,
    IDC_DISTLIST_STATIC_FAX,        IDH_WAB_DETAILS_FAX,
    IDC_DISTLIST_EDIT_FAX,          IDH_WAB_DETAILS_FAX,
    IDC_DISTLIST_STATIC_WEB,        IDH_WAB_DETAILS_WEBPAGE,
    IDC_DISTLIST_EDIT_URL,          IDH_WAB_DETAILS_WEBPAGE,
    IDC_DISTLIST_BUTTON_URL,        IDH_WAB_DETAILS_GO,
    IDC_DISTLIST_BUTTON_MAP,        IDH_WAB_BUSINESS_VIEWMAP,
    
    0,0
};


// forward declarations

INT_PTR CALLBACK fnDLProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK fnDLOtherProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam);
BOOL FillDLUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai,BOOL * lpbChangesMade);
BOOL GetDLFromUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai , BOOL bSomethingChanged, LPSPropValue * lppPropArray, LPULONG lpulcPropCount);
BOOL SetDLUI(HWND hDlg, int nPropSheet);
void RemoveSelectedDistListItems(HWND hWndLV, LPDL_INFO lpPai);
void AddDLMembers(HWND hwnd, HWND hWndLV, LPDL_INFO lpPai);
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index);




/****************************************************************************
*    FUNCTION: CreateDLPropertySheet(HWND)
*
*    PURPOSE:  Creates the DL property sheet
*
****************************************************************************/
INT_PTR CreateDLPropertySheet( HWND hwndOwner,
                           LPDL_INFO lpPropArrayInfo)
{
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    TCHAR szBuf[MAX_UI_STR];
    TCHAR szBuf2[MAX_UI_STR];

    ULONG ulTotal = 0;
    HPROPSHEETPAGE * lph = NULL;
    ULONG ulCount = 0;
    int i = 0;
    INT_PTR nRet = 0;

    ulTotal = propDLMax // Predefined ones +
            + lpPropArrayInfo->nPropSheetPages;

    lph = LocalAlloc(LMEM_ZEROINIT, sizeof(HPROPSHEETPAGE) * ulTotal);
    if(!lph)
        return FALSE;

    // DL
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = hinstMapiX;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DISTLIST);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = fnDLProc;
    LoadString(hinstMapiX, idsGroupTabName, szBuf, CharSizeOf(szBuf));
    psp.pszTitle = szBuf;
    psp.lParam = (LPARAM) lpPropArrayInfo;

    lph[ulCount] = gpfnCreatePropertySheetPage(&psp);
    if(lph[ulCount])
        ulCount++;

    // DL "Other"
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USETITLE;
    psp.hInstance = hinstMapiX;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DISTLIST_OTHER);
    psp.pszIcon = NULL;
    psp.pfnDlgProc = fnDLOtherProc;
    LoadString(hinstMapiX, idsGroupOtherTabName, szBuf, CharSizeOf(szBuf));
    psp.pszTitle = szBuf;
    psp.lParam = (LPARAM) lpPropArrayInfo;

    lph[ulCount] = gpfnCreatePropertySheetPage(&psp);
    if(lph[ulCount])
        ulCount++;

    // Start page is personal page
    psh.nStartPage = propGroup;

    // Now do the extended props if any
    for(i=0;i<lpPropArrayInfo->nPropSheetPages;i++)
    {
        if(lpPropArrayInfo->lphpages)
        {
            lph[ulCount] = lpPropArrayInfo->lphpages[i];
            ulCount++;
        }
    }

/*** US dialogs get truncated on FE OSes .. we want the comctl to fix the truncation
     but this is only implemented in IE4.01 and beyond .. the problem with this being 
     that wab is specifically compiled with the IE = 0x0300 so we're not pulling in the
     correct flag from the commctrl header .. so we will define the flag here and pray
     that commctrl never changes it ***/
#define PSH_USEPAGELANG         0x00200000  // use frame dialog template matched to page
/***                                ***/

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW;
    if(bIsIE401OrGreater())
        psh.dwFlags |= PSH_USEPAGELANG;
    psh.hwndParent = hwndOwner;
    psh.hInstance = hinstMapiX;
    psh.pszIcon = NULL;
    LoadString(hinstMapiX, IDS_DETAILS_CAPTION, szBuf2, CharSizeOf(szBuf2));
    psh.pszCaption = szBuf2;
    psh.nPages = ulCount; // ulProp //sizeof(psp) / sizeof(PROPSHEETPAGE);

    psh.phpage = lph;

    nRet = gpfnPropertySheet(&psh);

    if(lph) 
        LocalFree(lph);

    return nRet;
}


typedef struct _tagIDProp
{
    ULONG ulPropTag;
    int   idCtl;

} ID_PROP;



// Control IDs corresponding to the Personal property sheet

ID_PROP idPropDL[]=
{
    {PR_DISPLAY_NAME,   IDC_DISTLIST_EDIT_GROUPNAME},
};
const ULONG idPropDLCount = 1;

ID_PROP idPropDLOther[]=
{
    {PR_HOME_ADDRESS_STREET,    IDC_DISTLIST_EDIT_ADDRESS},
    {PR_HOME_ADDRESS_CITY,      IDC_DISTLIST_EDIT_CITY},
    {PR_HOME_ADDRESS_POSTAL_CODE,   IDC_DISTLIST_EDIT_ZIP},
    {PR_HOME_ADDRESS_STATE_OR_PROVINCE,   IDC_DISTLIST_EDIT_STATE},
    {PR_HOME_ADDRESS_COUNTRY,   IDC_DISTLIST_EDIT_COUNTRY},
    {PR_HOME_TELEPHONE_NUMBER,  IDC_DISTLIST_EDIT_PHONE},
    {PR_HOME_FAX_NUMBER,        IDC_DISTLIST_EDIT_FAX},
    {PR_PERSONAL_HOME_PAGE,     IDC_DISTLIST_EDIT_URL},
    {PR_COMMENT,                IDC_DISTLIST_EDIT_NOTES},
};
const ULONG idPropDLOtherCount = 9;



/****************************************************************************
*    FUNCTION: SetDLUI(HWND)
*
*    PURPOSE:  Sets up the UI for this PropSheet
*
****************************************************************************/
BOOL SetDLUI(HWND hDlg, int nPropSheet)
{
    ULONG i =0;
    ID_PROP * lpidProp;
    ULONG idCount;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);

    //HrInitListView(	hWndLV,LVS_REPORT | LVS_SORTASCENDING,FALSE);

    // Have to make this list view sorted
    if(nPropSheet == propGroup)
    {
        DWORD dwStyle;
        HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
        HrInitListView(	hWndLV,LVS_LIST,FALSE);
        dwStyle = GetWindowLong(hWndLV,GWL_STYLE);
        SetWindowLong(hWndLV,GWL_STYLE,dwStyle | LVS_SORTASCENDING);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_PROPERTIES),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_REMOVE),FALSE);
        EnableWindow(hWndLV, FALSE);
        lpidProp = idPropDL;
        idCount = idPropDLCount;
    }
    else if(nPropSheet == propGroupOther)
    {
        lpidProp = idPropDLOther;
        idCount = idPropDLOtherCount;
        ShowHideMapButton(GetDlgItem(hDlg, IDC_DISTLIST_BUTTON_MAP));
    }
    else
    {
        return FALSE;
    }


    //Set max input limits on the edit fields
    for(i=0;i<idCount;i++)
        SendMessage(GetDlgItem(hDlg,lpidProp[i].idCtl),EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR - 1,0);

    if(nPropSheet == propGroupOther)
    {
        SendMessage(GetDlgItem(hDlg,IDC_DISTLIST_EDIT_NOTES),EM_SETLIMITTEXT,(WPARAM) MAX_BUF_STR - 1,0);
        SetHTTPPrefix(hDlg, IDC_DISTLIST_EDIT_URL);
    }

    return TRUE;
}


/*
-
-   UpdateLVCount - shows a running count of how many members are in the ListView
*
*/
void UpdateLVCount(HWND hDlg)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
    HWND hWndStat =  GetDlgItem(hDlg, IDC_DISTLIST_STATIC_COUNT);

    int nCount = ListView_GetItemCount(hWndLV);

    if(nCount <= 0)
    {
        ShowWindow(hWndStat, SW_HIDE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_PROPERTIES),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_REMOVE),FALSE);
        EnableWindow(hWndLV, FALSE);
    }
    else
    {
        TCHAR sz[MAX_PATH];
        TCHAR szStr[MAX_PATH];
        LoadString(hinstMapiX, idsGroupMemberCount, szStr, CharSizeOf(sz));
        wnsprintf(sz, ARRAYSIZE(sz), szStr, nCount);
        SetWindowText(hWndStat, sz);
        ShowWindow(hWndStat, SW_SHOWNORMAL);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_PROPERTIES),TRUE);
        EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_REMOVE),TRUE);
        EnableWindow(hWndLV, TRUE);
    }
}

/****************************************************************************
*    FUNCTION: FillDLUI(HWND)
*
*    PURPOSE:  Fills in the dialog items on the property sheet
*
****************************************************************************/
BOOL FillDLUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai, BOOL * lpbChangesMade)
{
    ULONG i = 0,j = 0;
    BOOL bRet = FALSE;
    BOOL bChangesMade = FALSE;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    DWORD cchSize;
    
    if(lpPai->lpPropObj->lpVtbl->GetProps(lpPai->lpPropObj, NULL, MAPI_UNICODE,  &ulcPropCount, &lpPropArray))
        goto exit;

    if(nPropSheet == propGroup)
    {
        idPropCount = idPropDLCount;
        lpidProp = idPropDL;
    }
    else if(nPropSheet == propGroupOther)
    {
        idPropCount = idPropDLOtherCount;
        lpidProp = idPropDLOther;
    }

    for(i=0;i<idPropCount;i++)
    {
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpPropArray[j].ulPropTag == lpidProp[i].ulPropTag)
                SetDlgItemText(hDlg, lpidProp[i].idCtl, lpPropArray[j].Value.LPSZ);
            if( nPropSheet == propGroup &&
                lpidProp[i].idCtl == IDC_DISTLIST_EDIT_GROUPNAME &&
                lpPropArray[j].ulPropTag == PR_DISPLAY_NAME)
            {
                SetWindowPropertiesTitle(GetParent(hDlg), lpPropArray[j].Value.LPSZ);
                cchSize = lstrlen(lpPropArray[j].Value.LPSZ)+1;
                lpPai->lpszOldName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
                if(lpPai->lpszOldName)
                    StrCpyN(lpPai->lpszOldName,lpPropArray[j].Value.LPSZ,cchSize);
            }
        }

    }

    if(nPropSheet == propGroup)
    {
        HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
        for(j=0;j<ulcPropCount;j++)
        {
            if( lpPropArray[j].ulPropTag == PR_WAB_DL_ENTRIES  ||
                lpPropArray[j].ulPropTag == PR_WAB_DL_ONEOFFS   )
            {
                // Look at each entry in the PR_WAB_DL_ENTRIES and recursively check it.
                for (i = 0; i < lpPropArray[j].Value.MVbin.cValues; i++)
                {
                    AddWABEntryToListView(lpPai->lpIAB,
                                          hWndLV,
                                          lpPropArray[j].Value.MVbin.lpbin[i].cb,
									      (LPENTRYID)lpPropArray[j].Value.MVbin.lpbin[i].lpb,
                                          &(lpPai->lpContentsList));
                }
            }
        }

        // Select the first item ..
        if (ListView_GetItemCount(hWndLV) > 0)
            LVSelectItem(hWndLV, 0);
        UpdateLVCount(hDlg);
    }
    bRet = TRUE;

exit:

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return bRet;
}

extern BOOL bDoesEntryNameAlreadyExist(LPIAB lpIAB, LPTSTR lpsz);

//$$////////////////////////////////////////////////////////////////////////////
//
// bVerifyRequiredData
//
// Checks that all the data we are requesting has been filled up
// Returns CtrlID of the control that needs filling so we can set focus on it
//
/////////////////////////////////////////////////////////////////////////////////
BOOL bVerifyDLRequiredData(HWND hDlg, LPIAB lpIAB, LPTSTR szOldName, int * lpCtlID)
{
    TCHAR szBuf[2 * MAX_UI_STR];

    //
    // First check the required property (which is the GroupName)
    //
    *lpCtlID = 0;
    szBuf[0]='\0'; 
    GetDlgItemText(hDlg, IDC_DISTLIST_EDIT_GROUPNAME, szBuf, CharSizeOf(szBuf));
    TrimSpaces(szBuf);
    if(!lstrlen(szBuf))
    {
        ShowMessageBox(GetParent(hDlg), idsPleaseEnterGroupName, MB_ICONEXCLAMATION | MB_OK);
        *lpCtlID = IDC_DISTLIST_EDIT_GROUPNAME;
        return FALSE;
    }
    else
    {
        // Verify that this name does not already exist ..
        
        if( szOldName && lstrlen(szOldName) &&                          // we have an old name and
            lstrcmp(szBuf, szOldName) && !lstrcmpi(szBuf, szOldName))   // it's just a case change don't bother looking
            return TRUE;

        if(szOldName && !lstrcmp(szBuf, szOldName))
            return TRUE;

        if(bDoesEntryNameAlreadyExist(lpIAB, szBuf))
        {
            // the name already exists .. do don't let them use it ..
            ShowMessageBox(GetParent(hDlg), idsEntryAlreadyInWAB, MB_ICONEXCLAMATION | MB_OK);
            *lpCtlID = IDC_DISTLIST_EDIT_GROUPNAME;
            return FALSE;
        }
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////
//
//  GetDL from UI - reads the UI for its parameters and verifies that
//  all required fields are set.
//
//  bShowMsg is true when the user presses OK and we want to force a message
//      otherwise bShowMsg is false
//
////////////////////////////////////////////////////////////////////////////////
BOOL GetDLFromUI(HWND hDlg, int nPropSheet, LPDL_INFO lpPai , BOOL bSomethingChanged, LPSPropValue * lppPropArray, LPULONG lpulcPropCount)
{
    BOOL bRet = FALSE;

    TCHAR szBuf[2 * MAX_BUF_STR];
    LPTSTR lpszGroupName = NULL;

    ULONG ulcPropCount = 0,ulIndex=0;
    LPSPropValue lpPropArray = NULL;
    ULONG i =0;
    ID_PROP * lpidProp = NULL;
    ULONG idPropCount = 0;
    ULONG ulNotEmptyCount = 0;
    SCODE sc = S_OK;
    HRESULT hr = hrSuccess;
    LPRECIPIENT_INFO lpItem;

    *lppPropArray = NULL;
    *lpulcPropCount = 0;

    if(nPropSheet == propGroup)
    {
        idPropCount = idPropDLCount;
        lpidProp = idPropDL;
    }
    else if(nPropSheet == propGroupOther)
    {
        idPropCount = idPropDLOtherCount;
        lpidProp = idPropDLOther;
    }

    // The idea is to first count all the properties that have non-zero values
    // Then create a lpPropArray of that size and fill in the text from the props ..
    //
    if (!bSomethingChanged)
    {
        // nothing to do, no changes to save
        bRet = TRUE;
        goto out;
    }

    ulNotEmptyCount = 0;
    for(i=0;i<idPropCount;i++)
    {
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, CharSizeOf(szBuf));
        TrimSpaces(szBuf);
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
            ulNotEmptyCount++;
        if( lpidProp[i].idCtl == IDC_DISTLIST_EDIT_URL &&
            (lstrcmpi(szHTTP, szBuf)==0))
             ulNotEmptyCount--;
    }

    if (ulNotEmptyCount == 0)
    {
        // This prop sheet is empty ... ignore it
        bRet = TRUE;
        goto out;
    }

    ulcPropCount = ulNotEmptyCount;

    if(nPropSheet == propGroup && lpPai->lpContentsList)
    {
        ulcPropCount++; //For PR_WAB_DL_ENTRIES
        ulcPropCount++; //For PR_WAB_DL_ONEOFFS
    }

    sc = MAPIAllocateBuffer(sizeof(SPropValue) * ulcPropCount, &lpPropArray);

    if (sc!=S_OK)
    {
        DebugPrintError(( TEXT("Error allocating memory\n")));
        goto out;
    }


    ulIndex = 0; //now we reuse this variable as an index

    // Now read the props again and fill in the lpPropArray
    for(i=0;i<idPropCount;i++)
    {
        szBuf[0]='\0'; //reset
        GetDlgItemText(hDlg, lpidProp[i].idCtl, szBuf, CharSizeOf(szBuf));
        TrimSpaces(szBuf);
        if( lpidProp[i].idCtl == IDC_DISTLIST_EDIT_URL &&
            (lstrcmpi(szHTTP, szBuf)==0))
             continue;
        if(lstrlen(szBuf) && lpidProp[i].ulPropTag) //some text
        {
            ULONG nLen = (lstrlen(szBuf)+1);
            lpPropArray[ulIndex].ulPropTag = lpidProp[i].ulPropTag;
            sc = MAPIAllocateMore(sizeof(TCHAR)*nLen, lpPropArray, (LPVOID *) (&(lpPropArray[ulIndex].Value.LPSZ)));

            if (sc!=S_OK)
            {
                DebugPrintError(( TEXT("Error allocating memory\n")));
                goto out;
            }
            StrCpyN(lpPropArray[ulIndex].Value.LPSZ,szBuf,nLen);
            ulIndex++;
        }
    }

    if(nPropSheet == propGroup  && lpPai->lpContentsList)
    {
        LPPTGDATA lpPTGData=GetThreadStoragePointer();
        lpPropArray[ulIndex].ulPropTag = PR_WAB_DL_ENTRIES;
        lpPropArray[ulIndex].Value.MVbin.cValues = 0;
        lpPropArray[ulIndex].Value.MVbin.lpbin = NULL;
        lpPropArray[ulIndex+1].ulPropTag = PR_WAB_DL_ONEOFFS;
        lpPropArray[ulIndex+1].Value.MVbin.cValues = 0;
        lpPropArray[ulIndex+1].Value.MVbin.lpbin = NULL;
        // Now add the entry IDs to the DistList
        lpItem = lpPai->lpContentsList;
        while(lpItem)
        {
            BOOL bOneOff = (WAB_ONEOFF == IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID, NULL, NULL, NULL, NULL, NULL));
            if(pt_bIsWABOpenExSession)
                bOneOff = FALSE;
            if (HR_FAILED(hr = AddPropToMVPBin( lpPropArray, 
                                                bOneOff ? ulIndex+1 : ulIndex, 
                                                lpItem->lpEntryID, lpItem->cbEntryID,
                                                FALSE)))
            {
                DebugPrintError(( TEXT("AddPropToMVPBin -> %x\n"), GetScode(hr)));
                goto out;
            }
            lpItem = lpItem->lpNext;
        }
        if(lpPropArray[ulIndex].Value.MVbin.cValues == 0)
            lpPropArray[ulIndex].ulPropTag = PR_NULL;
        if(lpPropArray[ulIndex+1].Value.MVbin.cValues == 0)
            lpPropArray[ulIndex+1].ulPropTag = PR_NULL;
    }

    *lppPropArray = lpPropArray;
    *lpulcPropCount = ulcPropCount;

    bRet = TRUE;

out:
    if (!bRet)
    {
        if ((lpPropArray) && (ulcPropCount > 0))
        {
            MAPIFreeBuffer(lpPropArray);
            ulcPropCount = 0;
        }
    }
    return bRet;
}

/*
-
-  SetCancelOneOffUpdateUI - sets UI for Cancels/resets any update being done in the group
*
*/
void SetCancelOneOffUpdateUI(HWND hDlg, LPPROP_ARRAY_INFO lppai, LPTSTR lpName, LPTSTR lpEmail, BOOL bCancel)
{
    if(bCancel && lppai->ulFlags & DETAILS_EditingOneOff)
    {
        lppai->ulFlags &= ~DETAILS_EditingOneOff;
        lppai->sbDLEditingOneOff.cb = 0;
        LocalFreeAndNull((LPVOID *) (&(lppai->sbDLEditingOneOff.lpb)));
    }
    SetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDNAME, lpName ? lpName : szEmpty);
    SetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDEMAIL, lpEmail ? lpEmail : szEmpty);
    EnableWindow(GetDlgItem(hDlg, IDC_DISTLIST_BUTTON_UPDATECANCEL), !bCancel);
    ShowWindow(GetDlgItem(hDlg, IDC_DISTLIST_BUTTON_UPDATECANCEL), bCancel ? SW_HIDE : SW_SHOWNORMAL);
    {
        TCHAR sz[MAX_PATH];
        LoadString(hinstMapiX, bCancel ? idsConfAdd : idsConfUpdate, sz, CharSizeOf(sz));
        SetDlgItemText(hDlg, IDC_DISTLIST_BUTTON_ADDUPDATE, sz);
    }
    SendMessage(GetParent(hDlg), DM_SETDEFID, IDOK, 0);
}

/*
-   HrShowGroupEntryProperties - If selected entry is a one-off, shows special props on it else
-           cascades call down to regular call
*
*/
HRESULT HrShowGroupEntryProperties(HWND hDlg, HWND hWndLV, LPPROP_ARRAY_INFO lppai)
{
	HRESULT hr = E_FAIL;
	int iItemIndex = ListView_GetSelectedCount(hWndLV);
    LPRECIPIENT_INFO lpItem=NULL;
    BOOL bOneOff = FALSE;

	// Open props if only 1 item is selected
	if (iItemIndex == 1)
	{
		// Get index of selected item
        if((iItemIndex = ListView_GetNextItem(hWndLV,-1,LVNI_SELECTED)) != -1)
		{
			lpItem = GetItemFromLV(hWndLV, iItemIndex);;
			if(lpItem && lpItem->cbEntryID != 0)
			{
                if(WAB_ONEOFF == IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID,
                                         NULL, NULL, NULL, NULL, NULL))
                    bOneOff = TRUE;
            }
        }
    }

    if(!bOneOff)
    {
        // use our regular property processing 
        hr = HrShowLVEntryProperties(hWndLV, WAB_ONEOFF_NOADDBUTTON, lppai->lpIAB, NULL);
    }
    else
    {
        LPTSTR  lpName = NULL, lpEmail = NULL, lpAddrType = NULL;
        ULONG   ulMapiDataType = 0;
        
        // Deconstruct the entryid
        IsWABEntryID(lpItem->cbEntryID, lpItem->lpEntryID, &lpName, &lpAddrType, &lpEmail, (LPVOID *)&ulMapiDataType, NULL);

        // Set the flag marking that editing is in progress
        lppai->ulFlags |= DETAILS_EditingOneOff;
        // cache the item being edited so we can find it for updating
        LocalFreeAndNull((LPVOID *) (&((lppai->sbDLEditingOneOff).lpb)));
        SetSBinary(&(lppai->sbDLEditingOneOff), lpItem->cbEntryID, (LPBYTE)lpItem->lpEntryID);

        // [PaulHi] 3/4/99  Raid 73344
        // Check whether one off string data is ANSI or UNICODE
        if (!(ulMapiDataType & MAPI_UNICODE))
        {
            LPTSTR  lptszName = ConvertAtoW((LPSTR)lpName);
            LPTSTR  lptszAddrType = ConvertAtoW((LPSTR)lpAddrType);
            LPTSTR  lptszEmail = ConvertAtoW((LPSTR)lpEmail);

            SetCancelOneOffUpdateUI(hDlg, lppai, lptszName, lptszEmail, FALSE);

            LocalFreeAndNull(&lptszName);
            LocalFreeAndNull(&lptszAddrType);
            LocalFreeAndNull(&lptszEmail);
        }
        else
            SetCancelOneOffUpdateUI(hDlg, lppai, lpName, lpEmail, FALSE);

        SetFocus(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDNAME));
        SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDNAME), EM_SETSEL, 0, -1);
        hr = S_OK;
    }
    return hr;
}

/*
-
-   HrAddUpdateOneOffEntryToGroup - Adds or updates a one-off entry to a group
*       Status of a flag determines what the operation in progress is ..
*
*/
HRESULT HrAddUpdateOneOffEntryToGroup(HWND hDlg, LPPROP_ARRAY_INFO lppai)
{
    HRESULT hr = E_FAIL;
    TCHAR szName[MAX_UI_STR];
    TCHAR szEmail[MAX_UI_STR];
    ULONG cbEID = 0;
    LPENTRYID lpEID = NULL;
    HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);

    szName[0] = TEXT('\0');
    szEmail[0] = TEXT('\0');

    GetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDNAME, szName, CharSizeOf(szName));
    GetDlgItemText(hDlg, IDC_DISTLIST_EDIT_ADDEMAIL, szEmail, CharSizeOf(szEmail));

    if(!lstrlen(szName) && !lstrlen(szEmail))
    {
        ShowMessageBox(hDlg, idsIncompleteOneoffInfo, MB_ICONEXCLAMATION);
        return hr;
    }

    //Check the e-mail address here
    if(lstrlen(szEmail) && !IsInternetAddress(szEmail, NULL))
    {
        if(IDNO == ShowMessageBox(hDlg, idsInvalidInternetAddress, MB_ICONEXCLAMATION | MB_YESNO))
            return hr;
    }

    if(!lstrlen(szName) && lstrlen(szEmail))
        StrCpyN(szName, szEmail, ARRAYSIZE(szName));
    //else
    //if(!lstrlen(szEmail) && lstrlen(szName))
    //    StrCpyN(szEmail, szName, ARRAYSIZE(szEmail));

    if(!lstrlen(szEmail))
        szEmail[0] = TEXT('\0');

    if(HR_FAILED(hr = CreateWABEntryID(WAB_ONEOFF,
                          (LPVOID)szName, (LPVOID)szSMTP, (LPVOID)szEmail,
                          0, 0, NULL, &cbEID, &lpEID)))
      return hr;
    
    if(lppai->ulFlags & DETAILS_EditingOneOff)
    {
        // This is an edit in progress .. the edit is pretty similar to the normal ADD .. 
        // except we knock out the existing entry from the listview and add the modified entry to it 
        int i=0, nCount = ListView_GetItemCount(hWndLV);
        for(i=0;i<nCount;i++)
        {
            LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV,i);
            if( lpItem && lpItem->cbEntryID == lppai->sbDLEditingOneOff.cb &&
                !memcmp(lpItem->lpEntryID, lppai->sbDLEditingOneOff.lpb, lpItem->cbEntryID) )
            {
                // match
                // Select the item and then call the remove function
                LVSelectItem(hWndLV, i);
                RemoveSelectedDistListItems(hWndLV, lppai);
                break;
            }
        }
    }
        

    AddWABEntryToListView(lppai->lpIAB, hWndLV, cbEID, lpEID, &(lppai->lpContentsList));

    SetCancelOneOffUpdateUI(hDlg, lppai, NULL, NULL, TRUE);

    UpdateLVCount(hDlg);

    if(lpEID)
        MAPIFreeBuffer(lpEID);

    return S_OK;
}

enum _DLProp
{
    dlDisplayName=0,
    dlDLEntries,
    dlDLOneOffs,
    dlMax
};

//$$//////////////////////////////////////////////////////////////////////////////
//
// bUpdateOldPropTagArray
//
// For each prop sheet that is accessed, we will update the list of old prop tags
// for that sheet so that the old props can be knocked out of existing mailuser objects
//
//////////////////////////////////////////////////////////////////////////////////
BOOL bUpdateOldDLPropTagArray(LPPROP_ARRAY_INFO lpPai, int nIndex)
{
    LPSPropTagArray lpta = NULL;

    SizedSPropTagArray(3, ptaUIDetlsDL)=
    {
        3,
        {
            PR_DISPLAY_NAME,
            PR_WAB_DL_ENTRIES,
            PR_WAB_DL_ONEOFFS,
        }
    };

    SizedSPropTagArray(9, ptaUIDetlsDLOther)=
    {
        9,
        {
            PR_HOME_ADDRESS_STREET,
            PR_HOME_ADDRESS_CITY,
            PR_HOME_ADDRESS_POSTAL_CODE,
            PR_HOME_ADDRESS_STATE_OR_PROVINCE,
            PR_HOME_ADDRESS_COUNTRY,
            PR_HOME_TELEPHONE_NUMBER,
            PR_HOME_FAX_NUMBER,
            PR_PERSONAL_HOME_PAGE,
            PR_COMMENT,
        }
    };

    switch(nIndex)
    {
    case propGroup:
        lpta = (LPSPropTagArray) &ptaUIDetlsDL;
        break;
    case propGroupOther:
        lpta = (LPSPropTagArray) &ptaUIDetlsDLOther;
        break;
    }

    if(!lpta)
        return TRUE;

    if(lpPai->lpPropObj)
    {
        // Knock out these old props from the PropObject
        if( (lpPai->lpPropObj)->lpVtbl->DeleteProps( (lpPai->lpPropObj), lpta, NULL))
            return FALSE;
    }

    return TRUE;
}

//$$/////////////////////////////////////////////////////////////////////////
//
// bUpdatePropSheetData
//
// Every time the user switches pages, we update the globally accessible data
// The sheet will get PSN_KILLACTIVE when switching pages and PSN_APPLY when ok
// is pressed. A little bit of duplicated effort in the latter case but thats ok
//
/////////////////////////////////////////////////////////////////////////////
BOOL bUpdatePropSheetData(HWND hDlg, LPDL_INFO lpPai, int nPropSheet)
{
    BOOL bRet = TRUE;
    ULONG cValues = 0;
    LPSPropValue rgPropVals = NULL;

    // update old props to knock out
    //
    if (lpPai->ulOperationType != SHOW_ONE_OFF)
    {
        bUpdateOldDLPropTagArray(lpPai, nPropSheet);

        lpPai->bSomethingChanged = ChangedExtDisplayInfo(lpPai, lpPai->bSomethingChanged);

        if(lpPai->bSomethingChanged)
        {
            bRet = GetDLFromUI(hDlg, nPropSheet, lpPai, lpPai->bSomethingChanged, &rgPropVals, &cValues );

            if(cValues && rgPropVals)
                lpPai->lpPropObj->lpVtbl->SetProps(lpPai->lpPropObj, cValues, rgPropVals, NULL);
        }
    }    

    if(rgPropVals)
        MAPIFreeBuffer(rgPropVals);
    return bRet;
}


#define lpPAI ((LPDL_INFO) pps->lParam)
#define lpbSomethingChanged (&(lpPAI->bSomethingChanged))


void UpdateAddButton(HWND hDlg)
{
    BOOL    fEnable = TRUE;
    WPARAM  wpDefaultID = IDC_DISTLIST_BUTTON_ADDUPDATE;

    if (0 == GetWindowTextLength(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDNAME)) &&
        0 == GetWindowTextLength(GetDlgItem(hDlg, IDC_DISTLIST_EDIT_ADDEMAIL)))
    {
        fEnable = FALSE;
        wpDefaultID = IDOK;
    }

    EnableWindow(GetDlgItem(hDlg,IDC_DISTLIST_BUTTON_ADDUPDATE), fEnable);
    SendMessage(hDlg, DM_SETDEFID, wpDefaultID, 0);
}


/*//$$***********************************************************************
*    FUNCTION: fnHomeProc
*
*    PURPOSE:  Callback function for handling the HOME property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnDLProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;
    int CtlID = 0; //used to determine which required field in the UI has not been set

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;

        SetDLUI(hDlg, propGroup);
        (*lpbSomethingChanged) = FALSE;

        // Show Details if we need to ...
        if (    (lpPAI->ulOperationType == SHOW_DETAILS) ||
                (lpPAI->ulOperationType == SHOW_ONE_OFF)    )
        {
            FillDLUI(hDlg, propGroup, lpPAI, lpbSomethingChanged);
        }

        UpdateAddButton(hDlg);
        return TRUE;

    default:
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), message, wParam, lParam);
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDLHelpIDs );
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), message, wParam, lParam);
		break;

	case WM_CONTEXTMENU:
        {
            int id = GetDlgCtrlID((HWND)wParam);
            switch(id)
            {
            case IDC_DISTLIST_LISTVIEW:
    			ShowLVContextMenu(lvDialogABTo,(HWND)wParam, NULL, lParam, NULL,lpPAI->lpIAB, NULL);
                break;
            default:
                WABWinHelp((HWND) wParam,
                        g_szWABHelpFileName,
                        HELP_CONTEXTMENU,
                        (DWORD_PTR)(LPVOID) rgDLHelpIDs );
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if(LOWORD(wParam) == IDC_DISTLIST_EDIT_ADDNAME || LOWORD(wParam) == IDC_DISTLIST_EDIT_ADDEMAIL)
            {
                UpdateAddButton(hDlg);
                return 0;
                break;
            }
            else if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
            switch(LOWORD(wParam))
            { //update title as necessary
            case IDC_DISTLIST_EDIT_GROUPNAME:
                {
                    TCHAR szBuf[MAX_UI_STR];
                    GetWindowText((HWND) lParam,szBuf,CharSizeOf(szBuf));
                    SetWindowPropertiesTitle(GetParent(hDlg), szBuf);
                }
                break;
            }
            break;
        }
        switch(GET_WM_COMMAND_ID(wParam,lParam)) //check the notification code
        {
        default:
            return ProcessActionCommands((LPIAB) lpPAI->lpIAB, 
                                        GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), 
                                        hDlg, message, wParam, lParam);
            break;

        case IDC_DISTLIST_BUTTON_UPDATECANCEL:
            SetCancelOneOffUpdateUI(hDlg, lpPAI, NULL, NULL, TRUE);
            break;

        case IDC_DISTLIST_BUTTON_ADDUPDATE:
            HrAddUpdateOneOffEntryToGroup(hDlg, lpPAI);
            break;

        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;

        case IDM_LVCONTEXT_COPY:
            HrCopyItemDataToClipboard(hDlg, lpPAI->lpIAB, GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW));
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDC_DISTLIST_BUTTON_PROPERTIES:
            HrShowGroupEntryProperties(hDlg, GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), lpPAI);
            break;

        case IDM_LVCONTEXT_DELETE:
        case IDC_DISTLIST_BUTTON_REMOVE:
            RemoveSelectedDistListItems( GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW),lpPAI);
            UpdateLVCount(hDlg);
            break;

        case IDC_DISTLIST_BUTTON_ADD:
            AddDLMembers(hDlg, GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), lpPAI);
            UpdateLVCount(hDlg);
            break;

        case IDC_DISTLIST_BUTTON_ADDNEW:
            {
                HWND hWndLV = GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW);
                AddNewObjectToListViewEx( lpPAI->lpIAB, hWndLV, NULL, NULL,
                                        NULL,
                                        MAPI_MAILUSER,
                                        NULL, &(lpPAI->lpContentsList), NULL, NULL, NULL);
                UpdateLVCount(hDlg);
            }
            break;
        }
        break;



    case WM_NOTIFY:
#ifdef WIN16 // Enable context menu for WIN16
        if((int) wParam == IDC_DISTLIST_LISTVIEW && ((NMHDR FAR *)lParam)->code == NM_RCLICK)
        {
            POINT pt;

            GetCursorPos(&pt);
    	    ShowLVContextMenu(lvDialogABTo,((NMHDR FAR *)lParam)->hwndFrom, NULL, MAKELPARAM(pt.x, pt.y), NULL,lpPAI->lpIAB, NULL);
    	}
#endif // WIN16
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropSheetData(hDlg, lpPAI, propGroup);
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }

                if(!bVerifyDLRequiredData(hDlg, (LPIAB)lpPAI->lpIAB, lpPAI->lpszOldName, &CtlID))
                {
                    if (CtlID != 0) SetFocus(GetDlgItem(hDlg,CtlID));
                    //something failed ... abort this OK ... ie dont let them close
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
                bUpdatePropSheetData(hDlg, lpPAI, propGroup);
            }
            lpPAI->nRetVal = DETAILS_OK;
            SetCancelOneOffUpdateUI(hDlg, lpPAI, NULL, NULL, TRUE);
            ClearListView(GetDlgItem(hDlg,IDC_DISTLIST_LISTVIEW),
                          &(lpPAI->lpContentsList));
            break;

        case PSN_RESET:         //cancel
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            lpPAI->nRetVal = DETAILS_CANCEL;
            SetCancelOneOffUpdateUI(hDlg, lpPAI, NULL, NULL, TRUE);
            ClearListView(GetDlgItem(hDlg,IDC_DISTLIST_LISTVIEW),
                          &(lpPAI->lpContentsList));
            break;

	    case LVN_KEYDOWN:
            switch(wParam)
            {
            case IDC_DISTLIST_LISTVIEW:
                switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
                {
                case VK_DELETE:
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_DISTLIST_BUTTON_REMOVE, 0);
                    return 0;
                    break;
                }
                break;
            }
            break;

        case NM_DBLCLK:
            switch(wParam)
            {
            case IDC_DISTLIST_LISTVIEW:
                SendMessage(hDlg, WM_COMMAND, IDC_DISTLIST_BUTTON_PROPERTIES,0);
                break;
            }
            break;

	    case NM_CUSTOMDRAW:
            switch(wParam)
            {
            case IDC_DISTLIST_LISTVIEW:
                return ProcessLVCustomDraw(hDlg, lParam, TRUE);
                break;
	        }
            break;



        }

        return TRUE;
    }

    return bRet;

}



//$$///////////////////////////////////////////////////////////////////
//
// Removes all the items on the list view which are selected ...
//
//
//////////////////////////////////////////////////////////////////////
void RemoveSelectedDistListItems(HWND hWndLV, LPDL_INFO lpPai)
{
    int iItemIndex = ListView_GetNextItem(hWndLV, -1 , LVNI_SELECTED);
    int iLastItem = 0;

    while(iItemIndex != -1)
    {
        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);;

        if (lpItem)
        {
            if(lpItem->lpNext)
                lpItem->lpNext->lpPrev = lpItem->lpPrev;

            if(lpItem->lpPrev)
                lpItem->lpPrev->lpNext = lpItem->lpNext;

            if (lpPai->lpContentsList == lpItem)
                lpPai->lpContentsList = lpItem->lpNext;

            if (lpItem)
                FreeRecipItem(&lpItem);
        }

        ListView_DeleteItem(hWndLV, iItemIndex);

        iLastItem = iItemIndex;
        iItemIndex = ListView_GetNextItem(hWndLV, -1 , LVNI_SELECTED);
    }

    // Select the first item ..
    if (ListView_GetItemCount(hWndLV) <= 0)
    {
        HWND hWnd = GetParent(hWndLV);
        if (hWnd)
        {
            EnableWindow(GetDlgItem(hWnd,IDC_DISTLIST_BUTTON_PROPERTIES),FALSE);
            EnableWindow(GetDlgItem(hWnd,IDC_DISTLIST_BUTTON_REMOVE),FALSE);
        }
        EnableWindow(hWndLV, FALSE);
    }
    else
    {
        if(iLastItem > 0)
            iLastItem--;

        LVSelectItem(hWndLV, iLastItem);
    }

    return;

};


/***************************************************************************
//$$
    Name      : HrCreateAdrListFromLV

    Purpose   : Creates an AdrList from a List Views contents

    Parameters: lpIAB = adrbook
                hWndLV = hWnd of List View
                lpCOntentsList = ContentsList corresponding to the LV
                lppAdrList - returned AdrList ...

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrCreateAdrListFromLV(LPADRBOOK lpAdrBook,
                              HWND hWndLV,
                              LPADRLIST * lppAdrList)
{
    HRESULT hr = E_FAIL;
    ULONG nIndex = 0;
    LPADRLIST lpAdrList = NULL;
    SCODE sc = S_OK;
    int nEntryCount=0;
    LPRECIPIENT_INFO lpItem = NULL;
    int i = 0;



    if(!lppAdrList)
        goto out;
    else
        *lppAdrList = NULL;

    nEntryCount = ListView_GetItemCount(hWndLV);

    if (nEntryCount <= 0)
    {
        hr = S_OK;
        goto out;
    }

    sc = MAPIAllocateBuffer(sizeof(ADRLIST) + nEntryCount * sizeof(ADRENTRY),
                            &lpAdrList);

    if(FAILED(sc))
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    lpAdrList->cEntries = (ULONG) nEntryCount;

    nIndex = 0;

    for(i=nEntryCount;i>=0;i--)
    {
		LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, i);

        // Get item lParam LPRECIPIENT_INFO structure
        if (lpItem)
		{
            LPSPropValue rgProps = NULL;
            LPSPropValue lpPropArrayNew = NULL;
            ULONG cValues = 0;
            ULONG cValuesNew = 0;

            if (lpItem->cbEntryID != 0)
            {
                //resolved entry
                hr = HrGetPropArray(lpAdrBook,
                                    (LPSPropTagArray) &ptaResolveDefaults,
                                    lpItem->cbEntryID,
                                    lpItem->lpEntryID,
                                    MAPI_UNICODE,
                                    &cValues,
                                    &rgProps);

                if (!HR_FAILED(hr))
                {
                    SPropValue Prop = {0};
                    Prop.ulPropTag = PR_RECIPIENT_TYPE;
                    Prop.Value.l = MAPI_TO;

                    sc = ScMergePropValues( 1,
                                            &Prop,
                                            cValues,
                                            rgProps,
                                            &cValuesNew,
                                            &lpPropArrayNew);
                    if (sc != S_OK)
                    {
                        // oops this failed
                        if (lpPropArrayNew)
                            MAPIFreeBuffer(lpPropArrayNew);
                    }

                    //free rgProps
                    if (rgProps)
                        MAPIFreeBuffer(rgProps);

                    if(cValuesNew && lpPropArrayNew)
                    {
                        lpAdrList->aEntries[nIndex].cValues = cValuesNew;
                        lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
                        nIndex++;
                    }
                }
                else
                {
                    if(cValues && rgProps)
                        MAPIFreeBuffer(rgProps);
                } // if(!HR_F...
            } //if(lpItem->cbE...
        }//if(lpItem...
    } // for i...

    *lppAdrList = lpAdrList;

    hr = S_OK;

out:

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////
//
// Scans an Adrlist for dupes - only scans the first nUpto entries since
// whenever we start adding an entry, we will only check vs its peers
//
// Returns TRUE if Dupe found
//      FALSE if no Dupe found
////////////////////////////////////////////////////////////////////////////
BOOL CheckForDupes( LPADRLIST lpAdrList,
                    int nUpto,
                    LPSBinary lpsbEntryID)
{
    BOOL bDupeFound = FALSE;

    int i;

    for(i=0;i<nUpto;i++)
    {
        LPSBinary lpsb = FindAdrEntryID(lpAdrList, i);
        if (lpsb)
        {
            if(lpsb->cb == lpsbEntryID->cb)
            {
                if(!memcmp(lpsb->lpb, lpsbEntryID->lpb, lpsb->cb))
                {
                    bDupeFound = TRUE;
                    break;
                }
                else if (lpsb->cb == SIZEOF_WAB_ENTRYID)
                {
                    // sometimes we dont find the match if we just replaced an entryid
                    // case to DWORDS and compare
                    DWORD dw1 = 0;
                    DWORD dw2 = 0;
                    CopyMemory(&dw1, lpsb->lpb, SIZEOF_WAB_ENTRYID);
                    CopyMemory(&dw2, lpsbEntryID->lpb, SIZEOF_WAB_ENTRYID);
                    if(dw1 == dw2)
                    {
                        bDupeFound = TRUE;
                        break;
                    }
                }

            }
        }
    }

    return bDupeFound;
}

/***************************************************************************

    Name      : AddDLMembers

    Purpose   : Shows Select Members dialog and adds selections to ListView

    Parameters: hWnd = hWndParent
                hWndLV hWnd of List View
                lpPai = DistList Info

    Returns   : void

    Comment   :

***************************************************************************/
void AddDLMembers(HWND hwnd, HWND hWndLV, LPDL_INFO lpPai)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    ADRPARM AdrParms = {0};
    HRESULT hResult = hrSuccess;
    LPADRLIST lpAdrList = NULL;
    ULONG i = 0;
    LPSBinary lpsbEntryID;
    LPADRBOOK lpAdrBook = lpPai->lpIAB;
    TCHAR szCaption[MAX_UI_STR];
    TCHAR szWellTitle[MAX_DISPLAY_NAME_LENGTH];
    TCHAR szMemberTitle[MAX_DISPLAY_NAME_LENGTH];
    LPTSTR lpszDT[1];
    HCURSOR hOldCur = NULL;

    LoadString(hinstMapiX, idsGroupAddCaption, szCaption, CharSizeOf(szCaption));
    LoadString(hinstMapiX, idsGroupAddWellButton, szWellTitle, CharSizeOf(szWellTitle));
    LoadString(hinstMapiX, idsGroupDestWellsTitle, szMemberTitle, CharSizeOf(szMemberTitle));

    // TBe - this is temp
    AdrParms.ulFlags = DIALOG_MODAL | MAPI_UNICODE;
    AdrParms.lpszCaption = szCaption;
    AdrParms.cDestFields = 1;
    AdrParms.lpszDestWellsTitle = szMemberTitle;
    lpszDT[0]=szWellTitle;
    AdrParms.lppszDestTitles = lpszDT;

    hResult = HrCreateAdrListFromLV(lpAdrBook,
                                    hWndLV,
                                    &lpAdrList);

    if(HR_FAILED(hResult))
    {
        // no need to fail here .. keep going
        lpAdrList = NULL;
    }

    hResult = lpAdrBook->lpVtbl->Address(lpAdrBook,
                                        (PULONG_PTR)&hwnd,
                                        &AdrParms,
                                        &lpAdrList);

    if (! hResult && lpAdrList)
    {
        BOOL bFirstNonWABEntry = FALSE;

        pt_bDisableParent = TRUE;

        hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
        // Clear out the list view ...
        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) FALSE, 0);
        ClearListView(hWndLV, &(lpPai->lpContentsList));

        for (i = 0; i < lpAdrList->cEntries; i++)
        {
            if (lpsbEntryID = FindAdrEntryID(lpAdrList, i))
            {
                if(!CheckForDupes(lpAdrList, i, lpsbEntryID))
                {
                    ULONG cbEID = lpsbEntryID->cb;
                    LPENTRYID lpEID = (LPENTRYID)lpsbEntryID->lpb;
                    ULONG cbNewEID = 0;
                    LPENTRYID lpNewEID = NULL;

                    // if we have picked any entries from an LDAP server, we need
                    // to save these entries to the WAB before we can add them to this group.
                    if(WAB_LDAP_MAILUSER == IsWABEntryID(cbEID,
                                                         lpEID,
                                                         NULL,NULL,NULL, NULL, NULL))
                    {
                        HRESULT hr = S_OK;

                        // Add this entry to the WAB
                        if(!bFirstNonWABEntry)
                        {
                            bFirstNonWABEntry = TRUE;
                            ShowMessageBox(hwnd, idsNowAddingToWAB, MB_OK | MB_ICONINFORMATION);
                        }

                        hr = HrEntryAddToWAB(lpAdrBook,
                                            hwnd,
                                            cbEID,
                                            lpEID,
                                            &cbNewEID,
                                            &lpNewEID);

                        if(HR_FAILED(hr) || (!cbNewEID && !lpNewEID))
                        {
                            continue;
                        }

                        lpEID = lpNewEID;
                        cbEID = cbNewEID;

                        // if this newly added entry just replaced something already in the group,
                        // just go ahead and continue without changing anything else ...
                        {
                            SBinary SB = {0};
                            SB.cb = cbEID;
                            SB.lpb = (LPBYTE) lpEID;
                            if(CheckForDupes(lpAdrList, lpAdrList->cEntries, &SB))
                            {
                                continue;
                            }
                        }
                    }

                    if (CheckForCycle(  lpAdrBook,
                                        lpEID,
                                        cbEID,
                                        lpPai->lpEntryID,
                                        lpPai->cbEntryID))
                    {
                        DebugTrace( TEXT("DLENTRY_SaveChanges found cycle\n"));
                        {
                            LPTSTR lpszGroup=NULL;
                            ULONG k;
                            for(k=0;k<lpAdrList->aEntries[i].cValues;k++)
                            {
                                if (lpAdrList->aEntries[i].rgPropVals[k].ulPropTag == PR_DISPLAY_NAME)
                                {
                                    lpszGroup = lpAdrList->aEntries[i].rgPropVals[k].Value.LPSZ;
                                    break;
                                }
                            }
                            if(lpszGroup)
                            {
                                // TEXT("Could not add group %s to this group because group %s already contains this Group.")
                                ShowMessageBoxParam(hwnd, idsCouldNotAddGroupToGroup, MB_ICONERROR, lpszGroup);
                            }
                        }

                        if(lpNewEID)
                            MAPIFreeBuffer(lpNewEID);

                        continue;
                    }

                    AddWABEntryToListView(lpAdrBook,
                                          hWndLV,
                                          cbEID,
									      lpEID,
                                          &(lpPai->lpContentsList));

                    if(lpNewEID)
                        MAPIFreeBuffer(lpNewEID);

                    // Since LDAP entries take longer to add to the WAB, we will
                    // update the UI between additions if adding from LDAP so user
                    // knows that something is happening ...
                    if ((ListView_GetItemCount(hWndLV) > 0) &&
                        bFirstNonWABEntry )
                    {
                        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_PROPERTIES),TRUE);
                        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_REMOVE),TRUE);
                        EnableWindow(hWndLV, TRUE);
                        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
                    }
                }
            }
        }

        SendMessage(hWndLV, WM_SETREDRAW, (WPARAM) TRUE, 0);
    }



    if (ListView_GetItemCount(hWndLV) > 0)
    {
        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_PROPERTIES),TRUE);
        EnableWindow(GetDlgItem(hwnd,IDC_DISTLIST_BUTTON_REMOVE),TRUE);
        EnableWindow(hWndLV, TRUE);
    }

    UpdateWindow(hWndLV);

    if(lpAdrList)
        FreePadrlist(lpAdrList);

    if(hOldCur)
        SetCursor(hOldCur);

    pt_bDisableParent = FALSE;

    return;

}


/***************************************************************************

    Name      : FindAdrEntryID

    Purpose   : Find the PR_ENTRYID in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at

    Returns   : return pointer to the SBinary structure of the ENTRYID value

    Comment   :

***************************************************************************/
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == PR_ENTRYID) {
                return((LPSBinary)&lpAdrEntry->rgPropVals[i].Value);
            }
        }
    }
    return(NULL);
}




/*//$$***********************************************************************
*    FUNCTION: fnDLOtherProc
*
*    PURPOSE:  Callback function for handling the OTHER property sheet ...
*
****************************************************************************/
INT_PTR CALLBACK fnDLOtherProc(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam)
{
    PROPSHEETPAGE * pps;
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;
    int CtlID = 0; //used to determine which required field in the UI has not been set

    pps = (PROPSHEETPAGE *) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg,DWLP_USER,lParam);
        pps = (PROPSHEETPAGE *) lParam;
        ChangeLocaleBasedTabOrder(hDlg, groupOther);
        SetDLUI(hDlg, propGroupOther);
        (*lpbSomethingChanged) = FALSE;

        // Show Details if we need to ...
        if (    (lpPAI->ulOperationType == SHOW_DETAILS) ||
                (lpPAI->ulOperationType == SHOW_ONE_OFF)    )
        {
            FillDLUI(hDlg, propGroupOther, lpPAI, lpbSomethingChanged);
        }
        return TRUE;

    default:
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_DISTLIST_LISTVIEW), message, wParam, lParam);
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgDLHelpIDs );
        break;

	case WM_CONTEXTMENU:
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgDLHelpIDs );
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
        {
        case EN_CHANGE: //some edit box changed - dont care which
            if (lpbSomethingChanged)
                (*lpbSomethingChanged) = TRUE;
        }
        switch(GET_WM_COMMAND_ID(wParam,lParam)) //check the notification code
        {
        case IDCANCEL:
            // This is a windows bug that prevents ESC canceling prop sheets
            // which have MultiLine Edit boxes KB: Q130765
            SendMessage(GetParent(hDlg),message,wParam,lParam);
            break;
        case IDC_DISTLIST_BUTTON_MAP:
            bUpdatePropSheetData(hDlg, lpPAI, propGroupOther);
            ShowExpediaMAP(hDlg, lpPAI->lpPropObj, TRUE);
            break;

        case IDC_DISTLIST_BUTTON_URL:
            ShowURL(hDlg, IDC_DISTLIST_EDIT_URL,NULL);
            break;
        }
        break;

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //initialize
            break;

        case PSN_KILLACTIVE:    //Losing activation to another page
            bUpdatePropSheetData(hDlg, lpPAI, propGroupOther);
            break;

        case PSN_APPLY:         //ok
            if (lpPAI->ulOperationType != SHOW_ONE_OFF)
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }

                bUpdatePropSheetData(hDlg, lpPAI, propGroupOther);
            }
            lpPAI->nRetVal = DETAILS_OK;
            break;

        case PSN_RESET:         //cancel
            {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_bDisableParent)
                {
                    SetWindowLongPtr(hDlg,DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
            }
            lpPAI->nRetVal = DETAILS_CANCEL;
            break;
        }
        return TRUE;
    }
    return bRet;
}




/*
-   HrAssociateOneOffGroupMembersWithContacts()
-
*   Takes a group .. opens it up .. looks at all the one-off members
*   in the group, tries to match them up with corresponding entries that
*   have the same PR_DEFAULT_EMAIL address and for the ones that match,
*   removes the one-off entry and adds the entryid of the match to the group
*
*   lpsbGroupEID - EntryID of the Group
*   lpDistList - already open Distribution List object .. you can pass in 
*       either the entryid or the already opened object. If you pass in an 
*       open object, this function will not call SaveChanges on it. SaveChanges
*       is callers responsibility
*/
HRESULT HrAssociateOneOffGroupMembersWithContacts(LPADRBOOK lpAdrBook, 
                                                  LPSBinary lpsbGroupEID,
                                                  LPDISTLIST lpDistList)
{
    HRESULT hr = E_FAIL;

    SizedSPropTagArray(3, ptaDL)=
    {
        3,
        {
            PR_DISPLAY_NAME,
            PR_WAB_DL_ENTRIES,
            PR_WAB_DL_ONEOFFS,
        }
    };

    SizedSPropTagArray(1, ptaEmail)= { 1, { PR_EMAIL_ADDRESS } };

    ULONG ulcValues = 0, i,ulCount = 0;
    int j = 0;
    LPSPropValue lpProps = NULL;
    LPDISTLIST lpDL = NULL;
    ULONG ulObjType = 0;
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    BOOL * lpbRemove = NULL;

    if(!lpDistList && (!lpsbGroupEID || !lpsbGroupEID->cb || !lpsbGroupEID->lpb) )
        goto out;

    if(lpDistList)
        lpDL = lpDistList;
    else
    {
        if (HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                        lpsbGroupEID->cb,    // cbEntryID
                                                        (LPENTRYID)lpsbGroupEID->lpb,    // entryid
                                                        NULL,         // interface
                                                        MAPI_MODIFY,                // ulFlags
                                                        &ulObjType,       // returned object type
                                                        (LPUNKNOWN *)&lpDL)))
        {
            // Failed!  Hmmm.
            DebugTraceResult( TEXT("Address: IAB->OpenEntry:"), hr);
            goto out;
        }
        Assert(lpDL);

        if(ulObjType != MAPI_DISTLIST)
            goto out;
    }

    if (HR_FAILED(hr = lpDL->lpVtbl->GetProps(lpDL,(LPSPropTagArray)&ptaDL,
                                                    MAPI_UNICODE, &ulcValues, &lpProps)))
    {
        DebugTraceResult( TEXT("Address: IAB->GetProps:"), hr);
        goto out;
    }

    // Check if this one has the one-offs prop or not
    if( ulcValues < dlMax ||
        lpProps[dlDLOneOffs].ulPropTag != PR_WAB_DL_ONEOFFS  ||
        lpProps[dlDLOneOffs].Value.MVbin.cValues == 0)
        goto out;

    ulCount = lpProps[dlDLOneOffs].Value.MVbin.cValues;
    lpbRemove = LocalAlloc(LMEM_ZEROINIT, sizeof(BOOL)*ulCount);
    if(!lpbRemove)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }

    for(i=0;i<ulCount;i++)
    {
        LPSBinary lpsb = &(lpProps[dlDLOneOffs].Value.MVbin.lpbin[i]);
        ULONG ulc = 0;
        LPSPropValue lpsp = NULL;
        lpbRemove[i]=FALSE;
        if(!HR_FAILED(hr = HrGetPropArray(lpAdrBook, (LPSPropTagArray)&ptaEmail, lpsb->cb, (LPENTRYID)lpsb->lpb,
                                        MAPI_UNICODE,
                                        &ulc, &lpsp)))
        {
            if(ulc == 1 && lpsp[0].ulPropTag == PR_EMAIL_ADDRESS &&
                lpsp[0].Value.LPSZ && lstrlen(lpsp[0].Value.LPSZ))
            {
                // got an e-mail address .. see if it resolves uniquely or not
                ULONG ulMatch = 0;
                LPSBinary rgsbEntryIDs = NULL;
                if(!HR_FAILED(HrFindFuzzyRecordMatches(lpIAB->lpPropertyStore->hPropertyStore,
                                                        NULL,
                                                        lpsp[0].Value.LPSZ,
                                                        AB_FUZZY_FIND_EMAIL | AB_FUZZY_FAIL_AMBIGUOUS,
                                                        &ulMatch,
                                                        &rgsbEntryIDs)))
                {
                    // Note: there is a problem with the above search is that
                    // ed@hotmail.com will uniquely match ted@hotmail.com since its a 
                    // substring search used
                    //
                    if(ulMatch == 1)
                    {
                        // Single unique match .. use it
                        // Reset this entryid in the original DL_ONEOFF props and
                        // set the found entryid in the DL_ENTRIES prop

                        // For now, mark the one-off as having 0 size .. we will clean this up
                        // after we've gone through this loop once
                        lpbRemove[i] = TRUE;
                        AddPropToMVPBin(lpProps, dlDLEntries, rgsbEntryIDs[0].lpb, rgsbEntryIDs[0].cb, TRUE);
                    }
                    FreeEntryIDs(lpIAB->lpPropertyStore->hPropertyStore, ulMatch, rgsbEntryIDs);
                }
            }
            FreeBufferAndNull(&lpsp);
        }
    }
    // Now we've hopefully gone and changed everything, clean up the original list of oneoffs
    ulCount = lpProps[dlDLOneOffs].Value.MVbin.cValues;
    for(j=ulCount-1;j>=0;j--)
    {
        if(lpbRemove[j] == TRUE)
        {
            LPSBinary lpsb = &(lpProps[dlDLOneOffs].Value.MVbin.lpbin[j]);
            RemovePropFromMVBin(lpProps,dlMax,dlDLOneOffs,lpsb->lpb, lpsb->cb);
        }
    }

    // if we removed all the OneOffs from the entry, then RemovePropFromMVBin just sets
    // the prop tag on the prop to be PR_NULL .. instead we need to physically knock out
    // that prop from the object
    if( lpProps[dlDLOneOffs].Value.MVbin.cValues == 0 ||
        lpProps[dlDLOneOffs].ulPropTag == PR_NULL )
    {
        SizedSPropTagArray(1, tagDLOneOffs) =  { 1, PR_WAB_DL_ONEOFFS };
        lpDL->lpVtbl->DeleteProps(lpDL, (LPSPropTagArray) &tagDLOneOffs, NULL);
    }

    if (HR_FAILED(hr = lpDL->lpVtbl->SetProps(lpDL, ulcValues, lpProps, NULL)))
        goto out;

    if(!lpDistList)
        hr = lpDL->lpVtbl->SaveChanges(lpDL, 0);

out:

    if(lpDL && lpDL != lpDistList)
        lpDL->lpVtbl->Release(lpDL);

    FreeBufferAndNull(&lpProps);
    LocalFreeAndNull(&lpbRemove);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_pwd.h ===
// ui_pwd.h
//
// definitions for WAB synchronization password request dialog
//

#ifndef __UI_PWD_H__
#define __UI_PWD_H__

#ifdef __cplusplus
extern "C"{
#endif 

typedef struct tagPASSINFO
{
    TCHAR           szTitle[50];
    LPTSTR          lpszPassword;
    ULONG           cbMaxPassword;
    LPTSTR          lpszAccount;
    ULONG           cbMaxAccount;
    LPTSTR          lpszServer;
    BOOL            fRememberPassword;
    DWORD           fAlwaysPromptPassword;
} PASSINFO, *LPPASSINFO;


// Forward Declarations
typedef struct INETSERVER *LPINETSERVER;

// =====================================================================================
// Prototypes
// =====================================================================================
HRESULT HrGetPassword (HWND hwndParent, LPPASSINFO lpPassInfo);
BOOL PromptUserForPassword(LPINETSERVER pInetServer, HWND hwnd);


#ifdef __cplusplus
}
#endif 


#endif //__UI_PWD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_reslv.c ===
/*--------------------------------------------------------------
*
*
*   ui_reslv.c - shows the resolve name dialog
*
*
*
*
*
*
*
--------------------------------------------------------------*/
#include "_apipch.h"

extern HINSTANCE ghCommCtrlDLLInst;

#define MAX_RESLV_STRING 52 // Max # of characters to display in the static label ...

enum _ReturnValuesFromResolveDialog
{
    RESOLVE_PICKUSER=0,
    RESOLVE_CANCEL,
    RESOLVE_OK
};

typedef struct _ResolveInfo
{
    LPADRLIST * lppAdrList; // Stores the AdrList
    ULONG   nIndex;         // Index of the item of interest
    LPTSTR  lpszDisplayName;// Preextracted display name for that
    LPADRBOOK lpIAB;        // Pointer to the IAB object
    HWND    hWndParent;     // Stores hWndParents for dialog generating windows
    ULONG  ulFlag;          // Stores Resolved or Ambiguos state
    LPRECIPIENT_INFO lpContentsList;
    LPMAPITABLE lpMapiTable;
    BOOL    bUnicode;       // TRUE if MAPI_UNICODE specified in IAB::ResolveName
} RESOLVE_INFO, * LPRESOLVE_INFO;


static DWORD rgReslvHelpIDs[] =
{
    IDC_RESOLVE_BUTTON_BROWSE,  IDH_WAB_PICK_USER,
    IDC_RESOLVE_LIST_MATCHES,   IDH_WAB_CHK_NAME_LIST,
    IDC_RESOLVE_STATIC_1,       IDH_WAB_CHK_NAME_LIST,
    IDC_RESOLVE_BUTTON_PROPS,   IDH_WAB_PICK_RECIP_NAME_PROPERTIES,
    IDC_RESOLVE_BUTTON_NEWCONTACT,  IDH_WAB_PICK_RECIP_NAME_NEW,
    0,0
};


//forward declarations
HRESULT HrResolveName(LPADRBOOK lpIAB,
                      HWND hWndParent,
                      HANDLE hPropertyStore,
                      ULONG nIndex,
                      ULONG ulFlag,
                      BOOL bUnicode,
                      LPADRLIST * lppAdrList,
                      LPMAPITABLE lpMapiTable);


INT_PTR CALLBACK fnResolve(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

BOOL ProcessResolveLVNotifications(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

HRESULT HrShowPickUserDialog(LPRESOLVE_INFO lpRI, LPTSTR lpszCaption);

HRESULT HrShowNewEntryFromResolve(LPRESOLVE_INFO lpRI, HWND hWndParent, ULONG ulObjectType);

HRESULT HrFillLVWithMatches(   HWND hWndLV,
                                LPRESOLVE_INFO lpRI);

HRESULT HrMergeSelectionWithOriginal(LPRESOLVE_INFO lpRI,
                                     ULONG cbEID,
                                     LPENTRYID lpEID);

void ExitResolveDialog(HWND hDlg, LPRESOLVE_INFO lpRI, int nRetVal);

BOOL GetLVSelectedItem(HWND hWndLV, LPRESOLVE_INFO lpRI);



///////////////////////////////////////////////////////////////////////////////////////////////////
//
//
// HrShowResolveUI
//
// Wraps the UI for Resolve Names
//
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowResolveUI(IN  LPADRBOOK   lpIAB,
                        HWND hWndParent,
                        HANDLE hPropertyStore,
                        ULONG ulFlags,      // WAB_RESOLVE_NO_NOT_FOUND_UI
                        LPADRLIST * lppAdrList,
                        LPFlagList *lppFlagList,
                        LPAMBIGUOUS_TABLES lpAmbiguousTables)
{
    HRESULT hr = hrSuccess;
    ULONG i=0;
    LPFlagList lpFlagList= NULL;
    LPMAPITABLE lpMapiTable = NULL;
    BOOL bUnicode = (ulFlags & WAB_RESOLVE_UNICODE);

    // if no common control, exit
    if (NULL == ghCommCtrlDLLInst) {
        hr = ResultFromScode(MAPI_E_UNCONFIGURED);
        goto out;
    }

    if(!hPropertyStore || !lppAdrList || !lppFlagList || !(*lppAdrList) || !(*lppFlagList))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    lpFlagList=(*lppFlagList);

     // we need to scan the lpFlagList and look for unresolved entries

    for (i = 0; i < lpFlagList->cFlags; i++)
    {
        //
        // Occasionally someone (like athena) may hand us an adrlist with null rgPropVals
        // We need to anticipate that.
        //
        if (    ((*lppAdrList)->aEntries[i].cValues == 0) ||
                ((*lppAdrList)->aEntries[i].rgPropVals == NULL)  )
            continue;

        switch (lpFlagList->ulFlag[i])
        {
            case MAPI_RESOLVED:
                break;

            case MAPI_AMBIGUOUS:
                //
                // W2 - we now have an Ambiguous Table parameter .. for Unresolved
                // entries, there is no Table but for Ambiguous entries, there is
                // a corresponding ambiguous table filled in from the LDAP servers
                //
                if(lpAmbiguousTables)
                {
                    if (lpAmbiguousTables->cEntries != 0)
                    {
                        lpMapiTable = lpAmbiguousTables->lpTable[i];
                    }
                }
                //Fall through
            case MAPI_UNRESOLVED:
                //
                // We show a dialog asking the user what they want to do ...
                // For this version, they can
                // (b) browse the list of users or (c) cancel this user ..
                // We will assume that we already the AdrList already has
                // Recipient_Type and Display_Name and we only need to fill
                // in the EntryID of this user ...
                //
                if ((! (ulFlags & WAB_RESOLVE_NO_NOT_FOUND_UI) ||
                  lpFlagList->ulFlag[i] == MAPI_AMBIGUOUS)) {
                    hr = HrResolveName( lpIAB,
                                        hWndParent,
                                        hPropertyStore,
                                        i,
                                        lpFlagList->ulFlag[i],
                                        bUnicode,
                                        lppAdrList,
                                        lpMapiTable);
                    if (!HR_FAILED(hr))
                        lpFlagList->ulFlag[i] = MAPI_RESOLVED;
                    else
                    {
                        // Cancels are final .. other errors are not ..
                        if (hr == MAPI_E_USER_CANCEL)
                            goto out;
                    }
                }

                break;
        }
    }

out:

    return hr;
}



// *** Dont change *** the order of the first 2 properties between here and the similar structure
// in ui_addr.c
enum _lppAdrListReturnedProps
{
    propPR_DISPLAY_NAME,
    propPR_ENTRYID,
    TOTAL_ADRLIST_PROPS
};


////////////////////////////////////////////////////////////////////////////////////////
//
// HrResolveName - tackles one entry at a time ...
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrResolveName(  IN  LPADRBOOK   lpIAB,
                        HWND hWndParent,
                        HANDLE hPropertyStore,
                        ULONG nIndex,
                        ULONG ulFlag,
                        BOOL bUnicode,
                        LPADRLIST * lppAdrList,
                        LPMAPITABLE lpMapiTable)
{
    ULONG i=0;
    LPTSTR lpszDisplayName = NULL, lpszEmailAddress = NULL;
    int nRetVal = 0;
    HRESULT hr = hrSuccess;
    RESOLVE_INFO RI = {0};
    LPADRLIST lpAdrList = *lppAdrList;
    ULONG ulTagDN = PR_DISPLAY_NAME, ulTagEmail = PR_EMAIL_ADDRESS;

    if(!bUnicode)
    {
        ulTagDN = CHANGE_PROP_TYPE(ulTagDN, PT_STRING8);
        ulTagEmail = CHANGE_PROP_TYPE(ulTagEmail, PT_STRING8);
    }
    //Scan this adrlist entries properties
    for(i=0;i < lpAdrList->aEntries[nIndex].cValues; i++)
    {
        if (lpAdrList->aEntries[nIndex].rgPropVals[i].ulPropTag == ulTagDN)
        {
            lpszDisplayName = bUnicode ? 
                                (LPWSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ :
                                ConvertAtoW((LPSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ);
        }
        if (lpAdrList->aEntries[nIndex].rgPropVals[i].ulPropTag == ulTagEmail)
        {
            lpszEmailAddress = bUnicode ? 
                                (LPWSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ :
                                ConvertAtoW((LPSTR)lpAdrList->aEntries[nIndex].rgPropVals[i].Value.LPSZ);
        }
    }

    // we need some display name info to resolve on ...
    if (lpszDisplayName == NULL) //we need this info or cant proceed
    {
        if (lpszEmailAddress) 
        {
            lpszDisplayName = lpszEmailAddress;
            lpszEmailAddress = NULL;
        } 
        else 
        {
            hr = MAPI_E_INVALID_PARAMETER;
            goto out;
        }
    }


    RI.nIndex = nIndex;
    RI.lppAdrList = lppAdrList;
    RI.lpszDisplayName = lpszDisplayName;
    RI.lpIAB = lpIAB;
    RI.hWndParent = hWndParent;
    RI.ulFlag = ulFlag;
    RI.lpContentsList = NULL;
    RI.lpMapiTable = lpMapiTable;
    RI.bUnicode = bUnicode;

    nRetVal = (int) DialogBoxParam( hinstMapiX,
                    MAKEINTRESOURCE(IDD_DIALOG_RESOLVENAME),
                    hWndParent,
                    fnResolve,
                    (LPARAM) &RI);

    switch(nRetVal)
    {
    case RESOLVE_CANCEL:
        hr = MAPI_E_USER_CANCEL; //Cancel, flag it as pass and dont change anything
        goto out;
        break;

    case RESOLVE_OK:
        hr = hrSuccess;
        goto out;

    case -1:        // something went wrong ...
        DebugPrintTrace(( TEXT("DialogBoxParam -> %u\n"), GetLastError()));
        hr = E_FAIL;
        goto out;
        break;

    } //switch


out:

    if(!bUnicode) // <note> assumes UNICODE defined
    {
        LocalFreeAndNull(&lpszDisplayName);
        LocalFreeAndNull(&lpszEmailAddress);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////////
//
// SetResolveUI - 
//
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetResolveUI(HWND hDlg)
{

    // This function initializes a list view
    HrInitListView( GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES),
                    LVS_REPORT,
                    FALSE);		// Hide or show column headers

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
                        SetChildDefaultGUIFont,
                        (LPARAM) 0);


    return TRUE;

}


void SetLabelLDAP(HWND hDlg, HWND hWndLV)
{
    // look at an entryid from the hWNdLV
    // Use it only if its an LDAP entryid

    // if the entryid is something else, we need to get its name and
    // fill the structure accordingly
    LPRECIPIENT_INFO lpItem;

    if(ListView_GetItemCount(hWndLV) <= 0)
        goto out;

    lpItem = GetItemFromLV(hWndLV, 0);
    if(lpItem)
    {
        LPTSTR lpServer = NULL;
        LPTSTR lpDNS = NULL;
	    LPTSTR lpName = NULL;
        TCHAR szName[40]; // we will limit the name to 40 chars so that the whole
                          // string will fit in the UI for really large chars

        // is this an LDAP entryid ?
        if (WAB_LDAP_MAILUSER == IsWABEntryID(  lpItem->cbEntryID,
                                                lpItem->lpEntryID,
                                                &lpServer,
                                                &lpDNS,
                                                NULL, NULL, NULL))
        {
            //lpServer contains the server name

            LPTSTR lpsz;
            TCHAR szBuf[MAX_UI_STR];
            TCHAR szTmp[MAX_PATH], *lpszTmp;

            CopyTruncate(szName, lpServer, ARRAYSIZE(szName));

            lpName = (LPTSTR) szName;

            LoadString(hinstMapiX, idsResolveMatchesOnLDAP, szBuf, ARRAYSIZE(szBuf));

            CopyTruncate(szTmp, lpName, MAX_PATH - 1);
            lpszTmp = szTmp;
            if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                szBuf,
                                0,0, //ignored
                                (LPTSTR) &lpsz,
                                MAX_UI_STR,
                                (va_list *)&lpszTmp))
            {
                SetDlgItemText(hDlg, IDC_RESOLVE_STATIC_MATCHES, lpsz);
                IF_WIN32(LocalFree(lpsz);)
                IF_WIN16(FormatMessageFreeMem(lpsz);)
            }
        }
    }

out:
    return;
}


void FillUI(HWND hDlg, HWND hWndLV, LPRESOLVE_INFO lpRI)
{

    TCHAR szBuf[MAX_UI_STR];
    ULONG nLen = 0;
    LPTSTR lpszDisplayName = lpRI->lpszDisplayName;
    BOOL bNothingFound = FALSE;
    LPTSTR lpszBuffer = NULL;
	LPTSTR lpName = NULL;
    TCHAR szTmp[MAX_PATH], *lpszTmp;
    TCHAR szName[40]; // we will limit the name to 40 chars so that the whole
                      // string will fit in the UI for really large chars

    if (    (lpRI->ulFlag == MAPI_UNRESOLVED) ||
            (HR_FAILED(HrFillLVWithMatches(hWndLV, lpRI)))
        )
        bNothingFound = TRUE;

    nLen = CopyTruncate(szName, lpszDisplayName, ARRAYSIZE(szName));

    lpName = (LPTSTR) szName;

    LoadString(hinstMapiX, (bNothingFound ? IDS_RESOLVE_NO_MATCHES_FOR : IDS_ADDRBK_RESOLVE_CAPTION),
                szBuf, ARRAYSIZE(szBuf));

    // Win9x bug FormatMessage cannot have more than 1023 chars
    CopyTruncate(szTmp, lpName, MAX_PATH - 1);
    lpszTmp = szTmp;
    if(FormatMessage(   FORMAT_MESSAGE_FROM_STRING |
                        FORMAT_MESSAGE_ARGUMENT_ARRAY |
                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szBuf,
                        0,0, //ignored
                        (LPTSTR) &lpszBuffer,
                        MAX_UI_STR,
                        (va_list *)&lpszTmp))
    {
        SetDlgItemText(hDlg, IDC_RESOLVE_STATIC_1,lpszBuffer);
        IF_WIN32(LocalFreeAndNull(&lpszBuffer);)
        IF_WIN16(FormatMessageFreeMem(lpszBuffer);)
    }
    
    if(bNothingFound)
    {
        // If this has already been flagged as unresolved .. or
        // the attempt to find fuzzy matches was unsuccessful ...
        // tell 'em nothing found ...

        LoadString(hinstMapiX, IDS_RESOLVE_NO_MATCHES, szBuf, ARRAYSIZE(szBuf));
		{
			LV_ITEM lvI = {0};
			lvI.mask = LVIF_TEXT;
			lvI.cchTextMax = lstrlen(szBuf)+1;
			lvI.pszText = szBuf;
			ListView_InsertItem(hWndLV, &lvI);
			ListView_SetColumnWidth(hWndLV,0,400); //400 is a totally random number, we just want the column to be big enough not to truncate text
		}
        EnableWindow(hWndLV,FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_RESOLVE_BUTTON_PROPS),FALSE);
        EnableWindow(GetDlgItem(hDlg,IDOK/*IDC_RESOLVE_BUTTON_OK*/),FALSE);
        ShowWindow(GetDlgItem(hDlg,IDC_RESOLVE_STATIC_MATCHES),SW_HIDE);
    }
    else
    {

        // if the search results are from an ldap server, we need
        // to set the label on the dialog to say the results are from
        // an LDAP server
        SetLabelLDAP(hDlg, hWndLV);

        // If the list view is filled, select the first item
        if (ListView_GetItemCount(hWndLV) > 0)
        {
            LVSelectItem(hWndLV, 0);
            SetFocus(hWndLV);
        }
    }

    return;
}
/*************************************************************************
//
//  resolve Dialog - simple implementation for 0.5
//
**************************************************************************/
INT_PTR CALLBACK fnResolve(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf[MAX_UI_STR];
    ULONG nLen = 0, nLenMax = 0, nRetVal=0;
    HRESULT hr = hrSuccess;

    LPRESOLVE_INFO lpRI = (LPRESOLVE_INFO) GetWindowLongPtr(hDlg,DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            HWND hWndLV = GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES);
            SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference
            lpRI = (LPRESOLVE_INFO) lParam;

            SetResolveUI(hDlg);

            FillUI(hDlg, hWndLV, lpRI);
        }
        break;

    default:
#ifndef WIN16
        if((g_msgMSWheel && message == g_msgMSWheel) 
            // || message == WM_MOUSEWHEEL
            )
        {
            SendMessage(GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES), message, wParam, lParam);
            break;
        }
#endif // !WIN16
        return FALSE;
        break;

    case WM_SYSCOLORCHANGE:
		//Forward any system changes to the list view
		SendMessage(GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES), message, wParam, lParam);
		break;

   case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam,lParam))
        {
        default:
            return ProcessActionCommands((LPIAB) lpRI->lpIAB, 
                                        GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES), 
                                        hDlg, message, wParam, lParam);
            break;

        case IDM_LVCONTEXT_DELETE: //We renamed the delete on the context menu to say  TEXT("Show more Names")
        case IDC_RESOLVE_BUTTON_BROWSE:
            GetWindowText(hDlg, szBuf, ARRAYSIZE(szBuf));
            lpRI->hWndParent = hDlg;
            hr = HrShowPickUserDialog(lpRI, szBuf);
            if(!HR_FAILED(hr))
            {
                if(lpRI->lpContentsList)
                    ClearListView(  GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES),
                                    &(lpRI->lpContentsList));
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
//                EndDialog( hDlg, RESOLVE_OK);
            }
            else
            {
                if(hr != MAPI_E_USER_CANCEL)
                {
                    // Some error occured .. dont know what .. but since this dialog
                    // will stick around, need to warn the user about it ...
                    ShowMessageBox(hDlg,idsCouldNotSelectUser,MB_ICONERROR | MB_OK);
                }
            }
            break;

        case IDOK:
        case IDC_RESOLVE_BUTTON_OK:
            if (GetLVSelectedItem(GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES),lpRI))
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
            break;

        case IDCANCEL:
        case IDC_RESOLVE_BUTTON_CANCEL:
            ExitResolveDialog(hDlg, lpRI, RESOLVE_CANCEL);
            break;

        case IDM_LVCONTEXT_NEWCONTACT:
        case IDC_RESOLVE_BUTTON_NEWCONTACT:
            hr = HrShowNewEntryFromResolve(lpRI,hDlg,MAPI_MAILUSER);
            if (!HR_FAILED(hr))
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
            break;

        case IDM_LVCONTEXT_NEWGROUP:
//        case IDC_RESOLVE_BUTTON_NEWCONTACT:
            hr = HrShowNewEntryFromResolve(lpRI,hDlg,MAPI_DISTLIST);
            if (!HR_FAILED(hr))
                ExitResolveDialog(hDlg, lpRI, RESOLVE_OK);
            break;

        case IDM_LVCONTEXT_COPY:
            HrCopyItemDataToClipboard(hDlg, lpRI->lpIAB, GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES));
            break;

        case IDM_LVCONTEXT_PROPERTIES:
        case IDC_RESOLVE_BUTTON_PROPS:
            EnableWindow(GetDlgItem(hDlg, IDC_RESOLVE_BUTTON_PROPS), FALSE);
            HrShowLVEntryProperties(GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES), 0,
                                    lpRI->lpIAB, NULL);
            EnableWindow(GetDlgItem(hDlg, IDC_RESOLVE_BUTTON_PROPS), TRUE);
            break;

        }
        break;

    case WM_CLOSE:
        //treat it like a cancel button
        SendMessage (hDlg, WM_COMMAND, (WPARAM) IDC_RESOLVE_BUTTON_CANCEL, 0);
        break;

    case WM_CONTEXTMENU:
		if ((HWND)wParam == GetDlgItem(hDlg,IDC_RESOLVE_LIST_MATCHES))
		{
			ShowLVContextMenu(	lvDialogResolve, (HWND)wParam, NULL, lParam, NULL,lpRI->lpIAB, NULL);
		}
        else
        {
            WABWinHelp((HWND) wParam,
                    g_szWABHelpFileName,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) rgReslvHelpIDs );
        }
        break;

    case WM_HELP:
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgReslvHelpIDs );
        break;


    case WM_NOTIFY:
        switch((int) wParam)
        {
        case IDC_RESOLVE_LIST_MATCHES:
            return ProcessResolveLVNotifications(hDlg,message,wParam,lParam);
        }
        break;
    }

    return TRUE;

}



/////////////////////////////////////////////////////////////
//
// Processes Notification messages for the list view control
//
//
////////////////////////////////////////////////////////////
BOOL ProcessResolveLVNotifications(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;

    switch(pNm->hdr.code)
    {
    case NM_DBLCLK:
        // Doubleclick on the list view is equivalent to a OK with a selected item
        SendMessage(hDlg, WM_COMMAND, (WPARAM) IDOK/*IDC_RESOLVE_BUTTON_OK*/, 0);
        break;

    case NM_CUSTOMDRAW:
        return (0 != ProcessLVCustomDraw(hDlg, lParam, TRUE));
    	break;

    }

	return FALSE;

}

//////////////////////////////////////////////////////////////////////////////
//
//
// Pops up the New Entry dialog and then replaces the old entry with the
//  newly created entry ...
//
//////////////////////////////////////////////////////////////////////////////
HRESULT HrShowNewEntryFromResolve(LPRESOLVE_INFO lpRI, HWND hWndParent, ULONG ulObjectType)
{
	ULONG cbEID=0;
	LPENTRYID lpEID=NULL;

    HRESULT hr = hrSuccess;
    ULONG cbTplEID = 0;
    LPENTRYID lpTplEID = NULL;

    //OutputDebugString( TEXT("HrShowNewEntryFromResolve entry\n"));

    if (ulObjectType!=MAPI_MAILUSER && ulObjectType!=MAPI_DISTLIST)
        goto out;

    if(HR_FAILED(hr = HrGetWABTemplateID(   lpRI->lpIAB,
                                            ulObjectType,
                                            &cbTplEID,
                                            &lpTplEID)))
    {
        DebugPrintError(( TEXT("HrGetWABTemplateID failed: %x\n"), hr));
        goto out;
    }

	if (HR_FAILED(hr = (lpRI->lpIAB)->lpVtbl->NewEntry(	lpRI->lpIAB,
				            					(ULONG_PTR) hWndParent,
							            		0,
									            0,NULL,
									            cbTplEID,lpTplEID,
									            &cbEID,&lpEID)))
    {
        DebugPrintError(( TEXT("NewEntry failed: %x\n"),hr));
        goto out;
    }


   // We created a new entry, and we want to use it to replace the old unresolved entry

    hr = HrMergeSelectionWithOriginal(lpRI, cbEID, lpEID);

out:
    FreeBufferAndNull(&lpEID);
    FreeBufferAndNull(&lpTplEID);

    //OutputDebugString( TEXT("HrShowNewEntryFromResolve exit\n"));
    return hr;
}


////////////////////////////////////////////////////////////////
//
// Takes entry id of users selection and returns it appropriately ...
//
//
////////////////////////////////////////////////////////////////
HRESULT HrMergeSelectionWithOriginal(LPRESOLVE_INFO lpRI,
                                     ULONG cbEID,
                                     LPENTRYID lpEID)
{
    HRESULT hr = hrSuccess;
    ULONG cValues = 0;
    LPSPropValue lpPropArray = NULL;
    LPADRLIST lpAdrList = *(lpRI->lppAdrList);
    SCODE sc;
    ULONG nIndex = lpRI->nIndex;

    //OutputDebugString( TEXT("HrMergeSelectionWithOriginal entry\n"));

    hr = HrGetPropArray((lpRI->lpIAB),
                        (LPSPropTagArray) &ptaResolveDefaults,
                        cbEID,
                        lpEID,
                        lpRI->bUnicode ? MAPI_UNICODE : 0,
                        &cValues,
                        &lpPropArray);

    if (HR_FAILED(hr)) goto out;

    if ((!cValues) || (!lpPropArray))
    {
        hr = E_FAIL;
        goto out;
    }
    else
    {
        LPSPropValue lpPropArrayNew = NULL;
        ULONG cValuesNew = 0;

        sc = ScMergePropValues( lpAdrList->aEntries[nIndex].cValues,
                                lpAdrList->aEntries[nIndex].rgPropVals,
                                cValues,
                                lpPropArray,
                                &cValuesNew,
                                &lpPropArrayNew);
        if (sc != S_OK)
        {
            hr = ResultFromScode(sc);
            goto out;
        }

        if ((lpPropArrayNew) && (cValuesNew > 0))
        {
            // [PaulHi] Raid 69325
            // We need to convert these properties to ANSI since we are now the
            // UNICODE WAB and if our client is !MAPI_UNICODE
            if (!(lpRI->bUnicode))
            {
                if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cValuesNew, 0))
                    goto out;
            }

            MAPIFreeBuffer(lpAdrList->aEntries[nIndex].rgPropVals);
            lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
            lpAdrList->aEntries[nIndex].cValues = cValuesNew;
        }
    }


    hr = hrSuccess;

out:

    if (lpPropArray)
        MAPIFreeBuffer(lpPropArray);


    //OutputDebugString( TEXT("HrMergeSelectionWithOriginal exit\n"));

    return hr;

}

////////////////////////////////////////////////////////////////////////////////////////
//
// HrShowPickuserDialog - shows the pick user dialog
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowPickUserDialog(LPRESOLVE_INFO lpRI,
                             LPTSTR lpszCaption)
{
    LPADRLIST lpAdrList = *(lpRI->lppAdrList);
    ULONG nIndex = lpRI->nIndex;
    LPTSTR lpszDisplayName = lpRI->lpszDisplayName;

    LPADRLIST lpAdrListSingle = NULL;
    ADRPARM AdrParms = {0};
    SCODE sc;
    HRESULT hr = hrSuccess;
    DWORD cchSize = 0;

    //OutputDebugString( TEXT("HrShowPickUserDialog entry\n"));

    // create an AdrList structure which we pass to Address ... to show UI
    // We pass in the bare minimum props here which are - Display Name and Entry ID field (which is really NULL)
    // The Address UI, if successful, gives us a whole list of props back which we merge with
    // the original list, overwriting what we got back fresh ...

    sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrListSingle);

    if (sc != S_OK)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    lpAdrListSingle->cEntries = 1;
    lpAdrListSingle->aEntries[0].ulReserved1 = 0;
    lpAdrListSingle->aEntries[0].cValues = TOTAL_ADRLIST_PROPS;

    sc = MAPIAllocateBuffer(   TOTAL_ADRLIST_PROPS * sizeof(SPropValue),
                             (LPVOID *) (&(lpAdrListSingle->aEntries[0].rgPropVals)));
    if (sc != S_OK)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    lpAdrListSingle->aEntries[0].rgPropVals[propPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
    cchSize = (lstrlen(lpszDisplayName)+1);
    sc = MAPIAllocateMore((sizeof(TCHAR) * cchSize),
                            lpAdrListSingle->aEntries[0].rgPropVals,
                            (LPVOID *) (&lpAdrListSingle->aEntries[0].rgPropVals[propPR_DISPLAY_NAME].Value.LPSZ));

    if (sc != S_OK)
    {
        hr = ResultFromScode(sc);
        goto out;
    }

    StrCpyN(lpAdrListSingle->aEntries[0].rgPropVals[propPR_DISPLAY_NAME].Value.LPSZ, lpszDisplayName, cchSize);

    lpAdrListSingle->aEntries[0].rgPropVals[propPR_ENTRYID].ulPropTag = PR_ENTRYID;
    lpAdrListSingle->aEntries[0].rgPropVals[propPR_ENTRYID].Value.bin.cb = 0;
    lpAdrListSingle->aEntries[0].rgPropVals[propPR_ENTRYID].Value.bin.lpb = NULL;

    AdrParms.cDestFields = 0;
    AdrParms.ulFlags = DIALOG_MODAL | ADDRESS_ONE | MAPI_UNICODE;
    AdrParms.lpszCaption = lpszCaption;


    if (!HR_FAILED(hr = (lpRI->lpIAB)->lpVtbl->Address(
                                                lpRI->lpIAB,
                                                (PULONG_PTR) &(lpRI->hWndParent),
                                                &AdrParms,
                                                &lpAdrListSingle)))
    {
            // We successfully selected some user and the lpAdrListSingle contains
            // a new set of lpProps for that user ...
            //
            LPSPropValue lpPropArrayNew = NULL;
            ULONG cValuesNew = 0;

            sc = ScMergePropValues( lpAdrList->aEntries[nIndex].cValues,
                                    lpAdrList->aEntries[nIndex].rgPropVals,
                                    lpAdrListSingle->aEntries[0].cValues,
                                    lpAdrListSingle->aEntries[0].rgPropVals,
                                    &cValuesNew,
                                    &lpPropArrayNew);
            if (sc != S_OK)
            {
                hr = ResultFromScode(sc);
                goto out;
            }

            if ((lpPropArrayNew) && (cValuesNew > 0))
            {
                // [PaulHi] Raid 69325
                // We need to convert these properties to ANSI since we are now the
                // UNICODE WAB and if our client is !MAPI_UNICODE
                if (!(lpRI->bUnicode))
                {
                    if(sc = ScConvertWPropsToA((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArrayNew, cValuesNew, 0))
                        goto out;
                }

                MAPIFreeBuffer(lpAdrList->aEntries[nIndex].rgPropVals);
                lpAdrList->aEntries[nIndex].rgPropVals = lpPropArrayNew;
                lpAdrList->aEntries[nIndex].cValues = cValuesNew;
            }

    }

out:

    if (lpAdrListSingle)
    {
        FreePadrlist(lpAdrListSingle);
    }

    //OutputDebugString( TEXT("HrShowPickUserDialog exit\n"));
    return hr;
}



//$$/////////////////////////////////////////////////////////////////////////////////
//
//
// HrFillLVWithMatches - fills the list view with close matches for the given name
//
// Fails (E_FAIL) if it doesnt find anything to fill in the List View
//
//////////////////////////////////////////////////////////////////////////////////////////
HRESULT HrFillLVWithMatches(   HWND hWndLV,
                                LPRESOLVE_INFO lpRI)
{
    HRESULT hr = hrSuccess;
    LPSBinary * lprgsbEntryIDs = NULL;
    ULONG iolkci=0, colkci = 0;
	OlkContInfo *rgolkci;
    ULONG * lpcValues = NULL;
    ULONG i = 0, j = 0;
    LPSRowSet   lpSRowSet = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    ULONG ulFlags = AB_FUZZY_FIND_ALL;

    EnterCriticalSection(&(((LPIAB)(lpRI->lpIAB))->cs));

	if (pt_bIsWABOpenExSession) 
    {
		colkci = ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->colkci;
		Assert(colkci);
		rgolkci = ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->rgolkci;
		Assert(rgolkci);
    }
    else
	if (bAreWABAPIProfileAware((LPIAB)lpRI->lpIAB)) 
    {
		colkci = ((LPIAB)(lpRI->lpIAB))->cwabci;
		Assert(colkci);
		rgolkci = ((LPIAB)(lpRI->lpIAB))->rgwabci;
		Assert(rgolkci);
        if(colkci > 1 && !lpRI->lpMapiTable)
            ulFlags |= AB_FUZZY_FIND_PROFILEFOLDERONLY;
    }
    else
        colkci = 1;

    lprgsbEntryIDs = LocalAlloc(LMEM_ZEROINIT, colkci*sizeof(LPSBinary));
    lpcValues = LocalAlloc(LMEM_ZEROINIT, colkci*sizeof(ULONG));
    if(!lprgsbEntryIDs || !lpcValues)
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto out;
    }
    
    //
    // First search the property store
    //

    if(!(lpRI->lpMapiTable))
    {
        // if we dont have a ambiguous table to look in then that means we look in the
        // property store for ambiguous stuff ...
		while (iolkci < colkci) 
        {
            hr = HrFindFuzzyRecordMatches(
                            ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->hPropertyStore,
                            (colkci == 1) ? NULL : rgolkci[iolkci].lpEntryID,
                            lpRI->lpszDisplayName,
                            ulFlags, //flags
                            &(lpcValues[iolkci]),
                            &(lprgsbEntryIDs[iolkci]));
			iolkci++;
		}

        if (HR_FAILED(hr))
            goto out;


        if(bAreWABAPIProfileAware((LPIAB)lpRI->lpIAB))
        {
            // it's possible that nothing in the profile matched but other stuff in the WAB matched
            // Doublecheck that if we found nothing in the profile, we can search the whole WAB
            ULONG nCount = 0;
            for(i=0;i<colkci;i++)
                nCount += lpcValues[i];
            if(!nCount)
            {
                // search the whole WAB
                hr = HrFindFuzzyRecordMatches(
                                ((LPIAB)(lpRI->lpIAB))->lpPropertyStore->hPropertyStore,
                                NULL,
                                lpRI->lpszDisplayName,
                                AB_FUZZY_FIND_ALL, //flags
                                &(lpcValues[0]),
                                &(lprgsbEntryIDs[0]));
            }
        }

        // Now we have a list of EntryIDs
        // Use them to populate the List View
        //
        // We can
        // (a) Read the entryids one by one and fill the list view
        //      AddWABEntryToListView
        // or
        // (b) We can create an lpContentsList and fill it in one shot
        //      HrFillListView

        // We'll go with (a) for now
        // If performance is bad, do (b)

        for(i=0;i<colkci;i++)
        {
            for(j=0;j<lpcValues[i];j++)
            {
                AddWABEntryToListView(  lpRI->lpIAB,
                                        hWndLV,
                                        lprgsbEntryIDs[i][j].cb,
                                        (LPENTRYID) lprgsbEntryIDs[i][j].lpb,
                                        &(lpRI->lpContentsList));
            }
        }

    }
    else if(lpRI->lpMapiTable)
    {
        // if there is a MAPI ambiguous contents table associated with this display name
        // use it to further fill in the lpContentsList
        BOOL bUnicode = ((LPVUE)lpRI->lpMapiTable)->lptadParent->bMAPIUnicodeTable;

        hr = HrQueryAllRows(lpRI->lpMapiTable,
                            NULL,
                            NULL,
                            NULL,
                            0,
                            &lpSRowSet);

        if (HR_FAILED(hr))
        {
            DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
            goto out;
        }

        for(i=0;i<lpSRowSet->cRows;i++)
        {
            LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;

            ULONG ulcPropCount = lpSRowSet->aRow[i].cValues;

            LPRECIPIENT_INFO lpItem = LocalAlloc(LMEM_ZEROINIT, sizeof(RECIPIENT_INFO));
		
            if (!lpItem)
		    {
			    DebugPrintError(( TEXT("LocalAlloc Failed \n")));
			    hr = MAPI_E_NOT_ENOUGH_MEMORY;
			    goto out;
		    }

            if(!bUnicode) // the props are in ANSI - convert to UNICODE for our use
            {
                if(ScConvertAPropsToW((LPALLOCATEMORE) (&MAPIAllocateMore), lpPropArray, ulcPropCount, 0))
                    goto out;
            }

		    GetRecipItemFromPropArray(ulcPropCount, lpPropArray, &lpItem);

		    // The critical prop is display name - without it we are nothing ...
		    // If no display name, junk this entry and continue ..

		    if (!lstrlen(lpItem->szDisplayName) || (lpItem->cbEntryID == 0)) //This entry id is not allowed
		    {
			    FreeRecipItem(&lpItem);				
			    continue;
		    }


        	AddSingleItemToListView(hWndLV, lpItem);

            //
            // Hook in the lpItem into the lpContentsList so we can free it later
            //
            lpItem->lpPrev = NULL;
            lpItem->lpNext = lpRI->lpContentsList;
            if (lpRI->lpContentsList)
                lpRI->lpContentsList->lpPrev = lpItem;
            lpRI->lpContentsList = lpItem;

            lpItem = NULL;

        } //for i ....

    }


    //
    // If, after all this we still have an empty list box, we will report a failure
    //
    if(ListView_GetItemCount(hWndLV)<=0)
    {
        DebugPrintTrace(( TEXT("Empty List View - no matches found\n")));
        hr = E_FAIL;
        goto out;
    }


out:

    for(i=0;i<colkci;i++)
    {
        FreeEntryIDs(((LPIAB)(lpRI->lpIAB))->lpPropertyStore->hPropertyStore,
                     lpcValues[i],
                     lprgsbEntryIDs[i]);
    }
    if(lpcValues)
        LocalFree(lpcValues);
    if(lprgsbEntryIDs)
        LocalFree(lprgsbEntryIDs);

    if (lpSRowSet)
        FreeProws(lpSRowSet);

    //
    // ReSet the ListView SortAscending style off
    //
    // SetWindowLong(hWndLV, GWL_STYLE, (dwStyle | LVS_SORTASCENDING));
    LeaveCriticalSection(&(((LPIAB)(lpRI->lpIAB))->cs));

    return hr;
}


//////////////////////////////////////////////////////////////////////////
//
// Returns the item selected in the list view
//
////////////////////////////////////////////////////////////////////////
BOOL GetLVSelectedItem(HWND hWndLV, LPRESOLVE_INFO lpRI)
{
    int iItemIndex = 0;
    LV_ITEM lvi = {0};
    LPRECIPIENT_INFO lpItem;
    BOOL bRet = FALSE;

    //OutputDebugString( TEXT("GetLVSelectedItem Entry\n"));

    if (ListView_GetSelectedCount(hWndLV) != 1)
        goto out;

    iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

    lpItem = GetItemFromLV(hWndLV, iItemIndex);

    if(lpItem)
        HrMergeSelectionWithOriginal(lpRI,lpItem->cbEntryID,lpItem->lpEntryID);
    else
        goto out;

    bRet = TRUE;

out:
    //OutputDebugString( TEXT("GetLVSelectedItem Exit\n"));

    return bRet;
}

////////////////////////////////////////////////////////////////////////
//
// Generic exit function
//
////////////////////////////////////////////////////////////////////////
void ExitResolveDialog(HWND hDlg, LPRESOLVE_INFO lpRI, int nRetVal)
{
    HWND hWndLV = GetDlgItem(hDlg, IDC_RESOLVE_LIST_MATCHES);

    //OutputDebugString( TEXT("ExitResolveDialog Entry\n"));

    if(lpRI->lpContentsList)
    {
        ClearListView(hWndLV,&(lpRI->lpContentsList));
    }

    if(ListView_GetItemCount(hWndLV) > 0)
        ListView_DeleteAllItems(hWndLV);

    EndDialog(hDlg, nRetVal);

    //OutputDebugString( TEXT("ExitResolveDialog Exit\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_reslv.h ===
#ifndef _RESOLVE_H_
#define _RESOLVE_H_

HRESULT HrShowResolveUI(    IN  LPADRBOOK   lpIAB,
                            HWND        hWndParent,
                            HANDLE      hPropertyStore,
                            ULONG       ulFlags,
                            LPADRLIST * lppAdrList,
                      	    LPFlagList*	lppFlagList,
                            LPAMBIGUOUS_TABLES lpAmbiguousTables);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\unkobj.h ===
/*
 *	U N K O B J . H
 *
 * This is a generic definition of the IUnknown (plus GetLastError) part
 * of objects that are derived from IUnknown with GetLastError.
 *
 * Used in:
 * IPROP
 *
 */

// #include <_glheap.h>


typedef struct _UNKOBJ FAR *	LPUNKOBJ;

/* The instance portion of UNKOBJ structure members.
 */
typedef struct _UNKINST
{
	LPALLOCATEBUFFER	lpfAllocateBuffer;
	LPALLOCATEMORE		lpfAllocateMore;
	LPFREEBUFFER		lpfFreeBuffer;
	LPMALLOC			lpmalloc;
	HINSTANCE			hinst;

} UNKINST, * PUNKINST;

typedef ULONG	IDS;

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 * Vtable alignment
 */
#ifndef VTABLE_FILL
#ifdef MAC
#define VTABLE_FILL		NULL,
#else
#define VTABLE_FILL
#endif
#endif

/*============================================================================
 *
 *	UNKOBJ (IUnknown) Class
 */

#define	cchLastError	1024

#define MAPI_IMAPIUNKNOWN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\

#undef	INTERFACE
#define	INTERFACE	struct _UNKOBJ

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	UNKOBJ_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,UNKOBJ_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIUNKNOWN_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(UNKOBJ_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIUNKNOWN_METHODS(IMPL)
};

#define	UNKOBJ_MEMBERS					\
	ULONG				ulcbVtbl;		\
	ULONG				ulcRef;			\
	LPIID FAR *			rgpiidList;		\
	ULONG				ulcIID;			\
	CRITICAL_SECTION	csid;			\
	UNKINST *			pinst;			\
	HRESULT				hrLastError;	\
	IDS					idsLastError;	\
	HLH					lhHeap

typedef struct _UNKOBJ
{
	UNKOBJ_Vtbl FAR *	lpvtbl;
	UNKOBJ_MEMBERS;

} UNKOBJ;



#ifndef WIN16
__inline VOID
UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj )
{
	EnterCriticalSection(&lpunkobj->csid);
}

__inline VOID
UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj )
{
	LeaveCriticalSection(&lpunkobj->csid);
}

__inline HRESULT
UNKOBJ_HrSetLastResult( LPUNKOBJ	lpunkobj,
						HRESULT		hResult,
						IDS			idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = hResult;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return hResult;
}

__inline HRESULT
UNKOBJ_HrSetLastError( LPUNKOBJ	lpunkobj,
					   SCODE	sc,
					   IDS		idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastError( LPUNKOBJ	lpunkobj,
					 SCODE		sc,
					 IDS		idsError )
{
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorSc( LPUNKOBJ	lpunkobj,
					   SCODE	sc )
{
	lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorIds( LPUNKOBJ	lpunkobj,
						IDS			ids )
{
	lpunkobj->idsLastError = ids;
}
#else  // !WIN16
// !!! Watcom C compiler does not support inline.
// The functions are defined in UNKOBJ.C
VOID UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj );
VOID UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj );
HRESULT UNKOBJ_HrSetLastResult( LPUNKOBJ lpunkobj, HRESULT hResult, IDS idsError );
HRESULT UNKOBJ_HrSetLastError( LPUNKOBJ lpunkobj, SCODE sc, IDS idsError );
VOID UNKOBJ_SetLastError( LPUNKOBJ lpunkobj, SCODE sc, IDS idsError );
VOID UNKOBJ_SetLastErrorSc( LPUNKOBJ lpunkobj, SCODE sc );
VOID UNKOBJ_SetLastErrorIds( LPUNKOBJ lpunkobj, IDS ids );
#endif // !WIN16

STDAPI_(SCODE)
UNKOBJ_Init( LPUNKOBJ			lpunkobj,
			 UNKOBJ_Vtbl FAR *	lpvtblUnkobj,
			 ULONG				ulcbVtbl,
			 LPIID FAR *		rgpiidList,
			 ULONG				ulcIID,
			 PUNKINST			punkinst );

STDAPI_(VOID)
UNKOBJ_Deinit( LPUNKOBJ lpunkobj );

STDAPI_(SCODE)
UNKOBJ_ScAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );

STDAPI_(SCODE)
UNKOBJ_ScAllocateMore( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID		lpv,
					   LPVOID FAR *	lppv );

STDAPI_(VOID)
UNKOBJ_Free( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );

STDAPI_(VOID)
UNKOBJ_FreeRows( LPUNKOBJ	lpunkobj,
				 LPSRowSet	lprows );


STDAPI_(SCODE)
UNKOBJ_ScCOAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );


STDAPI_(SCODE)
UNKOBJ_ScCOReallocate( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID FAR *	lplpv );

STDAPI_(VOID)
UNKOBJ_COFree( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );



STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAlloc( LPUNKOBJ		lpunkobj,
						 IDS			ids,
						 ULONG			ulFlags,
						 int			cchBuf,
						 LPTSTR FAR *	lpszBuf );

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAllocMore( LPUNKOBJ		lpunkobj,
							 IDS			ids,
							 ULONG			ulFlags,
							 LPVOID			lpvBase,
							 int			cchBuf,
							 LPTSTR FAR *	lppszBuf );


/* These should be moved to a more useful (generic) location (mapidefs.h?).
 */

#ifdef WIN16

/* IsEqualGUID is used to eliminate dependency on compob(j/32).lib. This
 * is only necessary on WIN16 because all other platforms define this
 * already. (see objbase.h)
 */
#define IsEqualGUID(a, b)			(memcmp((a), (b), sizeof(GUID)) == 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\useragnt.c ===
// --------------------------------------------------------------------------------
// u s e r a g n t . h
//
// author:  Greg Friedman [gregfrie]
//  
// converted to wab: Christopher Evans [cevans]
//
// history: 11-10-98    Created
//
// purpose: provide a common http user agent string for use by WAB
//          in all http queries.
//
// dependencies: depends on ObtainUserAgent function in urlmon.
//
// Copyright (c) 1998 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

#include "_apipch.h"

#include <iert.h>
#include "useragnt.h"
#include "demand.h"
#include <string.h>

static LPSTR       g_pszWABUserAgent = NULL;
CRITICAL_SECTION    g_csWABUserAgent = {0};

LPSTR c_szCompatible = "compatible";
LPSTR c_szEndUATokens = ")";
LPSTR c_szWABUserAgent = "Windows-Address-Book/6.0";
LPSTR c_szBeginUATokens = " (";
LPSTR c_szSemiColonSpace = "; ";

// --------------------------------------------------------------------------------
// PszSkipWhiteA
// --------------------------------------------------------------------------
static LPSTR PszSkipWhiteA(LPSTR psz)
{
    while(*psz && (*psz == ' ' || *psz == '\t'))
        psz++;
    return psz;
}

static LPSTR _StrChrA(LPCSTR lpStart, WORD wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }
    return (NULL);
}

//----------------------------------------------------------------------
// InitWABUserAgent
//
// Initialize or tear down WAB's user agent support.
//----------------------------------------------------------------------
void InitWABUserAgent(BOOL fInit)
{
    if (fInit)
        InitializeCriticalSection(&g_csWABUserAgent);
    else
    {
        if (g_pszWABUserAgent)
        {
            LocalFree(g_pszWABUserAgent);
            g_pszWABUserAgent = NULL;
        }
        DeleteCriticalSection(&g_csWABUserAgent);
    }
}

//----------------------------------------------------------------------
// GetWABUserAgentString
//
// Returns the Outlook Express user agent string. The caller MUST
// delete the string that is returned.
//----------------------------------------------------------------------
LPSTR GetWABUserAgentString(void)
{
    LPSTR pszReturn = NULL;

    // thread safety
    EnterCriticalSection(&g_csWABUserAgent);

    if (NULL == g_pszWABUserAgent)
    {
        CHAR            szUrlMonUA[4048];
        DWORD           cbSize = ARRAYSIZE(szUrlMonUA) - 1;
        CHAR            szResult[4096];
        CHAR            *pch, *pchBeginTok;
        BOOL            fTokens = FALSE;
        HRESULT         hr = S_OK;
        DWORD           cchSize;

        szResult[0] = TEXT('\0');
        StrCpyNA(szResult, c_szWABUserAgent, ARRAYSIZE(szResult));
        
        // allow urlmon to generate our base user agent
        if (SUCCEEDED(ObtainUserAgentString(0, szUrlMonUA, &cbSize)))
        {
            // make sure the string we obtained is null terminated
            szUrlMonUA[cbSize] = '\0';

            // find the open beginning of the token list
            pch = _StrChrA(szUrlMonUA, '(');
            if ((NULL != pch) && pch[0])
            {
                pch++;
                pchBeginTok = pch;
                while (pch)
                {
                    // find the next token
                    pch = StrTokEx(&pchBeginTok, "(;)");
                    if (pch)
                    {
                        // skip past white space
                        pch = PszSkipWhiteA(pch);

                        // omit the "compatible" token...it doesn't apply to WAB
                        if (0 != lstrcmpiA(pch, c_szCompatible))
                        {
                            if ((lstrlenA(szResult) + lstrlenA(pch) + 5) > ARRAYSIZE(szResult))
                                break;

                            // begin the token list with an open paren, or insert a delimeter
                            if (!fTokens)
                            {
                                StrCatBuffA(szResult, c_szBeginUATokens, ARRAYSIZE(szResult));
                                fTokens = TRUE;
                            }
                            else
                                StrCatBuffA(szResult, c_szSemiColonSpace, ARRAYSIZE(szResult));

                            // write the token
                            StrCatBuffA(szResult, pch, ARRAYSIZE(szResult));
                        }
                    }
                }
                
                // if one or more tokens were added, close the parens
                if (fTokens)
                    StrCatBuffA(szResult, c_szEndUATokens, ARRAYSIZE(szResult));
            }
        }
    
        cchSize = (lstrlenA(szResult) + 1);
        g_pszWABUserAgent = LocalAlloc(LMEM_FIXED, sizeof(g_pszWABUserAgent[0]) * cchSize);
        if (g_pszWABUserAgent)
            StrCpyNA(g_pszWABUserAgent, szResult, cchSize);
    }
    
    // duplicate the user agent
    if (g_pszWABUserAgent)
    {
        DWORD cchSize2 = (lstrlenA(g_pszWABUserAgent) + 1);
        pszReturn = LocalAlloc(LMEM_FIXED, cchSize2 * sizeof(pszReturn[0]));
        if (pszReturn)
            StrCpyNA(pszReturn, g_pszWABUserAgent, cchSize2);
    }

    // thread safety
    LeaveCriticalSection(&g_csWABUserAgent);
    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\unkobj.c ===
/*
 *	U N K O B J . C
 *
 * This is a generic implementation of the IUnknown plus GetLastError)
 * "IMAPIUnknown" part of objects that are derived from IUnknown with
 * GetLastError.
 *
 * This also implements several useful utility functions based on
 * IMAPIUnknown.
 *
 * To use this, you must implement your own init function.
 *
 * Used in:
 * IPROP
 * ITABLE
 *
 */


#include "_apipch.h"



/*
 *	Per-instance global data for the UNKOBJ Class
 */
typedef struct
{
	int				cRef;			//	reference count for instance data
	HLH				hlh;			//  Single heap used by UNKOBJ_ScCOxxx
									//	allocators for all Unkobj's
	CRITICAL_SECTION cs;			//	critical section for data access
} UNKOBJCLASSINST, FAR *LPUNKOBJCLASSINST;

#if defined (WIN32) && !defined (MAC)
CRITICAL_SECTION csUnkobjInit;
extern BOOL fGlobalCSValid;
#endif

// $MAC - Use Mac specific instance global handlers

#ifndef MAC
DefineInstList(UNKOBJ);
#undef  PvGetInstanceGlobals
#define PvGetInstanceGlobals()		PvGetInstanceGlobalsEx(UNKOBJ)
#undef  ScSetInstanceGlobals
#define ScSetInstanceGlobals(pinst)	ScSetInstanceGlobalsEx(pinst, UNKOBJ)
#else  // MAC
#include <utilmac.h>
#define	PvGetInstanceGlobals()				PvGetInstanceGlobalsMac(kInstMAPIU)
#define	PvGetInstanceGlobalsEx(_x)			PvGetInstanceGlobalsMac(kInstMAPIU)
#define ScSetInstanceGlobals(a)				ScSetInstanceGlobalsMac(a, kInstMAPIU)
#define	ScSetInstanceGlobalsEx(_pinst, _x)	ScSetInstanceGlobalsMac(_pinst, kInstMAPIU)
#endif // MAC

// #pragma SEGMENT(Common)

/*============================================================================
 *	UNKOBJ (IMAPIUnknown) Class
 *
 *	Routines for handling per-process global data for the UNKOBJ Class
 *
 */

/*============================================================================
 *
 *	Initializes per-process global data for the UNKOBJ Class
 *
 */
IF_WIN32(__inline) SCODE
ScGetUnkClassInst(LPUNKOBJCLASSINST FAR *ppinst)
{
	SCODE sc = S_OK;
	LPUNKOBJCLASSINST pinst = NULL;

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		EnterCriticalSection(&csUnkobjInit);
#endif

	pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();

	if (pinst)
	{
		EnterCriticalSection(&pinst->cs);
		pinst->cRef++;
		LeaveCriticalSection(&pinst->cs);
		goto ret;
	}


	if (!(pinst = (LPUNKOBJCLASSINST) GlobalAllocPtr(GPTR, sizeof(UNKOBJCLASSINST))))
	{
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}

	//	Initialize the instance structure

//	DebugTrace( TEXT("Creating UnkObj Inst: %8x"), pinst);

	InitializeCriticalSection(&pinst->cs);
	pinst->cRef = 1;

	//	(the heap will be created when the first allocation is done) ....
	pinst->hlh = NULL;

#ifdef NEVER
	// Create a Heap for the UNKOBJ Class that will be used by
	// all unkobjs in this process.
	//$ NOTE: The heap creation can be removed from here and the
	//$ code to fault the heap in in UNKOBJ_ScCO(Re)Allocate()
	//$ enabled instead - that would *require* users of CreateIProp,
	//$ CreateITable etc not to do LH_SetHeapName().

	pinst->hlh = LH_Open(0);
	if (!pinst->hlh)
	{
		DebugTrace( TEXT("ScGetUnkClassInst():: Can't create Local Heap\n"));
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto ret;
	}
#endif

	// ... and install the instance globals.

	if (FAILED(sc = ScSetInstanceGlobals(pinst)))
	{
		DebugTrace( TEXT("ScGetUnkClassInst():: Failed to install instance globals\n"));
		goto ret;
	}

ret:
	if (FAILED(sc))
	{
		if (pinst)
		{
			DeleteCriticalSection(&pinst->cs);
			if (pinst->hlh)
				LH_Close(pinst->hlh);
			GlobalFreePtr(pinst);
			pinst = NULL;
		}
	}

	*ppinst = pinst;

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		LeaveCriticalSection(&csUnkobjInit);
#endif

	DebugTraceSc(ScInitInstance, sc);
	return sc;
}

/*============================================================================
 *
 *	Cleans up per-process global data for the UNKOBJ Class
 *
 */
IF_WIN32(__inline) void
ReleaseUnkClassInst()
{
	LPUNKOBJCLASSINST 		pinst = NULL;

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		EnterCriticalSection(&csUnkobjInit);
#endif

	pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();

	if (!pinst)
		goto out;

	EnterCriticalSection(&pinst->cs);
	if (--(pinst->cRef) > 0)
	{
		LeaveCriticalSection(&pinst->cs);
		goto out;
	}

	// The last Unkobj for this process is going away, hence close
	// our heap.

//	DebugTrace( TEXT("Deleting UnkObj Inst: %8x"), pinst);

	if (pinst->hlh)
	{
//		DebugTrace( TEXT("Destroying hlh (%8x) for Inst: %8x"), pinst->hlh, pinst);
		LH_Close(pinst->hlh);
	}

	pinst->hlh = 0;

	LeaveCriticalSection(&pinst->cs);
	DeleteCriticalSection(&pinst->cs);

	GlobalFreePtr(pinst);
	(void)ScSetInstanceGlobals(NULL);
out:

#if defined (WIN32) && !defined (MAC)
	if (fGlobalCSValid)
		LeaveCriticalSection(&csUnkobjInit);
#endif

	return;
}


/*============================================================================
 *	UNKOBJ (IMAPIUnknown) Class
 *
 *		Object methods.
 */


/*============================================================================
 -	UNKOBJ::QueryInterface()
 -
 */

STDMETHODIMP
UNKOBJ_QueryInterface (LPUNKOBJ	lpunkobj,
					   REFIID	riid,
					   LPVOID FAR * lppUnk)
{
	LPIID FAR *	lppiidSupported;
	ULONG		ulcIID;
	SCODE		sc;

#if	!defined(NO_VALIDATION)
	/* Validate the object.
	 */
    if (BAD_STANDARD_OBJ( lpunkobj, UNKOBJ_, QueryInterface, lpvtbl))
	{
		DebugTrace(  TEXT("UNKOBJ::QueryInterface() - Bad object passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

    Validate_IUnknown_QueryInterface(lpunkobj, riid, lppUnk);
#endif


	for ( lppiidSupported = lpunkobj->rgpiidList, ulcIID = lpunkobj->ulcIID
		; ulcIID
		; lppiidSupported++, ulcIID--)
	{
		if (IsEqualGUID(riid, *lppiidSupported))
		{
			/* We support the interface so break out of the search loop.
			 */
			break;
		}
	}

	/* Return error if the requested interface was not in our list of
	 * supported interfaces.
	 */
	if (!ulcIID)
	{
		*lppUnk = NULL;	// OLE requires zeroing [out] parameters
		sc = E_NOINTERFACE;
		goto error;
	}


	/* We found the requested interface so increment the reference count.
	 */
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->ulcRef++;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	*lppUnk = lpunkobj;

	return hrSuccess;

error:
	UNKOBJ_EnterCriticalSection(lpunkobj);
	UNKOBJ_SetLastError(lpunkobj, E_NOINTERFACE, 0);
	UNKOBJ_LeaveCriticalSection(lpunkobj);
	
	return ResultFromScode(sc);
}



/*============================================================================
 -	UNKOBJ::AddRef()
 -
 */

STDMETHODIMP_(ULONG)
UNKOBJ_AddRef( LPUNKOBJ lpunkobj )
{
	ULONG	ulcRef;


#if !defined(NO_VALIDATION)
	if (BAD_STANDARD_OBJ( lpunkobj, UNKOBJ_, AddRef, lpvtbl))
	{
		DebugTrace(  TEXT("UNKOBJ::AddRef() - Bad object passed\n") );
		return 42;
	}
#endif

	UNKOBJ_EnterCriticalSection(lpunkobj);
	ulcRef = ++lpunkobj->ulcRef;
	UNKOBJ_LeaveCriticalSection(lpunkobj);
	return ulcRef;
}



/*============================================================================
 -	UNKOBJ::GetLastError()
 -
 * NOTE!
 *	An error in GetLastError will NOT cause the objects last error to be
 *	set again.  This will allow the caller to retry the call.
 */

STDMETHODIMP
UNKOBJ_GetLastError( LPUNKOBJ			lpunkobj,
					 HRESULT			hrError,
					 ULONG				ulFlags,
					 LPMAPIERROR FAR *	lppMAPIError)
{
	SCODE	sc = S_OK;
	HRESULT	hrLastError;
	IDS		idsLastError;
	LPTSTR	lpszMessage = NULL;
	LPMAPIERROR lpMAPIError = NULL;


#if !defined(NO_VALIDATION)
	if (BAD_STANDARD_OBJ( lpunkobj, UNKOBJ_, GetLastError, lpvtbl))
	{
		DebugTrace(  TEXT("UNKOBJ::GetLastError() - Bad object passed\n") );
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}

    Validate_IMAPIProp_GetLastError(lpunkobj, hrError, ulFlags, lppMAPIError);
#endif

	/* Verify flags.
	 */
	if (ulFlags & ~(MAPI_UNICODE))
	{
		return ResultFromScode(MAPI_E_UNKNOWN_FLAGS);
	}

	*lppMAPIError = NULL;

	/* Get a snapshot of the last error.
	 */
	UNKOBJ_EnterCriticalSection(lpunkobj);
	idsLastError = lpunkobj->idsLastError;
	hrLastError = lpunkobj->hrLastError;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	/* If last error doesn't match parameter or there is no
	 * provider-context specific error string then just succeed.
	 */
	if ((hrError != hrLastError) || !idsLastError)
		goto out;

	/*  Generate new lpMAPIError
	 */
	sc = UNKOBJ_ScAllocate(lpunkobj,
							sizeof(MAPIERROR),
							&lpMAPIError);
	if (FAILED(sc))
	{
		DebugTrace(  TEXT("UNKOBJ::GetLastError() - Unable to allocate memory\n"));
		goto err;
	}

	FillMemory(lpMAPIError, sizeof(MAPIERROR), 0x00);
	lpMAPIError->ulVersion = MAPI_ERROR_VERSION;

	/*	Load a copy of the error string.
	 */
	if ( FAILED(sc = UNKOBJ_ScSzFromIdsAllocMore(lpunkobj,
											 idsLastError,
											 ulFlags,
											 lpMAPIError,
											 cchLastError,
											 &lpszMessage)) )
	{
		DebugTrace(  TEXT("UNKOBJ::GetLastError() - WARNING: Unable to load error string (SCODE = 0x%08lX). Returning hrSuccess.\n"), sc );
		return ResultFromScode(sc);
	}

	lpMAPIError->lpszError = lpszMessage;

	*lppMAPIError = lpMAPIError;

out:

	DebugTraceSc(UNKOBJ_GetLastError, sc);
	return ResultFromScode(sc);

err:
	UNKOBJ_Free( lpunkobj, lpMAPIError );

	goto out;
}


/*
 * UNKOBJ utility functions.
 */


/*============================================================================
 -	UNKOBJ::ScAllocate()
 -
 *		Utility function to allocate memory using MAPI linked memory.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lplpv		out		MAPI-Allocated buffer.
 */

STDAPI_(SCODE)
UNKOBJ_ScAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lplpv )
{
	// parameter validation
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );
			
	return lpunkobj->pinst->lpfAllocateBuffer(ulcb, lplpv);
}



/*============================================================================
 -	UNKOBJ::ScAllocateMore()
 -
 *		Utility function to allocate more memory using MAPI linked memory.
 *		If the link buffer is null, this function just does a MAPI allocate.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lpv			in		Buffer to link to.
 *		lplpv		out		New buffer
 */

STDAPI_(SCODE)
UNKOBJ_ScAllocateMore( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID		lpv,
					   LPVOID FAR *	lplpv )
{
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );
			
	return lpv ?
		lpunkobj->pinst->lpfAllocateMore(ulcb, lpv, lplpv) :
		lpunkobj->pinst->lpfAllocateBuffer(ulcb, lplpv) ;
}



/*============================================================================
 -	UNKOBJ::Free()
 -
 *		Utility function to free MAPI linked memory.  NULL buffers are ignored.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lpv			in		Buffer to free.
 */

STDAPI_(VOID)
UNKOBJ_Free( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv )
{
	// parameter validation
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
			
	if (lpv)
    {
        if (lpv == lpunkobj)
            lpunkobj->lpvtbl = NULL;

		(void) lpunkobj->pinst->lpfFreeBuffer(lpv);
    }
}



/*============================================================================
 -	UNKOBJ::FreeRows()
 -
 *		Frees a row set of the form returned from IMAPITable::QueryRows
 *		(i.e. where the row set and each individual *prop value array*
 *		in that row set are individually allocated with MAPI linked memory.)
 *		NULL row sets are ignored.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lprows		in		Row set to free.
 */

STDAPI_(VOID)
UNKOBJ_FreeRows( LPUNKOBJ	lpunkobj,
				 LPSRowSet	lprows )
{
	LPSRow	lprow;

	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( !lprows || !FBadRowSet( lprows ),  TEXT("lprows fails address check") );
	
	if ( !lprows )
		return;

	/* Free each row in the set from last to first.  UNKOBJ_Free
	 * handles NULL pointers.
	 */
	lprow = lprows->aRow + lprows->cRows;
	while ( lprow-- > lprows->aRow )
		UNKOBJ_Free((LPUNKOBJ) lpunkobj, lprow->lpProps);

	UNKOBJ_Free(lpunkobj, lprows);
}



/*============================================================================
 -	UNKOBJ::ScCOAllocate()
 -
 *		Utility function to allocate memory using CO memory allocators.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lplpv		out		Pointer to allocated buffer.
 */

STDAPI_(SCODE)
UNKOBJ_ScCOAllocate( LPUNKOBJ		lpunkobj,
					 ULONG			ulcb,
					 LPVOID FAR *	lplpv )
{
	HLH lhHeap;
	
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );

	/*	If caller _really_ wants a 0 byte allocation, warn
	 *	them and give them back a NULL pointer so that they
	 *	can't dereference it, but should be able to free it.
	 */
	if ( ulcb == 0 )
	{
		DebugTrace(  TEXT("LH_Alloc() - WARNING: Caller requested 0 bytes; returning NULL\n") );
		*lplpv = NULL;
		return S_OK;
	}

	lhHeap = lpunkobj->lhHeap;

	// Enable following section when we fault in the Heap - requires changes
	// throughout where CreateIProp/CreateITable calls are
	// done followed by LH_SetHeapName(). The LH_SetHeapName
	// calls have to be used since we may not have a heap
	// at the time. Furthermore, there is only 1 heap, so
	// they are unnecessary anyway.

#if 1
	if (!lhHeap)
	{
		LPUNKOBJCLASSINST pinst;

		// The UNKOBJ heap *probably* does not exist, make sure
		// (to guard against a race) and create it if indeed so.

		pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();
		Assert(pinst);
		EnterCriticalSection(&pinst->cs);
		if (!pinst->hlh)
		{


			lhHeap = LH_Open(0);
			if (!lhHeap)
			{
				DebugTrace( TEXT("UNKOBJ_ScCOAllocate() - Can't create Local Heap"));
				LeaveCriticalSection(&pinst->cs);
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}

//			DebugTrace( TEXT("Faulting in heap (%8x). UnkObj Inst: %8x"), lhHeap, pinst);

			// Install the heap handle in the global data

			pinst->hlh = lhHeap;
		}
		else
		{
			// The rare event that the heap got created by some other
			// object between our UNKOBJ_Init and this (first) allocation ...
			// ... Take it and use it.

			lhHeap = pinst->hlh;
		}

		LeaveCriticalSection(&pinst->cs);

		// Install the heap handle in this object's internal data too
		// so we don't have to access the instance data for subsequent
		// allocations. This does not need to be crit-sectioned on lpunkobj
		// since an overwrite will be with the same heap!.

		lpunkobj->lhHeap = lhHeap;

		LH_SetHeapName(lhHeap,  TEXT("UNKOBJ Internal Heap"));
	}
#endif

	/* Allocate the buffer.
	 */
	*lplpv = LH_Alloc( lhHeap,(UINT) ulcb );
	if (!*lplpv)
	{
		DebugTrace(  TEXT("LH_Alloc() - OOM allocating *lppv\n") );
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}
	LH_SetName1(lhHeap, *lplpv,  TEXT("UNKOBJ::ScCOAllocate %ld"), *lplpv);

	return S_OK;
}



/*============================================================================
 -	UNKOBJ::ScCOReallocate()
 -
 *		Utility function to reallocate memory using CO memory allocators.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ulcb		in		Count of bytes to allocate.
 *		lplpv		in		Pointer to buffer to reallocate.
 *					out		Pointer to reallocated buffer.
 */

STDAPI_(SCODE)
UNKOBJ_ScCOReallocate( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID FAR *	lplpv )
{
	HLH lhHeap;
	SCODE sc = S_OK;
	LPVOID lpv = NULL;
	
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lplpv && !IsBadWritePtr( lplpv, sizeof( LPVOID ) ),
			 TEXT("lplpv fails address check") );
	
	lhHeap = lpunkobj->lhHeap;

	// Enable following section when we fault in the Heap - requires changes
	// throughout where CreateIProp/CreateITable calls are
	// done followed by LH_SetHeapName(). The LH_SetHeapName
	// calls have to be used since we may not have a heap
	// at the time. Furthermore, there is only 1 heap, so
	// they are unnecessary anyway.

#if 1
	if (!lhHeap)
	{
		LPUNKOBJCLASSINST pinst;

		// The UNKOBJ heap *probably* does not exist, make sure
		// (to guard against a race) and create it if indeed so.

		pinst = (LPUNKOBJCLASSINST)PvGetInstanceGlobals();
		Assert(pinst);
		EnterCriticalSection(&pinst->cs);
		if (!pinst->hlh)
		{
			lhHeap = LH_Open(0);
			if (!lhHeap)
			{
				DebugTrace( TEXT("UNKOBJ_ScCOReallocate() - Can't create Local Heap"));
				LeaveCriticalSection(&pinst->cs);
				return MAPI_E_NOT_ENOUGH_MEMORY;
			}

//			DebugTrace( TEXT("Faulting in heap (%8x). UnkObj Inst: %8x"), lhHeap, pinst);

			// Install the heap handle in the global data

			pinst->hlh = lhHeap;
		}
		else
		{
			// The rare event that the heap got created by some other
			// object between our UNKOBJ_Init and this (first) allocation ...
			// ... Take it and use it.

			lhHeap = pinst->hlh;
		}

		LeaveCriticalSection(&pinst->cs);

		// Install the heap handle in this object's internal data too
		// so we don't have to access the instance data for subsequent
		// allocations. This does not need to be crit-sectioned on lpunkobj
		// since an overwrite will be with the same heap!.

		lpunkobj->lhHeap = lhHeap;

		LH_SetHeapName(lhHeap,  TEXT("UNKOBJ Internal Heap"));
	}	
#endif

//$BUG	Actually, the CO model is supposed do an Alloc() if
//$BUG	the pointer passed in is NULL, but it currently
//$BUG	doesn't seem to work that way....
	if ( *lplpv == NULL )
	{
		lpv = LH_Alloc(lhHeap, (UINT) ulcb);
		if (lpv)
		{
			*lplpv = lpv;
			LH_SetName1(lhHeap, lpv,  TEXT("UNKOBJ::ScCOReallocate %ld"), lpv);
		}
		else
			sc = E_OUTOFMEMORY;
		
		goto out;
	}

	/* Reallocate the buffer.
	 */
	lpv = LH_Realloc(lhHeap, *lplpv, (UINT) ulcb );
	if (!lpv)
	{
		DebugTrace(  TEXT("UNKOBJ::ScCOReallocate() - OOM reallocating *lplpv\n") );
		sc = MAPI_E_NOT_ENOUGH_MEMORY;
		goto out;
	}

	LH_SetName1(lhHeap, lpv,  TEXT("UNKOBJ::ScCOReallocate %ld"), lpv);
	*lplpv = lpv;

out:
	return sc;
}



/*============================================================================
 -	UNKOBJ::COFree()
 -
 *		Utility function to free memory using CO memory allocators.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		lpv			in		Buffer to free.
 */

STDAPI_(VOID)
UNKOBJ_COFree( LPUNKOBJ	lpunkobj,
			   LPVOID	lpv )
{
	HLH lhHeap;
	
	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	lhHeap = lpunkobj->lhHeap;
	
	/*	Free the buffer.
	 */
//$???	Don't know if CO properly handles freeing NULL pointers,
//$???	but I assume it doesn't....
	if ( lpv != NULL )
		LH_Free( lhHeap, lpv );
}



/*============================================================================
 -	UNKOBJ::ScSzFromIdsAlloc()
 -
 *		Utility function load a resource string into a MAPI-allocated buffer.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ids			in		ID of resource string.
 *		ulFlags		in		Flags (UNICODE or ANSI)
 *		cchBuf		in		Max length, in characters, to read.
 *		lpszBuf		out		Pointer to allocated buffer containing string.
 */

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAlloc( LPUNKOBJ		lpunkobj,
						 IDS			ids,
						 ULONG			ulFlags,
						 int			cchBuf,
						 LPTSTR FAR *	lppszBuf )
{
	SCODE	sc;
	ULONG	ulStringMax;


	// validate parameters
	
	AssertSz( lpunkobj && !FBadUnknown( (LPUNKNOWN)lpunkobj ),  TEXT("lpunkobj fails address check") );
	
	AssertSz( lppszBuf && !IsBadWritePtr( lppszBuf, sizeof( LPVOID ) ),
			 TEXT("lppszBuf fails address check") );
	
	AssertSz( cchBuf > 0,  TEXT("cchBuf can't be less than 1") );

	ulStringMax =  cchBuf
				 * ((ulFlags & MAPI_UNICODE) ? sizeof(TCHAR) : sizeof(CHAR));
	if ( FAILED(sc = UNKOBJ_ScAllocate(lpunkobj,
									   ulStringMax,
									   (LPVOID FAR *) lppszBuf)) )
	{
		DebugTrace(  TEXT("UNKOBJ::ScSzFromIdsAlloc() - Error allocating string (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

#if !defined(WIN16) && !defined(MAC)
	if ( ulFlags & MAPI_UNICODE )
		(void) LoadStringW(hinstMapiX,
						   (UINT) ids,
						   (LPWSTR) *lppszBuf,
						   cchBuf);
	else
#endif
		(void) LoadStringA(hinstMapiX,
						   (UINT) ids,
						   (LPSTR) *lppszBuf,
						   cchBuf);
	return S_OK;
}

/*============================================================================
 -	UNKOBJ::ScSzFromIdsAllocMore()
 -
 *		Utility function load a resource string into a MAPI-allocated buffer.
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 *		ids			in		ID of resource string.
 *		ulFlags		in		Flags (UNICODE or ANSI)
 *		lpvBase		in		Base allocation
 *		cchBuf		in		Max length, in characters, to read.
 *		lpszBuf		out		Pointer to allocated buffer containing string.
 */

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAllocMore( LPUNKOBJ		lpunkobj,
							 IDS			ids,
							 ULONG			ulFlags,
							 LPVOID			lpvBase,
							 int			cchBuf,
							 LPTSTR FAR *	lppszBuf )
{
	SCODE	sc;
	ULONG	ulStringMax;


	ulStringMax =  cchBuf
				 * ((ulFlags & MAPI_UNICODE) ? sizeof(WCHAR) : sizeof(CHAR));
	if ( FAILED(sc = UNKOBJ_ScAllocateMore(lpunkobj,
									   ulStringMax,
									   lpvBase,
									   (LPVOID FAR *) lppszBuf)) )
	{
		DebugTrace(  TEXT("UNKOBJ::ScSzFromIdsAllocMore() - Error allocating string (SCODE = 0x%08lX)\n"), sc );
		return sc;
	}

#if !defined(WIN16) && !defined(MAC)
	if ( ulFlags & MAPI_UNICODE )
		(void) LoadStringW(hinstMapiX,
						   (UINT) ids,
						   (LPWSTR) *lppszBuf,
						   cchBuf);
	else
#endif
		(void) LoadStringA(hinstMapiX,
						   (UINT) ids,
						   (LPSTR) *lppszBuf,
						   cchBuf);
	return S_OK;
}

/*============================================================================
 -	UNKOBJ::Init()
 -
 *		Initialize an object of the UNKOBJ Class
 *
 *
 *	Parameters:
 *		lpunkobj		in		UNKOBJ with instance variable containing
 *								allocators.
 *		lpvtblUnkobj	in		the object v-table
 *		ulcbVtbl		in		size of the object v-table
 *		rgpiidList		in		list of iid's supported by this object
 *		ulcIID			in		count of iid's in the list above
 *		punkinst		in		pointer to object's private (instance) data
 */

STDAPI_(SCODE)
UNKOBJ_Init( LPUNKOBJ			lpunkobj,
			 UNKOBJ_Vtbl FAR *	lpvtblUnkobj,
			 ULONG				ulcbVtbl,
			 LPIID FAR *		rgpiidList,
			 ULONG				ulcIID,
			 PUNKINST			punkinst )
{
	SCODE	sc = S_OK;
	LPUNKOBJCLASSINST 	pinst = NULL;

	// Create/Get per process global data for the Unkobj class
	// This gets faulted in the first time UNKOBJ_Init
	// is called by the process, i.e., when the process creates
	// its first Unkobj. Subsequent calls just Addref
	// the instance data. Note that this data is global to all
	// UNKOBJ objects (per process) and differs from the per object
	// data that *each* Unkobj keeps.

	sc = ScGetUnkClassInst(&pinst);
	if (FAILED(sc))
	{
		DebugTrace( TEXT("UNKOBJ_Init() - Can't create Instance Data"));
		goto ret;
	}

	Assert(pinst);

	lpunkobj->lpvtbl	= lpvtblUnkobj;
	lpunkobj->ulcbVtbl	= ulcbVtbl;
	lpunkobj->ulcRef	= 1;
	lpunkobj->rgpiidList= rgpiidList;
	lpunkobj->ulcIID	= ulcIID;
	lpunkobj->pinst		= punkinst;
	lpunkobj->hrLastError	= hrSuccess;
	lpunkobj->idsLastError	= 0;

	InitializeCriticalSection(&lpunkobj->csid);
	
	// If we have a heap for this instance, use it;
	// otherwise, wait and it'll get faulted in the first time
	// and allocation is made on this object.

	lpunkobj->lhHeap = pinst->hlh ? pinst->hlh : NULL;

ret:
	return sc;
}

/*============================================================================
 -	UNKOBJ::Deinit()
 -
 *		Deinitialize an object of the UNKOBJ Class
 *
 *
 *	Parameters:
 *		lpunkobj	in		UNKOBJ with instance variable containing
 *							allocators.
 */

STDAPI_(VOID)
UNKOBJ_Deinit( LPUNKOBJ lpunkobj )
{
	// Cleanup per process global data for the Unkobj class,
	// if necessary. Last one out will end up shutting off
	// the lights.

	ReleaseUnkClassInst();

	DeleteCriticalSection(&lpunkobj->csid);
}

#ifdef WIN16
// Win16 version of inline function. These are no longer inline function because
// Watcom WCC doesn't support inline. (WPP(C++ compiler) support inline.
VOID
UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj )
{
    EnterCriticalSection(&lpunkobj->csid);
}

VOID
UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj )
{
    LeaveCriticalSection(&lpunkobj->csid);
}

HRESULT
UNKOBJ_HrSetLastResult( LPUNKOBJ    lpunkobj,
                        HRESULT        hResult,
                        IDS            idsError )
{
    UNKOBJ_EnterCriticalSection(lpunkobj);
    lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = hResult;
    UNKOBJ_LeaveCriticalSection(lpunkobj);

    return hResult;
}

HRESULT
UNKOBJ_HrSetLastError( LPUNKOBJ    lpunkobj,
                       SCODE    sc,
                       IDS        idsError )
{
    UNKOBJ_EnterCriticalSection(lpunkobj);
    lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
    UNKOBJ_LeaveCriticalSection(lpunkobj);

    return ResultFromScode(sc);
}

VOID
UNKOBJ_SetLastError( LPUNKOBJ    lpunkobj,
                     SCODE        sc,
                     IDS        idsError )
{
    lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
}

VOID
UNKOBJ_SetLastErrorSc( LPUNKOBJ    lpunkobj,
                       SCODE    sc )
{
    lpunkobj->hrLastError = ResultFromScode(sc);
}

VOID
UNKOBJ_SetLastErrorIds( LPUNKOBJ    lpunkobj,
                        IDS            ids )
{
    lpunkobj->idsLastError = ids;
}
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\useragnt.h ===
// --------------------------------------------------------------------------------
// u s e r a g n t . h
//
// author:  Greg Friedman [gregfrie]
//
// history: 11-10-98    Created
//
// purpose: provide a common http user agent string for use by Outlook Express
//          in all http queries.
//
// dependencies: depends on ObtainUserAgent function in urlmon.
//
// Copyright (c) 1998 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------

#ifndef _USERAGNT_H
#define _USERAGNT_H

void InitWABUserAgent(BOOL fInit);

LPSTR GetWABUserAgentString(void);

#endif // _USERAGNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\validate.c ===
/*
 *	V A L I D A T E . C
 *	
 *	Functions used to validate parameters on standard MAPI object methods.
 *
 *	Used in conjunction with macros found in VALIDATE.H.
 *	
 *	Copyright 1992-93 Microsoft Corporation.  All Rights Reserved.
 */

#include <_apipch.h>


/*
 *	FBadRgPropVal()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		property value array, LPSPropVal
 */
/*
 *BOOL
 *FBadPropVal( LPSPropValue lpPropVal)
 *{
 *	ULONG		ulPropType;
 *	BOOL		fLongMVProp = FALSE;
 *	ULONG		cbItemType = 0;
 *	ULONG		cMVVals;
 *	LPVOID FAR	*lppvMVArray;
 *
 *	switch (ulPropType = PROP_TYPE(lpPropVal->ulPropTag))
 *	{
 *	case PT_STRING8:
 *
 *		if (IsBadStringPtrA( lpPropVal->Value.lpszA, (UINT)-1 ))
 *		{
 *			return TRUE;
 *		}
 *
 *		break;
 *
 *
 *#ifdef WIN32
 *	case PT_UNICODE:
 *
 *		if (IsBadStringPtrW( lpPropVal->Value.lpszW, (UINT)-1 ))
 *		{
 *			return TRUE;
 *		}
 *		break;
 *#endif
 *
 *
 *	case PT_BINARY:
 *
 *		if (IsBadReadPtr( lpPropVal->Value.bin.lpb
 *						, (UINT) lpPropVal->Value.bin.cb))
 *		{
 *			return TRUE;
 *		}
 *
 *		break;
 *
 *	case PT_MV_I2:					// 16 bit quantities
 *
 *		cbItemType = sizeof(lpPropVal->Value.i);
 *		break;
 *
 *
 *	case PT_MV_UNICODE:				// Arrays of strings
 *	case PT_MV_STRING8:
 *
 *		fLongMVProp = TRUE;
 *
 *		// Now fall thru to the 32 bit quantity code below to size the
 *		// top level array of ptrs
 *
 *
 *	case PT_MV_LONG:				// 32 bit quantities
 *	case PT_MV_R4:
 *
 *		cbItemType = sizeof(long);
 *		break;
 *
 *
 *	case PT_MV_BINARY:				// Arrays of counted binary data
 *
 *		fLongMVProp = TRUE;
 *
 *		// Now fall thru to the 64 bit quantity code below to size the array
 *		// of ULONG lengths / ULONG ptrs that comprise the top level stream
 *
 *
 *	case PT_MV_DOUBLE:				// 64 bit quantities
 *	case PT_MV_CURRENCY:
 *	case PT_MV_APPTIME:
 *	case PT_MV_SYSTIME:
 *	case PT_MV_I8:
 *
 *		// Assert that all array elements for this case are the same size.
 *		Assert( sizeof( double ) == sizeof( LARGE_INTEGER ));
 *		cbItemType = sizeof( double );
 *		break;
 *
 *
 *	case PT_MV_CLSID:				// 128 bit quantity
 *
 *		cbItemType = sizeof( GUID );
 *		break;
 *
 *
 *	case PT_OBJECT:
 *	case PT_NULL:
 *	default:
 *		if (ulPropType & MV_FLAG)
 *		{
 *			return TRUE;		// Unknown multivalue prop is bad
 *		}
 *
 *		break;
 *	}
 *
 *	if (!(ulPropType & MV_FLAG))
 *	{
 *		return FALSE;
 *	}
 *
 *	// Try to validate the multivalue props
 *
 *	// This code assumes that the count and ptr of every multivalue
 *	// property are in the same place.
 *	// Asserts check that the sizes of the grouped types above are
 *	// matched
 *
 *	cMVVals = lpPropVal->Value.MVl.cValues;
 *	lppvMVArray = (LPVOID FAR *) (lpPropVal->Value.MVl.lpl);
 *
 *	if (IsBadReadPtr( lppvMVArray, (UINT) (cMVVals * cbItemType)))
 *	{
 *		return TRUE;
 *	}
 *
 *	if (fLongMVProp)
 *	{
 *		// Go verify the array of pointers.
 *		for ( ; cMVVals; cMVVals--, lppvMVArray++)
 *		{
 *			switch (ulPropType)
 *			{
 *#ifdef WIN32
 *			case PT_MV_UNICODE:
 *
 *				if (IsBadStringPtrW( (LPCWSTR) (*lppvMVArray), (UINT) -1))
 *				{
 *					return TRUE;
 *				}
 *
 *				break;
 *#endif
 *			case PT_MV_STRING8:
 *
 *				if (IsBadStringPtrA( (LPCSTR) (*lppvMVArray), (UINT) -1))
 *				{
 *					return TRUE;
 *				}
 *
 *				break;
 *
 *			case PT_MV_BINARY:
 *
 *				if (IsBadReadPtr( ((SBinary FAR *)(*lppvMVArray))->lpb
 *								, (UINT)
 *								  ((SBinary FAR *)(*lppvMVArray))->cb))
 *				{
 *					return TRUE;
 *				}
 *				break;
 *			}
 *		}
 *	}
 *
 *	return FALSE;
 *}
 */

/*
 *	FBadRgPropVal()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		property value array, LPSPropVal
 */
/*BOOL
 *FBadRgPropVal( LPSPropValue lpPropVal,
 *			   ULONG cValues)
 *{
 *
 *	if (IsBadReadPtr( lpPropVal, sizeof(SPropValue) * (UINT) cValues))
 *	{
 *		return TRUE;
 *	}
 *
 *	// Warning!  Modifies the function parameters (NOT what they point to!).
 *	//
 *	for ( ; cValues ; cValues--, lpPropVal++)
 *	{
 *		if (FBadPropVal( lpPropVal))
 *		{
 *			return TRUE;
 *		}
 *	}
 *
 *	return FALSE;
 *}
 */

/*
 *	FBadRglpszA()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		array of string8 pointers, LPSTR FAR *.
 */
STDAPI_(BOOL)
FBadRglpszA( LPSTR FAR	*lppszA,
			 ULONG		cStrings)
{
	if (IsBadReadPtr( lppszA, (UINT) (cStrings * sizeof(LPSTR FAR *))))
	{
		return TRUE;
	}


	/* Check for readability of each string in the array.
	 *
	 * WARNING!
	 * Function pointers and counts are modified (NOT what they point to).
	 */
	for (; cStrings; cStrings--, lppszA++)
	{
		if (IsBadStringPtrA( *lppszA, (UINT)-1 ))
		{
			return TRUE;
		}
	}


	return FALSE;
}


/*
 *	FBadRglpszW()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		array of UNICODE string pointers, LPSTR FAR *.
 */
STDAPI_(BOOL)
FBadRglpszW( LPWSTR FAR	*lppszW,
			 ULONG		cStrings)
{
	if (IsBadReadPtr( lppszW, (UINT) (cStrings * sizeof(LPWSTR FAR *))))
	{
		return TRUE;
	}


	// Check for readability of each string in the array.
	//
	// WARNING!
	// Function pointers and counts are modified (NOT what they point to).
	//
	for (; cStrings; cStrings--, lppszW++)
	{
#ifdef MAC		
		if (IsBadStringPtr( *lppszW, (UINT)-1 ))
#else
		if (IsBadStringPtrW( *lppszW, (UINT)-1 ))
#endif			
		{
			return TRUE;
		}
	}


	return FALSE;
}


/*
 *	FBadRowSet()
 *
 *	Purpose:
 *		Routine to validate all rows of properties in a row set.
 *
 *	NOTE!	A NULL row pointer is assumed to be a VALID entry in a row set.
 *			A NULL row set pointer is assumed to be INVALID.
 */
STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet)
{
	LPSRow	lpRow;
	ULONG	cRows;

	if (IsBadReadPtr( lpRowSet, CbNewSRowSet(0)))
		return TRUE;
	
	if (IsBadWritePtr( lpRowSet, CbSRowSet(lpRowSet)))
		return TRUE;

	//  Short cut
	if (!lpRowSet->cRows)
		return FALSE;

	// Check each row in the set.
	// cValues == 0 is valid if and only if lpProps == NULL
	//
	for ( lpRow = lpRowSet->aRow, cRows = lpRowSet->cRows
		; cRows
		; lpRow++, cRows--)
	{
		if (   IsBadReadPtr( lpRow, sizeof(*lpRow))
#ifndef _WIN64
			|| FBadRgPropVal( lpRow->lpProps, (int) (lpRow->cValues))
#endif // _WIN64
            )
		{
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	FBadRglpNameID()
 *
 *	Purpose:
 *		Routine to attempt to validate all of the ptrs contained in an input
 *		array of MAPINAMEID pointers, LPMAPINAMEID FAR *.
 */
STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames)
{
	if (IsBadReadPtr( lppNameId, (UINT) (cNames * sizeof(LPMAPINAMEID FAR *))))
	{
		return TRUE;
	}


	// Check for readability of each string in the array.
	//
	for (; cNames; cNames--, lppNameId++)
	{
		LPMAPINAMEID lpName = *lppNameId;

		if (IsBadReadPtr(lpName, sizeof(MAPINAMEID)))
		{
			return TRUE;
		}

		if (IsBadReadPtr(lpName->lpguid, sizeof(GUID)))
		{
			return TRUE;
		}

		if (lpName->ulKind != MNID_ID && lpName->ulKind != MNID_STRING)
		{
			return TRUE;
		}

		if (lpName->ulKind == MNID_STRING)
		{
			if (IsBadStringPtrW( lpName->Kind.lpwstrName, (UINT)-1 ))				
			{
				return TRUE;
			}
		}

	}
	return FALSE;
}


/* FBadEntryList moved to src\lo\msvalid. */


/*============================================================================
 *	The following functions are used to determine the validity of various
 *	table-related structures.  These functions should most definitely
 *	be moved to proputil when it becomes a lib (or DLL).
 */



/*============================================================================
 -	FBadPropTag()
 -
 *		Returns TRUE if the specified prop tag isn't one of the known
 *		MAPI property types, FALSE otherwise.
 *
 *
 *	Parameter:
 *		ulPropTag	in	Proptag to validate.
 */

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag )
{
	//	Just check the type
	switch ( PROP_TYPE(ulPropTag) & ~MV_FLAG )
	{
		default:
			return TRUE;

		case PT_UNSPECIFIED:
		case PT_NULL:
		case PT_I2:
		case PT_LONG:
		case PT_R4:
		case PT_DOUBLE:
		case PT_CURRENCY:
		case PT_APPTIME:
		case PT_ERROR:
		case PT_BOOLEAN:
		case PT_OBJECT:
		case PT_I8:
		case PT_STRING8:
		case PT_UNICODE:
		case PT_SYSTIME:
		case PT_CLSID:
		case PT_BINARY:
			return FALSE;
	}
}


/*============================================================================
 -	FBadRow()
 -
 *		Returns TRUE if the specified row contains invalid (PT_ERROR or
 *		PT_NULL) columns or if any of those columns are invalid.
 *
 *
 *	Parameter:
 *		lprow	in		Row	to validate.
 */

STDAPI_(ULONG)
FBadRow( LPSRow lprow )
{
	LPSPropValue	lpprop;
	LPSPropValue	lppropT;


	if ( IsBadReadPtr(lprow, sizeof(SRow)) ||
		 IsBadReadPtr(lprow->lpProps, (size_t)(lprow->cValues * sizeof(SPropValue))) )
		return TRUE;

	lpprop = lprow->lpProps + lprow->cValues;
	while ( lpprop-- > lprow->lpProps )
	{
		if ( FBadProp(lpprop) )
			return TRUE;

		lppropT = lpprop;
		while ( lppropT-- > lprow->lpProps )
			if ( lppropT->ulPropTag == lpprop->ulPropTag &&
				 PROP_TYPE(lppropT->ulPropTag) != PT_ERROR &&
				 PROP_TYPE(lppropT->ulPropTag) != PT_NULL )
			{
				DebugTrace(  TEXT("FBadRow() - Row has multiple columns with same proptag!\n") );
				return TRUE;
			}
	}

	return FALSE;
}


/*============================================================================
 -	FBadProp()
 -
 *		Returns TRUE if the specified property is invalid.
 *
 *
 *	Parameters:
 *		lpprop	in		Property to validate.
 */

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop )
{
	ULONG	ulcb;
	LPVOID	lpv;

	if ( IsBadReadPtr(lpprop, sizeof(SPropValue)) ||
		 FBadPropTag(lpprop->ulPropTag) )
		return TRUE;

	switch ( PROP_TYPE(lpprop->ulPropTag) )
	{
		default:
			return FALSE;

		case PT_BINARY:
			ulcb = lpprop->Value.bin.cb;
			lpv = lpprop->Value.bin.lpb;
			break;

		case PT_STRING8:
			ulcb = sizeof(CHAR);
			lpv = lpprop->Value.lpszA;
			break;

#ifndef WIN16
		case PT_UNICODE:
			ulcb = sizeof(WCHAR);
			lpv = lpprop->Value.lpszW;
			break;
#endif
		case PT_CLSID:
			ulcb = sizeof(GUID);
			lpv = lpprop->Value.lpguid;
			break;

		case PT_MV_I2:
		case PT_MV_LONG:
		case PT_MV_R4:
		case PT_MV_DOUBLE:
		case PT_MV_CURRENCY:
		case PT_MV_I8:
			ulcb = UlPropSize(lpprop);
			lpv = lpprop->Value.MVi.lpi;
			break;

		case PT_MV_BINARY:
		{
			LPSBinary lpbin;
			
			if ( IsBadReadPtr(lpprop->Value.MVbin.lpbin,
							  (size_t)(lpprop->Value.MVbin.cValues *
									   sizeof(SBinary))) )
				return TRUE;

			lpbin = lpprop->Value.MVbin.lpbin + lpprop->Value.MVbin.cValues;
			while ( lpprop->Value.MVbin.lpbin < lpbin-- )
				if ( IsBadReadPtr(lpbin->lpb, (size_t)(lpbin->cb) ))
					return TRUE;

			return FALSE;
		}

		case PT_MV_STRING8:
		{
			LPCSTR FAR * lppsz;
			
			if ( IsBadReadPtr(lpprop->Value.MVszA.lppszA,
							  (size_t)(lpprop->Value.MVszA.cValues * sizeof(LPSTR))) )
				return TRUE;

			lppsz = lpprop->Value.MVszA.lppszA + lpprop->Value.MVszA.cValues;
			while ( lpprop->Value.MVszA.lppszA < lppsz-- )
// Need to break the code up this way for the Mac version
				if ( IsBadReadPtr(*lppsz, sizeof(CHAR)))
					return TRUE;
			return FALSE;
		}

		case PT_MV_UNICODE:
		{
			UNALIGNED LPWSTR FAR * lppsz;
			
			if ( IsBadReadPtr(lpprop->Value.MVszW.lppszW,
							  (size_t)(lpprop->Value.MVszW.cValues * sizeof(LPWSTR))) )
				return TRUE;

			lppsz = lpprop->Value.MVszW.lppszW + lpprop->Value.MVszW.cValues;
			while ( lpprop->Value.MVszW.lppszW < lppsz-- )
				if ( IsBadReadPtr(*lppsz, sizeof(WCHAR)))
					return TRUE;
			return FALSE;
		}
	}

	return IsBadReadPtr(lpv, (size_t) ulcb);
}


/* FBadSortOrderSet moved to src\lo\MSVALID.C */


/*============================================================================
 -	FBadColumnSet()
 -
 *		Returns TRUE if the specified column set is invalid.  For use
 *		with IMAPITable::SetColumns(), this function treats PT_ERROR columns
 *		as invalid and PT_NULL columns as valid.
 *
 *
 *	Parameter:
 *		lpptaCols		in		Column set to validate.
 */

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols )
{
	UNALIGNED ULONG FAR * pulPropTag;
	
	if ( IsBadReadPtr(lpptaCols,CbNewSPropTagArray(0)) ||
		 IsBadReadPtr(lpptaCols,CbSPropTagArray(lpptaCols)))
	{
		DebugTrace(  TEXT("FBadColumnSet() - Bad column set structure\n") );
		return TRUE;
	}

	// maximum number of proptags we can calculate size for. raid 4460
	
	if ( lpptaCols->cValues > ((INT_MAX - offsetof( SPropTagArray, aulPropTag ))
		/ sizeof( ULONG )))
	{
		DebugTrace(  TEXT("FBadColumnSet(): Exceeded maximum number of tags\n") );
		return TRUE;
	}

	pulPropTag = lpptaCols->aulPropTag + lpptaCols->cValues;
	while ( pulPropTag-- > lpptaCols->aulPropTag )
	{
		//	DCR 978: Disallow PT_ERROR columns.
		//	DCR 715: Ignore PT_NULL columns and only allow columns
		//	from initial column set.
		if ( PROP_TYPE(*pulPropTag) != PT_NULL &&
			 (PROP_TYPE(*pulPropTag) == PT_ERROR ||
			  FBadPropTag(*pulPropTag)) )
		{
			DebugTrace(  TEXT("FBadColumnSet() - Bad column 0x%08lX\n"), *pulPropTag );
			return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\vcard.c ===
/*
 *      VCard.C - Implement VCard
 *
 * Wrap VCard in a mailuser object
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 */

#include "_apipch.h"

#ifdef VCARD

// This is the current vCard version implemented in this file
//
#define CURRENT_VCARD_VERSION "2.1"
//#define CURRENT_VCARD_VERSION "2.1+"  <- The code is really this version, see the URL section in WriteVCard.

typedef enum _VC_STATE_ENUM {
    VCS_INITIAL,
    VCS_ITEMS,
    VCS_FINISHED,
    VCS_ERROR,
} VC_STATE_ENUM, *LPVC_STATE_ENUM;

typedef struct _VC_STATE {
    VC_STATE_ENUM vce;  // state
    ULONG ulEmailAddrs; // count of email addresses
    BOOL fBusinessURL;  // TRUE if we have already got a business URL
    BOOL fPersonalURL;  // TRUE if we have already got a personal URL
} VC_STATE, *LPVC_STATE;


typedef enum _VCARD_KEY {
    VCARD_KEY_NONE = -1,     // Always first
    VCARD_KEY_BEGIN = 0,
    VCARD_KEY_END,
    VCARD_KEY_ADR,
    VCARD_KEY_ORG,
    VCARD_KEY_N,
    VCARD_KEY_NICKNAME,
    VCARD_KEY_AGENT,
    VCARD_KEY_LOGO,
    VCARD_KEY_PHOTO,
    VCARD_KEY_LABEL,
    VCARD_KEY_FADR,
    VCARD_KEY_FN,
    VCARD_KEY_TITLE,
    VCARD_KEY_SOUND,
    VCARD_KEY_LANG,
    VCARD_KEY_TEL,
    VCARD_KEY_EMAIL,
    VCARD_KEY_TZ,
    VCARD_KEY_GEO,
    VCARD_KEY_NOTE,
    VCARD_KEY_URL,
    VCARD_KEY_BDAY,
    VCARD_KEY_ROLE,
    VCARD_KEY_REV,
    VCARD_KEY_UID,
    VCARD_KEY_KEY,
    VCARD_KEY_MAILER,
    VCARD_KEY_X,
    VCARD_KEY_VCARD,
    VCARD_KEY_VERSION,
    VCARD_KEY_X_WAB_GENDER,
    VCARD_KEY_MAX,
} VCARD_KEY, *LPVCARD_KEY;


// MUST be maintained in same order as _VCARD_KEY enum
const LPSTR vckTable[VCARD_KEY_MAX] = {
     "BEGIN",            // VCARD_KEY_BEGIN
     "END",              // VCARD_KEY_END
     "ADR",              // VCARD_KEY_ADR
     "ORG",              // VCARD_KEY_ORG
     "N",                // VCARD_KEY_N
     "NICKNAME",         // VCARD_KEY_NICKNAME
     "AGENT",            // VCARD_KEY_AGENT
     "LOGO",             // VCARD_KEY_LOGO
     "PHOTO",            // VCARD_KEY_PHOTO
     "LABEL",            // VCARD_KEY_LABEL
     "FADR",             // VCARD_KEY_FADR
     "FN",               // VCARD_KEY_FN
     "TITLE",            // VCARD_KEY_TITLE
     "SOUND",            // VCARD_KEY_SOUND
     "LANG",             // VCARD_KEY_LANG
     "TEL",              // VCARD_KEY_TEL
     "EMAIL",            // VCARD_KEY_EMAIL
     "TZ",               // VCARD_KEY_TZ
     "GEO",              // VCARD_KEY_GEO
     "NOTE",             // VCARD_KEY_NOTE
     "URL",              // VCARD_KEY_URL
     "BDAY",             // VCARD_KEY_BDAY
     "ROLE",             // VCARD_KEY_ROLE
     "REV",              // VCARD_KEY_REV
     "UID",              // VCARD_KEY_UID
     "KEY",              // VCARD_KEY_KEY
     "MAILER",           // VCARD_KEY_MAILER
     "X-",               // VCARD_KEY_X
     "VCARD",            // VCARD_KEY_VCARD
     "VERSION",          // VCARD_KEY_VERSION
     "X-WAB-GENDER",     // VCARD_KEY_X_WAB_GENDER
};

typedef enum _VCARD_TYPE {
    VCARD_TYPE_NONE = -1,    // always first
    VCARD_TYPE_DOM = 0,
    VCARD_TYPE_INTL,
    VCARD_TYPE_POSTAL,
    VCARD_TYPE_PARCEL,
    VCARD_TYPE_HOME,
    VCARD_TYPE_WORK,
    VCARD_TYPE_PREF,
    VCARD_TYPE_VOICE,
    VCARD_TYPE_FAX,
    VCARD_TYPE_MSG,
    VCARD_TYPE_CELL,
    VCARD_TYPE_PAGER,
    VCARD_TYPE_BBS,
    VCARD_TYPE_MODEM,
    VCARD_TYPE_CAR,
    VCARD_TYPE_ISDN,
    VCARD_TYPE_VIDEO,
    VCARD_TYPE_AOL,
    VCARD_TYPE_APPLELINK,
    VCARD_TYPE_ATTMAIL,
    VCARD_TYPE_CIS,
    VCARD_TYPE_EWORLD,
    VCARD_TYPE_INTERNET,
    VCARD_TYPE_IBMMAIL,
    VCARD_TYPE_MSN,
    VCARD_TYPE_MCIMAIL,
    VCARD_TYPE_POWERSHARE,
    VCARD_TYPE_PRODIGY,
    VCARD_TYPE_TLX,
    VCARD_TYPE_X400,
    VCARD_TYPE_GIF,
    VCARD_TYPE_CGM,
    VCARD_TYPE_WMF,
    VCARD_TYPE_BMP,
    VCARD_TYPE_MET,
    VCARD_TYPE_PMB,
    VCARD_TYPE_DIB,
    VCARD_TYPE_PICT,
    VCARD_TYPE_TIFF,
    VCARD_TYPE_ACROBAT,
    VCARD_TYPE_PS,
    VCARD_TYPE_JPEG,
    VCARD_TYPE_QTIME,
    VCARD_TYPE_MPEG,
    VCARD_TYPE_MPEG2,
    VCARD_TYPE_AVI,
    VCARD_TYPE_WAVE,
    VCARD_TYPE_AIFF,
    VCARD_TYPE_PCM,
    VCARD_TYPE_X509,
    VCARD_TYPE_PGP,
    VCARD_TYPE_MAX
} VCARD_TYPE, *LPVCARD_TYPE;


// MUST be maintained in same order as _VCARD_TYPE enum
const LPSTR vctTable[VCARD_TYPE_MAX] = {
     "DOM",              // VCARD_TYPE_DOM
     "INTL",             // VCARD_TYPE_INTL
     "POSTAL",           // VCARD_TYPE_POSTAL
     "PARCEL",           // VCARD_TYPE_PARCEL
     "HOME",             // VCARD_TYPE_HOME
     "WORK",             // VCARD_TYPE_WORK
     "PREF",             // VCARD_TYPE_PREF
     "VOICE",            // VCARD_TYPE_VOICE
     "FAX",              // VCARD_TYPE_FAX
     "MSG",              // VCARD_TYPE_MSG
     "CELL",             // VCARD_TYPE_CELL
     "PAGER",            // VCARD_TYPE_PAGER
     "BBS",              // VCARD_TYPE_BBS
     "MODEM",            // VCARD_TYPE_MODEM
     "CAR",              // VCARD_TYPE_CAR
     "ISDN",             // VCARD_TYPE_ISDN
     "VIDEO",            // VCARD_TYPE_VIDEO
     "AOL",              // VCARD_TYPE_AOL
     "APPLELINK",        // VCARD_TYPE_APPLELINK
     "ATTMAIL",          // VCARD_TYPE_ATTMAIL
     "CIS",              // VCARD_TYPE_CIS
     "EWORLD",           // VCARD_TYPE_EWORLD
     "INTERNET",         // VCARD_TYPE_INTERNET
     "IBMMAIL",          // VCARD_TYPE_IBMMAIL
     "MSN",              // VCARD_TYPE_MSN
     "MCIMAIL",          // VCARD_TYPE_MCIMAIL
     "POWERSHARE",       // VCARD_TYPE_POWERSHARE
     "PRODIGY",          // VCARD_TYPE_PRODIGY
     "TLX",              // VCARD_TYPE_TLX
     "X400",             // VCARD_TYPE_X400
     "GIF",              // VCARD_TYPE_GIF
     "CGM",              // VCARD_TYPE_CGM
     "WMF",              // VCARD_TYPE_WMF
     "BMP",              // VCARD_TYPE_BMP
     "MET",              // VCARD_TYPE_MET
     "PMB",              // VCARD_TYPE_PMB
     "DIB",              // VCARD_TYPE_DIB
     "PICT",             // VCARD_TYPE_PICT
     "TIFF",             // VCARD_TYPE_TIFF
     "ACROBAT",          // VCARD_TYPE_ACROBAT
     "PS",               // VCARD_TYPE_PS
     "JPEG",             // VCARD_TYPE_JPEG
     "QTIME",            // VCARD_TYPE_QTIME
     "MPEG",             // VCARD_TYPE_MPEG
     "MPEG2",            // VCARD_TYPE_MPEG2
     "AVI",              // VCARD_TYPE_AVI
     "WAVE",             // VCARD_TYPE_WAVE
     "AIFF",             // VCARD_TYPE_AIFF
     "PCM",              // VCARD_TYPE_PCM
     "X509",             // VCARD_TYPE_X509
     "PGP",              // VCARD_TYPE_PGP
};


typedef enum _VCARD_PARAM{
    VCARD_PARAM_NONE = -1,      // always first
    VCARD_PARAM_TYPE = 0,
    VCARD_PARAM_ENCODING,
    VCARD_PARAM_LANGUAGE,
    VCARD_PARAM_VALUE,
    VCARD_PARAM_CHARSET,
    VCARD_PARAM_MAX,
} VCARD_PARAM, *LPVCARD_PARAM;

// MUST be maintained in same order as _VCARD_PARAM enum
const LPSTR vcpTable[VCARD_PARAM_MAX] = {
     "TYPE",             // VCARD_PARAM_TYPE
     "ENCODING",         // VCARD_PARAM_ENCODING
     "LANGUAGE",         // VCARD_PARAM_LANGUAGE
     "VALUE",            // VCARD_PARAM_VALUE
     "CHARSET",          // VCARD_PARAM_CHARSET
};


typedef enum _VCARD_ENCODING{
    VCARD_ENCODING_NONE = -1,  // always first
    VCARD_ENCODING_QUOTED_PRINTABLE = 0,
    VCARD_ENCODING_BASE64,
    VCARD_ENCODING_7BIT,
    VCARD_ENCODING_8BIT,
    VCARD_ENCODING_X,
    VCARD_ENCODING_MAX,
} VCARD_ENCODING, *LPVCARD_ENCODING;


// MUST be maintained in same order as _VCARD_ENCODING enum
const LPSTR vceTable[VCARD_ENCODING_MAX] = {
     "QUOTED-PRINTABLE", // VCARD_ENCODING_QUOTED_PRINTABLE
     "BASE64",           // VCARD_ENCODING_BASE64
     "7BIT",             // VCARD_ENCODING_7BIT
     "8BIT",             // VCARD_ENCODING_8BIT
     "X-",               // VCARD_ENCODING_X
};

const LPTSTR szColon =   TEXT(":");
const LPSTR szColonA =   ":";
const LPTSTR szSemicolon =   TEXT(";");
const LPSTR szEquals =   "=";
const LPSTR szCRLFA =   "\r\n";
const LPTSTR szCRLF =   TEXT("\r\n");
const LPTSTR szCommaSpace =   TEXT(", ");
const LPTSTR szSpace = TEXT(" ");
const LPTSTR szX400 =   TEXT("X400");
const LPSTR szSMTPA =  "SMTP";

typedef struct _VCARD_PARAM_FLAGS {
    int fTYPE_DOM:1;
    int fTYPE_INTL:1;
    int fTYPE_POSTAL:1;
    int fTYPE_PARCEL:1;
    int fTYPE_HOME:1;
    int fTYPE_WORK:1;
    int fTYPE_PREF:1;
    int fTYPE_VOICE:1;
    int fTYPE_FAX:1;
    int fTYPE_MSG:1;
    int fTYPE_CELL:1;
    int fTYPE_PAGER:1;
    int fTYPE_BBS:1;
    int fTYPE_MODEM:1;
    int fTYPE_CAR:1;
    int fTYPE_ISDN:1;
    int fTYPE_VIDEO:1;
    int fTYPE_AOL:1;
    int fTYPE_APPLELINK:1;
    int fTYPE_ATTMAIL:1;
    int fTYPE_CIS:1;
    int fTYPE_EWORLD:1;
    int fTYPE_INTERNET:1;
    int fTYPE_IBMMAIL:1;
    int fTYPE_MSN:1;
    int fTYPE_MCIMAIL:1;
    int fTYPE_POWERSHARE:1;
    int fTYPE_PRODIGY:1;
    int fTYPE_TLX:1;
    int fTYPE_X400:1;
    int fTYPE_GIF:1;
    int fTYPE_CGM:1;
    int fTYPE_WMF:1;
    int fTYPE_BMP:1;
    int fTYPE_MET:1;
    int fTYPE_PMB:1;
    int fTYPE_DIB:1;
    int fTYPE_PICT:1;
    int fTYPE_TIFF:1;
    int fTYPE_ACROBAT:1;
    int fTYPE_PS:1;
    int fTYPE_JPEG:1;
    int fTYPE_QTIME:1;
    int fTYPE_MPEG:1;
    int fTYPE_MPEG2:1;
    int fTYPE_AVI:1;
    int fTYPE_WAVE:1;
    int fTYPE_AIFF:1;
    int fTYPE_PCM:1;
    int fTYPE_X509:1;
    int fTYPE_PGP:1;
    int fPARAM_TYPE:1;
    int fPARAM_ENCODING:1;
    int fPARAM_LANGUAGE:1;
    int fPARAM_VALUE:1;
    int fPARAM_CHARSET:1;
    int fENCODING_QUOTED_PRINTABLE:1;
    int fENCODING_BASE64:1;
    int fENCODING_7BIT:1;
    int fENCODING_X:1;
    LPSTR szPARAM_LANGUAGE;
    LPSTR szPARAM_CHARSET;

} VCARD_PARAM_FLAGS, *LPVCARD_PARAM_FLAGS;

// 
// For WAB clients that use named props and want to get/put their unique data
// in the vCards as extended vCard properties, we will store these extended
// props in a linked list and use it when importing/exporting a vCard
//
typedef struct _ExtVCardProp
{
    ULONG ulExtPropTag;
    LPSTR lpszExtPropName;
    struct _ExtVCardProp * lpNext;
} EXTVCARDPROP, * LPEXTVCARDPROP;


CONST CHAR six2base64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

CONST INT base642six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

HRESULT ReadLn(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppLine, LPULONG lpcbItem,
  LPSTR * lppBuffer, LPULONG lpcbBuffer);
HRESULT InterpretVCardItem (LPSTR lpName, LPSTR lpOption, LPSTR lpData,
  LPMAILUSER lpMailUser, LPEXTVCARDPROP lpList, LPVC_STATE lpvcs);
void ParseVCardItem(LPSTR lpBuffer, LPSTR * lppName, LPSTR * lppOption, LPSTR * lppData);
HRESULT ParseVCardType(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf);
HRESULT ParseVCardParams(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf);
VCARD_KEY RecognizeVCardKeyWord(LPSTR lpName);
HRESULT ParseVCardEncoding(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf);
HRESULT ReadVCardItem(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppBuffer, LPULONG lpcbBuffer);
HRESULT FileWriteFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbWritten);
HRESULT ParseCert( LPSTR lpData, ULONG cbData, LPMAILUSER lpMailUser );
HRESULT DecodeBase64(LPSTR bufcoded,LPSTR pbuffdecoded, PDWORD pcbDecoded);
HRESULT WriteVCardValue(HANDLE hVCard, VCARD_WRITE WriteFn, LPBYTE lpData, ULONG cbData);

/***************************************************************************

    Name      : FreeExtVCardPropList

    Purpose   : Frees the localalloced list of extended props that we
                get/set on a vCard

    Parameters: lpList -> list to free up

    Returns   : void

    Comment   :

***************************************************************************/
void FreeExtVCardPropList(LPEXTVCARDPROP lpList)
{
    LPEXTVCARDPROP lpTmp = lpList;
    while(lpTmp)
    {
        lpList = lpList->lpNext;
        LocalFreeAndNull(&lpTmp->lpszExtPropName);
        LocalFree(lpTmp);
        lpTmp = lpList;
    }
}

/***************************************************************************

    Name      : HrGetExtVCardPropList

    Purpose   : Reads the registry for registered named props for VCard 
                import/export and gets the named prop names and guids
                and extended prop strings and turns them into proper tags
                and stores these tags and strings in a linked list 

    Parameters: lppList -> list to return

    Returns   : HRESULT

    Comment   :

***************************************************************************/
static const TCHAR szNamedVCardPropsRegKey[] =  TEXT("Software\\Microsoft\\WAB\\WAB4\\NamedVCardProps");
 
HRESULT HrGetExtVCardPropList(LPMAILUSER lpMailUser, LPEXTVCARDPROP * lppList)
{
    HRESULT hr = E_FAIL;
    HKEY hKey = NULL;
    LPEXTVCARDPROP lpList = NULL;
    DWORD dwIndex = 0, dwSize = 0;
    TCHAR szGuidName[MAX_PATH];

    if(!lppList)
        goto out;
    *lppList = NULL;

    // 
    // We will look in the registry under HKLM\Software\Microsoft\WAB\WAB4\NamedVCardProps
    // If this key exists, we enumerate all sub keys under it
    // The format for this key is
    //
    // HKLM\Software\Microsoft\WAB\WAB4\NamedVCardProps
    //          Guid1
    //              PropString1:PropName1
    //              PropString1:PropName2
    //          Guid2
    //              PropString1:PropName1
    // etc
    //

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    szNamedVCardPropsRegKey,
                                    0, KEY_READ,
                                    &hKey))
    {
        goto out;
    }

    *szGuidName = '\0';
    dwSize = CharSizeOf(szGuidName);

    // Found the key, now enumerate all sub keys ...
    while(ERROR_SUCCESS == RegEnumKeyEx(hKey, dwIndex, szGuidName, &dwSize, NULL, NULL, NULL, NULL))
    {
        GUID guidTmp = {0};
        unsigned short szW[MAX_PATH];

        StrCpyN(szW, szGuidName, ARRAYSIZE(szW));
        if( !(HR_FAILED(hr = CLSIDFromString(szW, &guidTmp))) )
        {
            HKEY hGuidKey = NULL;

            // Open the GUID key
            if(ERROR_SUCCESS == RegOpenKeyEx(hKey, szGuidName, 0, KEY_READ, &hGuidKey))
            {
                TCHAR szValName[MAX_PATH];
                DWORD dwValIndex = 0, dwValSize = CharSizeOf(szValName);
                DWORD dwType = 0, dwTagName = 0, dwTagSize = sizeof(DWORD);
                TCHAR szTagName[MAX_PATH];

                *szValName = '\0';

                while(ERROR_SUCCESS == RegEnumValue(hGuidKey, dwValIndex, 
                                                    szValName, &dwValSize, 
                                                    0, &dwType, 
                                                    NULL, NULL))
                {
                    MAPINAMEID mnid = {0};
                    LPMAPINAMEID lpmnid = NULL;
                    LPSPropTagArray lpspta = NULL;

                    *szTagName = '\0';
                    // Check if this is a NAME or an ID
                    
                    if(dwType == REG_DWORD)
                    {
                        dwTagSize = sizeof(DWORD);
                        //Read in the Value
                        if(ERROR_SUCCESS != RegQueryValueEx(hGuidKey, szValName,
                                                            0, &dwType, 
                                                            (LPBYTE) &dwTagName, &dwTagSize))
                        {
                            continue;
                        }
                    }
                    else if(dwType == REG_SZ)
                    {
                        dwTagSize = CharSizeOf(szTagName);
                        //Read in the Value
                        if(ERROR_SUCCESS != RegQueryValueEx(hGuidKey, szValName,
                                                            0, &dwType, 
                                                            (LPBYTE) szTagName, &dwTagSize))
                        {
                            continue;
                        }
                    }

                    //
                    // At this point I have the GUID, the name of the named prop, and the
                    // ExtendedPropString for this prop ..
                    //
                    // First get the actual named proptag from this GUID
                    //

                    mnid.lpguid = &guidTmp;
                    if(lstrlen(szTagName))
                    {
                        mnid.ulKind = MNID_STRING;
                        mnid.Kind.lpwstrName = (LPWSTR) szTagName;
                    }
                    else
                    {
                        mnid.ulKind = MNID_ID;
                        mnid.Kind.lID = dwTagName;
                    }
                    lpmnid = &mnid;
                    if(!HR_FAILED(lpMailUser->lpVtbl->GetIDsFromNames(  lpMailUser, 
                                                                        1, &lpmnid,
                                                                        MAPI_CREATE, // Dont create if it dont exist 
                                                                        &lpspta)))
                    {
                        // Got the tag
                        if(lpspta->aulPropTag[0] && lpspta->cValues)
                        {
                            LPEXTVCARDPROP lpTmp = LocalAlloc(LMEM_ZEROINIT, sizeof(EXTVCARDPROP));
                            if(lpTmp)
                            {
                                lpTmp->lpszExtPropName = ConvertWtoA(szValName);
                                if(lpTmp->lpszExtPropName)
                                {
                                    lpTmp->ulExtPropTag = CHANGE_PROP_TYPE(lpspta->aulPropTag[0],PT_STRING8);
                                    lpTmp->lpNext = lpList;
                                    lpList = lpTmp;
                                }
                                else
                                    LocalFree(lpTmp);
                            }
                        }
                        if(lpspta)
                            MAPIFreeBuffer(lpspta);
                    }

                    dwValIndex++;
                    *szValName = '\0';
                    dwValSize = CharSizeOf(szValName);
                }
            }
            if(hGuidKey)
                RegCloseKey(hGuidKey);
        }
        dwIndex++;
        *szGuidName = '\0';
        dwSize = CharSizeOf(szGuidName);
    }

    *lppList = lpList;
    hr = S_OK;
out:
    if(hKey)
        RegCloseKey(hKey);

    if(HR_FAILED(hr) && lpList)
        FreeExtVCardPropList(lpList);

    return hr;

}

const static int c_cchMaxWin9XBuffer = 1000;

/***************************************************************************

    Name      : ReadVCard

    Purpose   : Reads a vCard from a file to a MAILUSER object.

    Parameters: hVCard = open handle to VCard object
                ReadFn = Read function to read hVCard, looks like ReadFile().
                lpMailUser -> open mailuser object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ReadVCard(HANDLE hVCard, VCARD_READ ReadFn, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    LPSTR lpBuffer = NULL;
    LPSTR lpName, lpOption, lpData;
    ULONG cbBuffer;
    VC_STATE vcs;
    LPEXTVCARDPROP lpList = NULL;

    vcs.vce = VCS_INITIAL;
    vcs.ulEmailAddrs = 0;
    vcs.fBusinessURL = FALSE;
    vcs.fPersonalURL = FALSE;

    //
    // See if there are any named props we need to handle on import
    //
    HrGetExtVCardPropList(lpMailUser, &lpList);


    while ( !HR_FAILED(hResult) && 
            !(HR_FAILED(hResult = ReadVCardItem(hVCard, ReadFn, &lpBuffer, &cbBuffer))) && 
            lpBuffer &&
            (vcs.vce != VCS_FINISHED)) 
    {
        ParseVCardItem(lpBuffer, &lpName, &lpOption, &lpData);

        // [PaulHi] 5/13/99  Win9X cannot handle strings larger than 1023 characters
        // in length (FormatMessage() is one example).  And can cause buffer overruns
        // and crashes.  If we get VCard data greater than this then we must not add
        // it to the lpMailUser object, or risk crashing Win9X when trying to display.
        // Instead just truncate so user can salvage as much as possible.
		//
		// YSt 6/25/99 if vCard has certificate then buffer may be more than 1000 bytes, we need to exlude this case
		// from this checkin.
		// I suppose that certificate has VCARD_KEY_KEY tag
        if (!g_bRunningOnNT && (lpName && lstrcmpiA(lpName, vckTable[VCARD_KEY_KEY])) && lpData && (lstrlenA(lpData) > c_cchMaxWin9XBuffer) )
            lpData[c_cchMaxWin9XBuffer] = '\0';

        if (lpName && lpData) 
        {
            if (hResult = InterpretVCardItem(lpName, lpOption, lpData, lpMailUser, lpList, &vcs)) 
            {
                DebugTrace( TEXT("ReadVCard:InterpretVCardItem -> %x"), GetScode(hResult));
            }
        }
        LocalFreeAndNull(&lpBuffer);
    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    if(lpList)
        FreeExtVCardPropList(lpList);

    return(hResult);
}

/***************************************************************************

    Name      : BufferReadFn

    Purpose   : Read from the supplied buffer

    Parameters: handle = pointer to SBinary in which the
                        lpb contains the source buffer and the
                        cb param contains how much of the buffer has
                        been parsed
                lpBuffer -> buffer to read to
                uBytes = size of lpBuffer
                lpcbRead -> returned bytes read

    Returns   : HRESULT

***************************************************************************/
HRESULT BufferReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead) {

    LPSBinary lpsb = (LPSBinary) handle;
    LPSTR lpBuf = (LPSTR) lpsb->lpb;
    LPSTR lpSrc = lpBuf + lpsb->cb;

    *lpcbRead = 0;

    if(!lstrlenA(lpSrc))
        return(ResultFromScode(WAB_W_END_OF_DATA));

    if(uBytes > (ULONG) lstrlenA(lpSrc))
        uBytes = lstrlenA(lpSrc);

    CopyMemory(lpBuffer, lpSrc, uBytes);

    lpsb->cb += uBytes;

    *lpcbRead = uBytes;

    return(hrSuccess);
}


/***************************************************************************

    Name      : FileReadFn

    Purpose   : Read from the file handle

    Parameters: handle = open file handle
                lpBuffer -> buffer to read to
                uBytes = size of lpBuffer
                lpcbRead -> returned bytes read

    Returns   : HRESULT

    Comment   : ReadFile callback for ReadVCard

***************************************************************************/
HRESULT FileReadFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbRead) {
    *lpcbRead = 0;

    if (! ReadFile(handle,
      lpBuffer,
      uBytes,
      lpcbRead,
      NULL)) {
        DebugTrace( TEXT("FileReadFn:ReadFile -> %u\n"), GetLastError());
        return(ResultFromScode(MAPI_E_DISK_ERROR));
    }

    if (*lpcbRead == 0) {
        return(ResultFromScode(WAB_W_END_OF_DATA));
    }

    return(hrSuccess);
}


/***************************************************************************

    Name      : TrimLeadingWhitespace

    Purpose   : Move the pointer past any whitespace.

    Parameters: lpBuffer -> string (null terminated)

    Returns   : pointer to next non-whitespace or NULL if end of line

    Comment   :

***************************************************************************/
LPBYTE TrimLeadingWhitespace(LPBYTE lpBuffer) {
    while (*lpBuffer) {
        switch (*lpBuffer) {
            case ' ':
            case '\t':
                lpBuffer++;
                break;
            default:
                return(lpBuffer);
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : TrimTrailingWhiteSpace

    Purpose   : Trims off the trailing white space

    Parameters: lpString = string to trim

    Returns   : none

    Comment   : Starts at the end of the string, moving the EOS marker back
                until a non-whitespace character is found.  Space and Tab
                are the only whitespace characters recognized.

***************************************************************************/
void TrimTrailingWhiteSpace(LPSTR lpString)
{
   register LPSTR lpEnd;

   lpEnd = lpString + (lstrlenA(lpString) - 1);
   while ((lpEnd >= lpString) && ((*lpEnd == ' ') || (*lpEnd == '\t'))) {
       *(lpEnd--) = '\0';
   }
}


/***************************************************************************

    Name      : ParseWord

    Purpose   : Move the pointer to the next word and null the end of the
                current word.  (null terminated)

    Parameters: lpBuffer -> current word
                ch = delimiter character

    Returns   : pointer to next word or NULL if end of line

    Comment   :

***************************************************************************/
LPSTR ParseWord(LPSTR lpString, TCHAR ch) {
    while (*lpString) {
        if (*lpString == ch) {
            *lpString++ = '\0';
            lpString = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpString);
            if (lpString && *lpString) {
                return(lpString);
            } else {
                return(NULL);
            }
        }
        lpString++;
    }

    // Didn't find another word.
    return(NULL);
}


/***************************************************************************

    Name      : RecognizeVCardKeyWord

    Purpose   : Recognize the vCard keyword (null terminated)

    Parameters: lpName -> start of key name

    Returns   : VCARD_KEY value

    Comment   :

***************************************************************************/
VCARD_KEY RecognizeVCardKeyWord(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_KEY_MAX; i++) {
        if (! lstrcmpiA(vckTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_KEY_NONE);     // didn't recognize
}


/***************************************************************************

    Name      : RecognizeVCardType

    Purpose   : Recognize the vCard type option (null terminated)

    Parameters: lpName -> start of type name

    Returns   : VCARD_OPTION value

    Comment   :

***************************************************************************/
VCARD_TYPE RecognizeVCardType(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_TYPE_MAX; i++) {
        if (! lstrcmpiA(vctTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_TYPE_NONE);     // didn't recognize
}


/***************************************************************************

    Name      : RecognizeVCardParam

    Purpose   : Recognize the vCard param (null terminated)

    Parameters: lpName -> start of param name

    Returns   : VCARD_PARAM value

    Comment   :

***************************************************************************/
VCARD_PARAM RecognizeVCardParam(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_PARAM_MAX; i++) {
        if (! lstrcmpiA(vcpTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_PARAM_NONE);
}


/***************************************************************************

    Name      : RecognizeVCardEncoding

    Purpose   : Recognize the vCard encoding (null terminated)

    Parameters: lpName -> start of encoding name

    Returns   : VCARD_ENCODING value

    Comment   :

***************************************************************************/
VCARD_ENCODING RecognizeVCardEncoding(LPSTR lpName) {
    register ULONG i;

    // Look for recognized words
    for (i = 0; i < VCARD_ENCODING_MAX; i++) {
        if (! lstrcmpiA(vceTable[i], lpName)) {
            // Found it
            return(i);
        }
    }
    return(VCARD_ENCODING_NONE);     // didn't recognize
}


/***************************************************************************

    Name      : ParseVCardItem

    Purpose   : Parse the vCard item into components

    Parameters: lpBuffer = current input line (null terminated)
                lppName -> returned property name pointer
                lppOption -> returned options string pointer
                lppData -> returned data string pointer

    Returns   : none

    Comment   : Expects the keyword to be in the current line (lpBuffer), but
                may read more lines as necesary to get a complete item.

***************************************************************************/
void ParseVCardItem(LPSTR lpBuffer, LPSTR * lppName, LPSTR * lppOption, LPSTR * lppData) {
    TCHAR ch;
    BOOL fColon = FALSE;
    BOOL fSemicolon = FALSE;


    *lppName = *lppOption = *lppData = NULL;

    // Find the Name
    if (lpBuffer = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer)) {
        *lppName = lpBuffer;

        while (ch = *lpBuffer) {
            switch (ch) {
                case ':':   // found end of name/options
                    fColon = TRUE;
                    // data follows whitespace
                    *lppData = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer + 1);
                    *lpBuffer = '\0';   // null out colon
                    goto exit;

                case ';':   // found an option seperator
                    if (! fSemicolon) {
                        fSemicolon = TRUE;
                        // option follows semicolon and whitespace
                        *lppOption = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer + 1);
                        *lpBuffer = '\0';   // null out first semicolon
                    }
                    break;

                case '.':   // end of a group prefix
                    if (! fColon && ! fSemicolon) {
                        // Yes, this is a group prefix.  Get past it.
                        *lppName = (LPSTR)TrimLeadingWhitespace((LPBYTE)lpBuffer + 1);
                    }
                    break;

                default:    // normal character
                    break;
            }

            lpBuffer++;
        }
    }
exit:
    return;
}


/***************************************************************************

    Name      : ParseName

    Purpose   : parse the name into properites

    Parameters: lpvcpf = parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   : vCard names are of the form:
                 TEXT("surname; given name; middle name; prefix; suffix")

***************************************************************************/
HRESULT ParseName(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[5] = {0};
    register LPSTR lpCurrent;
    ULONG i = 0;

    // Look for Surname
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_SURNAME, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_GIVEN_NAME, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_MIDDLE_NAME, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_DISPLAY_NAME_PREFIX, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_GENERATION, PT_STRING8);
            spv[i].Value.lpszA = lpCurrent;
            i++;
        }
    }

    if (i) {
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          i,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseName:SetProps -> %x\n"), GetScode(hResult));
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : ParseAdr

    Purpose   : parse the address into properites

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   : vCard addreses are of the form:
                 TEXT("PO box; extended addr; street addr; city; region; postal code; country")

                Option: DOM; INTL; POSTAL; PARCEL; HOME; WORK; PREF; CHARSET; LANGUAGE

                We will combine extended addr and street addr into PR_STREET_ADDRESS.

***************************************************************************/
HRESULT ParseAdr(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[7] = {0};   // must keep up with props set from ADR!
    register LPSTR lpCurrent;
    ULONG i = 0;
    LPSTR lpStreetAddr = NULL;
    LPSTR lpExtendedAddr = NULL;
    ULONG cbAddr = 0;
    LPSTR lpAddr = NULL;
    SCODE sc;
    BOOL fHome = lpvcpf->fTYPE_HOME;
    BOOL fBusiness = lpvcpf->fTYPE_WORK;  
    //
    // default is other type of address

    // Look for PO box
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_POST_OFFICE_BOX, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_POST_OFFICE_BOX, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_POST_OFFICE_BOX, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }
    // extended addr
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            lpExtendedAddr = lpCurrent;
        }
    }
    // Street address
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            lpStreetAddr = lpCurrent;
        }
    }
    if (fBusiness) {    // BUSINESS
         if (lpExtendedAddr) {
            // have a business extended addr field
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OFFICE_LOCATION, PT_STRING8);
            spv[i].Value.lpszA = lpExtendedAddr;;
            i++;
         }
         if (lpStreetAddr) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_STREET, PT_STRING8);
            spv[i].Value.lpszA = lpStreetAddr;;
            i++;
         }
    } else {            // HOME
        // Don't have extended for home
        if (! lpExtendedAddr && lpStreetAddr) {
            if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STREET, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STREET, PT_STRING8);
            spv[i].Value.lpszA= lpStreetAddr;
            i++;
        } else if (lpExtendedAddr && ! lpStreetAddr) {
            if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STREET, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STREET, PT_STRING8);
            spv[i].Value.lpszA= lpExtendedAddr;
            i++;
        } else {
            // Have to concatenate Extended and Street address
            if (lpExtendedAddr) {
                cbAddr = (lstrlenA(lpExtendedAddr)+1);
            }
            if (lpStreetAddr) {
                cbAddr += (lstrlenA(lpStreetAddr)+1);
            }
            if (cbAddr) {
                // room for CR and NULL
                if (sc = MAPIAllocateBuffer(cbAddr, &lpAddr)) {
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                if (lpExtendedAddr) {
                    StrCpyNA(lpAddr, lpExtendedAddr, (cbAddr / sizeof(lpAddr[0])));
                    if (lpStreetAddr) {
                        StrCatBuffA(lpAddr,  "\n", (cbAddr / sizeof(lpAddr[0])));
                    }
                    StrCatBuffA(lpAddr, lpStreetAddr, (cbAddr / sizeof(lpAddr[0])));
                } else if (lpStreetAddr) {
                    StrCpyNA(lpAddr, lpStreetAddr, (cbAddr / sizeof(lpAddr[0])));
                }

                if(fHome)
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STREET, PT_STRING8);
                else
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STREET, PT_STRING8);
                spv[i].Value.lpszA= lpAddr;
                i++;
            }
        }
    }


    // locality (city)
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_CITY, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_CITY, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_CITY, PT_STRING8);
           spv[i].Value.lpszA= lpCurrent;
           i++;
        }
    }

    // region (state/province)
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_STATE_OR_PROVINCE, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_STATE_OR_PROVINCE, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }

    // postal code
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_POSTAL_CODE, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_POSTAL_CODE, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_POSTAL_CODE, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }

    // Country
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            if(fBusiness)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_ADDRESS_COUNTRY, PT_STRING8);
            else if(fHome)
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_ADDRESS_COUNTRY, PT_STRING8);
            else
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_ADDRESS_COUNTRY, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }

    if (i) {
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          i,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseAdr:SetProps -> %x\n"), GetScode(hResult));
        }
    }
exit:
    FreeBufferAndNull(&lpAddr);

    return(hResult);
}


enum {
    iphPR_BUSINESS_FAX_NUMBER,
    iphPR_HOME_FAX_NUMBER,
    iphPR_CELLULAR_TELEPHONE_NUMBER,
    iphPR_CAR_TELEPHONE_NUMBER,
    iphPR_ISDN_NUMBER,
    iphPR_PAGER_TELEPHONE_NUMBER,
    iphPR_BUSINESS_TELEPHONE_NUMBER,
    iphPR_BUSINESS2_TELEPHONE_NUMBER,
    iphPR_HOME_TELEPHONE_NUMBER,
    iphPR_HOME2_TELEPHONE_NUMBER,
    iphPR_PRIMARY_TELEPHONE_NUMBER,
    iphPR_OTHER_TELEPHONE_NUMBER,
    iphMax
};

SizedSPropTagArray(iphMax, tagaPhone) = {
        iphMax,
   {
       PR_BUSINESS_FAX_NUMBER,
       PR_HOME_FAX_NUMBER,
       PR_CELLULAR_TELEPHONE_NUMBER,
       PR_CAR_TELEPHONE_NUMBER,
       PR_ISDN_NUMBER,
       PR_PAGER_TELEPHONE_NUMBER,
       PR_BUSINESS_TELEPHONE_NUMBER,
       PR_BUSINESS2_TELEPHONE_NUMBER,
       PR_HOME_TELEPHONE_NUMBER,
       PR_HOME2_TELEPHONE_NUMBER,
       PR_PRIMARY_TELEPHONE_NUMBER,
       PR_OTHER_TELEPHONE_NUMBER
        }
};
/***************************************************************************

    Name      : ParseTel

    Purpose   : parse the telephone number into properites

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseTel(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[iphMax] = {0};
    ULONG i = 0;
    BOOL fBusiness = lpvcpf->fTYPE_WORK;// || ! lpvcpf->fTYPE_HOME;  // default is business
    BOOL fHome = lpvcpf->fTYPE_HOME;
    BOOL fFax = lpvcpf->fTYPE_FAX;
    BOOL fCell = lpvcpf->fTYPE_CELL;
    BOOL fCar = lpvcpf->fTYPE_CAR;
    BOOL fModem = lpvcpf->fTYPE_MODEM;
    BOOL fISDN = lpvcpf->fTYPE_ISDN;
    BOOL fPager = lpvcpf->fTYPE_PAGER;
    BOOL fBBS = lpvcpf->fTYPE_BBS;
    BOOL fVideo = lpvcpf->fTYPE_VIDEO;
    BOOL fMsg = lpvcpf->fTYPE_MSG;
    BOOL fVoice = lpvcpf->fTYPE_VOICE | (! (fMsg | fFax | fModem | fISDN | fPager | fBBS));
    BOOL fPref = lpvcpf->fTYPE_PREF;
    LPSPropValue lpaProps = NULL;
    ULONG ulcProps;

    // if this is not a prefered address, and its not home or business
    // turn it into a business number - we make this exception for the
    // primary_telephone_number which we output with the PREF prefix
    if(!fPref && !fBusiness && !fHome && !fVoice)
        fBusiness = TRUE;

    // FAX #
    if (lpData && *lpData) {

        // What is already there?
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
          (LPSPropTagArray)&tagaPhone,
          0, //MAPI_UNICODE,    // ulFlags,
          &ulcProps,
          &lpaProps))) {
            DebugTraceResult( TEXT("ParseTel:GetProps(DL)\n"), hResult);
            // No properties, not fatal.
        }


        if (fFax) {
            if (fBusiness) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_BUSINESS_FAX_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_FAX_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
            if (fHome) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_HOME_FAX_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_FAX_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
        }

        // CELL #
        if (fCell) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_CELLULAR_TELEPHONE_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_CELLULAR_TELEPHONE_NUMBER, PT_STRING8);    // not business/home specific
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // CAR #
        if (fCar) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_CAR_TELEPHONE_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_CAR_TELEPHONE_NUMBER, PT_STRING8);         // not business/home specific
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // ISDN #
        if (fISDN) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_ISDN_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_ISDN_NUMBER, PT_STRING8);
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // PAGER #
        if (fPager) {
            if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_PAGER_TELEPHONE_NUMBER])) {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_PAGER_TELEPHONE_NUMBER, PT_STRING8);
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        // VOICE #
        if (fVoice) {
            if (fBusiness) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_BUSINESS_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
                else if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_BUSINESS2_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_BUSINESS2_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
            else
            if (fHome) {
                if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_HOME_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
                else if (lpvcpf->fTYPE_PREF || PROP_ERROR(lpaProps[iphPR_HOME2_TELEPHONE_NUMBER])) {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_HOME2_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
            else
            {
                if (lpvcpf->fTYPE_VOICE && PROP_ERROR(lpaProps[iphPR_OTHER_TELEPHONE_NUMBER])
                    && !(fFax | fCell | fCar | fModem | fISDN | fPager | fBBS | fVideo | fMsg) ) 
                {
                    spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_TELEPHONE_NUMBER, PT_STRING8);
                    spv[i].Value.lpszA= lpData;
                    i++;
                }
            }
        }

        if(fPref && !fFax && !fCell && !fCar && !fModem && !fISDN && !fPager && !fBBS && !fMsg)
        {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_PRIMARY_TELEPHONE_NUMBER, PT_STRING8);
            spv[i].Value.lpszA= lpData;
            i++;
        }

        // Store the first one of BBS, MODEM, or VIDEO that we get
        //
        if (fMsg || fBBS || fModem || fVideo) 
        {
            if (PROP_ERROR(lpaProps[iphPR_OTHER_TELEPHONE_NUMBER])) 
            {
                spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_OTHER_TELEPHONE_NUMBER, PT_STRING8);
                spv[i].Value.lpszA= lpData;
                i++;
            }
        }

        FreeBufferAndNull(&lpaProps);

        if (i) {
            if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
              i,
              spv,
              NULL))) {
                DebugTrace( TEXT("ParseTel:SetProps -> %x\n"), GetScode(hResult));
            }
        }
    }

    return(hResult);
}


enum {
    iemPR_CONTACT_EMAIL_ADDRESSES,
    iemPR_CONTACT_ADDRTYPES,
    iemPR_CONTACT_DEFAULT_ADDRESS_INDEX,
    iemPR_EMAIL_ADDRESS,
    iemPR_ADDRTYPE,
    iemMax
};

SizedSPropTagArray(iemMax, tagaEmail) = {
        iemMax,
   {
       PR_CONTACT_EMAIL_ADDRESSES,
       PR_CONTACT_ADDRTYPES,
       PR_CONTACT_DEFAULT_ADDRESS_INDEX,
       PR_EMAIL_ADDRESS,
       PR_ADDRTYPE,
        }
};

const char szAtSign[] =  "@";
#define cbAtSign    sizeof(szAtSign)

const char szMSNpostfix[] =  "@msn.com";
#define cbMSNpostfix    sizeof(szMSNpostfix)

const char szAOLpostfix[] =  "@aol.com";
#define cbAOLpostfix    sizeof(szAOLpostfix)

const char szCOMPUSERVEpostfix[] =  "@compuserve.com";
#define cbCOMPUSERVEpostfix    sizeof(szCOMPUSERVEpostfix)

/***************************************************************************

    Name      : ParseEmail

    Purpose   : parse an email address into properites

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object
                lpvcs -> vCard import state

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseEmail(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser, LPVC_STATE lpvcs) {
    HRESULT hResult = hrSuccess;
    ULONG i = 0;
    BOOL fBusiness = ! lpvcpf->fTYPE_HOME;  // default is business
    LPSPropValue lpaProps = NULL;
    ULONG ulcProps;
    SCODE sc;
    LPSTR lpAddrType = szSMTPA;
    LPSTR lpEmailAddress = lpData;
    LPSTR lpTemp = NULL;
    LPTSTR lpAddrTypeW = NULL;
    LPTSTR lpEmailAddressW = NULL;


    if (lpData && *lpData) {

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
          (LPSPropTagArray)&tagaEmail,
          MAPI_UNICODE,    // ulFlags,
          &ulcProps,
          &lpaProps))) {
            DebugTraceResult( TEXT("ParseEmail:GetProps(DL)\n"), hResult);
            // No property, not fatal.

            // allocate a buffer
            if (sc = MAPIAllocateBuffer(iemMax * sizeof(SPropValue), &lpaProps)) {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                sc = ResultFromScode(sc);
                goto exit;
            }
            // fill in with prop errors
            lpaProps[iemPR_EMAIL_ADDRESS].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_EMAIL_ADDRESS));
            lpaProps[iemPR_ADDRTYPE].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_ADDRTYPE));
            lpaProps[iemPR_CONTACT_EMAIL_ADDRESSES].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_CONTACT_EMAIL_ADDRESSES));
            lpaProps[iemPR_CONTACT_ADDRTYPES].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_CONTACT_ADDRTYPES));
            lpaProps[iemPR_CONTACT_DEFAULT_ADDRESS_INDEX].ulPropTag =
              PROP_TAG(PT_ERROR, PROP_ID(PR_CONTACT_DEFAULT_ADDRESS_INDEX));
        }

        if (lpvcpf->fTYPE_INTERNET) {
            // default
        } else if (lpvcpf->fTYPE_MSN) {
            // convert to SMTP
            // Allocate a new, longer string
            DWORD cchSize = (lstrlenA(lpData) + 1 + cbMSNpostfix);
            if (sc = MAPIAllocateBuffer((cchSize * sizeof(lpTemp[0])), &lpTemp))
            {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // append the msn site
            StrCpyNA(lpTemp, lpData, cchSize);
            StrCatBuffA(lpTemp, szMSNpostfix, cchSize);
            lpEmailAddress = lpTemp;
        } else if (lpvcpf->fTYPE_CIS) {
            // convert to SMTP
            // Allocate a new, longer string
            DWORD cchSize2 = (lstrlenA(lpData) + 1 + cbCOMPUSERVEpostfix);
            if (sc = MAPIAllocateBuffer((cchSize2 * sizeof(lpTemp[0])), &lpTemp))
            {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // append the MSN site
            StrCpyNA(lpTemp, lpData, cchSize2);
            StrCatBuffA(lpTemp, szCOMPUSERVEpostfix, cchSize2);
            // I need to convert the ',' to a '.'
            lpEmailAddress = lpTemp;
            while (*lpTemp) {
                if (*lpTemp == ',') {
                    *lpTemp = '.';
                    break;          // should only be one comma
                }
                lpTemp = CharNextA(lpTemp);
            }
            lpTemp = lpEmailAddress;
        } else if (lpvcpf->fTYPE_AOL) {
            // convert to SMTP
            // Allocate a new, longer string
            DWORD cchSize3 = (lstrlenA(lpData) + 1 + cbAOLpostfix);
            if (sc = MAPIAllocateBuffer((cchSize3 * sizeof(lpTemp[0])), &lpTemp))
            {
                DebugTrace( TEXT("ParseEmail:MAPIAllocateBuffer -> %x\n"), sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // append the AOL site
            StrCpyNA(lpTemp, lpData, cchSize3);
            StrCatBuffA(lpTemp, szAOLpostfix, cchSize3);
            lpEmailAddress = lpTemp;
        }

        // Don't know of any mappings to SMTP for these:
        else if (lpvcpf->fTYPE_X400) {
            // Mark as X400
            lpAddrType = vctTable[VCARD_TYPE_X400];
        } else if (lpvcpf->fTYPE_ATTMAIL) {
            // Mark as ATTMAIL
            lpAddrType = vctTable[VCARD_TYPE_ATTMAIL];
        } else if (lpvcpf->fTYPE_EWORLD) {
            // Mark as EWORLD
            lpAddrType = vctTable[VCARD_TYPE_EWORLD];
        } else if (lpvcpf->fTYPE_IBMMAIL) {
            // Mark as IBMMAIL
            lpAddrType = vctTable[VCARD_TYPE_IBMMAIL];
        } else if (lpvcpf->fTYPE_MCIMAIL) {
            // Mark as MCIMAIL
            lpAddrType = vctTable[VCARD_TYPE_MCIMAIL];
        } else if (lpvcpf->fTYPE_POWERSHARE) {
            // Mark as POWERSHARE
            lpAddrType = vctTable[VCARD_TYPE_POWERSHARE];
        } else if (lpvcpf->fTYPE_PRODIGY) {
            // Mark as PRODIGY
            lpAddrType = vctTable[VCARD_TYPE_PRODIGY];
//
// Telex Number should go in PR_TELEX_NUMBER
//        } else if (lpvcpf->fTYPE_TLX) {
//            // Mark as TLX
//            lpAddrType = vctTable[VCARD_TYPE_TLX];
        }

        lpEmailAddressW = ConvertAtoW(lpEmailAddress);
        lpAddrTypeW = ConvertAtoW(lpAddrType);

        if (hResult = AddPropToMVPString(lpaProps,
          ulcProps,
          iemPR_CONTACT_EMAIL_ADDRESSES,
          lpEmailAddressW)) {
            goto exit;
        }

        if (hResult = AddPropToMVPString(lpaProps,
          ulcProps,
          iemPR_CONTACT_ADDRTYPES,
          lpAddrTypeW)) {
            goto exit;
        }

        // Is this the default email address?
        if (lpvcpf->fTYPE_PREF || lpvcs->ulEmailAddrs == 0) {
            lpaProps[iemPR_CONTACT_DEFAULT_ADDRESS_INDEX].ulPropTag = PR_CONTACT_DEFAULT_ADDRESS_INDEX;
            lpaProps[iemPR_CONTACT_DEFAULT_ADDRESS_INDEX].Value.l = lpvcs->ulEmailAddrs;

            lpaProps[iemPR_EMAIL_ADDRESS].ulPropTag = PR_EMAIL_ADDRESS;
            lpaProps[iemPR_EMAIL_ADDRESS].Value.LPSZ = lpEmailAddressW;

            lpaProps[iemPR_ADDRTYPE].ulPropTag = PR_ADDRTYPE;
            lpaProps[iemPR_ADDRTYPE].Value.LPSZ = lpAddrTypeW;
        } else {
            ulcProps = 2;     // contact addresses and contact addrtypes
        }

        lpvcs->ulEmailAddrs++;

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          ulcProps,
          lpaProps,
          NULL))) {
            DebugTrace( TEXT("ParseEmail:SetProps -> %x\n"), GetScode(hResult));
        }
    }
exit:
    FreeBufferAndNull(&lpaProps);
    FreeBufferAndNull(&lpTemp);
    LocalFreeAndNull(&lpAddrTypeW);
    LocalFreeAndNull(&lpEmailAddressW);
    return(hResult);
}

/***************************************************************************

    Name      : ParseBday

    Purpose   : parse the birthday from string into FileTime

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseBday(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpDataA, LPMAILUSER lpMailUser) 
{
    HRESULT hResult = hrSuccess;
    SPropValue  spv[1] = {0};
    SYSTEMTIME st = {0};
    TCHAR sz[32];
    LPTSTR lpTmp = NULL;
    LPTSTR lpData = ConvertAtoW(lpDataA);
    
    // Birthday can be in 2 formats:
    // basic ISO 8601: YYYYMMDD
    // or
    // extended ISO 8601: YYYY-MM-DDTHH-MM-SSetc
    //
    // we'll assume that if the strlen == 8, then it is basic
    //
    if (lpData && *lpData && (lstrlen(lpData) >= 8)) 
    {
        StrCpyN(sz, lpData,ARRAYSIZE(sz));
        sz[31] = '\0';

        if(lstrlen(lpData) == 8) //basic ISO 8601
        {
            lpTmp = &(sz[6]);
            st.wDay = (WORD) my_atoi(lpTmp);
            *lpTmp = '\0';
            lpTmp = &(sz[4]);
            st.wMonth = (WORD) my_atoi(lpTmp);
            *lpTmp = '\0';
            st.wYear = (WORD) my_atoi(sz);
        }
        else //extended ISO 8601
        {
            sz[10]='\0';
            lpTmp = &(sz[8]);
            st.wDay = (WORD) my_atoi(lpTmp);
            sz[7]='\0';
            lpTmp = &(sz[5]);
            st.wMonth = (WORD) my_atoi(lpTmp);
            sz[4]='\0';
            st.wYear = (WORD) my_atoi(sz);
        }
        SystemTimeToFileTime(&st, &(spv[0].Value.ft));
        spv[0].ulPropTag = PR_BIRTHDAY;

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                              1, spv,
                                                              NULL))) 
        {
            DebugTrace( TEXT("ParseBday(0x%08x):SetProps -> %x\n"), PR_BIRTHDAY, GetScode(hResult));
        }
    }

    LocalFreeAndNull(&lpData);

    return(hResult);
}



/***************************************************************************

    Name      : ParseSimple

    Purpose   : parse the simple text prop into the property

    Parameters: lpvcpf -> parameter flags
                lpData = data string
                lpMailUser -> output mailuser object
                ulPropTag = property to save

    Returns   : hResult

    Comment   :

***************************************************************************/
HRESULT ParseSimple(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser,
  ULONG ulPropTag) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[1] = {0};

    if (lpData && *lpData) {
        spv[0].ulPropTag = CHANGE_PROP_TYPE(ulPropTag, PT_STRING8);
        spv[0].Value.lpszA= lpData;

        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          1,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseSimple(0x%08x):SetProps -> %x\n"), ulPropTag, GetScode(hResult));
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : InterpretVCardEncoding

    Purpose   : Recognize the VCard encoding and set the flags

    Parameters: lpType = encoding string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT InterpretVCardEncoding(LPSTR lpEncoding, LPVCARD_PARAM_FLAGS lpvcpf) {
    HRESULT hResult = hrSuccess;

    if (*lpEncoding) {
        // what is it?
        switch (RecognizeVCardEncoding(lpEncoding)) {
            case VCARD_ENCODING_NONE:
                break;

            case VCARD_ENCODING_QUOTED_PRINTABLE:
                lpvcpf->fENCODING_QUOTED_PRINTABLE = TRUE;
                break;
            case VCARD_ENCODING_BASE64:
                lpvcpf->fENCODING_BASE64 = TRUE;
                break;

            case VCARD_ENCODING_7BIT:
                lpvcpf->fENCODING_7BIT = TRUE;
                break;

            default:
                // Assert(FALSE);
                break;
        }
    }
    return(hResult);
}


/***************************************************************************

    Name      : InterpretVCardType

    Purpose   : Recognize the VCard type and set the flags

    Parameters: lpType = type string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT InterpretVCardType(LPSTR lpType, LPVCARD_PARAM_FLAGS lpvcpf) {
    HRESULT hResult = hrSuccess;

    if (*lpType) {
        // what is it?
        switch (RecognizeVCardType(lpType)) {
            case VCARD_TYPE_DOM:
                lpvcpf->fTYPE_DOM = TRUE;
                break;
            case VCARD_TYPE_INTL:
                lpvcpf->fTYPE_INTL = TRUE;
                break;
            case VCARD_TYPE_POSTAL:
                lpvcpf->fTYPE_POSTAL = TRUE;
                break;
            case VCARD_TYPE_PARCEL:
                lpvcpf->fTYPE_PARCEL = TRUE;
                break;
            case VCARD_TYPE_HOME:
                lpvcpf->fTYPE_HOME = TRUE;
                break;
            case VCARD_TYPE_WORK:
                lpvcpf->fTYPE_WORK = TRUE;
                break;
            case VCARD_TYPE_PREF:
                lpvcpf->fTYPE_PREF = TRUE;
                break;
            case VCARD_TYPE_VOICE:
                lpvcpf->fTYPE_VOICE = TRUE;
                break;
            case VCARD_TYPE_FAX:
                lpvcpf->fTYPE_FAX = TRUE;
                break;
            case VCARD_TYPE_MSG:
                lpvcpf->fTYPE_MSG = TRUE;
                break;
            case VCARD_TYPE_CELL:
                lpvcpf->fTYPE_CELL = TRUE;
                break;
            case VCARD_TYPE_PAGER:
                lpvcpf->fTYPE_PAGER = TRUE;
                break;
            case VCARD_TYPE_BBS:
                lpvcpf->fTYPE_BBS = TRUE;
                break;
            case VCARD_TYPE_MODEM:
                lpvcpf->fTYPE_MODEM = TRUE;
                break;
            case VCARD_TYPE_CAR:
                lpvcpf->fTYPE_CAR = TRUE;
                break;
            case VCARD_TYPE_ISDN:
                lpvcpf->fTYPE_ISDN = TRUE;
                break;
            case VCARD_TYPE_VIDEO:
                lpvcpf->fTYPE_VIDEO = TRUE;
                break;
            case VCARD_TYPE_AOL:
                lpvcpf->fTYPE_AOL = TRUE;
                break;
            case VCARD_TYPE_APPLELINK:
                lpvcpf->fTYPE_APPLELINK = TRUE;
                break;
            case VCARD_TYPE_ATTMAIL:
                lpvcpf->fTYPE_ATTMAIL = TRUE;
                break;
            case VCARD_TYPE_CIS:
                lpvcpf->fTYPE_CIS = TRUE;
                break;
            case VCARD_TYPE_EWORLD:
                lpvcpf->fTYPE_EWORLD = TRUE;
                break;
            case VCARD_TYPE_INTERNET:
                lpvcpf->fTYPE_INTERNET = TRUE;
                break;
            case VCARD_TYPE_IBMMAIL:
                lpvcpf->fTYPE_IBMMAIL = TRUE;
                break;
            case VCARD_TYPE_MSN:
                lpvcpf->fTYPE_MSN = TRUE;
                break;
            case VCARD_TYPE_MCIMAIL:
                lpvcpf->fTYPE_MCIMAIL = TRUE;
                break;
            case VCARD_TYPE_POWERSHARE:
                lpvcpf->fTYPE_POWERSHARE = TRUE;
                break;
            case VCARD_TYPE_PRODIGY:
                lpvcpf->fTYPE_PRODIGY = TRUE;
                break;
            case VCARD_TYPE_TLX:
                lpvcpf->fTYPE_TLX = TRUE;
                break;
            case VCARD_TYPE_X400:
                lpvcpf->fTYPE_X400 = TRUE;
                break;
            case VCARD_TYPE_GIF:
                lpvcpf->fTYPE_GIF = TRUE;
                break;
            case VCARD_TYPE_CGM:
                lpvcpf->fTYPE_CGM = TRUE;
                break;
            case VCARD_TYPE_WMF:
                lpvcpf->fTYPE_WMF = TRUE;
                break;
            case VCARD_TYPE_BMP:
                lpvcpf->fTYPE_BMP = TRUE;
                break;
            case VCARD_TYPE_MET:
                lpvcpf->fTYPE_MET = TRUE;
                break;
            case VCARD_TYPE_PMB:
                lpvcpf->fTYPE_PMB = TRUE;
                break;
            case VCARD_TYPE_DIB:
                lpvcpf->fTYPE_DIB = TRUE;
                break;
            case VCARD_TYPE_PICT:
                lpvcpf->fTYPE_PICT = TRUE;
                break;
            case VCARD_TYPE_TIFF:
                lpvcpf->fTYPE_TIFF = TRUE;
                break;
            case VCARD_TYPE_ACROBAT:
                lpvcpf->fTYPE_ACROBAT = TRUE;
                break;
            case VCARD_TYPE_PS:
                lpvcpf->fTYPE_PS = TRUE;
                break;
            case VCARD_TYPE_JPEG:
                lpvcpf->fTYPE_JPEG = TRUE;
                break;
            case VCARD_TYPE_QTIME:
                lpvcpf->fTYPE_QTIME = TRUE;
                break;
            case VCARD_TYPE_MPEG:
                lpvcpf->fTYPE_MPEG = TRUE;
                break;
            case VCARD_TYPE_MPEG2:
                lpvcpf->fTYPE_MPEG2 = TRUE;
                break;
            case VCARD_TYPE_AVI:
                lpvcpf->fTYPE_AVI = TRUE;
                break;
            case VCARD_TYPE_WAVE:
                lpvcpf->fTYPE_WAVE = TRUE;
                break;
            case VCARD_TYPE_AIFF:
                lpvcpf->fTYPE_AIFF = TRUE;
                break;
            case VCARD_TYPE_PCM:
                lpvcpf->fTYPE_PCM = TRUE;
                break;
            case VCARD_TYPE_X509:
                lpvcpf->fTYPE_X509 = TRUE;
                break;
            case VCARD_TYPE_PGP:
                lpvcpf->fTYPE_PGP = TRUE;
                break;
            case VCARD_TYPE_NONE:
                // Wasn't a TYPE, try an encoding
                hResult = InterpretVCardEncoding(lpType, lpvcpf);
                break;
            default:
                // Assert(FALSE);
                break;
        }
    }
    return(hResult);
}


/***************************************************************************

    Name      : ParseVCardParams

    Purpose   : Parse out the vCard's parameters

    Parameters: lpBuffer = option string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   : Assumes lpvcpf is initialized to all false.

***************************************************************************/
HRESULT ParseVCardParams(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf) {
    TCHAR ch;
    LPSTR lpOption, lpArgs;
    BOOL fReady;
    HRESULT hResult = hrSuccess;


    // Is there anything here?
    if (lpBuffer) {

        while (*lpBuffer) {
            fReady = FALSE;
            lpOption = lpBuffer;
            lpArgs = NULL;

            while ((ch = *lpBuffer) && ! fReady) {
                switch (ch) {
                    case ';':           // end of this param
                        *lpBuffer = '\0';
                        fReady = TRUE;
                        break;

                    case '=':           // found a param with args
                        if (! lpArgs) {
                            lpArgs = lpBuffer + 1;
                            *lpBuffer = '\0';
                        }
                        break;

                    default:            // normal character
                        break;
                }

                lpBuffer++;
            }
            if (*lpOption) {
                // what is it?
                switch (RecognizeVCardParam(lpOption)) {
                    case VCARD_PARAM_TYPE:
                        if (lpArgs) {
                            ParseVCardType(lpArgs, lpvcpf);
                        }
                        break;

                    case VCARD_PARAM_ENCODING:
                        if (lpArgs) {
                            ParseVCardEncoding(lpArgs, lpvcpf);
                        }
                        break;

                    case VCARD_PARAM_LANGUAGE:
                        lpvcpf->szPARAM_LANGUAGE = lpArgs;
                        break;

                    case VCARD_PARAM_CHARSET:
                        lpvcpf->szPARAM_CHARSET = lpArgs;
                        break;

                    case VCARD_PARAM_VALUE:
                        // BUGBUG: Should reject those that we can't process (like URL)
                        break;

                    case VCARD_PARAM_NONE:
                        if (hResult = InterpretVCardType(lpOption, lpvcpf)) {
                            goto exit;
                        }
                        break;
                    default:
                        break;
                }
            }
        }
    }
exit:
    return(hResult);
}


/***************************************************************************

    Name      : ParseOrg

    Purpose   : parse the organization into properites

    Parameters: lpvcpf ->
                lpData = data string
                lpMailUser -> output mailuser object

    Returns   : hResult

    Comment   : vCard organizations are of the form:
                 TEXT("organization; org unit; org unit; ...")

***************************************************************************/
HRESULT ParseOrg(LPVCARD_PARAM_FLAGS lpvcpf, LPSTR lpData, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    SPropValue  spv[2] = {0};
    register LPSTR lpCurrent;
    ULONG i = 0;

    // Look for Organization (company)
    if (lpData && *lpData) {
        lpCurrent = lpData;
        lpData = ParseWord(lpData, ';');
        if (*lpCurrent) {
            spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_COMPANY_NAME, PT_STRING8);
            spv[i].Value.lpszA= lpCurrent;
            i++;
        }
    }
    // Everything else goes into PR_DEPARTMENT_NAME
    if (lpData && *lpData) {
        spv[i].ulPropTag = CHANGE_PROP_TYPE(PR_DEPARTMENT_NAME, PT_STRING8);
        spv[i].Value.lpszA= lpData;
        i++;
    }

    if (i) {
        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
          i,
          spv,
          NULL))) {
            DebugTrace( TEXT("ParseName:SetProps -> %x\n"), GetScode(hResult));
        }
    }

    return(hResult);
}


/***************************************************************************

    Name      : ParseVCardType

    Purpose   : Parse out the vCard's type parameter

    Parameters: lpBuffer = type string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ParseVCardType(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf) {
    TCHAR ch;
    BOOL fReady;
    LPSTR lpType;
    HRESULT hResult = hrSuccess;


    // Is there anything here?
    if (lpBuffer) {
        while (*lpBuffer) {
            fReady = FALSE;
            lpType = lpBuffer;

            while ((ch = *lpBuffer) && ! fReady) {
                switch (ch) {
                    case ',':           // end of this type
                        *lpBuffer = '\0';
                        fReady = TRUE;
                        break;

                    default:            // normal character
                        break;
                }

                lpBuffer++;
            }

            hResult = InterpretVCardType(lpType, lpvcpf);
        }
    }
    return(hResult);
}


/***************************************************************************

    Name      : ParseVCardEncoding

    Purpose   : Parse out the vCard encoding parameter

    Parameters: lpBuffer = type string
                lpvcpf -> flags structure to fill in

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ParseVCardEncoding(LPSTR lpBuffer, LPVCARD_PARAM_FLAGS lpvcpf) {
    TCHAR ch;
    BOOL fReady;
    LPSTR lpEncoding;
    HRESULT hResult = hrSuccess;


    // Is there anything here?
    if (lpBuffer) {
        while (*lpBuffer) {
            fReady = FALSE;
            lpEncoding = lpBuffer;

            while ((ch = *lpBuffer) && ! fReady) {
                switch (ch) {
                    case ',':           // end of this type
                        *lpBuffer = '\0';
                        fReady = TRUE;
                        break;

                    default:            // normal character
                        break;
                }

                lpBuffer++;
            }

            hResult = InterpretVCardEncoding(lpEncoding, lpvcpf);
        }
    }
    return(hResult);
}



/***************************************************************************

    Name      : Base64DMap

    Purpose   : Decoding mapping for Base64

    Parameters: chIn = character from Base64 encoding

    Returns   : 6-bit value represented by chIn.

    Comment   :

***************************************************************************/
/*  
this function is not necessary any more because of the DecodeBase64 function

UCHAR Base64DMap(UCHAR chIn) {
    UCHAR chOut;

    // 'A' -> 0, 'B' -> 1, ... 'Z' -> 25
    if (chIn >= 'A' && chIn <= 'Z') {
        chOut = chIn - 'A';
    } else if (chIn >= 'a' && chIn <= 'z') {    // 'a' -> 26
        chOut = (chIn - 'a') + 26;
    } else if (chIn >= '0' && chIn <= '9') {   // '0' -> 52
        chOut = (chIn - '0') + 52;
    } else if (chIn == '+') {
        chOut = 62;
    } else if (chIn == '/') {
        chOut = 63;
    } else {
        // uh oh
        Assert(FALSE);
        chOut = 0;
    }

    return(chOut);
}

*/

/***************************************************************************

    Name      : DecodeVCardData

    Purpose   : Decode QUOTED_PRINTABLE or BASE64 data

    Parameters: lpData = data string
                cbData = the length of the decoded data string  // changed t-jstaj
                lpvcs -> state variable

    Returns   : hResult

    Comment   : Decode in place is possible since both encodings are
                guaranteed to take at least as much space as the original data.

***************************************************************************/
HRESULT DecodeVCardData(LPSTR lpData, PULONG cbData, LPVCARD_PARAM_FLAGS lpvcpf) {
    HRESULT hResult = hrSuccess;
    LPSTR lpTempIn = lpData;
    LPSTR lpTempOut = lpData;
    char chIn, chOut;
    char chA, chB, chC, chD;
    if (lpvcpf->fENCODING_QUOTED_PRINTABLE) {
        // Look for '=', this is the escape character for QP
        while (chIn = *lpTempIn) {
            if (chIn == '=') {
                chIn = *(++lpTempIn);
                // is it a soft line break or a hex character?
                if (chIn == '\n' || chIn == '\r') {
                    // Soft line break
                    while (chIn && (chIn == '\n' || chIn == '\r')) {
                        chIn = *(++lpTempIn);
                    }
                    continue;   // We're now pointing to next good data or NULL
                } else {
                    // hex encoded char
                    // high nibble
                    if (chIn >= '0' && chIn <= '9') {
                        chOut = (chIn - '0') << 4;
                    } else if (chIn >= 'A' && chIn <= 'F') {
                        chOut = ((chIn - 'A') + 10) << 4;
                    } else if (chIn >= 'a' && chIn <= 'f') {
                        chOut = ((chIn - 'a') + 10) << 4;
                    } else {
                        // bogus QUOTED_PRINTABLE data
                        // Cut it short right here.
                        break;
                    }
                    chIn = *(++lpTempIn);

                    // low nibble
                    if (chIn >= '0' && chIn <= '9') {
                        chOut |= (chIn - '0');
                    } else if (chIn >= 'A' && chIn <= 'F') {
                        chOut |= ((chIn - 'A') + 10);
                    } else if (chIn >= 'a' && chIn <= 'f') {
                        chOut |= ((chIn - 'a') + 10);
                    } else {
                        // bogus QUOTED_PRINTABLE data
                        // Cut it short right here.
                        break;
                    }
                }
            } else {
                chOut = chIn;
            }

            *(lpTempOut++) = chOut;
            lpTempIn++;
        }
        *lpTempOut = '\0';  // terminate it
    } else if (lpvcpf->fENCODING_BASE64) {
         // eliminate white spaces
        LPSTR lpTempCopyPt;
        for( lpTempCopyPt = lpTempIn = lpData;
             lpTempIn && *lpTempIn; 
             lpTempCopyPt++, lpTempIn++ )
        {
             while( /*IsSpace(lpTempIn)*/
                    *lpTempIn == ' '
                    || *lpTempIn == '\t') 
                 lpTempIn++;                 
             if( lpTempCopyPt != lpTempIn )
                 *(lpTempCopyPt) = *(lpTempIn);
        }
        *(lpTempCopyPt) = '\0';
        lpTempIn = lpData;
        lpTempOut = lpData;
        if( HR_FAILED(hResult = DecodeBase64(lpTempIn, lpTempOut, cbData) ) )
        {
            DebugTrace( TEXT("couldn't decode buffer\n"));
        }
       
     /** This is the original code for vcard decoding base64, however, it wasn't working so new decoding is all done
         within DecodeBase64 function.
     
        lpTempIn = lpData;
        lpTempOut = lpData;
        while (*lpTempIn) {
            chA = Base64DMap(*(PUCHAR)(lpTempIn)++);
            if (! (chB = Base64DMap(*(PUCHAR)(lpTempIn)++) )) {
                chC = chD = 0;
            } else if (chC = Base64DMap(*(PUCHAR)(lpTempIn)++)) {
                chD = 0;
            } else {
                chD = Base64DMap(*(PUCHAR)(lpTempIn)++);
            }
            // chA = high 6 bits
            // chD = low 6 bits

            *(lpTempOut++) = (chA << 0x02) | ((chB & 0x60)  >> 6);
            *(lpTempOut++) = ((chB & 0x0F) << 4) | ((chC & 0x3B) >> 2);
            *(lpTempOut++) = ((chC & 0x03) << 6) | (chD & 0x3F);
        }
        *lpTempOut = '\0';  // terminate it
        */
    }

    return(hResult);
}


/***************************************************************************

    Name      : InterpretVCardItem

    Purpose   : Recognize the vCard item

    Parameters: lpName = property name
                lpOption = option string
                lpData = data string
                lpMailUser -> output mailuser object
                lpvcs -> state variable

    Returns   : hResult

    Comment   : Expects the keyword to be in the current line (lpBuffer), but
                may read more lines as necesary to get a complete item.

***************************************************************************/
HRESULT InterpretVCardItem(LPSTR lpName, LPSTR lpOption, LPSTR lpData,
  LPMAILUSER lpMailUser, LPEXTVCARDPROP lpList, LPVC_STATE lpvcs) {
    HRESULT hResult = hrSuccess;
    VCARD_PARAM_FLAGS vcpf = {0};
    ULONG cbData = 0;
    ParseVCardParams(lpOption, &vcpf);

#if 0
#ifdef DEBUG
    if(lstrcmpiA(lpName, "KEY"))
    {
        LPTSTR lpW1 = ConvertAtoW(lpName);
        LPTSTR lpW2 = ConvertAtoW(lpData);
        DebugTrace( TEXT("%s:%s\n"), lpW1, lpW2);
        LocalFreeAndNull(&lpW1);
        LocalFreeAndNull(&lpW2);
    }
    else
        DebugTrace(TEXT("KEY:\n"));
#endif
#endif

    if (hResult = DecodeVCardData(lpData, &cbData, &vcpf)) {
        goto exit;
    }

    switch (RecognizeVCardKeyWord(lpName)) {
        case VCARD_KEY_VCARD:
            hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
            break;

        case VCARD_KEY_BEGIN:
            if (lpvcs->vce != VCS_INITIAL) {
                // uh oh, already saw BEGIN
                hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
            } else {
                switch (RecognizeVCardKeyWord(lpData)) {
                    case VCARD_KEY_VCARD:
                        lpvcs->vce = VCS_ITEMS;
                        break;
                    default:
                        lpvcs->vce = VCS_ERROR;
                        hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
                        break;
                }
            }
            break;

        case VCARD_KEY_END:
            if (lpvcs->vce != VCS_ITEMS) {
                // uh oh, haven't seen begin yet
                hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
            } else {
                switch (RecognizeVCardKeyWord(lpData)) {
                    case VCARD_KEY_VCARD:
                        lpvcs->vce = VCS_FINISHED;
                        break;
                    default:
                        lpvcs->vce = VCS_ERROR;
                        hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
                        break;
                }
            }
            break;

        case VCARD_KEY_N:   // structured name
            // Data: surname; given name; middle name; prefix; suffix
            hResult = ParseName(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_ORG: // organization info
            // Data: company name; org unit; org unit; ...
            hResult = ParseOrg(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_ADR:
            // Data:  TEXT("PO box; extended addr; street addr; city; region; postal code; country")
            // Option: DOM; INTL; POSTAL; PARCEL; HOME; WORK; PREF; CHARSET; LANGUAGE
            hResult = ParseAdr(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_TEL:
            // Data: canonical form phone number
            // Options: HOME, WORK, MSG, PREF, FAX, CELL, PAGER, VIDEO, BBS, MODEM, ISDN
            hResult = ParseTel(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_TITLE:
            // Data: job title
            // Options: CHARSET, LANGUAGE
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_TITLE);
            break;

        case VCARD_KEY_NICKNAME:
            // Data: job title
            // Options: CHARSET, LANGUAGE
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_NICKNAME);
            break;

        case VCARD_KEY_URL:
            // Data: URL
            // Options: none (though we'd like to see HOME, WORK)
            if (vcpf.fTYPE_HOME) {
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_PERSONAL_HOME_PAGE);
                lpvcs->fPersonalURL = TRUE;
            } else if (vcpf.fTYPE_WORK) {
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_BUSINESS_HOME_PAGE);
                lpvcs->fBusinessURL = TRUE;
            } else if (! lpvcs->fPersonalURL) {
                // assume it is HOME page
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_PERSONAL_HOME_PAGE);
                lpvcs->fPersonalURL = TRUE;
            } else if (! lpvcs->fBusinessURL) {
                // assume it is BUSINESS web page
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_BUSINESS_HOME_PAGE);
                lpvcs->fBusinessURL = TRUE;
            }   // else, toss it
            break;

        case VCARD_KEY_NOTE:
            // Data: note text
            // Options: CHARSET, LANGUAGE
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_COMMENT);
            break;

        case VCARD_KEY_FN:
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_DISPLAY_NAME);
            break;

        case VCARD_KEY_EMAIL:
            // since we are forcibly putting the telex value into the EMAIL type,
            // we also need to be able to get it out of there
            if(vcpf.fTYPE_TLX)
                hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_TELEX_NUMBER);
            else
                hResult = ParseEmail(&vcpf, lpData, lpMailUser, lpvcs);
            break;

        case VCARD_KEY_ROLE:
            hResult = ParseSimple(&vcpf, lpData, lpMailUser, PR_PROFESSION);
            break;

        case VCARD_KEY_BDAY:
            hResult = ParseBday(&vcpf, lpData, lpMailUser);
            break;

        case VCARD_KEY_AGENT:
        case VCARD_KEY_LOGO:
        case VCARD_KEY_PHOTO:
        case VCARD_KEY_LABEL:
        case VCARD_KEY_FADR:
        case VCARD_KEY_SOUND:
        case VCARD_KEY_LANG:
        case VCARD_KEY_TZ:
        case VCARD_KEY_GEO:
        case VCARD_KEY_REV:
        case VCARD_KEY_UID:
        case VCARD_KEY_MAILER:
            // Not yet implemented: ignore
#ifdef DEBUG
            {
                LPTSTR lpW = ConvertAtoW(lpName);
                DebugTrace( TEXT("===>>> NYI: %s\n"), lpW);
                LocalFreeAndNull(&lpW);
            }
#endif
            break;       
        case VCARD_KEY_KEY:
            {
                hResult = ParseCert( lpData, cbData, lpMailUser);
                break;
            }
        case VCARD_KEY_X_WAB_GENDER:
            {
                SPropValue  spv[1] = {0};
                if (lpData )
                {
                    INT fGender = (INT)lpData[0] - '0';
                    if( fGender < 0 || fGender > 2 )
                        fGender = 0;

                    spv[0].Value.l = fGender;                
                    spv[0].ulPropTag = PR_GENDER;
                    
                    if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                        1, spv,
                        NULL))) 
                    {
                        DebugTrace( TEXT("could not set props\n"));
                    }
                }
                break;
            }
        case VCARD_KEY_X:
        case VCARD_KEY_NONE:
            //
            // Check if this is an X- named prop that we might care about
            //
            if(lpList)
            {
                LPEXTVCARDPROP lpTemp = lpList;
                while(  lpTemp && lpTemp->ulExtPropTag && 
                        lpTemp->lpszExtPropName && lstrlenA(lpTemp->lpszExtPropName) )
                {
                    if(!lstrcmpiA(lpName, lpTemp->lpszExtPropName))
                    {
                        hResult = ParseSimple(&vcpf, lpData, lpMailUser, lpTemp->ulExtPropTag);
                        break;
                    }
                    lpTemp = lpTemp->lpNext;
                }
            }
#ifdef DEBUG
            {
                LPTSTR lpW = ConvertAtoW(lpName);
                DebugTrace( TEXT("Unrecognized or extended vCard key %s\n"), lpW);
                LocalFreeAndNull(&lpW);
            }
#endif //debug 
            break;

        default:
//            Assert(FALSE);
            break;
    }

    if (lpvcs->vce == VCS_INITIAL) {
        // We are still in initial state.  This is not a vCard.
        hResult = ResultFromScode(MAPI_E_INVALID_OBJECT);
    }
exit:
    return(hResult);
}


/***************************************************************************

    Name      : ReadLn

    Purpose   : Read a line from the handle

    Parameters: handle = open file handle
                ReadFn = function to read from handle
                lppLine -> returned pointer to this line's read into.
                lpcbItem -> [in] size of data in lppBuffer.  [out] returned size of
                  data in lppBuffer.  If zero, there is no more data.  (Does not
                  include terminating NULL)
                lppBuffer -> [in] start of item buffer or NULL if none yet.
                  [out] start of allocated item buffer.  Caller must
                  LocalFree this buffer once the item is read in.
                lpcbBuffer -> [in/out] size of lppBuffer allocation.

    Returns   : hResult: 0 on no error (recognized)

    Comment   : Reads a line from the handle, discarding any carriage return
                characters and empty lines.  Will not overwrite buffer, and
                will always terminate the string with a null.  Trims trailing
                white space.

                This is very inefficient since we're reading a byte at a time.
                I think we can get away with it since vCards are typically
                small.  If not, we'll have to do some read caching.

***************************************************************************/
#define READ_BUFFER_GROW    256
HRESULT ReadLn(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppLine, LPULONG lpcbItem, LPSTR * lppBuffer, LPULONG lpcbBuffer)
{
    HRESULT hResult = hrSuccess;
    LPSTR lpBuffer = *lppBuffer;
    LPSTR lpBufferTemp;
    register LPSTR lpRead = NULL;
    ULONG cbRead;
    ULONG cbBuffer;
    char ch;
    ULONG cbItem;
    ULONG cbStart = 0;

    if (! lpBuffer) {
        cbBuffer = READ_BUFFER_GROW;
        cbItem = 0;
        if (! (lpBuffer = LocalAlloc(LPTR, cbBuffer))) {
            DebugTrace( TEXT("ReadLn:LocalAlloc -> %u\n"), GetLastError());
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }
    } else {
        cbBuffer = *lpcbBuffer;
        cbItem = *lpcbItem;
        // Make certain we have room for at least one more character.
        if (cbItem >= cbBuffer) {
            // Time to grow the buffer
            cbBuffer += READ_BUFFER_GROW;
            if (! (lpRead = LocalReAlloc(lpBuffer, cbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                DebugTrace( TEXT("ReadLn:LocalReAlloc(%u) -> %u\n"), cbBuffer, GetLastError());
                goto exit;
            }
            lpBuffer = lpRead;
        }
    }

    cbStart = cbItem;
    lpRead = lpBuffer + cbItem;  // read pointer

    do {
        // read next character
        if (hResult = ReadFn(hVCard, lpRead, 1, &cbRead)) {
            goto exit;
        }

        if (! cbRead) {
            // End of file
            *lpRead = '\0';         // eol
            goto exit;
        } else {
//                Assert(cbRead == 1);
            ch = *lpRead;
            switch (ch) {
                case '\r':    // These are ignored
                    break;

                case '\n':    // Linefeed terminates string
                    *lpRead = '\0'; // eol
                    break;                    
                default:    // All other characters are added to string
                    cbItem += cbRead;
                    if (cbItem >= cbBuffer) {
                        // Time to grow the buffer
                        cbBuffer += READ_BUFFER_GROW;
                        lpBufferTemp = (LPSTR)LocalReAlloc(lpBuffer, cbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT);
                        if (!lpBufferTemp) {
                            DebugTrace( TEXT("ReadLn:LocalReAlloc(%u) -> %u\n"), cbBuffer, GetLastError());
                            hResult = E_OUTOFMEMORY;
                            goto exit;
                        }
                        else
                        {
                            lpBuffer = lpBufferTemp;
                        }
                        lpRead = lpBuffer + cbItem;
                    } else {
                        lpRead++;
                    }
                    break;
            }
        }
    } while (ch != '\n');

exit:
    *lppLine = &lpBuffer[cbStart];
    if (hResult || cbItem == 0) {
        LocalFreeAndNull(&lpBuffer);
        cbItem = 0;
        lpBuffer = NULL;
    } else {
        // If we didn't read anything more, we should return NULL in lppLine.
        if (cbItem == cbStart) {
            *lppLine = NULL;
        } else {
//            DebugTrace( TEXT("ReadLn: \")%s\ TEXT("\n"), *lppLine);
        }
    }

    *lpcbItem = cbItem;
    *lppBuffer = lpBuffer;
    *lpcbBuffer = cbBuffer;

    return(hResult);
}


/***************************************************************************

    Name      : FindSubstringBefore

    Purpose   : Find a substring before a particular character

    Parameters: lpString = full string
                lpSubstring = search string
                chBefore = character to terminate search

    Returns   : pointer to substring or NULL if not found

    Comment   :

***************************************************************************/
LPSTR FindSubstringBefore(LPSTR lpString, LPSTR lpSubstring, char chBefore) {
    ULONG cbSubstring = lstrlenA(lpSubstring);
    register ULONG i;
    BOOL fFound = FALSE;
    char szU[MAX_PATH];
    char szL[MAX_PATH];
    StrCpyNA(szU, lpSubstring, ARRAYSIZE(szU));
    StrCpyNA(szL, lpSubstring, ARRAYSIZE(szL));
    CharUpperA(szU);
    CharLowerA(szL);

    while (*lpString && *lpString != chBefore) {
        for (i = 0; i < cbSubstring; i++) {
             if (lpString[i] != szU[i] && lpString[i] != szL[i]) {
                 goto nomatch;
             }
        }
        return(lpString);
nomatch:
        lpString++;
    }
    return(NULL);
}


/***************************************************************************

    Name      : ReadVCardItem

    Purpose   : Read the next VCard item

    Parameters: handle = open file handle
                ReadFn = function to read from handle
                lppBuffer -> returned buffer containing the item.  Caller must
                  LocalFree this buffer.  (on input, if this is non-NULL,
                  the existing buffer should be used.)
                lpcbBuffer -> returned size of buffer.  If zero, there is no
                  more data.

    Returns   : hResult: 0 on no error (recognized)

    Comment   : Reads a vCard item from the handle, discarding any carriage return
                characters and empty lines.  Will not overwrite buffer, and
                will always terminate the string with a null.  Trims trailing
                white space.

***************************************************************************/
HRESULT ReadVCardItem(HANDLE hVCard, VCARD_READ ReadFn, LPSTR * lppBuffer, LPULONG lpcbBuffer) {
    HRESULT hResult;
    LPSTR lpLine = NULL;
    LPSTR lpBuffer = NULL;
    ULONG cbBuffer = 0;
    ULONG cbItem = 0;
    BOOL fDone = FALSE;
    BOOL fQuotedPrintable = FALSE;
    BOOL fBase64 = FALSE;
    BOOL fFirst = TRUE;
    ULONG cbStart;


    while (! fDone) {
        cbStart = cbItem;
        if (hResult = ReadLn(hVCard, ReadFn, &lpLine, &cbItem, &lpBuffer, &cbBuffer)) {
            if (HR_FAILED(hResult)) {
                DebugTrace( TEXT("ReadVCardItem: ReadLn -> %x\n"), GetScode(hResult));
            } else if (GetScode(hResult) == WAB_W_END_OF_DATA) {
                // EOF
                // all
            }
            fDone = TRUE;
        } else {
            if (lpBuffer) {
                // Do we need to read more data?
                // Look for the following
                if (fFirst) {
                    // look for the data type indications in the first line of the item.
                    fQuotedPrintable = FindSubstringBefore(lpBuffer, (LPSTR)vceTable[VCARD_ENCODING_QUOTED_PRINTABLE], ':') ? TRUE : FALSE;
                    fBase64 = FindSubstringBefore(lpBuffer, (LPSTR)vceTable[VCARD_ENCODING_BASE64], ':') ? TRUE : FALSE;
                    fFirst = FALSE;
                }

                if (fQuotedPrintable) {
                    // watch for soft line breaks (= before CRLF)
                    if (lpBuffer[cbItem - 1] == '=') {
                        // overwrite the soft break character
                        cbItem--;
                        lpBuffer[cbItem] = '\0';
                    } else {
                        fDone = TRUE;
                    }
                } else if (fBase64) {
                    // looking for empty line
                    if (cbStart == cbItem) {
                        fDone = TRUE;
                    }
                } else {
                    fDone = TRUE;
                }
            } else {
                // BUG Fix - if we set fDone to true here, we will exit out of our
                // vCard reading loop. lpBuffer can also be NULL because the
                // vCard contained blank lines. Better we dont set fDone here.
                
                //fDone = TRUE;
            }
        }
    }

    if (! HR_FAILED(hResult)) {
        *lppBuffer = lpBuffer;
        if (lpBuffer) {
            TrimTrailingWhiteSpace(lpBuffer);
        }
    }
    return(hResult);
}


enum {
    ivcPR_GENERATION,
    ivcPR_GIVEN_NAME,
    ivcPR_SURNAME,
    ivcPR_NICKNAME,
    ivcPR_BUSINESS_TELEPHONE_NUMBER,
    ivcPR_HOME_TELEPHONE_NUMBER,
    ivcPR_LANGUAGE,
    ivcPR_POSTAL_ADDRESS,
    ivcPR_COMPANY_NAME,
    ivcPR_TITLE,
    ivcPR_DEPARTMENT_NAME,
    ivcPR_OFFICE_LOCATION,
    ivcPR_BUSINESS2_TELEPHONE_NUMBER,
    ivcPR_CELLULAR_TELEPHONE_NUMBER,
    ivcPR_RADIO_TELEPHONE_NUMBER,
    ivcPR_CAR_TELEPHONE_NUMBER,
    ivcPR_OTHER_TELEPHONE_NUMBER,
    ivcPR_DISPLAY_NAME,
    ivcPR_PAGER_TELEPHONE_NUMBER,
    ivcPR_BUSINESS_FAX_NUMBER,
    ivcPR_HOME_FAX_NUMBER,
    ivcPR_TELEX_NUMBER,
    ivcPR_ISDN_NUMBER,
    ivcPR_HOME2_TELEPHONE_NUMBER,
    ivcPR_MIDDLE_NAME,
    ivcPR_PERSONAL_HOME_PAGE,
    ivcPR_BUSINESS_HOME_PAGE,
    ivcPR_HOME_ADDRESS_CITY,
    ivcPR_HOME_ADDRESS_COUNTRY,
    ivcPR_HOME_ADDRESS_POSTAL_CODE,
    ivcPR_HOME_ADDRESS_STATE_OR_PROVINCE,
    ivcPR_HOME_ADDRESS_STREET,
    ivcPR_HOME_ADDRESS_POST_OFFICE_BOX,
    ivcPR_POST_OFFICE_BOX,
    ivcPR_BUSINESS_ADDRESS_CITY,
    ivcPR_BUSINESS_ADDRESS_COUNTRY,
    ivcPR_BUSINESS_ADDRESS_POSTAL_CODE,
    ivcPR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    ivcPR_BUSINESS_ADDRESS_STREET,
    ivcPR_COMMENT,
    ivcPR_EMAIL_ADDRESS,
    ivcPR_ADDRTYPE,
    ivcPR_CONTACT_ADDRTYPES,
    ivcPR_CONTACT_DEFAULT_ADDRESS_INDEX,
    ivcPR_CONTACT_EMAIL_ADDRESSES,
    ivcPR_PROFESSION,
    ivcPR_BIRTHDAY,
    ivcPR_PRIMARY_TELEPHONE_NUMBER,
    ivcPR_OTHER_ADDRESS_CITY,
    ivcPR_OTHER_ADDRESS_COUNTRY,
    ivcPR_OTHER_ADDRESS_POSTAL_CODE,
    ivcPR_OTHER_ADDRESS_STATE_OR_PROVINCE,
    ivcPR_OTHER_ADDRESS_STREET,
    ivcPR_OTHER_ADDRESS_POST_OFFICE_BOX,
    ivcPR_DISPLAY_NAME_PREFIX,
    ivcPR_USER_X509_CERTIFICATE,
    ivcPR_GENDER,
    ivcMax
};

const SizedSPropTagArray(ivcMax, tagaVCard) = {
    ivcMax,
    {
        PR_GENERATION,
        PR_GIVEN_NAME,
        PR_SURNAME,
        PR_NICKNAME,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_LANGUAGE,
        PR_POSTAL_ADDRESS,
        PR_COMPANY_NAME,
        PR_TITLE,
        PR_DEPARTMENT_NAME,
        PR_OFFICE_LOCATION,
        PR_BUSINESS2_TELEPHONE_NUMBER,
        PR_CELLULAR_TELEPHONE_NUMBER,
        PR_RADIO_TELEPHONE_NUMBER,
        PR_CAR_TELEPHONE_NUMBER,
        PR_OTHER_TELEPHONE_NUMBER,
        PR_DISPLAY_NAME,
        PR_PAGER_TELEPHONE_NUMBER,
        PR_BUSINESS_FAX_NUMBER,
        PR_HOME_FAX_NUMBER,
        PR_TELEX_NUMBER,
        PR_ISDN_NUMBER,
        PR_HOME2_TELEPHONE_NUMBER,
        PR_MIDDLE_NAME,
        PR_PERSONAL_HOME_PAGE,
        PR_BUSINESS_HOME_PAGE,
        PR_HOME_ADDRESS_CITY,
        PR_HOME_ADDRESS_COUNTRY,
        PR_HOME_ADDRESS_POSTAL_CODE,
        PR_HOME_ADDRESS_STATE_OR_PROVINCE,
        PR_HOME_ADDRESS_STREET,
        PR_HOME_ADDRESS_POST_OFFICE_BOX,
        PR_POST_OFFICE_BOX,
        PR_BUSINESS_ADDRESS_CITY,
        PR_BUSINESS_ADDRESS_COUNTRY,
        PR_BUSINESS_ADDRESS_POSTAL_CODE,
        PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
        PR_BUSINESS_ADDRESS_STREET,
        PR_COMMENT,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
        PR_CONTACT_ADDRTYPES,
        PR_CONTACT_DEFAULT_ADDRESS_INDEX,
        PR_CONTACT_EMAIL_ADDRESSES,
        PR_PROFESSION,
        PR_BIRTHDAY,
        PR_PRIMARY_TELEPHONE_NUMBER,
        PR_OTHER_ADDRESS_CITY,
        PR_OTHER_ADDRESS_COUNTRY,
        PR_OTHER_ADDRESS_POSTAL_CODE,
        PR_OTHER_ADDRESS_STATE_OR_PROVINCE,
        PR_OTHER_ADDRESS_STREET,
        PR_OTHER_ADDRESS_POST_OFFICE_BOX,
        PR_DISPLAY_NAME_PREFIX,
        PR_USER_X509_CERTIFICATE,
        PR_GENDER
    }
};

HRESULT WriteOrExit(HANDLE hVCard, LPTSTR lpsz, VCARD_WRITE WriteFn)   
{
    LPSTR lpszA = NULL;
    HRESULT hr = S_OK;
    lpszA = ConvertWtoA(lpsz);
    hr = WriteFn(hVCard, lpszA, lstrlenA(lpszA), NULL);
    LocalFreeAndNull(&lpszA);
    return hr;
}

#define WRITE_OR_EXITW(string) {\
    if (hResult = WriteOrExit(hVCard, string, WriteFn)) \
        goto exit; \
    }

#define WRITE_OR_EXIT(string) {\
    if (hResult = WriteFn(hVCard, string, lstrlenA(string), NULL)) \
        goto exit; \
    }

HRESULT WriteValueOrExit(HANDLE hVCard, VCARD_WRITE WriteFn, LPBYTE data, ULONG size)   
{
    LPSTR lpszA = NULL;
    HRESULT hr = S_OK;
    if(!size)
        lpszA = ConvertWtoA((LPTSTR)data);
    hr = WriteVCardValue(hVCard, WriteFn, lpszA ? (LPBYTE)lpszA : data, size);
    LocalFreeAndNull(&lpszA);
    return hr;
}

#define WRITE_VALUE_OR_EXITW(data, size) {\
    if (hResult = WriteValueOrExit(hVCard, WriteFn, (LPBYTE)data, size)) {\
        goto exit;\
    }\
}

#define WRITE_VALUE_OR_EXIT(data, size) {\
    if (hResult = WriteVCardValue(hVCard, WriteFn, (LPBYTE)data, size)) {\
        goto exit;\
    }\
}


/***************************************************************************

    Name      : EncodeQuotedPrintable

    Purpose   : Encodes QUOTED_PRINTABLE

    Parameters: lpBuffer -> input buffer

    Returns   : encoded string buffer (must be LocalFree'd by caller)

    Comment   :

***************************************************************************/
#define QUOTED_PRINTABLE_MAX_LINE 76
#define QP_LOWRANGE_MIN ' '
#define QP_LOWRANGE_MAX '<'
#define QP_HIGHRANGE_MIN '>'
#define QP_HIGHRANGE_MAX '~'
LPSTR EncodeQuotedPrintable(LPBYTE lpInput) {
    LPSTR lpBuffer = NULL;
    register LPBYTE lpTempIn = lpInput;
    register LPSTR lpTempOut;
    ULONG cbBuffer = 0;
    ULONG cbLine;
    BYTE bOut;
    char ch;

    // How big must the buffer be?
    cbLine = 0;
    while (ch = *lpTempIn++) {
        if (ch == '\t' || (ch >= QP_LOWRANGE_MIN && ch <= QP_LOWRANGE_MAX) ||
          (ch >= QP_HIGHRANGE_MIN && ch <= QP_HIGHRANGE_MAX)) {
            cbBuffer++;
            cbLine++;
            if (cbLine >= (QUOTED_PRINTABLE_MAX_LINE)) {
                // 1 chars would overshoot max, wrap here
                cbLine = 0;
                cbBuffer += 3;
            }
        } else {
            if (cbLine >= (QUOTED_PRINTABLE_MAX_LINE - 3)) {
                // 3 chars would overshoot max, wrap here
                cbLine = 0;
                cbBuffer += 3;
            }
            cbLine += 3;
            cbBuffer += 3;  //  TEXT("=xx")
        }
    }

    // BUGBUG: Should handle terminating spaces

    if (cbBuffer) {
        cbBuffer++;     // Room for terminator
        if (lpBuffer = LocalAlloc(LPTR, sizeof(TCHAR)*cbBuffer)) {
            lpTempIn = lpInput;
            lpTempOut = lpBuffer;
            cbLine = 0;
            while (ch = *lpTempIn++) {
                if (ch == '\t' || (ch >= QP_LOWRANGE_MIN && ch <= QP_LOWRANGE_MAX) ||
                  (ch >= QP_HIGHRANGE_MIN && ch <= QP_HIGHRANGE_MAX)) {
                    if (cbLine >= QUOTED_PRINTABLE_MAX_LINE) {
                        //  char would overshoot max, wrap here
                        *(lpTempOut++) = '=';
                        *(lpTempOut++) = '\r';
                        *(lpTempOut++) = '\n';
                        cbLine = 0;
                    }
                    *(lpTempOut++) = ch;
                    cbLine++;
                } else {
                    if (cbLine >= (QUOTED_PRINTABLE_MAX_LINE - 3)) {
                        // 3 chars would overshoot max, wrap here
                        *(lpTempOut++) = '=';
                        *(lpTempOut++) = '\r';
                        *(lpTempOut++) = '\n';
                        cbLine = 0;
                    }

                    *(lpTempOut++) = '=';
                    if ((bOut = ((ch & 0xF0) >> 4)) > 9) {
                        *(lpTempOut++) = bOut + ('A' - 10);
                    } else {
                        *(lpTempOut++) = bOut + '0';
                    }
                    if ((bOut = ch & 0x0F) > 9) {
                        *(lpTempOut++) = bOut + ('A' - 10);
                    } else {
                        *(lpTempOut++) = bOut + '0';
                    }
                    cbLine += 3;
                }
            }
            *lpTempOut = '\0';  // terminate the string
        } // else fail
    }

    return(lpBuffer);
}


/***************************************************************************

    Name      : EncodeBase64

    Purpose   : Encodes BASE64
    Parameters: lpBuffer -> input buffer
                cbBuffer = size of input buffer
                lpcbReturn -> returned size of output buffer

    Returns   : encoded string buffer (must be LocalFree'd by caller)

    Comment   :

***************************************************************************/
#define BASE64_MAX_LINE 76
LPSTR EncodeBase64(LPBYTE lpInput, ULONG cbBuffer, LPULONG lpcbReturn) {
//#ifdef NEW_STUFF
    LPSTR lpBuffer = NULL;
    PUCHAR outptr;   
    UINT   i, cExtras;
    UINT   j, cCount, nBreakPt = ( (BASE64_MAX_LINE/4) - 1 );  // 72 encoded chars per line plus 4 spaces makes 76
                                // = (76 - 4)/ 4  for num of non space lines with 4 encoded characters per 3 data chars
    CONST CHAR * rgchDict = six2base64;
    // 4 spaces and 2 chars = 6 for new line
    cExtras = 6 * ((cbBuffer / BASE64_MAX_LINE) + 2); // want to add newline at beginning and end
    lpBuffer = LocalAlloc( LMEM_ZEROINIT, sizeof( TCHAR ) * (3 * cbBuffer  + cExtras));
    if (!lpBuffer)
        return NULL;

    // need to add a new line every 76 characters...
    outptr = (UCHAR *)lpBuffer;
    cCount = 0;

    for (i=0; i < cbBuffer; i += 3) 
    {// want it to start on next line from tag anyways so it is okay when i=0
        if( cCount++ % nBreakPt == 0 ) 
        {
            *(outptr++) = (CHAR)(13);
            *(outptr++) = (CHAR)(10);
            // then 4 spaces
            for( j = 0; j < 4; j++)
                *(outptr++) = ' ';
        }
        *(outptr++) = rgchDict[*lpInput >> 2];            /* c1 */
        *(outptr++) = rgchDict[((*lpInput << 4) & 060)      | ((lpInput[1] >> 4) & 017)]; /*c2*/
        *(outptr++) = rgchDict[((lpInput[1] << 2) & 074)    | ((lpInput[2] >> 6) & 03)];/*c3*/
        *(outptr++) = rgchDict[lpInput[2] & 077];         /* c4 */
        
        lpInput += 3;
    }
    /* If cbBuffer was not a multiple of 3, then we have encoded too
    * many characters.  Adjust appropriately.
    */
    if(i == cbBuffer+1) {
        /* There were only 2 bytes in that last group */
        outptr[-1] = '=';
    } else if(i == cbBuffer+2) {
        /* There was only 1 byte in that last group */
        outptr[-1] = '=';
        outptr[-2] = '=';
    }
    
    cCount = ((cCount - 1) % nBreakPt != 0) ? 2 : 1; // prevent an extra newline
    for ( i = 0; i < cCount; i++)
    {
        *(outptr++) = (CHAR)(13);
        *(outptr++) = (CHAR)(10);
    }
    *outptr = '\0';
   
    return lpBuffer;
}


/***************************************************************************

    Name      : WriteVCardValue

    Purpose   : Encode and write the value of a vCard item.

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                lpData -> data to be written
                cbData = length of data (or 0 if null-terminated string data)

    Returns   : HRESULT

    Comment   : Assumes that the Key and any parameters have been written,
                and we are ready for a ':' and some value data.

***************************************************************************/
HRESULT WriteVCardValue(HANDLE hVCard, VCARD_WRITE WriteFn, LPBYTE lpData,
  ULONG cbData) {
    HRESULT hResult = hrSuccess;
    register LPSTR lpTemp = (LPSTR)lpData;
    BOOL fBase64 = FALSE, fQuotedPrintable = FALSE;
    LPSTR lpBuffer = NULL;
    register TCHAR ch;

    if (cbData) {
        // Binary data, use BASE64 encoding
        fBase64 = TRUE;
        // Mark it as BASE64
        WRITE_OR_EXITW(szSemicolon);
        WRITE_OR_EXIT(vcpTable[VCARD_PARAM_ENCODING]);
        WRITE_OR_EXIT(szEquals);
        WRITE_OR_EXIT(vceTable[VCARD_ENCODING_BASE64]);
        lpBuffer = EncodeBase64(lpData, cbData, &cbData);
    } else {
        // Text data, do we need to encode?
        while (ch = *lpTemp++) {
            // If there are characters with the high bit set or control characters,
            // then we must use QUOTED_PRINTABLE

/* New vCard draft says default type is 8 bit so we should allow non-ASCII chars
    Some confusion about charsets if we need to fill that data in and also if we
    need to covert the current language to UTF-8

            if (ch > 0x7f) {        // high bits set.  Not ASCII!
                DebugTrace( TEXT("WriteVCardValue found non-ASCII data\n"));
                hResult = ResultFromScode(WAB_E_VCARD_NOT_ASCII);
                goto exit;
            }
*/
            if (ch < 0x20) {
                fQuotedPrintable = TRUE;
                // Mark it as QUOTED_PRINTABLE
                WRITE_OR_EXITW(szSemicolon);
                WRITE_OR_EXIT(vcpTable[VCARD_PARAM_ENCODING]);
                WRITE_OR_EXIT(szEquals);
                WRITE_OR_EXIT(vceTable[VCARD_ENCODING_QUOTED_PRINTABLE]);
                lpBuffer = EncodeQuotedPrintable(lpData);
                break;
            }
        }
    }
    WRITE_OR_EXIT(szColonA);
    WRITE_OR_EXIT(lpBuffer ? lpBuffer : lpData);
    WRITE_OR_EXIT(szCRLFA);

exit:
    if( lpBuffer) 
        LocalFree(lpBuffer);
    return(hResult);
}

/***************************************************************************

    Name:       bIsValidStrProp

    Purpose:    Checks if this is a valid string prop not an empty string
                (Outlook sometimes feeds us blank strings which we print out
                and then other apps go and die ..
*****************************************************************************/
BOOL bIsValidStrProp(SPropValue spv)
{
    return (!PROP_ERROR(spv) && spv.Value.LPSZ && lstrlen(spv.Value.LPSZ));
}

/***************************************************************************

    Name      : WriteVCardTel

    Purpose   : Writes a vCard Telephone entry

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                fPref = TRUE if prefered phone number
                fBusiness = TRUE if a work number
                fHome = TRUE if a home number
                fVoice = TRUE if a voice number
                fFax = TRUE if a fax number
                fISDN = TRUE if an ISDN number
                fCell = TRUE if a cellular number
                fPager = TRUE if a pager number
                fCar = TRUE if a car phone

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT WriteVCardTel(HANDLE hVCard, VCARD_WRITE WriteFn,
  SPropValue spv,
  BOOL fPref,
  BOOL fBusiness,
  BOOL fHome,
  BOOL fVoice,
  BOOL fFax,
  BOOL fISDN,
  BOOL fCell,
  BOOL fPager,
  BOOL fCar) {
    HRESULT hResult = hrSuccess;

    if (!bIsValidStrProp(spv))
        return hResult;

    if (! PROP_ERROR(spv)) {
        WRITE_OR_EXIT(vckTable[VCARD_KEY_TEL]);
        if (fPref) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_PREF]);
        }
        if (fBusiness) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);
        }
        if (fHome) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);
        }
        if (fFax) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_FAX]);
        }
        if (fCell) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_CELL]);
        }
        if (fCar) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_CAR]);
        }
        if (fPager) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_PAGER]);
        }
        if (fISDN) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_ISDN]);
        }
        if (fVoice) {
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_VOICE]);
        }

        WRITE_VALUE_OR_EXITW(spv.Value.LPSZ, 0);
    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : WriteVCardEmail

    Purpose   : Writes a vCard Email entry

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                lpEmailAddress -> Email address
                lpAddrType -> Addrtype or NULL (Default is SMTP)
                fDefault = TRUE if this is the preferred email address

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT WriteVCardEmail(HANDLE hVCard, VCARD_WRITE WriteFn, LPTSTR lpEmailAddress,
  LPTSTR lpAddrType, BOOL fDefault) {
    HRESULT hResult = hrSuccess;

    if (lpEmailAddress && lstrlen(lpEmailAddress)) {

        WRITE_OR_EXIT(vckTable[VCARD_KEY_EMAIL]);
        WRITE_OR_EXITW(szSemicolon);
        if (fDefault) {
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_PREF]);
            WRITE_OR_EXITW(szSemicolon);
        }

        if (lpAddrType && lstrlen(lpAddrType)) {
            if (! lstrcmpi(lpAddrType, szSMTP)) {
                WRITE_OR_EXIT(vctTable[VCARD_TYPE_INTERNET]);
            } else if (! lstrcmpi(lpAddrType, szX400)) {
                WRITE_OR_EXIT(vctTable[VCARD_TYPE_X400]);
            } else {
                // BUGBUG: This is questionable... we should stick to
                // the spec defined types, but what if they don't match?
                // Maybe I should ignore the type in that case.
                WRITE_OR_EXITW(lpAddrType);
            }
        } else {
            // Assume SMTP
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_INTERNET]);
        }
        WRITE_VALUE_OR_EXITW(lpEmailAddress, 0);
    }
exit:
    return(hResult);
}


/***************************************************************************

    Name      : PropLength

    Purpose   : string length of string property

    Parameters: spv = SPropValue
                lppString -> return pointer to string value or NULL

    Returns   : size of string (not including null)

    Comment   :

***************************************************************************/
ULONG PropLength(SPropValue spv, LPTSTR * lppString) {
    ULONG cbRet = 0;

    if (! PROP_ERROR(spv) && spv.Value.LPSZ && lstrlen(spv.Value.LPSZ)) 
    {
        *lppString = spv.Value.LPSZ;
        cbRet = sizeof(TCHAR)*lstrlen(*lppString);
    } else 
    {
        *lppString = NULL;
    }
    return(cbRet);
}


/***************************************************************************

    Name      : WriteVCard

    Purpose   : Writes a vCard to a file from a MAILUSER object.

    Parameters: hVCard = open handle to empty VCard file
                WriteFn = Write function to write hVCard
                lpMailUser -> open mailuser object

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT WriteVCard(HANDLE hVCard, VCARD_WRITE WriteFn, LPMAILUSER lpMailUser) {
    HRESULT hResult = hrSuccess;
    ULONG ulcValues;
    LPSPropValue lpspv = NULL,
                 lpspvAW = NULL;
    ULONG i;
    LPTSTR lpTemp = NULL;
    ULONG cbTemp = 0;
    LPTSTR lpSurname, lpGivenName, lpMiddleName, lpGeneration, lpPrefix;
    ULONG cbSurname, cbGivenName, cbMiddleName, cbGeneration, cbPrefix;
    LPTSTR lpCompanyName, lpDepartmentName;
    LPTSTR lpPOBox, lpOffice, lpStreet, lpCity, lpState, lpPostalCode, lpCountry;
    LPTSTR lpEmailAddress, lpAddrType;
    ULONG iDefaultEmail;
    LPEXTVCARDPROP lpList       = NULL;
    LPBYTE lpDataBuffer         = NULL;
    LPCERT_DISPLAY_INFO lpCDI   = NULL, lpCDITemp = NULL;

    // See if there are any named props we need to export
    //
    HrGetExtVCardPropList(lpMailUser, &lpList);

    // Get the interesting properties from the MailUser object
    if (HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
       (LPSPropTagArray)&tagaVCard,
       MAPI_UNICODE,      // flags
       &ulcValues,
       &lpspv)))
    {
        // @hack [bobn] {IE5-Raid 90265} Outlook cannot handle MAPI_UNICODE on Win9x
        // lets try not asking for unicode and converting...

        if(HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
          (LPSPropTagArray)&tagaVCard,
          0,      // flags
          &ulcValues,
          &lpspv)))
        {
            DebugTrace( TEXT("WriteVCard:GetProps -> %x\n"), GetScode(hResult));
            goto exit;
        }

        if(HR_FAILED(hResult = HrDupeOlkPropsAtoWC(ulcValues, lpspv, &lpspvAW)))
            goto exit;

        FreeBufferAndNull(&lpspv);
        lpspv = lpspvAW;
    }

    if (ulcValues) {

        WRITE_OR_EXIT(vckTable[VCARD_KEY_BEGIN]);
        WRITE_VALUE_OR_EXIT(vckTable[VCARD_KEY_VCARD], 0);

        WRITE_OR_EXIT(vckTable[VCARD_KEY_VERSION]);
        WRITE_VALUE_OR_EXIT(CURRENT_VCARD_VERSION, 0);

        //
        // Required props
        //

        //
        // Name
        //

        // Make sure we have a name.
        // If there is no FML, create them from DN.  If no DN, fail.
        cbSurname = PropLength(lpspv[ivcPR_SURNAME], &lpSurname);
        cbGivenName = PropLength(lpspv[ivcPR_GIVEN_NAME], &lpGivenName);
        cbMiddleName = PropLength(lpspv[ivcPR_MIDDLE_NAME], &lpMiddleName);
        cbGeneration = PropLength(lpspv[ivcPR_GENERATION], &lpGeneration);
        cbPrefix = PropLength(lpspv[ivcPR_DISPLAY_NAME_PREFIX], &lpPrefix);

        if (! lpSurname && ! lpGivenName && ! lpMiddleName) {
            // No FML, create them from DN.
            ParseDisplayName(
              lpspv[ivcPR_DISPLAY_NAME].Value.LPSZ,
              &lpGivenName,
              &lpSurname,
              lpspv,        // lpvRoot
              NULL);        // lppLocalFree

            cbGivenName = lstrlen(lpGivenName);
            cbSurname = lstrlen(lpSurname);
        }

        cbTemp = 0;
        cbTemp += cbSurname;
        cbTemp++;   // ';'
        cbTemp += cbGivenName;
        cbTemp++;   // ';'
        cbTemp += cbMiddleName;
        cbTemp++;   // ';'
        cbTemp += cbPrefix;
        cbTemp++;   // ';'
        cbTemp += cbGeneration;
        cbTemp++;

        if (! (lpSurname || lpGivenName || lpMiddleName)) {
            hResult = ResultFromScode(MAPI_E_MISSING_REQUIRED_COLUMN);
            goto exit;
        }
        if (! (lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*cbTemp))) {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        *lpTemp = '\0';
        if (lpSurname) {
            StrCatBuff(lpTemp, lpSurname, cbTemp);
        }
        if (lpGivenName || lpMiddleName || lpPrefix || lpGeneration) {
            StrCatBuff(lpTemp, szSemicolon, cbTemp);
        }
        if (lpGivenName) {
            StrCatBuff(lpTemp, lpGivenName, cbTemp);
        }
        if (lpMiddleName || lpPrefix || lpGeneration) {
            StrCatBuff(lpTemp, szSemicolon, cbTemp);
        }
        if (lpMiddleName) {
            StrCatBuff(lpTemp, lpMiddleName, cbTemp);
        }
        if (lpPrefix || lpGeneration) {
            StrCatBuff(lpTemp, szSemicolon, cbTemp);
        }
        if (lpPrefix) {
            StrCatBuff(lpTemp, lpPrefix, cbTemp);
        }
        if (lpGeneration) {
            StrCatBuff(lpTemp, szSemicolon, cbTemp);
            StrCatBuff(lpTemp, lpGeneration, cbTemp);
        }
        WRITE_OR_EXIT(vckTable[VCARD_KEY_N]);
        WRITE_VALUE_OR_EXITW(lpTemp, 0);
        LocalFreeAndNull(&lpTemp);

        //
        // Optional props
        //

        //
        // Formatted Name: PR_DISPLAY_NAME
        //
        if(bIsValidStrProp(lpspv[ivcPR_DISPLAY_NAME]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_FN]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_DISPLAY_NAME].Value.LPSZ, 0);
        }


        //
        // Title: PR_NICKNAME
        //
        if(bIsValidStrProp(lpspv[ivcPR_NICKNAME]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_NICKNAME]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_NICKNAME].Value.LPSZ, 0);
        }

        //
        // Organization: PR_COMPANY_NAME, PR_DEPARTMENT_NAME
        //
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_COMPANY_NAME], &lpCompanyName);
        cbTemp++;   // semicolon
        cbTemp += PropLength(lpspv[ivcPR_DEPARTMENT_NAME], &lpDepartmentName);
        cbTemp++;
        if (lpCompanyName || lpDepartmentName) {
            if (! (lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*cbTemp))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpCompanyName) {
                StrCatBuff(lpTemp, lpCompanyName, cbTemp);
            }
            if (lpDepartmentName) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
                StrCatBuff(lpTemp, lpDepartmentName, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ORG]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // Title: PR_TITLE
        //
        if(bIsValidStrProp(lpspv[ivcPR_TITLE]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_TITLE]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_TITLE].Value.LPSZ, 0);
        }

        //
        // Note: PR_COMMENT
        //
        if(bIsValidStrProp(lpspv[ivcPR_COMMENT]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_NOTE]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_COMMENT].Value.LPSZ, 0);
        }


        //
        // Phone numbers
        //

        //
        // PR_BUSINESS_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_BUSINESS_TELEPHONE_NUMBER],
          FALSE,        // fPref
          TRUE,         // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }


        //
        // PR_BUSINESS2_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_BUSINESS2_TELEPHONE_NUMBER],
          FALSE,        // fPref
          TRUE,         // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_HOME_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_HOME_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          TRUE,         // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_CELLULAR_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_CELLULAR_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          TRUE,         // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_CAR_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_CAR_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          TRUE)) {      // fCar
            goto exit;
        }

        //
        // PR_OTHER_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_OTHER_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_PAGER_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_PAGER_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          TRUE,         // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          TRUE,         // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_BUSINESS_FAX_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_BUSINESS_FAX_NUMBER],
          FALSE,        // fPref
          TRUE,         // fBusiness
          FALSE,        // fHome
          FALSE,        // fVoice
          TRUE,         // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }
        //
        // PR_HOME_FAX_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_HOME_FAX_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          TRUE,         // fHome
          FALSE,        // fVoice
          TRUE,         // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_HOME2_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_HOME2_TELEPHONE_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          TRUE,         // fHome
          FALSE,        // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_ISDN_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_ISDN_NUMBER],
          FALSE,        // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          FALSE,        // fVoice
          FALSE,        // fFax
          TRUE,         // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // PR_PRIMARY_TELEPHONE_NUMBER
        //
        if (hResult = WriteVCardTel(hVCard, WriteFn,
          lpspv[ivcPR_PRIMARY_TELEPHONE_NUMBER],
          TRUE,         // fPref
          FALSE,        // fBusiness
          FALSE,        // fHome
          FALSE,        // fVoice
          FALSE,        // fFax
          FALSE,        // fISDN
          FALSE,        // fCell
          FALSE,        // fPager
          FALSE)) {     // fCar
            goto exit;
        }

        //
        // Business Address
        //
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_POST_OFFICE_BOX], &lpPOBox);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OFFICE_LOCATION], &lpOffice);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_STREET], &lpStreet);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_CITY], &lpCity);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_STATE_OR_PROVINCE], &lpState);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_POSTAL_CODE], &lpPostalCode);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_BUSINESS_ADDRESS_COUNTRY], &lpCountry);
        cbTemp++;
        if (lpPOBox || lpOffice || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
            if (! (lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*cbTemp))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpPOBox) {
                StrCatBuff(lpTemp, lpPOBox, cbTemp);
            }
            if (lpOffice || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpOffice) {
                StrCatBuff(lpTemp, lpOffice, cbTemp);
            }
            if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpStreet) {
                StrCatBuff(lpTemp, lpStreet, cbTemp);
            }
            if (lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpCity) {
                StrCatBuff(lpTemp, lpCity, cbTemp);
            }
            if (lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpState) {
                StrCatBuff(lpTemp, lpState, cbTemp);
            }
            if (lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpPostalCode) {
                StrCatBuff(lpTemp, lpPostalCode, cbTemp);
            }
            if (lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
                StrCatBuff(lpTemp, lpCountry, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ADR]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);


            // Business Delivery Label
            // Use the same buffer
            *lpTemp = '\0';
            if (lpOffice) {
                StrCatBuff(lpTemp, lpOffice, cbTemp);
                if (lpPOBox || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpPOBox) {
                StrCatBuff(lpTemp, lpPOBox, cbTemp);
                if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpStreet) {
                StrCatBuff(lpTemp, lpStreet, cbTemp);
                if (lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpCity) {
                StrCatBuff(lpTemp, lpCity, cbTemp);
                if (lpState) {
                    StrCatBuff(lpTemp, szCommaSpace, cbTemp);
                } else if (lpPostalCode) {
                    StrCatBuff(lpTemp, szSpace, cbTemp);
                } else if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpState) {
                StrCatBuff(lpTemp, lpState, cbTemp);
                if (lpPostalCode) {
                    StrCatBuff(lpTemp, szSpace, cbTemp);
                } else if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpPostalCode) {
                StrCatBuff(lpTemp, lpPostalCode, cbTemp);
                if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpCountry) {
                StrCatBuff(lpTemp, lpCountry, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_LABEL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // Home Address
        //
        lpPOBox = lpStreet = lpCity = lpState = lpPostalCode = lpCountry = NULL;
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_POST_OFFICE_BOX], &lpPOBox);
        cbTemp+= 2;   // ';' or CRLF
        lpOffice = NULL;
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_STREET], &lpStreet);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_CITY], &lpCity);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_STATE_OR_PROVINCE], &lpState);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_POSTAL_CODE], &lpPostalCode);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_HOME_ADDRESS_COUNTRY], &lpCountry);
        cbTemp++;
        if (lpPOBox || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
            if (! (lpTemp = LocalAlloc(LPTR,  sizeof(TCHAR)*cbTemp))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpPOBox) {
                StrCatBuff(lpTemp, lpPOBox, cbTemp);
            }
            if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);   // WAB doesn't have extended on HOME address
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpStreet) {
                StrCatBuff(lpTemp, lpStreet, cbTemp);
            }
            if (lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpCity) {
                StrCatBuff(lpTemp, lpCity, cbTemp);
            }
            if (lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpState) {
                StrCatBuff(lpTemp, lpState, cbTemp);
            }
            if (lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpPostalCode) {
                StrCatBuff(lpTemp, lpPostalCode, cbTemp);
            }
            if (lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
                StrCatBuff(lpTemp, lpCountry, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ADR]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);


            // Home Delivery Label
            // Use the same buffer
            *lpTemp = '\0';
            if (lpPOBox) {
                StrCatBuff(lpTemp, lpPOBox, cbTemp);
                if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpStreet) {
                StrCatBuff(lpTemp, lpStreet, cbTemp);
                if (lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpCity) {
                StrCatBuff(lpTemp, lpCity, cbTemp);
                if (lpState) {
                    StrCatBuff(lpTemp, szCommaSpace, cbTemp);
                } else if (lpPostalCode) {
                    StrCatBuff(lpTemp, szSpace, cbTemp);
                } else if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpState) {
                StrCatBuff(lpTemp, lpState, cbTemp);
                if (lpPostalCode) {
                    StrCatBuff(lpTemp, szSpace, cbTemp);
                } else if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpPostalCode) {
                StrCatBuff(lpTemp, lpPostalCode, cbTemp);
                if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpCountry) {
                StrCatBuff(lpTemp, lpCountry, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_LABEL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // Other Address
        //
        lpPOBox = lpStreet = lpCity = lpState = lpPostalCode = lpCountry = NULL;
        cbTemp = 0;
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_POST_OFFICE_BOX], &lpPOBox);
        cbTemp+= 2;   // ';' or CRLF
        lpOffice = NULL;
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_STREET], &lpStreet);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_CITY], &lpCity);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_STATE_OR_PROVINCE], &lpState);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_POSTAL_CODE], &lpPostalCode);
        cbTemp+= 2;   // ';' or CRLF
        cbTemp += PropLength(lpspv[ivcPR_OTHER_ADDRESS_COUNTRY], &lpCountry);
        cbTemp++;
        if (lpPOBox || lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
            if (! (lpTemp = LocalAlloc(LPTR,  sizeof(TCHAR)*cbTemp))) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            *lpTemp = '\0';
            if (lpPOBox) {
                StrCatBuff(lpTemp, lpPOBox, cbTemp);
            }
            if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);   // WAB doesn't have extended on HOME address
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpStreet) {
                StrCatBuff(lpTemp, lpStreet, cbTemp);
            }
            if (lpCity || lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpCity) {
                StrCatBuff(lpTemp, lpCity, cbTemp);
            }
            if (lpState || lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpState) {
                StrCatBuff(lpTemp, lpState, cbTemp);
            }
            if (lpPostalCode || lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
            }
            if (lpPostalCode) {
                StrCatBuff(lpTemp, lpPostalCode, cbTemp);
            }
            if (lpCountry) {
                StrCatBuff(lpTemp, szSemicolon, cbTemp);
                StrCatBuff(lpTemp, lpCountry, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ADR]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_POSTAL]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);

            // Adr Label
            // Use the same buffer
            *lpTemp = '\0';
            if (lpPOBox) {
                StrCatBuff(lpTemp, lpPOBox, cbTemp);
                if (lpStreet || lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpStreet) {
                StrCatBuff(lpTemp, lpStreet, cbTemp);
                if (lpCity || lpState || lpPostalCode || lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpCity) {
                StrCatBuff(lpTemp, lpCity, cbTemp);
                if (lpState) {
                    StrCatBuff(lpTemp, szCommaSpace, cbTemp);
                } else if (lpPostalCode) {
                    StrCatBuff(lpTemp, szSpace, cbTemp);
                } else if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpState) {
                StrCatBuff(lpTemp, lpState, cbTemp);
                if (lpPostalCode) {
                    StrCatBuff(lpTemp, szSpace, cbTemp);
                } else if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpPostalCode) {
                StrCatBuff(lpTemp, lpPostalCode, cbTemp);
                if (lpCountry) {
                    StrCatBuff(lpTemp, szCRLF, cbTemp);
                }
            }
            if (lpCountry) {
                StrCatBuff(lpTemp, lpCountry, cbTemp);
            }
            WRITE_OR_EXIT(vckTable[VCARD_KEY_LABEL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_POSTAL]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        // GENDER
        if(! PROP_ERROR(lpspv[ivcPR_GENDER] ) )
        {           
            TCHAR szBuf[4];
            INT fGender = lpspv[ivcPR_GENDER].Value.l;

            // don't want to export gender data if
            // it is unspecified

            if( fGender == 1 || fGender == 2 ) 
            {
                szBuf[0] = '0' + fGender;
                szBuf[1] = '\0';                
                WRITE_OR_EXIT(vckTable[VCARD_KEY_X_WAB_GENDER]);             
                WRITE_OR_EXIT(szColonA);
                WRITE_OR_EXITW(szBuf);
                WRITE_OR_EXIT(szCRLFA);
            }
        }

        //
        // URL's.  Must do personal first.  Note that the vCard 2.0 standard does
        // not distinguish between HOME and WORK URL's.  Too bad.  Thus, if we export
        // a contact with only a business home page, then import it, we will end up
        // with a contact that has a personal home page.  Hopefully, the vCard 3.0 standard
        // will fix this.
        //

        // 62808: The above is really a big problem in Outlook because there is perceived data loss
        // Hence to prevent this, we will take advantage of a bug in WAB code .. blank URLS are not
        // ignored .. we will write out a blank URL for the personal one when only a business URL exists
        // That way, when round-tripping the business URL shows up in the right place
        //
        
		//
		// It's September of 2000.  The European Commission is looking at Outlook for their mail client,
		// one of the things that is hanging them up is this bug, the WORK URL jumps from the WORK URL 
		// box to the HOME URL if you export/import the vCard.  We need this functioning, so I looked
		// for the vCard 3.0 standard to see how they are handling the URL.  Every place I look says that
		// the people in charge of the vCard standard is www.versit.com, this however is a now defunct web
		// site, I queried the other companies that use the vCard, Apple, IBM, AT&T all give press releases
		// telling you to look at the www.versit.com web site, they also give a 1-800 number to call.  I've 
		// called the 1-800 number and that number is now a yellow pages operator.  I can't find a vCard 3.0 
		// standard, so......
		// 
		// Now, we all wish we could do this: URL;HOME: and URL;WORK:.  Well I'm going to do it!
		//
		
		//
        // URL: PR_PERSONAL_HOME_PAGE
        //
        if(bIsValidStrProp(lpspv[ivcPR_PERSONAL_HOME_PAGE]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_URL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_HOME]);

            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_PERSONAL_HOME_PAGE].Value.LPSZ, 0);
        }

        //
        // URL: PR_BUSINESS_HOME_PAGE
        //
        if(bIsValidStrProp(lpspv[ivcPR_BUSINESS_HOME_PAGE]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_URL]);
            WRITE_OR_EXITW(szSemicolon);
            WRITE_OR_EXIT(vctTable[VCARD_TYPE_WORK]);

            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_BUSINESS_HOME_PAGE].Value.LPSZ, 0);
        }

        //
        // ROLE: PR_PROFESSION
        //
        if(bIsValidStrProp(lpspv[ivcPR_PROFESSION]))
        {
            WRITE_OR_EXIT(vckTable[VCARD_KEY_ROLE]);
            WRITE_VALUE_OR_EXITW(lpspv[ivcPR_PROFESSION].Value.LPSZ, 0);
        }

        //
        // BDAY: PR_BIRTHDAY
        //
        // Format is YYYYMMDD e.g. 19970911 for September 11, 1997
        //
        if (! PROP_ERROR(lpspv[ivcPR_BIRTHDAY])) 
        {
            SYSTEMTIME st = {0};
            FileTimeToSystemTime((FILETIME *) (&lpspv[ivcPR_BIRTHDAY].Value.ft), &st);
            lpTemp = LocalAlloc(LPTR, sizeof(TCHAR)*32);
            wnsprintf(lpTemp, 32, TEXT("%.4d%.2d%.2d"), st.wYear, st.wMonth, st.wDay);
            WRITE_OR_EXIT(vckTable[VCARD_KEY_BDAY]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }

        //
        // DIGITAL CERTIFICATES
        //
        if(! PROP_ERROR(lpspv[ivcPR_USER_X509_CERTIFICATE] ) 
            // && ! PROP_ERROR(lpspv[ivcPR_EMAIL_ADDRESS])  
            )
        {   

            // LPTSTR              lpszDefaultEmailAddress = lpspv[ivcPR_EMAIL_ADDRESS].Value.LPSZ;
            LPSPropValue        lpSProp                 = &lpspv[ivcPR_USER_X509_CERTIFICATE];
            lpCDI = lpCDITemp = NULL;
            if( HR_FAILED(hResult = HrGetCertsDisplayInfo( NULL, lpSProp, &lpCDI) ) )
            {
                DebugTrace( TEXT("get cert display info failed\n"));
            }
            else
            {
                lpCDITemp = lpCDI;
                while( lpCDITemp )
                {
                /*        if( (lstrcmp(lpCDITemp->lpszEmailAddress, lpszDefaultEmailAddress) == 0)
                && lpCDITemp->bIsDefault )
                    break;*/
                    
                    if( lpCDITemp )  // found a certificate now export it to buffer and write to file          
                    {
                        ULONG  cbBufLen;                
                        
                        if( HR_SUCCEEDED(hResult = HrExportCertToFile( NULL, lpCDITemp->pccert, 
                            &lpDataBuffer, &cbBufLen, TRUE) ) )
                        {
                            WRITE_OR_EXIT(vckTable[VCARD_KEY_KEY]);
                            WRITE_OR_EXITW(szSemicolon);
                            WRITE_OR_EXIT(vctTable[VCARD_TYPE_X509]);
                            WRITE_VALUE_OR_EXITW(lpDataBuffer, cbBufLen);
                        }
                        else
                        {
                            DebugTrace( TEXT("unable to write to buffer at address %x\n"), lpDataBuffer);
                        }
                        LocalFreeAndNull(&lpDataBuffer);
                    }
                    lpCDITemp = lpCDITemp->lpNext;
                }                                        
            }
            while( lpCDI )  // free the cert info
            {
                lpCDITemp = lpCDI->lpNext;
                FreeCertdisplayinfo(lpCDI);
                lpCDI = lpCDITemp;
            }
            lpCDI = lpCDITemp = NULL;
        }
        //
        // E-Mail addresses
        //
        if (! PROP_ERROR(lpspv[ivcPR_CONTACT_EMAIL_ADDRESSES])) {
            // What's the default?
            if (PROP_ERROR(lpspv[ivcPR_CONTACT_DEFAULT_ADDRESS_INDEX])) {
                iDefaultEmail = 0;
            } else {
                iDefaultEmail = lpspv[ivcPR_CONTACT_DEFAULT_ADDRESS_INDEX].Value.l;
            }

            // for each email address, add an EMAIL key
            for (i = 0; i < lpspv[ivcPR_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.cValues; i++) {
                lpEmailAddress = lpspv[ivcPR_CONTACT_EMAIL_ADDRESSES].Value.MVSZ.LPPSZ[i];
                if (PROP_ERROR(lpspv[ivcPR_CONTACT_ADDRTYPES])) {
                    lpAddrType = (LPTSTR)szSMTP;
                } else {
                    lpAddrType = lpspv[ivcPR_CONTACT_ADDRTYPES].Value.MVSZ.LPPSZ[i];
                }
                if (hResult = WriteVCardEmail(hVCard, WriteFn, lpEmailAddress, lpAddrType, (iDefaultEmail == i))) {
                    goto exit;
                }
            }
        } else {
            // no PR_CONTACT_EMAIL_ADDRESSES, try PR_EMAIL_ADDRESS

            PropLength(lpspv[ivcPR_EMAIL_ADDRESS], &lpEmailAddress);
            PropLength(lpspv[ivcPR_ADDRTYPE], &lpAddrType);

            if (hResult = WriteVCardEmail(hVCard, WriteFn, lpEmailAddress, lpAddrType, TRUE)) {
                goto exit;
            }
        }

        //
        // EMAIL;TLX: PR_TELEX_NUMBER
        //
        // There is no place to put a telex number in a vCard but the EMAIL field
        // allows us to specify any AddrType .. hence under pressure from Outlook,
        // we force this Telex number into email .. Must make sure to filter this out
        // when we read in a vCard
        //
        if(bIsValidStrProp(lpspv[ivcPR_TELEX_NUMBER]))
        {
            if (hResult = WriteVCardEmail(hVCard, WriteFn, 
                                lpspv[ivcPR_TELEX_NUMBER].Value.LPSZ, 
                                TEXT("TLX"), FALSE)) 
            {
                goto exit;
            }
            
        }


        // Check if there are any outlook specific named properties
        // that need to be written out to the vCard
        if(lpList)
        {
            LPEXTVCARDPROP lpTemp = lpList;
            while(  lpTemp && lpTemp->ulExtPropTag && 
                    lpTemp->lpszExtPropName && lstrlenA(lpTemp->lpszExtPropName))
            {
                LPSPropValue lpspv = NULL;
                if(!HR_FAILED(HrGetOneProp( (LPMAPIPROP)lpMailUser,
                                            lpTemp->ulExtPropTag,
                                            &lpspv ) ))
                {
                    if(lpspv->Value.LPSZ && lstrlen(lpspv->Value.LPSZ))
                    {
                        WRITE_OR_EXIT(lpTemp->lpszExtPropName);
                        WRITE_VALUE_OR_EXITW(lpspv->Value.LPSZ, 0);
                    }
                    FreeBufferAndNull(&lpspv);
                }
                lpTemp = lpTemp->lpNext;
            }
        }

        //
        // REV: Current Modification Time
        //
        // Format is YYYYMMDD e.g. 19970911 for September 11, 1997
        //
        {
            SYSTEMTIME st = {0};
            DWORD ccSize = 32;

            GetSystemTime(&st);
            lpTemp = LocalAlloc(LPTR, sizeof(TCHAR) * ccSize);
            wnsprintf(lpTemp, ccSize, TEXT("%.4d%.2d%.2dT%.2d%.2d%.2dZ"), 
                            st.wYear, st.wMonth, st.wDay,
                            st.wHour,st.wMinute,st.wSecond);
            WRITE_OR_EXIT(vckTable[VCARD_KEY_REV]);
            WRITE_VALUE_OR_EXITW(lpTemp, 0);
            LocalFreeAndNull(&lpTemp);
        }
        // End of VCARD

        WRITE_OR_EXIT(vckTable[VCARD_KEY_END]);
        WRITE_VALUE_OR_EXIT(vckTable[VCARD_KEY_VCARD], 0);
    }

exit:
    if(lpList)
        FreeExtVCardPropList(lpList);

    while( lpCDI )  // free the cert info
    {
        lpCDITemp = lpCDI->lpNext;
        FreeCertdisplayinfo(lpCDI);
        lpCDI = lpCDITemp;
    }
    lpCDI = lpCDITemp = NULL;
    LocalFreeAndNull(&lpTemp);
    FreeBufferAndNull(&lpspv);
    LocalFreeAndNull(&lpDataBuffer);
    return(hResult);
}


/***************************************************************************

    Name      : FileWriteFn

    Purpose   : write to the file handle

    Parameters: handle = open file handle
                lpBuffer -> buffer to write
                uBytes = size of lpBuffer
                lpcbWritten -> returned bytes written (may be NULL)

    Returns   : HRESULT

    Comment   : WriteFile callback for WriteVCard

***************************************************************************/
HRESULT FileWriteFn(HANDLE handle, LPVOID lpBuffer, ULONG uBytes, LPULONG lpcbWritten) {
    ULONG cbWritten = 0;

    if (lpcbWritten) {
        *lpcbWritten = 0;
    } else {
        lpcbWritten = &cbWritten;
    }

#ifdef DEBUG
    {
        LPTSTR lpW = ConvertAtoW((LPCSTR)lpBuffer);
        DebugTrace(lpW);
        LocalFreeAndNull(&lpW);
    }
#endif

    if (! WriteFile(handle,
      lpBuffer,
      uBytes,
      lpcbWritten,
      NULL)) {
        DebugTrace( TEXT("FileWriteFn:WriteFile -> %u\n"), GetLastError());
        return(ResultFromScode(MAPI_E_DISK_ERROR));
    }

    return(hrSuccess);
}

////////////////////////////////////////////////////////////////

/*
-
- VCardGetBuffer
-
*   Retreives a vCard Buffer from a given filename or
*   retrieves a copy of a given buffer
*   Also inspects the buffer to see how many vCard
*   files are nested in it
*
*   lpszFileName - File to open
*   lpszBuf - Stream to open
*   ulFlags - MAPI_DIALOG or none
*   lppBuf - Local Alloced returned buf
*/
BOOL VCardGetBuffer(LPTSTR lpszFileName, LPSTR lpszBuf, LPSTR * lppBuf)
{
    BOOL bRet = FALSE;
    LPSTR lpBuf = NULL;
    HANDLE hFile = NULL;

    if(!lpszFileName && !lpszBuf)
        goto out;

    // first look for a buffer and not for the filename
    if(lpszBuf && lstrlenA(lpszBuf))
    {
        ULONG cbBuf = lstrlenA(lpszBuf)+1;
        lpBuf = LocalAlloc(LMEM_ZEROINIT, cbBuf);
        if(!lpBuf)
            goto out;
        StrCpyNA(lpBuf, lpszBuf, cbBuf);
    }
    else
    if(lpszFileName && lstrlen(lpszFileName))
    {
        if (INVALID_HANDLE_VALUE == 
            (hFile = CreateFile(lpszFileName,GENERIC_READ,FILE_SHARE_READ,NULL,
                                OPEN_EXISTING,FILE_FLAG_SEQUENTIAL_SCAN,NULL)))
        {
            goto out;
        }

        // Read the whole file into a buffer
        {
            DWORD dwSize = GetFileSize(hFile, NULL);
            DWORD dwRead = 0;
            if(!dwSize || dwSize == 0xFFFFFFFF)
                goto out; //err
            lpBuf = LocalAlloc(LMEM_ZEROINIT, dwSize+1);
            if(!lpBuf)
                goto out;
            if(!ReadFile(hFile, lpBuf, dwSize, &dwRead, NULL))
                goto out;
        }
    }

    *lppBuf = lpBuf;
    bRet = TRUE;
out:
    if(hFile)
        IF_WIN32(CloseHandle(hFile);) IF_WIN16(CloseFile(hFile);)
    return bRet;
}

/*
- 
- VCardGetNextBuffer
-
*   Scans a vCard buffer and returns pointers to the next vCard and the one after that
*
*/
static const LPSTR szVBegin = "BEGIN:VCARD";
static const LPSTR szVEnd = "END:VCARD";
BOOL VCardGetNextBuffer(LPSTR lpBuf, LPSTR * lppVCard, LPSTR * lppNext)
{
    LPSTR lpTemp = lpBuf;
    char sz[64];
    int nStr = lstrlenA(szVEnd);
    BOOL bFound = FALSE;
    BOOL bRet = TRUE;

    Assert(lppVCard);
    Assert(lppNext);
    *lppVCard = lpBuf;
    *lppNext = NULL;

    // Scan along lpBuf till we get to END:VCARD
    // After finding END:VCARD - insert a NULL to terminate the string 
    // and find the start of the next string

    if (!lpTemp)
        return FALSE;
    
    while((lstrlenA(lpTemp) >= nStr) && !bFound)
    {
        CopyMemory(sz,lpTemp,nStr);
        sz[nStr] = '\0';
        if(!lstrcmpiA(sz, szVEnd))
        {
            // Add a terminating NULL to isolate the vCard
            *(lpTemp + nStr) = '\0';
            lpTemp += nStr + 1;
            bFound = TRUE;
        }
        // scan to the end of the line
        while(*lpTemp && *lpTemp != '\n')
            lpTemp++;

        // Start from the next line
        if (*lpTemp)
            lpTemp++;
    }

    bFound = FALSE;
    nStr = lstrlenA(szVBegin);

    // Find the starting of the next BEGIN:VCARD
    while((lstrlenA(lpTemp) >= nStr) && !bFound)
    {
        CopyMemory(sz,lpTemp,nStr);
        sz[nStr] = '\0';
        if(!lstrcmpiA(sz, szVBegin))
        {
            *lppNext = lpTemp;
            bFound = TRUE;
        }
        else
        {
            // scan to the end of the line
            while(*lpTemp && *lpTemp != '\n')
                lpTemp++;

            // Start from the next line
            if (*lpTemp)
                lpTemp++;
        }
    }

    return bRet;
}


SizedSPropTagArray(2, tagaCerts) = { 2,
        {
            PR_USER_X509_CERTIFICATE,
            PR_WAB_TEMP_CERT_HASH
        }
};
/**
    ParseCert: will parse the binary data in the buffer and set the certificate 
               as a prop for the specified mailuser.
    [IN] lpData - address of the binary data buffer containing the certificate
    [IN] cbData - length of the binary data buffer
    [IN] lpMailUser - access to the mail user so the certificate can be set
*/
HRESULT ParseCert( LPSTR lpData, ULONG cbData, LPMAILUSER lpMailUser)
{
    HRESULT         hr          = hrSuccess;
    ULONG           ulcProps    = 0;
    LPSPropValue    lpSpv       = NULL;
    if( lpData && *lpData )
    {
        if( HR_FAILED( hr = lpMailUser->lpVtbl->GetProps( lpMailUser, 
                    (LPSPropTagArray)&tagaCerts, 
                    MAPI_UNICODE,
                    &ulcProps,
                    &lpSpv) ) )
        {
            DebugTrace( TEXT("could not get Props\n"));
            return hr;
        }
        if(lpSpv[0].ulPropTag != PR_USER_X509_CERTIFICATE )
        {
            MAPIFreeBuffer( lpSpv );
            MAPIAllocateBuffer( sizeof(SPropValue) * 2, &lpSpv);            
            if( lpSpv )            
            {
                lpSpv[0].ulPropTag = PR_USER_X509_CERTIFICATE;
                lpSpv[0].dwAlignPad = 0;
                lpSpv[0].Value.MVbin.cValues = 0;
                lpSpv[1].ulPropTag = PR_WAB_TEMP_CERT_HASH;
                lpSpv[1].dwAlignPad = 0;
                lpSpv[1].Value.MVbin.cValues = 0;
            }
            else
            {
                DebugTrace( TEXT("could not allocate mem for props\n"));
                hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                return hr;
            }
        }
        else
        {
            // [PaulHi] 5/3/99  Check the PR_WAB_TEMP_CERT_HASH to see if it is 
            // of type PT_ERROR.  If it is then this is Ok, it is just empty of
            // data.  We only use this to hold temporary data which is freed below.
            if ( PROP_TYPE(lpSpv[1].ulPropTag) == PT_ERROR )
            {
                lpSpv[1].ulPropTag = PR_WAB_TEMP_CERT_HASH;
                lpSpv[1].Value.MVbin.cValues = 0;
                lpSpv[1].Value.MVbin.lpbin = NULL;
            }
        }
        // Put the certs into the prop array.
        hr = HrLDAPCertToMAPICert( lpSpv, 0, 1, cbData, (LPBYTE)lpData, 1);
        if( HR_SUCCEEDED( hr ) )
        {
            if (HR_FAILED(hr = lpMailUser->lpVtbl->SetProps(lpMailUser,
                1,
                lpSpv,
                NULL))) 
            {
                DebugTrace( TEXT("failed setting props\n"));
            }
        }
        else
        {
            DebugTrace( TEXT("LDAPCertToMapiCert failed\n"));
        }  
        MAPIFreeBuffer( lpSpv );
    }
    else 
    {
        DebugTrace( TEXT("lpData was null\n"));
        hr = E_FAIL;
    }
    return hr;
}

/**
  DecodeBase64:  decode BASE64 data
  [IN] bufcoded - access to the BASE64 encoded data
  [OUT] pbuffdecoded - address of the buffer where decoded data will go
  [OUT] pcbDecode - length of the decoded data buffer
*/
HRESULT DecodeBase64(LPSTR bufcoded, LPSTR pbuffdecoded, PDWORD pcbDecoded)
{
    INT            nbytesdecoded;
    LPSTR         bufin;
    LPSTR         bufout;
    INT            nprbytes; 
    CONST INT     *rgiDict = base642six;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(rgiDict[*(bufin++)] <= 63);
    nprbytes = (INT) (bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    bufout = (LPSTR)pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (char) (rgiDict[*bufin] << 2 | rgiDict[bufin[1]] >> 4);
        *(bufout++) =
            (char) (rgiDict[bufin[1]] << 4 | rgiDict[bufin[2]] >> 2);
        *(bufout++) =
            (char) (rgiDict[bufin[2]] << 6 | rgiDict[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(rgiDict[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((LPSTR)pbuffdecoded)[nbytesdecoded] = '\0';

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\ui_srch.c ===
/*--------------------------------------------------------------
*
*
*   ui_srch.c - contains stuff for showing the WAB search dialog
*               with LDAP Search and Local Search
*
*
*
*
*
*  9/96 - created VikramM
--------------------------------------------------------------*/
#include "_apipch.h"

#define CONTROL_SPACE   7 //pixels
#define BORDER_SPACE  11 //pixels

typedef struct _ServerDat
{
    HIMAGELIST himl;
    SBinary SB;
} SERVERDAT, * LPSERVERDAT;

enum
{ 
    IS_LDAP = 0,
    IS_PAB,
    IS_OLK,
    IS_ERR
};

enum
{
    tabSimple=0,
    tabAdvanced,
    tabMax
};

// Structure passed to Search Dialog Proc
typedef struct _FindParams
{
    LDAP_SEARCH_PARAMS LDAPsp;
    SORT_INFO SortInfo;
    LPRECIPIENT_INFO lpContentsList;
    LPADRPARM_FINDINFO lpAPFI;
    BOOL bShowFullDialog; // Determines whether to show the full dialog or the truncated dialog
    BOOL bLDAPActionInProgress;
    LPLDAPURL lplu;
    BOOL bInitialized;
    BOOL bUserCancel;
    int MinDlgWidth;
    int MinDlgHeight;
    int MinDlgHeightWithResults;
} WAB_FIND_PARAMS, * LPWAB_FIND_PARAMS;


// Search dialog control arrays
int rgAdrParmButtonID[] =
{
    IDC_FIND_BUTTON_TO,
    IDC_FIND_BUTTON_CC,
    IDC_FIND_BUTTON_BCC
};

int rgAdvancedButtons[] = 
{
    IDC_FIND_BUTTON_ADDCONDITION,
    IDC_FIND_BUTTON_REMOVECONDITION
};

int rgSearchEditID[] =
{
    IDC_FIND_EDIT_NAME,
    IDC_FIND_EDIT_EMAIL,
    IDC_FIND_EDIT_STREET,
    IDC_FIND_EDIT_PHONE,
    IDC_FIND_EDIT_ANY,
};
#define SEARCH_EDIT_MAX 5 //sync with above array

/*
*   Prototypes
*/

// extern LPIMAGELIST_LOADIMAGE    gpfnImageList_LoadImage;
extern LPIMAGELIST_LOADIMAGE_A    gpfnImageList_LoadImageA;
extern LPIMAGELIST_LOADIMAGE_W    gpfnImageList_LoadImageW;

extern LPIMAGELIST_DESTROY      gpfnImageList_Destroy;
extern LPIMAGELIST_DRAW         gpfnImageList_Draw;

extern BOOL bIsHttpPrefix(LPTSTR szBuf);
extern const LPTSTR  lpszRegFindPositionKeyValueName;
extern BOOL ListAddItem(HWND hDlg, HWND hWndAddr, int CtlID, LPRECIPIENT_INFO * lppList, ULONG RecipientType);
extern HRESULT LDAPSearchWithoutContainer(HWND hWnd, LPLDAPURL lplu,
			   LPSRestriction  lpres,
			   LPTSTR lpAdvFilter,
			   BOOL bReturnSinglePropArray,
               ULONG ulFlags,
			   LPRECIPIENT_INFO * lppContentsList,
			   LPULONG lpulcProps,
			   LPSPropValue * lppPropArray);
extern HRESULT HrGetLDAPSearchRestriction(LDAP_SEARCH_PARAMS LDAPsp, LPSRestriction lpSRes);

#ifdef PAGED_RESULT_SUPPORT
extern BOOL bMorePagedResultsAvailable();
extern void ClearCachedPagedResultParams();
#endif //#ifdef PAGED_RESULT_SUPPORT


int ComboAddItem(HWND hWndLV, LPTSTR lpszItemText, LPARAM lParam, LPTSTR szPref, int * lpnStart, BOOL * lpbAddedPref);
INT_PTR CALLBACK fnSearch( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
void UpdateButtons(HWND hDlg, HWND hWndLVResults, HWND hWndLV, LPLDAPURL lplu);
//HRESULT HrInitServerListLV(HWND hWndLV);
LRESULT ProcessLVMessages(HWND   hWnd, UINT   uMsg, WPARAM   wParam, LPARAM lParam);
LRESULT ProcessLVResultsMessages(HWND   hWnd,
				 UINT   uMsg,
				 WPARAM   wParam,
				 LPARAM lParam,
				 LPWAB_FIND_PARAMS lpWFP);
BOOL DoTheSearchThing(HWND hDlg, LPWAB_FIND_PARAMS lpWFP);
void SaveFindWindowPos(HWND hWnd, LPIAB lpIAB);
int CurrentContainerIsPAB(HWND hWndLV);

static const LPTSTR szKeyLastFindServer = TEXT("Software\\Microsoft\\WAB\\WAB4\\LastFind");
static const LPTSTR c_tszPolicyPrefAccount = TEXT("Software\\Policies\\Microsoft\\Internet Account Manager\\Account Pref");


/***/
static DWORD rgSrchHelpIDs[] =
{
    IDC_FIND_STATIC_FINDIN,         IDH_WAB_DIR_SER_LIST,
    IDC_FIND_COMBO_LIST,            IDH_WAB_DIR_SER_LIST,
    IDC_FIND_STATIC_NAME,           IDH_WAB_FIND_FIRST,
    IDC_FIND_EDIT_NAME,             IDH_WAB_FIND_FIRST,
    IDC_FIND_STATIC_EMAIL,          IDH_WAB_FIND_E_MAIL,
    IDC_FIND_EDIT_EMAIL,            IDH_WAB_FIND_E_MAIL,
    IDC_FIND_STATIC_STREET,         IDH_WAB_FIND_ADDRESS,
    IDC_FIND_EDIT_STREET,           IDH_WAB_FIND_ADDRESS,
    IDC_FIND_STATIC_PHONE,          IDH_WAB_FIND_PHONE,
    IDC_FIND_EDIT_PHONE,            IDH_WAB_FIND_PHONE,
    IDC_FIND_STATIC_ANY,            IDH_WAB_FIND_OTHER,
    IDC_FIND_EDIT_ANY,              IDH_WAB_FIND_OTHER,
    IDC_FIND_BUTTON_FIND,           IDH_WAB_FIND_FINDNOW,
    IDC_FIND_BUTTON_CLEAR,          IDH_WAB_FIND_CLEARALL,
    IDC_FIND_BUTTON_CLOSE,          IDH_WAB_FIND_CLOSE,
    IDC_FIND_LIST_RESULTS,          IDH_WAB_FIND_RESULTS,
    IDC_FIND_BUTTON_PROPERTIES,     IDH_WAB_PICK_RECIP_NAME_PROPERTIES,
    IDC_FIND_BUTTON_DELETE,         IDH_WAB_FIND_DELETE,
    IDC_FIND_BUTTON_ADDTOWAB,       IDH_WAB_FIND_ADD2WAB,
    IDC_FIND_BUTTON_TO,             IDH_WAB_PICK_RECIP_NAME_TO_BUTTON,
    IDC_FIND_BUTTON_CC,             IDH_WAB_PICK_RECIP_NAME_CC_BUTTON,
    IDC_FIND_BUTTON_BCC,            IDH_WAB_PICK_RECIP_NAME_BCC_BUTTON,
    IDC_TAB_FIND,                   IDH_WAB_COMM_GROUPBOX,
    IDC_FIND_BUTTON_SERVER_INFO,    IDH_WAB_VISITDS_BUTTON,
    IDC_FIND_BUTTON_STOP,           IDH_WAB_FIND_STOP,
    IDC_FIND_STATIC_ADVANCED,       IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_COMBO_FIELD,           IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_COMBO_CONDITION,       IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_EDIT_ADVANCED,         IDH_WAB_FIND_ADV_CRITERIA,
    IDC_FIND_LIST_CONDITIONS,       IDH_WAB_FIND_ADV_CRITERIA_DISPLAY,
    IDC_FIND_BUTTON_ADDCONDITION,   IDH_WAB_FIND_ADV_CRITERIA_ADD,
    IDC_FIND_BUTTON_REMOVECONDITION,IDH_WAB_FIND_ADV_CRITERIA_REMOVE,
    0,0
};


/*
-
- ShowHideMoreResultsButton
*
*   This is called to show the MORE RESULTS button whenever
*   a paged result was done and a Cookie was cached
*   The button is hidden whenever search parameters change
*
*/
void ShowHideMoreResultsButton(HWND hDlg, BOOL bShow)
{
    HWND hWnd = GetDlgItem(hDlg, IDC_FIND_BUTTON_MORE);
    EnableWindow(hWnd, bShow);
    ShowWindow(hWnd, bShow ? SW_NORMAL : SW_HIDE);
}


/***/
/*
-   ResizeSearchDlg
-
*
*/
void ResizeSearchDlg(HWND hDlg, LPWAB_FIND_PARAMS lpWFP)
{
	// resize the dialog to show the full results and let the user
	// resize it henceforth without restriction
	RECT rc;
    HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);

	GetWindowRect(hDlg, &rc);
	lpWFP->bShowFullDialog = TRUE;
	SetWindowPos(hDlg, HWND_TOP, rc.left, rc.top,
			rc.right - rc.left, lpWFP->MinDlgHeightWithResults, 
			SWP_NOMOVE | SWP_NOZORDER);
	SetColumnHeaderBmp( hWndLVResults, lpWFP->SortInfo);

    // Also set the WS_TABSTOP style on the results Listview once the dialog is
    // expanded 
    {
	    DWORD dwStyle = GetWindowLong(hWndLVResults, GWL_STYLE);
	    dwStyle |= WS_TABSTOP;
	    SetWindowLong(hWndLVResults, GWL_STYLE, dwStyle);
    }
}

//$$///////////////////////////////////////////////////////////////////////////
//
// AddTabItem
//
////////////////////////////////////////////////////////////////////////////////
void AddTabItem(HWND hDlg, int nIndex)
{
    HWND hWndTab = GetDlgItem(hDlg, IDC_TAB_FIND);
    TC_ITEM tci ={0};
    TCHAR sz[MAX_PATH];
    LoadString(hinstMapiX, idsFindTabTitle+nIndex, sz, ARRAYSIZE(sz));
    tci.mask = TCIF_TEXT;
    tci.pszText = sz;
    tci.cchTextMax = lstrlen(sz)+1;
    TabCtrl_InsertItem(hWndTab, nIndex, &tci);
}

//$$////////////////////////////////////////////////////////////////////////////
//
// Gets the text of the currently selected item in the combo .. defaults to 
// item 0 if no selection
//
// szBuf should be a large enough predefined buffer
//
////////////////////////////////////////////////////////////////////////////////
void GetSelectedText(HWND hWndCombo, LPTSTR * lppBuf)
{
    int iItemIndex = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);
    int nLen = 0;

    if(!lppBuf)
	    return;
    
    *lppBuf = NULL;

    if(iItemIndex == CB_ERR)
    {
        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
        iItemIndex = 0;
    }

    nLen = (int) SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM) iItemIndex, 0);

    if (nLen != CB_ERR)
    {
        nLen++;     // Make space for the terminator
        *lppBuf = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR) * nLen);

        if(*lppBuf)
        {
            *lppBuf[0] = TEXT('\0');
            SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) iItemIndex, (LPARAM) *lppBuf);
        }
    }
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// hrShowSearchDialog - wrapper for Search UI
//
// lpAPFI - is a special structure passed in by the select recipients dialog
//  that enables us to add memebers to the select recipients dialog from the
//  find dialog
//
/////////////////////////////////////////////////////////////////////////////////
HRESULT HrShowSearchDialog(LPADRBOOK lpAdrBook,
		   HWND hWndParent,
		   LPADRPARM_FINDINFO lpAPFI,
	       LPLDAPURL lplu,
	       LPSORT_INFO lpSortInfo)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = (LPIAB)lpAdrBook;
    HRESULT hr = hrSuccess;
    int nRetVal = SEARCH_ERROR;
    WAB_FIND_PARAMS fp = {0};

    InitLDAPClientLib();

    fp.lpContentsList = NULL;

    if(!lpSortInfo)
    	ReadRegistrySortInfo(lpIAB, &(fp.SortInfo));
    else
    	fp.SortInfo = *lpSortInfo;

#ifndef WIN16 // Disable until ldap16.dll is available.
    if(!lplu)   //dont want anything filled in if this was a ldapurl thing
	fp.LDAPsp = pt_LDAPsp;
    fp.LDAPsp.lpIAB = lpAdrBook;
#endif

    fp.lpAPFI = lpAPFI;
    fp.lplu = lplu;

    if(lplu)
    {
	    if(lplu->lpList)
	        fp.bShowFullDialog = TRUE;
    }
    fp.bLDAPActionInProgress = FALSE;

    nRetVal = (int) DialogBoxParam(
		    hinstMapiX,
		    MAKEINTRESOURCE(IDD_DIALOG_FIND),
		    hWndParent,
		    fnSearch,
		    (LPARAM) &fp);

#ifndef WIN16 // Disable until ldap16.dll is available.
    pt_LDAPsp = fp.LDAPsp;
#endif

	if(lpAPFI)
        lpAPFI->nRetVal = nRetVal;

    switch(nRetVal)
    {
    case SEARCH_CANCEL:
	    hr = MAPI_E_USER_CANCEL;
	    break;
	case SEARCH_CLOSE:
    case SEARCH_OK:
	case SEARCH_USE:
	    hr = S_OK;
	    break;
    case SEARCH_ERROR:
	    hr = E_FAIL;
	    break;
    }

    if(fp.lpContentsList)
    {
		LPRECIPIENT_INFO lpItem;
		lpItem = fp.lpContentsList;
		while(lpItem)
		{
			fp.lpContentsList = lpItem->lpNext;
			FreeRecipItem(&lpItem);
			lpItem = fp.lpContentsList;
		}
		fp.lpContentsList = NULL;
	}

    DeinitLDAPClientLib();

    return hr;
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// SetEnableDisableUI - shows/hides edit fields based on whether selected item
//                       in the list view is WAB or Directory Service
//
//  hDlg - Parent dialog
//  hWndLV - List View
//
////////////////////////////////////////////////////////////////////////////////
void SetEnableDisableUI(HWND hDlg, HWND hWndCombo, LPLDAPURL lplu, int nTab)
{
    BOOL bIsWAB = FALSE, bHasLogo = FALSE;
    int swShowSimple, swShowSimpleWAB, swShowAdvanced;
    ULONG cbEID;
    LPENTRYID lpEID;

    // Just in case the list view lost its selection,
    // dont modify the UI


    if(!lplu && (CurrentContainerIsPAB(hWndCombo) != IS_LDAP))
        bIsWAB = TRUE;

    swShowSimple = (nTab == tabSimple) ? SW_SHOWNORMAL : SW_HIDE;
    swShowSimpleWAB = (nTab == tabSimple && bIsWAB) ? SW_SHOWNORMAL : SW_HIDE;
    swShowAdvanced = (nTab == tabAdvanced) ? SW_SHOWNORMAL : SW_HIDE;

    // Show / Hide the simple tab elements based on what this is
    //
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_NAME), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_NAME), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_EMAIL), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_EMAIL), swShowSimple);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_STREET), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_STREET), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_PHONE), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_PHONE), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_ANY), swShowSimpleWAB);
    ShowWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_ANY), swShowSimpleWAB);


    EnableWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_STREET), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_STREET), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_PHONE), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_PHONE), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_EDIT_ANY), bIsWAB);
    EnableWindow(GetDlgItem(hDlg,IDC_FIND_STATIC_ANY), bIsWAB);


    // Show / Hide the advanced tab elements based on what this is
    //
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_STATIC_ADVANCED), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_EDIT_ADVANCED), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), swShowAdvanced);
    ShowWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), swShowAdvanced);

    // Turn off advanced searching for WAB
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_STATIC_ADVANCED), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_EDIT_ADVANCED), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), !bIsWAB);
    //EnableWindow(GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS), !bIsWAB);


    if (! bIsWAB) 
    { // This is an LDAP container
	    LDAPSERVERPARAMS lsp = {0};
	    ULONG iItemIndex;
        LPTSTR lpBuf = NULL;

	    // Does it have a URL registered?
	    // Get the LDAP server properties for the selected container

        GetSelectedText(hWndCombo, &lpBuf);

        GetLDAPServerParams(lpBuf, &lsp);

    	if( nTab == tabSimple &&
            lsp.lpszLogoPath && lstrlen(lsp.lpszLogoPath) &&
	        GetFileAttributes(lsp.lpszLogoPath) != 0xFFFFFFFF )
        {
            HANDLE hbm = LoadImage( hinstMapiX, lsp.lpszLogoPath,
			            IMAGE_BITMAP, 134,38,
			            LR_LOADFROMFILE  | LR_LOADMAP3DCOLORS); //| LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS); //LR_DEFAULTCOLOR);
            if(hbm)
            {
                SendDlgItemMessage(hDlg, IDC_FIND_STATIC_LOGO, STM_SETIMAGE, (WPARAM) IMAGE_BITMAP, (LPARAM) hbm);
                bHasLogo = TRUE;
            }
        }


        if (lsp.lpszURL && lstrlen(lsp.lpszURL) && bIsHttpPrefix(lsp.lpszURL)) 
	        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_SERVER_INFO), TRUE);
        else
	        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_SERVER_INFO), FALSE);

        FreeLDAPServerParams(lsp);

        if(lpBuf)
	        LocalFree(lpBuf);
    }
    else
        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_SERVER_INFO), FALSE);

    ShowWindow(GetDlgItem(hDlg, IDC_FIND_STATIC_LOGO), (bHasLogo ? SW_SHOW : SW_HIDE));

    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// SetSearchUI - Sets up the Search UI
//
/////////////////////////////////////////////////////////////////////////////////
BOOL SetSearchUI(HWND hDlg, LPWAB_FIND_PARAMS lpWFP)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    int i =0;

    // Set the font of all the children to the default GUI font
    EnumChildWindows(   hDlg,
			SetChildDefaultGUIFont,
			(LPARAM) 0);

    // Set the title on the TAB
    AddTabItem(hDlg, tabSimple);
    AddTabItem(hDlg, tabAdvanced);

    //
    // Set the max text length of all the edit boxes to MAX_UI_STR
    //
    for(i=0;i<SEARCH_EDIT_MAX;i++)
    {
        SendMessage(GetDlgItem(hDlg,rgSearchEditID[i]),EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR-16,0);
    }
    SendMessage(GetDlgItem(hDlg,IDC_FIND_EDIT_ADVANCED),EM_SETLIMITTEXT,(WPARAM) MAX_UI_STR-16,0);


    HrInitListView( GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
					LVS_REPORT,
					TRUE);

    {
        HWND hWndAnim = GetDlgItem(hDlg, IDC_FIND_ANIMATE1);
        if(Animate_Open(hWndAnim, MAKEINTRESOURCE(IDR_AVI_WABFIND)))
        {
	        if(Animate_Play(hWndAnim, 0, 1, 0))
	        Animate_Stop(hWndAnim);
        }
    }

    // Set the to, cc, bcc buttons appropriately
    if(lpWFP->lpAPFI)
    {
	    // if this pointer is not null then we were called by a select recipients dlg
	    if(lpWFP->lpAPFI->lpAdrParms)
	    {
            LPADRPARM lpAdrParms = lpWFP->lpAPFI->lpAdrParms;
            ULONG i;

			// If this is called from the PickUser dialog, then the results list view
			// needs to be single select
			if(lpWFP->lpAPFI->DialogState == STATE_PICK_USER)
			{
				HWND hWndLV = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
				DWORD dwStyle= GetWindowLong(hWndLV , GWL_STYLE);
				SetWindowLong(hWndLV , GWL_STYLE, dwStyle | LVS_SINGLESEL);
			}

            for(i=0;i < lpAdrParms->cDestFields; i++)
            {
	            HWND hWndButton = GetDlgItem(hDlg, rgAdrParmButtonID[i]);
	            ShowWindow(hWndButton, SW_NORMAL);
	            EnableWindow(hWndButton, TRUE);
	            if(lpAdrParms->lppszDestTitles)
	            {
                    LPTSTR lpTitle = (lpAdrParms->ulFlags & MAPI_UNICODE) ?
                                        (LPWSTR)lpAdrParms->lppszDestTitles[i] :
                                         ConvertAtoW((LPSTR)lpAdrParms->lppszDestTitles[i]);          
                    if(lpTitle)
                    {
		                ULONG Len = lstrlen(lpTitle);
		                TCHAR szBuf[32];
                        if (Len > ARRAYSIZE(szBuf) - 4)
		                {
                            ULONG iLen = TruncatePos(lpTitle, ARRAYSIZE(szBuf) - 4);
                            CopyMemory(szBuf, lpTitle, min(iLen*sizeof(TCHAR), sizeof(szBuf)));
			                szBuf[iLen] = '\0';
		                }
		                else
                            StrCpyN(szBuf,lpTitle, ARRAYSIZE(szBuf));
                        StrCatBuff(szBuf,szArrow, ARRAYSIZE(szBuf));
		                SetWindowText(hWndButton, szBuf);
                        if(lpTitle != lpAdrParms->lppszDestTitles[i]) 
                            LocalFreeAndNull(&lpTitle);
                    }
	            }
            }
	    }
    }

    
    if(ReadRegistryPositionInfo((LPIAB)lpWFP->LDAPsp.lpIAB, &ABPosColSize, lpszRegFindPositionKeyValueName))
    {
        if( IsWindowOnScreen( &ABPosColSize.rcPos) )                      
        {
            int nW = ABPosColSize.rcPos.right-ABPosColSize.rcPos.left;
            MoveWindow(hDlg,
                ABPosColSize.rcPos.left,
                ABPosColSize.rcPos.top,
                (nW < lpWFP->MinDlgWidth) ? lpWFP->MinDlgWidth : nW,
                lpWFP->MinDlgHeight, 
                FALSE);
        }
    }
    else
    {
	    MoveWindow(hDlg,
		   20,
		   20,
		   lpWFP->MinDlgWidth, 
		   lpWFP->MinDlgHeight, 
		   FALSE);
    }

    if(ABPosColSize.nTab > tabMax)
        ABPosColSize.nTab = tabSimple;

    TabCtrl_SetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND), ABPosColSize.nTab);


    if(lpWFP->bShowFullDialog)
        ResizeSearchDlg(hDlg, lpWFP);

    {
	    TCHAR szBuf[MAX_PATH];
        LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, ARRAYSIZE(szBuf));
	    SetWindowText(hDlg, szBuf);
    }

    ImmAssociateContext(GetDlgItem(hDlg, IDC_FIND_EDIT_PHONE), (HIMC)NULL);   
    
    return TRUE;
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// ClearFieldCombo - Clears any allocated memory in the Advanced Field Combo
//
/////////////////////////////////////////////////////////////////////////////////
void ClearFieldCombo(HWND hWndCombo)
{
    int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    LPTSTR lp = NULL;
    if(!nCount || nCount == CB_ERR)
        return;

    if(nCount >= LDAPFilterFieldMax)
    {
        // Get the item behind the first element
        // This item is a pointer to an allocated string
        lp = (LPTSTR) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) LDAPFilterFieldMax, 0);
        if(lp && (CB_ERR != (ULONG_PTR)lp))
	        LocalFreeAndNull(&lp);
    }
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// FillAdvancedFieldCombos - Fills the Search UI with various information
//
/////////////////////////////////////////////////////////////////////////////////
void FillAdvancedFieldCombos(HWND hDlg, HWND hWndComboContainer)
{
    // The 2 advanced tab combos have data based on the current container ..
    // Hence need the CurrentContainerInfo here...
    BOOL bIsPAB =  (CurrentContainerIsPAB(hWndComboContainer) != IS_LDAP);
    HWND hWndComboField = GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD);
    HWND hWndComboCondition = GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION);
    int i = 0, nPos = 0, nMax = 0;
    TCHAR sz[MAX_PATH];

    ClearFieldCombo(hWndComboField);
    SendMessage(hWndComboCondition, CB_RESETCONTENT, 0, 0);

    {
        HWND hWndTab = GetDlgItem(hDlg, IDC_TAB_FIND);
        if(bIsPAB)
        {
	        TabCtrl_SetCurSel(hWndTab, tabSimple);
	        TabCtrl_DeleteItem(GetDlgItem(hDlg,IDC_TAB_FIND), tabAdvanced);
        }
        else
        {
	        if(TabCtrl_GetItemCount(hWndTab) < tabMax)
	        AddTabItem(hDlg, tabAdvanced);
        }
    }

    // If this is the WAB only give the "contains" option
    nMax = bIsPAB ? 1 : LDAPFilterOptionMax;

    for(i=0;i<nMax;i++)
    {
        LoadString(hinstMapiX, idsLDAPFilterOption1+i, sz, ARRAYSIZE(sz));
        nPos = (int) SendMessage(hWndComboCondition, CB_ADDSTRING, 0, (LPARAM) sz);
    }

    // Now add the default set of searchable attributes
    {
        LPTSTR lp = NULL;
        // If this is the WAB only give the Name and E-Mail option
        nMax = bIsPAB ? 2 : LDAPFilterFieldMax;

        for(i=0;i<nMax;i++)
        {
            LoadString(hinstMapiX, idsLDAPFilterField1+i, sz, ARRAYSIZE(sz));
	        nPos = (int) SendMessage(hWndComboField, CB_ADDSTRING, 0, (LPARAM) sz);
	        SendMessage(hWndComboField, CB_SETITEMDATA, (WPARAM) nPos, (LPARAM) g_rgszAdvancedFindAttrs[i]);
        }
    }

    // Check if this server has advanced Search attributes registered
    if(!bIsPAB)
    {
        LDAPSERVERPARAMS lsp = {0};
        LPTSTR lpBuf = NULL;

        GetSelectedText(hWndComboContainer, &lpBuf);
        GetLDAPServerParams(lpBuf, &lsp);
        if(lpBuf)
            LocalFree(lpBuf);

        if(lsp.lpszAdvancedSearchAttr && *(lsp.lpszAdvancedSearchAttr))
        {
            // we need to use this advanced search attributes
            ULONG cchSize = lstrlen(lsp.lpszAdvancedSearchAttr) + 1;
            LPTSTR  lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(cchSize));
            LPTSTR  lpAttr = NULL, lpName = NULL;
            BOOL    bAssigned = FALSE;

            if(!lp)
                return;
            StrCpyN(lp, lsp.lpszAdvancedSearchAttr, cchSize);

            // Attribute format is:
            // Attribute-Display-Name:Attribute,Attribute-Display-Name:Attribute, etc
            // e.g.
            // co:Company,cn:Common Name,etc
            //
            // So we will parse this string and feed it into the combo
            lpAttr = lp;
            while(*lpAttr)
            {
                LPTSTR lpTemp = lpAttr;
                while(*lpTemp && *lpTemp != ':')
	                lpTemp++;
                if(*lpTemp != ':')
	                break;
                lpName = lpTemp+1;
                *lpTemp = '\0';
                lpTemp = lpName;
                while(*lpTemp && *lpTemp != ',')
	                lpTemp++;
                if(*lpTemp == ',')
                {
	                *lpTemp = '\0';
	                lpTemp++;
                }

	            // Note that the LDAPFilterFieldMax-th item in the list will point to the allocated
	            // String 'lp'
	            // Hence to clean up we only need to free this item in the combo
                // [PaulHi] 3/4/99  Memory leak fix and @todo
                // Why not just make a copy of g_rgszAdvancedFindAttrs so
                // that special cases like these can be added?
	            nPos = (int) SendMessage(hWndComboField, CB_ADDSTRING, 0, (LPARAM) lpName);
	            SendMessage(hWndComboField, CB_SETITEMDATA, (WPARAM) nPos, (LPARAM) lpAttr);
                bAssigned = TRUE;

                lpAttr = lpTemp;
            }

            // [PaulHi] 3/4/99  Memory leak fix.  If this lp pointer isn't passed to the hWndComboField
            // combo box, for whatever reason, we need to deallocate it here.
            if (!bAssigned)
                LocalFreeAndNull(&lp);
	    }
    	FreeLDAPServerParams(lsp);
    }

    SendMessage(hWndComboField, CB_SETCURSEL, 0, 0);
    SendMessage(hWndComboCondition, CB_SETCURSEL, 0, 0);

}


//$$/////////////////////////////////////////////////////////////////////////////
//
// FillSearchUI - Fills the Search UI with various information
//
/////////////////////////////////////////////////////////////////////////////////
BOOL FillSearchUI(HWND hDlg,LPWAB_FIND_PARAMS lpWFP)
{

    int i;
    BOOL bRet = FALSE;
    HWND hWndCombo;

    TCHAR szBuf[MAX_UI_STR];
    LPLDAP_SEARCH_PARAMS lpLDAPsp = &(lpWFP->LDAPsp);
    //
    // Fill the fields if there is anything in the LDAPsp structure
    //
    for(i=0;i<SEARCH_EDIT_MAX;i++)
    {
	    switch(rgSearchEditID[i])
	    {
	    case IDC_FIND_EDIT_NAME:
            StrCpyN(szBuf,lpLDAPsp->szData[ldspDisplayName], ARRAYSIZE(szBuf));
		    break;
	    case IDC_FIND_EDIT_EMAIL:
            StrCpyN(szBuf,lpLDAPsp->szData[ldspEmail], ARRAYSIZE(szBuf));
		    break;
	    case IDC_FIND_EDIT_STREET:
            StrCpyN(szBuf,lpLDAPsp->szData[ldspAddress], ARRAYSIZE(szBuf));
		    break;
	    case IDC_FIND_EDIT_PHONE:
            StrCpyN(szBuf,lpLDAPsp->szData[ldspPhone], ARRAYSIZE(szBuf));
		    break;
	    case IDC_FIND_EDIT_ANY:
            StrCpyN(szBuf,lpLDAPsp->szData[ldspOther], ARRAYSIZE(szBuf));
		    break;
	    }
        szBuf[MAX_UI_STR -1] = '\0';
	    SetDlgItemText(hDlg,rgSearchEditID[i],szBuf);
    }


    //
    // Populate the combo box with the list of LDAP containers and set it to the current selection
    //
    hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);

    FreeLVItemParam(hWndCombo);

    if(lpWFP->lplu)
    {
	    LPSERVERDAT lpSD = LocalAlloc(LMEM_ZEROINIT,sizeof(SERVERDAT));
	    // Add this one item in the directory service list only ..
	    if(lpSD)
	    {
	        lpSD->himl = NULL;
	        lpSD->SB.cb = 0;
	        lpSD->SB.lpb = NULL;
	        ComboAddItem(    hWndCombo, //hWndLV,
				    lpWFP->lplu->lpszServer,
				    (LPARAM) lpSD,
				    NULL, NULL, NULL);
	        SetWindowText(hWndCombo, lpWFP->lplu->lpszServer);
	        SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);
	    }

	    if(lpWFP->lplu->lpList)
	    {
	        HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
		    HrFillListView(hWndLVResults,
						       lpWFP->lplu->lpList);
	        UpdateButtons(hDlg, hWndLVResults, hWndCombo, lpWFP->lplu); //hWndLV);
	        if(ListView_GetItemCount(hWndLVResults) > 0)
	        {
		        TCHAR szBuf[MAX_PATH];
		        TCHAR szBufStr[MAX_PATH - 6];
                LoadString(hinstMapiX, idsSearchDialogTitleWithResults, szBufStr, ARRAYSIZE(szBufStr));
                wnsprintf(szBuf, ARRAYSIZE(szBuf), szBufStr, ListView_GetItemCount(hWndLVResults));
		        SetWindowText(hDlg, szBuf);
	        }
	    }
    }
    else
    {
	    TCHAR   tsz[MAX_PATH];
        ULONG   cb = ARRAYSIZE(tsz);
        LPTSTR  lptszPreferredName = NULL;

	    if(!lstrlen(lpLDAPsp->szContainerName))
	    {
            LPIAB lpIAB = (LPIAB)lpLDAPsp->lpIAB;
            HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;

	        // Read the last used container name from the registry
            if (ERROR_SUCCESS == RegQueryValue(hKeyRoot, szKeyLastFindServer, tsz, &cb))
            {
                StrCpyN(lpLDAPsp->szContainerName, tsz, ARRAYSIZE(lpLDAPsp->szContainerName));
            }
            
            // [PaulHi] 3/19/99  Raid 73461  First check to see if there is a policy setting
            // pointing to the preferred selected server.  If so pass this server name in as
            // the preferred container name.  We still use the below "szContainerName" as
            // back up if the preferred name doesn't exist in the server enumeration.
            // [PaulHi] 6/22/99  I acutally had this backwards.  The policy should be checked
            // in this order: HKLM, HKCU, Identity  (instead of Identity, HKCU, HKLM).
            cb = ARRAYSIZE(tsz);
            if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_tszPolicyPrefAccount, tsz, &cb))
            {
                lptszPreferredName = tsz;
            }
            else
            {
                // Try looking at HKCU
                cb = ARRAYSIZE(tsz);
                if ( (hKeyRoot != HKEY_CURRENT_USER) && 
                    (ERROR_SUCCESS == RegQueryValue(HKEY_CURRENT_USER, c_tszPolicyPrefAccount, tsz, &cb)) )
                {
                    lptszPreferredName = tsz;
                }
                else
                {
                    // Finally try looking in current identity
                    cb = ARRAYSIZE(tsz);
                    if(ERROR_SUCCESS == RegQueryValue(hKeyRoot, c_tszPolicyPrefAccount, tsz, &cb))
                    {
                        lptszPreferredName = tsz;
                    }
                }
            }
        }

	    PopulateContainerList(lpLDAPsp->lpIAB,
				    hWndCombo,                      // hWndLV,
				    lpLDAPsp->szContainerName,      // Last used server name
                    lptszPreferredName);            // Preferred server name
    }

    // Fill the combos for the advanced field
    FillAdvancedFieldCombos(hDlg, hWndCombo);

    SetEnableDisableUI(hDlg, hWndCombo, lpWFP->lplu,
		    TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)) );

    return TRUE;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// UpdateButtons - Sets the state of the buttons based on various criteria
//
/////////////////////////////////////////////////////////////////////////////////
void UpdateButtons(HWND hDlg, HWND hWndLVResults, HWND hWndCombo, LPLDAPURL lplu) 
{

    BOOL bIsWAB = FALSE;
    BOOL bHasResults = (ListView_GetItemCount(hWndLVResults) > 0) ? TRUE : FALSE;
    int i;

    if(!lplu && CurrentContainerIsPAB(hWndCombo) != IS_LDAP)
	bIsWAB = TRUE;

    if (bIsWAB && bHasResults)
    {
	    // We have some search results
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_DELETE), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_DELETE), FALSE);
    }

    if (!bIsWAB && bHasResults)
    {
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), FALSE);
    }

    if(bHasResults)
    {
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), TRUE);
	    SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_PROPERTIES, 0);

	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO), TRUE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC), TRUE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC), TRUE);
    }
    else
    {
	    EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), FALSE);
	    SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_FIND, 0);

	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_TO), FALSE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_CC), FALSE);
	    if(IsWindowVisible(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC)))
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_BCC), FALSE);
    }
    return;
}


//$$/////////////////////////////////////////////////////////////////////////////
//
// GetAdvancedFilter - Creates an advanced filter from the pieces in the listbox
//
/////////////////////////////////////////////////////////////////////////////////
void GetAdvancedFilter(HWND hDlg, LPTSTR * lppAdvFilter, BOOL bLocalSearch, LPLDAP_SEARCH_PARAMS lpLDAPsp)
{
    LPTSTR lpF = NULL, lp =NULL;
    HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
    int nCount = 0, nLen = 0, i = 0;
    DWORD cchSizeF = 0;

    *lppAdvFilter = NULL;

    nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
    if(!nCount)
        return;

    for(i=0;i<nCount;i++)
    {
        lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) i, 0);
        if(lp)
            nLen += lstrlen(lp) + 1; 
    }

    cchSizeF = (nLen+4);
    lpF = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR) * cchSizeF); //add enough extra spaces for a 3 chars to each subfilter '(''&'')'
    if(!lpF)
        return;

    StrCpyN(lpF, szEmpty, cchSizeF);

    // We have to AND all the filters together 
    if(nCount > 1)
        StrCatBuff(lpF,  TEXT("(&"), cchSizeF);

    for(i=0;i<nCount;i++)
    {
        lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) i, 0);
        if(lp)
            StrCatBuff(lpF, lp, cchSizeF);
    }

    if(nCount > 1)
        StrCatBuff(lpF,  TEXT(")"), cchSizeF);

    DebugTrace( TEXT("Filter:%s\n"),lpF);

    *lppAdvFilter = lpF;

    if(bLocalSearch)
    {
	// the local search only allows searching on
    }
}

extern OlkContInfo *FindContainer(LPIAB lpIAB, ULONG cbEntryID, LPENTRYID lpEID);

//$$/////////////////////////////////////////////////////////////////////////////
//
// DoTheSearchThing - Does the search thing and produces results
//
/////////////////////////////////////////////////////////////////////////////////
BOOL DoTheSearchThing(HWND hDlg, LPWAB_FIND_PARAMS lpWFP)
{

    int i =0, iItemIndex=0;
    LPTSTR lpBuf = NULL;
    TCHAR szBuf[MAX_UI_STR];
    HWND hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);
    HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
    BOOL bRet = FALSE;
    LPLDAP_SEARCH_PARAMS lpLDAPsp = &(lpWFP->LDAPsp);
    HWND hWndAnim = GetDlgItem(hDlg, IDC_FIND_ANIMATE1);
    BOOL bAnimateStart = FALSE;
    HRESULT hr = E_FAIL;
    int SearchType = TRUE;
    LPSBinary lpsbCont = NULL;
    SBinary sbCont = {0};
	LPPTGDATA lpPTGData=GetThreadStoragePointer();

    HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    int nTab = TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND));
    LPTSTR lpAdvFilter = NULL;

    // Check if the current container is an LDAP container or a PAB container
    // or an Outlook contact store container
    if(lpWFP->lplu)
        SearchType = IS_LDAP;
    else
        SearchType = CurrentContainerIsPAB(hWndCombo);

    // if this is an advanced search, assemble a search filter
    if(tabAdvanced == nTab)
        GetAdvancedFilter(hDlg, &lpAdvFilter, (SearchType != IS_LDAP),  lpLDAPsp);
    else
    {
        for(i=0;i<SEARCH_EDIT_MAX;i++)
        {
	        if(IsWindowEnabled(GetDlgItem(hDlg, rgSearchEditID[i])))
	        {
                GetDlgItemText(hDlg,rgSearchEditID[i],szBuf,ARRAYSIZE(szBuf));
		        TrimSpaces(szBuf);
		        if (lstrlen(szBuf))
                    bRet = TRUE;

		        switch(rgSearchEditID[i])
		        {
		        case IDC_FIND_EDIT_NAME:
                    StrCpyN(lpLDAPsp->szData[ldspDisplayName], szBuf, ARRAYSIZE(lpLDAPsp->szData[0]));
			        break;
		        case IDC_FIND_EDIT_EMAIL:
                    StrCpyN(lpLDAPsp->szData[ldspEmail], szBuf, ARRAYSIZE(lpLDAPsp->szData[0]));
			        break;
		        case IDC_FIND_EDIT_STREET:
                    StrCpyN(lpLDAPsp->szData[ldspAddress], szBuf, ARRAYSIZE(lpLDAPsp->szData[0]));
			        break;
		        case IDC_FIND_EDIT_PHONE:
                    StrCpyN(lpLDAPsp->szData[ldspPhone], szBuf, ARRAYSIZE(lpLDAPsp->szData[0]));
			        break;
		        case IDC_FIND_EDIT_ANY:
                    StrCpyN(lpLDAPsp->szData[ldspOther], szBuf, ARRAYSIZE(lpLDAPsp->szData[0]));
			        break;
		        }
	        }
        }
    }
   
    GetSelectedText(hWndCombo, &lpBuf);
    
    StrCpyN(lpLDAPsp->szContainerName, (lpBuf ? lpBuf : szEmpty), ARRAYSIZE(lpLDAPsp->szContainerName));

    if(lpBuf)
        LocalFree(lpBuf);

    if((!bRet && nTab == tabSimple) ||
       (!lpAdvFilter && nTab == tabAdvanced) )
    {
	    ShowMessageBox(hDlg,idsSpecifySearchCriteria,MB_ICONEXCLAMATION | MB_OK);
	    goto out;
    }

    if(Animate_Open(hWndAnim, MAKEINTRESOURCE(IDR_AVI_WABFIND)))
    {
        if(Animate_Play(hWndAnim, 0, -1, -1))
	        bAnimateStart = TRUE;
    }

    {   // reset the window title
	    TCHAR szBuf[MAX_PATH];
        LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, ARRAYSIZE(szBuf));
	    SetWindowText(hDlg, szBuf);
    }

    if(SearchType == IS_PAB)
    {
        lpsbCont = NULL;
    }
    else if(SearchType == IS_OLK)
    {
        if (pt_bIsWABOpenExSession)
        {
	        OlkContInfo *polkci;
	        // is this an outlook container ?
	        GetCurrentContainerEID(hWndCombo,
			          &(sbCont.cb),
			          (LPENTRYID *)&(sbCont.lpb));

            EnterCriticalSection((&((LPIAB)lpLDAPsp->lpIAB)->cs));
	        polkci = FindContainer((LPIAB)(lpLDAPsp->lpIAB), 
				        sbCont.cb, (LPENTRYID) sbCont.lpb);
	        if(polkci)
                lpsbCont = &sbCont;
            LeaveCriticalSection((&((LPIAB)lpLDAPsp->lpIAB)->cs));
        }
    }

    // We do the actual search over here ....
    if(SearchType != IS_LDAP)
    {
	    // Local Search
	    ULONG ulFoundCount = 0;
        LPSBinary rgsbEntryIDs = NULL;

	    ClearListView(hWndLVResults, &(lpWFP->lpContentsList));

	    HrDoLocalWABSearch( ((LPIAB)lpWFP->LDAPsp.lpIAB)->lpPropertyStore->hPropertyStore,
                lpsbCont,
				lpWFP->LDAPsp,
				&ulFoundCount,
				&rgsbEntryIDs);

	    if(ulFoundCount && rgsbEntryIDs)
	    {
            ULONG i;

            for(i=0;i<ulFoundCount;i++)
            {
	            LPRECIPIENT_INFO lpItem = NULL;

		            if(!ReadSingleContentItem(  lpWFP->LDAPsp.lpIAB,
					            rgsbEntryIDs[i].cb,
					            (LPENTRYID) rgsbEntryIDs[i].lpb,
					            &lpItem))
		            continue;

	            if(!lpItem)
		            continue;
	            //
	            // Hook in the lpItem into the lpContentsList so we can free it later
	            //
	            lpItem->lpPrev = NULL;
	            lpItem->lpNext = lpWFP->lpContentsList;
	            if (lpWFP->lpContentsList)
		            (lpWFP->lpContentsList)->lpPrev = lpItem;
	            (lpWFP->lpContentsList) = lpItem;
            }

            HrFillListView(hWndLVResults, lpWFP->lpContentsList);
	    }

        FreeEntryIDs(((LPIAB)lpWFP->LDAPsp.lpIAB)->lpPropertyStore->hPropertyStore,
		         ulFoundCount, 
		         rgsbEntryIDs);

	    if(ListView_GetItemCount(hWndLVResults) <= 0)
            ShowMessageBox(hDlg, 
                            pt_bIsWABOpenExSession ? idsNoFolderSearchResults : idsNoLocalSearchResults, 
                            MB_OK | MB_ICONINFORMATION);

	    hr = S_OK;
    }
    else
    {

	    pt_hWndFind = hDlg;

	    //
	    // At this point we can discard the old data
	    //
	    ClearListView(hWndLVResults, 
                    (lpWFP->lplu && lpWFP->lplu->lpList) ? &(lpWFP->lplu->lpList) : &(lpWFP->lpContentsList));
	
        if(lpWFP->lplu)
        {
	        SRestriction Sres = {0};
	        if(!lpAdvFilter)
                hr = HrGetLDAPSearchRestriction(lpWFP->LDAPsp, &Sres);

	        hr = LDAPSearchWithoutContainer(hDlg, lpWFP->lplu,
					        &Sres,
					        lpAdvFilter,
					        FALSE,
                            MAPI_DIALOG,
					        &(lpWFP->lpContentsList),
					        NULL,
					        NULL);

	        if(!lpAdvFilter && Sres.res.resAnd.lpRes)
                MAPIFreeBuffer(Sres.res.resAnd.lpRes);
        }
        else
        {

	        hr = HrSearchAndGetLDAPContents( lpWFP->LDAPsp,
                            lpAdvFilter,
					        hWndCombo,
					        lpWFP->LDAPsp.lpIAB,
					        lpWFP->SortInfo,
					        &(lpWFP->lpContentsList));
        }

	    pt_hWndFind = NULL;

	    if(!HR_FAILED(hr))
	    {
#ifdef PAGED_RESULT_SUPPORT
            if(bMorePagedResultsAvailable())
                ShowHideMoreResultsButton(hDlg, TRUE);
#endif //#ifdef PAGED_RESULT_SUPPORT
            hr = HrFillListView(hWndLVResults,
							    lpWFP->lpContentsList);
	    }
        else
        {
#ifdef PAGED_RESULT_SUPPORT
            ClearCachedPagedResultParams();
            ShowHideMoreResultsButton(hDlg, FALSE);
#endif //#ifdef PAGED_RESULT_SUPPORT
        }
    }

    UpdateButtons(hDlg, hWndLVResults, hWndCombo, lpWFP->lplu);

    if(!HR_FAILED(hr))
    {
	    // The LDAp search results may not be in any sorted order - so always sort ...
	    SortListViewColumn((LPIAB)lpWFP->LDAPsp.lpIAB, hWndLVResults, colDisplayName, &(lpWFP->SortInfo), TRUE);

		LVSelectItem(hWndLVResults, 0);
        SetFocus(hWndLVResults);
    }

    if(ListView_GetItemCount(hWndLVResults) > 0)
    {
	    TCHAR szBuf[MAX_PATH];
	    TCHAR szBufStr[MAX_PATH - 6];
        LoadString(hinstMapiX, idsSearchDialogTitleWithResults, szBufStr, ARRAYSIZE(szBufStr));
        wnsprintf(szBuf, ARRAYSIZE(szBuf), szBufStr, ListView_GetItemCount(hWndLVResults));
	    SetWindowText(hDlg, szBuf);
    }

    bRet = TRUE;

out:
    if (bAnimateStart)
    	Animate_Stop(hWndAnim);

    SetCursor(hOldCur);

    if( bRet &&
	    !lpWFP->bShowFullDialog &&
	    (ListView_GetItemCount(hWndLVResults) > 0))
    {
        ResizeSearchDlg(hDlg, lpWFP);
    }
    LocalFreeAndNull(&lpAdvFilter);
    return bRet;
}


//$$/////////////////////////////////////////////////////////////////////////
//
// Enforces a size in response to user resizing
//
///////////////////////////////////////////////////////////////////////////
LRESULT EnforceSize(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LPWAB_FIND_PARAMS lpWFP )
{
	LPPOINT lppt = (LPPOINT)lParam;                 // lParam points to array of POINTs
    if(!lpWFP->bInitialized)
    {
        RECT rc, rc1;
        TCHAR sz[32];
        GetWindowRect(hWnd, &rc);
        GetWindowRect(GetDlgItem(hWnd, IDC_FIND_LIST_RESULTS), &rc1);
        LoadString(hinstMapiX, idsFindDlgWidth, sz, CharSizeOf(sz));
        lpWFP->MinDlgWidth = my_atoi(sz); // the resource is really wide to help localizers .. dont need that much
        lpWFP->MinDlgHeight = (rc1.top - rc.top - 3);
        lpWFP->MinDlgHeightWithResults = (rc.bottom - rc.top);
    }
    lppt[3].x  = lpWFP->MinDlgWidth;
    if(!lpWFP->bShowFullDialog)
    {
	    lppt[4].y = lppt[3].y  = lpWFP->MinDlgHeight; 
    }
    else
    {
	    lppt[3].y  = lpWFP->MinDlgHeightWithResults; 
    }
	return DefWindowProc(hWnd, uMsg, wParam, lParam);

}


#define FIND_BUTTON_MAX 12 //Keep in sync with array below
int rgFindButtonID[]=
{
    IDC_FIND_BUTTON_FIND,
    IDC_FIND_BUTTON_SERVER_INFO,
    IDC_FIND_BUTTON_STOP,
    IDC_FIND_BUTTON_CLEAR,
    IDC_FIND_BUTTON_CLOSE,
    IDC_FIND_BUTTON_PROPERTIES,
    IDC_FIND_BUTTON_DELETE,
    IDC_FIND_BUTTON_ADDTOWAB,
    IDC_FIND_BUTTON_MORE,
    IDC_FIND_BUTTON_TO,
    IDC_FIND_BUTTON_CC,
    IDC_FIND_BUTTON_BCC
};

//$$*************************************************************************
//
//  ResizeFindDialog - Resizes the child controls on the dialog in response to
//                  a WM_SIZE message
//
//
//***************************************************************************
void ResizeFindDialog(HWND hDlg, WPARAM wParam, LPARAM lParam, LPWAB_FIND_PARAMS lpWFP)
{
    DWORD fwSizeType = (DWORD) wParam;      // resizing flag
    int nWidth = LOWORD(lParam);  // width of client area
    int nHeight = HIWORD(lParam); // height of client area
    POINT ptLU; // Left, Upper vertex
    POINT ptRB; // Right, Bottom vertex
    RECT rc, rc1, rcDlg;
    int nButtonWidth, nButtonHeight;
    int nEditWidth, nEditHeight;
    int nLVWidth, nLVHeight;
    int nFrameWidth;
    int nAnimateWidth, nAnimateHeight;
    HWND hWndC = NULL;

    int i;

	HDWP hdwp = BeginDeferWindowPos(12);

    // Resize based on width

    // Move all the buttons to the right edge
    for(i=0;i<FIND_BUTTON_MAX;i++)
    {
        hWndC = GetDlgItem(hDlg,rgFindButtonID[i]);
	    GetWindowRect(hWndC,&rc);
	    nButtonWidth = (rc.right - rc.left);
	    nButtonHeight = (rc.bottom - rc.top);

	    ptLU.y = rc.top;
	    ptLU.x = 0;

	    ScreenToClient(hDlg, &ptLU);
	    ptLU.x = nWidth - BORDER_SPACE - nButtonWidth;

	    MoveWindow(hWndC,ptLU.x,ptLU.y,nButtonWidth, nButtonHeight, TRUE);
    }

    nLVWidth = nWidth - BORDER_SPACE - BORDER_SPACE - nButtonWidth - BORDER_SPACE;

    // Move the animation control too
    hWndC = GetDlgItem(hDlg,IDC_FIND_ANIMATE1);
    GetWindowRect(hWndC,&rc1);
    nAnimateWidth = rc1.right - rc1.left;
    nAnimateHeight = rc1.bottom - rc1.top;
    ptLU.x = rc1.left;
    ptLU.y = rc1.top;
    ScreenToClient(hDlg, &ptLU);
    ptLU.x = nWidth - BORDER_SPACE - nButtonWidth + (nButtonWidth - nAnimateWidth)/2;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nAnimateWidth, nAnimateHeight,TRUE);

    // Resize the Combo
    hWndC = GetDlgItem(hDlg,IDC_FIND_COMBO_LIST);
    GetWindowRect(hWndC,&rc);
    nLVHeight = rc.bottom - rc.top;
    //
    //This api works for both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU.x = rc.left;
    ptLU.y = rc.top;
    nFrameWidth = nLVWidth + BORDER_SPACE - ptLU.x;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nFrameWidth, nLVHeight,TRUE);
    ptRB.x = ptLU.x + nFrameWidth;

    // Resize the TAB
    hWndC = GetDlgItem(hDlg,IDC_TAB_FIND);
    GetWindowRect(hWndC,&rc);
    nLVHeight = rc.bottom - rc.top;
    //
    //This api working in both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU.x = rc.left;
    ptLU.y = rc.top;
    nFrameWidth = nLVWidth + BORDER_SPACE - ptLU.x;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nFrameWidth, nLVHeight,TRUE);
    ptRB.x = ptLU.x + nFrameWidth;

    // Resize the Edit Controls
    for(i=0;i<SEARCH_EDIT_MAX;i++)
    {
        hWndC = GetDlgItem(hDlg,rgSearchEditID[i]);
	    GetWindowRect(hWndC,&rc);

        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

	    ptLU.y = rc.top;
	    ptLU.x = rc.left;

	    nEditWidth = ptRB.x - BORDER_SPACE - ptLU.x; //ptRB.x is x coordinate of frame right edge

	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // Resize the advanced controls
    // First the group-box
    {
        hWndC = GetDlgItem(hDlg,IDC_FIND_STATIC_ADVANCED);
	    GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = ptRB.x - BORDER_SPACE - ptLU.x; //ptRB.x is x coordinate of tab right edge
        // update this variable with the group-box right border
        ptRB.x = ptLU.x + nEditWidth;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // Resize the Advanced edit controls also
    {
        hWndC = GetDlgItem(hDlg,IDC_FIND_COMBO_FIELD);
	    GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = (ptRB.x - BORDER_SPACE - 2*CONTROL_SPACE - ptLU.x)/3; //ptRB.x is x coordinate of frame right edge
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);

        hWndC = GetDlgItem(hDlg,IDC_FIND_COMBO_CONDITION);
        ptLU.x += nEditWidth + CONTROL_SPACE;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);

        hWndC = GetDlgItem(hDlg,IDC_FIND_EDIT_ADVANCED);
        ptLU.x += nEditWidth + CONTROL_SPACE;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // Move the two advanced buttons
    for(i=0;i<2;i++)
    {
        hWndC = GetDlgItem(hDlg,rgAdvancedButtons[i]);
        GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = rc.right - rc.left; // Dont modify width of the button
        ptLU.x = ptRB.x - BORDER_SPACE - nEditWidth;
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }
    // update this variable with the left edge of the button
    // List box width is adjusted based on this
    ptRB.x = ptLU.x;

    // Adjust the listbox width
    {
        hWndC = GetDlgItem(hDlg,IDC_FIND_LIST_CONDITIONS);
        GetWindowRect(hWndC,&rc);
        nEditHeight = (rc.bottom - rc.top);
        //
        //This api works for both mirrored and unmirrored windows.
        //
        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);        
	    ptLU.y = rc.top;
	    ptLU.x = rc.left;
	    nEditWidth = ptRB.x - BORDER_SPACE - ptLU.x; //ptRB.x is x coordinate of frame right edge
	    MoveWindow(hWndC,ptLU.x,ptLU.y,nEditWidth, nEditHeight, TRUE);
    }

    // For the height, we only adjust the list view height

    // Resize the List View
    hWndC = GetDlgItem(hDlg,IDC_FIND_LIST_RESULTS);
    GetWindowRect(hWndC,&rc);
    //
    //This api works for both mirrored and unmirrored windows.
    //
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    
    ptLU.x = rc.left;
    ptLU.y = rc.top;
    nLVHeight = nHeight - BORDER_SPACE - ptLU.y;
    MoveWindow(hWndC, ptLU.x, ptLU.y, nLVWidth, nLVHeight,TRUE);

	EndDeferWindowPos(hdwp);

    return;
}


//$$**************************************************************************
//
//  ShowContainerContextMenu - Shows the context menu for the container list
//
//
//****************************************************************************
/****/
void ShowContainerContextMenu(HWND hDlg,
			      HWND hWndCombo, //hWndLV,
			      LPARAM lParam)
{
	HMENU hMenu = LoadMenu(hinstMapiX, MAKEINTRESOURCE(IDM_FIND_CONTEXTMENU_CONTAINER));
	HMENU hMenuTrackPopUp = GetSubMenu(hMenu, 0);

	if (!hMenu || !hMenuTrackPopUp)
	{
		DebugPrintError(( TEXT("LoadMenu failed: %x\n"),GetLastError()));
		goto out;
	}

    if (CurrentContainerIsPAB(hWndCombo) != IS_LDAP)
        EnableMenuItem(hMenuTrackPopUp,IDM_FIND_CONTAINERPROPERTIES,MF_BYCOMMAND | MF_GRAYED);

    //
    // Popup the menu
    //
	TrackPopupMenu( hMenuTrackPopUp,
					TPM_LEFTALIGN | TPM_RIGHTBUTTON,
					LOWORD(lParam),
					HIWORD(lParam),
					0,
					hDlg,
					NULL);
	
	DestroyMenu(hMenu);

out:
	return;
}
/****/
//$$**************************************************************************
//
//  ShowContainerProperties - Shows the context menu for the container list
//
//  hWndLV - list containing the list of containers
//          We dont show any properties for the address book
//
//****************************************************************************
void ShowContainerProperties(   HWND hDlg,
						HWND hWndCombo,
						LPWAB_FIND_PARAMS lpWFP)
{
    LPTSTR lpBuf = NULL;

    GetSelectedText(hWndCombo, &lpBuf);

    if(!lpBuf || !lstrlen(lpBuf))
    {
        ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
    }
    else
    {
	    if(CurrentContainerIsPAB(hWndCombo) == IS_LDAP)
	    {
            LPTSTR ptszName=NULL;

            HrShowDSProps(hDlg, lpBuf, &ptszName, FALSE);

            if (ptszName)
            {
		        if(lstrcmpi(lpBuf, ptszName))
		        {
                    // The name changed, update it in the list view ...
                    SendMessage(hWndCombo, WM_SETREDRAW, FALSE, 0);
                    FreeLVItemParam(hWndCombo);
                    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);
                    PopulateContainerList(  lpWFP->LDAPsp.lpIAB,
                                    hWndCombo, ptszName, NULL);

                    SendMessage(hWndCombo, WM_SETREDRAW, TRUE, 0);
                    SetEnableDisableUI(hDlg, hWndCombo, lpWFP->lplu,
                    TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)));
		        }
                LocalFreeAndNull(&ptszName);
            }
	    }
    }
    LocalFreeAndNull(&lpBuf);
    return;
}

enum
{
    filtContains=0,
    filtIs,
    filtStartsWith,
    filtEndsWith,
    filtSoundsLike,
    filtMax
};


extern void EscapeIllegalChars(LPTSTR lpszSrcStr, LPTSTR lpszDestStr, ULONG cchDestStr);

/*//$$************************************************************************
//
//  CreateSubFilter();
//  Creates a subfilter basedon available data
//
//  szFIlter is a preallocated buffer big enough
//
/////////////////////////////////////////////////////////////////////////////*/
void CreateSubFilter(LPTSTR pszField, int nCondition, LPTSTR pszText, LPTSTR pszFilter, DWORD cchSizeFilter)
{
    LPTSTR pszTemplate = NULL;
    TCHAR szCleanText[MAX_PATH*2];
    
    EscapeIllegalChars(pszText, szCleanText, ARRAYSIZE(szCleanText));

    switch(nCondition)
    {
    case filtContains:
        pszTemplate =  TEXT("(%s=*%s*)");
        break;
    case filtIs:
        pszTemplate =  TEXT("(%s=%s)");
        break;
    case filtStartsWith:
        pszTemplate =  TEXT("(%s=%s*)");
        break;
    case filtEndsWith:
        pszTemplate =  TEXT("(%s=*%s)");
        break;
    case filtSoundsLike:
        pszTemplate =  TEXT("(%s=~%s)");
        break;
    }
    wnsprintf(pszFilter, cchSizeFilter, pszTemplate, pszField, szCleanText);
}

/*//$$************************************************************************
//
//  HrAddFindFilterCondition(hDlg);
//  Adds a condition to the advanced find list box
//
/////////////////////////////////////////////////////////////////////////////*/
HRESULT HrAddFindFilterCondition(HWND hDlg)
{
    HWND hWndComboField = GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD);
    HWND hWndComboCondition = GetDlgItem(hDlg, IDC_FIND_COMBO_CONDITION);
    HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
    HRESULT hr = E_FAIL;
    int nID = 0, nCount = 0, nPos = 0;
    LPTSTR lpField = NULL, lpCondition = NULL, lpsz[3], lpFilter = NULL;
    TCHAR szField[MAX_PATH], szCondition[MAX_PATH];
    TCHAR szText[MAX_PATH], szString[MAX_PATH], szFormat[MAX_PATH];
    DWORD cchSize = 0;

    // if the text field is empty, do nothing
    GetDlgItemText(hDlg, IDC_FIND_EDIT_ADVANCED, szText, ARRAYSIZE(szText));
    if(!lstrlen(szText))
        goto out;

    // depending on whether this is the 1st item or not, there is an And in the beginning
    nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
    nID = ((nCount > 0) ? idsFindFilterAnd : idsFindFilter);
    LoadString(hinstMapiX, nID, szFormat, ARRAYSIZE(szFormat));

    // Get the selected item in the Field Combo
    nPos = (int) SendMessage(hWndComboField, CB_GETCURSEL, 0, 0);
    if(nPos == CB_ERR)
        goto out;
    cchSize = (DWORD)SendMessage(hWndComboField, CB_GETLBTEXTLEN, (WPARAM) nPos, (LPARAM) 0);
    if ((cchSize == CB_ERR) || (ARRAYSIZE(szField) < cchSize))
        goto out;
    SendMessage(hWndComboField, CB_GETLBTEXT, (WPARAM) nPos, (LPARAM) szField);
    lpField = (LPTSTR) SendMessage(hWndComboField, CB_GETITEMDATA, (WPARAM) nPos, 0);

    // Get the selected item in the Condition Combo
    nPos = (int) SendMessage(hWndComboCondition, CB_GETCURSEL, 0, 0);
    if(nPos == CB_ERR)
        goto out;
    cchSize =(DWORD)SendMessage(hWndComboCondition, CB_GETLBTEXTLEN, (WPARAM) nPos, (LPARAM) 0);
    if ((cchSize == CB_ERR) || (ARRAYSIZE(szCondition) < cchSize))
        goto out;
    SendMessage(hWndComboCondition, CB_GETLBTEXT, (WPARAM) nPos, (LPARAM) szCondition);

    // Now create the formatted message
    if(     (lstrlen(szField) > 1023) ||
            (lstrlen(szCondition) > 1023) ||
            (lstrlen(szText) > 1023))
        goto out;

    lpsz[0] = szField;
    lpsz[1] = szCondition;
    lpsz[2] = szText;

    if (! FormatMessage(  FORMAT_MESSAGE_FROM_STRING |
			  FORMAT_MESSAGE_ALLOCATE_BUFFER |
			  FORMAT_MESSAGE_ARGUMENT_ARRAY,
			  szFormat,
			  0,                    // stringid
			  0,                    // dwLanguageId
			  (LPTSTR)&lpCondition,     // output buffer
			  0,               
			  (va_list *)lpsz))
    {
        DebugTrace( TEXT("FormatMessage -> %u\n"), GetLastError());
        goto out;
    }
    // <TBD> create the sub filter at this point
    CreateSubFilter(lpField, nPos, szText, szString, ARRAYSIZE(szString));

    cchSize = (lstrlen(szString)+1);
    lpFilter = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)* cchSize);
    if(!lpFilter)
        goto out;
    StrCpyN(lpFilter, szString, cchSize);

    nPos = (int) SendMessage(hWndLB, LB_ADDSTRING, 0, (LPARAM) lpCondition);
    SendMessage(hWndLB, LB_SETITEMDATA, (WPARAM) nPos, (LPARAM) lpFilter);
    SendMessage(hWndLB, LB_SETCURSEL, (WPARAM) nPos, 0);
    DebugTrace( TEXT("%s\n"), lpFilter);

    hr = S_OK;
out:
    IF_WIN32(LocalFree(lpCondition);)
    IF_WIN16(FormatMessageFreeMem(lpCondition);)
    return hr;
}


//$$*************************************************************************
//
//  DoInitialFindDlgResizing -
//
//  There are so many controls (some which overlap) on the find dialog that 
//  localizers can't make head or tail of them - so we spread the controls around
//  in the resource description and then at runtime, we move them all to their 
//  appropriate locations - right now, this means shifting the Advanced-Pane
//  controls to be flush left with the beginning of the name static ..
//
//***************************************************************************
void DoInitialFindDlgResizing (HWND hDlg)
{
    POINT ptLU; // Left, Upper vertex
    RECT rcN, rcF, rc;
    HWND hWndC = NULL;
    int nMove = 0, nButtonWidth = 0 , nButtonHeight = 0;

    int rgAdv[] = { IDC_FIND_STATIC_ADVANCED,
            IDC_FIND_COMBO_FIELD,
            IDC_FIND_COMBO_CONDITION,
            IDC_FIND_EDIT_ADVANCED,
            IDC_FIND_LIST_CONDITIONS,
            IDC_FIND_BUTTON_ADDCONDITION,
            IDC_FIND_BUTTON_REMOVECONDITION };
    int i = 0, nAdvMax = 7;

    GetWindowRect(GetDlgItem(hDlg, IDC_FIND_STATIC_NAME), &rcN);
    GetWindowRect(GetDlgItem(hDlg, IDC_FIND_STATIC_ADVANCED), &rcF);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcN, 2);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&rcF, 2);    
    
    nMove = rcF.left - rcN.left; // we want to move everything left this many units

    for(i=0;i<nAdvMax;i++)
    {
        hWndC = GetDlgItem(hDlg,rgAdv[i]);
        GetWindowRect(hWndC,&rc);

        nButtonWidth = (rc.right - rc.left);
        nButtonHeight = (rc.bottom - rc.top);

        MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);    

        ptLU.y = rc.top;
        ptLU.x = rc.left;

        // ScreenToClient(hDlg, &ptLU);
        ptLU.x -= nMove;

        MoveWindow(hWndC,ptLU.x,ptLU.y,nButtonWidth, nButtonHeight, TRUE);
    }
}
/****/

/*//$$************************************************************************
//
//  fnSearch - Search Dialog Proc
//
**************************************************************************/
INT_PTR CALLBACK fnSearch(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    ULONG nLen = 0, nLenMax = 0, nRetVal=0;
    HRESULT hr = hrSuccess;
    static FILETIME ftLast = {0};

    LPWAB_FIND_PARAMS lpWFP = (LPWAB_FIND_PARAMS) GetWindowLongPtr(hDlg,DWLP_USER);
    LPLDAP_SEARCH_PARAMS lpLDAPsp = &(lpWFP->LDAPsp);

    switch(message)
    {
    case WM_INITDIALOG:
	    SetWindowLongPtr(hDlg,DWLP_USER,lParam); //Save this for future reference
	    lpWFP = (LPWAB_FIND_PARAMS) lParam;
	    lpLDAPsp = &(lpWFP->LDAPsp);
	    {
            HICON hIcon = LoadIcon(hinstMapiX, MAKEINTRESOURCE(IDI_ICON_ABOOK));
            SendMessage(hDlg, WM_SETICON, (WPARAM) ICON_BIG, (LPARAM) hIcon);
	    }
        DoInitialFindDlgResizing (hDlg);
        SetSearchUI(hDlg,lpWFP);
        FillSearchUI(hDlg,lpWFP);
        if(!GetParent(hDlg))
        {
            // Then this is going to be a top level dialog and won't block any identity
            // changes .. most likely it came from the Find | People option
            // In case the address book object is ready to receive identity change 
            // notifications, we should set our hWnd on the LPIAB object so we get a 
            // message telling us to refresh the user ..
            ((LPIAB)(lpLDAPsp->lpIAB))->hWndBrowse = hDlg;
        }
        SetForegroundWindow(hDlg); // On OSR2, this window will sometimes not come up in focus - needs explicit call
        lpWFP->bInitialized = TRUE;
	    break;

	case WM_GETMINMAXINFO:
		//enforce a minimum size for sanity
		return EnforceSize(hDlg, message, wParam, lParam, lpWFP);
		break;

    default:
#ifndef WIN16
	if((g_msgMSWheel && message == g_msgMSWheel) 
        // || message == WM_MOUSEWHEEL
        )
	{
	    if(GetFocus() == GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS))
		SendMessage(GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS), message, wParam, lParam);
	    break;
	}
#endif
	    return FALSE;
	break;

   case WM_COMMAND:
	    switch(GET_WM_COMMAND_CMD(wParam,lParam)) //check the notification code
	    {
	    case EN_CHANGE: //some edit box changed - dont care which
            ShowHideMoreResultsButton(hDlg, FALSE);
            switch(LOWORD(wParam))
            {
            case IDC_FIND_EDIT_ADVANCED:
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), TRUE);
                // Set focus on the ADD button
                SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_ADDCONDITION, 0);
                break;
            default:
	            SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_FIND, 0);
	            break;
            }
            break;
        case CBN_SELCHANGE:
            ShowHideMoreResultsButton(hDlg, FALSE);
            switch(LOWORD(wParam))
            {
            case IDC_FIND_COMBO_LIST:
                FillAdvancedFieldCombos(hDlg, (HWND) lParam);
                SetEnableDisableUI(hDlg, (HWND) lParam, lpWFP->lplu,
                TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)));
                break;
            }
            break;
	    }
	    switch (GET_WM_COMMAND_ID(wParam,lParam))
	    {
        default:
            return ProcessActionCommands(   (LPIAB) lpWFP->LDAPsp.lpIAB, 
					            GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS), 
					            hDlg, message, wParam, lParam);
            break;

        case IDC_FIND_BUTTON_REMOVECONDITION:
            {
                HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
                int nCount = 0, nPos = (int) SendMessage(hWndLB, LB_GETCURSEL, 0, 0);
                if(nPos != LB_ERR)
                {
	                LPTSTR lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) nPos, 0);
	                if(lp)
                        LocalFree(lp);
	                SendMessage(hWndLB, LB_DELETESTRING, (WPARAM) nPos, 0);
	                nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
	                if(nCount == 0)
                        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), FALSE);
	                else
	                {
                        if(nPos >= nCount)
                            nPos--;
                        SendMessage(hWndLB, LB_SETCURSEL, (WPARAM) nPos, 0);
	                }
                }
            }
            break;
        case IDC_FIND_BUTTON_ADDCONDITION:
            HrAddFindFilterCondition(hDlg);
            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), TRUE);
            // Default button is FIND
	            SendMessage (hDlg, DM_SETDEFID, IDC_FIND_BUTTON_FIND, 0);
            break;

        case IDC_FIND_BUTTON_STOP:
	        if(lpWFP->bLDAPActionInProgress)
	        {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                if(pt_hDlgCancel)
	                SendMessage(pt_hDlgCancel, WM_COMMAND, (WPARAM) IDCANCEL, 0);
	        }
	        break;


            // only difference between FIND and MORE is that
            // in MORE we repeat the search with the cached paged result cookie
            // if one exists. If the cookie doesnt exist, user wouldnt get to 
            // see the MORE button
            // Any change in search parameters also hides the MORE button
	    case IDC_FIND_BUTTON_FIND:
#ifdef PAGED_RESULT_SUPPORT
	        if(!lpWFP->bLDAPActionInProgress)
                ClearCachedPagedResultParams(); 
#endif //#ifdef PAGED_RESULT_SUPPORT
        case IDC_FIND_BUTTON_MORE:
	        // 96/11/20 markdu  BUG 11030
	        // Disable the find now button so we only get one search.
	        if(!lpWFP->bLDAPActionInProgress)
	        {
                LPPTGDATA lpPTGData=GetThreadStoragePointer();
                pt_bDontShowCancel = TRUE;
                lpWFP->bUserCancel = FALSE;
		        lpWFP->bLDAPActionInProgress = TRUE;
                ShowHideMoreResultsButton(hDlg, FALSE);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_FIND), FALSE);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_STOP), TRUE);
		        DoTheSearchThing(hDlg, lpWFP);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_FIND), TRUE);
		        EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_STOP), FALSE);
		        lpWFP->bLDAPActionInProgress = FALSE;
                pt_bDontShowCancel = FALSE;
                if(lpWFP->bUserCancel) // DId the user try to cancel while the search was happening
                {
	                lpWFP->bUserCancel = FALSE;
	                PostMessage(hDlg, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_CLOSE, 0);
                }
	        }
	        break;

	    case IDC_FIND_BUTTON_CLEAR:
            if(!lpWFP->bLDAPActionInProgress)
            {
	            int i;
	            TCHAR szBuf[MAX_PATH];

                LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, ARRAYSIZE(szBuf));
	            SetWindowText(hDlg, szBuf);

	            for(i=0;i<SEARCH_EDIT_MAX;i++)
		            SetDlgItemText(hDlg, rgSearchEditID[i], szEmpty);

                // Clear the advanced buttons too
                SetDlgItemText(hDlg, IDC_FIND_EDIT_ADVANCED, szEmpty);
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDCONDITION), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_REMOVECONDITION), FALSE);
                SendDlgItemMessage(hDlg, IDC_FIND_LIST_CONDITIONS, LB_RESETCONTENT, 0, 0);

	            ClearListView(  GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
	            (lpWFP->lplu && lpWFP->lplu->lpList) ? &(lpWFP->lplu->lpList) : &(lpWFP->lpContentsList));

	            for(i=0;i<ldspMAX;i++)
	            {
                    StrCpyN(lpLDAPsp->szData[i], szEmpty, ARRAYSIZE(lpLDAPsp->szData[i]));
	            }
            }
            break;

	    case IDOK:
	    case IDCANCEL:
	    case IDC_FIND_BUTTON_CLOSE:
	    // Clear any contents in the Advanced LB
    	    {
	            int nCount = 0, i = 0;
	            HWND hWndLB = GetDlgItem(hDlg, IDC_FIND_LIST_CONDITIONS);
	            nCount = (int) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);
	            if(nCount)
	            {
		            for(i=0;i<nCount;i++)
		            {
		            LPTSTR lp = (LPTSTR) SendMessage(hWndLB, LB_GETITEMDATA, (WPARAM) i, 0);
		            if(lp)
			            LocalFree(lp);
		            }
		            SendMessage(hWndLB, LB_RESETCONTENT, 0, 0);
	            }
	            // Clear any allocated memory in the field combo box
	            ClearFieldCombo(GetDlgItem(hDlg, IDC_FIND_COMBO_FIELD));
	        }
	        // if there is an LDAP operation in progress, close it and set the
	        // flag to cancel from where the LDAP operation was initialized
	        // This prevents aborting any process incompletely and faulting
	        if(lpWFP->bLDAPActionInProgress)
	        {
	            LPPTGDATA lpPTGData=GetThreadStoragePointer();
	            if(pt_hDlgCancel)
		            SendMessage(pt_hDlgCancel, WM_COMMAND, (WPARAM) IDCANCEL, 0);
	            lpWFP->bUserCancel= TRUE;
	        }
	        else
	        {
		        SaveFindWindowPos(hDlg, (LPIAB)lpWFP->LDAPsp.lpIAB);
		        FreeLVItemParam(GetDlgItem(hDlg, IDC_FIND_COMBO_LIST));//IDC_FIND_LIST));
		        EndDialog(hDlg, SEARCH_CLOSE);
	        }
	        break;

	    case IDM_LVCONTEXT_COPY:
    		HrCopyItemDataToClipboard(  hDlg,
			            lpWFP->LDAPsp.lpIAB,
					    GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS));
	        break;

	    case IDM_LVCONTEXT_PROPERTIES:
	    case IDC_FIND_BUTTON_PROPERTIES:
            if(!lpWFP->bLDAPActionInProgress)
            {
	            lpWFP->bLDAPActionInProgress = TRUE;
	            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), FALSE);
	            HrShowLVEntryProperties(GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS), 0,
				            lpWFP->LDAPsp.lpIAB,
				            &ftLast);
	            EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_PROPERTIES), TRUE);
	            lpWFP->bLDAPActionInProgress = FALSE;
            }
            break;

	    case IDM_LVCONTEXT_DELETE:
	    case IDC_FIND_BUTTON_DELETE:
            if(!lpWFP->bLDAPActionInProgress)
            {
                HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
			    DeleteSelectedItems(hWndLVResults,
                                    (LPADRBOOK)lpWFP->LDAPsp.lpIAB,
                                    ((LPIAB)lpWFP->LDAPsp.lpIAB)->lpPropertyStore->hPropertyStore, &ftLast);
                UpdateButtons(  hDlg,
		                hWndLVResults,
		                GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
			            lpWFP->lplu);
                {
                    TCHAR szBuf[MAX_PATH];
                    ULONG nItemCount = ListView_GetItemCount(hWndLVResults);
                    if (nItemCount <= 0)
                    {
                        LoadString(hinstMapiX, idsSearchDialogTitle, szBuf, ARRAYSIZE(szBuf));
                        // also free up the contents list so we dont show the deleted contents again
                        FreeRecipList(&(lpWFP->lpContentsList));
                    }
                    else
                    {
                        TCHAR szBufStr[MAX_PATH - 6];
                        LoadString(hinstMapiX, idsSearchDialogTitleWithResults, szBufStr, ARRAYSIZE(szBufStr));
                        wnsprintf(szBuf, ARRAYSIZE(szBuf), szBufStr, ListView_GetItemCount(hWndLVResults));
                    }
                    SetWindowText(hDlg, szBuf);
                }
                return 0;
            }
            break;

	    case IDM_LVCONTEXT_ADDTOWAB:
	    case IDC_FIND_BUTTON_ADDTOWAB:
            if(!lpWFP->bLDAPActionInProgress)
            {
                HWND hWndLVResults = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
                lpWFP->bLDAPActionInProgress = TRUE;
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), FALSE);
                EnableWindow(hWndLVResults, FALSE); // need to do this to preserve the selection in the list
	            HrAddToWAB( lpWFP->LDAPsp.lpIAB,
		            hWndLVResults,
		            &ftLast);
                EnableWindow(GetDlgItem(hDlg, IDC_FIND_BUTTON_ADDTOWAB), TRUE);
                EnableWindow(hWndLVResults, TRUE);
                SetColumnHeaderBmp(hWndLVResults, lpWFP->SortInfo);
                lpWFP->bLDAPActionInProgress = FALSE;
                SetFocus(hWndLVResults);
            }
            break;

        case IDM_FIND_CONTAINERPROPERTIES:
            if(!lpWFP->lplu)
            {
	            ShowContainerProperties(hDlg,
				            GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
				            lpWFP);
            }
            break;

        case IDM_NOTIFY_REFRESHUSER:
            ReadWABCustomColumnProps((LPIAB)lpWFP->LDAPsp.lpIAB);
            ReadRegistrySortInfo((LPIAB)lpWFP->LDAPsp.lpIAB, &(lpWFP->SortInfo));
        case IDM_FIND_DIRECTORYSERVICES:
	        if(!lpWFP->bLDAPActionInProgress)
	        {
                LPTSTR lpBuf = NULL;
                HWND hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);
                GetSelectedText(hWndCombo, &lpBuf);
                if(lpBuf)
                {
                    if(GET_WM_COMMAND_ID(wParam,lParam) == IDM_FIND_DIRECTORYSERVICES)
                        HrShowDirectoryServiceModificationDlg(hDlg, (LPIAB)lpWFP->LDAPsp.lpIAB);
                    FreeLVItemParam(hWndCombo);
                    PopulateContainerList(  lpWFP->LDAPsp.lpIAB, hWndCombo, lpBuf, NULL);
                    SetEnableDisableUI(hDlg, hWndCombo, lpWFP->lplu, TabCtrl_GetCurSel(GetDlgItem(hDlg, IDC_TAB_FIND)));
                    LocalFree(lpBuf);
                }
            }
	        break;

        case IDC_FIND_BUTTON_TO:
		    {
                if(lpWFP->lpAPFI->DialogState == STATE_SELECT_RECIPIENTS)
                {
	                ULONG ulMapiTo = MAPI_TO;
	                if ((lpWFP->lpAPFI->lpAdrParms->cDestFields > 0) && (lpWFP->lpAPFI->lpAdrParms->lpulDestComps))
	                ulMapiTo = lpWFP->lpAPFI->lpAdrParms->lpulDestComps[0];
	                ListAddItem(    GetParent(hDlg),
			                GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
			                IDC_ADDRBK_LIST_TO,
			                lpWFP->lpAPFI->lppTo,
			                ulMapiTo);
                    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDOK, 0);
                }
                else if(lpWFP->lpAPFI->DialogState == STATE_PICK_USER)
                {
                    // Here we need to do a couple of things:
                    // - if no entry is selected, tell the user to select one
                    // - if an entry is selected, get its entryid and cache it
                    //      and close this dialog
                    HWND hWndLV = GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS);
                    int iItemIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);
                    if (iItemIndex == -1)
	                    ShowMessageBox(hDlg, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
                    else
                    {
                        // Get the entryid of this selected item
                        LPRECIPIENT_INFO lpItem = GetItemFromLV(hWndLV, iItemIndex);
                        if (lpItem)
                        {
                            // remove this item from our linked list of arrays
                            // if this is the first item in the list then handle that special case too
                            lpWFP->lpAPFI->lpEntryID = LocalAlloc(LMEM_ZEROINIT, lpItem->cbEntryID);
                            if(lpWFP->lpAPFI->lpEntryID)
                            {
                                CopyMemory(lpWFP->lpAPFI->lpEntryID, lpItem->lpEntryID, lpItem->cbEntryID);
                                lpWFP->lpAPFI->cbEntryID = lpItem->cbEntryID;
                                SaveFindWindowPos(hDlg, (LPIAB)lpWFP->LDAPsp.lpIAB);
                                FreeLVItemParam(GetDlgItem(hDlg, IDC_FIND_COMBO_LIST));
                                EndDialog(hDlg, SEARCH_USE);
                            }
                        }
                    }
                }
            }
            break;

	    case IDC_FIND_BUTTON_CC:
            {
                ULONG ulMapiTo = MAPI_CC;
                if ((lpWFP->lpAPFI->lpAdrParms->cDestFields > 0) && (lpWFP->lpAPFI->lpAdrParms->lpulDestComps))
	                ulMapiTo = lpWFP->lpAPFI->lpAdrParms->lpulDestComps[1];
                ListAddItem(    GetParent(hDlg),
		                GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
		                IDC_ADDRBK_LIST_CC,
		                lpWFP->lpAPFI->lppCC,
		                ulMapiTo);
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDOK, 0);
            }
            break;

	    case IDC_FIND_BUTTON_BCC:
    		{
                ULONG ulMapiTo = MAPI_BCC;
                if ((lpWFP->lpAPFI->lpAdrParms->cDestFields > 0) && (lpWFP->lpAPFI->lpAdrParms->lpulDestComps))
	                ulMapiTo = lpWFP->lpAPFI->lpAdrParms->lpulDestComps[2];
                ListAddItem(    GetParent(hDlg),
		                GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
		                IDC_ADDRBK_LIST_BCC,
		                lpWFP->lpAPFI->lppBCC,
		                ulMapiTo);
                SendMessage (hDlg, WM_COMMAND, (WPARAM) IDOK, 0);
		    }
		    break;

	    case IDC_FIND_BUTTON_SERVER_INFO:
		    {
			    LDAPSERVERPARAMS lsp = {0};
			    ULONG iItemIndex;
                LPTSTR lpBuf = NULL;
			    HWND hWndCombo = GetDlgItem(hDlg, IDC_FIND_COMBO_LIST);
			    HINSTANCE hInst;

			    // Does it have a URL registered?
			    // Get the LDAP server properties for the selected container

                GetSelectedText(hWndCombo, &lpBuf);

                if(lpBuf)
                {
	                GetLDAPServerParams(lpBuf, &lsp);
                    if (lsp.lpszURL && lstrlen(lsp.lpszURL) && bIsHttpPrefix(lsp.lpszURL)) 
	                {
		                // Yes, there is a URL, shell execute it to bring up the browser.
		                HCURSOR hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
		                hInst = ShellExecute(GetParent(hDlg),  TEXT("open"), lsp.lpszURL, NULL, NULL, SW_SHOWNORMAL);
		                SetCursor(hOldCur);
                    }
                    FreeLDAPServerParams(lsp);
                    LocalFree(lpBuf);
                }
		    }
		    break;
	    }
	    break;

    case WM_SIZE:
	    ResizeFindDialog(hDlg, wParam, lParam, lpWFP);
	    return 0;
	    break;

    case WM_CLOSE:
	    //treat it like a cancel button
	    SendMessage (hDlg, WM_COMMAND, (WPARAM) IDCANCEL, 0);
	    break;

    case WM_HELP:
	    WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
			    g_szWABHelpFileName,
			    HELP_WM_HELP,
			    (DWORD_PTR)(LPSTR) rgSrchHelpIDs );
	    break;

	case WM_CONTEXTMENU:
		if ((HWND)wParam == GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS))
		{
			ShowLVContextMenu(  lvDialogFind,
				GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
				GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
				lParam,
				NULL,
				lpWFP->LDAPsp.lpIAB, NULL);
		}
        else if ((HWND)wParam == GetDlgItem(hDlg, IDC_FIND_COMBO_LIST) && (!lpWFP->lplu))
		{
            ShowContainerContextMenu(   hDlg,
                                    GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
                                    lParam);
		}
	    else
	    {
            WABWinHelp((HWND) wParam,
	            g_szWABHelpFileName,
	            HELP_CONTEXTMENU,
	            (DWORD_PTR)(LPVOID) rgSrchHelpIDs );
	    }
		break;

		break;

    case WM_VKEYTOITEM:
        if( VK_DELETE == LOWORD(wParam) &&
	        SendMessage((HWND) lParam, LB_GETCOUNT, 0, 0) > 0) // Delete pressed
        {
	        SendMessage(hDlg, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_REMOVECONDITION, 0);
	        return -2; // means we handled the keystroke completely
        }
        else
	        return DefWindowProc(hDlg, message, wParam, lParam);
        break;

    case WM_NOTIFY:
        switch((int) wParam)
        {
        case IDC_TAB_FIND:
	        if(((NMHDR FAR *)lParam)->code == TCN_SELCHANGE)
	        {
                int nTab = TabCtrl_GetCurSel(((NMHDR FAR *)lParam)->hwndFrom);
                SetEnableDisableUI( hDlg, 
		                GetDlgItem(hDlg, IDC_FIND_COMBO_LIST), 
		                lpWFP->lplu,
		                nTab);
                if(nTab == tabSimple)
                    SetFocus(GetDlgItem(hDlg, IDC_FIND_EDIT_NAME));
                else
                    SetFocus(GetDlgItem(hDlg, IDC_FIND_EDIT_ADVANCED));
	        }
	        break;

        case IDC_FIND_LIST_RESULTS:
        #ifdef WIN16 // Context menu handler for WIN16
	        if(((NMHDR FAR *)lParam)->code == NM_RCLICK)
	        {
	            POINT pt;

	            GetCursorPos(&pt);
	            ShowLVContextMenu( lvDialogFind,
			               GetDlgItem(hDlg, IDC_FIND_LIST_RESULTS),
			               GetDlgItem(hDlg, IDC_FIND_COMBO_LIST),
			               MAKELPARAM(pt.x, pt.y),
			               NULL,
			               lpWFP->LDAPsp.lpIAB, NULL);
	        }
        #endif
	        return ProcessLVResultsMessages(hDlg,message,wParam,lParam, lpWFP);
	        break;
        }
        break;
    }
    return TRUE;
}

/**********
//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ProcessLVMessages - Processes messages for the Container list view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessLVMessages(HWND   hWnd, UINT   uMsg, UINT   wParam, LPARAM lParam)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
	HWND hWndLV = pNm->hdr.hwndFrom;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    switch(pNm->hdr.code)
	{

    case NM_DBLCLK:
	    SendMessage (hWnd, WM_COMMAND, (WPARAM) IDM_FIND_CONTAINERPROPERTIES, 0);
	    break;

    case LVN_ITEMCHANGED:
    case NM_SETFOCUS:
    case NM_CLICK:
    case NM_RCLICK:
	    SetEnableDisableUI(hWnd, hWndLV);
		break;

    case NM_CUSTOMDRAW:
	{
		    NMCUSTOMDRAW *pnmcd=(NMCUSTOMDRAW*)lParam;
	    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
	    NMLVCUSTOMDRAW * pnmlvcd = (NMLVCUSTOMDRAW * )lParam;

		    if(pnmcd->dwDrawStage==CDDS_PREPAINT)
		    {
		SetWindowLong(hWnd, DWL_MSGRESULT, CDRF_NOTIFYITEMDRAW | CDRF_DODEFAULT);
			    return TRUE;
		    }
		    else if(pnmcd->dwDrawStage==CDDS_ITEMPREPAINT)
	    {
		LPSERVERDAT lpSD = (LPSERVERDAT) pnmcd->lItemlParam;

		if(lpSD != 0 &&
		   (WAB_PAB != IsWABEntryID(lpSD->SB.cb, 
					    (LPENTRYID) lpSD->SB.lpb, 
					    NULL, NULL, NULL)) &&
		   lpSD->himl)
		{
		    HDC hdcLV = pnmlvcd->nmcd.hdc;
		    RECT rcLVItem;
		    UINT fType = ILD_NORMAL;

		    ListView_GetItemRect(hWndLV, pnmcd->dwItemSpec, &rcLVItem, LVIR_BOUNDS);
		    if (ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED) == (int) pnmcd->dwItemSpec)
		    {
			FillRect(hdcLV, &rcLVItem, (HBRUSH) (COLOR_HIGHLIGHT+1));
			//fType |= ILD_BLEND25;
			DrawFocusRect(hdcLV, &rcLVItem);
		    }
		    else
			FillRect(hdcLV, &rcLVItem, (HBRUSH) (COLOR_WINDOW+1));

		    if(!gpfnImageList_Draw( lpSD->himl, 
					0, 
					hdcLV, 
					rcLVItem.left + L_BITMAP_WIDTH + 1, //gives enough space to paint the icon
					rcLVItem.top, 
					fType))
		    {
			DebugPrintError(( TEXT("ImageList_Draw failed\n")));
		    }

		    if (ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED) == (int) pnmcd->dwItemSpec)
			fType |= ILD_BLEND25;

		    {
			HIMAGELIST himlLV = ListView_GetImageList(hWndLV,LVSIL_SMALL);
			gpfnImageList_Draw(himlLV, imageDirectoryServer, hdcLV, rcLVItem.left + 1, rcLVItem.top, fType);
		    }
		    SetWindowLong(hWnd, DWL_MSGRESULT, CDRF_SKIPDEFAULT);
				    return TRUE;
		}
		    }
	    SetWindowLong(hWnd, DWL_MSGRESULT, CDRF_DODEFAULT);
	    return TRUE;
	}
	break;

    }

	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}
/********/

//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ProcessLVResultsMessages - Processes messages for the Search Results list view control
//
//////////////////////////////////////////////////////////////////////////////////////////
LRESULT ProcessLVResultsMessages(HWND   hWnd,
				 UINT   uMsg,
				 WPARAM   wParam,
				 LPARAM lParam,
				 LPWAB_FIND_PARAMS lpWFP)
{

    NM_LISTVIEW * pNm = (NM_LISTVIEW *)lParam;
	HWND hWndLV = pNm->hdr.hwndFrom;

	// Bug 17027: GPF due to null lpWFP
	if(lpWFP)
	{
		if(lpWFP->bLDAPActionInProgress)
			return 0;
	}

    switch(pNm->hdr.code)
	{
    case LVN_COLUMNCLICK:
		if(lpWFP)
	        SortListViewColumn((LPIAB)lpWFP->LDAPsp.lpIAB, hWndLV, pNm->iSubItem, &(lpWFP->SortInfo), FALSE);
    	break;


	case LVN_KEYDOWN:
        switch(((LV_KEYDOWN FAR *) lParam)->wVKey)
        {
        case VK_DELETE:
            if(CurrentContainerIsPAB(GetDlgItem(hWnd, IDC_FIND_COMBO_LIST)) != IS_LDAP)
                SendMessage (hWnd, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_DELETE, 0);
            return 0;
            break;
        case VK_RETURN:
	        SendMessage (hWnd, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_PROPERTIES, 0);
	        return 0;
        }
        break;


    case NM_DBLCLK:
        SendMessage (hWnd, WM_COMMAND, (WPARAM) IDC_FIND_BUTTON_PROPERTIES, 0);
        return 0;
        break;

	case NM_CUSTOMDRAW:
        return ProcessLVCustomDraw(hWnd, lParam, TRUE);
        break;
	}
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}


//$$////////////////////////////////////////////////////////////////////////////
//
// SaveFindWindowPos - saves the find window position and size
//
////////////////////////////////////////////////////////////////////////////////
void SaveFindWindowPos(HWND hWnd, LPIAB lpIAB)
{
    ABOOK_POSCOLSIZE  ABPosColSize = {0};
    WINDOWPLACEMENT wpl = {0};

    wpl.length = sizeof(WINDOWPLACEMENT);

    // This call tells us the window state and normal size and position
    GetWindowPlacement(hWnd, &wpl);

	// There seems to be a bug in GetWindowPlacement that
	// doesnt account for various taskbars on the screen when
	// returning the Window's Normal Position .. as a result
	// the stored coordinates won't be accurate. Instead, we'll
	// use those coordinates only if the window is maximized or
	// minimized - otherwise we will use the GetWindowRect
	// coordinates.

    // Get the screen position of this window
    GetWindowRect(hWnd, &(ABPosColSize.rcPos));

    if(wpl.showCmd != SW_SHOWNORMAL)
    {
        ABPosColSize.rcPos = wpl.rcNormalPosition;
    }

    ABPosColSize.nTab = TabCtrl_GetCurSel(GetDlgItem(hWnd, IDC_TAB_FIND));

    WriteRegistryPositionInfo(lpIAB, &ABPosColSize,lpszRegFindPositionKeyValueName);

    // Also save the last used server name in the registry for the next
    // session
    {
        LPTSTR lpBuf = NULL;
        GetSelectedText(GetDlgItem(hWnd, IDC_FIND_COMBO_LIST), &lpBuf);
        if(lpBuf)
        {
            HKEY hKeyRoot = (lpIAB && lpIAB->hKeyCurrentUser) ? lpIAB->hKeyCurrentUser : HKEY_CURRENT_USER;
	        RegSetValue(hKeyRoot, szKeyLastFindServer, REG_SZ, lpBuf,  lstrlen(lpBuf));
	        LocalFree(lpBuf);
        }
    }

    return;
}


/*************************************************************************
//$$
//  HrInitServerListLV - Initializes the list view that displays the list
//          of servers ...
//
//  hWndLV - handle of list view
//
**************************************************************************/
/****
HRESULT HrInitServerListLV(HWND hWndLV)
{
	HRESULT hr = hrSuccess;
    LV_COLUMN lvC;               // list view column structure
	HIMAGELIST hSmall=NULL;

	DWORD dwLVStyle;
	ULONG nCols=0;
	ULONG index=0;

	if (!hWndLV)
	{
		hr = MAPI_E_INVALID_PARAMETER;
		goto out;
	}

    ListView_SetExtendedListViewStyle(hWndLV, LVS_EX_FULLROWSELECT);

	dwLVStyle = GetWindowLong(hWndLV,GWL_STYLE);
    if(dwLVStyle & LVS_EDITLABELS)
	SetWindowLong(hWndLV,GWL_STYLE,(dwLVStyle & ~LVS_EDITLABELS));

    hSmall = gpfnImageList_LoadImage(   hinstMapiX,     
				    MAKEINTRESOURCE(IDB_BITMAP_LARGE),
				    L_BITMAP_WIDTH,
				    0,
				    RGB_TRANSPARENT,
				    IMAGE_BITMAP,       
				    0);

	ListView_SetImageList (hWndLV, hSmall, LVSIL_SMALL);

	lvC.mask = LVCF_FMT | LVCF_WIDTH;
    lvC.fmt = LVCFMT_LEFT;   // left-align column

    {
	RECT rc;
	GetWindowRect(hWndLV, &rc);
	lvC.cx = rc.right - rc.left - L_BITMAP_WIDTH - 10;
    }
	lvC.pszText = NULL;

    lvC.iSubItem = 0;

    if (ListView_InsertColumn (hWndLV, 0, &lvC) == -1)
	{
		DebugPrintError(( TEXT("ListView_InsertColumn Failed\n")));
		hr = E_FAIL;
		goto out;
	}


out:    

	return hr;
}
/***/


//$$
//*------------------------------------------------------------------------
//| FreeLVItemParam: Frees the LPSBinary structure associated with each element
//|                     of the list view containing a container list
//|
//| hWndLV - Handle of List View whose data we are freeing
//|
//*------------------------------------------------------------------------
void FreeLVItemParam(HWND hWndCombo)//hWndLV)
{
    int i = 0;
    int nCount;

    if(!hWndCombo)
	return;

    nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    
    // Each Combo item has a entryid associated with it which we need to free up
    for(i=0;i<nCount;i++)
    {
        LPSERVERDAT lpSD = NULL;

        lpSD = (LPSERVERDAT) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) i, 0);

        if(lpSD != NULL)
        {
	        if(lpSD->himl)
	        gpfnImageList_Destroy(lpSD->himl);
	        LocalFreeAndNull((LPVOID *) (&(lpSD->SB.lpb)));
	        LocalFreeAndNull(&lpSD);
        }
    }
    SendMessage(hWndCombo, CB_RESETCONTENT, 0, 0);

    return;
}


//$$
//*------------------------------------------------------------------------
//| PopulateContainerList: Enumerates potential container names and fills
//| combo ...
//|
//| lpIAB       - AdrBook Object
//| hWndCombo   - Handle of Combo we are populating
//| lpszSelection - NULL or some value - if exists, this value is set as the
//|                 combo selection otherwise the local store is the default
//|                 selection
//| lptszPreferredSelection - NULL or some value - if exists then set as the
//|                           combo selection, otherwise the above 
//|                           lpszSelection or local store is the default.
//|
//*------------------------------------------------------------------------
HRESULT PopulateContainerList(
    LPADRBOOK lpAdrBook,
    HWND hWndCombo,
    LPTSTR lpszSelection,
    LPTSTR lptszPreferredSelection)
{
    LPPTGDATA   lpPTGData=GetThreadStoragePointer();
    HRESULT     hr = hrSuccess;
    ULONG       ulObjectType = 0;
    LPROOT      lpRoot = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    LPSRowSet   lpSRowSet = NULL;
    ULONG       i=0,j=0;
    TCHAR       szPref[MAX_PATH];
    int         nPos = 0;
    int         nStart = 1; // pos we start sorting at ... always after the  TEXT("WAB") item
    BOOL        bAddedPref = FALSE;
    LPIAB       lpIAB = (LPIAB)lpAdrBook;
    BOOL        bFoundSelection = FALSE;
    BOOL        bFoundPreferredSelection = FALSE;

    if( !lpAdrBook ||
    	!hWndCombo)
    {
        hr = MAPI_E_INVALID_PARAMETER;
        DebugPrintError(( TEXT("Invalid Params\n")));
        goto out;
    }

    // if running against outlook, there can be more than 1 contact folder and
    // we need to push them all to the top of the list .. so we will really start 
    // adding generic stuff after the colkci position
    //
    if (pt_bIsWABOpenExSession) 
    {
        nStart = lpIAB->lpPropertyStore->colkci;
    }

    *szPref = '\0';
    LoadString(hinstMapiX, idsPreferedPartnerCode, szPref, ARRAYSIZE(szPref));

    hr = lpAdrBook->lpVtbl->OpenEntry( lpAdrBook,
				    0,
				    NULL,       
				    NULL,       
				    0,  
				    &ulObjectType,      
				    (LPUNKNOWN *) &lpRoot );

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("OpenEntry Failed: %x\n"),hr));
        goto out;
    }

    // if this is a profile aware session, only put the All Contacts item in the drop down list
    // unless it's an outlook session in which case don't do anything
    {
        ULONG ulFlags = MAPI_UNICODE;
        if(bIsWABSessionProfileAware(lpIAB))
            ulFlags |= WAB_NO_PROFILE_CONTAINERS;

        hr = lpRoot->lpVtbl->GetContentsTable( lpRoot,
					        ulFlags,
					        &lpContentsTable);
    }

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("GetContentsTable Failed: %x\n"),hr));
        goto out;
    }

    hr = HrQueryAllRows(lpContentsTable,
			NULL, NULL, NULL, 0,
			&lpSRowSet);

    if (HR_FAILED(hr))
    {
        DebugPrintError(( TEXT("HrQueryAllRows Failed: %x\n"),hr));
        goto out;
    }

    for(i=0;i<lpSRowSet->cRows;i++)
    {
        LPTSTR lpszDisplayName = NULL;
        LPSERVERDAT lpSD = LocalAlloc(LMEM_ZEROINIT, sizeof(SERVERDAT));

        if(!lpSD)
        {
	        DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
	        goto out;
        }
        lpSD->himl = NULL;

        for(j=0;j<lpSRowSet->aRow[i].cValues;j++)
        {
            LPSPropValue lpPropArray = lpSRowSet->aRow[i].lpProps;

            switch(lpPropArray[j].ulPropTag)
            {
            case PR_DISPLAY_NAME:
                lpszDisplayName = lpPropArray[j].Value.LPSZ;
                break;
            case PR_ENTRYID:
                lpSD->SB.cb = lpPropArray[j].Value.bin.cb;
                if(lpSD->SB.cb > 0)
                {
                    lpSD->SB.lpb = LocalAlloc(LMEM_ZEROINIT, lpSD->SB.cb);
                    if(!lpSD->SB.lpb)
                    {
                    DebugPrintError(( TEXT("LocalAlloc failed to allocate memory\n")));
                    goto out;
                    }
                    CopyMemory(lpSD->SB.lpb, lpPropArray[j].Value.bin.lpb,lpSD->SB.cb);
                }
                break;
            }
        }

        nPos = ComboAddItem( hWndCombo, 
			        lpszDisplayName,
			        (LPARAM) lpSD,
			        szPref,
			        &nStart, &bAddedPref);

        if(!bFoundPreferredSelection && lpszSelection && !lstrcmpi(lpszDisplayName, lpszSelection))
        {
            bFoundSelection = TRUE;
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM)nPos, 0);
            SetWindowText(hWndCombo, lpszSelection);
        }

        if (lptszPreferredSelection && !lstrcmpi(lpszDisplayName, lptszPreferredSelection))
        {
            bFoundPreferredSelection = TRUE;
            SendMessage(hWndCombo, CB_SETCURSEL, (WPARAM)nPos, 0);
            SetWindowText(hWndCombo, lptszPreferredSelection);
        }
    }

out:

    if (!bFoundSelection && !bFoundPreferredSelection)
	    SendMessage(hWndCombo, CB_SETCURSEL, 0, 0);

    if (lpSRowSet)
        FreeProws(lpSRowSet);

    if(lpContentsTable)
        lpContentsTable->lpVtbl->Release(lpContentsTable);

    if(lpRoot)
        lpRoot->lpVtbl->Release(lpRoot);

    return hr;
}


//$$/////////////////////////////////////////////////////////////////////////////////
//
// CurrentContainerIsPAB - Returns TRUE if the current viewed container is the PAB
//
//  hWndLV - List Containing the list of containers.
//
////////////////////////////////////////////////////////////////////////////////////////
int CurrentContainerIsPAB(HWND hWndCombo)
{
    HRESULT hr = hrSuccess;
    ULONG cbContainerEID = 0;
    LPENTRYID lpContainerEID = NULL;
    BYTE bType = 0;

    GetCurrentContainerEID(hWndCombo, 
			  &cbContainerEID,
			  &lpContainerEID);

    //
    // Check if this entryid is a Local WAB store
    //
    if(!cbContainerEID && !lpContainerEID)
        return IS_PAB;

    bType = IsWABEntryID(cbContainerEID, lpContainerEID, NULL, NULL, NULL, NULL, NULL);

    if(bType == WAB_LDAP_CONTAINER)
        return IS_LDAP;

    if(bType == WAB_PAB || bType == WAB_PABSHARED)
        return IS_PAB;

    // for now we'll figure anything else is a Outlook container
    return IS_OLK;
}

//$$
/******************************************************************************
//
// HrSearchAndGetLDAPContents - Gets and fills the current list view with contents from
//                      an LDAP server.
//
// hWndCombo    - Handle to  TEXT("ShowNames") combo (in case we need to update it
// hWndList     - Handle to List View which we will populate
// lpIAB        - Handle to Address Bok object
// SortInfo     - Current Sort State
// lppContentsList - linked list in which we will store info about entries
// lpAdvFilter - an advanced search filter that is used for advanced searches
//
/******************************************************************************/
HRESULT HrSearchAndGetLDAPContents( LDAP_SEARCH_PARAMS LDAPsp,
				    LPTSTR lpAdvFilter,
				    HWND hWndCombo, 
				    LPADRBOOK lpAdrBook,
				    SORT_INFO SortInfo,
				    LPRECIPIENT_INFO * lppContentsList)
{
    LPPTGDATA   lpPTGData=GetThreadStoragePointer();
    HRESULT hr = hrSuccess;
    SCODE sc = ERROR_SUCCESS;
    ULONG cbContainerEID = 0;
    LPENTRYID lpContainerEID = NULL;
    TCHAR szBuf[MAX_UI_STR];

    ULONG ulCurSel = 0;
    SRestriction SRes = {0};
    LPSRestriction lpPropRes = NULL;
    ULONG ulcPropCount = 0;
    ULONG i = 0;
    HCURSOR hOldCursor = NULL;
    BOOL bKeepSearching = TRUE;

    //while(bKeepSearching)
    {
        hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        //
        // Then we get the container entry id for thie container
        //
        GetCurrentContainerEID( hWndCombo, 
			        &cbContainerEID,
			        &lpContainerEID);

        //
        // Now we have the search dialog data .. we need to create a restriction from it which
        // we can use with the LDAP contents table..
        //
        if(!lpAdvFilter)
        {
	        if(HR_FAILED(HrGetLDAPSearchRestriction(LDAPsp, &SRes)))
	        goto out;
	        lpPropRes = SRes.res.resAnd.lpRes;
        }

        hr = HrGetLDAPContentsList(
			        lpAdrBook,
			        cbContainerEID,
			        lpContainerEID,
			        SortInfo,
			        &SRes,
			        lpAdvFilter,
			        NULL,
			        0,
			        lppContentsList);

        if((HR_FAILED(hr)) && (MAPI_E_USER_CANCEL != hr))
        {
	        int ids;
	        UINT flags = MB_OK | MB_ICONEXCLAMATION;

	        switch(hr)
	        {
	        case MAPI_E_UNABLE_TO_COMPLETE:
                ids = idsLDAPSearchTimeExceeded;
                break;
	        case MAPI_E_AMBIGUOUS_RECIP:
                ids = idsLDAPAmbiguousRecip;
                break;
	        case MAPI_E_NOT_FOUND:
                ids = idsLDAPSearchNoResults;
                break;
	        case MAPI_E_NO_ACCESS:
                ids = idsLDAPAccessDenied;
                break;
	        case MAPI_E_TIMEOUT:
                ids = idsLDAPSearchTimedOut;
                break;
	        case MAPI_E_NETWORK_ERROR:
                ids = idsLDAPCouldNotFindServer;
                break;
	        default:
                ids = idsLDAPErrorOccured;
                DebugPrintError(( TEXT("HrGetLDAPContentsList failed:%x\n"),hr));
                break;
	        }
	        ShowMessageBox( GetParent(hWndCombo),ids, flags);
	        goto out;
        }
        else
        {
	        if(hr == MAPI_W_PARTIAL_COMPLETION)
	        ShowMessageBox( GetParent(hWndCombo),
			        idsLDAPPartialResults, MB_OK | MB_ICONINFORMATION);
        }
    } // while(bKeepSearching)

out:

    if(lpPropRes)
        MAPIFreeBuffer(lpPropRes);

    if(hOldCursor)
        SetCursor(hOldCursor);

    return(hr);
}

//$$
//*------------------------------------------------------------------------
//| GetCurrentContainerEID: Gets EntryID of Current Container - takes a handle
//|                 to a populated combo, gets the current selection, and then
//|                 gets the ItemData (EntryID) for that current selection.
//|
//| hWndLV   - Handle of a ListView containing the container list
//| lpcbContEID,lppContEID - returned Container Entry ID
//|
//| **NOTE** lpContEID is not allocated - its just a pointer and should not be freed
//|
//*------------------------------------------------------------------------
void GetCurrentContainerEID(HWND hWndCombo, //hWndLV,
			    LPULONG lpcbContEID,
			    LPENTRYID * lppContEID)
{
    LPSERVERDAT lpSD = NULL;
    int iItemIndex = 0;

    if(!lpcbContEID || !lppContEID)
        goto out;

    *lpcbContEID = 0;
    *lppContEID = NULL;

    iItemIndex = (int) SendMessage(hWndCombo, CB_GETCURSEL, 0, 0);

    if(iItemIndex == CB_ERR)
        goto out;

    lpSD = (LPSERVERDAT) SendMessage(hWndCombo, CB_GETITEMDATA, (WPARAM) iItemIndex, 0);

    if(!lpSD)
        goto out;

    *lpcbContEID = lpSD->SB.cb;
    *lppContEID = (LPENTRYID) lpSD->SB.lpb;

out:
    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////
//
// ComboAddItem Generic function for adding items to list view
//
// hWndLV   -   HWND of List View
// lpszItemText - ItemText
// lParam - LPARAM (can be NULL)
// lpnStart - position at which to start adding generic servers .. in the case where there
//      is more than one server at the top of the list
//
////////////////////////////////////////////////////////////////////////////////////////////
int ComboAddItem( HWND hWndCombo, //hWndLV,
		     LPTSTR lpszItemText,
		     LPARAM lParam,
		     LPTSTR szPref,
		     int * lpnStart, BOOL * lpbAddedPref)
{
    LPTSTR lp = NULL;
    int nPos = 0, nStart = 1;
    int nCount = (int) SendMessage(hWndCombo, CB_GETCOUNT, 0, 0);
    LDAPSERVERPARAMS Params = {0};

    if(lpnStart && *lpnStart)
        nStart = *lpnStart;

    GetLDAPServerParams(lpszItemText, &Params);

    
    if( Params.dwIsNTDS == LDAP_NTDS_IS) // NTDS accounts need to come upfront after the Address Book
    {
        // if the prefered accounts have already been added at nStart .. only add the NT accounts at
        // nStart - 1
        nPos = (int) SendMessage(hWndCombo, CB_INSERTSTRING, 
                        (WPARAM) ((lpbAddedPref && *lpbAddedPref == TRUE) ? nStart - 1 : nStart), 
                        (LPARAM) lpszItemText); 
        if(lpnStart)
	        (*lpnStart)++;
    }
    else
    if( ( szPref && lstrlen(szPref) &&  lpszItemText && lstrlen(lpszItemText) && SubstringSearch(lpszItemText, szPref)) )
    {
        nPos = (int) SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) nStart, (LPARAM) lpszItemText); // Prefered partner goes in after contact folders at top of the list
        if(lpnStart)
	        (*lpnStart)++;
        if(lpbAddedPref)
            *lpbAddedPref = TRUE;
    }
    else
    {
        // Once we add the pref server, we only need to compare from after that item 
        if(nCount >= nStart)
        {
	        // need to start adding alphabetically
	        // We cant set this list to a sorted state because we always want the Address Book first
	        // and then the prefered partner second
	        int i,nLen;

	        for(i=nStart; i< nCount; i++)
	        {
                // get the current string in the combo
                nLen = (int) SendMessage(hWndCombo, CB_GETLBTEXTLEN, (WPARAM) i, 0);
                if (nLen && (CB_ERR != nLen))
                {
                    if(lp)
                    {
                        LocalFree(lp);
                        lp = NULL;
                    }
                    lp = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(nLen+1));
                    if(lp)
                    {
                        SendMessage(hWndCombo, CB_GETLBTEXT, (WPARAM) i, (LPARAM)lp);
                        if(lstrlen(lp) && lstrcmpi(lp, lpszItemText) >= 0)
                        {
	                        nPos = i;
	                        break;
                        }
    		        }
	            }
	        }
        }
        if(nPos)
        {
	        // we have a valid position to add the string to
	        nPos = (int) SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) nPos, (LPARAM) lpszItemText); // Prefered partner goes in after Address book at top of the list
        }
        else
        {
	        // just tag it to the end
	        nPos = (int) SendMessage(hWndCombo, CB_ADDSTRING, 0, (LPARAM) lpszItemText);
        }
    }

    SendMessage(hWndCombo, CB_SETITEMDATA, (WPARAM) nPos, lParam);

    if(lp)
        LocalFree(lp);

    FreeLDAPServerParams(Params);

    return nPos;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\valcopy.c ===
/*
 *	VALCOPY.C
 *
 *	Utility functions for validating, copying, and (yeech) relocating
 *	complex MAPI structures.
 *
 *	For each data type there are three functions:
 *		ScCountXXX address-checks and calculates the size
 *		ScCopyXXX copies to a contiguous block of memory, which
 *			must be pre-allocated
 *		ScRelocXXX adjusts pointers, assuming that a structure in a
 *			contiguous block of memory has been moved
 *
 *	Data types supported:
 *		NOTIFICATION (and array of), in ScCountNotifications etc.
 *		SPropValue (and array of), in ScCountProps etc.
 *
 *	//$ SIZE Returning the byte count from ScRelocXXX may not be necessary.
 */

#include <_apipch.h>



#if defined (_AMD64_) || defined (_IA64_)
#define AlignProp(_cb)	Align8(_cb)
#else
#define AlignProp(_cb)	(_cb)
#endif

#define ALIGN_RISC		8
#define ALIGN_X86		1


//	Pointer manipulation macros for use in the Reloc functions
#ifdef WIN16
#define SEG(_fp)	HIWORD((DWORD)_fp)
#define OFF(_fp)	LOWORD((DWORD)_fp)

#define PvRelocPv(_p,_baseOld,_baseNew) \
	((LPVOID)MAKELONG(OFF(_p) - OFF(_baseOld) + OFF(_baseNew), SEG(_baseNew)))
#else
#define PvRelocPv(_p,_baseOld,_baseNew)	\
	((LPVOID)((LPBYTE)(_p) - (LPBYTE)(_baseOld) + (LPBYTE)(_baseNew)))
#endif


#ifdef NOTIFICATIONS    // save this for notifications
STDAPI_(SCODE)
ScCountNotifications(int cntf, LPNOTIFICATION rgntf, ULONG FAR *pcb)
{
	ULONG			cb;
	ULONG			cbT;
	LPNOTIFICATION	pntf;
	SCODE			sc = S_OK;

	// validate parameters

	AssertSz(!cntf || !IsBadReadPtr(rgntf, sizeof(NOTIFICATION) * cntf),
			 TEXT("rgntf fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
		 TEXT("pcb fails address check"));

	for (cb = 0, pntf = rgntf; cntf--; ++pntf)
	{
		if (IsBadReadPtr(pntf, sizeof(NOTIFICATION)))
		{
			DebugTraceArg(ScCountNotification,  TEXT("pntf fails address check"));
			goto badNotif;
		}
		cb += sizeof(NOTIFICATION);

		switch (HIWORD(pntf->ulEventType))
		{
		case (fnevExtended >> 16):
//		case (fnevSpooler >> 16):
			//	fnevSpooler and fnevExtended both use the EXTENDED_NOTIFICATION
			//	structure for their parameters
			if (pntf->info.ext.cb &&
				IsBadReadPtr(pntf->info.ext.pbEventParameters, (UINT)pntf->info.ext.cb))
			{
				DebugTraceArg(ScCountNotification,  TEXT("ext.pbEventParameters fails address check"));
				goto badNotif;
			}
			cb += AlignProp(pntf->info.ext.cb);
			break;

		case 0:
		{
			switch (LOWORD(pntf->ulEventType))
			{
			case (USHORT)fnevCriticalError:
			{
				ERROR_NOTIFICATION FAR *perr = &pntf->info.err;

				if ( IsBadReadPtr( perr->lpEntryID, (UINT)perr->cbEntryID ) )
				{
					DebugTraceArg( ScCountNotification,  TEXT("lpEntryID fails address check") );
					goto badNotif;
				}

				cb += AlignProp(((UINT)perr->cbEntryID));

				if (perr->lpMAPIError)
				{
					cb += AlignProp(sizeof( MAPIERROR ));

#if defined(_WINNT) && !defined(MAC)
					if (perr->ulFlags & MAPI_UNICODE)
					{
						//$	No error check in WIN16
						if (IsBadStringPtrW((LPWSTR)perr->lpMAPIError->lpszError, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszError (UNICODE) fails address check"));
							goto badNotif;
						}

						cb += AlignProp(((lstrlenW((LPWSTR)perr->lpMAPIError->lpszError) + 1)
							* sizeof(WCHAR)));

						if ( perr->lpMAPIError->lpszComponent )
						{
							if (IsBadStringPtrW((LPWSTR)perr->lpMAPIError->lpszComponent, INFINITE))
							{
								DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszComponent (UNICODE) fails address check"));
								goto badNotif;
							}

							cb += AlignProp(((lstrlenW((LPWSTR)perr->lpMAPIError->lpszComponent) + 1)
								* sizeof(WCHAR)));

						}
					}
					else
#endif
					{
						if (IsBadStringPtrA((LPSTR)perr->lpMAPIError->lpszError, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszError (ASCII) fails address check"));
							goto badNotif;
						}

						cb += AlignProp((lstrlenA((LPSTR)perr->lpMAPIError->lpszError) + 1));

						if ( perr->lpMAPIError->lpszComponent )
						{
							if (IsBadStringPtrA((LPSTR)perr->lpMAPIError->lpszComponent, INFINITE))
							{
								DebugTraceArg(ScCountNotification,  TEXT("err.MapiError.lpszError (ASCII) fails address check"));
								goto badNotif;
							}

							cb += AlignProp((lstrlenA((LPSTR)perr->lpMAPIError->lpszComponent) + 1));
						}
					}
				}
				break;
			}

			case (USHORT)fnevNewMail:
			{
				NEWMAIL_NOTIFICATION FAR *pnew = &pntf->info.newmail;

				if (IsBadReadPtr(pnew->lpEntryID, (UINT)pnew->cbEntryID))
				{
					DebugTraceArg(ScCountNotification,  TEXT("lpEntryID fails address check"));
					goto badNotif;
				}
				cb += AlignProp(((UINT)pnew->cbEntryID));
				if (IsBadReadPtr(pnew->lpParentID, (UINT)pnew->cbParentID))
				{
					DebugTraceArg(ScCountNotification,  TEXT("lpParentID fails address check"));
					goto badNotif;
				}
				cb += AlignProp(((UINT)pnew->cbParentID));
				if (pnew->lpszMessageClass)
				{
					if (pnew->ulFlags & MAPI_UNICODE)
					{
#if defined(_WINNT) && !defined(MAC)
						//$	No error check in WIN16
						if (IsBadStringPtrW((LPWSTR)pnew->lpszMessageClass, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("newmail.lpszMessageClass (UNICODE) fails address check"));
							goto badNotif;
						}
#endif
						cb += AlignProp(((lstrlenW((LPWSTR)pnew->lpszMessageClass) + 1)
							* sizeof(WCHAR)));
					}
					else
					{
						if (IsBadStringPtrA((LPSTR)pnew->lpszMessageClass, INFINITE))
						{
							DebugTraceArg(ScCountNotification,  TEXT("newmail.lpszMessageClass (ASCII) fails address check"));
							goto badNotif;
						}
						cb += AlignProp((lstrlenA((LPSTR)pnew->lpszMessageClass) + 1));
					}
				}

				break;
			}

			case (USHORT)fnevObjectCreated:
			case (USHORT)fnevObjectDeleted:
			case (USHORT)fnevObjectModified:
			case (USHORT)fnevObjectMoved:
			case (USHORT)fnevObjectCopied:
			case (USHORT)fnevSearchComplete:
			{
				OBJECT_NOTIFICATION FAR *pobj = &pntf->info.obj;

				if (pobj->cbEntryID)
				{
					if (IsBadReadPtr(pobj->lpEntryID, (UINT)pobj->cbEntryID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpEntryID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbEntryID);
				}
				if (pobj->cbParentID)
				{
					if (IsBadReadPtr(pobj->lpParentID, (UINT)pobj->cbParentID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpParentID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbParentID);
				}
				if (pobj->cbOldID)
				{
					if (IsBadReadPtr(pobj->lpOldID, (UINT)pobj->cbOldID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpOldID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbOldID);
				}
				if (pobj->cbOldParentID)
				{
					if (IsBadReadPtr(pobj->lpOldParentID, (UINT)pobj->cbOldParentID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpOldParentID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pobj->cbOldParentID);
				}
				if (pobj->lpPropTagArray)
				{
					if (IsBadReadPtr(pobj->lpPropTagArray, sizeof(ULONG)) ||
						IsBadReadPtr(pobj->lpPropTagArray,
							offsetof(SPropTagArray, aulPropTag) +
								(UINT)pobj->lpPropTagArray->cValues * sizeof(ULONG)))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("obj.lpPropTagArray fails address check"));
						goto badNotif;
					}
					cb += AlignProp(offsetof(SPropTagArray, aulPropTag) +
						pobj->lpPropTagArray->cValues * sizeof(ULONG));
				}
				break;
			}

			case (USHORT)fnevTableModified:
			{
				TABLE_NOTIFICATION FAR *ptn = &pntf->info.tab;
				UINT	n = (UINT) ptn->ulTableEvent;

				if (n != TABLE_CHANGED &&
					n != TABLE_RELOAD &&
					n != TABLE_ERROR &&
					n != TABLE_ROW_ADDED &&
					n != TABLE_ROW_DELETED &&
					n != TABLE_ROW_MODIFIED &&
					n != TABLE_SORT_DONE &&
					n != TABLE_RESTRICT_DONE &&
					n != TABLE_SETCOL_DONE)
				{
					DebugTraceArg(ScCountNotifications,  TEXT("invalid tab.ulTableEvent"));
					goto badNotif;
				}

				if (ptn->propIndex.ulPropTag)
				{
					if (sc = ScCountProps(1, &ptn->propIndex, &cbT))
						goto ret;
					cb += cbT;
				}
				if (ptn->propPrior.ulPropTag)
				{
					if (sc = ScCountProps(1, &ptn->propPrior, &cbT))
						goto ret;
					cb += cbT;
				}
				if (ptn->row.cValues)
				{
					if (sc = ScCountProps((int)ptn->row.cValues, ptn->row.lpProps,
							&cbT))
						goto ret;
					cb += cbT;
				}
				else if (ptn->row.lpProps)
				{
					DebugTraceArg(ScCountNotifications,  TEXT("non-NULL row.lpProps with zero row.cValues in table notification"));
					goto badNotif;
				}
				break;
			}

			case (USHORT)fnevStatusObjectModified:
			{
				STATUS_OBJECT_NOTIFICATION FAR *pstat = &pntf->info.statobj;

				if (pstat->cbEntryID)
				{
					if (IsBadReadPtr(pstat->lpEntryID, (UINT)pstat->cbEntryID))
					{
						DebugTraceArg(ScCountNotifications,  TEXT("statobj.lpEntryID fails address check"));
						goto badNotif;
					}
					cb += AlignProp(pstat->cbEntryID);
				}
				if (pstat->cValues)
				{
					if (sc = ScCountProps((int)pstat->cValues,
							pstat->lpPropVals, &cbT))
						goto ret;
					cb += cbT;
				}
				break;
			}

			default:
				DebugTraceArg(ScCountNotification,  TEXT("invalid ulEventType"));
				goto badNotif;
			}
			break;
		}
		default:
			DebugTraceArg(ScCountNotification,  TEXT("invalid ulEventType"));
			goto badNotif;
		}
	}

	if (pcb)
		*pcb = cb;

ret:
	DebugTraceSc(ScCountNotifications, sc);
	return sc;

badNotif:
	//	trace already issued
	return E_INVALIDARG;
}

STDAPI_(SCODE)
ScCopyNotifications(int cntf, LPNOTIFICATION rgntf, LPVOID pvDst,
	ULONG FAR *pcb)
{
	LPBYTE			pb = pvDst;
	ULONG			cb = 0;
	ULONG			cbT;
	LPNOTIFICATION	pntf;
	LPNOTIFICATION	pntfDst;
	SCODE			sc = S_OK;

	// validate parameters

	AssertSz(!cntf || !IsBadReadPtr(rgntf, sizeof(NOTIFICATION) * cntf),
			 TEXT("rgntf fails address check"));

	AssertSz(!cntf || !IsBadWritePtr(pvDst, sizeof(NOTIFICATION) * cntf),
			 TEXT("pvDst fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	cb = cntf * sizeof(NOTIFICATION);
	MemCopy(pvDst, rgntf, (UINT)cb);
	pb = (LPBYTE)pvDst + cb;

	for (pntf = rgntf, pntfDst = (LPNOTIFICATION)pvDst;
		cntf--;
			++pntf, ++pntfDst)
	{
		switch (HIWORD(pntf->ulEventType))
		{
		case (fnevExtended >> 16):
//     case (fnevSpooler >> 16):
			if (pntf->info.ext.cb)
			{
				pntfDst->info.ext.pbEventParameters = pb;
				cbT = pntf->info.ext.cb;
				MemCopy(pb, pntf->info.ext.pbEventParameters, (UINT)cbT);
				pb += AlignProp(cbT);
				cb += AlignProp(cbT);
			}
			break;

		case 0:
		{
			switch (LOWORD(pntf->ulEventType))
			{
			case (USHORT)fnevCriticalError:
			{
				ERROR_NOTIFICATION FAR *perr = &pntf->info.err;

				if ( perr->cbEntryID )
				{
					pntfDst->info.err.lpEntryID = (LPENTRYID)pb;
					cbT = perr->cbEntryID;
					MemCopy(pb, perr->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}


				if ( perr->lpMAPIError )
				{
					pntfDst->info.err.lpMAPIError = (LPMAPIERROR)pb;
					cbT = sizeof(MAPIERROR);
					MemCopy( pb, perr->lpMAPIError, sizeof( MAPIERROR ) );
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);

					if (perr->lpMAPIError->lpszError)
					{
#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
						{
							cbT = (lstrlenW((LPWSTR)perr->lpMAPIError->lpszError)
									+ 1) * sizeof(WCHAR);
						}
						else
#endif
						{
							cbT = lstrlenA((LPSTR)perr->lpMAPIError->lpszError) + 1;

						}

						pntfDst->info.err.lpMAPIError->lpszError = (LPSTR)pb;
						MemCopy(pb, perr->lpMAPIError->lpszError, (UINT)cbT);
						pb += AlignProp(cbT);
						cb += AlignProp(cbT);
					}

					if (perr->lpMAPIError->lpszComponent)
					{
#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
						{
							cbT = (lstrlenW((LPWSTR)perr->lpMAPIError->lpszComponent)
									+ 1) * sizeof(WCHAR);
						}
						else
#endif
						{
							cbT = lstrlenA((LPSTR)perr->lpMAPIError->lpszComponent) + 1;

						}

						pntfDst->info.err.lpMAPIError->lpszComponent = pb;
						MemCopy(pb, perr->lpMAPIError->lpszComponent, (UINT)cbT);
						pb += AlignProp(cbT);
						cb += AlignProp(cbT);
					}
				}

				break;
			}

			case (USHORT)fnevNewMail:
			{
				NEWMAIL_NOTIFICATION FAR *pnew = &pntf->info.newmail;

				if (pnew->cbEntryID)
				{
					pntfDst->info.newmail.lpEntryID = (LPENTRYID)pb;
					cbT = pnew->cbEntryID;
					MemCopy(pb, pnew->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (pnew->cbParentID)
				{
					pntfDst->info.newmail.lpParentID = (LPENTRYID)pb;
					cbT = pnew->cbParentID;
					MemCopy(pb, pnew->lpParentID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (pnew->lpszMessageClass)
				{
					if (pnew->ulFlags & MAPI_UNICODE)
						cbT = (lstrlenW((LPWSTR)pnew->lpszMessageClass) + 1)
							* sizeof(WCHAR);
					else
						cbT = lstrlenA((LPSTR)pnew->lpszMessageClass) + 1;
					pntfDst->info.newmail.lpszMessageClass = (LPTSTR)pb;
					MemCopy(pb, pnew->lpszMessageClass, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevObjectCreated:
			case (USHORT)fnevObjectDeleted:
			case (USHORT)fnevObjectModified:
			case (USHORT)fnevObjectMoved:
			case (USHORT)fnevObjectCopied:
			case (USHORT)fnevSearchComplete:
			{
				OBJECT_NOTIFICATION FAR *pobj = &pntf->info.obj;

				if (pobj->cbEntryID)
				{
					pntfDst->info.obj.lpEntryID = (LPENTRYID)pb;
					cbT = pobj->cbEntryID;
					MemCopy(pb, pobj->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->cbParentID)
				{
					pntfDst->info.obj.lpParentID = (LPENTRYID)pb;
					cbT = pobj->cbParentID;
					MemCopy(pb, pobj->lpParentID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->cbOldID)
				{
					pntfDst->info.obj.lpOldID = (LPENTRYID)pb;
					cbT = pobj->cbOldID;
					MemCopy(pb, pobj->lpOldID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->cbOldParentID)
				{
					pntfDst->info.obj.lpOldParentID = (LPENTRYID)pb;
					cbT = pobj->cbOldParentID;
					MemCopy(pb, pobj->lpOldParentID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pobj->lpPropTagArray)
				{
					cbT = offsetof(SPropTagArray, aulPropTag) +
						pobj->lpPropTagArray->cValues * sizeof(ULONG);
					pntfDst->info.obj.lpPropTagArray = (LPSPropTagArray)pb;
					MemCopy(pb, pobj->lpPropTagArray, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevTableModified:
			{
				TABLE_NOTIFICATION FAR *ptn = &pntf->info.tab;

				if (ptn->propIndex.ulPropTag)
				{
					//	Wastes 16 bytes when the property doesn't have a tail
					if (sc = ScCopyProps(1, &ptn->propIndex, pb, &cbT))
						goto ret;
                    //
                    //  This was once a straight structure assignment.  However, on RISC platforms
                    //  if pntfDst is not on an 8-byte boundary, this raises a Datatype
                    //  Misalignment Exception.  Changed this to a memcpy in order to not worry
                    //  about alignment and not cause any extra exception handling.
                    //
					memcpy(&(pntfDst->info.tab.propIndex), (LPSPropValue)pb, sizeof(SPropValue));
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (ptn->propPrior.ulPropTag)
				{
					//	Wastes 16 bytes when the property doesn't have a tail
					if (sc = ScCopyProps(1, &ptn->propPrior, pb, &cbT))
						goto ret;
                    //
                    //  This was once a straight structure assignment.  However, on RISC platforms
                    //  if pntfDst is not on an 8-byte boundary, this raises a Datatype
                    //  Misalignment Exception.  Changed this to a memcpy in order to not worry
                    //  about alignment and not cause any extra exception handling.
                    //
					memcpy(&(pntfDst->info.tab.propPrior), (LPSPropValue)pb, sizeof(SPropValue));
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}

				if (ptn->row.cValues)
				{
					pntfDst->info.tab.row.lpProps = (LPSPropValue)pb;
					if (sc = ScCopyProps((int)ptn->row.cValues, ptn->row.lpProps, pb, &cbT))
						goto ret;
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevStatusObjectModified:
			{
				STATUS_OBJECT_NOTIFICATION FAR *pstat = &pntf->info.statobj;

				if (pstat->cbEntryID)
				{
					pntfDst->info.statobj.lpEntryID = (LPENTRYID)pb;
					cbT = pstat->cbEntryID;
					MemCopy(pb, pstat->lpEntryID, (UINT)cbT);
					pb += AlignProp(cbT);
					cb += AlignProp(cbT);
				}
				if (pstat->cValues)
				{
					pntfDst->info.statobj.lpPropVals = (LPSPropValue)pb;
					if (sc = ScCopyProps((int)pstat->cValues,
							pstat->lpPropVals, pb, &cbT))
						goto ret;
					pb += cbT;
					cb += cbT;
				}
				break;
			}

			default:
				DebugTraceArg(ScCopyNotification,  TEXT("invalid ulEventType"));
				goto badNotif;
			}
			break;
		}
		default:
			DebugTraceArg(ScCopyNotification,  TEXT("invalid ulEventType"));
			goto badNotif;
		}
	}

	if (pcb)
		*pcb = (ULONG)cb;

ret:
	DebugTraceSc(ScCopyNotifications, sc);
	return sc;

badNotif:
	//	trace already issued
	return E_INVALIDARG;

#undef COPY
}

STDAPI_(SCODE)
ScRelocNotifications(int cntf, LPNOTIFICATION rgntf, LPVOID pvBaseOld,
	LPVOID pvBaseNew, ULONG FAR *pcb)
{
	ULONG			cb;
	ULONG			cbT;
	LPNOTIFICATION	pntf;
	SCODE			sc = S_OK;

	AssertSz(!cntf || !IsBadReadPtr(rgntf, sizeof(NOTIFICATION) * cntf),
			 TEXT("rgntf fails address check"));

	AssertSz(pvBaseOld,  TEXT("pvBaseOld fails address check"));

	AssertSz(!IsBadWritePtr(pvBaseNew, sizeof(LPVOID)),
			 TEXT("pvBaseNew fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	cb = cntf * sizeof(NOTIFICATION);
	for (pntf = rgntf; cntf--; ++pntf)
	{
		switch (HIWORD(pntf->ulEventType))
		{
		case (fnevExtended >> 16):
 //      case (fnevSpooler >> 16):
			if (pntf->info.ext.cb)
			{
				pntf->info.ext.pbEventParameters =
					PvRelocPv(pntf->info.ext.pbEventParameters, pvBaseOld,
						pvBaseNew);
				cb += AlignProp(pntf->info.ext.cb);
			}
			break;

		case 0:
		{
			switch (LOWORD(pntf->ulEventType))
			{
			case (USHORT)fnevCriticalError:
			{
				ERROR_NOTIFICATION FAR *perr 	= &pntf->info.err;

				if ( perr->lpEntryID )
				{
					perr->lpEntryID = PvRelocPv( perr->lpEntryID, pvBaseOld,
							pvBaseNew );
					cb += AlignProp( (UINT)perr->cbEntryID );
				}

				if ( perr->lpMAPIError )
				{
					perr->lpMAPIError = PvRelocPv( perr->lpMAPIError, pvBaseOld,
							pvBaseNew );

					if (perr->lpMAPIError->lpszError)
					{
						perr->lpMAPIError->lpszError = PvRelocPv(
								perr->lpMAPIError->lpszError, pvBaseOld,
								pvBaseNew );

#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
							cb += AlignProp((lstrlenW((LPWSTR)perr->lpMAPIError->lpszError)
									+ 1) * sizeof(WCHAR));
						else
#endif
							cb += AlignProp(lstrlenA((LPSTR)perr->lpMAPIError->lpszError) + 1);
					}

					if (perr->lpMAPIError->lpszComponent)
					{
						perr->lpMAPIError->lpszComponent = PvRelocPv(
								perr->lpMAPIError->lpszComponent, pvBaseOld,
								pvBaseNew );
#ifdef _WINNT
						if (perr->ulFlags & MAPI_UNICODE)
							cb += AlignProp((lstrlenW((LPWSTR)perr->lpMAPIError->lpszComponent) + 1)
								* sizeof(WCHAR));
						else
#endif
							cb += AlignProp(lstrlenA((LPSTR)perr->lpMAPIError->lpszComponent) + 1);
					}
				}
			}

			case (USHORT)fnevNewMail:
			{
				NEWMAIL_NOTIFICATION FAR *pnew = &pntf->info.newmail;

				if (pnew->lpEntryID)
				{
					pnew->lpEntryID = PvRelocPv(pnew->lpEntryID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp((UINT)pnew->cbEntryID);
				}

				if (pnew->lpParentID)
				{
					pnew->lpParentID = PvRelocPv(pnew->lpParentID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp((UINT)pnew->cbParentID);
				}

				if (pnew->lpszMessageClass)
				{
					pnew->lpszMessageClass = PvRelocPv(pnew->lpszMessageClass,
						pvBaseOld, pvBaseNew);
					if (pnew->ulFlags & MAPI_UNICODE)
						cbT = (lstrlenW((LPWSTR)pnew->lpszMessageClass) + 1)
							* sizeof(WCHAR);
					else
						cbT = lstrlenA((LPSTR)pnew->lpszMessageClass) + 1;
					cb += AlignProp(cbT);
				}
				break;
			}

			case (USHORT)fnevObjectCreated:
			case (USHORT)fnevObjectDeleted:
			case (USHORT)fnevObjectModified:
			case (USHORT)fnevObjectMoved:
			case (USHORT)fnevObjectCopied:
			case (USHORT)fnevSearchComplete:
			{
				OBJECT_NOTIFICATION FAR *pobj = &pntf->info.obj;

				if (pobj->lpEntryID)
				{
					pobj->lpEntryID = PvRelocPv(pobj->lpEntryID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbEntryID);
				}
				if (pobj->lpParentID)
				{
					pobj->lpParentID = PvRelocPv(pobj->lpParentID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbParentID);
				}
				if (pobj->lpOldID)
				{
					pobj->lpOldID = PvRelocPv(pobj->lpOldID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbOldID);
				}
				if (pobj->lpOldParentID)
				{
					pobj->lpOldParentID = PvRelocPv(pobj->lpOldParentID, pvBaseOld,
						pvBaseNew);
					cb += AlignProp(pobj->cbOldParentID);
				}
				if (pobj->lpPropTagArray)
				{
					pobj->lpPropTagArray = PvRelocPv(pobj->lpPropTagArray,
						pvBaseOld, pvBaseNew);
					cb += offsetof(SPropTagArray, aulPropTag) +
						pobj->lpPropTagArray->cValues * sizeof(ULONG);
				}
				break;
			}

			case (USHORT)fnevTableModified:
			{
				TABLE_NOTIFICATION FAR *ptn = &pntf->info.tab;

				Assert (FIsAligned (&ptn->propIndex));
				if (ptn->propIndex.ulPropTag)
				{
					if (sc = ScRelocProps(1, &ptn->propIndex, pvBaseOld,
							pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				Assert (FIsAligned (&ptn->propPrior));
				if (ptn->propPrior.ulPropTag)
				{
					if (sc = ScRelocProps(1, &ptn->propPrior, pvBaseOld,
							pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				if (ptn->row.cValues)
				{
					Assert (FIsAligned (ptn->row.lpProps));
					ptn->row.lpProps = PvRelocPv(ptn->row.lpProps,
						pvBaseOld, pvBaseNew);
					if (sc = ScRelocProps((int)ptn->row.cValues, ptn->row.lpProps,
							pvBaseOld, pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				break;
			}

			case (USHORT)fnevStatusObjectModified:
			{
				STATUS_OBJECT_NOTIFICATION FAR *pstat = &pntf->info.statobj;

				if (pstat->lpEntryID)
				{
					pstat->lpEntryID = PvRelocPv(pstat->lpEntryID, pvBaseOld,
						pvBaseNew);

					//	Whoa, this is not sufficient to buffer the size of
					//	the entryid.  If the entryid is not aligned, then the
					//	the properties that follow will not be aligned either.
					//
					Assert (FIsAligned (pstat->lpEntryID));
					cb += AlignProp(pstat->cbEntryID);
				}
				if (pstat->cValues)
				{
					pstat->lpPropVals = PvRelocPv(pstat->lpPropVals,
						pvBaseOld, pvBaseNew);
					Assert (FIsAligned (pstat->lpPropVals));
					if (sc = ScRelocProps((int)pstat->cValues, pstat->lpPropVals,
							pvBaseOld, pvBaseNew, &cbT))
						goto ret;
					cb += cbT;
				}
				break;
			}

			default:
				DebugTraceArg(ScRelocNotification,  TEXT("invalid ulEventType"));
				goto badNotif;
			}
			break;
		}
		default:
			DebugTraceArg(ScRelocNotification,  TEXT("invalid ulEventType"));
			goto badNotif;
		}
	}

	if (pcb)
		*pcb = cb;

ret:
	DebugTraceSc(ScRelocNotifications, sc);
	return sc;

badNotif:
	//	trace already issued
	return E_INVALIDARG;
}
#endif // NOTIFICATIONS

STDAPI_(LPSPropValue)
LpValFindProp( ULONG ulPropTag, ULONG cprop, LPSPropValue rgprop)
{
	//	Mutate the property tag to a property ID
	ulPropTag = PROP_ID(ulPropTag);

	while (cprop--)
	{
		Assert( !IsBadReadPtr( rgprop, sizeof(SPropValue)));

		if (PROP_ID(rgprop->ulPropTag) == ulPropTag)
		{
			return rgprop;
		}

		rgprop++;
	}

	// No match was found so return NULL.
	return NULL;
}

/*
 * 	ScCountPropsEx()
 *
 * 	Internal routine that computes the size required
 * 	to hold a given propval array based on specified alignment
 */

SCODE
ScCountPropsEx(int cprop, LPSPropValue rgprop, ULONG ulAlign, ULONG FAR *pcb)
{
	LPSPropValue	pprop;
	ULONG			cb = 0;
	ULONG			cbMV;
	int				iValue;

#define Align(_cb)	((ULONG)( ((DWORD_PTR) ((_cb) + (ulAlign-1))) & ~(((DWORD_PTR) ulAlign-1))))

	// validate parameters

	AssertSz(ulAlign && ulAlign <= ALIGN_RISC,
			 TEXT("invalid alignment value"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	//$ SIZE Some of the multi-valued cases could be collapsed if we don't
	//$	mind assuming that the counts and pointers are in the same place.

	if (   (rgprop && !cprop)
		|| IsBadReadPtr(rgprop, cprop*sizeof(SPropValue)))
	{
		DebugTraceArg(ScCountProps,  TEXT("rgprop fails address check"));
		return MAPI_E_INVALID_PARAMETER;
	}

	for (pprop = rgprop; cprop--; ++pprop)
	{
		ULONG	ulID = PROP_ID(pprop->ulPropTag);
		ULONG	ulType = PROP_TYPE(pprop->ulPropTag);

		//	Check for valid PROP_ID
		if (   (ulID == PROP_ID_INVALID)
			|| ((ulType == PT_NULL) && (ulID != PROP_ID_NULL))
			|| ((ulID == PROP_ID_NULL) && (ulType != PT_NULL) && (ulType != PT_ERROR)))
			return MAPI_E_INVALID_PARAMETER;

		//	Check for valid PROP_TYPE and count memory consumed
		cb += sizeof(SPropValue);
		switch ( PROP_TYPE(pprop->ulPropTag) )
		{
			case PT_UNSPECIFIED:
			default:
				DebugTrace( TEXT("ScCountProps: Unknown property type %s (index %d)\n"), SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
				return MAPI_E_INVALID_PARAMETER;

			case PT_I2:
			case PT_LONG:
			case PT_R4:
			case PT_APPTIME:
			case PT_DOUBLE:
			case PT_BOOLEAN:
			case PT_CURRENCY:
			case PT_SYSTIME:
			case PT_I8:
			case PT_ERROR:
			case PT_OBJECT:
			case PT_NULL:
				break;

			case PT_CLSID:
				if (IsBadReadPtr(pprop->Value.lpguid, sizeof(GUID)))
					goto badProp;
				cb += Align(sizeof(GUID));
				break;

			case PT_BINARY:
				//$Hack:  IsBadReadPtr works funny under Win16.
				//$Hack:  It doesn't handle the case of 0 cb, and
				//$Hack:  non-0 lpb.
				if (pprop->Value.bin.cb && IsBadReadPtr( pprop->Value.bin.lpb
								, (UINT) (pprop->Value.bin.cb)))
					goto badProp;

				cb += Align(pprop->Value.bin.cb);
				break;

			case PT_STRING8:
				if (IsBadStringPtrA(pprop->Value.lpszA, INFINITE))
					goto badProp;
				cb += Align((lstrlenA( pprop->Value.lpszA ) + 1) * sizeof(CHAR));

				break;

			case PT_UNICODE:
#if defined(WIN32) && !defined(MAC)
				//$	No validation code available on Win16
				if (IsBadStringPtrW(pprop->Value.lpszW, INFINITE))
					goto badProp;
#endif
				cb += Align((lstrlenW( pprop->Value.lpszW ) + 1) * sizeof(WCHAR));
				break;


            //	Note!	MVxxx.cValues may NOT be zero (DCR 2789).

			case PT_MV_I2:
				if (   !(cbMV = pprop->Value.MVi.cValues * sizeof(short int))
					|| IsBadReadPtr(pprop->Value.MVi.lpi, (UINT) cbMV))
					goto badProp;
				cb += Align(cbMV);
				break;

			case PT_MV_LONG:
				if (   !(cbMV = pprop->Value.MVl.cValues * sizeof(LONG))
					|| IsBadReadPtr(pprop->Value.MVl.lpl, (UINT) cbMV))
					goto badProp;
				cb += Align(cbMV);
				break;

			case PT_MV_R4:
				if (   !(cbMV = pprop->Value.MVflt.cValues * sizeof(float))
					|| IsBadReadPtr(pprop->Value.MVflt.lpflt, (UINT) cbMV))
					goto badProp;
				cb += Align(cbMV);
				break;

			case PT_MV_APPTIME:
				if (   !(cbMV = pprop->Value.MVat.cValues * sizeof(double))
					|| IsBadReadPtr(pprop->Value.MVat.lpat, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_DOUBLE:
				if (   !(cbMV = pprop->Value.MVdbl.cValues * sizeof(double))
					|| IsBadReadPtr(pprop->Value.MVdbl.lpdbl, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_CURRENCY:
				if (   !(cbMV = pprop->Value.MVcur.cValues * sizeof(CURRENCY))
					|| IsBadReadPtr(pprop->Value.MVcur.lpcur, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_SYSTIME:
				if (   !(cbMV = pprop->Value.MVft.cValues * sizeof(FILETIME))
					|| IsBadReadPtr(pprop->Value.MVft.lpft, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_CLSID:
				if (   !(cbMV = pprop->Value.MVguid.cValues * sizeof(GUID))
					|| IsBadReadPtr(pprop->Value.MVguid.lpguid, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;

			case PT_MV_I8:
				if (   !(cbMV = pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER))
					|| IsBadReadPtr(pprop->Value.MVli.lpli, (UINT) cbMV))
					goto badProp;
				cb += cbMV;
				break;


			case PT_MV_BINARY:
				if (   !(cbMV = pprop->Value.MVbin.cValues * sizeof(SBinary))
					|| IsBadReadPtr(pprop->Value.MVbin.lpbin, (UINT) cbMV))
					goto badProp;

				Assert(Align(cbMV) == cbMV);
				cb += cbMV;

				for ( iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVbin.cValues;
					  	iValue++ )
				{
					if (IsBadReadPtr(pprop->Value.MVbin.lpbin[iValue].lpb,
							(UINT)pprop->Value.MVbin.lpbin[iValue].cb))
						goto badProp;
					cb += Align(pprop->Value.MVbin.lpbin[iValue].cb);
				}

				break;

			case PT_MV_STRING8:
				if (   !(cbMV = pprop->Value.MVszA.cValues * sizeof(LPVOID))
					|| IsBadReadPtr(pprop->Value.MVszA.lppszA, (UINT) cbMV))
					goto badProp;

				cb += cbMV;

				for ( iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszA.cValues;
					  	iValue++ )
				{
					if (IsBadStringPtrA(pprop->Value.MVszA.lppszA[iValue],
										INFINITE))
						goto badProp;
					cb += lstrlenA(pprop->Value.MVszA.lppszA[iValue]) + 1;
				}

				cb = Align(cb);

				break;

			case PT_MV_UNICODE:
				if (   !(cbMV = pprop->Value.MVszW.cValues * sizeof(LPVOID))
					|| IsBadReadPtr(pprop->Value.MVszW.lppszW, (UINT) cbMV))
					goto badProp;

				cb += cbMV;

				for ( iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszW.cValues;
					  	iValue++ )
				{
#if defined(WIN32) && !defined(MAC)
					//$	No validation on Win16
					if (IsBadStringPtrW(pprop->Value.MVszW.lppszW[iValue], INFINITE))
						goto badProp;
#endif
					cb += (lstrlenW(pprop->Value.MVszW.lppszW[iValue]) + 1)
						  * sizeof(WCHAR);
				}

				cb = Align(cb);

				break;
		}
	}

	if (pcb)
	{
		Assert(!IsBadWritePtr(pcb, sizeof(ULONG)));
		*pcb = cb;
	}
	return S_OK;

badProp:
	DebugTrace( TEXT("ScCountProps: Unreadable property %s (index %d)\n"), SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
	return MAPI_E_INVALID_PARAMETER;

#undef Align
}

STDAPI_(SCODE)
ScCountProps(int cprop, LPSPropValue rgprop, ULONG FAR *pcb)
{
#if defined (_AMD64_) || defined(_IA64_)
	return ScCountPropsEx( cprop, rgprop, ALIGN_RISC, pcb );
#else
	return ScCountPropsEx( cprop, rgprop, ALIGN_X86, pcb );
#endif
}

STDAPI_(SCODE)
ScCopyProps(int cprop, LPSPropValue rgprop, LPVOID pvDst, ULONG FAR *pcb)
{
	LPSPropValue	pprop;
	LPSPropValue	ppropDst;
	ULONG			cb;
	ULONG			cbMV;
	LPBYTE			pb;
	UINT			cbT;
	int				iValue;

	// validate parameters

	AssertSz(!cprop || !IsBadReadPtr(rgprop, sizeof(SPropValue) * cprop),
			 TEXT("rgprop fails address check"));

	AssertSz(!cprop || !IsBadWritePtr(pvDst, sizeof(SPropValue) * cprop),
			 TEXT("pvDst fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	//$ SIZE Some of the multi-valued cases could be collapsed if we don't
	//$	mind assuming that the counts and pointers are in the same place.

	cb = cprop * sizeof(SPropValue);
	MemCopy(pvDst, rgprop, (UINT)cb);
	pb = (LPBYTE)pvDst + cb;

	for (pprop = rgprop, ppropDst = pvDst; cprop--; ++pprop, ++ppropDst)
	{
		//	Tricky: common code after the switch increments pb and cb
		//	by the amount copied. If no increment is necessary, the case
		//	uses 'continue' rather than 'break' to exit the switch, thus
		//	skipping the increment -- AND any other code which may be
		//	added after the switch.

		switch ( PROP_TYPE(pprop->ulPropTag) )
		{
			default:
				DebugTrace( TEXT("ScCopyProps: Unknown property type %s (index %d)\n"), SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
				return E_INVALIDARG;

			case PT_I2:
			case PT_LONG:
			case PT_R4:
			case PT_APPTIME:
			case PT_DOUBLE:
			case PT_BOOLEAN:
			case PT_CURRENCY:
			case PT_SYSTIME:
			case PT_I8:
			case PT_ERROR:
			case PT_OBJECT:
			case PT_NULL:
				continue;	//	nothing to add

			case PT_CLSID:
				ppropDst->Value.lpguid = (LPGUID) pb;
				cbT = sizeof(GUID);
				MemCopy(pb, (LPBYTE) pprop->Value.lpguid, cbT);
				break;

			case PT_BINARY:
				ppropDst->Value.bin.lpb = pb;
				cbT = (UINT)pprop->Value.bin.cb;
				MemCopy(pb, pprop->Value.bin.lpb, cbT);
				break;

			case PT_STRING8:
				ppropDst->Value.lpszA = (LPSTR)pb;
				cbT = lstrlenA( pprop->Value.lpszA ) + 1;
				MemCopy(pb, pprop->Value.lpszA, cbT);
				break;

			case PT_UNICODE:
				ppropDst->Value.lpszW = (LPWSTR)pb;
				cbT = (lstrlenW( pprop->Value.lpszW ) + 1) * sizeof(WCHAR);
				MemCopy(pb, pprop->Value.lpszW, cbT);
				break;

			case PT_MV_I2:
				ppropDst->Value.MVi.lpi = (short int FAR *)pb;
				cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
				MemCopy(pb, pprop->Value.MVi.lpi, cbT);
				break;

			case PT_MV_LONG:
				ppropDst->Value.MVl.lpl = (LONG FAR *)pb;
				cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
				MemCopy(pb, pprop->Value.MVl.lpl, cbT);
				break;

			case PT_MV_R4:
				ppropDst->Value.MVflt.lpflt = (float FAR *)pb;
				cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
				MemCopy(pb, pprop->Value.MVflt.lpflt, cbT);
				break;

			case PT_MV_APPTIME:
				ppropDst->Value.MVat.lpat = (double FAR *)pb;
				cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
				MemCopy(pb, pprop->Value.MVat.lpat, cbT);
				break;

			case PT_MV_DOUBLE:
				ppropDst->Value.MVdbl.lpdbl = (double FAR *)pb;
				cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
				MemCopy(pb, pprop->Value.MVdbl.lpdbl, cbT);
				break;

			case PT_MV_CURRENCY:
				ppropDst->Value.MVcur.lpcur = (CURRENCY FAR *)pb;
				cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
				MemCopy(pb, pprop->Value.MVcur.lpcur, cbT);
				break;

			case PT_MV_SYSTIME:
				ppropDst->Value.MVft.lpft = (FILETIME FAR *)pb;
				cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
				MemCopy(pb, pprop->Value.MVft.lpft, cbT);
				break;

			case PT_MV_CLSID:
				ppropDst->Value.MVguid.lpguid = (GUID FAR *)pb;
				cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
				MemCopy(pb, pprop->Value.MVguid.lpguid, cbT);
				break;

			case PT_MV_I8:
				ppropDst->Value.MVli.lpli = (LARGE_INTEGER FAR *)pb;
				cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
				MemCopy(pb, pprop->Value.MVli.lpli, cbT);
				break;

			case PT_MV_BINARY:
				ppropDst->Value.MVbin.lpbin = (SBinary *) pb;
				cbMV = pprop->Value.MVbin.cValues * sizeof(SBinary);
				pb += cbMV;
				cb += cbMV;
				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVbin.cValues;
					  	iValue++)
				{
					ppropDst->Value.MVbin.lpbin[iValue].lpb = pb;
					cbT = (UINT)pprop->Value.MVbin.lpbin[iValue].cb;
					ppropDst->Value.MVbin.lpbin[iValue].cb = (ULONG)cbT;
					MemCopy(pb, pprop->Value.MVbin.lpbin[iValue].lpb, cbT);
					cbT = AlignProp(cbT);
					cb += cbT;
					pb += cbT;
				}
				continue;	//	already updated, don't do it again

			case PT_MV_STRING8:
				ppropDst->Value.MVszA.lppszA = (LPSTR *) pb;
				cbMV = pprop->Value.MVszA.cValues * sizeof(LPSTR);
				pb += cbMV;
				cb += cbMV;
				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszA.cValues;
					  	iValue++)
				{
					ppropDst->Value.MVszA.lppszA[iValue] = (LPSTR)pb;
					cbT = lstrlenA(pprop->Value.MVszA.lppszA[iValue]) + 1;
					MemCopy(pb, pprop->Value.MVszA.lppszA[iValue], cbT);
					pb += cbT;
					cb += cbT;
				}
				cbT = (UINT)AlignProp(cb);
				pb += cbT - cb;
				cb  = cbT;
				continue;	//	already updated, don't do it again

			case PT_MV_UNICODE:
				ppropDst->Value.MVszW.lppszW = (LPWSTR *) pb;
				cbMV = pprop->Value.MVszW.cValues * sizeof(LPWSTR);
				pb += cbMV;
				cb += cbMV;
				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszW.cValues;
					  	iValue++)
				{
					ppropDst->Value.MVszW.lppszW[iValue] = (LPWSTR)pb;
					cbT = (lstrlenW(pprop->Value.MVszW.lppszW[iValue]) + 1)
						* sizeof(WCHAR);
					MemCopy(pb, pprop->Value.MVszW.lppszW[iValue], cbT);
					pb += cbT;
					cb += cbT;
				}
				cbT = (UINT)AlignProp(cb);
				pb += cbT - cb;
				cb  = cbT;
				continue;	//	already updated, don't do it again
		}

		//	Advance pointer and total count by the amount copied
		cbT = AlignProp(cbT);
		pb += cbT;
		cb += cbT;
	}

	if (pcb)
	{
		Assert(!IsBadWritePtr(pcb, sizeof(ULONG)));
		*pcb = cb;
	}
	return S_OK;
}

#ifdef NOTIFICATIONS
STDAPI_(SCODE)
ScRelocProps(	int cprop,
				LPSPropValue rgprop,
				LPVOID pvBaseOld,
				LPVOID pvBaseNew,
				ULONG FAR *pcb)
{
	LPSPropValue	pprop;
	ULONG			cb;
	UINT			cbT;
	LPVOID			pvT;
	int				iValue;
	BOOL			fBaseNewValid = !IsBadReadPtr (pvBaseNew, sizeof (LPVOID));

	// validate parameters

	AssertSz(!cprop || !IsBadWritePtr(rgprop, sizeof(SPropValue) * cprop),
			 TEXT("rgprop fails address check"));

	AssertSz(!pcb || !IsBadWritePtr(pcb, sizeof(ULONG)),
			 TEXT("pcb fails address check"));

	// The old behavior of this code assumed that pvBaseNew was a usable
	// pointer and that there would be no relocation to or from an unusable
	// pointer. We've changed this so that you may relocate to or from an
	// unusable pointer -- but logic to figure out whether to use the
	// original or new pointer to fixup internal pointers was added.
	// What we mean by this is that things like strlens and mv prop arrays
	// need to be computed based on where the data ** CURRENTLY ** lives.
	// The old rules allowed us to assume that the NEW location was always
	// the right place. The new rules make us figure it out based on the
	// validity of the two pointers pvBaseNew/Old, that are passed in.
	//
	// In order to preserve the old behavior, we try to use the new pointer
	// (the one that was always used before) as the basis for internal
	// pointer fixup. If it is bad (for example if we are relocating from
	// something to zero), we will use the old pointer.
	//
	// A new wrinkle in the behavior of this code is a return of
	// MAPI_E_INVALID_PARAMETER if both addresses appear invalid. This is
	// to help protect this code for the mv or strlen case (though all
	// other cases would have worked OK).

	if (!fBaseNewValid && IsBadReadPtr (pvBaseOld, sizeof (LPVOID)))
	{
		DebugTrace ( TEXT("pvBaseOld and pvBaseNew failed address check"));
		DebugTraceSc (ScRelocProps, MAPI_E_INVALID_PARAMETER);
		return MAPI_E_INVALID_PARAMETER;
	}

	//$ SIZE Some of the multi-valued cases could be collapsed if we don't
	//$	mind assuming that the counts and pointers are in the same place.

	cb = cprop * sizeof(SPropValue);

	for (pprop = rgprop; cprop--; ++pprop)
	{
		//	Tricky: common code after the switch increments cb.
		//	If no increment is necessary, the case
		//	uses 'continue' rather than 'break' to exit the switch, thus
		//	skipping the increment -- AND any other code which may be
		//	added after the switch.

		switch ( PROP_TYPE(pprop->ulPropTag) )
		{
			default:
				DebugTrace(	 TEXT("ScRelocProps: Unknown property type %s")
							 TEXT(" (index %d)\n"),
							SzDecodeUlPropTag(pprop->ulPropTag), pprop - rgprop);
				return E_INVALIDARG;

			case PT_I2:
			case PT_LONG:
			case PT_R4:
			case PT_APPTIME:
			case PT_DOUBLE:
			case PT_BOOLEAN:
			case PT_CURRENCY:
			case PT_SYSTIME:
			case PT_I8:
			case PT_ERROR:
			case PT_OBJECT:
			case PT_NULL:
				continue;	//	nothing to add or relocate

			case PT_CLSID:
				pprop->Value.lpguid = PvRelocPv(pprop->Value.lpguid,
					pvBaseOld, pvBaseNew);
				cbT = sizeof(GUID);
				break;

			case PT_BINARY:
				pprop->Value.bin.lpb = PvRelocPv(pprop->Value.bin.lpb,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.bin.cb;
				break;

			case PT_STRING8:

				// If we're assuming that the old pointer is OK (this
				// means that we determined that the new one is not OK),
				// save the current lpszA value in a temp variable. After
				// the relocation, if the reverse is true, we'll put the
				// relocated lpszA value into the temp variable.
				//
				// We then use the strlen of the string we hope the temp
				// variable is pointing to, in order to compute the amount
				// of space in the blob which is occupied by the string.

				if (!fBaseNewValid)
					pvT = pprop->Value.lpszA;

				pprop->Value.lpszA = PvRelocPv(pprop->Value.lpszA,
					pvBaseOld, pvBaseNew);

				if (fBaseNewValid)
					pvT = pprop->Value.lpszA;

				cbT = lstrlenA((LPSTR)pvT) + 1;

				break;

			case PT_UNICODE:

				// If we're assuming that the old pointer is OK (this
				// means that we determined that the new one is not OK),
				// save the current lpszW value in a temp variable. After
				// the relocation, if the reverse is true, we'll put the
				// relocated lpszW value into the temp variable.
				//
				// We then use the strlen of the string we hope the temp
				// variable is pointing to, in order to compute the amount
				// of space in the blob which is occupied by the string.

				if (!fBaseNewValid)
					pvT = pprop->Value.lpszW;

				pprop->Value.lpszW = PvRelocPv(pprop->Value.lpszW,
					pvBaseOld, pvBaseNew);

				if (fBaseNewValid)
					pvT = pprop->Value.lpszW;

				cbT = (lstrlenW((LPWSTR)pvT) + 1) * sizeof(WCHAR);

				break;

			case PT_MV_I2:
				pprop->Value.MVi.lpi = PvRelocPv(pprop->Value.MVi.lpi,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVi.cValues * sizeof(short int);
				break;

			case PT_MV_LONG:
				pprop->Value.MVl.lpl = PvRelocPv(pprop->Value.MVl.lpl,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVl.cValues * sizeof(LONG);
				break;

			case PT_MV_R4:
				pprop->Value.MVflt.lpflt = PvRelocPv(pprop->Value.MVflt.lpflt,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVflt.cValues * sizeof(float);
				break;

			case PT_MV_APPTIME:
				pprop->Value.MVat.lpat = PvRelocPv(pprop->Value.MVat.lpat,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVat.cValues * sizeof(double);
				break;

			case PT_MV_DOUBLE:
				pprop->Value.MVdbl.lpdbl = PvRelocPv(pprop->Value.MVdbl.lpdbl,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVdbl.cValues * sizeof(double);
				break;

			case PT_MV_CURRENCY:
				pprop->Value.MVcur.lpcur = PvRelocPv(pprop->Value.MVcur.lpcur,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVcur.cValues * sizeof(CURRENCY);
				break;

			case PT_MV_SYSTIME:
				pprop->Value.MVft.lpft = PvRelocPv(pprop->Value.MVft.lpft,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVft.cValues * sizeof(FILETIME);
				break;

			case PT_MV_CLSID:
				pprop->Value.MVguid.lpguid = PvRelocPv(pprop->Value.MVguid.lpguid,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVguid.cValues * sizeof(GUID);
				break;

			case PT_MV_I8:
				pprop->Value.MVli.lpli = PvRelocPv(pprop->Value.MVli.lpli,
					pvBaseOld, pvBaseNew);
				cbT = (UINT)pprop->Value.MVli.cValues * sizeof(LARGE_INTEGER);
				break;

			case PT_MV_BINARY:
			{
				LPSBinary lpsbT = pprop->Value.MVbin.lpbin;

				pprop->Value.MVbin.lpbin = PvRelocPv(lpsbT, pvBaseOld, pvBaseNew);

				// We've already set up a temporary variable to point to the
				// pvBaseOld memory location. If pvBaseNew was OK, then we'll
				// redirect the temp variable to the relocated memory before
				// using it to correct the pointers in the MVbin array.

				if (fBaseNewValid)
					lpsbT = pprop->Value.MVbin.lpbin;

				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVbin.cValues;
					  	iValue++)
				{
					lpsbT[iValue].lpb = PvRelocPv(lpsbT[iValue].lpb, pvBaseOld, pvBaseNew);
					cb += (UINT)AlignProp(lpsbT[iValue].cb);
				}
				continue;	//	already updated, don't do it again
			}

			case PT_MV_STRING8:
			{
				LPSTR * lppszT = pprop->Value.MVszA.lppszA;

				pprop->Value.MVszA.lppszA = PvRelocPv(lppszT, pvBaseOld, pvBaseNew);

				// We've already set up a temporary variable to point to the
				// pvBaseOld memory location. If pvBaseNew was OK, then we'll
				// redirect the temp variable to the relocated memory before
				// using it to correct the pointers in the MVszA array.

				if (fBaseNewValid)
					   lppszT = pprop->Value.MVszA.lppszA;

				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszA.cValues;
					  	iValue++)
				{
					// If we're assuming that the old pointer is OK (this
					// means that we determined that the new one is not OK),
					// save the current lppszT value in a temp variable. After
					// the relocation, if the reverse is true, we'll put the
					// relocated lppszT value into the temp variable.
					//
					// We then use the strlen of the string we hope the temp
					// variable is pointing to, in order to compute the amount
					// of space in the blob which is occupied by the string.

					if (!fBaseNewValid)
						pvT = lppszT[iValue];

					lppszT[iValue] = PvRelocPv(lppszT[iValue], pvBaseOld, pvBaseNew);

					if (fBaseNewValid)
						pvT = lppszT[iValue];

					cb += lstrlenA((LPSTR)pvT) + 1;
				}
				cb = AlignProp(cb);
				continue;	//	already updated, don't do it again
			}

			case PT_MV_UNICODE:
			{
				LPWSTR * lppszwT = pprop->Value.MVszW.lppszW;

				pprop->Value.MVszW.lppszW = PvRelocPv(lppszwT, pvBaseOld, pvBaseNew);

				// We've already set up a temporary variable to point to the
				// pvBaseOld memory location. If pvBaseNew was OK, then we'll
				// redirect the temp variable to the relocated memory before
				// using it to correct the pointers in the MVszW array.

				if (fBaseNewValid)
					   lppszwT = pprop->Value.MVszW.lppszW;

				for (iValue = 0;
				  	(ULONG)iValue < pprop->Value.MVszW.cValues;
					  	iValue++)
				{
					// If we're assuming that the old pointer is OK (this
					// means that we determined that the new one is not OK),
					// save the current lppszwT value in a temp variable. After
					// the relocation, if the reverse is true, we'll put the
					// relocated lppszwT value into the temp variable.
					//
					// We then use the strlen of the string we hope the temp
					// variable is pointing to, in order to compute the amount
					// of space in the blob which is occupied by the string.

					if (!fBaseNewValid)
						pvT = lppszwT[iValue];

					lppszwT[iValue] = PvRelocPv(lppszwT[iValue], pvBaseOld, pvBaseNew);

					if (fBaseNewValid)
						pvT = lppszwT[iValue];

					cb += (lstrlenW(lppszwT[iValue]) + 1) * sizeof(WCHAR);
				}
				cb = AlignProp(cb);
				continue;	//	already updated, don't do it again
			}
		}

		//	Advance total count
		cb += AlignProp(cbT);
	}

	if (pcb)
	{
		Assert(!IsBadWritePtr(pcb, sizeof(ULONG)));
		*pcb = cb;
	}
	return S_OK;
}
#endif

/*
 *	Wrapper function to just duplicate a property value array
 *	into a single block of MAPI memory.
 */
STDAPI_(SCODE)
ScDupPropset(int cprop, LPSPropValue rgprop, LPALLOCATEBUFFER palloc,
	LPSPropValue FAR *prgprop)
{
	ULONG		cb;
	SCODE		sc;

	// validate parameters

	AssertSz(!cprop || !IsBadReadPtr(rgprop, sizeof(SPropValue) * cprop),
			 TEXT("rgprop fails address check"));

	AssertSz(!IsBadCodePtr((FARPROC)palloc),  TEXT("palloc fails address check"));

	AssertSz(!IsBadWritePtr(prgprop, sizeof(LPSPropValue)),
			 TEXT("prgprop fails address check"));

	//	Find out how much memory we need
	if (sc = ScCountProps(cprop, rgprop, &cb))
		goto ret;
	//	Obtain memory
	if (sc = (*palloc)(cb, (LPVOID *)prgprop))
		goto ret;
	//	Copy the properties
	if (sc = ScCopyProps(cprop, rgprop, *prgprop, &cb))
		goto ret;

ret:
	DebugTraceSc(ScDupPropset, sc);
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wab16.c ===
#include "_apipch.h"

/*****************************************************************************\
*                                                                             *
*  Unknown local functions in wab\wabapi
*                                                                             *
\*****************************************************************************/
int
AlertIdsCtx( HWND hwnd,
             HINSTANCE hinst,
             UINT idsMsg,
             LPSTR szComponent,
             ULONG ulContext,
             ULONG ulLow,
             UINT fuStyle)
{
    return 0;
}

int
AlertSzCtx( HWND hwnd,
            LPSTR szMsg,
            LPSTR szComponent,
            ULONG ulContext,
            ULONG ulLow,
            UINT fuStyle)
{
    return 0;
}

LPVOID
PvGetInstanceGlobals(void)
{
    return NULL;
}

LPVOID
PvGetInstanceGlobalsInt(LPInstList lpInstListX)
{
    return NULL;
}

SCODE
ScSetInstanceGlobalsInt(LPVOID pv, LPInstList lpInstListX)
{
    return NULL;
}

SCODE
ScSetInstanceGlobals(LPVOID pv)
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wab16.h ===
/*****************************************************************************\
*                                                                             *
* Wab16.h                                                                  *
*                                                                             *
\*****************************************************************************/

#ifndef __WAB16_H__
#define __WAB16_H__

#ifdef __cplusplus
extern "C"{
#endif

/*****************************************************************************\
*                                                                             *
*  From windowsx.h(INC32)
*                                                                             *
\*****************************************************************************/
typedef WCHAR  PWCHAR;
#define END_INTERFACE

// From capi.h
#define      WTD_UI_ALL              1
#define      WTD_UI_NONE             2
#define      WTD_UI_NOBAD            3
#define      WTD_UI_NOGOOD           4
#define      WTD_REVOKE_NONE         0x00000000
#define      WTD_REVOKE_WHOLECHAIN   0x00000001

#pragma pack(8)

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_DATA Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust to pass necessary information into
//  the Providers.
//
typedef struct _WINTRUST_DATA
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_DATA)

    LPVOID          pPolicyCallbackData;        // optional: used to pass data between the app and policy
    LPVOID          pSIPClientData;             // optional: used to pass data between the app and SIP.

    DWORD           dwUIChoice;                 // required: UI choice.  One of the following.
#                       define      WTD_UI_ALL              1
#                       define      WTD_UI_NONE             2
#                       define      WTD_UI_NOBAD            3
#                       define      WTD_UI_NOGOOD           4

    DWORD           fdwRevocationChecks;        // required: certificate revocation check options
#                       define      WTD_REVOKE_NONE         0x00000000
#                       define      WTD_REVOKE_WHOLECHAIN   0x00000001

    DWORD           dwUnionChoice;              // required: which structure is being passed in?
#                       define      WTD_CHOICE_FILE         1
#                       define      WTD_CHOICE_CATALOG      2
#                       define      WTD_CHOICE_BLOB         3
#                       define      WTD_CHOICE_SIGNER       4
#                       define      WTD_CHOICE_CERT         5
    union
    {
        struct WINTRUST_FILE_INFO_      *pFile;         // individual file
        struct WINTRUST_CATALOG_INFO_   *pCatalog;      // member of a Catalog File
        struct WINTRUST_BLOB_INFO_      *pBlob;         // memory blob
        struct WINTRUST_SGNR_INFO_      *pSgnr;         // signer structure only
        struct WINTRUST_CERT_INFO_      *pCert;
    };

    DWORD           dwStateAction;                      // optional
#                       define      WTD_STATEACTION_IGNORE  0x00000000
#                       define      WTD_STATEACTION_VERIFY  0x00000001
#                       define      WTD_STATEACTION_CLOSE   0x00000002

    HANDLE          hWVTStateData;                      // optional

    WCHAR           *pwszURLReference;          // optional: currently used to determine zone.

} WINTRUST_DATA, *PWINTRUST_DATA;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_FILE_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against an individual file.
//
typedef struct WINTRUST_FILE_INFO_
{
    DWORD           cbStruct;                   // = sizeof(WINTRUST_FILE_INFO)

    LPCWSTR         pcwszFilePath;              // required, file name to be verified
    HANDLE          hFile;                      // optional, open handle to pcwszFilePath
      
} WINTRUST_FILE_INFO, *PWINTRUST_FILE_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CATALOG_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a member of a Microsoft Catalog
//  file.
//
typedef struct WINTRUST_CATALOG_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_CATALOG_INFO)

    DWORD               dwCatalogVersion;       // optional: Catalog version number
    LPCWSTR             pcwszCatalogFilePath;   // required: path/name to Catalog file

    LPCWSTR             pcwszMemberTag;         // required: tag to member in Catalog
    LPCWSTR             pcwszMemberFilePath;    // required: path/name to member file
    HANDLE              hMemberFile;            // optional: open handle to pcwszMemberFilePath

} WINTRUST_CATALOG_INFO, *PWINTRUST_CATALOG_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_BLOB_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a memory blob.
//
typedef struct WINTRUST_BLOB_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_BLOB_INFO)

    GUID                gSubject;               // SIP to load

    LPCWSTR             pcwszDisplayName;       // display name of object

    DWORD               cbMemObject;
    BYTE                *pbMemObject;

    DWORD               cbMemSignedMsg;
    BYTE                *pbMemSignedMsg;

} WINTRUST_BLOB_INFO, *PWINTRUST_BLOB_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_SGNR_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CMSG_SIGNER_INFO Structure
//
typedef struct WINTRUST_SGNR_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_SGNR_INFO)

    LPCWSTR             pcwszDisplayName;       // name of the "thing" the pbMem is pointing to.

    CMSG_SIGNER_INFO    *psSignerInfo;

    DWORD               chStores;               // number of stores in pahStores
    HCERTSTORE          *pahStores;             // array of stores to add to internal list

} WINTRUST_SGNR_INFO, *PWINTRUST_SGNR_INFO;

//////////////////////////////////////////////////////////////////////////////
//
// WINTRUST_CERT_INFO Structure
//----------------------------------------------------------------------------
//  Used when calling WinVerifyTrust against a CERT_CONTEXT Structure
//
typedef struct WINTRUST_CERT_INFO_
{
    DWORD               cbStruct;               // = sizeof(WINTRUST_CERT_INFO)

    LPCWSTR             pcwszDisplayName;       // display name

    CERT_CONTEXT        *psCertContext;

    DWORD               chStores;               // number of stores in pahStores
    HCERTSTORE          *pahStores;             // array of stores to add to internal list

} WINTRUST_CERT_INFO, *PWINTRUST_CERT_INFO;

#pragma pack()

// End of Capi.h

const CLSID CLSID_HTMLDocument;

#ifdef __cplusplus
}
#endif

#endif // !__WAB16_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabapi.c ===
/*
 * WABAPI.C - Main entry to WAB API
 *
 */

#include <_apipch.h>

const LPTSTR  lpszOldKeyName = TEXT("Software\\Microsoft\\WAB\\Wab File Name");
const LPTSTR  lpszKeyName = TEXT("Software\\Microsoft\\WAB\\WAB4\\Wab File Name");

#if 0
CRITICAL_SECTION csOMIUnload;
// @todo [PaulHi] DLL Leak.  Remove this or implement
static s_bIsReallyOnlyWABOpenExSession = FALSE; // [PaulHi] TRUE if any thread in process creates a 
                                                // WAB object through the WABOpenEx() function
#endif


//
//  IWABObject jump table is defined here...
//

IWOINT_Vtbl vtblIWOINT = {
    VTABLE_FILL
    (IWOINT_QueryInterface_METHOD FAR *)    UNKOBJ_QueryInterface,
    (IWOINT_AddRef_METHOD FAR *)            UNKOBJ_AddRef,
    IWOINT_Release,
    (IWOINT_GetLastError_METHOD FAR *)      UNKOBJ_GetLastError,
    IWOINT_AllocateBuffer,
    IWOINT_AllocateMore,
    IWOINT_FreeBuffer,
    IWOINT_Backup,
    IWOINT_Import,
    IWOINT_Find,
    IWOINT_VCardDisplay,
    IWOINT_LDAPUrl,
    IWOINT_VCardCreate,
    IWOINT_VCardRetrieve,
    IWOINT_GetMe,
    IWOINT_SetMe
};

/* Interface which can be queried from lpWABOBJECT.
 *
 * It is important that the order of the interfaces supported be preserved
 * and that IID_IUnknown be the last in the list.
 */
IID const FAR * argpiidIWABOBJECT[] =
{
    &IID_IUnknown
};


#define WAB_USE_OUTLOOK_ALLOCATORS    0x20000000// Note: This internal flag needs to be
                                                // harmonious with external flags defined 
                                                // in wabapi.h for WAB_PARAM structs


/****************************************************************
 *
 -  CreateWABObject
 -
 *      Purpose
 *              Used for creating a WABObject interface in memory.
 *
 *      Arguments
 *              lppWABObject        Pointer to memory location which will receive a
 *                                                      pointer to the new WABObject.
 *     lpPropertyStore     Property store structure
 *
 *      Returns
 *              SCODE
 *
 */


STDAPI_(SCODE)
CreateWABObject(LPWAB_PARAM lpWP, LPPROPERTY_STORE lpPropertyStore, LPWABOBJECT FAR * lppWABObject)
{
    SCODE       sc;
    LPIWOINT    lpIWOINT = NULL;


    // validate paremeters
    AssertSz(lppWABObject &&
      !IsBadWritePtr(lppWABObject, sizeof(LPWABOBJECT)) &&
      !IsBadWritePtr(lpPropertyStore, sizeof(LPPROPERTY_STORE)),
       TEXT("lppWABObject fails address check"));

    //
    //  Create a IPDAT per object for lpMAPIPropInternal so that it gets
    //  called first.

    if (FAILED(sc = MAPIAllocateBuffer(sizeof(*lpIWOINT), &lpIWOINT))) {
        goto error;
    }

    // Init the object to 0, NULL
    memset((BYTE *)lpIWOINT, 0, sizeof(*lpIWOINT));

    MAPISetBufferName(lpIWOINT,  TEXT("WABAPI: lpIWOINT in CreateWABObject"));

    // Tag each object that it is created using the OLK MAPI allocators.
    if ( lpWP && (lpWP->ulFlags & WAB_USE_OUTLOOK_ALLOCATORS) )
        lpIWOINT->bSetOLKAllocators = TRUE;

    // Fill in the object specific instance data.
    lpIWOINT->inst.hinst = hinstMapiX;//HinstMapi();

#ifdef DEBUG
    if (lpIWOINT->inst.hinst == NULL)
        TraceSz1( TEXT("WABObject: GetModuleHandle failed with error %08lX"),
          GetLastError());
#endif /* DEBUG */

    //
    // Open the property store
    //
    if (FAILED(sc = OpenAddRefPropertyStore(lpWP, lpPropertyStore))) {
        goto error;
    }

    lpIWOINT->lpPropertyStore = lpPropertyStore;

    // Initialize the  TEXT("standard") object. This must be the last operation that can fail.
    // If not, explicitly call UNKOBJ_Deinit() for failures after a successful UNKOBJ_Init.
    if (FAILED(sc = UNKOBJ_Init((LPUNKOBJ)lpIWOINT,
      (UNKOBJ_Vtbl FAR *)&vtblIWOINT,
      sizeof(vtblIWOINT),
      (LPIID FAR *) argpiidIWABOBJECT,
      dimensionof(argpiidIWABOBJECT),
      &(lpIWOINT->inst)))) {
        DebugTrace( TEXT("CreateWABObject() - Error initializing IWOINT object (SCODE = 0x%08lX)\n"), sc);
        ReleasePropertyStore(lpPropertyStore);   // undo the above operation
        goto error;
    }

    // Initialize the defaults in WABObject specific part of the object.
    lpIWOINT->ulObjAccess = IPROP_READWRITE;

    *lppWABObject = (LPWABOBJECT)lpIWOINT;

    return(S_OK);

error:
    FreeBufferAndNull(&lpIWOINT);

    return(sc);
}



// --------
// IUnknown



/*
 -      IWOINT_Release
 -
 *      Purpose:
 *              Decrements reference count on the WABObject and
 *              removes instance data if reference count becomes zero.
 *
 *      Arguments:
 *               lpWABObject The object to be released.
 *
 *      Returns:
 *               Decremented reference count
 *
 *      Side effects:
 *
 *      Errors:
 */
STDMETHODIMP_(ULONG)
IWOINT_Release(LPIWOINT lpWABObject)
{
    ULONG   ulcRef;
    BOOL    bSetOLKAllocators;

#if !defined(NO_VALIDATION)
        // Make sure the object is valid.
        //
    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Release, lpVtbl)) {
        DebugTrace( TEXT("IWOINT::Release() - Bad object passed\n"));
        return(1);
    }
#endif


    UNKOBJ_EnterCriticalSection((LPUNKOBJ)lpWABObject);
    ulcRef = --lpWABObject->ulcRef;
    UNKOBJ_LeaveCriticalSection((LPUNKOBJ)lpWABObject);

    // Free the object.
    //
    // No critical section lock is required since we are guaranteed to be
    // the only thread accessing the object (ie ulcRef == 0).
    //
    if (!ulcRef) {
        // Free the object.
        //
        UNKOBJ_Deinit((LPUNKOBJ)lpWABObject);

        lpWABObject->lpVtbl = NULL;

        ReleaseOutlookStore(lpWABObject->lpPropertyStore->hPropertyStore, lpWABObject->lpOutlookStore);

        ReleasePropertyStore(lpWABObject->lpPropertyStore);

        bSetOLKAllocators = lpWABObject->bSetOLKAllocators;
        FreeBufferAndNull(&lpWABObject);

        // [PaulHi] 5/5/99  Raid 77138  Null out Outlook allocator function
        // pointers if our global count goes to zero.
        if (bSetOLKAllocators)
        {
            Assert(g_nExtMemAllocCount > 0);
            InterlockedDecrement((LPLONG)&g_nExtMemAllocCount);
            if (g_nExtMemAllocCount == 0)
            {
                lpfnAllocateBufferExternal = NULL;
                lpfnAllocateMoreExternal = NULL;
                lpfnFreeBufferExternal = NULL;
            }
        }
    }

    return(ulcRef);
}


/*
 -  IWOINT_AllocateBuffer
 -
 *  Purpose:
 *      Allocation routine
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      cbSize                          number of bytes to allocate
 *      lppBuffer                       -> Returned buffer
 *
 *  Returns:
 *      SCODE
 *
 */
STDMETHODIMP_(SCODE)
IWOINT_AllocateBuffer(LPIWOINT lpWABObject, ULONG cbSize, LPVOID FAR * lppBuffer) {
    SCODE sc = S_OK;


#if !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, AllocateBuffer, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::AllocateBuffer() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_AllocateBuffer(
      lpWABObject,
      cbSize,
      lppBuffer);

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lppBuffer)
        return MAPI_E_INVALID_PARAMETER;

    sc = MAPIAllocateBuffer(cbSize, lppBuffer);


    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(sc);
}


/*
 -  IWOINT_AllocateMore
 -
 *  Purpose:
 *      Allocation routine
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      cbSize                          number of bytes to allocate
 *      lpObject                        original allocation
 *      lppBuffer                       -> Returned buffer
 *
 *  Returns:
 *      SCODE
 *
 */
STDMETHODIMP_(SCODE)
IWOINT_AllocateMore(LPIWOINT lpWABObject, ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    SCODE sc = S_OK;


#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, AllocateMore, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::AllocateMore() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_AllocateMore(
      lpWABObject,
      cbSize,
      lpObject,
      lppBuffer);

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lppBuffer || !lpObject)
        return MAPI_E_INVALID_PARAMETER;


    sc = MAPIAllocateMore(cbSize, lpObject, lppBuffer);


    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(sc);
}


/*
 -  IWOINT_FreeBuffer
 -
 *  Purpose:
 *      Allocation routine
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpBuffer                        Buffer to free
 *
 *  Returns:
 *      SCODE
 *
 */
STDMETHODIMP_(SCODE)
IWOINT_FreeBuffer(LPIWOINT lpWABObject, LPVOID lpBuffer) {
    SCODE sc = S_OK;


#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, FreeBuffer, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::FreeBuffer() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_FreeBuffer(
      lpWABObject,
      lpBuffer);

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpBuffer)
        return MAPI_E_INVALID_PARAMETER;


    sc = MAPIFreeBuffer(lpBuffer);


    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(sc);
}



/*
 -  IWOINT_Backup
 -
 *  Purpose:
 *      Backup the current database to a file.
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpFileName                      Filename to backup to
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_Backup(LPIWOINT lpWABObject, LPSTR lpFileName) {
    SCODE sc = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Backup, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::Backup() - Bad object passed\n"));
        return ResultFromScode(MAPI_E_INVALID_PARAMETER);
    }

    Validate_IWABObject_Backup(
      lpWABObject,
      lpFileName);

#endif  // not NO_VALIDATION


    // Not yet implemented.
    DebugTrace( TEXT("IWABOBJECT::Backup() - Not yet implemented!\n"));
    sc = MAPI_E_NO_SUPPORT;

    // error:
    UNKOBJ_SetLastError((LPUNKOBJ)lpWABObject, sc, 0);

    return(MakeResult(sc));
}


/*
 -  IWOINT_Import
 -
 *  Purpose:
 *      Imports an address book into the current WAB database.
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpwip - WABIMPORTPARAM struct
 *
 *  Returns:
 *      HRESULT - MAPI_W_ERRORS_RETURNED if some errors occured during import
 *              Failure code if something really failed, S_OK otherwise ..
 *
 */
STDMETHODIMP
IWOINT_Import(LPIWOINT lpWABObject, LPSTR lpWIP) 
{
    LPWABIMPORTPARAM lpwip = (LPWABIMPORTPARAM) lpWIP;
    LPTSTR lpFile = NULL;
    HRESULT hr = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Import, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::Import() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

    Validate_IWABObject_Import(
      lpWABObject,
      lpWIP);

#endif  // not NO_VALIDATION

    if(!lpwip || !lpwip->lpAdrBook || !lpWABObject)
        return MAPI_E_INVALID_PARAMETER;

    lpFile = 
        ConvertAtoW(lpwip->lpszFileName);

    hr = HrImportWABFile(lpwip->hWnd, lpwip->lpAdrBook, lpwip->ulFlags, lpFile);

    LocalFreeAndNull(&lpFile);

    return hr;
}


/*
 -  IWOINT_Find
 -
 *  Purpose:
 *      Displays the Find dialog so we can do Start | Find | People
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      hWnd                            hWnd of parent for the find dialog
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_Find(LPIWOINT  lpWABObject,
            LPADRBOOK lpAdrBook,
            HWND hWnd)
{
    HRESULT hr = S_OK;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, Find, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::Find() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook)
        return MAPI_E_INVALID_PARAMETER;


    hr = HrShowSearchDialog(lpAdrBook,
                            hWnd,
                            (LPADRPARM_FINDINFO) NULL,
                            (LPLDAPURL) NULL,
                            NULL);

    return(hr);
}


/*
 -  IWOINT_VCardDisplay
 -
 *  Purpose:
 *      Displays One off props on a vCard File
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      hWnd                            hWnd of parent for the find dialog
 *      lpszFileName                    Null terminated file name to display
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_VCardDisplay(LPIWOINT  lpWABObject,
                    LPADRBOOK lpAdrBook,
                    HWND hWnd,
                    LPSTR szvCardFile)
{
    HRESULT hr = S_OK;
    LPTSTR lpVCard = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, VCardDisplay, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::VCardDisplay() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook)
        return MAPI_E_INVALID_PARAMETER;

    lpVCard = 
        ConvertAtoW(szvCardFile);

    hr = HrShowOneOffDetailsOnVCard( lpAdrBook,
                                     hWnd,
                                     lpVCard);
    LocalFreeAndNull(&lpVCard);
    return(hr);
}


/*
 -  IWOINT_VCardCreate
 -
 *  Purpose:
 *      Takes input mailuser object, and converts its properties
 *      into a vCard file
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      hWnd                            hWnd of parent for the find dialog
 *      lpszFileName                    Null terminated file name to create
 *      lpMailUser                      MailUser object to convert to vCard
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_VCardCreate(LPIWOINT  lpWABObject,
                    LPADRBOOK lpAdrBook,
                    ULONG ulFlags,
                    LPSTR szvCardFile,
                    LPMAILUSER lpMailUser)
{
    HRESULT hr = S_OK;
    LPTSTR lpVCardFile = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, VCardDisplay, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::VCardDisplay() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook || !lpMailUser)
        return MAPI_E_INVALID_PARAMETER;

    lpVCardFile = 
        ConvertAtoW(szvCardFile);

    hr = VCardCreate(lpAdrBook,
                     NULL,
                     0,
                     lpVCardFile,
                     lpMailUser);
    LocalFreeAndNull(&lpVCardFile);
    return(hr);
}

/*
 -  IWOINT_VCardRetrieve
 -
 *  Purpose:
 *      Opens a vCard file and creates a corresponding MailUser out of it
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      ulFlags                         STREAM or FILE
 *      lpszFileName                    Null terminated file name to display
 *      lppMailUser                     returned MailUser object
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_VCardRetrieve(LPIWOINT  lpWABObject,
                    LPADRBOOK lpAdrBook,
                    ULONG  ulFlags,
                    LPSTR szvCard,
                    LPMAILUSER * lppMailUser)
{
    HRESULT hr = S_OK;
    LPSTR lpStream = NULL;
    LPTSTR lpFileName = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, VCardDisplay, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::VCardDisplay() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if( !lpWABObject || !lpAdrBook || !lppMailUser || 
        !szvCard || (!(ulFlags&WAB_VCARD_STREAM) && !lstrlenA(szvCard)) )
        return MAPI_E_INVALID_PARAMETER;

    if(ulFlags & WAB_VCARD_STREAM)
    {
        DWORD cchSizeStream = (lstrlenA(szvCard)+1);
        if (!(lpStream = LocalAlloc(LMEM_ZEROINIT, (sizeof(lpStream[0]) * cchSizeStream))))
            return MAPI_E_NOT_ENOUGH_MEMORY;
        StrCpyNA(lpStream, szvCard, cchSizeStream);
    }
    else
    {
        lpFileName = ConvertAtoW(szvCard);
    }

    hr = VCardRetrieve(lpAdrBook,
                       NULL,
                       0,
                       lpFileName,
                       lpStream,
                       lppMailUser);
    LocalFreeAndNull(&lpFileName);
    LocalFreeAndNull(&lpStream);

    return(hr);
}

/*
 -  IWOINT_LDAPUrl
 -
 *  Purpose:
 *      Handles an LDAP URL
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      hWnd                            hWnd of parent for the find dialog
 *      ulFlags                         flags saying how we want the results returned
 *      lpszUrl                         Null terminated file name to display
 *      lppMailUser                     Possible Mailuser to return based on flag
 *
 *      With this API, users can pass in a Wide string URL by casting it to a 
 *      LPSTR and setting ulFlags to MAPI_UNICODE .. if we detect MAPI_UNICODE,
 *      we cast the string back to a WideChar
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_LDAPUrl( LPIWOINT  lpWABObject,
                LPADRBOOK lpAdrBook,
                HWND hWnd,
                ULONG ulFlags,
                LPSTR szLDAPUrl,
                LPMAILUSER * lppMailUser)
{
    HRESULT hr = S_OK;
    LPTSTR lpUrl = NULL;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, LDAPUrl, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::LDAPUrl() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook || !szLDAPUrl)// || !lstrlen(szLDAPUrl))
        return MAPI_E_INVALID_PARAMETER;

    if(ulFlags & MAPI_UNICODE)
    {
        lpUrl = (LPWSTR)szLDAPUrl;
    }
    else
    {
        lpUrl = ConvertAtoW(szLDAPUrl);
    }

    if(!lstrlen(lpUrl))
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto out;
    }

    hr = HrProcessLDAPUrl(  lpAdrBook,
                            hWnd,
                            ulFlags | ((!ulFlags && hWnd) ? MAPI_DIALOG : 0),
                            lpUrl,
                            lppMailUser);
out:
    if(lpUrl && lpUrl != (LPTSTR)szLDAPUrl)
        LocalFreeAndNull(&lpUrl);

    return hr;
}


/*
 -  IWOINT_GetMe
 -
 *  Purpose:
 *      Retrieves the 'Me' entry from the WAB .. if the entry doesnt exist,
 *      prompts the user to create one or select someone from his address book.
 *      Unless the caller surpresses the dialog by passing in AB_NO_DIALOG, in
 *      which case, the entry is created behind-the-scenes. Caller can also
 *      call this function to check existence of a ME entry without causing a new
 *      one created as a side effect - to do that they specify the WABOBJECT_ME_NOCREATE flag
 *      which causes failure with MAPI_E_NOT_FOUND if nothing found
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      ulFlags                         0 or AB_NO_DIALOG
 *                                      or WABOBJECT_ME_NOCREATE                                       
 *      lpdwAction                      if supplied, returns WABOBJECT_ME_NEW if a new ME was created
 *      SBinary *                       returns the entry id of the ME,
 *      ulParam                         HWND of parent cast as a (ULONG)
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_GetMe(   LPIWOINT    lpWABObject,
                LPADRBOOK   lpAdrBook,
                ULONG       ulFlags,
                DWORD *     lpdwAction,
                SBinary *   lpsbEID,
                ULONG       ulParam) 
{
    HRESULT hr = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, GetMe, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::GetMe() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if(!lpWABObject || !lpAdrBook)
        return MAPI_E_INVALID_PARAMETER;

    hr = HrGetMeObject(lpAdrBook, ulFlags, lpdwAction, lpsbEID, ulParam);

    return hr;

}

/*
 -  IWOINT_SetMe
 -
 *  Purpose:
 *      Sets the specified object as the Me object .. only 1 Me object will exist in a WAB
 *      Hence it strips the previous Me object, if different, of its Me status.
 *      If no entryid is passed in, and MAPI_DIALOG is specified, a dialog pops up 
 *          asking the user to create a ME or to select a ME object .. the selection in the SetMe
 *          dialog is set to the current ME object, if any
 *      If no entryid is passed in, and MAPI_DIALOG is not specified, the function fails
 *      If an entryid is passed in, and MAPI_DIALOG is specified, the SetME dialog is displayed
 *          with the corresponding entryid-object selected in it
 *      If an entryid is passed in, and MAPI_DIALOG is not specified, the entryid, if exists, is 
 *          set as the ME object and the old ME object stripped
 *
 *  Arguments:
 *      lpWABOBJECT                     this = the open wab object
 *      lpAdrBook                       lpAdrBook object
 *      ulFlags                         0 or MAPI_DIALOG
 *      sbEID                           entry id of the object to set as ME,
 *      ulParam                         HWND of parent for DIalogs cast as a ULONG
 *
 *  Returns:
 *      HRESULT
 *
 */
STDMETHODIMP
IWOINT_SetMe(   LPIWOINT    lpWABObject,
                LPADRBOOK   lpAdrBook,
                ULONG       ulFlags,
                SBinary     sbEID,
                ULONG       ulParam) 
{
    HRESULT hr = S_OK;

#if     !defined(NO_VALIDATION)
    // Make sure the object is valid.

    if (BAD_STANDARD_OBJ(lpWABObject, IWOINT_, SetMe, lpVtbl)) {
        DebugTrace( TEXT("IWABOBJECT::GetMe() - Bad object passed\n"));
        return(ResultFromScode(MAPI_E_INVALID_PARAMETER));
    }

#endif  // not NO_VALIDATION

    if( !lpAdrBook ||
        ((!sbEID.cb||!sbEID.lpb) && !ulFlags) )
    {
        hr = MAPI_E_INVALID_PARAMETER;
        goto exit;
    }

    hr = HrSetMeObject(lpAdrBook, ulFlags, sbEID, ulParam);

exit:
    return hr;

}






/*
 -  ReleasePropertyStore
 -
 *  Purpose:
 *      Keep track of property store refcount
 *
 *  Arguments:
 *      lpPropertyStore     PROPERTY_STORE structure
 *
 *  Returns:
 *      Current reference count.  When 0, property store is
 *      no longer open.
 *
 */
ULONG ReleasePropertyStore(LPPROPERTY_STORE lpPropertyStore) {
    if (lpPropertyStore->ulRefCount) {
        IF_WIN32(Assert(lpPropertyStore->hPropertyStore);)
        if (0 == (--(lpPropertyStore->ulRefCount))) {
            // Reference goes to zero, release the property store

            ClosePropertyStore(lpPropertyStore->hPropertyStore,0);
            lpPropertyStore->hPropertyStore = NULL;

			// Free the container list
			FreeBufferAndNull(&(lpPropertyStore->rgolkci));
            lpPropertyStore->colkci = 0;

            // [PaulHi] Raid #61556
            // Must reset this global variable or OUT32WAB.DLL will crash
            // the next time it is loaded and the store opened.
            pmsessOutlookWabSPI = NULL;
        }
    }
    return(lpPropertyStore->ulRefCount);
}

#ifdef WIN16
BOOL WINAPI WABInitThread()
{
    // allocate a TLS index
    if ((dwTlsIndex = TlsAlloc()) == 0xfffffff)
        return FALSE;

    return TRUE;
}
#endif

#define WAB_USE_OUTLOOK_CONTACT_STORE 0x10000000// Note: This internal flag needs to be
                                                // harmonious with external flags defined 
                                                // in wabapi.h for WAB_PARAM structs

//
// Input information to pass to WABOpen from IE4 WAB
//
typedef struct _tagWAB_PARAM_V4
{
    ULONG   cbSize;         // sizeof(WAB_PARAM).
    HWND    hwnd;           // hWnd of calling client Application. Can be NULL
    LPTSTR  szFileName;     // WAB File name to open. if NULL, opens default.
    ULONG   ulFlags;        // Currently no flags.
} WAB_PARAM_V4, * LPWAB_PARAM_V4;



/*
 -  WABOpen
 -
 *  Purpose:
 *      Entry point into the WAB API
 *
 *  Arguments:
 *      lppAdrBook                      Returned IAdrBook object
 *      lppWABOBJECT                    Returned WABObject
 *      Reserved1                       Reserved for future filename?
 *      Reserved2                       Reserved for future flags
 *
 *  Returns:
 *      HRESULT
 *          S_OK
 *          E_FAIL                      // some generic error
 *          MAPI_E_NOT_ENOUGH_MEMORY:   // ran out of memory
 *          MAPI_E_NO_ACCESS:           // file is locked by someone
 *          MAPI_E_CORRUPT_DATA:        // file corrupt
 *          MAPI_E_DISK_ERROR:          // some disk related error opening file
 *          MAPI_E_INVALID_OBJECT:      // secified file exists but its GUID doesnt match
 *
 */
STDMETHODIMP WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP, DWORD Reserved2) {
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;
    static PROPERTY_STORE PropertyStore = {NULL, 0, 0, 0, NULL, 0};
    static OUTLOOK_STORE OutlookStore = {NULL, 0};
    BOOL bUseOutlook = FALSE;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPTSTR lpFile = NULL;

    AssertSz(lppAdrBook && !IsBadWritePtr(lppAdrBook, sizeof(LPADRBOOK)),
       TEXT("lppAdrBook fails address check"));

    AssertSz(lppWABObject && !IsBadWritePtr(lppWABObject, sizeof(LPWABOBJECT)),
       TEXT("lppWABObject fails address check"));

    if(!lppAdrBook || !lppWABObject)
        return MAPI_E_INVALID_PARAMETER;

    IF_WIN16(ScInitMapiUtil(0);)

    // First check if this is supposed to be an Outlook session
    // If we are explicitly told to use the contact store ...
    if((lpWP && (lpWP->ulFlags & WAB_USE_OUTLOOK_CONTACT_STORE)) &&
        PropertyStore.ulRefCount == 0)  // Bad bug where wabopen process calls outlook which 
                                        // calls wabopenex and we flunk everywhere since this PropertyStore
                                        // information is a static in the original process.. 
                                        // force the wabopenex to be a wabopen if this rare case happens
        bUseOutlook = TRUE;
    else
    {
        // if a file name is specified and this is not wabopenex, then override any
        // outlook use .. this way we can explicitly call the wab to open a .wab file
        // from anywhere
        if(lpWP && lpWP->szFileName && lstrlenA(lpWP->szFileName))
            bUseOutlook = FALSE;
        else 
            bUseOutlook = bUseOutlookStore();
    }

#if 0
    // @todo [PaulHi] DLL Leak.  Remove this or implement
    // [PaulHi] Set this process global boolean ONLY if the WAB is opened through the WABOpenEx()
    // function ,i.e., by the Outlook process
    if (lpWP && (lpWP->ulFlags & WAB_USE_OUTLOOK_CONTACT_STORE))
    {
        EnterCriticalSection(&csOMIUnload);
        s_bIsReallyOnlyWABOpenExSession = TRUE;
        LeaveCriticalSection(&csOMIUnload);
    }
#endif

    //
    // if a .wab file is already initialized in this process space, just inherit that file
    // [PaulHi] 12/5/98  Raid #56437
    // We still need to allow the Outlook refcount to increment if this store has been created.
    // So we need to check both the WAB PropertyStore and OutlookStore ref counts to determine
    // if we should prevent the Outlook store from being opened.
    // Note that these two lines fixes the following problem:
    // 1)  User opens OE5 (which opens WAB in non-outlook store mode)
    // 2)  User has the Outlook set as their default mail client.
    // 3)  User uses the WAB to initiate a send email.
    // 4)  Since Outlook is the default client it is launched, and in turn opens WAB
    //     in outlook store mode.  At this point the WAB is already open in non-outlook store
    //     mode so we want to prevent the Outlook store from being initialized.
    //
    if (PropertyStore.ulRefCount && !OutlookStore.ulRefCount)
        bUseOutlook = FALSE;

    if(bUseOutlook)
    {
        // If this call fails, we will just end up defaulting to the WAB store...
        // so we can ignore any errors here
        OpenAddRefOutlookStore(&OutlookStore);
    }

    //
    // Create the WAB Object
    //
    if (FAILED(sc = CreateWABObject(lpWP, &PropertyStore, lppWABObject))) {
        hResult = ResultFromScode(sc);
        if(bUseOutlook)   // IE6 bug 15174
            pt_bIsWABOpenExSession = FALSE; 
        goto exit;
    }

    //
    // Create the IAdrBook Object
    //
    if (HR_FAILED(hResult = HrNewIAB(&PropertyStore, *lppWABObject, lppAdrBook))) {
        // IAdrBook creation failed, fail WABOpen and clean up.
        UlRelease(*lppWABObject);
        goto exit;
    }
    DebugTrace( TEXT("WABOpen succeeds\n"));

    if(bUseOutlook)
    {
        if( lppWABObject && *lppWABObject &&
            OutlookStore.hOutlookStore)
        {
            ((LPIWOINT)(*lppWABObject))->lpOutlookStore = &OutlookStore;
        }

        // Bug - Outlook needs a way for its secondary threads to know this is a WABOpenEx session
        // without their calling WABOpenEx (They pass the iAdrBook pointer around it seems). Hence
        // tag this IADRbook pointer
        if(!HR_FAILED(hResult) && lppAdrBook && *lppAdrBook && pt_bIsWABOpenExSession)
            ((LPIAB)(*lppAdrBook))->lpPropertyStore->bIsWABOpenExSession = TRUE;
    }

    if(lppAdrBook && *lppAdrBook)
    {
        // Load the WABs private named properties
        HrLoadPrivateWABProps((LPIAB) *lppAdrBook);

        if(lpWP && (lpWP->cbSize > sizeof(WAB_PARAM_V4)) )
            ((LPIAB)*lppAdrBook)->guidPSExt = lpWP->guidPSExt;

        // As long as this is not an Outlook session, profiles are always
        // enabled in the UI
        if( !pt_bIsWABOpenExSession &&
            !((LPIAB)(*lppAdrBook))->lpPropertyStore->bIsWABOpenExSession )
        {
            ((LPIAB)(*lppAdrBook))->bProfilesEnabled = TRUE;
        }

        if( ((LPIAB)(*lppAdrBook))->bProfilesEnabled )
        {
            if(lpWP && (lpWP->ulFlags & WAB_ENABLE_PROFILES)) // only check for profiles the first time we enter for this process
            {
                if(PropertyStore.ulRefCount >= 2)
                {
                    ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = ((LPIAB)(*lppAdrBook))->bProfilesIdent = TRUE;
                }
                else
                {
                    ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = PropertyStore.bProfileAPIs;
                }

                if(((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled )
                    hResult = HrLogonAndGetCurrentUserProfile(lpWP->hwnd, ((LPIAB)(*lppAdrBook)), FALSE, FALSE);
                
                // if there is some identity related error we should then revert to
                // non-identity mode
                if(HR_FAILED(hResult))
                {
                    PropertyStore.bProfileAPIs = ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = FALSE;
                    hResult = S_OK;
                }
                else
                    PropertyStore.bProfileAPIs = ((LPIAB)(*lppAdrBook))->bProfilesAPIEnabled = TRUE;
            }
        }

        if( ((LPIAB)(*lppAdrBook))->bProfilesEnabled )
        {
            if(HR_FAILED(hResult = HrGetWABProfiles((LPIAB) *lppAdrBook)))
            {
                // UGH! If this failed then we are quite in trouble and won't be able to support a profile-enabled
                // session without crashing badly .. hence above failure is critical enough to stop
                // loading the WAB
                (*lppAdrBook)->lpVtbl->Release(*lppAdrBook);
                (*lppWABObject)->lpVtbl->Release(*lppWABObject);
            }
        }
        
        ReadWABCustomColumnProps((LPIAB) *lppAdrBook);

        // need to be aware of Identity Notifications if this is a profile aware WAB independent
        // of whether the store is switched to using Outlook or not
        //
        // If the caller specifically asked for profiles 
        // (then assume it is identity aware and register for Identity Notifications
        // because if the caller is using Identites, WAB launched as a child window
        // needs to be able to shut down when it gets a switch_identites message
        if( lpWP && (lpWP->ulFlags & WAB_ENABLE_PROFILES)) 
            HrRegisterUnregisterForIDNotifications( (LPIAB) *lppAdrBook, TRUE);

        if( lpWP && (lpWP->ulFlags & WAB_USE_OE_SENDMAIL)) 
            ((LPIAB) *lppAdrBook)->bUseOEForSendMail = TRUE;
    }

exit:
    return(hResult);
}


/*
 -  WABOpenEx
 -
 *  Purpose:
 *      Extended Entry point into the WAB API
 *
 *  Arguments:
 *      lppAdrBook                      Returned IAdrBook object
 *      lppWABOBJECT                    Returned WABObject
 *      lpMP                            WAB Parameter structure (NULL by default)
 *      Reserved                        Optional IMAPISession parameter
 *      fnAllocateBuffer                AllocateBuffer function (may be NULL)
 *      fnAllocateMore                  AllocateMore function (may be NULL)
 *      fnFreeBuffer                    FreeBuffer function (may be NULL)
 *
 *  Returns:
 *      HRESULT
 *          S_OK
 *          E_FAIL                      // some generic error
 *          MAPI_E_NOT_ENOUGH_MEMORY:   // ran out of memory
 *          MAPI_E_NO_ACCESS:           // file is locked by someone
 *          MAPI_E_CORRUPT_DATA:        // file corrupt
 *          MAPI_E_DISK_ERROR:          // some disk related error opening file
 *          MAPI_E_INVALID_OBJECT:      // secified file exists but its GUID doesnt match
 *
 */
STDMETHODIMP WABOpenEx(LPADRBOOK FAR * lppAdrBook,
  LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP,
  DWORD Reserved,
  ALLOCATEBUFFER * lpfnAllocateBuffer,
  ALLOCATEMORE * lpfnAllocateMore,
  FREEBUFFER * lpfnFreeBuffer) {

    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    WAB_PARAM wp = {0};
    
    if (Reserved) {
        // This is an IMAPISession that needs to be passed to the
        // Outlook storage provider interface ..
		pmsessOutlookWabSPI = (LPUNKNOWN)IntToPtr(Reserved);
    }

    if(!lppWABObject || !lppAdrBook)
        return MAPI_E_INVALID_PARAMETER;

    wp.cbSize = sizeof(WAB_PARAM);
    if(!lpWP)
        lpWP = &wp;
    lpWP->ulFlags |= WAB_USE_OUTLOOK_CONTACT_STORE;
    
    // Did we get allocators?  Set up the globals
    if (lpfnAllocateBuffer || lpfnAllocateMore || lpfnFreeBuffer)
    {
        if (lpfnAllocateBuffer && lpfnAllocateMore && lpfnFreeBuffer)
        {
            DebugTrace( TEXT("WABOpenEx found external allocators\n"));
            lpfnAllocateBufferExternal = lpfnAllocateBuffer;
            lpfnAllocateMoreExternal = lpfnAllocateMore;
            lpfnFreeBufferExternal = lpfnFreeBuffer;
            lpWP->ulFlags |= WAB_USE_OUTLOOK_ALLOCATORS;
            InterlockedIncrement((LPLONG)&g_nExtMemAllocCount); // Incremented twice for each object created; IAB and IWO
            InterlockedIncrement((LPLONG)&g_nExtMemAllocCount);
        }
        else
        {
            DebugTrace( TEXT("WABOpenEx got one or two allocator functions, but not all three\n"));
            hResult = ResultFromScode(MAPI_E_INVALID_PARAMETER);
            goto exit;
        }
    }

    hResult = WABOpen(  lppAdrBook, lppWABObject, lpWP, 0);

    if(lpWP == &wp)
        lpWP = NULL;

    if(HR_FAILED(hResult))
        goto exit;

exit:
    return(hResult);
}

/*
 -
 -  GetNewDataDirName
 *
 *  Purpose:
 *      Gets the path of the new data directory in which the WAB file should be placed
 *
 *      We look for:
 *          Roaming User App Data Dir; else
 *          Program Files\IE\OE\Current User\Address Book; else
 *          Common Files\Microsoft Shared\Address Book; else
 *          Create c:\Address book\ else
 *          Create c:\wab\
 *
 *  Returns a valid, existing directory name terminated by a \
 *
 */
HRESULT GetNewDataDirName(LPTSTR szDir, DWORD cchSizeDir)
{
    HRESULT hr = E_FAIL;
    const LPTSTR lpszShellFolders = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
    const LPTSTR lpszAppData = TEXT("AppData");
    const LPTSTR lpszCurrentVer = TEXT("Software\\Microsoft\\Windows\\CurrentVersion");
    const LPTSTR lpszCommonFiles = TEXT("CommonFilesDir");
    const LPTSTR lpszMicrosoftShared = TEXT("\\Microsoft Shared");
    const LPTSTR lpszAddressBook = TEXT("\\Address Book");
    const LPTSTR lpszOEKey = TEXT("Software\\Microsoft\\Outlook Express\\5.0");
    const LPTSTR lpszOERoot = TEXT("Store Root");
    const LPTSTR lpszMicrosoft = TEXT("\\Microsoft");
    const LPTSTR lpszCAddressBook = TEXT("c:\\Address book");
    const LPTSTR lpszCWAB = TEXT("c:\\WAB");

    HKEY hKey = NULL;
    DWORD dwSize = 0;

    DWORD dwType = 0;
    TCHAR szPath[MAX_PATH];
    TCHAR szUser[MAX_PATH];

    *szPath='\0';

    if(!szDir)
        goto out;

    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,lpszShellFolders,0,KEY_READ,&hKey))
    {
    // Look for the App Data directory
        dwSize = ARRAYSIZE(szPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpszAppData, NULL, &dwType, (LPBYTE) szPath, &dwSize))
        {
            if(lstrlen(szPath))
            {
                StrCpyN(szDir, szPath, cchSizeDir);
                if(GetFileAttributes(szDir) != 0xFFFFFFFF)
                {
                    StrCatBuff(szDir, lpszMicrosoft, cchSizeDir);
                    if(GetFileAttributes(szDir) == 0xFFFFFFFF)
                        CreateDirectory(szDir, NULL);
                    StrCatBuff(szDir, lpszAddressBook, cchSizeDir);
                    if(GetFileAttributes(szDir) == 0xFFFFFFFF)
                        CreateDirectory(szDir, NULL);
                }
                hr = S_OK;
                goto out;
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
    hKey = NULL;

    // Didnt find this directory
    // Look for MyDocuments folder - it will only be installed with Office so no gaurantee it will be found
    // <TBD> - there doesnt seem to be a definite location for this except under
    // CurrentVersion\Explorer\Shell Folders\Personal

    // Didnt find a My Documents directory
    // See if OE is installed for the current user ..

    /** commented out until OE has stable dir structure
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpszOEKey, 0, KEY_READ, &hKey))
    {
        dwSize = CharSizeOf(szPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpszOERoot, NULL, &dwType, (LPBYTE) szPath, &dwSize))
        {
            if(lstrlen(szPath))
            {
                StrCatBuff(szPath,lpszAddressBook, ARRAYSIZE(szPath));

                //if directory doesnt exist, create it 
                CreateDirectory(szPath, NULL); //ignore error if it already exists

                if(GetFileAttributes(szPath) != 0xFFFFFFFF)
                {
                    StrCpyN(szDir, szPath, cchSizeDir);
                    hr = S_OK;
                    goto out;
                }
            }
        }
    }

    if(hKey)
        RegCloseKey(hKey);
    */
  hKey = NULL;

    // No user name .. just get the common files directory and put  TEXT("Microsoft Shared\Address Book") under it
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpszCurrentVer, 0, KEY_READ, &hKey))
    {
        dwSize = ARRAYSIZE(szPath);
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpszCommonFiles, NULL, &dwType, (LPBYTE) szPath, &dwSize))
        {
            if(lstrlen(szPath))
            {
                StrCatBuff(szPath, lpszMicrosoftShared, ARRAYSIZE(szPath));
                CreateDirectory(szPath, NULL);
                if(GetFileAttributes(szPath) != 0xFFFFFFFF)
                {
                    StrCatBuff(szPath, lpszAddressBook, ARRAYSIZE(szPath));
                    CreateDirectory(szPath, NULL);
                    if(GetFileAttributes(szPath) != 0xFFFFFFFF)
                    {
                        StrCpyN(szDir, szPath, cchSizeDir);
                        hr = S_OK;
                        goto out;
                    }
                }
            }
        }
    }

    // if all of the above failed then we'll have problems since this function must NEVER fail when
    // it is called,
    // Hence go ahead and try to create c:\address book (which might fail on an 8.3 machine) in which case
    // create c:\wab
    if(CreateDirectory(lpszCAddressBook, NULL))
    {
        StrCpyN(szDir, lpszCAddressBook, cchSizeDir);
        StrCatBuff(szDir, TEXT("\\"), cchSizeDir);
        hr = S_OK;
        goto out;
    }

    // failed - try c:\wab
    if(CreateDirectory(lpszCWAB, NULL))
    {
        StrCpyN(szDir, lpszCWAB, cchSizeDir);
        hr = S_OK;
        goto out;
    }

    // still failed !!!!!???!!? !@#!@#!!!
    // just return the windows directory if we can
    if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)))
    {
        StrCpyN(szDir, szPath, cchSizeDir);
        hr = S_OK;
        goto out;
    }
 
    // still failed !!!!!???!!? !@#!@#!!!
    // just return 'c:' 
    StrCpyN(szDir, TEXT("c:\\"), cchSizeDir);
    hr = S_OK;


out:
    if(hKey)
        RegCloseKey(hKey);

    if(szDir && lstrlen(szDir))
    {
        // Add a terminating slash to the directory name if one doesnt exist
        if( *(szDir+lstrlen(szDir)-1) != '\\' )
            StrCatBuff(szDir, szBackSlash, cchSizeDir);
    }

    return hr;
}

/*
 -
 -  DoFirstRunMigrationAndProcessing
 *
 *  Purpose:
 *      If this is an IE4 or later first run, move the old WAB file from
 *      windows to a new location and/or create a new WAB file so that the
 *      old WAB file is not mucked around with
 *
 */
HRESULT DoFirstRunMigrationAndProcessing()
{
    HRESULT hr = S_OK;
    const LPTSTR lpszFirstRunValue = TEXT("FirstRun");
    const LPTSTR lpszIE3Ext = TEXT(".ie3");
    DWORD dwType = 0;
    DWORD dwValue = 0;  
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    TCHAR szDir[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    HKEY hKey = NULL;
    DWORD dwSize = sizeof(DWORD);

    // First check if this is a first run - if its not a first run then we can just skip out
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpNewWABRegKey, 0, KEY_READ, &hKey))
    {
        if(ERROR_SUCCESS == RegQueryValueEx( hKey, lpszFirstRunValue, NULL, &dwType, (LPBYTE) &dwValue, &dwSize))
        {
            goto out;
        }
    }

    if(hKey)
        RegCloseKey(hKey);
    hKey = NULL;

    // So this is the first run ..

    // First thing to do is to Migrate the LDAP accounts in this session only ...
    // Set the first run flag
    pt_bFirstRun = TRUE;

    // Get the directory name of the new directory in which the WAB file will be created/copied
    *szDir = '\0';

    if (hr = GetNewDataDirName(szDir, ARRAYSIZE(szDir)))
        goto out;

    *szFileName = '\0';

    // Do we have a pre-existing wab data file ? Check by looking in the registry for the appropriate reg key
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpszOldKeyName, 0, KEY_ALL_ACCESS, &hKey))
    {
        TCHAR szOldPath[MAX_PATH];
        TCHAR szWinPath[MAX_PATH];
        TCHAR szNewName[MAX_PATH];

        // Get the file path ..
        dwSize = ARRAYSIZE(szOldPath);
        *szOldPath = '\0';
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, NULL, NULL, &dwType, (LPBYTE)szOldPath, &dwSize))
        {
            if(lstrlen(szOldPath) && GetFileAttributes(szOldPath)!= 0xFFFFFFFF)
            {
                LPTSTR lp1= NULL, lp2 = NULL;

                // isolate the wab file name here
                lp1 = szOldPath;
                while(lp1 && *lp1)
                {
                    if(*lp1 == '\\')
                        lp2 = lp1;
                    lp1 = CharNext(lp1);
                }

                if(!lp2)
                    lp2 = szOldPath;
                else
                {
                    lp1 = lp2;
                    lp2 = CharNext(lp1);
                }

                StrCpyN(szFileName, lp2, ARRAYSIZE(szFileName));

                // rename the old file as an ie3 file by appending .ie3 to the end of the file name
                StrCpyN(szNewName, szOldPath, ARRAYSIZE(szNewName));
                StrCatBuff(szNewName, lpszIE3Ext, ARRAYSIZE(szNewName));

                if(MoveFile(szOldPath, szNewName))
                {
                    // Update the new name and path in the old registry setting
                    RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)szNewName, (lstrlen(szNewName)+1) * sizeof(TCHAR) );
                }
            
                StrCpyN(szOldPath, szNewName, ARRAYSIZE(szOldPath));
                *szNewName = '\0';

                // Is this in the Windows Directory ??
                *szWinPath = '\0';
                GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath));
                if(lstrlen(szWinPath) &&
                   lstrlen(szWinPath) < lstrlen(szOldPath))
                {
                    // Terminate the old file path just before the filename
                    // If the file is in the Windows directory, the remaining filename
                    // will be the same as the windows path

                    if(*lp1 == '\\') //lp1 was set above
                    {
                        // First check that the windows directory is not the root directory (e.g. C:\)
                        if(lstrlen(szWinPath) == 3 && szWinPath[1]==':' && szWinPath[2]=='\\')
                            lp1 = CharNext(lp1); // Move lp1 past the '\'
                        *lp1 = '\0';
                    }

                    if(!lstrcmpi(szOldPath, szWinPath))
                    {
                        dwSize = ARRAYSIZE(szOldPath);
                        RegQueryValueEx(hKey, NULL, 0, &dwType, (LPBYTE) szOldPath, &dwSize);

                        StrCpyN(szNewName, szDir, ARRAYSIZE(szNewName));
                        StrCatBuff(szNewName, szFileName, ARRAYSIZE(szNewName));
                        StrCatBuff(szNewName, lpszIE3Ext, ARRAYSIZE(szNewName));

                        // move this file to the new directory
                        if(MoveFile(szOldPath, szNewName))
                        {
                            // Update the newname in the registry
                            RegSetValueEx(hKey, NULL, 0, REG_SZ, (LPBYTE)szNewName, (lstrlen(szNewName)+1) * sizeof(TCHAR) );
                        }

                        StrCpyN(szOldPath, szNewName, ARRAYSIZE(szOldPath));
                    }
                }

                // Since the old WAB file exists, we will make a copy and put it in the newdir
                StrCpyN(szNewName, szDir, ARRAYSIZE(szNewName));
                StrCatBuff(szNewName, szFileName, ARRAYSIZE(szNewName));

                CopyFile(szOldPath, szNewName, TRUE);
                {
                    // if the CopyFile fails because something already exists in the new dir, still update
                    // the path to the new dir (prevent using the old file no matter what)
                    HKEY hKeyNew = NULL;
                    DWORD dwDisposition = 0;
                    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, lpszKeyName, 0, NULL, 0, KEY_ALL_ACCESS, 
                                                        NULL, &hKeyNew, &dwDisposition))
                    {
                        RegSetValueEx(hKeyNew, NULL, 0, REG_SZ, (LPBYTE)szNewName, (lstrlen(szNewName)+1) * sizeof(TCHAR) );
                    }
                    if(hKeyNew)
                        RegCloseKey(hKeyNew);
                }                                       
            }
        }
    }


    // update the first run flag
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, lpNewWABRegKey, 0, KEY_ALL_ACCESS, &hKey))
    {
        dwValue = 1;
        dwSize = sizeof(dwValue);
        if(ERROR_SUCCESS != RegSetValueEx( hKey, lpszFirstRunValue, 0, REG_DWORD, (LPBYTE) &dwValue, dwSize))
        {
            goto out;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    hKey = NULL;

    hr = S_OK;

out:

    if(hKey)
        RegCloseKey(hKey);

    return hr;
}

// Random test data .. ignore
// static OlkContInfo rgOlk[2];
// LPTSTR lp1 = "Contact Folder 1";
// LPTSTR lp2 = "Second Contact Folder";
extern void ConvertOlkConttoWABCont( ULONG * lpcolk,   OutlookContInfo ** lprgolk, 
                                     ULONG * lpcolkci, OlkContInfo ** lprgolkci);

/*
 -  OpenAddRefPropertyStore
 -
 *  Purpose:
 *      Get the property store name from the registry and open it.
 *      Addref it
 *
 *  Arguments:
 *      lpPropertyStore     PROPERTY_STORE structure
 *
 *  Returns:
 *      SCODE
 *
 *  Notes:
 *      This routine is kind of a mess with all these gotos and special cases
 *      for failed registry functions.  I'm not sure why, but the registry
 *      functions operate differently on NT and Win95, but in both cases,
 *      they sometimes act as though the key already exists even when it doesn't.
 *
 */
SCODE OpenAddRefPropertyStore(LPWAB_PARAM lpWP, LPPROPERTY_STORE lpPropertyStore) {
    HRESULT hResult = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;
    TCHAR   szFileName[MAX_PATH];
    LPTSTR  lpCurrent;
    HKEY    hKey = NULL;
    DWORD   cchLenName = ARRAYSIZE(szFileName);
    DWORD   cchCurrent = 0;
    DWORD   dwDisposition = 0;
    DWORD   dwType = 0;
    HWND    hWnd = NULL;
    ULONG   ulFlags = AB_OPEN_ALWAYS;
    LPTSTR  lpszWABExt = TEXT(".wab");
    BOOL    fNewKey = FALSE;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    szFileName[0]='\0';

    if (lpWP)
    {
        // The cbSize parameter will, in the future, tell us what version
        // of the WAB_PARAM is being called so we can upgrade the WAB_PARAM
        // structure in future releases. For this version the cbSize
        // doesnt really matter.
        hWnd = lpWP->hwnd;

        if(!lpWP->ulFlags && lpWP->szFileName )
        {
            LPWSTR lpW = ConvertAtoW(lpWP->szFileName);
            if (lpW != NULL)
            {
                lstrcpy(szFileName, lpW);
                LocalFreeAndNull(&lpW);
            }
        }

    }

    if (! lpPropertyStore->ulRefCount) {
		if (pt_bIsWABOpenExSession) {
			hResult = OpenPropertyStore(NULL, 0, hWnd,
					&(lpPropertyStore->hPropertyStore));
			if (SUCCEEDED(hResult)) 
            {
				LPWABSTORAGEPROVIDER lpWSP;
                ULONG colk = 0;
                OutlookContInfo * rgolk = NULL;
				Assert(lpPropertyStore->hPropertyStore);
				Assert(!lpPropertyStore->rgolkci);
				Assert(!lpPropertyStore->colkci);
				lpWSP = (LPWABSTORAGEPROVIDER)(lpPropertyStore->hPropertyStore);
				hResult = lpWSP->lpVtbl->GetContainerList(lpWSP, &colk, &rgolk);
                if(!HR_FAILED(hResult))
                {
    				DebugTrace(TEXT("WABStorageProvider::GetContainerList returns:%x\n"),hResult);
                    ConvertOlkConttoWABCont(&colk, &rgolk, &lpPropertyStore->colkci, &lpPropertyStore->rgolkci);
                    FreeBufferAndNull(&rgolk);
                }
                else
				{
					lpWSP->lpVtbl->Release(lpWSP);
					lpPropertyStore->hPropertyStore = NULL;
				}
			}
			if (FAILED(hResult)) {
				sc = ResultFromScode(hResult);
				goto error;
			}
            //lpPropertyStore->colkci = 2;
            //rgOlk[0].lpEntryID = rgOlk[1].lpEntryID = lpPropertyStore->rgolkci[0].lpEntryID;
            //rgOlk[0].lpszName = lp1;
            //rgOlk[1].lpszName = lp2;
            //lpPropertyStore->rgolkci = rgOlk;
			goto out;
		}

        //
        // Get the default WAB file name from the registry
        // if we don't have a name supplied in lpWP
        //
try_again:
        if(!lstrlen(szFileName))
        {
            DoFirstRunMigrationAndProcessing();

            // First, try to open an existing key
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                              lpszKeyName,
                                              0,    // options, MBZ
                                              KEY_ALL_ACCESS,
                                              &hKey))
            {
                dwDisposition = REG_OPENED_EXISTING_KEY;
            }
            else
            {
                // Create the key
                if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                                    lpszKeyName,
                                                    0,      //reserved
                                                    NULL,
                                                    REG_OPTION_NON_VOLATILE,
                                                    KEY_ALL_ACCESS,
                                                    NULL,
                                                    &hKey,
                                                    &dwDisposition))
                {
                    DebugTrace( TEXT("RegCreateKeyEx failed\n"));
                    sc = MAPI_E_NOT_FOUND; // ??
                    goto error;
                }
            }

            if (dwDisposition == REG_CREATED_NEW_KEY)
            {
new_key:
                // prevent more than one retry
                if (fNewKey)
                {
                    hResult = ResultFromScode(MAPI_E_NOT_INITIALIZED);
                    goto error;
                }
                fNewKey = TRUE;
                //
                // New key ... need to give it a value ..
                //

                // BUG - dont use windows directory for new wab files ..
                // use one of the application data directories ...
                if (GetNewDataDirName(szFileName, ARRAYSIZE(szFileName)))
                {
                    DebugTrace( TEXT("GetNewDataDirName failed\n"));
                    sc = MAPI_E_NOT_FOUND; // ??
                    goto error;
                }

                cchCurrent = lstrlen(szFileName);

                //Tag on a trailing slash if 1 doesnt exist ..
                if (szFileName[cchCurrent-1] != '\\')
                {
                    StrCatBuff(szFileName, szBackSlash, ARRAYSIZE(szFileName));
                }

                // Get a user name ...

                cchCurrent = lstrlen(szFileName);
                lpCurrent = szFileName + cchCurrent;
                cchLenName = (ARRAYSIZE(szFileName) - cchCurrent);
                if (!GetUserName(lpCurrent, &cchLenName))
                {
                    cchLenName = (ARRAYSIZE(szFileName) - cchCurrent);

                    // On failure just create some dummy file name
                    StrCpyN(lpCurrent, TEXT("AddrBook"), cchLenName);
                }

                // Fix any invalid characters in the filename
                while (*lpCurrent) {
                    switch (*lpCurrent) {
                        case '\\':
                        case '/':
                        case '<':
                        case '>':
                        case ':':
                        case '"':
                        case '|':
                        case '?':
                        case '*':
                        case '.':
                            *lpCurrent = '_';   // replace with underscore
                            break;

                        default:
                            break;
                    }

                    lpCurrent++;
                }

                StrCatBuff(szFileName, lpszWABExt, ARRAYSIZE(szFileName));

                cchLenName = sizeof(TCHAR)*lstrlen(szFileName);

                //save this as the value of the Wab file in the registry
                if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                                    NULL,
                                                    0,
                                                    REG_SZ,
                                                    (LPBYTE)szFileName,
                                                    cchLenName))
                {
                    DebugTrace( TEXT("RegSetValue failed\n"));
                    sc = MAPI_E_NOT_FOUND; // ??
                    goto error;
                }
            }
            else
            {
                // Didn't create a new key, so get the key value
                if (ERROR_SUCCESS != RegQueryValueEx(hKey,
                                                    NULL,
                                                    NULL,
                                                    &dwType,      //reserved
                                                    (LPBYTE)szFileName,
                                                    &cchLenName))
                {
                    DebugTrace( TEXT("RegSetValue failed\n"));
                    goto new_key;
                }
                else if (! lstrlen(szFileName))
                {
                    DebugTrace( TEXT("Warning: Found empty name key!\n"));
                    goto new_key;
                }

                //Check that the name in the existing key is a valid filename
                // If it is not a valid file name then we should remove it
                // from the registry and create a new default file name
                if(0xFFFFFFFF == GetFileAttributes(szFileName))
                {
                    // There is some problem with this file ...
                    // Remove it from the registry and recreate a new file name
                    // only if the path doesnt exist. Its possible that the file
                    // doesnt exist, in which case we create a new file in open
                    // property store
                    DWORD dwErr = GetLastError();
                    //NT5 bug 180007 - upgrading from Win95 to WinNT 5, if the
                    // old file name had quotes around it, CreateFile will fail and
                    // so will GetFileAttributes.
                    // Strip out the quotes and try again
                    if( (dwErr == ERROR_PATH_NOT_FOUND || dwErr == ERROR_INVALID_NAME) &&
                        lstrlen(szFileName) && szFileName[0] == '"' && szFileName[lstrlen(szFileName)-1] == '"')
                    {
                        // remove the quotes
                        szFileName[lstrlen(szFileName)-1] = '\0';
                        StrCpyN(szFileName, szFileName+1, ARRAYSIZE(szFileName));
                        if(0xFFFFFFFF != GetFileAttributes(szFileName))
                            goto open_file;
                    }
                    // otherwise some unknown error with the file name - just discard the
                    // file name and try again
                    RegCloseKey(hKey);
                    RegDeleteKey(HKEY_CURRENT_USER, lpszKeyName);
                    szFileName[0]='\0';
                    fNewKey = FALSE;
                    goto try_again;
                }
            }
        }
open_file:
        //
        // now we have the file name, open the property store
        //
        if (HR_FAILED(hResult = OpenPropertyStore(szFileName,
                                        AB_OPEN_ALWAYS,
                                        hWnd, // HWND for potential Message Boxes
                                        &(lpPropertyStore->hPropertyStore))))
        {
            // The above call should always pass unless we ran out of disk space or
            // some such thing ..
            DebugTrace( TEXT("OpenPropertyStore failed\n"));

            if(hResult == MAPI_E_NO_ACCESS)
            {
                sc = GetScode(hResult);
                goto error;
            }

            // There is a chance that this may have failed due to a long file name
            // which the machine could not accept.
            if(lstrlen(szFileName) > 8 + 1 + lstrlen(lpszWABExt)) // 8+.+3
            {
                LPTSTR lpLast = szFileName;
                LPTSTR lpTemp = szFileName;

                while(*lpTemp)
                {
                    if((*lpTemp) == '\\')
                        lpLast = lpTemp;
                    lpTemp = CharNext(lpTemp);
                }

                // lpLast points to the last \ .. everything after this will be the file name
                if(lstrlen(lpLast+1) > 12)
                {
                    // we need to truncate this name
                    *(lpLast+8) = '\0';
                    StrCatBuff(szFileName, lpszWABExt, ARRAYSIZE(szFileName));
                    hResult = OpenPropertyStore(szFileName,
                                                AB_OPEN_ALWAYS,
                                                hWnd, // HWND for potential Message Boxes
                                                &(lpPropertyStore->hPropertyStore));
                }
            }

            if(HR_FAILED(hResult))
            {
                sc = GetScode(hResult);
                goto error;
            }
        }
    }

out:
    lpPropertyStore->ulRefCount++;

error:
    if (hKey) {
        RegCloseKey(hKey);
    }


    return(sc);
}


/*
 -  ReleaseOutlookStore
 -
 *  Purpose:
 *      Keep track of outlook store dll refcount
 *
 *  Arguments:
 *      lpOutlookStore     OUTLOOK_STORE structure
 *
 *  Returns:
 *      Current reference count.  When 0, unload outlook-wab dll
 *      no longer open.
 *
 */
ULONG ReleaseOutlookStore(HANDLE hPropertyStore, LPOUTLOOK_STORE lpOutlookStore)
{
    if(lpOutlookStore)
    {
        lpOutlookStore->ulRefCount--;

        if(0==lpOutlookStore->ulRefCount)
        {
            LPPTGDATA lpPTGData=GetThreadStoragePointer();
            
            if(pt_bIsWABOpenExSession && hPropertyStore)
            {
                // This is a WABOpenEx session using outlooks storage provider
                LPWABSTORAGEPROVIDER lpWSP = (LPWABSTORAGEPROVIDER) hPropertyStore;
                lpWSP->lpVtbl->Release(lpWSP);
            }

            if(lpOutlookStore->hOutlookStore)
            {
                FreeLibrary(lpOutlookStore->hOutlookStore);
                lpOutlookStore->hOutlookStore = NULL;

#if 0
                // @todo [PaulHi] DLL Leak.  Remove this or implement
                // [PaulHi] 3/12/99  @hack Serious HACK warning
                // The Outlook outlwab.dll store module is not unloading some Outlook
                // dlls.  This causes Outlook to get confused about who loaded these dlls
                // and whether Outlook or OE should service MAPI calls.  
                // HACK Forcibly remove these dlls HACK
                // But only if the WAB WASN'T opened by OL process.
                EnterCriticalSection(&csOMIUnload);
                if (!s_bIsReallyOnlyWABOpenExSession)
                {
                    LPCSTR      c_lpszOMI9DLL = "omi9.dll";
                    LPCSTR      c_lpszOMI9PSTDLL = "omipst9.dll";
                    LPCSTR      c_lpszOMINTDLL = "omint.dll";
                    LPCSTR      c_lpszOMINTPSTDLL = "omipstnt.dll";
                    HINSTANCE   hinst;

                    // It is essential to unload the omipst9.dll and omipstnt.dll
                    // modules first because they load the omi9.dll and omint.dll
                    // modules.  The FreeLibary() on the omi9/omint modules should
                    // not be necessary.
                    if ( hinst = GetModuleHandleA(c_lpszOMI9PSTDLL) )
                        FreeLibrary(hinst);

                    if ( hinst = GetModuleHandleA(c_lpszOMINTPSTDLL) )
                        FreeLibrary(hinst);

                    if ( hinst = GetModuleHandleA(c_lpszOMI9DLL) )
                        FreeLibrary(hinst);

                    if ( hinst = GetModuleHandleA(c_lpszOMINTDLL) )
                        FreeLibrary(hinst);
                }
                LeaveCriticalSection(&csOMIUnload);
#endif
            }
        }

        return lpOutlookStore->ulRefCount;
    }

    return 0;
}


/*
 -  OpenAddRefOutlookStore
 -
 *  Purpose:
 *      Open or ref count outlook-wab dll
 *
 *  Arguments:
 *      lpOutlookStore     OUTLOOK_STORE structure
 *
 *  Returns:
 *      
 */
SCODE OpenAddRefOutlookStore(LPOUTLOOK_STORE lpOutlookStore)
{
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(!lpOutlookStore)
        return(MAPI_E_INVALID_PARAMETER);

    if(!lpOutlookStore->ulRefCount)
    {
        TCHAR szOutlWABPath[MAX_PATH];
        *szOutlWABPath = '\0';
        if (!bCheckForOutlookWABDll(szOutlWABPath, ARRAYSIZE(szOutlWABPath)) ||
            !lstrlen(szOutlWABPath) ||
            !(lpOutlookStore->hOutlookStore = LoadLibrary(szOutlWABPath)) )
            return MAPI_E_NOT_INITIALIZED;

        // Load the Outlook WABStorageProvider Dll Entry Point here

        // First try to load the Unicode version (doesn't exist but we're thinking forward here)
        lpfnWABOpenStorageProvider = (LPWABOPENSTORAGEPROVIDER) GetProcAddress(lpOutlookStore->hOutlookStore, WAB_SPI_ENTRY_POINT_W);
        if(lpfnWABOpenStorageProvider)
            pt_bIsUnicodeOutlook = TRUE;
        else
        {
            pt_bIsUnicodeOutlook = FALSE;
            lpfnWABOpenStorageProvider = (LPWABOPENSTORAGEPROVIDER) GetProcAddress(lpOutlookStore->hOutlookStore, WAB_SPI_ENTRY_POINT);
        }
    }

    if(lpfnWABOpenStorageProvider && lpOutlookStore->hOutlookStore)
    {
        // Tag this thread as a valid Outlook store session
        // If this flag below is false, we willd default to 
        // using the WAB store 
        pt_bIsWABOpenExSession = TRUE; 
    }

    lpOutlookStore->ulRefCount++;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink
#define USES_IID_IWABExtInit

#define USES_PS_MAPI
#define USES_PS_PUBLIC_STRINGS


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
#include "_apipch.h"

#include <imnxport.h>       // required for transports for syncing
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\w9xwraps.h ===
/*****************************************************************************\
*                                                                             *
* w9xwraps.h - Unicode wrappers for ANSI functions on Win9x                   *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1998, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

//
//  This file is for internal use only.  Do not put it in the SDK.
//

#ifndef _INC_W9XWRAPS
#define _INC_W9XWRAPS

#ifndef  DONOT_USE_WRAPPER

#define RegOpenKeyExW                RegOpenKeyExWrapW
#define RegQueryValueW               RegQueryValueWrapW
#define RegEnumKeyExW                RegEnumKeyExWrapW
#define RegSetValueW                 RegSetValueWrapW
#define RegDeleteKeyW                RegDeleteKeyWrapW
#define GetUserNameW                 GetUserNameWrapW
#define RegEnumValueW                RegEnumValueWrapW
#define RegDeleteValueW              RegDeleteValueWrapW
#define RegCreateKeyW                RegCreateKeyWrapW
//#define CryptAcquireContextW         CryptAcquireContextWrapW
#define RegQueryValueExW             RegQueryValueExWrapW
#define RegCreateKeyExW              RegCreateKeyExWrapW
#define RegSetValueExW               RegSetValueExWrapW
#define RegQueryInfoKeyW             RegQueryInfoKeyWrapW
#define GetObjectW                   GetObjectWrapW
#define StartDocW                    StartDocWrapW
#define CreateFontIndirectW          CreateFontIndirectWrapW
#define GetLocaleInfoW               GetLocaleInfoWrapW
#define CreateDirectoryW             CreateDirectoryWrapW
#define GetWindowsDirectoryW         GetWindowsDirectoryWrapW
#define GetSystemDirectoryW          GetSystemDirectoryWrapW
#define GetProfileIntW               GetProfileIntWrapW
#define LCMapStringW                 LCMapStringWrapW
#define GetFileAttributesW           GetFileAttributesWrapW
#define CompareStringW              CompareStringWrapW
#define GetStringTypeW              GetStringTypeWrapW
#define lstrcpyW                     lstrcpyWrapW
#define lstrcmpiW                    lstrcmpiWrapW
#define LoadLibraryW                 LoadLibraryWrapW
#define GetTimeFormatW               GetTimeFormatWrapW
#define GetTextExtentPoint32W        GetTextExtentPoint32WrapW
#define GetDateFormatW               GetDateFormatWrapW
#define lstrcpynW                    lstrcpynWrapW
#define CreateFileW                  CreateFileWrapW
#define OutputDebugStringW           OutputDebugStringWrapW
#define lstrcatW                     lstrcatWrapW
#define FormatMessageW               FormatMessageWrapW
#define GetModuleFileNameW           GetModuleFileNameWrapW
#define GetPrivateProfileIntW        GetPrivateProfileIntWrapW
#define IsBadStringPtrW              IsBadStringPtrWrapW
#define GetPrivateProfileStringW     GetPrivateProfileStringWrapW
#define lstrcmpW                     lstrcmpWrapW
#define CreateMutexW                 CreateMutexWrapW
#define GetTempPathW                 GetTempPathWrapW
#define ExpandEnvironmentStringsW    ExpandEnvironmentStringsWrapW
#define GetTempFileNameW             GetTempFileNameWrapW
#define DeleteFileW                  DeleteFileWrapW
#define CopyFileW                    CopyFileWrapW
#define FindFirstChangeNotificationW FindFirstChangeNotificationWrapW
#define FindFirstFileW               FindFirstFileWrapW
#define GetDiskFreeSpaceW            GetDiskFreeSpaceWrapW
#define MoveFileW                    MoveFileWrapW
#define ShellExecuteW                ShellExecuteWrapW
#define DragQueryFileW               DragQueryFileWrapW
#define CharPrevW                    CharPrevWrapW
#define DrawTextW                    DrawTextWrapW
#define ModifyMenuW                  ModifyMenuWrapW
#define InsertMenuW                  InsertMenuWrapW
#define LoadImageW                   LoadImageWrapW
#define GetClassInfoExW              GetClassInfoExWrapW
#define LoadStringW                  LoadStringWrapW
#define CharNextW                    CharNextWrapW
#define SendMessageW                 SendMessageWrapW
#define DefWindowProcW               DefWindowProcWrapW
#define DialogBoxParamW              DialogBoxParamWrapW
#define SendDlgItemMessageW          SendDlgItemMessageWrapW
#define SetWindowLongW               SetWindowLongWrapW
#define GetWindowLongW               GetWindowLongWrapW
#define CreateWindowExW              CreateWindowExWrapW
#define UnRegisterClassW             UnRegisterClassWrapW
#define RegisterClassW               RegisterClassWrapW
#define LoadCursorW                  LoadCursorWrapW
#define wsprintfW                    wsprintfWrapW
#define wvsprintfW                   wvsprintfWrapW
#define RegisterWindowMessageW       RegisterWindowMessageWrapW
#define SystemParametersInfoW        SystemParametersInfoWrapW
#define CreateDialogParamW           CreateDialogParamWrapW
#define SetWindowTextW               SetWindowTextWrapW
#define PostMessageW                 PostMessageWrapW
#define GetMenuItemInfoW             GetMenuItemInfoWrapW
#define GetClassInfoW                GetClassInfoWrapW
#define CharUpperW                   CharUpperWrapW
#define CharUpperBuffW               CharUpperBuffWrapW
#define CharLowerW                   CharLowerWrapW
#define CharLowerBuffW               CharLowerBuffWrapW
#define IsCharUpperW                 IsCharUpperWrapW
#define IsCharLowerW                 IsCharLowerWrapW
#define RegisterClipboardFormatW     RegisterClipboardFormatWrapW
#define DispatchMessageW             DispatchMessageWrapW
#define IsDialogMessageW             IsDialogMessageWrapW
#define GetMessageW                  GetMessageWrapW
#define SetDlgItemTextW              SetDlgItemTextWrapW
#define RegisterClassExW             RegisterClassExWrapW
#define LoadAcceleratorsW            LoadAcceleratorsWrapW
#define LoadMenuW                    LoadMenuWrapW
#define LoadIconW                    LoadIconWrapW
#define GetWindowTextW               GetWindowTextWrapW
#define CallWindowProcW              CallWindowProcWrapW
#define GetClassNameW                GetClassNameWrapW
#define TranslateAcceleratorW        TranslateAcceleratorWrapW
#define GetDlgItemTextW              GetDlgItemTextWrapW
#define SetMenuItemInfoW             SetMenuItemInfoWrapW
#define PeekMessageW                 PeekMessageWrapW
#define GetWindowTextLengthW         GetWindowTextLengthWrapW
#define CreateEventW                 CreateEventWrapW

// for RunTime loaded functions in Comctl32.dll

#define gpfnImageList_LoadImage      gpfnImageList_LoadImageWrapW
#define gpfnPropertySheet            gpfnPropertySheetWrapW
#define gpfnCreatePropertySheetPage  gpfnCreatePropertySheetPageWrapW

// for APIs in Commdlg32.dll

#define pfnGetOpenFileName           pfnGetOpenFileNameWrapW
#define pfnGetSaveFileName           pfnGetSaveFileNameWrapW 

#define pfnPrintDlgEx                pfnPrintDlgExWrapW
#define pfnPrintDlg                  pfnPrintDlgWrapW

#endif  // DONOT_USER_WRAPPER

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabimprt.c ===
/*
-
-
-   WABImprt.c - Contains code for importing another WAB into the currently opened WAB
*
*
*/
#include "_apipch.h"

/*
-
-   PromptForWABFile 
*
*   Shows the OpenFileName dialog to prompt for the WAB file to import
*   <TBD>:Cache the last imported WAB file in the registry
*
*   bOpen - if TRUE, calls GetOpenFileName; if false, calls GetSaveFileName
*/
BOOL PromptForWABFile(HWND hWnd, LPTSTR pszFile, DWORD cchSizeFile, BOOL bOpen)
{
    OPENFILENAME ofn;
    LPTSTR lpFilter = FormatAllocFilter(idsWABImportString, TEXT("*.WAB"),0,NULL,0,NULL);
    TCHAR szFileName[MAX_PATH + 1] =  TEXT("");
    TCHAR szTitle[MAX_PATH] =  TEXT("");
    BOOL bRet = FALSE;

    LoadString( hinstMapiX, bOpen ? idsSelectWABToImport : idsSelectWABToExport, szTitle, ARRAYSIZE(szTitle));
    
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hinstMapiX;
    ofn.lpstrFilter = lpFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = ARRAYSIZE(szFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt =  TEXT("wab");
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if(bOpen)
        bRet = GetOpenFileName(&ofn);
    else

        bRet = GetSaveFileName(&ofn);

    if(bRet)
        StrCpyN(pszFile, szFileName, cchSizeFile);

    LocalFreeAndNull(&lpFilter);

    return bRet;
}


/*
- MapOldNamedPropsToNewNamedProps
-
*   Takes all the props from the wab being imported and finds or creates appropriate
*   named props from the store being imported into
*   *lpulOldNP and *lpulNewNP are LocalAlloced and should be freed by caller

typedef struct _NamedProp
{
    ULONG   ulPropTag;  // Contains the proptag for this named prop
    LPTSTR  lpsz;       // Contains the string for this named prop
} NAMED_PROP, * LPNAMED_PROP;
typedef struct _tagGuidNamedProps
{
    LPGUID lpGUID;  // Application GUID for which these named props are
    ULONG cValues;  // Number of entries in the lpmn array
    LPNAMED_PROP lpnm;  // Array of Named Props for this Guid.
} GUID_NAMED_PROPS, * LPGUID_NAMED_PROPS;

*/
HRESULT MapOldNamedPropsToNewNamedProps(HANDLE hPropertyStore, LPADRBOOK lpAdrBook, ULONG * lpulPropCount,
                                        LPULONG * lppulOldNP, LPULONG * lppulNewNP)
{
    ULONG ulcGUIDCount = 0,i=0,j=0,ulCount=0;
    LPGUID_NAMED_PROPS lpgnp = NULL;
    HRESULT hr = S_OK;
    LPULONG lpulOldNP = NULL, lpulNewNP = NULL;
    ULONG ulcOldNPCount = 0;
    LPSPropTagArray lpta = NULL;
    LPMAPINAMEID * lppPropNames = NULL;
    SCODE sc ;

    if(HR_FAILED(hr = GetNamedPropsFromPropStore(hPropertyStore, &ulcGUIDCount, &lpgnp)))
        goto exit;

    if(ulcGUIDCount)
    {
        for(i=0;i<ulcGUIDCount;i++)
            ulcOldNPCount += lpgnp[i].cValues;
    
        lpulOldNP = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ulcOldNPCount);
        lpulNewNP = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ulcOldNPCount);

        if(!lpulOldNP || !lpulNewNP)
        {
            hr = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        ulCount = 0;
        for(i=0;i<ulcGUIDCount;i++)
        {
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                lpulOldNP[ulCount++] = lpgnp[i].lpnm[j].ulPropTag;
            }
        }

        sc = MAPIAllocateBuffer(sizeof(LPMAPINAMEID) * ulcOldNPCount, (LPVOID *) &lppPropNames);
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto exit;
        }

        ulCount = 0;
        for(i=0;i<ulcGUIDCount;i++)
        {
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                if(sc = MAPIAllocateMore(sizeof(MAPINAMEID), lppPropNames, &(lppPropNames[ulCount])))
                {
                    hr = ResultFromScode(sc);
                    goto exit;
                }
                lppPropNames[ulCount]->lpguid = lpgnp[i].lpGUID;
                lppPropNames[ulCount]->ulKind = MNID_STRING;

                {
                    int nSize = lstrlen(lpgnp[i].lpnm[j].lpsz);
                    if(!nSize)
                        continue;
                    else
                    {
                        nSize++;
                        if(sc = MAPIAllocateMore(sizeof(WCHAR)*nSize, lppPropNames, &(lppPropNames[ulCount]->Kind.lpwstrName)))
                        {
                            hr = ResultFromScode(sc);
                            goto exit;
                        }
                    }
                    StrCpyN(lppPropNames[ulCount]->Kind.lpwstrName,lpgnp[i].lpnm[j].lpsz, nSize);
                    ulCount++;
                }
            }
        }

        // [PaulHi] 3/25/99  Use the actual count of the lppPropNames array, or we will walk off
        // into unknown memory and crash.
        ulcOldNPCount = ulCount;
        hr = lpAdrBook->lpVtbl->GetIDsFromNames(lpAdrBook, ulcOldNPCount, lppPropNames, MAPI_CREATE, &lpta);
        if(HR_FAILED(hr))
            goto exit;

        // Note that of the tags that are returned, we don't know the tag type .. this we will have
        // to infer based on the original tags when we see them being used

        ulCount = 0;
        for(i=0;i<ulcGUIDCount;i++)
        {
            for(j=0;j<lpgnp[i].cValues;j++)
            {
                lpulNewNP[ulCount++] = lpta->aulPropTag[ulCount];
            }
        }
    }

    *lppulNewNP = lpulNewNP;
    *lppulOldNP = lpulOldNP;
    *lpulPropCount = ulcOldNPCount;

    hr = S_OK;
exit:

    if(lpta)
        MAPIFreeBuffer(lpta);

    if(lppPropNames)
        MAPIFreeBuffer(lppPropNames);

    if(HR_FAILED(hr))
    {
        LocalFreeAndNull(&lpulNewNP);
        LocalFreeAndNull(&lpulOldNP);
    }

    FreeGuidnamedprops(ulcGUIDCount, lpgnp);
    
    return hr;
}

/***************************************************************************
****************************************************************************/
void ChangeOldNamedPropsToNewNamedProps(ULONG ulcProps, LPSPropValue lpProps, 
                                           ULONG ulcNPCount, ULONG * lpulOldNP, ULONG *lpulNewNP)
{
    ULONG i,j;
    for(i=0;i<ulcProps;i++)
    {
        ULONG ulPropId = PROP_ID(lpProps[i].ulPropTag);
        if(ulPropId >= 0x8000) //this is a named prop
        {
            ULONG ulType = PROP_TYPE(lpProps[i].ulPropTag);
            for(j=0;j<ulcNPCount;j++)
            {
                if(ulPropId == PROP_ID(lpulOldNP[j]))
                {
                    lpProps[i].ulPropTag = CHANGE_PROP_TYPE(lpulNewNP[j], ulType);
                    break;
                }
            }
        }
    }
    return;
}


enum
{
    eidOld=0,
    eidTemp,
    eidNew,
    eidMax
};

void SetTempSBinary(LPSBinary lpsbTemp, LPSBinary lpsbOld)
{
    DWORD dwTemp = 0;
    if(lpsbOld->cb != SIZEOF_WAB_ENTRYID)
    {
        // perhaps this is a Folder EID in it's formal proper form ..
        // We should try to reduce it to a DWORD...
        // this may be a WAB container .. reset the entryid to a WAB entryid
        if(WAB_CONTAINER == IsWABEntryID(lpsbTemp->cb, (LPENTRYID)lpsbTemp->lpb, 
                                        NULL,NULL,NULL,NULL,NULL))
        {
            SBinary sbEID = {0};
            IsWABEntryID(lpsbTemp->cb, (LPENTRYID)lpsbTemp->lpb, 
                             (LPVOID*)&sbEID.lpb,(LPVOID*)&sbEID.cb,NULL,NULL,NULL);
            if(sbEID.cb == SIZEOF_WAB_ENTRYID)
                CopyMemory(&dwTemp, sbEID.lpb, min(sbEID.cb, sizeof(dwTemp)));
            else return;
        }
    }
    else
        CopyMemory(&dwTemp, lpsbOld->lpb, min(lpsbOld->cb, sizeof(dwTemp)));
    dwTemp = 0xFFFFFFFF - dwTemp;
    SetSBinary(lpsbTemp, lpsbOld->cb, (LPBYTE)&dwTemp);
}

/*
- GetNewEID
-
*   Finds a new entryid or a temp entryid for a given old entryid
*   When bTemp is true, only looks in the temp entryid column 
*/
LPSBinary GetNewEID(LPSBinary lpsbOldEID, DWORD dwCount, LPSBinary * lppsbEIDs, BOOL bTemp)
{
    DWORD dw = 0;

    while(lppsbEIDs[eidOld][dw].cb && dw < dwCount)
    {
        if( lppsbEIDs[eidOld][dw].cb == lpsbOldEID->cb && // if it's an old eid, return a new or a temp
            !memcmp(lppsbEIDs[eidOld][dw].lpb, lpsbOldEID->lpb, lpsbOldEID->cb))
        {
            if(bTemp)
                return lpsbOldEID;

            if(lppsbEIDs[eidNew][dw].cb)
                return &(lppsbEIDs[eidNew][dw]);
            else if(lppsbEIDs[eidTemp][dw].cb)
                return &(lppsbEIDs[eidTemp][dw]);
            else
                return lpsbOldEID;
        }
        else 
        if( lppsbEIDs[eidTemp][dw].cb == lpsbOldEID->cb && // if it's an old eid, return a new or a temp
            !memcmp(lppsbEIDs[eidTemp][dw].lpb, lpsbOldEID->lpb, lpsbOldEID->cb))
        {
            if(lppsbEIDs[eidNew][dw].cb)
                return &(lppsbEIDs[eidNew][dw]);
            else
                return lpsbOldEID;
        }
        dw++;
    }
    // if we reached here, then we haven't cached an appropriate temp or new eid for the current one
    // so add the current one to this table
    if(dw<dwCount && !lppsbEIDs[eidOld][dw].cb)
    {
        SetSBinary(&(lppsbEIDs[eidOld][dw]), lpsbOldEID->cb, lpsbOldEID->lpb);
        SetTempSBinary(&(lppsbEIDs[eidTemp][dw]), lpsbOldEID);
        return(&(lppsbEIDs[eidTemp][dw]));
    }
    return lpsbOldEID;
}

/*
-   SetNewEID
-
*
*/
void SetNewEID(LPSBinary lpsbOldEID, LPSBinary lpsbNewEID, DWORD dwCount, LPSBinary * lppsbEIDs)
{
    DWORD dw = 0;

    while(lppsbEIDs[eidOld][dw].cb && dw < dwCount)
    {
        if( lppsbEIDs[eidOld][dw].cb == lpsbOldEID->cb && // if it's an old eid, return a new or a temp
            !memcmp(lppsbEIDs[eidOld][dw].lpb, lpsbOldEID->lpb, lpsbOldEID->cb))
        {
            SetSBinary(&(lppsbEIDs[eidNew][dw]), lpsbNewEID->cb, lpsbNewEID->lpb);
            if(!lppsbEIDs[eidTemp][dw].cb)
                SetTempSBinary(&(lppsbEIDs[eidTemp][dw]), lpsbOldEID);
            return;
        }
        dw++;
    }
    if(dw<dwCount && !lppsbEIDs[eidOld][dw].cb)
    {
        SetSBinary(&lppsbEIDs[eidOld][dw], lpsbOldEID->cb, lpsbOldEID->lpb);
        SetSBinary(&lppsbEIDs[eidNew][dw], lpsbNewEID->cb, lpsbNewEID->lpb);
        SetTempSBinary(&(lppsbEIDs[eidTemp][dw]), lpsbOldEID);
    }
}

/*
-
-   Replace EID
*
*/
void ReplaceEID(LPSBinary lpsb, LPSPropValue lpProps, DWORD dwCount, LPSBinary * lppsbEIDs, BOOL bTemp)
{
    LPSBinary lpsbOldEID = lpsb;
    LPSBinary lpsbNewEID = GetNewEID(lpsbOldEID, dwCount, lppsbEIDs, bTemp);

    if(lpsbOldEID == lpsbNewEID)
        return;

    if(lpsbOldEID->cb != lpsbNewEID->cb)
    {
        if(!bTemp)
        {
            // this is a prop array read from a WAB file using readrecord
            LocalFree(lpsbOldEID->lpb);
            lpsbOldEID->lpb = LocalAlloc(LMEM_ZEROINIT, lpsbNewEID->cb);
        }
        else
        {
            // this was called from GetProps and is a MAPI Array
            lpsbOldEID->lpb = NULL;
            MAPIAllocateMore(lpsbNewEID->cb, lpProps, (LPVOID *) (&(lpsbOldEID->lpb)));
        }
    }
    if(lpsbOldEID->lpb)
    {
        lpsbOldEID->cb = lpsbNewEID->cb;
        CopyMemory(lpsbOldEID->lpb, lpsbNewEID->lpb, lpsbNewEID->cb);
    }
}

/*
- UpdateEntryIDReferences
-
*   Updates entryids in the given prop array
*
*   The first time the function is called, btemp is FALSE and we replace all EIDs in the
*   array with temp or new eids
*   The second time this function is called, bTemp is TRUE and we replace all temp EIDS in
*   the array with the new EIDs
*
*/
void UpdateEntryIDReferences(ULONG ulcProps, LPSPropValue lpProps, DWORD dwCount, LPSBinary * lppsbEIDs, BOOL bTemp)
{
    ULONG i, j, k, l;

    ULONG ulEntryIDTags[] = 
    {
        PR_WAB_DL_ENTRIES,
        PR_WAB_FOLDER_PARENT,
        PR_WAB_FOLDER_PARENT_OLDPROP,
        PR_WAB_USER_SUBFOLDERS,
    };
    DWORD dwEntryIDTagCount = 4; //keep in sync with above array
    

    for(i=0;i<ulcProps;i++)
    {
        ULONG ulType = PROP_TYPE(lpProps[i].ulPropTag);
        // Props containing entryids will be of Binary or MV_Binary type
        if(ulType == PT_BINARY || ulType == PT_MV_BINARY)
        {
            // Check against the known set of props dealing with entryids
            for(j=0;j<dwEntryIDTagCount;j++)
            {
                if(lpProps[i].ulPropTag == ulEntryIDTags[j])
                {
                    LPSBinary lpsbOldEID = NULL, lpsbNewEID = NULL;

                    switch(ulType)
                    {
                    case PT_BINARY:
                        //if(lpProps[i].Value.bin.cb == SIZEOF_WAB_ENTRYID)
                        {
                            ReplaceEID(&(lpProps[i].Value.bin), lpProps, dwCount, lppsbEIDs, bTemp);
                        }
                        break;
                    case PT_MV_BINARY:
                        for(k=0;k<lpProps[i].Value.MVbin.cValues;k++)
                        {
                            //if(lpProps[i].Value.MVbin.lpbin[k].cb == SIZEOF_WAB_ENTRYID)
                            {
                                ReplaceEID(&(lpProps[i].Value.MVbin.lpbin[k]), lpProps, dwCount, lppsbEIDs, bTemp);
                            }
                        }
                        break;
                    }
                    break;
                }
            }
        }
    }
}



/***************************************************************************

    Name      : HrImportWABFile

    Purpose   : Merges an external WAB file with the current on

    Parameters: hwnd = hwnd
                lpIAB -> IAddrBook object
                ulFlags = 0 or MAPI_DIALOG - MAPI_DIALOG means show msgs and progress bar
                lpszFileName - file name to open, if 0 prompts with GetOpenFileName dialog
    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT HrImportWABFile(HWND hWnd, LPADRBOOK lpAdrBook, ULONG ulFlags, LPTSTR lpszFileName)
{
    LPIAB lpIAB = (LPIAB) lpAdrBook;
    BOOL bFoldersImported = FALSE;
    HRESULT hr = E_FAIL;
    HRESULT hrDeferred = S_OK;
    TCHAR szWABFile[MAX_PATH+1] = TEXT("");
    TCHAR szFile[MAX_PATH+1] = TEXT(""), szPath[MAX_PATH] = TEXT("");
    HANDLE hPropertyStore = NULL;
    DWORD dwWABEntryCount = 0;
    LPSBinary * lppsbWABEIDs = NULL;
    ULONG ulcNPCount = 0;
    LPULONG lpulOldNP = NULL,lpulNewNP = NULL;
    ULONG i,j,k,n;
    BOOL bShowUI = (hWnd && (ulFlags & MAPI_DIALOG));
    
    ULONG rgObj[] = { MAPI_MAILUSER, MAPI_DISTLIST, MAPI_ABCONT };
#ifdef IMPORT_FOLDERS
#define ulrgObjMax 3
#else
#define ulrgObjMax 2
#endif

    SBinary sbPAB = {0};

    SPropertyRestriction PropRes = {0};
    //HCURSOR hOldCur = NULL;
    SPropValue sp = {0};
    ULONG ulcOldProps = 0;
    LPSPropValue lpOldProps = NULL;
    LPMAPIPROP lpObject = NULL;

    ULONG ulEIDCount = 0;
    LPSBinary rgsbEntryIDs = NULL;

    TCHAR szBuf[MAX_UI_STR];
    LPPTGDATA lpPTGData=GetThreadStoragePointer();

    if(lpszFileName && lstrlen(lpszFileName))
        StrCpyN(szWABFile, lpszFileName, ARRAYSIZE(szWABFile));
    else if (!PromptForWABFile(hWnd, szWABFile, ARRAYSIZE(szWABFile), TRUE))
    {
        hr = MAPI_E_USER_CANCEL;   
        goto exit;
    }

    //hOldCur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // when importing old format files, there is always a possibility that the file data may get
    // munged when opening the file ..
    // therefore, before we attempt to import it, we will try to make a copy of the file
    if(GetFileAttributes(szWABFile) == 0xFFFFFFFF)
        goto exit;
    if (!GetTempPath(ARRAYSIZE(szPath), szPath))
        goto exit;
    if(!GetTempFileName(szPath, TEXT("WAB"), 0, szFile))
        goto exit;
    if(!CopyFile(szWABFile, szFile, FALSE))
        goto exit;
    if(GetFileAttributes(szFile) == 0xFFFFFFFF)
        goto exit;

    // First let's open this file
    hr = OpenPropertyStore(szFile, AB_OPEN_EXISTING | AB_DONT_RESTORE | AB_IGNORE_OUTLOOK, hWnd, &hPropertyStore);

    if(HR_FAILED(hr) || (!hPropertyStore))
    {
        //if(bShowUI)
        //    ShowMessageBoxParam(hWnd, IDE_VCARD_IMPORT_FILE_ERROR, MB_ICONEXCLAMATION, szFile);
        goto exit;
    }

    // get a count of how many entries exist in this new .wab file
    if(!(dwWABEntryCount = GetWABFileEntryCount(hPropertyStore)))
    {
        hr = S_OK;
        goto exit;
    }

    if(bShowUI)
    {
        EnableWindow(hWnd, FALSE);
        CreateShowAbortDialog(hWnd, idsImporting, IDI_ICON_IMPORT, dwWABEntryCount*2 + 1, 0);
    }

    if(lppsbWABEIDs = LocalAlloc(LMEM_ZEROINIT, sizeof(LPSBinary) * eidMax))
    {
        for(i=0;i<eidMax;i++)
        {
            lppsbWABEIDs [i] = LocalAlloc(LMEM_ZEROINIT, sizeof(SBinary) * dwWABEntryCount);
            if(!lppsbWABEIDs [i])
            {
                hr = MAPI_E_NOT_ENOUGH_MEMORY;
                goto exit;
            }
        }
    }
    else
    {
        hr = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }


    // Before we start doing anything we need to get the appropriate named properties
    // from the importee so that we can correctly map them to stuff in the new store ..
    // By calling GetIDsFromNames, all the old GUIDs etc will automatically be migrated into the
    // final file from the importee
    if(HR_FAILED(hr = MapOldNamedPropsToNewNamedProps(hPropertyStore, lpAdrBook, &ulcNPCount, 
                                                        &lpulOldNP, &lpulNewNP)))
        goto exit;

    if(HR_FAILED(lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &sbPAB.cb, (LPENTRYID *)&sbPAB.lpb)))
        goto exit;

    for(n=0;n<ulrgObjMax;n++) 
    {
        // Next we want to get a list of all the contacts in the WAB ...
        PropRes.ulPropTag = PR_OBJECT_TYPE;
        PropRes.relop = RELOP_EQ;
        sp.ulPropTag = PR_OBJECT_TYPE;
        sp.Value.l = rgObj[n];
        PropRes.lpProp = &sp;

        // skip doing folders for Outlook
        if(pt_bIsWABOpenExSession && rgObj[n]==MAPI_ABCONT)
            continue;

        if(HR_FAILED(hr = FindRecords(hPropertyStore, NULL, AB_IGNORE_OUTLOOK, TRUE, &PropRes, &ulEIDCount, &rgsbEntryIDs)))
            goto exit;

        if(bTimeToAbort())
        {
            hr = MAPI_E_USER_CANCEL;
            goto exit;
        }

        // Now that we have a list of all contacts we want to open them one by one and
        //  - change named props to new named props
        //  - tag all existing entryid properties in it
        //  - remove existing entryid from it
        //  - do a save changes with create merge
        //  - get the new entryid and cache it
        //
        for(i=0;i<ulEIDCount;i++)
        {
            SBinary sbOldEID = {0};
            SBinary sbNewEID = {0};
            BOOL bIsFolderMember = FALSE;

            if(bTimeToAbort())
            {
                hr = MAPI_E_USER_CANCEL;
                goto exit;
            }

            if(HR_FAILED(hr = ReadRecord(hPropertyStore, &rgsbEntryIDs[i], AB_IGNORE_OUTLOOK, &ulcOldProps, &lpOldProps)))
                continue; // ignore errors

            // just make sure no container has snuck in here
            if(rgObj[n] != MAPI_ABCONT)
            {
                for(j=0;j<ulcOldProps;j++)
                {
                    if( lpOldProps[j].ulPropTag == PR_OBJECT_TYPE && 
                        lpOldProps[j].Value.l == MAPI_ABCONT)
                    {
                        goto endofthisloop;
                    }
                }
            }

            for(j=0;j<ulcOldProps;j++)
            {
                if(lpOldProps[j].ulPropTag == PR_DISPLAY_NAME)
                {
                    if(bShowUI)
                        SetPrintDialogMsg(0, idsImportingName, lpOldProps[j].Value.LPSZ);
                }
                if(lpOldProps[j].ulPropTag == PR_WAB_FOLDER_PARENT_OLDPROP && PR_WAB_FOLDER_PARENT)
                    lpOldProps[j].ulPropTag = PR_WAB_FOLDER_PARENT;

                if(lpOldProps[j].ulPropTag == PR_WAB_FOLDER_PARENT)
                {
#ifdef IMPORT_FOLDERS
                    bIsFolderMember = TRUE;
#else
                    // remove any folder parent info on this entry
                    ULONG k = 0;
                    lpOldProps[j].ulPropTag = PR_NULL;
                    for(k=0;k<lpOldProps[j].Value.MVbin.cValues;k++)
                        LocalFreeAndNull((LPVOID *) (&(lpOldProps[j].Value.MVbin.lpbin[k].lpb)));
                    LocalFreeAndNull((LPVOID *) (&(lpOldProps[j].Value.MVbin.lpbin)));
#endif
                }
            }

            // Scan these props and change any old named props in them
            ChangeOldNamedPropsToNewNamedProps(ulcOldProps, lpOldProps, ulcNPCount, lpulOldNP, lpulNewNP);

            // Update any references to entryids in any of the properties
            UpdateEntryIDReferences(ulcOldProps, lpOldProps, dwWABEntryCount, lppsbWABEIDs, FALSE);

            // negate the old eid after caching it
            for(j=0;j<ulcOldProps;j++)
            {
                if(lpOldProps[j].ulPropTag == PR_ENTRYID)
                {
                    Assert(lpOldProps[j].Value.bin.cb == SIZEOF_WAB_ENTRYID);
                    SetSBinary(&sbOldEID, lpOldProps[j].Value.bin.cb, lpOldProps[j].Value.bin.lpb);
                    LocalFreeAndNull((LPVOID *) (&(lpOldProps[j].Value.bin.lpb)));
                    lpOldProps[j].Value.bin.cb = 0;
                    lpOldProps[j].ulPropTag = PR_NULL;
                    break;
                }
            }

#ifdef IMPORT_FOLDERS
            // if these are containers, they may have ProfileIDs in them .. negate the profile ids
            // to some random number so they don't cause problems with the existing profile ids in this contact
            if(rgObj[n]==MAPI_ABCONT)
            {
                bFoldersImported = TRUE;
                bIsFolderMember = FALSE; //folders shouldnt end up nested.. all should be at top level
                for(j=0;j<ulcOldProps;j++)
                {
                    if( lpOldProps[j].ulPropTag == PR_WAB_USER_PROFILEID )
                    {
                        // This is some kind of user-folder .. well we don't know how this relates
                        // to the users of the WAB into which this is being imported, so we hide this value
                        lpOldProps[j].ulPropTag = PR_NULL;
                        LocalFreeAndNull(&(lpOldProps[j].Value.LPSZ));
                        // If we were importing a User Folder, and there is no current user, this folder
                        // is going to get lost .. so instead we set the SHARED flag to true on it and it
                        // will show up under Shared Contacts
                        if(!bIsThereACurrentUser(lpIAB) && bDoesThisWABHaveAnyUsers(lpIAB))
                        {
                            lpOldProps[j].ulPropTag = PR_WAB_SHAREDFOLDER;
                            lpOldProps[j].Value.l = FOLDER_SHARED;
                        }
                    }
                    else
                    if( lpOldProps[j].ulPropTag == PR_WAB_FOLDEROWNER) // folder-owner info is meaningless here ..
                    {
                        lpOldProps[j].ulPropTag = PR_NULL;
                        LocalFreeAndNull(&(lpOldProps[j].Value.LPSZ));
                    }
                    else
                    if( lpOldProps[j].ulPropTag == PR_WAB_FOLDER_PARENT) // don't want a folder parent here.
                    {
                        ULONG k = 0;
                        lpOldProps[j].ulPropTag = PR_NULL;
                        for(k=0;k<lpOldProps[j].Value.MVbin.cValues;k++)
                            LocalFreeAndNull(&(lpOldProps[j].Value.MVbin.lpbin[k].lpb));
                        LocalFreeAndNull(&(lpOldProps[j].Value.MVbin.lpbin));
                    }
                }
            }
#endif

            {
                LPSBinary lpsb = NULL;
#ifdef IMPORT_FOLDERS
                lpsb = bIsFolderMember ? NULL : &sbPAB;//if this is already a member of some folder, don't reset parenthood on it
#else
                lpsb = &sbPAB;
#endif
                // Create a new mailuser for this entry
                if(HR_FAILED(hr = HrCreateNewObject(lpAdrBook, lpsb,
                                                    MAPI_MAILUSER, 
                                                    CREATE_CHECK_DUP_STRICT | CREATE_REPLACE | CREATE_MERGE, 
                                                    &lpObject)))
                {
                    hrDeferred = hr;
                    hr = S_OK;
                    goto endofthisloop;
                }
            }

            // Set the old guys props on the new guy - note that this overwrites any common props on 
            // potential duplicates when calling savechanges
            if(HR_FAILED(hr = lpObject->lpVtbl->SetProps(lpObject, ulcOldProps, lpOldProps, NULL)))
            {
                hrDeferred = hr;
                hr = S_OK;
                goto endofthisloop;
            }

            // SaveChanges
            if(HR_FAILED(hr = lpObject->lpVtbl->SaveChanges(lpObject, KEEP_OPEN_READONLY)))
            {
                hrDeferred = hr;
                hr = S_OK;
                goto endofthisloop;
            }

            // By now the object has a new or existin EID .. if so, use this EID
            {
                ULONG ulcNewProps = 0;
                LPSPropValue lpNewProps = NULL;
            
                if(HR_FAILED(hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &ulcNewProps, &lpNewProps)))
                {
                    hrDeferred = hr;
                    hr = S_OK;
                    goto endofthisloop;
                }

                for(j=0;j<ulcNewProps;j++)
                {
                    if(lpNewProps[j].ulPropTag == PR_ENTRYID)
                    {
                        if(rgObj[n] != MAPI_ABCONT)
                            SetSBinary(&sbNewEID, lpNewProps[j].Value.bin.cb, lpNewProps[j].Value.bin.lpb);
#ifdef IMPORT_FOLDERS
                        else
                        {
                            ULONG cb = 0; LPENTRYID lpb = NULL;
                            if(!HR_FAILED(CreateWABEntryID( WAB_CONTAINER, 
                                                            lpNewProps[j].Value.bin.lpb, NULL, NULL,
                                                            lpNewProps[j].Value.bin.cb, 0,
                                                            NULL, &cb, &lpb)))
                            {
                                // Add the entryids to this prop - ignore errors
                                SetSBinary(&sbNewEID, cb, (LPBYTE)lpb);
                                MAPIFreeBuffer(lpb);
                            }
                        }
                        if(rgObj[n] == MAPI_ABCONT && bIsThereACurrentUser(lpIAB))
                            hr = HrAddRemoveFolderFromUserFolder(lpIAB, NULL, &sbNewEID, NULL, TRUE);
#endif
                        break;
                    }
                }
                MAPIFreeBuffer(lpNewProps);
            }

            SetNewEID(&sbOldEID, &sbNewEID, dwWABEntryCount, lppsbWABEIDs);

endofthisloop:
            if(sbOldEID.lpb)
                LocalFree(sbOldEID.lpb);
            if(sbNewEID.lpb)
                LocalFree(sbNewEID.lpb);
            ReadRecordFreePropArray(NULL, ulcOldProps, &lpOldProps);
            ulcOldProps = 0;
            lpOldProps = NULL;

            if(lpObject)
                lpObject->lpVtbl->Release(lpObject);
            lpObject = NULL;
        } //for i..

        FreeEntryIDs(NULL, ulEIDCount, rgsbEntryIDs);
        rgsbEntryIDs = NULL;
        ulEIDCount = 0;
    } // for n..

    if(bShowUI)
        SetPrintDialogMsg(idsImportProcessing, 0, szEmpty);

    // Now that we have opened all the entries, we need to reopen the new entries in the new WAB and
    // reset any temp entryids we might have put in them
    for(n=0;n<dwWABEntryCount;n++)
    {
        ULONG ulObjType = 0;

        if(bShowUI)
            SetPrintDialogMsg(0, 0, szEmpty);

        if(bTimeToAbort())
        {
            hr = MAPI_E_USER_CANCEL;
            goto exit;
        }

        if(!lppsbWABEIDs[eidNew][n].cb)
            continue;

        if(HR_FAILED(hr = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, lppsbWABEIDs[eidNew][n].cb, 
                                                (LPENTRYID) lppsbWABEIDs[eidNew][n].lpb,
                                                NULL, MAPI_BEST_ACCESS, &ulObjType,
                                                (LPUNKNOWN *)&lpObject)))
        {
            hrDeferred = hr;
            hr = S_OK;
            continue;
        }

        if(ulObjType == MAPI_ABCONT)
            goto endloop;
        
        if(HR_FAILED(hr = lpObject->lpVtbl->GetProps(lpObject, NULL, MAPI_UNICODE, &ulcOldProps, &lpOldProps)))
        {
            hrDeferred = hr;
            hr = S_OK;
            goto endloop;
        }

        // open the record and reset any temp eids in it
        UpdateEntryIDReferences(ulcOldProps, lpOldProps, dwWABEntryCount, lppsbWABEIDs, TRUE);
    
        // SaveChanges
        if(HR_FAILED(hr = lpObject->lpVtbl->SaveChanges(lpObject, KEEP_OPEN_READONLY)))
        {
            hrDeferred = hr;
            hr = S_OK;
        }

endloop:
        if(lpOldProps)
        {
            MAPIFreeBuffer(lpOldProps);
            ulcOldProps = 0;
            lpOldProps = NULL;
        }
        if(lpObject)
        {
            lpObject->lpVtbl->Release(lpObject);
            lpObject = NULL;
        }
    } // for n...

    hr = S_OK;

exit:
    if(lstrlen(szFile))
        DeleteFile(szFile);

    if(sbPAB.lpb)
        MAPIFreeBuffer(sbPAB.lpb);

    if(ulcOldProps && lpOldProps)
        LocalFreePropArray(NULL, ulcOldProps, &lpOldProps);

    if(lpObject)
        lpObject->lpVtbl->Release(lpObject);

    if(lppsbWABEIDs)
    {
        for(i=0;i<eidMax;i++)
        {
            for(j=0;j<dwWABEntryCount;j++)
                LocalFreeAndNull((LPVOID *) (&lppsbWABEIDs[i][j].lpb));
            LocalFreeAndNull(&lppsbWABEIDs[i]);
        }
        LocalFree(lppsbWABEIDs);
    }

    if(hPropertyStore)
        ClosePropertyStore(hPropertyStore,AB_DONT_BACKUP | AB_IGNORE_OUTLOOK);

    FreeEntryIDs(NULL, ulEIDCount, rgsbEntryIDs);

    //if(hOldCur)
    //    SetCursor(hOldCur);

    LocalFreeAndNull(&lpulNewNP);
    LocalFreeAndNull(&lpulOldNP);

    if(bShowUI)
    {
        EnableWindow(hWnd, TRUE);
        CloseAbortDlg();

        if(hr!=MAPI_E_USER_CANCEL)
            ShowMessageBox(hWnd, (  HR_FAILED(hr) ? idsImportError : 
                                    (HR_FAILED(hrDeferred) ? idsImportCompleteError : idsImportComplete) ),
                                    MB_OK | MB_ICONINFORMATION);
    }

    if(!hr && HR_FAILED(hrDeferred))
        hr = MAPI_W_ERRORS_RETURNED;

    if(!HR_FAILED(hr) && bFoldersImported)
        HrGetWABProfiles(lpIAB);

    return(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabprint.h ===
#ifndef _MSGPRNT_H
#define _MSGPRNT_H

typedef struct _PrintInfo
{
    // Public fields for use
    HDC         hdcPrn;                 // The HDC to use for printing
    RECT        rcMargin;               // The margin settings for printing
    SIZE        sizeInch;               // Pixels to an inch
    SIZE        sizePage;               // Pixels to an page

    // Private fields used by the printing subroutines
    RECT        rcBand;                 // The current drawing area
    BOOL        fEndOfPage;             // Whether rcBand represents the end of
                                        //  of the page
    LONG        lPageNumber;            // The current page number
    LONG        lPrevPage;              // The last page we printed out so far
    TCHAR       szPageNumber[20];       // Formatting string for page number

    INT         yFooter;                // Where to put the footer

    HFONT       hfontSep;               // Font for separator
    HFONT       hfontPlain;             // Font for footer
    HFONT       hfontBold;             // Font for footer

    ABORTPROC   pfnAbortProc;           // Pointer to our abort proc

    HWND        hwnd;                   // Handle of our parent window
    TCHAR *     szHeader;               // Pointer to our header string
    HWND        hwndRE;                 // RichEdit control for rendering
    HWND        hwndDlg;                // Handle of the original note form
    // Form mode print support
    //PRINTDETAILS *  pprintdetails;
} PRINTINFO;


HRESULT HrPrintItems(HWND hWnd, LPADRBOOK lpIAB, HWND hWndListAB, BOOL bCurrentSortisByLastName);


// STDMETHODIMP WABPrintExt(LPADRBOOK FAR lpAdrBook, LPWABOBJECT FAR lpWABObject, HWND hWnd, LPADRLIST lpAdrList);

typedef HRESULT (STDMETHODCALLTYPE WABPRINTEXT)(LPADRBOOK FAR lpAdrBook, LPWABOBJECT FAR lpWABObject, HWND hWnd, LPADRLIST lpAdrList);
typedef WABPRINTEXT FAR * LPWABPRINTEXT;

#endif //_MSGPRNT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabspi.h ===
#ifndef _WABSPI_H_
#define _WABSPI_H_

#ifdef __cplusplus
extern "C" {
#endif

// WAB object types
#define RECORD_CONTACT      0x00000001
#define RECORD_DISTLIST     0x00000002
#define RECORD_CONTAINER    0x00000003

//Flags used in property-type record searching (independent of property data)
#define AB_MATCH_PROP_ONLY  0x00000001

/**Flags used for calling find HrFindFuzzyRecordMatches**/
#define AB_FUZZY_FAIL_AMBIGUOUS 0x0000001
#define AB_FUZZY_FIND_NAME      0x0000010
#define AB_FUZZY_FIND_EMAIL     0x0000100
#define AB_FUZZY_FIND_ALIAS     0x0001000
#define AB_FUZZY_FIND_ALL       AB_FUZZY_FIND_NAME | AB_FUZZY_FIND_EMAIL | AB_FUZZY_FIND_ALIAS

// Container info struct
typedef struct _OutlookContInfo
{
	LPSBinary lpEntryID;
	LPSTR lpszName;
} OutlookContInfo;

// Container info struct - we need a LPTSTR version for the WAB
typedef struct _OlkContInfo
{
	LPSBinary lpEntryID;
	LPTSTR lpszName;
} OlkContInfo;

/* IWABStorageProvider Interface ---------------------------------------------------- */

#define CBIWABSTORAGEPROVIDER sizeof(IWABSTORAGEPROVIDER)


#define WAB_IWABSTORAGEPROVIDER_METHODS(IPURE)					\
	MAPIMETHOD(GetContainerList)								\
		(THIS_	LPULONG					lpulcCount,				\
				OutlookContInfo 		**prgolkci) IPURE;		\
	MAPIMETHOD(ReadRecord)										\
		(THIS_	LPSBinary				lpEntryID,				\
				ULONG					ulFlags,				\
				LPULONG					lpulcProps,				\
				LPSPropValue			*lppPropArray) IPURE;	\
	MAPIMETHOD(WriteRecord)										\
		(THIS_	LPSBinary				lpFolderID,				\
				LPSBinary				*lppEntryID,			\
				ULONG					ulFlags,				\
				ULONG					ulRecordType,			\
				ULONG					ulcProps,				\
				LPSPropValue			lpPropArray) IPURE;		\
	MAPIMETHOD(ReadPropArray)									\
		(THIS_	LPSBinary				lpFolderID,				\
				SPropertyRestriction	*lpPropRes,				\
				ULONG					ulFlags,				\
				ULONG					ulPropTagCount,			\
				LPULONG					lpPropTagArray,			\
				LPADRLIST				*lppContentList) IPURE;	\
	MAPIMETHOD(FindRecords)										\
		(THIS_	LPSBinary				lpFolderID,				\
				ULONG					ulFlags,				\
				SPropertyRestriction	*lpPropRes,				\
				LPULONG					lpulcCount,				\
				LPSBinary				*rgEntryIDs) IPURE;		\
	MAPIMETHOD(DeleteRecord)									\
		(THIS_	LPSBinary				lpEntryID) IPURE;		\
	MAPIMETHOD(GetContentsTable)								\
		(THIS_	LPSBinary				lpFolderID,				\
				ULONG					ulFlags,				\
				LPMAPITABLE				*lppTable) IPURE;		\
	MAPIMETHOD(FindFuzzyRecordMatches)							\
		(THIS_	LPSBinary				lpFolderID,				\
				LPSTR					lpszDisplayName,		\
				ULONG					ulFlags,				\
				LPULONG					lpulcCount,				\
				LPSBinary				*rgEntryIDs) IPURE;		\
	MAPIMETHOD(GetIDsFromNames)									\
		(THIS_	ULONG					cPropNames,				\
				LPMAPINAMEID			*lppPropNames,			\
				ULONG					ulFlags,				\
				LPSPropTagArray			*lppPropTags) IPURE;	\
	MAPIMETHOD(ReadMessage)										\
		(THIS_	LPMESSAGE				pmess,					\
				LPULONG					lpulcProps,				\
				LPSPropValue			*lppPropArray) IPURE;	\
	MAPIMETHOD(CreateRecord)									\
		(THIS_	LPSBinary				lpFolderID,				\
				ULONG					ulcProps,				\
				LPSPropValue			lpPropArray,			\
				IMessage				**lppMessage) IPURE;	\
	MAPIMETHOD(FreeEntryIDs)									\
		(THIS_	ULONG					ulcCount,				\
				LPSBinary				rgEntryIDs) IPURE;		\
	MAPIMETHOD(FreePropArray)									\
		(THIS_	ULONG					ulcProps,				\
				LPSPropValue			lpPropArray) IPURE;		\
	MAPIMETHOD(FreeContentList)									\
		(THIS_	LPADRLIST				lpContentList) IPURE;	\

#undef           INTERFACE
#define          INTERFACE      IWABStorageProvider
DECLARE_MAPI_INTERFACE_(IWABStorageProvider, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABSTORAGEPROVIDER_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABStorageProvider, LPWABSTORAGEPROVIDER);


#undef  INTERFACE
#define INTERFACE       struct _IWABSTORAGEPROVIDER

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWABSTORAGEPROVIDER_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWABSTORAGEPROVIDER_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABSTORAGEPROVIDER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWABSTORAGEPROVIDER_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABSTORAGEPROVIDER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABSTORAGEPROVIDER_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	WAB_IWABSTORAGEPROVIDER_METHODS(IMPL)
};



//
// Root public entry point for WAB SPI
//
STDMETHODIMP WABOpenStorageProvider(HWND hwnd, LPUNKNOWN pmsess,
		LPALLOCATEBUFFER lpAllocateBuffer, LPALLOCATEMORE lpAllocateMore,
		LPFREEBUFFER lpFreeBuffer, BOOL fUnicode,
		LPWABSTORAGEPROVIDER FAR * lppWSP);

typedef HRESULT (STDMETHODCALLTYPE WABOPENSTORAGEPROVIDER)(
	HWND hwnd,
	LPUNKNOWN pmsess,
	LPALLOCATEBUFFER lpAllocateBuffer,
	LPALLOCATEMORE lpAllocateMore,
	LPFREEBUFFER lpFreeBuffer,
	BOOL fUnicode,
	LPWABSTORAGEPROVIDER FAR * lppWSP
);
typedef WABOPENSTORAGEPROVIDER FAR * LPWABOPENSTORAGEPROVIDER;

#define OUTLWAB_DLL_NAME "OUTLWAB.DLL"

#define WAB_SPI_ENTRY_POINT "WABOpenStorageProvider"
#define WAB_SPI_ENTRY_POINT_W "WABOpenStorageProviderW"

#ifdef __cplusplus
}
#endif

#endif /* _WABSPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabprint.c ===
/*
 *    wabprint.c
 *
 *    Purpose:
 *        Print Contacts
 *
 *    Owner:
 *        vikramm.
 *
 *  History:
 *
 *      Ported from Athena mailnews\mail\msgprint.cpp 10/30/96
 *
 *    Copyright (C) Microsoft Corp. 1993, 1994.
 */


#include <_apipch.h>

// Function prototypes
extern BOOL PrintDlg(LPPRINTDLG lppd);
extern HRESULT PrintDlgEx(LPPRINTDLGEX lppdex);

INT_PTR CALLBACK fnPrintDialogProc( HWND    hDlg, UINT    message, WPARAM    wParam, LPARAM  lParam);
HRESULT HrCreatePrintCallbackObject(LPIAB lpIAB, LPWABPRINTDIALOGCALLBACK * lppWABPCO, DWORD dwSelectedStyle);
void ReleaseWABPrintCallbackObject(LPWABPRINTDIALOGCALLBACK lpWABPCO);
SCODE ScInitPrintInfo(   PRINTINFO * ppi, HWND hwnd, LPTSTR szHeader, RECT * prcBorder, HWND hWndRE);
int GetNumberFromStringResource(int idNumString);
BOOL bCheckForPrintExtensions(LPTSTR lpDLLPath, DWORD cchSize);
HRESULT HrUseWABPrintExtension(HWND hWnd, LPADRBOOK lpAdrBook, HWND hWndLV);


//
// Some string constants used in text formatting
//
const LPTSTR lpszTab = TEXT("\t");
const LPTSTR lpszFlatLine = TEXT("________________________________________________________________");
const LPTSTR lpszSpace = TEXT(" ");


//
// Print options ...
//
enum _PrintRange
{
    rangeAll=0,
    rangeSelected
};

enum _PrintStyles
{
    styleMemo=0,
    styleBusinessCard,
    stylePhoneList
};

static DWORD rgPrintHelpIDs[] =
{
    IDC_PRINT_FRAME_STYLE,  IDH_WAB_COMM_GROUPBOX,
    IDC_PRINT_RADIO_MEMO,   IDH_WAB_PRINT_MEMO,
    IDC_PRINT_RADIO_CARD,   IDH_WAB_PRINT_BIZCARD,
    IDC_PRINT_RADIO_PHONELIST,  IDH_WAB_PRINT_PHONELIST,
    0,0
};


//
// This structure contains information about a specific contact
//
enum _MemoStrings
{
    memoTitleName=0, // the big name that will be displayed based on the current sort settings ..
    memoName,
    memoJobTitle,
    memoDepartment,
    memoOffice,
    memoCompany,
    memoBusinessAddress,        // Don't mess with the order of home and business address tags
    memoBusinessAddressStreet,
    memoBusinessAddressCity,
    memoBusinessAddressState,
    memoBusinessAddressZip,
    memoBusinessAddressCountry,
    memoHomeAddress,
    memoHomeAddressStreet,
    memoHomeAddressCity,
    memoHomeAddressState,
    memoHomeAddressZip,
    memoHomeAddressCountry,
    memoBusinessPhone,      // Dont mess with the phone numbers - they should all be together in this order
    memoBusinessFax,
    memoBusinessPager,
    memoHomePhone,
    memoHomeFax,
    memoHomeCellular,
    memoEmail,
    memoBusinessWebPage,
    memoHomeWebPage,
    memoNotes,
    memoGroupMembers,
    memoMAX
};

typedef struct _MemoInfo
{
    LPTSTR lpszLabel[memoMAX];
    LPTSTR lpsz[memoMAX];
} MEMOINFO, * LPMEMOINFO;


TCHAR szDontDisplayInitials[16];

/*
 * c o n s t a n t s
 */
#define     cTwipsPerInch           1440
#define     cPtsPerInch             72
#ifndef WIN16
#define     INT_MAX                 2147483647
#endif
#define     cySepFontSize(_ppi)     (12 * (_ppi)->sizeInch.cy / cPtsPerInch)

#define     CCHMAX_STRINGRES        MAX_UI_STR


/*
 * m a c r o s
 */
#define ScPrintRestOfPage(_ppi,_fAdvance)    ScGetNextBand( (_ppi), (_fAdvance))


/*
 * g l o b a l s
 */
static TCHAR    szDefFont[]  = TEXT("Arial");
static TCHAR    szThaiDefFont[]  = TEXT("Cordia New");
static BOOL     s_bUse20 = TRUE;

// Default margin settings
static RECT        g_rcBorder =
{
    cTwipsPerInch * 1 / 2,                    // distance from left
    cTwipsPerInch * 3 / 4,                    // distance from top
    cTwipsPerInch * 1 / 2,                    // distance from right
    cTwipsPerInch * 1 / 2                    // distance from bottom
};


/*
 * p r o t o t y p e s
 */
SCODE ScGetNextBand( PRINTINFO * ppi, BOOL fAdvance );
LONG LGetHeaderIndent();




//$$/////////////////////////////////////////////////////////////////////////////
//
// CleanPrintAddressString
//
// The Home and Business addresses are FormatMessaged and may contain redundant
// spaces and line breaks if input data is incomplete
// We strip out those spaces etc
//
/////////////////////////////////////////////////////////////////////////////////
void CleanPrintAddressString(LPTSTR szAddress)
{
    LPTSTR lpTemp = szAddress;
    LPTSTR lpTemp2 = NULL;

    // The original template for styleMemo is
    //       TEXT("%1\r\n\t%2 %3 %4\r\n\t%5")
    //
    // Worst case, we will get
    //       TEXT("\r\n\t   \r\n\t")
    //
    // We want to reduce double spaces to single space
    // We want to strip out empty line breaks
    // We want to strip out redundant tabs
    //
    // For style styleBusinessCard, there are no tabs and we
    //  strip out redundancies accordingly
    //

    TrimSpaces(szAddress);

    // Squish multiple space blocks to a single space
    while (*lpTemp) {
        if (IsSpace(lpTemp) && IsSpace(CharNext(lpTemp))) {
            DWORD cchSize = lstrlen(lpTemp);            // Boy I hate using this kind of logic, but it works here.

            // There are >= 2 spaces starting at lpTemp
            lpTemp2 = CharNext(lpTemp); // point to 2nd space
            StrCpyN(lpTemp, lpTemp2, cchSize);
            continue;   // Cycle again with same lpTemp
        }
        lpTemp = CharNext(lpTemp);
    }

    TrimSpaces(szAddress);

    lpTemp = szAddress;

    // Dont let it start with a line break
    while(*lpTemp == '\r' && *(lpTemp+1) == '\n')
    {
        DWORD cchSize = lstrlen(lpTemp);            // Boy I hate using this kind of logic, but it works here.

        lpTemp2 = lpTemp+2;
        if(*lpTemp2 == '\t')
            lpTemp2 = CharNext(lpTemp2);
        StrCpyN(lpTemp, lpTemp2, cchSize);
        TrimSpaces(lpTemp);
    }

    // Dont let it end with a line break
    if(lstrlen(szAddress))
    {
        int nLen = lstrlen(szAddress);
        lpTemp = szAddress;
        while(  (*(lpTemp + nLen - 3)=='\r' && *(lpTemp + nLen - 2)=='\n') ||
                (*(lpTemp + nLen - 2)=='\r' && *(lpTemp + nLen - 1)=='\n') )
        {
            if(*(lpTemp + nLen -3) == '\r')
                *(lpTemp + nLen - 3)='\0';
            else
                *(lpTemp + nLen - 2)='\0';

            TrimSpaces(szAddress);
            nLen = lstrlen(szAddress);
            lpTemp = szAddress;
        }
    }

    TrimSpaces(szAddress);

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
//  AddTabsToLineBreaks - For the memo format, our paragraph format for the
//          data on the right side gives each paragraph a default indentation
//          of 1 tab space after the first line. However if the data contains
//          line breaks, the paragraph format gets messed up. So we take
//          a data string and insert a tab after each line break. There are
//          only a few data values such as Address and Notes that need this
//          multi-line treatment.
//
////////////////////////////////////////////////////////////////////////////
void AddTabsToLineBreaks(LPTSTR * lppsz)
{
    ULONG nBreaks = 0, nLen = 0;
    LPTSTR lpTemp,lpStart;
    LPTSTR lpsz;
    DWORD cchSize;

    if(!lppsz || !(*lppsz))
        goto out;

    lpTemp = *lppsz;

    // count the number of breaks which are not followed by tabs
    while(*lpTemp)
    {
        if(*lpTemp == '\n' && *(lpTemp+1) != '\t')
            nBreaks++;
        lpTemp = CharNext(lpTemp);
    }

    if(!nBreaks)
        goto out;

    // Allocate a new string
    cchSize = (lstrlen(*lppsz)+1+nBreaks);
    lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
    if(!lpsz)
        goto out;

    lpTemp = *lppsz;
    lpStart = lpTemp;

    StrCpyN(lpsz, szEmpty, cchSize);

    // Copy over the old string into the new with appropriate breaks
    while(*lpTemp)
    {
        if((*lpTemp == '\n') && (*(lpTemp+1)!='\t'))
        {
            *lpTemp = '\0';
            StrCatBuff(lpsz, lpStart, cchSize);
            StrCatBuff(lpsz, TEXT("\n"), cchSize);
            StrCatBuff(lpsz, lpszTab, cchSize);
            lpStart = lpTemp+1;
            lpTemp = lpStart;
        }
        else
            lpTemp = CharNext(lpTemp);
    }

    if(lstrlen(lpStart))
        StrCatBuff(lpsz, lpStart, cchSize);

    LocalFreeAndNull(lppsz);
    *lppsz = lpsz;

out:
    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
//  FreeMemoInfoStruct - Frees the MemoInfo struct allocated strings
//
////////////////////////////////////////////////////////////////////////////
void FreeMemoInfoStruct(LPMEMOINFO lpMI)
{
    int i;
    for(i=0;i<memoMAX;i++)
    {
        if(lpMI->lpsz[i] && (lpMI->lpsz[i] != szEmpty))
#ifdef WIN16
            if(i == memoBusinessAddress || i == memoHomeAddress)
                FormatMessageFreeMem(lpMI->lpsz[i]);
            else
#endif
            LocalFree(lpMI->lpsz[i]);
        if(lpMI->lpszLabel[i] && (lpMI->lpszLabel[i] != szEmpty))
            LocalFree(lpMI->lpszLabel[i]);
    }
}


//$$////////////////////////////////////////////////////////////////////////////////////////////////
//
//  GetMemoInfoStruct - Parses the data in a PropArray and puts it into a Memo_Info struch along with
//      the propert labels, bsaed on the given style
//
//
////////////////////////////////////////////////////////////////////////////////////////////////////
void GetMemoInfoStruct(LPADRBOOK lpAdrBook,
                       ULONG ulcPropCount,
                       LPSPropValue lpPropArray,
                       DWORD dwStyle,
                       LPMEMOINFO lpMI,
                       BOOL bCurrentSortIsByLastName)
{
    ULONG i,j;
    TCHAR szBuf[MAX_UI_STR];

    LPTSTR lpszFirst = NULL;
    LPTSTR lpszMiddle = NULL;
    LPTSTR lpszLast = NULL;
    LPTSTR lpszDisplayName = NULL;
    LPTSTR lpszCompany = NULL;
    LPTSTR lpszNickName = NULL;

    BOOL bIsGroup = FALSE;
    int len = 0;

    if(!lpPropArray || !ulcPropCount)
        goto out;

    // special case initialization
    for(j=memoHomeAddressStreet;j<=memoHomeAddressCountry;j++)
    {
        lpMI->lpsz[j]=szEmpty;
    }

    for(j=memoBusinessAddressStreet;j<=memoBusinessAddressCountry;j++)
    {
        lpMI->lpsz[j]=szEmpty;
    }

    // Find out if this is a mailuser or a group
    for(i=0;i<ulcPropCount;i++)
    {
        if(lpPropArray[i].ulPropTag == PR_OBJECT_TYPE)
        {
            bIsGroup = (lpPropArray[i].Value.l == MAPI_DISTLIST);
            break;
        }
    }


    for(i=0;i<ulcPropCount;i++)
    {
        LPTSTR lpszData = NULL;
        int nIndex = -1;
        int nStringID = 0;

        switch(lpPropArray[i].ulPropTag)
        {
        case PR_DISPLAY_NAME:
            nIndex = memoName;
            if(bIsGroup)
                nStringID = idsPrintGroupName;
            else
                nStringID = idsPrintDisplayName;
            lpszDisplayName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_NICKNAME:
            lpszNickName = lpPropArray[i].Value.LPSZ;
            break;
        case PR_GIVEN_NAME:
            lpszFirst = lpPropArray[i].Value.LPSZ;
            break;
        case PR_SURNAME:
            lpszLast = lpPropArray[i].Value.LPSZ;
            break;
        case PR_MIDDLE_NAME:
            lpszMiddle = lpPropArray[i].Value.LPSZ;
            break;
        case PR_TITLE:
            nIndex = memoJobTitle;
            nStringID = idsPrintTitle;
            break;
        case PR_DEPARTMENT_NAME:
            nIndex = memoDepartment;
            nStringID = idsPrintDepartment;
            break;
        case PR_OFFICE_LOCATION:
            nIndex = memoOffice;
            nStringID = idsPrintOffice;
            break;
        case PR_COMPANY_NAME:
            lpszCompany = lpPropArray[i].Value.LPSZ;
            nIndex = memoCompany;
            nStringID = idsPrintCompany;
            break;

        case PR_BUSINESS_ADDRESS_STREET:
            nIndex = memoBusinessAddressStreet;
            break;
        case PR_BUSINESS_ADDRESS_CITY:
            nIndex = memoBusinessAddressCity;
            break;
        case PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE:
            nIndex = memoBusinessAddressState;
            break;
        case PR_BUSINESS_ADDRESS_POSTAL_CODE:
            nIndex = memoBusinessAddressZip;
            break;
        case PR_BUSINESS_ADDRESS_COUNTRY:
            nIndex = memoBusinessAddressCountry;
            break;

        case PR_HOME_ADDRESS_STREET:
            nIndex = memoHomeAddressStreet;
            break;
        case PR_HOME_ADDRESS_CITY:
            nIndex = memoHomeAddressCity;
            break;
        case PR_HOME_ADDRESS_STATE_OR_PROVINCE:
            nIndex = memoHomeAddressState;
            break;
        case PR_HOME_ADDRESS_POSTAL_CODE:
            nIndex = memoHomeAddressZip;
            break;
        case PR_HOME_ADDRESS_COUNTRY:
            nIndex = memoHomeAddressCountry;
            break;

        case PR_BUSINESS_TELEPHONE_NUMBER:
            nIndex = memoBusinessPhone;
            nStringID = (dwStyle == styleMemo) ? idsPrintBusinessPhone : idsPrintBusCardBusinessPhone;
            break;
         case PR_BUSINESS_FAX_NUMBER:
            nIndex = memoBusinessFax;
            nStringID = (dwStyle == styleMemo) ? idsPrintBusinessFax : idsPrintBusCardBusinessFax;
            break;
        case PR_PAGER_TELEPHONE_NUMBER:
            nIndex = memoBusinessPager;
            nStringID = idsPrintBusinessPager;
            break;
        case PR_HOME_TELEPHONE_NUMBER:
            nIndex = memoHomePhone;
            nStringID = (dwStyle == styleMemo) ? idsPrintHomePhone : idsPrintBusCardHomePhone;
            break;
        case PR_HOME_FAX_NUMBER:
            nIndex = memoHomeFax;
            nStringID = idsPrintHomeFax;
            break;
        case PR_CELLULAR_TELEPHONE_NUMBER:
            nIndex = memoHomeCellular;
            nStringID = idsPrintHomeCellular;
            break;
        case PR_BUSINESS_HOME_PAGE:
            nIndex = memoBusinessWebPage;
            nStringID = idsPrintBusinessWebPage;
            break;
        case PR_PERSONAL_HOME_PAGE:
            nIndex = memoHomeWebPage;
            nStringID = idsPrintHomeWebPage;
            break;
        case PR_COMMENT:
            nIndex = memoNotes;
            nStringID = idsPrintNotes;
            break;
        default:
            continue;
            break;
        }

        if(nIndex != -1)
        {
            if(nStringID != 0)
            {
                LoadString(hinstMapiX, nStringID, szBuf, ARRAYSIZE(szBuf));
                lpMI->lpszLabel[nIndex] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                if(!lpMI->lpszLabel[nIndex])
                    goto out;
                StrCpyN(lpMI->lpszLabel[nIndex], szBuf, lstrlen(szBuf)+1);
            }

            lpMI->lpsz[nIndex] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.LPSZ)+1));
            if(!lpMI->lpsz[nIndex])
                goto out;
            StrCpyN(lpMI->lpsz[nIndex], lpPropArray[i].Value.LPSZ, lstrlen(lpPropArray[i].Value.LPSZ)+1);
        }
    }

    // Email is a special case since a contact can hace PR_EMAIL_ADDRESS or
    // PR_CONTACT_EMAIL_ADDRESSES or both or neither
    // We first look for PR_CONTACT_EMAIL_ADDRESS .. if not found, then for
    // PR_EMAIL_ADDRESS
    {
        BOOL bMVEmail = FALSE;
        LPTSTR lpszEmails = NULL;

        for(i=0;i<ulcPropCount;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
            {
                ULONG k,ulBufSize=0;
                for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                {
                    ulBufSize += sizeof(TCHAR)*(lstrlen(lpPropArray[i].Value.MVSZ.LPPSZ[k])+1);
                    ulBufSize += sizeof(TCHAR)*(lstrlen(szCRLF)+1);
                    ulBufSize += sizeof(TCHAR)*(lstrlen(lpszTab)+1);
                }
                ulBufSize -= sizeof(TCHAR)*(lstrlen(szCRLF)+1);
                ulBufSize -= sizeof(TCHAR)*(lstrlen(lpszTab)+1);

                lpszEmails = LocalAlloc(LMEM_ZEROINIT, ulBufSize);
                if(!lpszEmails)
                {
                    DebugPrintError(( TEXT("Local Alloc Failed\n")));
                    goto out;
                }
                StrCpyN(lpszEmails, szEmpty, ulBufSize/sizeof(TCHAR));
                for (k=0;k<lpPropArray[i].Value.MVSZ.cValues;k++)
                {
                    if(k>0)
                    {
                        StrCatBuff(lpszEmails, szCRLF,ulBufSize/sizeof(TCHAR) );
                        StrCatBuff(lpszEmails, lpszTab, ulBufSize/sizeof(TCHAR));
                    }
                    StrCatBuff(lpszEmails,lpPropArray[i].Value.MVSZ.LPPSZ[k], ulBufSize/sizeof(TCHAR));
                }

                bMVEmail = TRUE;
                break;
            }
        }

        if(!bMVEmail)
        {
            // No CONTACT_EMAIL_ADDRESSES
            // Should look for email address
            for(i=0;i<ulcPropCount;i++)
            {
                if(lpPropArray[i].ulPropTag == PR_EMAIL_ADDRESS)
                {
                    ULONG cchSize = lstrlen(lpPropArray[i].Value.LPSZ)+1;
                    lpszEmails = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
                    if(!lpszEmails)
                        goto out;
                    StrCpyN(lpszEmails, lpPropArray[i].Value.LPSZ, cchSize);
                    break;
                }
            }
        }

        if(lpszEmails)
        {
            ULONG cchSize = lstrlen(szBuf)+1;

            lpMI->lpsz[memoEmail] = lpszEmails;

            LoadString(hinstMapiX, idsPrintEmail, szBuf, ARRAYSIZE(szBuf));

            lpMI->lpszLabel[memoEmail] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
            if(!lpMI->lpszLabel[memoEmail])
                goto out;
            StrCpyN(lpMI->lpszLabel[memoEmail], szBuf, cchSize);
        }
    }

    //Now we have to format the Home and Business Addresses
    //

    {
        LPTSTR lpszData[5];

        for(i=memoHomeAddressStreet;i<=memoHomeAddressCountry;i++)
        {
            // Win9x bug FormatMessage cannot have more than 1023 chars
            len += lstrlen(lpMI->lpsz[i]);
            if(len < 1023)
                lpszData[i-memoHomeAddressStreet] = lpMI->lpsz[i];
            else
                lpszData[i-memoHomeAddressStreet] = NULL;
        }
        for(i=memoHomeAddressStreet;i<=memoHomeAddressCountry;i++)
        {
            if(lpMI->lpsz[i] && lpMI->lpsz[i] != szEmpty)
            {
                LPTSTR lpszHomeAddress = NULL;
                TCHAR szBuf[MAX_UI_STR];

                int nStringID = (dwStyle == styleMemo) ? idsPrintAddressTemplate : idsPrintBusCardAddressTemplate ;

                LoadString(hinstMapiX, nStringID, szBuf, CharSizeOf(szBuf));

                if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szBuf,
                      0,                    // stringid
                      0,                    // dwLanguageId
                      (LPTSTR)&lpszHomeAddress,     // output buffer
                      0,                    //MAX_UI_STR
                      (va_list *)&lpszData[0]))
                {
                        CleanPrintAddressString(lpszHomeAddress);
                        lpMI->lpsz[memoHomeAddress] = lpszHomeAddress;
                        szBuf[0]='\0';
                        LoadString(hinstMapiX, idsPrintHomeAddress, szBuf, CharSizeOf(szBuf));
                        lpMI->lpszLabel[memoHomeAddress] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                        if(!lpMI->lpszLabel[memoHomeAddress])
                            goto out;
                        StrCpyN(lpMI->lpszLabel[memoHomeAddress], szBuf, lstrlen(szBuf)+1 );
                        break;
                }

            }
        }

        len = 0;
        for(i=memoBusinessAddressStreet;i<=memoBusinessAddressCountry;i++)
        {
            // Win9x bug FormatMessage cannot have more than 1023 chars
            len += lstrlen(lpMI->lpsz[i]);
            if(len < 1023)
                lpszData[i-memoBusinessAddressStreet] = lpMI->lpsz[i];
            else
                lpszData[i-memoBusinessAddressStreet] = NULL;
        }
        for(i=memoBusinessAddressStreet;i<=memoBusinessAddressCountry;i++)
        {
            if(lpMI->lpsz[i] && lpMI->lpsz[i] != szEmpty)
            {
                LPTSTR lpszBusinessAddress = NULL;
                TCHAR szBuf[MAX_UI_STR];
                int nStringID = (dwStyle == styleMemo) ? idsPrintAddressTemplate : idsPrintBusCardAddressTemplate ;
                TCHAR szTmp[MAX_PATH], *lpszTmp;

                LoadString(hinstMapiX, nStringID, szBuf, CharSizeOf(szBuf));

                if (FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szBuf,
                      0,                    // stringid
                      0,                    // dwLanguageId
                      (LPTSTR)&lpszBusinessAddress,     // output buffer
                      0,                    //MAX_UI_STR
                      (va_list *)&lpszData[0]))
                {
                        CleanPrintAddressString(lpszBusinessAddress);
                        lpMI->lpsz[memoBusinessAddress] = lpszBusinessAddress;
                        szBuf[0]='\0';
                        LoadString(hinstMapiX, idsPrintBusinessAddress, szBuf, CharSizeOf(szBuf));
                        lpMI->lpszLabel[memoBusinessAddress] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(szBuf)+1));
                        if(!lpMI->lpszLabel[memoBusinessAddress])
                            goto out;
                        StrCpyN(lpMI->lpszLabel[memoBusinessAddress], szBuf, lstrlen(szBuf)+1);
                        break;
                }

            }
        }


    }

    // Set the name that will be printed out for each entry
    // This is dependent on the current view and on the local language setting
    {
        LPTSTR lpszTmp = NULL;

        if( bCurrentSortIsByLastName != bDNisByLN)
        {
            // for auto add to WABs we dont have all this info .. so
            // if we just have a displayname we use it as it is
            if(lpszFirst || lpszMiddle || lpszLast || lpszNickName || (lpszCompany && !lpszDisplayName))
            {
                if(SetLocalizedDisplayName(lpszFirst,
                                           lpszMiddle,
                                           lpszLast,
                                           lpszCompany,
                                           lpszNickName,
                                           NULL, //&szBuf,
                                           0,
                                           bCurrentSortIsByLastName,
                                           NULL,
                                           &lpszTmp))
                {
                    lpMI->lpsz[memoTitleName]=lpszTmp;
                }
            }
        }
        if(!lpMI->lpsz[memoTitleName])
        {
            // use whatever DisplayName we have
            lpMI->lpsz[memoTitleName] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(lpszDisplayName)+1));
            if(!lpMI->lpsz[memoTitleName])
                goto out;
            StrCpyN(lpMI->lpsz[memoTitleName],lpszDisplayName, lstrlen(lpszDisplayName)+1);
        }
    }

    if(bIsGroup)
    {
        LPTSTR lpszMembers = NULL;
        ULONG nLen = 0;

        // Get the group members
        for(i=0;i<ulcPropCount;i++)
        {
            if(lpPropArray[i].ulPropTag == PR_WAB_DL_ENTRIES || lpPropArray[i].ulPropTag == PR_WAB_DL_ONEOFFS )
            {
                // Look at each entry in the PR_WAB_DL_ENTRIES.
                for (j = 0; j < lpPropArray[i].Value.MVbin.cValues; j++)
                {
                    ULONG cbEID = lpPropArray[i].Value.MVbin.lpbin[j].cb;
                    LPENTRYID lpEID = (LPENTRYID)lpPropArray[i].Value.MVbin.lpbin[j].lpb;
                    ULONG ulcProps=0;
                    LPSPropValue lpProps=NULL;
                    LPTSTR lpszName = NULL;
                    ULONG k;

                    if (HR_FAILED(  HrGetPropArray( lpAdrBook,NULL,cbEID,lpEID,MAPI_UNICODE,&ulcProps,&lpProps)))
                    {
                        DebugPrintError(( TEXT("HrGetPropArray failed\n")));
                        continue;
                    }

                    for(k=0;k<ulcProps;k++)
                    {
                        if(lpProps[k].ulPropTag == PR_DISPLAY_NAME)
                        {
                            lpszName = lpProps[k].Value.LPSZ;
                            break;
                        }
                    }

                    if(lpszName)
                    {
                        LPTSTR lpsz;
                        if(!lpszMembers)
                            nLen = 0;
                        else
                        {
                            nLen = lstrlen(lpszMembers)+1;
                            nLen += lstrlen(lpszTab) + lstrlen(szCRLF) + 1;
                        }

                        nLen += lstrlen(lpszName)+1;

                        lpsz = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*nLen);
                        if(!lpsz)
                        {
                            if(lpProps)
                                MAPIFreeBuffer(lpProps);
                            goto out;
                        }

                        *lpsz='\0';
                        if(lpszMembers)
                        {
                            StrCpyN(lpsz,lpszMembers, nLen);
                            StrCatBuff(lpsz,szCRLF, nLen);
                            StrCatBuff(lpsz,lpszTab, nLen);
                        }
                        StrCatBuff(lpsz,lpszName, nLen);
                        LocalFreeAndNull(&lpszMembers);
                        lpszMembers = lpsz;
                    }

                    if(lpProps)
                        MAPIFreeBuffer(lpProps);
                } // for(j...
            }
        } // for(i...

        if(lpszMembers)
        {
            ULONG cchSize = lstrlen(szBuf)+1;
            szBuf[0]='\0';
            LoadString(hinstMapiX, idsPrintGroupMembers, szBuf, ARRAYSIZE(szBuf));
            lpMI->lpszLabel[memoGroupMembers] = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*cchSize);
            if(!lpMI->lpszLabel[memoGroupMembers])
                goto out;
            StrCpyN(lpMI->lpszLabel[memoGroupMembers], szBuf, cchSize);
            lpMI->lpsz[memoGroupMembers]=lpszMembers;
        }
    }

    //Speacial case formatting of multiline data
    if(dwStyle == styleMemo)
    {
        AddTabsToLineBreaks(&(lpMI->lpsz[memoNotes]));
        AddTabsToLineBreaks(&(lpMI->lpsz[memoHomeAddress]));
        AddTabsToLineBreaks(&(lpMI->lpsz[memoBusinessAddress]));
    }

out:
    // special case uninitialization
    for(j=memoHomeAddressStreet;j<=memoHomeAddressCountry;j++)
    {
        if(lpMI->lpsz[j] && (lpMI->lpsz[j] != szEmpty))
            LocalFreeAndNull(&(lpMI->lpsz[j]));
    }

    for(j=memoBusinessAddressStreet;j<=memoBusinessAddressCountry;j++)
    {
        if(lpMI->lpsz[j] && (lpMI->lpsz[j] != szEmpty))
            LocalFreeAndNull(&(lpMI->lpsz[j]));
    }

    return;
}

/*
 *        NTwipsToPixels
 *
 *        Purpose:
 *            Converts a measurement in twips into pixels
 *
 *        Arguments:
 *            nTwips                    the value to be converted
 *            cPixels                    number of pixels per inch
 *
 *        Returns:
 *            Returns a int representing the number of pixels in nTwips
 */
int NTwipsToPixels(int nTwips, int cPixelsPerInch)
{
    LONG lT = (LONG) nTwips * (LONG) cPixelsPerInch / (LONG) cTwipsPerInch;

    return (int) lT;
}

/*
 *      LPixelsToTwips
 *
 *      Purpose:
 *          Converts a measurement in pixles into twips
 *
 *      Arguments:
 *          nPixels                 the value to be converted
 *          cPixels                 number of pixels per inch
 *
 *      Returns:
 *          Returns a int representing the number of pixels in nTwips
 */
LONG LPixelsToTwips(int nPixels, int cPixelsPerInch)
{

    LONG lT = (LONG) nPixels * (LONG) cTwipsPerInch / (LONG) cPixelsPerInch;

    return lT;
}


/*
 *        PrintPageNumber
 *
 *        Purpose:
 *            To print the page number for each page
 *
 *        Arguments:
 *            ppi                    Pointer to the PRINTINFO structure
 *
 *        Returns:
 *            SCODE indicating success or failure.
 *            Currently always return S_OK
 */
void PrintPageNumber(PRINTINFO * ppi)
{
    RECT        rcExt;
    HFONT        hfontOld;
    TCHAR        szT[20];

    DebugPrintTrace(( TEXT("PrintPageNumber\n")));

    // Find out how much space our text take will take
    rcExt = ppi->rcBand;
    rcExt.top = ppi->yFooter;
    hfontOld = (HFONT)SelectObject(ppi->hdcPrn, ppi->hfontPlain);
    DrawText(ppi->hdcPrn, szT, wnsprintf(szT, ARRAYSIZE(szT), ppi->szPageNumber,
                ppi->lPageNumber), &rcExt, DT_CENTER);
    SelectObject(ppi->hdcPrn, hfontOld);

}



/*
 *        ScGetNextBand
 *
 *        Purpose:
 *            Retrieves the next band to print on. Adjusts the band to conform
 *            to the margins established in the PRINTINFO structure. Bumps up
 *            the page number as appropriate.
 *
 *        Arguments:
 *            ppi                        print information
 *            fAdvance                flag whether to move to the next page
 *
 *        Returns:
 *            SCODE indicating the success or failure
 */
SCODE ScGetNextBand(PRINTINFO * ppi, BOOL fAdvance)
{
    SCODE    sc = S_OK;
    int        nCode;

    DebugPrintTrace(( TEXT("ScGetNextBand\n")));

    // Call the abort proc to see if the user wishes to stop

    if (!ppi->pfnAbortProc(ppi->hdcPrn, 0))
    {
        sc=E_FAIL;
        nCode = AbortDoc(ppi->hdcPrn);
        if(nCode < 0)
        {
            DebugPrintTrace(( TEXT("Abort Doc error: %d\n"),GetLastError()));
            ShowMessageBox(ppi->hwndDlg, idsPrintJobCannotStop, MB_OK | MB_ICONEXCLAMATION);
        }
        goto CleanUp;
    }

    // brettm:
    // USE_BANDING stuff removed, as we're always on Win32

    // End the previous page
    if (ppi->lPageNumber)
    {
        nCode = EndPage(ppi->hdcPrn);
        DebugPrintTrace(( TEXT("+++++++++EndPage\n")));
        if (nCode <= 0)
        {
        sc=E_FAIL;
        goto CleanUp;
        }
    }

    if (fAdvance)
    {
        nCode = StartPage(ppi->hdcPrn);
        DebugPrintTrace(( TEXT("+++++++++StartPage\n")));
        // Start a new page
        if (nCode <= 0)
            {
            sc=E_FAIL;
            goto CleanUp;
            }
        // Let the entire page be the band
        ppi->rcBand        = ppi->rcMargin;
        ppi->fEndOfPage    = TRUE;                // end of page!

        // Bump up the page number and print
        ppi->lPrevPage = ppi->lPageNumber++;
        PrintPageNumber(ppi);
        {
            TCHAR szBuf[MAX_UI_STR];
            TCHAR szString[MAX_UI_STR];
            LoadString(hinstMapiX, idsPrintingPageNumber, szString, ARRAYSIZE(szString));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szString, ppi->lPageNumber);
            SetPrintDialogMsg(0, 0, szBuf);
        }
    }

CleanUp:
    return sc;
}




/*
 *  LGetHeaderIndent
 *
 *  Purpose:
 *      Retrieves from the resource file the suggested indent overhang for
 *      headers.
 *
 *  Arguments:
 *      none.
 *
 *  Returns:
 *      LONG            The suggested indent overhang in twips
 */
LONG LGetHeaderIndent()
{
    LONG    lOver = 1440;               // default
    //TCHAR    szT[10];

    //if (LoadString(hinstMapiX, idsHeaderIndent, szT, CharSizeOf(szT)))
    //    lOver = atoi(szT);
    return lOver;
}















//$$////////////////////////////////////////////////////////////////////////////////
//
//  AppendText - Simple routine that appends a given string to the End of the text
//      in the given richedit control
//
////////////////////////////////////////////////////////////////////////////////////
void AppendText(HWND hWndRE, LPTSTR lpsz)
{
    // Set the insertion point to the end of the current text
    int nLastChar =  (int) SendMessage(hWndRE, WM_GETTEXTLENGTH, 0, 0);
    CHARRANGE charRange = {0};

    charRange.cpMin = charRange.cpMax = nLastChar + 1;
    SendMessage(hWndRE, EM_EXSETSEL, 0, (LPARAM) &charRange);

    // Insert the text
    // [PaulHi] 7/7/99  Raid 82350  RichEdit 1.0 can't handle Unicode
    // strings even though the window is created Unicode.
    if (s_bUse20)
    {
        // RichEdit 2.0
        SendMessage(hWndRE, EM_REPLACESEL, (WPARAM) FALSE, (LPARAM) lpsz);
    }
    else
    {
        // RichEdit 1.0
        LPSTR   lpszTemp = ConvertWtoA(lpsz);

        Assert(lpszTemp);
        if (lpszTemp)
            SendMessageA(hWndRE, EM_REPLACESEL, (WPARAM) FALSE, (LPARAM) lpszTemp);

        LocalFreeAndNull(&lpszTemp);
    }

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// ParaCmd - Sets/Unsets paragraph formatting in the Rich Edit Control
//
// We want all the information on the right side to be indented
// so we will put an indent on that information and remove it when
// adding labels
////////////////////////////////////////////////////////////////////////////
void ParaCmd(HWND hWndRE, BOOL bIndent)
{
    // We want no indentation on the first line and we want a
    // 1 tab indentation on the second line onwards

    PARAFORMAT pf ={0};
    int nTabStop = (int) (1.5 * cTwipsPerInch);

    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_OFFSET  |
                PFM_TABSTOPS |
                PFM_NUMBERING;

    SendMessage(hWndRE, EM_GETPARAFORMAT, (WPARAM) TRUE, (LPARAM) &pf);


    pf.wNumbering = 0;


    if (bIndent)
    {
        //pf.dxStartIndent = nTabStop;
        pf.dxOffset = nTabStop;
        pf.cTabCount = 1;
        pf.rgxTabs[0] = nTabStop;
    }
    else
    {
        //pf.dxStartIndent = 0;
        pf.dxOffset = 0;
        pf.cTabCount = 1;
        pf.rgxTabs[0] = 720; //seems to be the default = 0.5 inches
    }

    SendMessage(hWndRE, EM_SETPARAFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &pf);
    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// BoldCmd - Sets/Unsets current font to bold in the Rich Edit Control
//
////////////////////////////////////////////////////////////////////////////
void BoldCmd(HWND hWndRE, BOOL bBold)
{
    CHARFORMAT cf = {0};

    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_BOLD;

    SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) TRUE, (LPARAM) &cf);

    if (bBold)
        cf.dwEffects = cf.dwEffects | CFE_BOLD;
    else
        cf.dwEffects = cf.dwEffects & ~CFE_BOLD;

    SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &cf);

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// TitleCmd - Sets/Unsets title text (BOLD, Bigger) in the Rich Edit Control
//
////////////////////////////////////////////////////////////////////////////
void TitleCmd(HWND hWndRE, BOOL bBold)
{
    CHARFORMAT cf = {0};
    PARAFORMAT pf = {0};

    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_BOLD /*| CFM_ITALIC*/ | CFM_SIZE;

    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_NUMBERING;

    SendMessage(hWndRE, EM_GETPARAFORMAT, (WPARAM) TRUE, (LPARAM) &pf);
    SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) TRUE, (LPARAM) &cf);

    if (bBold)
    {
        cf.dwEffects = cf.dwEffects | CFE_BOLD; // | CFE_ITALIC;
        cf.yHeight += 50;
        pf.wNumbering = PFN_BULLET;
    }
    else
    {
        cf.dwEffects = cf.dwEffects & ~CFE_BOLD;
//        cf.dwEffects = cf.dwEffects & ~CFE_ITALIC;
        cf.yHeight -= 50;
        pf.wNumbering = 0;
    }

    SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &cf);
    SendMessage(hWndRE, EM_SETPARAFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &pf);

    return;
}

//$$////////////////////////////////////////////////////////////////////////
//
// ReduceFontCmd - Reduces the displayed font in the Rich Edit Control
//
////////////////////////////////////////////////////////////////////////////
void ReduceFontCmd(HWND hWndRE, BOOL bReduce, int nReduceBy, BOOL bSelectionOnly)
{
    CHARFORMAT cf = {0};

    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_SIZE;

    SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) bSelectionOnly, (LPARAM) &cf);

    if (bReduce)
        cf.yHeight -= nReduceBy; //40;
    else
        cf.yHeight += nReduceBy; //40;

    SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) bSelectionOnly ? SCF_SELECTION : SCF_DEFAULT, (LPARAM) &cf);

    return;
}


//$$////////////////////////////////////////////////////////////////////////
//
// SetTabsCmd - Sets and Unsets the Tabs in the RichEdit Control
//
////////////////////////////////////////////////////////////////////////////
void SetTabsCmd(HWND hWndRE, BOOL bSet)
{
    PARAFORMAT pf ={0};
    int nTabStop = (int) (1.5 * cTwipsPerInch);
    int j;

    pf.cbSize = sizeof(pf);
    pf.dwMask = PFM_TABSTOPS | PFM_NUMBERING;

    SendMessage(hWndRE, EM_GETPARAFORMAT, (WPARAM) TRUE, (LPARAM) &pf);

    pf.wNumbering = 0;

    if (bSet)
    {
        for(j=0;j<5;j++)
            pf.rgxTabs[j] = nTabStop;
    }
    else
    {
        for(j=0;j<5;j++)
            pf.rgxTabs[j] = 720;
    }

    SendMessage(hWndRE, EM_SETPARAFORMAT, (WPARAM) SCF_SELECTION, (LPARAM) &pf);

    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//  WABStylePhoneList - Fills the Rich edit control with info from MI as per the
//                      Phone List style
//
//  hWndRE - handle to Print Formating Rich Edit Control
//  MI - MEMOINFO strcuture containing the info to print
//  lpszPrevEntry - the first TCHAR of the previous entry - this lets us break the list
//      alphabetically - this points to a preallocated buffer
//
////////////////////////////////////////////////////////////////////////////////////////////////
void WABStylePhoneList(HWND hWndRE, MEMOINFO MI, LPTSTR lpszPrevEntry, DWORD cchSizePrevEntry)
{
    // We want an extra gap between certain groups of information
    // we'll track these groups using these BOOLs
    ULONG i,j,k;

    TCHAR szBufChar1[16];
    TCHAR szBufChar2[16];
    LPTSTR lpTemp = NULL;
    int nReduceFontBy = GetNumberFromStringResource(idsPhoneFontReduceBy);


    // First we compare the first character of the current string with the previous
    // string - if it is the same, then we do nothing - if it different, we ouput
    // the lower case TCHAR as a heading for the phone directory
    //
    // If the character is not alphanumeric, we ignore it as a heading (e.g. ' )

    // Bug: 25710
    // We ignore these initialls totally if localizers have set idsDontDisplayInitials
    //  these initials to anything other than 0 because in some FE languages
    //  names have double characters in them and they look strange with a single
    //  character up front
    if(szDontDisplayInitials[0] == '0')
    {
        StrCpyN(szBufChar1, lpszPrevEntry, ARRAYSIZE(szBufChar1));

        if(lstrlen(MI.lpsz[memoTitleName]) > 16)
        {
            ULONG iLen = TruncatePos(MI.lpsz[memoTitleName], 16-1);
            CopyMemory(szBufChar2, MI.lpsz[memoTitleName], sizeof(TCHAR)*iLen);
            szBufChar2[iLen]='\0';
        }
        else
            StrCpyN(szBufChar2, MI.lpsz[memoTitleName], ARRAYSIZE(szBufChar2));

/***********
    // Bug 14615 - this alphanumeric filtering doesnt work for DBCS and FE names
    //

    // Ignore all non-alpha numeric characters
    lpTemp = szBufChar2;
    {
        //Temp Hack
        TCHAR szTemp[16];
        LPTSTR lpTemp2 = NULL;
        StrCpyN(szTemp, lpTemp, ARRAYSIZE(szTemp));
        lpTemp2 = CharNext(szTemp);
        *lpTemp2 = '\0';
        while(lpTemp && lstrlen(lpTemp))
        {
            if(IsCharAlphaNumeric(szTemp[0]))
                break;
            lpTemp = CharNext(lpTemp);
            StrCpyN(szTemp, lpTemp, ARRAYSIZE(szTemp));
            lpTemp2 = CharNext(szTemp);
            *lpTemp2 = '\0';
        }
    }
    if(lpTemp != szBufChar2)
        StrCpyN(szBufChar2, lpTemp, ARRAYSIZE(szBufChar2));
***************/


        // Isolate the first TCHAR of the above strings
        lpTemp = CharNext(szBufChar1);
        *lpTemp = '\0';
        lpTemp = CharNext(szBufChar2);
        *lpTemp = '\0';

        // Compare these two characters
        CharLower(szBufChar1);
        CharLower(szBufChar2);

        if(lstrcmp(szBufChar1, szBufChar2))
        {
            // They are different

            // Add the TCHAR as a title string
            AppendText(hWndRE, szCRLF);
            TitleCmd(hWndRE, TRUE);
            BoldCmd(hWndRE, TRUE);
            AppendText(hWndRE, lpszSpace);
            AppendText(hWndRE, szBufChar2);
            AppendText(hWndRE, szCRLF);
            TitleCmd(hWndRE, FALSE);
            BoldCmd(hWndRE, FALSE);
            ParaCmd(hWndRE, TRUE);
            AppendText(hWndRE, lpszFlatLine);
            AppendText(hWndRE, szCRLF);
            AppendText(hWndRE, szCRLF);
            ParaCmd(hWndRE, FALSE);

            StrCpyN(lpszPrevEntry, szBufChar2, cchSizePrevEntry);
        }
    } //dontdisplayinitials

    ReduceFontCmd(hWndRE, TRUE, nReduceFontBy, TRUE);
    SetTabsCmd(hWndRE, TRUE);


    // Figure out how much space the name will take up ...
    {
        TCHAR szBuf[MAX_PATH];
        int nMaxTabs = 2;
        int nTabStop = (int)(1.5 * cTwipsPerInch);
        int MaxWidth = nMaxTabs * nTabStop;
        int sizeCxTwips;
        int PixelsPerInch;

        int nLen = lstrlen(MI.lpsz[memoTitleName]);
        SIZE size = {0};
        HDC hdc = GetDC(hWndRE);

        {
            HDC hDC = GetDC(NULL);
            PixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSX);
            ReleaseDC(NULL, hDC);
        }


		if (nLen >= MAX_PATH)
		{
		    ULONG iLen = TruncatePos(MI.lpsz[memoTitleName], MAX_PATH-1);
            CopyMemory(szBuf, MI.lpsz[memoTitleName], sizeof(TCHAR)*iLen);
            szBuf[iLen]='\0';
        }
        else
            StrCpyN(szBuf, MI.lpsz[memoTitleName], ARRAYSIZE(szBuf));

        nLen = lstrlen(szBuf);
        GetTextExtentPoint32(hdc, szBuf, nLen, &size);

        sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);

        // We dont want our displayed name to be more than 2 tabstops
        // so we decide where to truncate the name to fit it on screen
        if(sizeCxTwips > MaxWidth)
        {
            while(sizeCxTwips > MaxWidth)
            {
                nLen--;
		        nLen = TruncatePos(szBuf, nLen);
                szBuf[nLen]='\0';
                nLen = lstrlen(szBuf);
                GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
            }
            // chop of 3 more characters for good measure
            nLen-=3;
		    nLen = TruncatePos(szBuf, nLen);
            szBuf[nLen]='\0';
            nLen = lstrlen(szBuf);
            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
        }


        while ((sizeCxTwips < MaxWidth) && (nLen < ARRAYSIZE(szBuf)-1))
        {
            StrCatBuff(szBuf, TEXT("."), ARRAYSIZE(szBuf));
            nLen = lstrlen(szBuf);
            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
        }

        StrCatBuff(szBuf, lpszTab, ARRAYSIZE(szBuf));
        AppendText(hWndRE, szBuf);

        // Now we are ready to tag on the phone numbers
        {
            int nPhoneCount = 0; //counts how many phones there are
            int nPhoneLabelSpaceTwips = GetNumberFromStringResource(idsPhoneTextSpaceTwips); //1150

            for(j=memoBusinessPhone;j<=memoHomeCellular;j++)
            {
                if(MI.lpsz[j] && lstrlen(MI.lpsz[j]))
                {
                    if(nPhoneCount != 0)
                    {
                        int k;
                        AppendText(hWndRE, szCRLF);

                        // Bug 73266
                        if(s_bUse20)
                            ReduceFontCmd(hWndRE, TRUE, nReduceFontBy, TRUE);

                        StrCpyN(szBuf, szEmpty, ARRAYSIZE(szBuf));
                        nLen = lstrlen(szBuf);
                        GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                        sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
                        while ((sizeCxTwips < MaxWidth) && (nLen < ARRAYSIZE(szBuf)-1))
                        {
                            StrCatBuff(szBuf, lpszSpace, ARRAYSIZE(szBuf));
                            nLen = lstrlen(szBuf);
                            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
                        }
                        StrCatBuff(szBuf, lpszTab, ARRAYSIZE(szBuf));
                        AppendText(hWndRE, szBuf);
                    }

                    TrimSpaces(MI.lpszLabel[j]);
                    StrCpyN(szBuf, MI.lpszLabel[j], ARRAYSIZE(szBuf));

                    nLen = lstrlen(szBuf);
                    GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                    sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);

                    if(sizeCxTwips < nPhoneLabelSpaceTwips)
                    {
                        while ((sizeCxTwips < nPhoneLabelSpaceTwips) && (nLen < ARRAYSIZE(szBuf)-1))
                        {
                            StrCatBuff(szBuf, lpszSpace, ARRAYSIZE(szBuf));
                            nLen = lstrlen(szBuf);
                            GetTextExtentPoint32(hdc, szBuf, nLen, &size);
                            sizeCxTwips = (int)((size.cx * cTwipsPerInch)/PixelsPerInch);
                        }
                        StrCatBuff(szBuf, lpszTab, ARRAYSIZE(szBuf));
                    }
                    StrCatBuff(szBuf, MI.lpsz[j], ARRAYSIZE(szBuf));
                    AppendText(hWndRE, szBuf);
                    nPhoneCount++;
                }
            }
            if(nPhoneCount == 0)
            {
                LoadString(hinstMapiX, idsPrintNoPhone, szBuf, ARRAYSIZE(szBuf));
                AppendText(hWndRE, szBuf);
            }
        }

        AppendText(hWndRE, szCRLF);

        ReleaseDC(hWndRE, hdc);
    }

    SetTabsCmd(hWndRE, FALSE);
    ReduceFontCmd(hWndRE, FALSE, nReduceFontBy, TRUE);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//  WABStyleBusinessCard - Fills the Rich edit control with info from MI as per the
//                      business card style
//
//  hWndRE - handle to Print Formating Rich Edit Control
//  MI - MEMOINFO strcuture containing the info to print
//
////////////////////////////////////////////////////////////////////////////////////////////////
void WABStyleBusinessCard(HWND hWndRE, MEMOINFO MI)
{
    // We want an extra gap between certain groups of information
    // we'll track these groups using these BOOLs
    ULONG i,j,k;
    int nReduceBy = GetNumberFromStringResource(idsBusCardFontReduceBy);

    // Add the contact name as a heading
    //TitleCmd(hWndRE, TRUE);
    BoldCmd(hWndRE, TRUE);
    //AppendText(hWndRE, lpszSpace);
    AppendText(hWndRE, MI.lpsz[memoTitleName]);
    AppendText(hWndRE, szCRLF);
    //TitleCmd(hWndRE, FALSE);
    BoldCmd(hWndRE, FALSE);

    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    AppendText(hWndRE, szCRLF);
    AppendText(hWndRE, szCRLF);
    ParaCmd(hWndRE, FALSE);

    ReduceFontCmd(hWndRE, TRUE, nReduceBy, TRUE);

    for(j=memoName;j<memoMAX;j++)
    {
        if(MI.lpsz[j] && lstrlen(MI.lpsz[j]))
        {
            switch(j)
            {
            case memoJobTitle:
            //case memoDepartment:
            //case memoOffice:
            case memoCompany:
            case memoBusinessAddress:
                break;
            case memoEmail:
                // Add the label
                AppendText(hWndRE, MI.lpszLabel[j]);
                AppendText(hWndRE, lpszTab);
                break;
            case memoBusinessWebPage:
            case memoBusinessPhone:
            case memoBusinessFax:
            case memoBusinessPager:
            case memoHomePhone:
            case memoHomeFax:
            case memoHomeCellular:
                // Add the label
                AppendText(hWndRE, MI.lpszLabel[j]);
                AppendText(hWndRE, lpszSpace);
                break;
            default:
                continue;
            }

            // Add the value
            AppendText(hWndRE, MI.lpsz[j]);
            // line break
            AppendText(hWndRE, szCRLF);
        }

    } //for j...

    ReduceFontCmd(hWndRE, FALSE, nReduceBy, TRUE);

    // Closing line
    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    ParaCmd(hWndRE, FALSE);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//  WABStyleMemo - Fills the Rich edit control with info from MI as per the memo style
//
//  hWndRE - handle to Print Formating Rich Edit Control
//  MI - MEMOINFO strcuture containing the info to print
//
//
//  The memo style consists of a dump of all the WAB Contacts properties one by one with
//      labels. Some properties are grouped togethor (eg all the phone properties)
//
////////////////////////////////////////////////////////////////////////////////////////////////
void WABStyleMemo(HWND hWndRE, MEMOINFO MI)
{
    BOOL bGapAddress = FALSE; // a gap before the address fields
    BOOL bGapPhone = FALSE;   // a gap before the phone fields
    BOOL bGapEmail = FALSE;
    BOOL bGapNotes = FALSE;
    BOOL bGapWeb = FALSE;
    ULONG i,j,k;

    // Add the heading
    TitleCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszSpace);
    AppendText(hWndRE, MI.lpsz[memoTitleName]);
    AppendText(hWndRE, szCRLF);
    TitleCmd(hWndRE, FALSE);

    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    AppendText(hWndRE, szCRLF);
    AppendText(hWndRE, szCRLF);
    ParaCmd(hWndRE, FALSE);


    for(j=memoName;j<memoMAX;j++)
    {
        int nLastChar;
        LPTSTR lpSpace = NULL;
        ULONG nLen = 0;

        if(MI.lpsz[j] && lstrlen(MI.lpsz[j]))
        {
            // Append an additional space if necessary ..
            switch(j)
            {
            case memoBusinessAddress:
            case memoHomeAddress:
                if(!bGapAddress)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapAddress = TRUE;
                }
                break;
            case memoBusinessPhone:
            case memoBusinessFax:
            case memoBusinessPager:
            case memoHomePhone:
            case memoHomeFax:
            case memoHomeCellular:
                if(!bGapPhone)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapPhone = TRUE;
                }
                break;
            case memoEmail:
                if(!bGapEmail)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapEmail = TRUE;
                }
                break;
            case memoBusinessWebPage:
            case memoHomeWebPage:
            case memoGroupMembers: // stick in group members here to save an extra variable
                if(!bGapWeb)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapWeb = TRUE;
                }
                break;
            case memoNotes:
                if(!bGapNotes)
                {
                    AppendText(hWndRE, szCRLF);
                    bGapNotes = TRUE;
                }
                break;
            } // switch

            // Set the paragraph formating
            ParaCmd(hWndRE, TRUE);
            // Set the current insertion font to bold
            BoldCmd(hWndRE, TRUE);
            // Add the label
            AppendText(hWndRE, MI.lpszLabel[j]);
            BoldCmd(hWndRE, FALSE);
            // Tab
            AppendText(hWndRE, lpszTab);
            // Add the value
            AppendText(hWndRE, MI.lpsz[j]);
            // line break
            AppendText(hWndRE, szCRLF);
            ParaCmd(hWndRE, FALSE);
        }

    } //for j...

    // Closing line
    ParaCmd(hWndRE, TRUE);
    AppendText(hWndRE, lpszFlatLine);
    ParaCmd(hWndRE, FALSE);

    return;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
//  WABFormatData - takes the given information and formats it into the
//      RichEdit Control for subsequent printing ..
//
//  lpIAB - LPADRBOOK pointer
//  hWndParent - HWND of Parent
//  hWndRE - HWDN of rich edit control used for formatting
//  hWndLV - List View containing the items which need to be printed
//  dwRange - Range to print (ALL or SELECTION)
//  dwStyle - Style to print (Phone List, Memo, Business Card)
//  ppi - PRINT INFO struct
//  bCurrentSortIsByLastName - Used to determine whether the names are printed
//      by first name or by last name. Current sort option in the list view decides
//
////////////////////////////////////////////////////////////////////////////////////
BOOL WABFormatData( LPADRBOOK   lpIAB,
                    HWND hWndParent,
                    HWND hWndRE,
                    HWND hWndLV,
                    DWORD dwRange,
                    DWORD dwStyle,
                    PRINTINFO * ppi,
                    BOOL bCurrentSortIsByLastName)
{
    BOOL bRet = FALSE;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    //LPTSTR lpszPrevEntry = NULL;
    TCHAR szPrevEntry[MAX_DISPLAY_NAME_LENGTH]; //32 chars

    if (!hWndRE || !hWndLV)
        goto out;

    if(ListView_GetItemCount(hWndLV) <= 0)
        goto out;

    if(dwStyle == stylePhoneList)
    {
        LoadString(hinstMapiX, idsDontDisplayInitials, szDontDisplayInitials, CharSizeOf(szDontDisplayInitials));
    }

    if((dwRange == rangeSelected) && (ListView_GetSelectedCount(hWndLV)<=0))
    {
        ShowMessageBox(hWndParent, IDS_ADDRBK_MESSAGE_NO_ITEM, MB_OK | MB_ICONEXCLAMATION);
        goto out;
    }

    StrCpyN(szPrevEntry, szEmpty, ARRAYSIZE(szPrevEntry));

    {
        int iItemIndex = 0, i = 0;
        int iLastItemIndex = -1;
        int nItemCount;

        if(dwRange == rangeSelected)
            nItemCount = ListView_GetSelectedCount(hWndLV);
        else if(dwRange == rangeAll)
            nItemCount = ListView_GetItemCount(hWndLV);


        for(i=0;i<nItemCount;i++)
        {
            int j;
            LPTSTR lpszData = NULL;
            ULONG ulMemSize = 0;
            HRESULT hr;
            MEMOINFO MI = {0};
            LPRECIPIENT_INFO lpItem = NULL;

            if(dwRange == rangeSelected)
                iItemIndex = ListView_GetNextItem(hWndLV, iLastItemIndex, LVNI_SELECTED);
            else if(dwRange == rangeAll)
                iItemIndex = i;

            lpItem = GetItemFromLV(hWndLV, iItemIndex);

            if(lpItem)
            {
                if (HR_FAILED(  HrGetPropArray( lpIAB,
                                                NULL,
                                                lpItem->cbEntryID,
                                                lpItem->lpEntryID,
                                                MAPI_UNICODE,
                                                &ulcPropCount,
                                                &lpPropArray) ) )
                {
                    DebugPrintError(( TEXT("HrGetPropArray failed\n")));
                    goto out;
                }

                GetMemoInfoStruct(lpIAB, ulcPropCount, lpPropArray, dwStyle, &MI, bCurrentSortIsByLastName);

                SetPrintDialogMsg(0, idsPrintFormattingName, MI.lpsz[memoTitleName]);

                // Poll the cancel dialog to see if the user wants to cancel
                if (!ppi->pfnAbortProc(ppi->hdcPrn, 0))
                {
                    FreeMemoInfoStruct(&MI);
                    DebugPrintError(( TEXT("User canceled printing ...\n")));
                    goto out;
                }

                switch(dwStyle)
                {
                case styleMemo:
                    WABStyleMemo(hWndRE, MI);
                    break;
                case styleBusinessCard:
                    WABStyleBusinessCard(hWndRE, MI);
                    break;
                case stylePhoneList:
                    WABStylePhoneList(hWndRE, MI, szPrevEntry, ARRAYSIZE(szPrevEntry));
                    //if(lpszPrevEntry)
                    //    LocalFreeAndNull(&lpszPrevEntry);
                    //lpszPrevEntry = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lstrlen(MI.lpsz[memoTitleName])+1));
                    //if(!lpszPrevEntry)
                        //goto out;
                    //lstrcpy(lpszPrevEntry, MI.lpsz[memoTitleName]);
                    break;
                }

                FreeMemoInfoStruct(&MI);
            }

            if(lpPropArray)
                MAPIFreeBuffer(lpPropArray);

            lpPropArray = NULL;

            // fill in some space between multiple contacts
            {
                int numBreaks = (dwStyle == stylePhoneList) ? 1 : 4;
                for(j=0;j<numBreaks;j++)
                    AppendText(hWndRE, szCRLF);
            }

            if(dwRange == rangeSelected)
                iLastItemIndex = iItemIndex;

        } // for i ...
    }


    bRet = TRUE;
out:

    //if(lpszPrevEntry)
    //    LocalFreeAndNull(&lpszPrevEntry);

    if(lpPropArray)
        MAPIFreeBuffer(lpPropArray);

    return bRet;
}







/*
 *        ScPrintBody
 *
 *        Purpose:
 *            To print the body of each message
 *
 *        Arguments:
 *            ppi                    Pointer to the PRINTINFO structure
 *            cyGap                Gap above message text
 //*            pmsg                Pointer to message whose body is to be printed
 *            hwndRE                Pre-rendered body
 *            lpszTxt               Txt to print
 *
 *        Returns:
 *            SCODE indicating success or failure
 *
 */
SCODE ScPrintBody(PRINTINFO * ppi, int cyGap)
{
    SCODE           sc=S_OK;
    RECT            rcSep;
    FORMATRANGE     fr;
    HWND            hwndRE = ppi->hwndRE;

    int                ifrm;
    LONG        lTextLength = 0;   
    LONG        lTextPrinted = 0;  

    DebugPrintTrace(( TEXT("ScPrintBody\n")));

    // Put a gap between the fields the message text

    rcSep = ppi->rcBand;
    if (rcSep.top + cyGap > ppi->yFooter)
    {
        // Adding the gap will go past the page. Just go to the next page
        sc = ScGetNextBand(ppi, TRUE);
    }
    else
    {
        // Keep on getting a band till the bottom of the band passes the gap
        while (rcSep.top + cyGap > ppi->rcBand.bottom)
            if ((sc = ScGetNextBand(ppi, TRUE)) != S_OK)
                goto CleanUp;

        // Adjust the band so that we don't damage the gap
        ppi->rcBand.top += cyGap + 1;
    }


#ifdef DEBUG_PRINTMSGS
    InvalidateRect(ppi->hwndRE, NULL, TRUE);
    UpdateWindow(ppi->hwndRE);
#endif

    // Format the text for printing
    fr.hdc = ppi->hdcPrn;
    fr.hdcTarget = 0;
    fr.rcPage.left = fr.rcPage.top = 0;
    fr.rcPage.right = (int)LPixelsToTwips(ppi->sizePage.cx, ppi->sizeInch.cx);
    fr.rcPage.bottom = (int)LPixelsToTwips(ppi->sizePage.cy, ppi->sizeInch.cy);
    fr.chrg.cpMin = 0;
    fr.chrg.cpMax = -1;
    
    lTextLength = (LONG) SendMessage(hwndRE, WM_GETTEXTLENGTH, 0, 0);
    lTextPrinted = 0;

    // Handle no body case
    if (lTextLength <= 0)
        goto CleanUp;

    // tell RichEdit not to erase the background before rendering text
    SetBkMode(fr.hdc, TRANSPARENT);

    do
    {
        fr.chrg.cpMin = lTextPrinted;

        // Tell format range where to render to
        fr.rc.top = (int) LPixelsToTwips(ppi->rcBand.top, ppi->sizeInch.cy);
        fr.rc.left = (int) LPixelsToTwips(ppi->rcBand.left, ppi->sizeInch.cx);
        fr.rc.right = (int) LPixelsToTwips(ppi->rcBand.right, ppi->sizeInch.cx);
        fr.rc.bottom = (int) LPixelsToTwips(min(ppi->rcBand.bottom, ppi->yFooter), ppi->sizeInch.cy);

        // Go draw it
        DebugPrintTrace(( TEXT("Rendering\r\n")));
        lTextPrinted = (LONG) SendMessage(hwndRE, EM_FORMATRANGE, TRUE,(LPARAM) &fr);
        //TextOut(ppi->hdcPrn, fr.rc.left, fr.rc.top, lpszTxt, lstrlen(lpszTxt));

        // weird bug with RichEdit20 .. lTextPrinted is actually reduces in size
        // Another weird bug ... lTextPrinted is never incremented.  [PaulHi]
        if(lTextPrinted <= fr.chrg.cpMin)
            break;

    } while (lTextPrinted > 0 &&
              lTextPrinted < lTextLength &&
              (sc = ScGetNextBand(ppi, TRUE)) == S_OK);

    //$ Raid 1137: Need to clear out the cached font characteristics
    fr.chrg.cpMin = fr.chrg.cpMax + 1;
    //SendMessage(hwndRE, EM_FORMATRANGE, 0, 0);

    // Don't damage what we have just printed
    ppi->rcBand.top = NTwipsToPixels(fr.rc.bottom, ppi->sizeInch.cy);

CleanUp:
    DebugPrintTrace(( TEXT("ScPrintBody:%d\n"), sc));
    return sc;
}













/*
 *        ScPrintMessage
 *
 *        Purpose:
 *            To print the header and body of a message
 *
 *        Arguments:
 *            ppi                    Pointer to the PRINTINFO structure
 *            pmsg                Pointer to the message which needs its header
 *                                to be printed.
 *            hwndRE                Pre-rendered body
 *            phi                    Message header info
 *
 *        Returns:
 *            SCODE indicating success or failure
 *
 */
SCODE ScPrintMessage(PRINTINFO * ppi, HWND hWndRE)
{
    RECT            rcExt;
    RECT            rcSep;
    HFONT           hfontOld = NULL;
    HBRUSH          hbrushOld = NULL;
    HPEN            hpenOld = NULL;
    SIZE            sizeExt;
    int             cyHeader;
    SCODE           sc = S_OK;
    PARAFORMAT      pf = { 0 };

    pf.cbSize = sizeof(PARAFORMAT);


    // If we currently have no band, get the next band
    if (IsRectEmpty(&ppi->rcBand) &&
         (sc = ScGetNextBand(ppi, TRUE)) != S_OK)
        goto CleanUp;

    // Determine how much room we need for the header string and separator

    hfontOld = (HFONT)SelectObject(ppi->hdcPrn, ppi->hfontSep);
    hbrushOld = (HBRUSH)SelectObject(ppi->hdcPrn, GetStockObject(BLACK_BRUSH));
    hpenOld = (HPEN)SelectObject(ppi->hdcPrn, GetStockObject(BLACK_PEN));

    // Find out how much space our text take will take
    GetTextExtentPoint(ppi->hdcPrn, ppi->szHeader, lstrlen(ppi->szHeader),
                        &sizeExt);
    cyHeader = 2 * sizeExt.cy + 1 + (cySepFontSize(ppi) / 4);

    // Check if enough room on page. Move to the next page as needed

    if (ppi->rcBand.top + cyHeader > ppi->yFooter)
    {
        // No more room on this page, see if it'll fit on the next page
        if (ppi->rcMargin.top + cyHeader > ppi->yFooter)
        {
            DebugPrintTrace(( TEXT("Header too big for any page.\n")));
            goto CleanUp;
        }

        // Go on to the next page
        if ((sc = ScPrintRestOfPage(ppi, TRUE)) != S_OK)
            goto CleanUp;
    }

    // Calculate the rectangle that our header will take up
    rcExt = ppi->rcBand;
    rcExt.bottom = rcExt.top + cyHeader;
    rcSep = rcExt;
    rcSep.top += sizeExt.cy;
    rcSep.bottom = rcSep.top + (cySepFontSize(ppi) / 4);
    rcSep.right = rcSep.left + sizeExt.cx;

    // Draw the text and separator
    TextOut(ppi->hdcPrn, rcExt.left, rcExt.top, ppi->szHeader,
             lstrlen(ppi->szHeader));

    Rectangle(ppi->hdcPrn, rcSep.left, rcSep.top, rcSep.right, rcSep.bottom);
    MoveToEx(ppi->hdcPrn, rcSep.right, rcSep.top, NULL);
    LineTo(ppi->hdcPrn, rcExt.right, rcSep.top);

    rcExt.top = rcExt.bottom + 5;


/***/
    // Adjust the band so that we don't damage the header
    ppi->rcBand.top = rcExt.bottom + 1;

    // Create a header in a richedit control

    pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_ALIGNMENT |
                PFM_OFFSET | PFM_TABSTOPS;
    pf.dxOffset = LGetHeaderIndent();
    pf.cTabCount = 1;
    pf.rgxTabs[0] = pf.dxOffset;
    pf.wAlignment = PFA_LEFT;

    sc = ScPrintBody(ppi, sizeExt.cy);
/***/
CleanUp:
    if (hfontOld != NULL)
        SelectObject(ppi->hdcPrn, hfontOld);
    if (hbrushOld != NULL)
        SelectObject(ppi->hdcPrn, hbrushOld);
    if (hpenOld != NULL)
        SelectObject(ppi->hdcPrn, hpenOld);

    return sc;
}


#ifdef WIN16
typedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
#endif


#ifdef WIN16
typedef UINT (CALLBACK *LPPRINTHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
typedef UINT (CALLBACK *LPSETUPHOOKPROC) (HWND, UINT, WPARAM, LPARAM);
#endif

//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//
// SetPrintDlgExStruct - Fills in the default PDEX values
//
//  hWnd - HWND of parent dialog
//  PD - PrintDLG struct
//  hWndLV - HWND of listView to print from - if there are no selections in the list view,
//          the selections option is turned off in the print dialog
//
////////////////////////////////////////////////////////////////////////////////////////////////
void SetPrintDlgExStruct(HWND hWnd, PRINTDLGEX * lpPD, HWND hWndLV, LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    // set up the print dialog stuff
    // Call the common print dialog to get the default
    PRINTDLGEX    pd={0};

    pd.lStructSize = sizeof(PRINTDLGEX);
    pd.hwndOwner = hWnd;
    pd.hDevMode = (HANDLE) NULL;
    pd.hDevNames = (HANDLE) NULL;
    pd.hDC = (HDC) NULL;
    pd.Flags =  PD_RETURNDC |           // return PrintDC
                PD_DISABLEPRINTTOFILE |
                PD_ENABLEPRINTTEMPLATE |
                PD_HIDEPRINTTOFILE |
                PD_NOPAGENUMS;
    pd.Flags2 = 0;
    if(ListView_GetSelectedCount(hWndLV) > 0)
        pd.Flags |= PD_SELECTION;
    else
        pd.Flags |= PD_NOSELECTION;

    pd.nCopies = 1;

    pd.hInstance = hinstMapiX;
    pd.lpPrintTemplateName = MAKEINTRESOURCE(IDD_DIALOG_PRINTDLGEX); //(LPSTR) NULL;
    pd.lpCallback = (LPUNKNOWN)lpWABPCO;           // app callback interface
    
    pd.nPropertyPages = 0;
    pd.lphPropertyPages = NULL;
    
    pd.nStartPage = START_PAGE_GENERAL;

    *lpPD = pd;

    return;
}

//$$////////////////////////////////////////////////////////////////////////////////////////////
//
//
// SetPrintDlgStruct - Fills in the default PD values
//
//  hWnd - HWND of parent dialog
//  PD - PrintDLG struct
//  hWndLV - HWND of listView to print from - if there are no selections in the list view,
//          the selections option is turned off in the print dialog
//
////////////////////////////////////////////////////////////////////////////////////////////////
void SetPrintDlgStruct(HWND hWnd, PRINTDLG * lpPD, HWND hWndLV, LPARAM lCustData)
{
    // set up the print dialog stuff
    // Call the common print dialog to get the default
    PRINTDLG    pd={0};

    pd.lStructSize = sizeof(PRINTDLG);
    pd.hDevMode = (HANDLE) NULL;
    pd.hDevNames = (HANDLE) NULL;

    pd.Flags =  PD_RETURNDC |           // return PrintDC
                PD_NOPAGENUMS |         // Disable Page number option
                PD_DISABLEPRINTTOFILE |
                PD_HIDEPRINTTOFILE |
                PD_ENABLEPRINTHOOK |
                PD_ENABLEPRINTTEMPLATE;

    if(ListView_GetSelectedCount(hWndLV) > 0)
        pd.Flags |= PD_SELECTION;
    else
        pd.Flags |= PD_NOSELECTION;

    pd.hwndOwner = hWnd;
    pd.hDC = (HDC) NULL;
    pd.nFromPage = 1;
    pd.nToPage = 1;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 1;
    pd.hInstance = hinstMapiX;
    pd.lCustData = lCustData;
    pd.lpfnPrintHook = (LPPRINTHOOKPROC) &fnPrintDialogProc; //NULL;
    pd.lpfnSetupHook = (LPSETUPHOOKPROC) NULL;
    pd.lpPrintTemplateName = MAKEINTRESOURCE(IDD_DIALOG_PRINTDLGORD); //(LPSTR) NULL;
    pd.lpSetupTemplateName = (LPTSTR)  NULL;
    pd.hPrintTemplate = (HANDLE) NULL;
    pd.hSetupTemplate = (HANDLE) NULL;

    *lpPD = pd;

    return;
}


/*
-
-   HrGetPrintData
-
    Determines whether to show the new print dialog or the old print dialog
    Fills in all the structures appropriately and returns the values we
    care about such as nCopies, Print style, etc
*
*
*/
HRESULT HrGetPrintData(LPADRBOOK lpAdrBook, HWND hWndParent, HWND hWndLV, 
                       HDC * lphdcPrint, int * lpnCopies, 
                       DWORD * lpdwStyle, DWORD * lpdwRange)
{
    DWORD dwSelectedStyle = styleMemo;
    HRESULT hr = S_OK;
    LPWABPRINTDIALOGCALLBACK lpWABPCO = NULL;
    PRINTDLG pd = {0};
    PRINTDLGEX pdEx = {0};

    // Test for presence of NT5 PrintDlgEx

    if(!HR_FAILED(hr = PrintDlgEx(NULL)))
    {
        if(HR_FAILED(hr = HrCreatePrintCallbackObject((LPIAB)lpAdrBook,&lpWABPCO,dwSelectedStyle)))
            goto out;
        if(!lpWABPCO)
        {
            hr = E_FAIL;
            goto out;
        }
        SetPrintDlgExStruct(hWndParent, &pdEx, hWndLV, lpWABPCO);
        if(HR_FAILED(hr = PrintDlgEx(&pdEx)))
        {
            DebugTrace( TEXT("PrintDlgEx returns 0x%.8x\n"),hr);
            // #98841 Millenium returns fail in this case, but for PrintDlgEx(NULL) it returns S_OK (YST)
            goto doOldPrint;
        }
        *lphdcPrint = pdEx.hDC;
        *lpnCopies = pdEx.nCopies;
        *lpdwStyle = lpWABPCO->dwSelectedStyle;
        if (pdEx.Flags & PD_SELECTION)
            *lpdwRange = rangeSelected;
        else
            *lpdwRange = rangeAll;
    }
    else
    {
doOldPrint:
        SetPrintDlgStruct(hWndParent, &pd, hWndLV, (LPARAM) &dwSelectedStyle);
        // Show the print dialog
        if(!PrintDlg(&pd))
            goto out;
        *lphdcPrint = pd.hDC;
        *lpnCopies = pd.nCopies;
        *lpdwStyle = dwSelectedStyle;
        if (pd.Flags & PD_SELECTION)
            *lpdwRange = rangeSelected;
        else
            *lpdwRange = rangeAll;
        hr = S_OK;
    }    
out:
    if(lpWABPCO)
        lpWABPCO->lpVtbl->Release(lpWABPCO);

    return hr;
}


//$$////////////////////////////////////////////////////////////////////////////////
//
// HrPrintItems - Prints selected contacts
//      Prints the contents of the address book
//      Pops up a dialog that lets user select what he wants to print
//          Options are (or will be)
//          All or selected
//          Style - memo, business, or phone book
//
//      Items are printed using the current sort style in the list view
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT HrPrintItems(   HWND hWnd,
                        LPADRBOOK lpAdrBook,
                        HWND hWndLV,
                        BOOL bCurrentSortisByLastName)
{
    HRESULT hr = E_FAIL;
    HWND hWndRE = NULL; // we'll do our formating in a riceh edit control and use that for printing
    PRINTINFO 	*ppi=0;
    BOOL fStartedDoc = FALSE;
    BOOL fStartedPage= FALSE;
    DOCINFO     docinfo={0};
    HCURSOR hOldCur = NULL;
    int i,nCode;
    HINSTANCE hRELib = NULL;
    LPPTGDATA lpPTGData=GetThreadStoragePointer();
    LPIAB lpIAB = (LPIAB)lpAdrBook;

    HDC hdcPrint = NULL;
    int nCopies = 0;
    DWORD dwStyle;
    DWORD dwRange;
    
    // Double check if there are any print extensions that we need to accomodate
    //
    if(bCheckForPrintExtensions(NULL, 0))
    {
        // Found a print extension
        hr = HrUseWABPrintExtension(hWnd, lpAdrBook, hWndLV);
        goto out;
    }

    if(!(ppi = LocalAlloc(LMEM_ZEROINIT, sizeof(PRINTINFO))))
        goto out;
    ppi->hwndDlg = hWnd;

    if(HR_FAILED(HrGetPrintData(lpAdrBook, hWnd, hWndLV, &hdcPrint, &nCopies, &dwStyle, &dwRange)))
        goto out;

    if(!hdcPrint)
        goto out;

    // Take care of zilch copies
    //
    // Actually it seems that this number is meaningless if the printer can handle multiple
    // copies. If the printer can't handle multiple copies, we will get info in this number.
    //
    if(!nCopies)
		nCopies = 1;

    ppi->hdcPrn = hdcPrint;

    // Create a RichEdit control in which we will do our formatting
    hRELib = LoadLibrary( TEXT("riched20.dll"));
    if(!hRELib)
    {
        hRELib = LoadLibrary( TEXT("riched32.dll"));
        s_bUse20 = FALSE;
    }
    //IF_WIN16(hRELib = LoadLibrary( TEXT("riched.dll"));)
    if(!hRELib)
        goto out;

    hWndRE = CreateWindowEx(0, 
                            (s_bUse20 ? RICHEDIT_CLASS : TEXT("RichEdit")), 
                            TEXT(""),WS_CHILD | ES_MULTILINE,
                            CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
                            hWnd,(HMENU) NULL,hinstMapiX,NULL);

    if (!hWndRE)
        goto out;

    //////////////////////////
    {
        CHARFORMAT  cf = {0};
        TCHAR       rgch[CCHMAX_STRINGRES];
        DWORD       dwCodepage ;
        CHARSETINFO rCharsetInfo;
        LOGFONT lfSystem;
        BOOL bNeedLargeFont = FALSE;

        cf.cbSize = sizeof(cf);
        cf.dwMask = CFM_FACE;

        SendMessage(hWndRE, EM_GETCHARFORMAT, (WPARAM) TRUE, (LPARAM) &cf);

        if(LoadString(hinstMapiX, idsDefaultFontFace, rgch, ARRAYSIZE(rgch)))
            StrCpyN(cf.szFaceName, rgch, ARRAYSIZE(cf.szFaceName));
        else
            StrCpyN(cf.szFaceName, szDefFont, ARRAYSIZE(cf.szFaceName));

        // [a-msadek] bug#56478
        // Arail does not support Thai so as all other base fonts
        // The best way to determine the OS language is from system font charset
        if(GetObject(GetStockObject(SYSTEM_FONT), sizeof(lfSystem), (LPVOID)&lfSystem))
        {
            if (lfSystem.lfCharSet == THAI_CHARSET)
            {
                StrCpyN(cf.szFaceName, szThaiDefFont, ARRAYSIZE(cf.szFaceName));

                // Thai Font sizes are always smaller than English as the vowl and tone
                // markes consumes some of the font height
                bNeedLargeFont = TRUE;
            }
        }

        // bug #53058 - set correct CharSet info for Eastern European
        dwCodepage = GetACP();
        // Get GDI charset info
        if ( dwCodepage != 1252 && TranslateCharsetInfo((LPDWORD) IntToPtr(dwCodepage) , &rCharsetInfo, TCI_SRCCODEPAGE))
            cf.bCharSet = (BYTE) rCharsetInfo.ciCharset;

        SendMessage(hWndRE, EM_SETCHARFORMAT, (WPARAM) SCF_ALL, (LPARAM) &cf);
        if(bNeedLargeFont)
        {
            ReduceFontCmd(hWndRE, FALSE, 80, TRUE);
        }

    }
    //////////////////////////


    // At the top of the print job, print the header with the users name or with
    // the default  TEXT("Windows Address Book") title
    {
        TCHAR szHead[MAX_PATH];
        DWORD dwLen = ARRAYSIZE(szHead);
        SCODE sc;
        *szHead = '\0';
        if(bIsThereACurrentUser(lpIAB) && lstrlen(lpIAB->szProfileName))
            StrCpyN(szHead, lpIAB->szProfileName, ARRAYSIZE(szHead));
        else 
            GetUserName(szHead, &dwLen);
        if(!lstrlen(szHead))
            LoadString(hinstMapiX, IDS_ADDRBK_CAPTION, szHead, ARRAYSIZE(szHead));

        if (( sc = ScInitPrintInfo( ppi, hWnd, szHead, &g_rcBorder, hWndRE)) != S_OK)
            goto out;
    }

    // While the printing is in progress, we dont want the user to mess with the
    // listview selection otherwise the print job will print the wrong entries
    // Hence we disable this window (since the print cancel dialog is really a modeless dialog)
    EnableWindow(hWnd, FALSE);

    CreateShowAbortDialog(hWnd, 0, 0, ListView_GetSelectedCount(hWndLV), 0);

    // Format the prop data into the Rich Edit Control
    if(!WABFormatData(lpAdrBook, hWnd, hWndRE, hWndLV, dwRange, dwStyle, ppi, bCurrentSortisByLastName))
        goto out;

	if(bTimeToAbort())
        goto out;

    for(i=0;i<nCopies;i++)
    {
        TCHAR szBuf[MAX_PATH];

        LoadString(hinstMapiX, idsPrintDocTitle, szBuf, ARRAYSIZE(szBuf));

        docinfo.cbSize = sizeof(docinfo);
        docinfo.lpszDocName = szBuf;
        docinfo.lpszOutput = NULL;

        SetMapMode(hdcPrint, MM_TEXT);

        // Set the abort procedure
        if ((nCode=SetAbortProc(ppi->hdcPrn, ppi->pfnAbortProc)) <= 0)
        {
            hr = E_FAIL;
            break;
        }

	    if(bTimeToAbort())
            goto out;

        // Start a print job
        if (StartDoc(ppi->hdcPrn, &docinfo) <= 0)
        {
            DebugPrintError(( TEXT("StartDoc failed: %d\n"), GetLastError()));
            goto out;
        }
        fStartedDoc = TRUE;

        //StartPage(pd.hDC);
	    if(bTimeToAbort())
            goto out;


        // Go on and print the message!
        if (ScPrintMessage(ppi, hWndRE) != S_OK)
                goto out;

	    if(bTimeToAbort())
            goto out;

        // End the page
        if(ScGetNextBand( ppi, FALSE) != S_OK)
            goto out;

	    if(bTimeToAbort())
            goto out;

        // Finish up the print job if it had been started
        if (fStartedDoc)
        {
            EndDoc(ppi->hdcPrn);
            fStartedDoc = FALSE;
        }
    }

    hr = hrSuccess;

out:

    if(hWndRE)
    {
        SendMessage(hWndRE, WM_SETTEXT, 0, (LPARAM)szEmpty);
        SendMessage(hWndRE, WM_CLEAR, 0, 0);
    }

    if(bTimeToAbort())
    {
        hr = MAPI_E_USER_CANCEL;
        pt_bPrintUserAbort = FALSE;
    }

    // Re-enable the window and ensure it stays put
    EnableWindow(hWnd, TRUE);
    //SetWindowPos(hWnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER);

    CloseAbortDlg();

    // Finish up the print job if it had been started
    if (fStartedDoc)
        EndDoc(ppi->hdcPrn);

    // Get rid of our Rich Edit control
    if (hWndRE)
        DestroyWindow(hWndRE);

    if(hOldCur)
        SetCursor(hOldCur);

    if(ppi)
    {
        if(ppi->hfontPlain)
            DeleteObject(ppi->hfontPlain);
        if(ppi->hfontBold)
            DeleteObject(ppi->hfontBold);
        if(ppi->hfontSep)
            DeleteObject(ppi->hfontSep);
        LocalFreeAndNull(&ppi);
    }

    if(hRELib)
        FreeLibrary((HMODULE) hRELib);

    return hr;
}


/*
*   Handles the WM_INITDIALOG for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMInitDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LPDWORD lpdwStyle)
{
    DWORD dwStyle = lpdwStyle ? *lpdwStyle : styleMemo;
    int nID;

    switch (dwStyle)
    {
    case styleBusinessCard:
        nID = IDC_PRINT_RADIO_CARD;
        break;
    case stylePhoneList:
        nID = IDC_PRINT_RADIO_PHONELIST;
        break;
    default:
    case styleMemo:
        nID = IDC_PRINT_RADIO_MEMO; //default
        break;
    }
    CheckRadioButton(   hDlg, IDC_PRINT_RADIO_MEMO, IDC_PRINT_RADIO_PHONELIST, nID);
    SetFocus(hDlg);
    return 0;
}
/*
*   Handles the WM_COMMAND for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMCommand(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LPDWORD lpdwStyle )
{
    switch (GET_WM_COMMAND_ID(wParam,lParam))
    {
    case IDC_PRINT_RADIO_MEMO:
        //lpPD->lCustData = (DWORD) styleMemo;
        *lpdwStyle = (DWORD) styleMemo;
        break;
    case IDC_PRINT_RADIO_CARD:
        //lpPD->lCustData = (DWORD) styleBusinessCard;
        *lpdwStyle = (DWORD) styleBusinessCard;
        break;
    case IDC_PRINT_RADIO_PHONELIST:
        //lpPD->lCustData = (DWORD) stylePhoneList;
        *lpdwStyle = (DWORD) stylePhoneList;
        break;
    }
    return 0;
}
/*
*   Handles the WM_HELP for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMHelp(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LPDWORD lpdwStyle )
{
    int id = ((LPHELPINFO)lParam)->iCtrlId;
    if( id == IDC_PRINT_FRAME_STYLE ||
        id == IDC_PRINT_RADIO_MEMO ||
        id == IDC_PRINT_RADIO_CARD ||
        id == IDC_PRINT_RADIO_PHONELIST)
    {
        WABWinHelp(((LPHELPINFO)lParam)->hItemHandle,
                g_szWABHelpFileName,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR) rgPrintHelpIDs );
    }

    return FALSE;
}
/*
*   Handles the WM_CONTEXTMENU for both PrintDlg and PrintDlgEx
*/
BOOL bHandleWMContextMenu(HWND hDlg, UINT message, WPARAM wParam,LPARAM lParam,LPDWORD lpdwStyle )
{
    HWND hwnd = (HWND) wParam;
    if( hwnd == GetDlgItem(hDlg, IDC_PRINT_FRAME_STYLE) ||
        hwnd == GetDlgItem(hDlg, IDC_PRINT_RADIO_MEMO) ||
        hwnd == GetDlgItem(hDlg, IDC_PRINT_RADIO_CARD) ||
        hwnd == GetDlgItem(hDlg, IDC_PRINT_RADIO_PHONELIST) )
    {
        WABWinHelp((HWND) wParam,
                g_szWABHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) rgPrintHelpIDs );
    }
    
    return FALSE;
}

//$$*****************************************************************
//
//  FUNCTION:   fnPrintDialogProc
//
//  PURPOSE:    Printer dialog hook procedure
//
//              We have modified the CommDlg print template with the
//              WAB print styles.
//              This is a hook procedure that takes care of our
//              newly added controls
//
// When WM_INITDIALOG is called, the lParam contains a pointer to the
//  PRINTDLG structure controling the print setup dialog
//
//*******************************************************************
INT_PTR CALLBACK fnPrintDialogProc( HWND    hDlg,
                                    UINT    message,
                                    WPARAM  wParam,
                                    LPARAM  lParam)
{

    LPDWORD lpdwStyle = (LPDWORD) GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        {
            LPPRINTDLG lpPD = (LPPRINTDLG) lParam;
#ifdef WIN16
// Strange situation here. If I don't create edt1 and edt2 which are used for page range, entire print dialog work incorrectly.
// So I just add two controls(edt1 and edt2) and hide those here.
            ShowWindow(GetDlgItem(hDlg, edt1), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, edt2), SW_HIDE);
#endif
            if(lpPD)
            {
                lpdwStyle = (LPDWORD) lpPD->lCustData;
                SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)lpdwStyle); //Save this for future reference
                return bHandleWMInitDialog(hDlg,message,wParam,lParam,lpdwStyle);
            }
        }
        SetFocus(hDlg);
        return 0;
        break;

   case WM_COMMAND:
       if(lpdwStyle)
            return bHandleWMCommand(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    case WM_HELP:
        return bHandleWMHelp(hDlg,message,wParam,lParam,lpdwStyle);
        break;


#ifndef WIN16
    case WM_CONTEXTMENU:
        return bHandleWMContextMenu(hDlg,message,wParam,lParam,lpdwStyle);
        break;
#endif // !WIN16



    default:
        return FALSE;
        break;
    }

    return FALSE;
}


/**************************************************************************************************
 *        ScInitPrintInfo
 *
 *        Purpose:
 *            Initialize the fields of a print info structure relevant for
 *            the actual printing.
 *
 *        Arguments:
 *            ppi                 Pointer to the PRINTINFO structure
 *            hwnd                The owner of the print dialog box
 *            szHeader            The string to be printed at the top of each
 *                                message
 *            prcBorder           Pointer to a rect whose fields contain the
 *                                number of twips to use as a margin around the
 *                                printed text.
 *              hWndRE            rich edit control in which we will do our formatting
 *
 *        Returns:
 *            SCODE indicating success or failure
 *
 ***************************************************************************************************/
SCODE ScInitPrintInfo(   PRINTINFO * ppi,
                                HWND hwnd,
                                LPTSTR szHeader,
                                RECT * prcBorder,
                                HWND hWndRE)
{
    SIZE        sizeExt;
    LOGFONT     logfont    = {0};
    HFONT       hfontOld;
    TCHAR       szT[20];
    SCODE       sc = S_OK;
    TCHAR       rgch[CCHMAX_STRINGRES];

    // Save handle to our parent window
    ppi->hwnd = hwnd;

    // Save a pointer to our header string
    ppi->szHeader = szHeader;

    // Set up pointer to our abort procedure
    ppi->pfnAbortProc = FAbortProc;

    ppi->hwndRE = hWndRE;

    // Determine the page size in pixels
    ppi->sizePage.cx = GetDeviceCaps(ppi->hdcPrn, HORZRES);
    ppi->sizePage.cy = GetDeviceCaps(ppi->hdcPrn, VERTRES);

    // Exchange 13497: If we have nothing to render to abort now.
    if (!ppi->sizePage.cx || !ppi->sizePage.cy)
    {
        sc = E_FAIL;
        goto CleanUp;
    }

    ///MoveWindow(hWndRE, 0, 0, ppi->sizepage.cx, ppi->sizepage.cy, FALSE);

    // Determine the number of pixels in a logical inch
    ppi->sizeInch.cx = GetDeviceCaps(ppi->hdcPrn, LOGPIXELSX);
    ppi->sizeInch.cy = GetDeviceCaps(ppi->hdcPrn, LOGPIXELSY);

    // Exchange 13497: If we failed to get some info make some assumptions.
    //                    At worst assume 300 dpi.
    if (!ppi->sizeInch.cx)
        ppi->sizeInch.cx = ppi->sizeInch.cy ? ppi->sizeInch.cy : 300;
    if (!ppi->sizeInch.cy)
        ppi->sizeInch.cy = 300;

    //$ Raid 2667: Determine if we still fit within the page in twips
    if (LPixelsToTwips(ppi->sizePage.cx, ppi->sizeInch.cx) > INT_MAX ||
         LPixelsToTwips(ppi->sizePage.cy, ppi->sizeInch.cy) > INT_MAX)
    {
        sc = E_FAIL;
        goto CleanUp;
    }


    // Set up the margin settings
    ppi->rcMargin.top = NTwipsToPixels(prcBorder->top, ppi->sizeInch.cy);
    ppi->rcMargin.bottom = ppi->sizePage.cy
                        - NTwipsToPixels(prcBorder->bottom, ppi->sizeInch.cy);
    if (ppi->rcMargin.bottom < ppi->rcMargin.top)
    {
        // Bottom is above top. Top/Bottom margins ignored
        ppi->rcMargin.top = 0;
        ppi->rcMargin.bottom = ppi->sizePage.cy;
    }

    ppi->rcMargin.left = NTwipsToPixels(prcBorder->left, ppi->sizeInch.cx);
    ppi->rcMargin.right = ppi->sizePage.cx
                        - NTwipsToPixels(prcBorder->right, ppi->sizeInch.cx);
    if (ppi->rcMargin.right < ppi->rcMargin.left)
    {
        // Right is left of left. Left/Right margins ignored
        ppi->rcMargin.left = 0;
        ppi->rcMargin.right = ppi->sizePage.cx;
    }


    // Set up the separator font
    //$ Raid 2773: Let user customize separator font
    logfont.lfHeight = - cySepFontSize(ppi);
    logfont.lfWeight = FW_BOLD;
    logfont.lfCharSet =  DEFAULT_CHARSET;
    if (LoadString(hinstMapiX, idsDefaultFontFace, rgch, ARRAYSIZE(rgch)))
        StrCpyN(logfont.lfFaceName, rgch, ARRAYSIZE(logfont.lfFaceName));
    else
        StrCpyN(logfont.lfFaceName, szDefFont, ARRAYSIZE(logfont.lfFaceName));

    ppi->hfontSep = CreateFontIndirect(&logfont);

    // Set up common font
    ZeroMemory(&logfont, sizeof(LOGFONT));
    logfont.lfHeight = - 10 *  ppi->sizeInch.cy / cPtsPerInch;

    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet =  DEFAULT_CHARSET;
    if(LoadString(hinstMapiX, idsDefaultFontFace, rgch, ARRAYSIZE(rgch)))
        StrCpyN(logfont.lfFaceName, rgch, ARRAYSIZE(logfont.lfFaceName));
    else
        StrCpyN(logfont.lfFaceName, szDefFont, ARRAYSIZE(logfont.lfFaceName));
    ppi->hfontPlain = CreateFontIndirect(&logfont);

    logfont.lfWeight = FW_BOLD;
    ppi->hfontBold = CreateFontIndirect(&logfont);

    // Calculate where to put the footer

    // Load up the formatting string to use for page numbers
    //LoadString(hinstMapiX, idsFmtPageNumber, ppi->szPageNumber, ARRAYSIZE(ppi->szPageNumber));
    StrCpyN(ppi->szPageNumber, TEXT("%d"), ARRAYSIZE(ppi->szPageNumber));
    wnsprintf(szT, ARRAYSIZE(szT), ppi->szPageNumber, ppi->lPageNumber);

    // Sample the height
    hfontOld = (HFONT)SelectObject(ppi->hdcPrn, ppi->hfontPlain);
    GetTextExtentPoint(ppi->hdcPrn, szT, lstrlen(szT), &sizeExt);
    ppi->yFooter = ppi->rcMargin.bottom - sizeExt.cy;
    SelectObject(ppi->hdcPrn, hfontOld);

    // Make sure our footer doesn't go above the top of the page
    if (ppi->yFooter < ppi->rcMargin.top)
        sc = E_FAIL;

CleanUp:
    return sc;
}



//$$////////////////////////////////////////
//
// GetNumberFromStringResource
//
////////////////////////////////////////////
int GetNumberFromStringResource(int idNumString)
{
    TCHAR szBuf[MAX_PATH];

    if (LoadString(hinstMapiX, idNumString, szBuf, ARRAYSIZE(szBuf)))
        return my_atoi(szBuf);
    else
        return 0;
}



/*--------------------------------------------------------------------------------------------------*/
/*--IPrintDialogCallback stuff----------------------------------------------------------------------*/
/*--Special stuff for the new NT5 Print Dialog------------------------------------------------------*/
/*--------------------------------------------------------------------------------------------------*/

WAB_PRINTDIALOGCALLBACK_Vtbl vtblWABPRINTDIALOGCALLBACK = {
    VTABLE_FILL
    WAB_PRINTDIALOGCALLBACK_QueryInterface,
    WAB_PRINTDIALOGCALLBACK_AddRef,
    WAB_PRINTDIALOGCALLBACK_Release,
    WAB_PRINTDIALOGCALLBACK_InitDone,
    WAB_PRINTDIALOGCALLBACK_SelectionChange,
    WAB_PRINTDIALOGCALLBACK_HandleMessage
};

/*
-   HrCreatePrintCallbackObject
-
*
*   This callback object is needed so the new NT5 print dialog can provide send messages back to
*   us for the customization we do for the print dialog ..
*
*/
HRESULT HrCreatePrintCallbackObject(LPIAB lpIAB, LPWABPRINTDIALOGCALLBACK * lppWABPCO, DWORD dwSelectedStyle)
{
    LPWABPRINTDIALOGCALLBACK lpWABPCO = NULL;
    SCODE 		     sc;
    HRESULT 	     hr     		   = hrSuccess;

    //
    //  Allocate space for the IAB structure
    //
    if (FAILED(sc = MAPIAllocateBuffer(sizeof(WABPRINTDIALOGCALLBACK), (LPVOID *) &lpWABPCO))) 
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    MAPISetBufferName(lpWABPCO,  TEXT("WAB Print Dialog Callback Object"));

    ZeroMemory(lpWABPCO, sizeof(WABPRINTDIALOGCALLBACK));

    lpWABPCO->lpVtbl = &vtblWABPRINTDIALOGCALLBACK;

    lpWABPCO->lpIAB = lpIAB;

    lpWABPCO->dwSelectedStyle = dwSelectedStyle;

    lpWABPCO->lpVtbl->AddRef(lpWABPCO);

    *lppWABPCO = lpWABPCO;

    return(hrSuccess);

err:

    FreeBufferAndNull(&lpWABPCO);
    return(hr);
}


void ReleaseWABPrintCallbackObject(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    MAPIFreeBuffer(lpWABPCO);
}


STDMETHODIMP_(ULONG)
WAB_PRINTDIALOGCALLBACK_AddRef(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    return(++(lpWABPCO->lcInit));
}



STDMETHODIMP_(ULONG)
WAB_PRINTDIALOGCALLBACK_Release(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    ULONG ulc = (--(lpWABPCO->lcInit));
    if(ulc==0)
       ReleaseWABPrintCallbackObject(lpWABPCO);
    return(ulc);
}


STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_QueryInterface(LPWABPRINTDIALOGCALLBACK lpWABPCO,
                          REFIID lpiid,
                          LPVOID * lppNewObj)
{
    LPVOID lp = NULL;

    if(!lppNewObj)
        return MAPI_E_INVALID_PARAMETER;

    *lppNewObj = NULL;

    if(IsEqualIID(lpiid, &IID_IUnknown))
        lp = (LPVOID) lpWABPCO;

    if(IsEqualIID(lpiid, &IID_IPrintDialogCallback))
        lp = (LPVOID) lpWABPCO;

    if(!lp)
        return E_NOINTERFACE;

    ((LPWABPRINTDIALOGCALLBACK) lp)->lpVtbl->AddRef((LPWABPRINTDIALOGCALLBACK) lp);

    *lppNewObj = lp;

    return S_OK;

}

STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_InitDone(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    HRESULT hr = S_FALSE;
    DebugTrace( TEXT("WAB_PRINTDIALOGCALLBACK_InitDone\n"));
    return hr;
}

STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_SelectionChange(LPWABPRINTDIALOGCALLBACK lpWABPCO)
{
    HRESULT hr = S_FALSE;
    DebugTrace( TEXT("WAB_PRINTDIALOGCALLBACK_SelectionChange\n"));
    return hr;
}

STDMETHODIMP
WAB_PRINTDIALOGCALLBACK_HandleMessage(LPWABPRINTDIALOGCALLBACK lpWABPCO,
                                      HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
    BOOL bRet = FALSE;
    LPDWORD lpdwStyle = &lpWABPCO->dwSelectedStyle;

    DebugTrace( TEXT("WAB_PRINTDIALOGCALLBACK_HandleMessage: 0x%.8x\n"), message);

    switch(message)
    {
    case WM_INITDIALOG:
        bRet = bHandleWMInitDialog(hDlg,message,wParam,lParam,lpdwStyle);
        break;

   case WM_COMMAND:
        bRet = bHandleWMCommand(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    case WM_HELP:
        bRet = bHandleWMHelp(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    case WM_CONTEXTMENU:
        bRet = bHandleWMContextMenu(hDlg,message,wParam,lParam,lpdwStyle);
        break;

    default:
        bRet = FALSE;
        break;
    }

    return (bRet ? S_OK : S_FALSE);
}


/******************************************************************************************/


/*
-   bCheckForPrintExtensions
-
*   In case any app has implemented a Print Extension to the WAB, we should hook into
*   that print extension
*
*   lpDLLPath can be NULL or should point to a buffer big enough to receive the module Path
*
*/
static const LPTSTR szExtDisplayMailUser = TEXT("Software\\Microsoft\\WAB\\WAB4\\ExtPrint");
extern HrGetActionAdrList(LPADRBOOK lpAdrBook,HWND hWndLV,LPADRLIST * lppAdrList,LPTSTR * lppURL, BOOL * lpbIsNTDSEntry);

BOOL bCheckForPrintExtensions(LPTSTR lpDLLPath, DWORD cchSize)
{
    BOOL bRet = FALSE;
    HKEY hKey = NULL;

    if(ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,szExtDisplayMailUser,0, KEY_READ,&hKey))
    {
        goto out;
    }

    {
        TCHAR szExt[MAX_PATH];
        DWORD dwIndex = 0, dwSize = ARRAYSIZE(szExt), dwType = 0;
        *szExt = '\0';

        while(ERROR_SUCCESS == RegEnumValue(hKey, dwIndex, szExt, &dwSize, 
                                        0, &dwType, NULL, NULL))
        {
            // we found some entry in here .. the value name will be the full path
            // to the module containing the print function
            // Double-check that this module actually exists
            if (szExt && lstrlen(szExt) && (GetFileAttributes(szExt) != 0xFFFFFFFF))
            {
                if(lpDLLPath)
                    StrCpyN(lpDLLPath, szExt, cchSize);
                bRet = TRUE;
                goto out;
            }
        }
    }
    
out:
    if(hKey)
        RegCloseKey(hKey);
    return bRet;
}

/*
-
-   HrUseWABPrintExtension()
-
*   Loads the WAB Print Extension from the extension DLL
*   and calls into it
*
*   hWnd        - Handle of WAB parent
*   lpAdrBook   - lpAdrBook pointer
*   hWndLV      - listview from which a user may have chosen selections
*
*/
HRESULT HrUseWABPrintExtension(HWND hWnd, LPADRBOOK lpAdrBook, HWND hWndLV)
{
    TCHAR szExt[MAX_PATH];
    HRESULT hr = E_FAIL;
    HINSTANCE hInstPrint = NULL;
    LPWABPRINTEXT lpfnWABPrintExt = NULL;
    LPADRLIST lpAdrList = NULL;
    LPWABOBJECT lpWABObject = (LPWABOBJECT)((LPIAB)lpAdrBook)->lpWABObject;

    *szExt = '\0';
    if(!bCheckForPrintExtensions(szExt, ARRAYSIZE(szExt)) || !lstrlen(szExt))
        goto out;

    if(!(hInstPrint = LoadLibrary(szExt)))
        goto out;

    lpfnWABPrintExt = (LPWABPRINTEXT) GetProcAddress(hInstPrint, "WABPrintExt");
    if(!lpfnWABPrintExt)
        goto out;

    // Get the currently selected data from the list view
    if(HR_FAILED(hr = HrGetActionAdrList(lpAdrBook,hWndLV,&lpAdrList,NULL,NULL)))
        goto out;

    hr = lpfnWABPrintExt(lpAdrBook, lpWABObject, hWnd, lpAdrList);

out:
    if(lpAdrList)
        FreePadrlist(lpAdrList);
    if(hInstPrint)
        FreeLibrary(hInstPrint);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wabval.h ===
/*
 *	M A P I V A L . H
 *	
 *	Macros used to validate parameters on standard MAPI object methods.
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	_INC_VALIDATE
#define	_INC_VALIDATE

#ifdef __cplusplus
extern "C" {
#endif

#define MAKE_ENUM(Method, Interface)	Interface##_##Method

typedef enum _tagMethods
{
/* IUnknown */
	MAKE_ENUM(QueryInterface, IUnknown) = 0,
	MAKE_ENUM(AddRef, IUnknown),			/* For completness */
	MAKE_ENUM(Release, IUnknown),			/* For completness */
	
/* IMAPIProps */
	MAKE_ENUM(GetLastError, IMAPIProp),
	MAKE_ENUM(SaveChanges, IMAPIProp),
	MAKE_ENUM(GetProps, IMAPIProp),
	MAKE_ENUM(GetPropList, IMAPIProp),
	MAKE_ENUM(OpenProperty, IMAPIProp),
	MAKE_ENUM(SetProps, IMAPIProp),
	MAKE_ENUM(DeleteProps, IMAPIProp),
	MAKE_ENUM(CopyTo, IMAPIProp),
	MAKE_ENUM(CopyProps, IMAPIProp),
	MAKE_ENUM(GetNamesFromIDs, IMAPIProp),
	MAKE_ENUM(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_ENUM(GetLastError, IMAPITable),
	MAKE_ENUM(Advise, IMAPITable),
	MAKE_ENUM(Unadvise, IMAPITable),
	MAKE_ENUM(GetStatus, IMAPITable),
	MAKE_ENUM(SetColumns, IMAPITable),
	MAKE_ENUM(QueryColumns, IMAPITable),
	MAKE_ENUM(GetRowCount, IMAPITable),
	MAKE_ENUM(SeekRow, IMAPITable),
	MAKE_ENUM(SeekRowApprox, IMAPITable),
	MAKE_ENUM(QueryPosition, IMAPITable),
	MAKE_ENUM(FindRow, IMAPITable),
	MAKE_ENUM(Restrict, IMAPITable),
	MAKE_ENUM(CreateBookmark, IMAPITable),
	MAKE_ENUM(FreeBookmark, IMAPITable),
	MAKE_ENUM(SortTable, IMAPITable),
	MAKE_ENUM(QuerySortOrder, IMAPITable),
	MAKE_ENUM(QueryRows, IMAPITable),
	MAKE_ENUM(Abort, IMAPITable),
	MAKE_ENUM(ExpandRow, IMAPITable),
	MAKE_ENUM(CollapseRow, IMAPITable),
	MAKE_ENUM(WaitForCompletion, IMAPITable),
	MAKE_ENUM(GetCollapseState, IMAPITable),
	MAKE_ENUM(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_ENUM(GetContentsTable, IMAPIContainer),
	MAKE_ENUM(GetHierarchyTable, IMAPIContainer),
	MAKE_ENUM(OpenEntry, IMAPIContainer),
	MAKE_ENUM(SetSearchCriteria, IMAPIContainer),
	MAKE_ENUM(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_ENUM(CreateEntry, IABContainer),
	MAKE_ENUM(CopyEntries, IABContainer),
	MAKE_ENUM(DeleteEntries, IABContainer),
	MAKE_ENUM(ResolveNames, IABContainer),

/* IDistList */
	MAKE_ENUM(CreateEntry, IDistList),
	MAKE_ENUM(CopyEntries, IDistList),
	MAKE_ENUM(DeleteEntries, IDistList),
	MAKE_ENUM(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_ENUM(CreateMessage, IMAPIFolder),
	MAKE_ENUM(CopyMessages, IMAPIFolder),
	MAKE_ENUM(DeleteMessages, IMAPIFolder),
	MAKE_ENUM(CreateFolder, IMAPIFolder),
	MAKE_ENUM(CopyFolder, IMAPIFolder),
	MAKE_ENUM(DeleteFolder, IMAPIFolder),
	MAKE_ENUM(SetReadFlags, IMAPIFolder),
	MAKE_ENUM(GetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SaveContentsSort, IMAPIFolder),
	MAKE_ENUM(EmptyFolder, IMAPIFolder),

#ifdef OLD_STUFF
/* IMsgStore */
	MAKE_ENUM(Advise, IMsgStore),
	MAKE_ENUM(Unadvise, IMsgStore),
	MAKE_ENUM(CompareEntryIDs, IMsgStore),
	MAKE_ENUM(OpenEntry, IMsgStore),
	MAKE_ENUM(SetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolderTable, IMsgStore),
	MAKE_ENUM(StoreLogoff, IMsgStore),
	MAKE_ENUM(AbortSubmit, IMsgStore),
	MAKE_ENUM(GetOutgoingQueue, IMsgStore),
	MAKE_ENUM(SetLockState, IMsgStore),
	MAKE_ENUM(FinishedMsg, IMsgStore),
	MAKE_ENUM(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_ENUM(GetAttachmentTable, IMessage),
	MAKE_ENUM(OpenAttach, IMessage),
	MAKE_ENUM(CreateAttach, IMessage),
	MAKE_ENUM(DeleteAttach, IMessage),
	MAKE_ENUM(GetRecipientTable, IMessage),
	MAKE_ENUM(ModifyRecipients, IMessage),
	MAKE_ENUM(SubmitMessage, IMessage),
	MAKE_ENUM(SetReadFlag, IMessage),

/* IABProvider */
	MAKE_ENUM(Shutdown, IABProvider),
	MAKE_ENUM(Logon, IABProvider),

/* IABLogon */
	MAKE_ENUM(GetLastError, IABLogon),
	MAKE_ENUM(Logoff, IABLogon),
	MAKE_ENUM(OpenEntry, IABLogon),
	MAKE_ENUM(CompareEntryIDs, IABLogon),
	MAKE_ENUM(Advise, IABLogon),
	MAKE_ENUM(Unadvise, IABLogon),
	MAKE_ENUM(OpenStatusEntry, IABLogon),
	MAKE_ENUM(OpenTemplateID, IABLogon),
	MAKE_ENUM(GetOneOffTable, IABLogon),
	MAKE_ENUM(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_ENUM(Shutdown, IXPProvider),
	MAKE_ENUM(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_ENUM(AddressTypes, IXPLogon),
	MAKE_ENUM(RegisterOptions, IXPLogon),
	MAKE_ENUM(TransportNotify, IXPLogon),
	MAKE_ENUM(Idle, IXPLogon),
	MAKE_ENUM(TransportLogoff, IXPLogon),
	MAKE_ENUM(SubmitMessage, IXPLogon),
	MAKE_ENUM(EndMessage, IXPLogon),
	MAKE_ENUM(Poll, IXPLogon),
	MAKE_ENUM(StartMessage, IXPLogon),
	MAKE_ENUM(OpenStatusEntry, IXPLogon),
	MAKE_ENUM(ValidateState, IXPLogon),
	MAKE_ENUM(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_ENUM(Shutdown, IMSProvider),
	MAKE_ENUM(Logon, IMSProvider),
	MAKE_ENUM(SpoolerLogon, IMSProvider),
	MAKE_ENUM(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_ENUM(GetLastError, IMSLogon),
	MAKE_ENUM(Logoff, IMSLogon),
	MAKE_ENUM(OpenEntry, IMSLogon),
	MAKE_ENUM(CompareEntryIDs, IMSLogon),
	MAKE_ENUM(Advise, IMSLogon),
	MAKE_ENUM(Unadvise, IMSLogon),
	MAKE_ENUM(OpenStatusEntry, IMSLogon),
	
/* IMAPIControl */
	MAKE_ENUM(GetLastError, IMAPIControl),
	MAKE_ENUM(Activate, IMAPIControl),
	MAKE_ENUM(GetState, IMAPIControl),

/* IMAPIStatus */
	MAKE_ENUM(ValidateState, IMAPIStatus),
	MAKE_ENUM(SettingsDialog, IMAPIStatus),
	MAKE_ENUM(ChangePassword, IMAPIStatus),
	MAKE_ENUM(FlushQueues, IMAPIStatus),

#endif

/* IStream */
	MAKE_ENUM(Read, IStream),
	MAKE_ENUM(Write, IStream),
	MAKE_ENUM(Seek, IStream),
	MAKE_ENUM(SetSize, IStream),
	MAKE_ENUM(CopyTo, IStream),
	MAKE_ENUM(Commit, IStream),
	MAKE_ENUM(Revert, IStream),
	MAKE_ENUM(LockRegion, IStream),
	MAKE_ENUM(UnlockRegion, IStream),
	MAKE_ENUM(Stat, IStream),
	MAKE_ENUM(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_ENUM(OnNotify, IMAPIAdviseSink),

/* IWABObject */
	MAKE_ENUM(GetLastError, IWABObject),
	MAKE_ENUM(AllocateBuffer, IWABObject),
	MAKE_ENUM(AllocateMore, IWABObject),
	MAKE_ENUM(FreeBuffer, IWABObject),
	MAKE_ENUM(Backup, IWABObject),
	MAKE_ENUM(Import, IWABObject),

} METHODS;


/* Macro wrappers to hide the Validate function return handling */
#if defined(_X86_) || defined( WIN16 )
#ifdef __cplusplus

/* C++ methods can't take the address of the This pointer, so we must
   use the first parameter instead */

#define ValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, (LPVOID) &First);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, &First);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, First)				\
		AssertSz(HR_SUCCEEDED(__CPPValidateParameters(eMethod, &First)), "Parameter validation failed for method called by MAPI!")


#else /* __cplusplus */

/* For methods that will be called by clients
   - validate always */

#define ValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, ppThis)				\
		AssertSz(HR_SUCCEEDED(__ValidateParameters(eMethod, ppThis)), "Parameter validation failed for method called by MAPI!")

#endif /* __cplusplus */
#endif /* _X86_ || WIN16 */

/* Prototypes for functions used to validate complex parameters.
 */
#define FBadPropVal( lpPropVal)	(FAILED(ScCountProps( 1, lpPropVal, NULL)))

#define FBadRgPropVal( lpPropVal, cValues) \
		(FAILED(ScCountProps( cValues, lpPropVal, NULL)))

#define FBadAdrList( lpAdrList) \
		(   AssertSz(   (   offsetof( ADRLIST, cEntries) \
						 == offsetof( SRowSet, cRows)) \
					 && (   offsetof( ADRLIST, aEntries) \
						 == offsetof( SRowSet, aRow)) \
					 && (   offsetof( ADRENTRY, cValues) \
						 == offsetof( SRow, cValues)) \
					 && (   offsetof( ADRENTRY, rgPropVals) \
						 == offsetof( SRow, lpProps)) \
					,  TEXT("ADRLIST doesn't match SRowSet")) \
		 || FBadRowSet( (LPSRowSet) lpAdrList))

STDAPI_(BOOL)
FBadRglpszW( LPWSTR FAR	*lppszW,
			 ULONG		cStrings);

STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet);

STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames);

STDAPI_(BOOL)
FBadEntryList( LPENTRYLIST	lpEntryList);


/* BAD_STANDARD_OBJ
 *
 * This macro insures that the object is a writable object of the correct size
 * and that this method belongs to the object.
 *
 * NOTES ON USE!
 *	This depends upon using the standard method of declaring the object
 *	interface.
 *
 *	prefix is the method prefix you chose when declaring the object interface.
 *	method is the standard method name of the calling method.
 *	lpVtbl is the name of the lpVtbl element of your object.
 */
#define BAD_STANDARD_OBJ( lpObj, prefix, method, lpVtbl) \
	(   IsBadWritePtr( (lpObj), sizeof(*lpObj)) \
	 || IsBadReadPtr( (void *) &(lpObj->lpVtbl->method), sizeof(LPVOID)) \
	 ||( ( LPVOID) (lpObj->lpVtbl->method) != (LPVOID) (prefix##method)))


#define FBadUnknown( lpObj ) \
	(	IsBadReadPtr( (lpObj), sizeof(LPVOID) ) \
	 ||	IsBadReadPtr( (lpObj)->lpVtbl, 3 * sizeof(LPUNKNOWN) ) \
	 ||	IsBadCodePtr( (FARPROC)(lpObj)->lpVtbl->QueryInterface ))

/*
 * IUnknown
 */


/*
 * QueryInterface
 */
#define FBadQueryInterface( lpObj, riid, ppvObj)	\
	(   IsBadReadPtr( riid, sizeof(IID)) \
	 || IsBadWritePtr( ppvObj, sizeof(LPVOID)))


/*
 * AddRef
 *	No parameter validation required.
 */
#define FBadAddRef( lpObj)	FALSE


/*
 * Release
 *	No parameter validation required.
 */
#define FBadRelease( lpObj)	FALSE


/*
 * GetLastError
 */
#define FBadGetLastError( lpObj, hResult, ulFlags, lppMAPIError )\
	(IsBadWritePtr( lppMAPIError, sizeof(LPMAPIERROR)))

/*
 * IMAPIProp
 */


/*
 * SaveChanges
 *	No parameter validation required.
 */
#define FBadSaveChanges( lpObj, ulFlags)	FALSE


/*
 * GetProps
 */
#define FBadGetProps( lpObj, lpPTagA, lpcValues, lppPropArray) \
	(   (   lpPTagA \
		 && (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcValues, sizeof(ULONG)) \
	 || IsBadWritePtr( lppPropArray, sizeof(LPSPropValue)))


/*
 * GetPropList
 */
#define FBadGetPropList( lpObj, lppPTagA) \
	(IsBadWritePtr( lppPTagA, sizeof(LPSPropTagArray FAR *)))


/*
 * OpenProperty
 */
#define FBadOpenProperty( lpObj, ulPropTag, lpiid, ulInterfaceOptions, ulFlags \
						, lppUnk) \
	(   IsBadReadPtr( lpiid, sizeof(IID)) \
	 || IsBadWritePtr( lppUnk, sizeof (LPUNKNOWN FAR *)))


/*
 * SetProps
 */
#define FBadSetProps( lpObj, cValues, lpPropArray, lppProblems) \
	(   FBadRgPropVal( lpPropArray, (UINT) cValues) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * DeleteProps
 */
#define FBadDeleteProps( lpObj, lpPTagA, lppProblems) \
	(   (   !lpPTagA \
		 || (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyTo
 */
#define FBadCopyTo( lpIPDAT, ciidExclude, rgiidExclude, lpExcludeProps \
				  , ulUIParam, lpProgress, lpInterface, lpDestObj \
				  , ulFlags, lppProblems) \
	(	(	ciidExclude \
		 && (  IsBadReadPtr( rgiidExclude, (UINT)(ciidExclude * sizeof(IID))))) \
	 || (   lpExcludeProps \
		 && (   IsBadReadPtr( lpExcludeProps, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpExcludeProps \
			 				, (UINT)(  (lpExcludeProps->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyProps
 */
#define FBadCopyProps( lpIPDAT, lpPropTagArray \
					 , ulUIParam, lpProgress, lpInterface, lpDestObj \
					 , ulFlags, lppProblems) \
	(   (   lpPropTagArray \
		 && (   IsBadReadPtr( lpPropTagArray, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPropTagArray \
			 				, (UINT)(  (lpPropTagArray->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))



/*
 * GetNamesFromIDs
 */
#define FBadGetNamesFromIDs( lpIPDAT, lppPropTags, lpPropSetGuid, ulFlags, \
							 lpcPropNames, lpppPropNames) \
	(   IsBadReadPtr( lppPropTags, sizeof(LPSPropTagArray)) \
	 || ( lpPropSetGuid && IsBadReadPtr( lpPropSetGuid, sizeof(GUID))) \
	 || (   *lppPropTags \
		 && (   IsBadReadPtr( *lppPropTags, sizeof(ULONG)) \
		 	 || IsBadReadPtr( *lppPropTags \
			 				, (UINT)( ( ( *lppPropTags)->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcPropNames, sizeof (ULONG)) \
	 || IsBadWritePtr( lpppPropNames, sizeof (LPVOID FAR *)))



/*
 * GetNamesFromIDs
 */
#define FBadGetIDsFromNames( lpIPDAT, cPropNames, lppPropNames, ulFlags \
						   , lppPropTags) \
	(   (cPropNames && FBadRglpNameID( lppPropNames, cPropNames)) \
	 || IsBadWritePtr( lppPropTags, sizeof(LPULONG FAR *)))


STDAPI_(ULONG)
FBadRestriction( LPSRestriction lpres );

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag );

STDAPI_(ULONG)
FBadRow( LPSRow lprow );

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop );

STDAPI_(ULONG)
FBadSortOrderSet( LPSSortOrderSet lpsos );

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols );

/* Validation function

	The eMethod parameter tells us which internal validation to perform.
	
	The ppThis parameter tells us where the stack is, so we can access the other
	parameters.
	
	Becuase of this *magic* we MUST obtain the pointer to the This pointer in
	the method function.
	
*/

#ifdef WIN16
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_STACK
#endif


#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__CPPValidateParameters(METHODS eMethod, const LPVOID ppFirst);

#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__ValidateParameters(METHODS eMethod, LPVOID ppThis);

#ifdef _MAC
#define STDAPIVCALLTYPE         __cdecl
#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE
#endif /* _MAC */

/* Macro wrappers for platform independent validation */

#if defined(_X86_) || defined( WIN16 )
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParameters x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParameters x), "Parameter validation failed for method called by MAPI!")
#else
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParametersV x ), "Parameter validation failed for method called by MAPI!")
#endif

#if defined(_X86_) || defined( WIN16 )

#define ValidateParameters1( m, a1 )
#define ValidateParameters2( m, a1, a2 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters3( m, a1, a2, a3 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define UlValidateParameters1( m, a1 )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters3( m, a1, a2, a3 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( ( m, (LPVOID FAR *) &a2 ) )

#define CheckParameters1( m, a1 )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters3( m, a1, a2, a3)	\
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( ( m, (LPVOID FAR *) &a2 ) )

#else /* !_X86_  && !WIN16 */

#define ValidateParameters1( m, a1 ) \
			ValidateParms( ( m, a1 ) )
#define ValidateParameters2( m, a1, a2 )	\
			ValidateParms( ( m, a1, a2 ))
#define ValidateParameters3( m, a1, a2, a3 )	\
			ValidateParms( ( m, a1, a2, a3 ))
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, a1, a2, a3, a4 ))
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define UlValidateParameters1( m, a1 ) \
			UlValidateParms( ( m, a1 ) )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, a1, a2 ))
#define UlValidateParameters3( m, a1, a2, a3 )	\
			UlValidateParms( ( m, a1, a2, a3 ))
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, a1, a2, a3, a4 ))
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define CheckParameters1( m, a1 ) \
			CheckParms( ( m, a1 ) )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, a1, a2 ))
#define CheckParameters3( m, a1, a2, a3 )	\
			CheckParms( ( m, a1, a2, a3 ))
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, a1, a2, a3, a4 ))
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5 ))
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#endif /* _X86_ || WIN16 */


/*
 *  	M A P I    P A R A M E T E R   V A L I D A T I O N    M A C R O S
 */


/* IUnknown */

#define Validate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 ValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define UlValidate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 UlValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define CheckParameters_IUnknown_QueryInterface( a1, a2, a3 ) \
			 CheckParameters3( IUnknown_QueryInterface, a1, a2, a3 )

#define Validate_IUnknown_AddRef( a1 ) \
			 ValidateParameters1( IUnknown_AddRef, a1 )
#define UlValidate_IUnknown_AddRef( a1 ) \
			 UlValidateParameters1( IUnknown_AddRef, a1 )
#define CheckParameters_IUnknown_AddRef( a1 ) \
			 CheckParameters1( IUnknown_AddRef, a1 )

#define Validate_IUnknown_Release( a1 ) \
			 ValidateParameters1( IUnknown_Release, a1 )
#define UlValidate_IUnknown_Release( a1 ) \
			 UlValidateParameters1( IUnknown_Release, a1 )
#define CheckParameters_IUnknown_Release( a1 ) \
			 CheckParameters1( IUnknown_Release, a1 )


/* IMAPIProp */

#define Validate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIProp_SaveChanges( a1, a2 ) \
			 ValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define UlValidate_IMAPIProp_SaveChanges( a1, a2 ) \
			 UlValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define CheckParameters_IMAPIProp_SaveChanges( a1, a2 ) \
			 CheckParameters2( IMAPIProp_SaveChanges, a1, a2 )

#define Validate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )

#define Validate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define UlValidate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define CheckParameters_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_GetPropList, a1, a2, a3 )

#define Validate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )

#define Validate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define UlValidate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define CheckParameters_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )

#define Validate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 ValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define UlValidate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 UlValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 CheckParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )

#define Validate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )


/* IMAPITable */

#define Validate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_Advise, a1, a2, a3, a4 )

#define Validate_IMAPITable_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define UlValidate_IMAPITable_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define CheckParameters_IMAPITable_Unadvise( a1, a2 ) \
			 CheckParameters2( IMAPITable_Unadvise, a1, a2 )

#define Validate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define UlValidate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetStatus( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetStatus, a1, a2, a3 )

#define Validate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_SetColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SetColumns, a1, a2, a3 )

#define Validate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_QueryColumns, a1, a2, a3 )

#define Validate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define UlValidate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetRowCount, a1, a2, a3 )

#define Validate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define UlValidate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define CheckParameters_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )

#define Validate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )

#define Validate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_Restrict( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define UlValidate_IMAPITable_Restrict( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define CheckParameters_IMAPITable_Restrict( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_Restrict, a1, a2, a3 )

#define Validate_IMAPITable_CreateBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define UlValidate_IMAPITable_CreateBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define CheckParameters_IMAPITable_CreateBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_CreateBookmark, a1, a2 )

#define Validate_IMAPITable_FreeBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define UlValidate_IMAPITable_FreeBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define CheckParameters_IMAPITable_FreeBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_FreeBookmark, a1, a2 )

#define Validate_IMAPITable_SortTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define UlValidate_IMAPITable_SortTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define CheckParameters_IMAPITable_SortTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SortTable, a1, a2, a3 )

#define Validate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 ValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define UlValidate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define CheckParameters_IMAPITable_QuerySortOrder( a1, a2 ) \
			 CheckParameters2( IMAPITable_QuerySortOrder, a1, a2 )

#define Validate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )

#define Validate_IMAPITable_Abort( a1 ) \
			 ValidateParameters1( IMAPITable_Abort, a1 )
#define UlValidate_IMAPITable_Abort( a1 ) \
			 UlValidateParameters1( IMAPITable_Abort, a1 )
#define CheckParameters_IMAPITable_Abort( a1 ) \
			 CheckParameters1( IMAPITable_Abort, a1 )

#define Validate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )

#define Validate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )

#define Validate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )


/* IMAPIContainer */

#define Validate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )

#define Validate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )

#define Validate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define UlValidate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define CheckParameters_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )

#define Validate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )


/* IABContainer */

#define Validate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define UlValidate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IABContainer_DeleteEntries, a1, a2, a3 )

#define Validate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )


/* IDistList */

#define Validate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define UlValidate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IDistList_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IDistList_DeleteEntries, a1, a2, a3 )

#define Validate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )


/* IMAPIFolder */

#define Validate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )

#define Validate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )

#define Validate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define UlValidate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define CheckParameters_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 CheckParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )

#define Validate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )


/* IStream */

#define Validate_IStream_Read( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define UlValidate_IStream_Read( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define CheckParameters_IStream_Read( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Read, a1, a2, a3, a4 )

#define Validate_IStream_Write( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define UlValidate_IStream_Write( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define CheckParameters_IStream_Write( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Write, a1, a2, a3, a4 )

#define Validate_IStream_Seek( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define UlValidate_IStream_Seek( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define CheckParameters_IStream_Seek( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Seek, a1, a2, a3, a4 )

#define Validate_IStream_SetSize( a1, a2 ) \
			 ValidateParameters2( IStream_SetSize, a1, a2 )
#define UlValidate_IStream_SetSize( a1, a2 ) \
			 UlValidateParameters2( IStream_SetSize, a1, a2 )
#define CheckParameters_IStream_SetSize( a1, a2 ) \
			 CheckParameters2( IStream_SetSize, a1, a2 )

#define Validate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define UlValidate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define CheckParameters_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )

#define Validate_IStream_Commit( a1, a2 ) \
			 ValidateParameters2( IStream_Commit, a1, a2 )
#define UlValidate_IStream_Commit( a1, a2 ) \
			 UlValidateParameters2( IStream_Commit, a1, a2 )
#define CheckParameters_IStream_Commit( a1, a2 ) \
			 CheckParameters2( IStream_Commit, a1, a2 )

#define Validate_IStream_Revert( a1 ) \
			 ValidateParameters1( IStream_Revert, a1 )
#define UlValidate_IStream_Revert( a1 ) \
			 UlValidateParameters1( IStream_Revert, a1 )
#define CheckParameters_IStream_Revert( a1 ) \
			 CheckParameters1( IStream_Revert, a1 )

#define Validate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_LockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_LockRegion, a1, a2, a3, a4 )

#define Validate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )

#define Validate_IStream_Stat( a1, a2, a3 ) \
			 ValidateParameters3( IStream_Stat, a1, a2, a3 )
#define UlValidate_IStream_Stat( a1, a2, a3 ) \
			 UlValidateParameters3( IStream_Stat, a1, a2, a3 )
#define CheckParameters_IStream_Stat( a1, a2, a3 ) \
			 CheckParameters3( IStream_Stat, a1, a2, a3 )

#define Validate_IStream_Clone( a1, a2 ) \
			 ValidateParameters2( IStream_Clone, a1, a2 )
#define UlValidate_IStream_Clone( a1, a2 ) \
			 UlValidateParameters2( IStream_Clone, a1, a2 )
#define CheckParameters_IStream_Clone( a1, a2 ) \
			 CheckParameters2( IStream_Clone, a1, a2 )


/* IMAPIAdviseSink */

#define Validate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define UlValidate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define CheckParameters_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 CheckParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )


/* IWABObject */

#define Validate_IWABObject_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IWABObject_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IWABObject_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IWABOBject_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IWABObject_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IWABObject_GetLastError, a1, a2, a3, a4 )


#define Validate_IWABObject_AllocateBuffer( a1, a2, a3 ) \
			 ValidateParameters3( IWABObject_AllocateBuffer, a1, a2, a3 )
#define UlValidate_IWABObject_AllocateBuffer( a1, a2, a3) \
			 UlValidateParameters3( IWABOBject_AllocateBuffer, a1, a2, a3 )
#define CheckParameters_IWABObject_AllocateBuffer( a1, a2, a3 ) \
			 CheckParameters3( IWABObject_AllocateBuffer, a1, a2, a3 )


#define Validate_IWABObject_AllocateMore( a1, a2, a3, a4 ) \
			 ValidateParameters4( IWABObject_AllocateMore, a1, a2, a3, a4 )
#define UlValidate_IWABObject_AllocateMore( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IWABOBject_AllocateMore, a1, a2, a3, a4 )
#define CheckParameters_IWABObject_AllocateMore( a1, a2, a3, a4 ) \
			 CheckParameters4( IWABObject_AllocateMore, a1, a2, a3, a4 )


#define Validate_IWABObject_FreeBuffer( a1, a2 ) \
			 ValidateParameters2( IWABObject_FreeBuffer, a1, a2 )
#define UlValidate_IWABObject_FreeBuffer( a1, a2 ) \
			 UlValidateParameters2( IWABOBject_FreeBuffer, a1, a2 )
#define CheckParameters_IWABObject_FreeBuffer( a1, a2 ) \
			 CheckParameters2( IWABObject_FreeBuffer, a1, a2 )


#define Validate_IWABObject_Backup( a1, a2 ) \
			 ValidateParameters2( IWABObject_Backup, a1, a2 )
#define UlValidate_IWABObject_Backup( a1, a2 ) \
			 UlValidateParameters2( IWABOBject_Backup, a1, a2 )
#define CheckParameters_IWABObject_Backup( a1, a2 ) \
			 CheckParameters2( IWABObject_Backup, a1, a2 )


#define Validate_IWABObject_Import( a1, a2 ) \
			 ValidateParameters2( IWABObject_Import, a1, a2 )
#define UlValidate_IWABObject_Import( a1, a2 ) \
			 UlValidateParameters2( IWABOBject_Import, a1, a2 )
#define CheckParameters_IWABObject_Import( a1, a2 ) \
			 CheckParameters2( IWABObject_Import, a1, a2 )






#ifdef WIN16
HRESULT
PASCAL	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#elif defined(_X86_)
STDAPI	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#else
STDAPIV	HrValidateParametersV( METHODS eMethod, ... );
STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist );
#endif /* WIN16 */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_VALIDATE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_abroot.h ===
/***********************************************************************
 *
 *  _ABROOT.H
 *
 *  Header file for code in ABROOT.C
 *
 *  Copyright 1992, 1993 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer for ROOT object.  (i.e. IAB::OpenEntry() with an
 *  lpEntryID of NULL).
 */

#undef	INTERFACE
#define INTERFACE	struct _ROOT

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ROOT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, ROOT_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ROOT_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _ROOT {
    MAILUSER_BASE_MEMBERS(ROOT)
    ULONG ulType;
} ROOT, *LPROOT;

#define CBROOT	sizeof(ROOT)

//
//  Entry point to create the AB Hierarchy object
//

HRESULT NewROOT(LPVOID lpObj,
  ULONG ulIntFlag,
  LPCIID lpInterface,
  ULONG ulOpenFlags,
  ULONG *lpulObjType,
  LPVOID *lppROOT);


//  Internal flags for NewROOT
#define AB_ROOT ((ULONG)0x00000000)
#define AB_WELL ((ULONG)0x00000001)

// Internal flag that tells the root contents table that even if this is a 
// profile session, ignore all the user containers except the "All Contacts" 
// item and only add the "All contact" item
// This simulates the old-type behaviour where you get a single local container
// Internal-only flag
//
#define WAB_NO_PROFILE_CONTAINERS   0x00400000

// registry settings
extern const LPTSTR szWABKey;

/*
 *  Creates a new Hierarchy table off the Root object
 */
HRESULT MergeHierarchy(LPROOT lpROOT,
  LPIAB lpIAB,
  ULONG ulFlags);

//BOOL ResolveLDAPServers(void);

/*
 *	 call back function used to rebuild hierarchy and one off tables
 */
NOTIFCALLBACK lTableNotifyCallBack;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\wrap.c ===
/*
 *	WRAP.C
 *	
 *	Wrapped IProp
 */

#include "_apipch.h"

/*********************************************************************
 *
 *  The actual Wrapped IMAPIProp methods
 *
 */





//
//  Wrapped IMAPIProp jump table is defined here...
//  Try to use as much of IAB as possible.
//


WRAP_Vtbl vtblWRAP_OOP = {
	VTABLE_FILL
	(WRAP_QueryInterface_METHOD *)	IAB_QueryInterface,
	WRAP_AddRef,
	WRAP_Release,
	(WRAP_GetLastError_METHOD *)	IAB_GetLastError,
	WRAP_SaveChanges,
	WRAP_GetProps,
	WRAP_GetPropList,
	WRAP_OpenProperty,
	WRAP_SetProps,
	WRAP_DeleteProps,
	WRAP_CopyTo,
	WRAP_CopyProps,
	WRAP_GetNamesFromIDs,
	WRAP_GetIDsFromNames,
};




/**************************************************
 *
 *  WRAP_AddRef
 *		Increment lcInit
 *
 */
STDMETHODIMP_(ULONG) WRAP_AddRef(LPWRAP lpWRAP)
{

#ifdef PARAMETER_VALIDATION
    // Check to see if it has a jump table
    if (IsBadReadPtr(lpWRAP, sizeof(LPVOID))) {
        //No jump table found
        return(1);
    }

    // Check to see if the jump table has at least sizeof IUnknown
    if (IsBadReadPtr(lpWRAP->lpVtbl, 3 * sizeof(LPVOID))) {
        // Jump table not derived from IUnknown
        return(1);
    }

    // Check to see if the method is the same
    if (WRAP_AddRef != lpWRAP->lpVtbl->AddRef) {
        // Wrong object - the object passed doesn't have this
        // method.
        return(1);
    }

#endif // PARAMETER_VALIDATION

    EnterCriticalSection(&lpWRAP->cs);

    ++lpWRAP->lcInit;

    LeaveCriticalSection(&lpWRAP->cs);

    return(lpWRAP->lcInit);
}


STDMETHODIMP_(ULONG)
WRAP_Release (LPWRAP	lpWRAP)
{

#if	!defined(NO_VALIDATION)
    // Make sure the object is valid.
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, Release, lpVtbl)) {
        return(1);
    }
#endif


    EnterCriticalSection(&lpWRAP->cs);

    --lpWRAP->lcInit;

    if (lpWRAP->lcInit == 0) {

        UlRelease(lpWRAP->lpPropData);

        //
        //  Need to free the object
        //
        LeaveCriticalSection(&lpWRAP->cs);
        DeleteCriticalSection(&lpWRAP->cs);
        FreeBufferAndNull(&lpWRAP);
        return(0);
    }

    LeaveCriticalSection(&lpWRAP->cs);
    return(lpWRAP->lcInit);
}


// IProperty

STDMETHODIMP
WRAP_SaveChanges (LPWRAP	lpWRAP,
				  ULONG		ulFlags)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, SaveChanges, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->SaveChanges(
					lpWRAP->lpPropData,
					ulFlags);
}


STDMETHODIMP
WRAP_GetProps (LPWRAP			lpWRAP,
			   LPSPropTagArray	lpPropTagArray,
			   ULONG			ulFlags,
			   ULONG *			lpcValues,
			   LPSPropValue *	lppPropArray)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetProps(
		lpWRAP->lpPropData,
		lpPropTagArray,
		ulFlags,
		lpcValues,
		lppPropArray);
}


STDMETHODIMP
WRAP_GetPropList (LPWRAP			lpWRAP,
				  ULONG				ulFlags,
				  LPSPropTagArray *	lppPropTagArray)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetPropList, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetPropList(
		lpWRAP->lpPropData,
		ulFlags,
		lppPropTagArray);
}



STDMETHODIMP
WRAP_OpenProperty (LPWRAP		lpWRAP,
				   ULONG		ulPropTag,
				   LPCIID		lpiid,
				   ULONG		ulInterfaceOptions,
				   ULONG		ulFlags,
				   LPUNKNOWN *	lppUnk)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, OpenProperty, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->OpenProperty(
				lpWRAP->lpPropData,
				ulPropTag,
				lpiid,
				ulInterfaceOptions,
				ulFlags,
				lppUnk);
}


STDMETHODIMP
WRAP_SetProps (LPWRAP					lpWRAP,
			   ULONG					cValues,
			   LPSPropValue				lpPropArray,
			   LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, SetProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->SetProps(
		lpWRAP->lpPropData,
		cValues,
		lpPropArray,
		lppProblems);
}


STDMETHODIMP
WRAP_DeleteProps (LPWRAP				lpWRAP,
				  LPSPropTagArray		lpPropTagArray,
				  LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, DeleteProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->DeleteProps(
		lpWRAP->lpPropData,
		lpPropTagArray,
		lppProblems);
}

STDMETHODIMP
WRAP_CopyTo (	LPWRAP					lpWRAP,
				ULONG					ciidExclude,
				LPCIID					rgiidExclude,
				LPSPropTagArray			lpExcludeProps,
				ULONG_PTR    			ulUIParam,
				LPMAPIPROGRESS			lpProgress,
				LPCIID					lpInterface,
				LPVOID					lpDestObj,
				ULONG					ulFlags,
				LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, CopyTo, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	// Make sure we're not copying to ourselves
	
	if ((LPVOID)lpWRAP == (LPVOID)lpDestObj)
	{
		DebugTrace( TEXT("OOP WRAP_CopyTo(): Copying to self is not supported\n"));
		return ResultFromScode(MAPI_E_NO_ACCESS);
	}
	

	return lpWRAP->lpPropData->lpVtbl->CopyTo(
		lpWRAP->lpPropData,
		ciidExclude,
		rgiidExclude,
		lpExcludeProps,
		ulUIParam,
		lpProgress,
		lpInterface,
		lpDestObj,
		ulFlags,
		lppProblems);
}

STDMETHODIMP
WRAP_CopyProps (	LPWRAP					lpWRAP,
					LPSPropTagArray			lpIncludeProps,
					ULONG_PTR				ulUIParam,
					LPMAPIPROGRESS			lpProgress,
					LPCIID					lpInterface,
					LPVOID					lpDestObj,
					ULONG					ulFlags,
					LPSPropProblemArray *	lppProblems)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, CopyProps, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->CopyProps(
		lpWRAP->lpPropData,
		lpIncludeProps,
		ulUIParam,
		lpProgress,
		lpInterface,
		lpDestObj,
		ulFlags,
		lppProblems);
}


STDMETHODIMP
WRAP_GetNamesFromIDs (	LPWRAP				lpWRAP,
						LPSPropTagArray *	lppPropTags,
						LPGUID				lpPropSetGuid,
						ULONG				ulFlags,
						ULONG *				lpcPropNames,
						LPMAPINAMEID **		lpppPropNames)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetNamesFromIDs, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetNamesFromIDs(
		lpWRAP->lpPropData,
		lppPropTags,
		lpPropSetGuid,
		ulFlags,
		lpcPropNames,
		lpppPropNames);
}

STDMETHODIMP
WRAP_GetIDsFromNames (	LPWRAP				lpWRAP,
						ULONG				cPropNames,
						LPMAPINAMEID *		lppPropNames,
						ULONG				ulFlags,
						LPSPropTagArray *	lppPropTags)
{

#if	!defined(NO_VALIDATION)
	/* Make sure the object is valid.
	 */
    if (BAD_STANDARD_OBJ(lpWRAP, WRAP_, GetIDsFromNames, lpVtbl))
	{
		return ResultFromScode(MAPI_E_INVALID_PARAMETER);
	}
#endif

	return lpWRAP->lpPropData->lpVtbl->GetIDsFromNames(
		lpWRAP->lpPropData,
		cPropNames,
		lppPropNames,
		ulFlags,
		lppPropTags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_abcont.h ===
/***********************************************************************
 *
 *  _ABCONT.H
 *
 *  Header file for code in ABCONT.C: Container Object
 *
 *  Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

/*
 *  ABContainer object.
 */

#undef	INTERFACE
#define INTERFACE	struct _CONTAINER

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, CONTAINER_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, CONTAINER_)
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(CONTAINER_) {
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(IMPL)
    MAPI_IMAPIPROP_METHODS(IMPL)
    MAPI_IMAPICONTAINER_METHODS(IMPL)
    MAPI_IABCONTAINER_METHODS(IMPL)
};

typedef struct _CONTAINER {
    MAILUSER_BASE_MEMBERS(CONTAINER)
    ULONG ulType;
    BOOL fLoadedLDAP;
} CONTAINER, *LPCONTAINER;

#define CBCONTAINER sizeof(CONTAINER)

HRESULT HrSetCONTAINERAccess(LPCONTAINER lpCONTAINER,
  ULONG ulFlags);

//
// Create a new AB Container object
//
HRESULT HrNewCONTAINER(LPIAB lpIAB,
  ULONG ulType,
  LPCIID lpInterface,
  ULONG  ulOpenFlags,
  ULONG cbEID,
  LPENTRYID lpEID,
  ULONG  *lpulObjType,
  LPVOID *lppContainer);

//  Internal flags for HrNewCONTAINER - these flags determine the type of
//  container being created
typedef enum _ContainerType {
    AB_ROOT = 0,        // Root Container
    AB_WELL,
    AB_DL,              // Distribution list container
    AB_CONTAINER,       // Normal container
    AB_PAB,             // "PAB" or default container
    AB_LDAP_CONTAINER   // Special LDAP container
} CONTAINER_TYPE, *LPCONTAINER_TYPE;



// Inside the WAB when we call GetContentsTable followed by SetColumns, we basically end up 
// reading everything from the WAB twice which is a time consuming process 
// To improve performance we can try avoiding one unnecessary call but we need to do
// this carefully .. 
// The following flag is specified to GetContentsTable ONLY WHEN that call will
// be imediately followed by SetColumns .. do not expose this flag to anyone else..
// this is a WAB-internal flag only
//
#define WAB_CONTENTTABLE_NODATA 0x00400000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_apipch.h ===
/*
 *      _APIPCH.H
 *
 *      Precompile these headers.
 *      
 *      When adding new .h and .c files into the WAB, add the .h
 *      file here and include this file in the .C file
 *
 */

#define UNICODE
// This flag ensures that all we only pull in functions that return
// ASCII and not UTF-8.
//#define LDAP_UNICODE 0

// This commctrl flag enables us to be compiled with the new commctrl headers
// yet work with the old commctrls ... the base requirement for the WAB is the
// IE 3.0x common control. WAB doesn't use any of the newer commctrl features
// and so does not have an IE4 dependency
//
#ifndef _WIN64
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0400
#endif
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))

// Turns on the Parameter checking for most of the WAB API
#define PARAMETER_VALIDATION 1

#ifdef WIN16
#define WINAPI_16 WINAPI
#endif

#define _COMDLG32_ // We delayload common dialogs

#include <windows.h>
#include <windowsx.h>
#include <shlwapi.h>
#include <shellapi.h>
#ifdef WIN16
#include <winregp.h>
#include <ver.h>
#include <dlgs.h>
#include <commdlg.h>
#include <comctlie.h>
#include <athena16.h>
#include <mapi.h>
#include <wab16.h>
#include <prsht.h>
#else
#include <zmouse.h>
#endif // WIN16
#include <wab.h>
#include <wabdbg.h>
#include <wabguid.h>
#ifndef WIN16
#include <mapi.h>
#endif
#include <shlobj.h>
#include <wininet.h>
#include <docobj.h>
#include <mshtml.h>
#include <urlmon.h>
#include <msident.h>
#include <_layguid.h>
#include <_entryid.h>
#include <_imem.h>
#include <_imemx.h>
#include <glheap.h>
#include <_glheap.h>
#include <_mapiprv.h>
#include <limits.h>
#include <unkobj.h>
#include <wabval.h>
#include <_iprop.h>
#include <_memcpy.h>
//#include <_huntype.h>
#include <_mapiu.h>
#include <_runt.h>
#include <_itable.h>
#include <structs.h>
#include <_wabapi.h>
#include <_wabobj.h>
#include <iadrbook.h>
#include <_wrap.h>
#include "_notify.h"
#include <_iab.h>
#include <_errctx.h>
#include <_mailusr.h>
#include <_abcont.h>
#include <winldap.h>
#include <wabspi.h>
#include <imnact.h>
#include <_ldapcnt.h>
#include <_distlst.h>
#include <_abroot.h>
#include <mutil.h>
#include <mapiperf.h>
#include <_contabl.h>
#include <ui_clbar.h>
#ifndef WIN16
#include <commctrl.h>
#endif
#include "..\wab32res\resource.h"
#include "..\wab32res\resrc1.h"
#include <wincrypt.h>
#include <certs.h>
#include <_idrgdrp.h>
#include <_dochost.h>
#include <uimisc.h>
#include <ui_detls.h>
#include <ui_addr.h>
#include <ui_reslv.h>
#include "fonts.h"
#include <_vcard.h>
#include <globals.h>
#include "wabprint.h"
#include "_profile.h"
#include "_wabtags.h"
#include "..\wabhelp\adcs_ids.h"
#include <cryptdlg.h>

#ifndef WIN16
#include <capi.h>
#endif
#include "dial.h"
#include "_printex.h"
#include <pstore.h>
#include "demand.h"     // must be last!

#define TABLES TRUE

#include <ansiwrap.h>
#include "w9xwraps.h"

#ifdef WIN16
#ifndef GetLastError
#define GetLastError()     (-1)
#endif // !GetLastError
#endif // !WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_distlst.h ===
/*
-
-   Distribution List interface
-
*/
#ifndef _DISTLIST_H_
#define _DISTLIST_H_


#ifdef OLD_STUFF
#undef	INTERFACE
#define INTERFACE	struct _DistList

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, DistList_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, DistList_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(DistList_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _DistList {
    MAILUSER_BASE_MEMBERS(DistList)
} DistList, FAR * LPDistList;	
#endif

extern CONTAINER_Vtbl vtblDISTLIST;



#undef	INTERFACE
#define INTERFACE	struct _DLENTRY

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, DLENTRY_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, DLENTRY_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIPROP_METHODS(IMPL)

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(DLENTRY_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIPROP_METHODS(IMPL)
};

typedef struct _DLENTRY {
    MAILUSER_BASE_MEMBERS(DLENTRY)
    LPCONTAINER         lpCONTAINER;    // DistList containing this DLENTRY
} DLENTRY, FAR * LPDLENTRY;	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_contabl.h ===
/***********************************************************************
 *
 *  _CONTABL.H
 *
 *  Header file for code in CONTABLE.C
 *
 *  Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 ***********************************************************************/

//
//  Entry point to create the AB Hierarchy object
//

// Creates a new content table
//
HRESULT NewContentsTable(LPABCONT lpABContainer,
  LPIAB lpIAB,
  ULONG ulFlags,
  LPCIID  lpInterface,
  LPVOID *lppROOT);

CALLERRELEASE ContentsViewGone;

HRESULT GetEntryProps(
  LPABCONT lpContainer,
  ULONG cbEntryID,
  LPENTRYID lpEntryID,
  LPSPropTagArray lpSPropTagArray,
  LPVOID lpAllocMoreHere,
  ULONG ulFlags,
  LPULONG lpulcProps,
  LPSPropValue * lppSPropValue);

// Reads in data from the WAB store and fills in the ContentsTable
//
HRESULT FillTableDataFromPropertyStore(LPIAB lpIAB,
  LPSPropTagArray lppta,
  LPTABLEDATA lpTableData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_dochost.h ===
/****
*
*
*
* DocHost2 - second attempt at the WAB Doc Host interface
*
*
*    Purpose:
*        basic implementation of a docobject host. Used by the body class to
*        host Trident and/or MSHTML - when we do LDAP searches, LDAP providers
-       are allowed to return URLs in the LDAPURI attribute. WAB then addds
-       a "general" property tab that hosts trident and shows the contents
-       of the URL within the WAB. This allows the providers to add ADs and
-       branding to their data to diffrentiate themselves from each other.
-       Oh, the things we do for business relationships ... 
*
*  History
*      August '96: brettm - created
*      Ported to WAB - vikramm 4/97
*    
*    Copyright (C) Microsoft Corp. 1995, 1996, 1997.
****/

#ifndef _DOCHOST_H
#define _DOCHOST_H

#define RECYCLE_TRIDENT
//#define ASYNC_LOADING

// DocHost border sytles
enum
{
    dhbNone     =0x0,   // no border
    dhbHost     =0x01,  // dochost paints border
    dhbObject   =0x02   // docobj paints border
};



/* IWABDocHost Interface ---------------------------------------------------- */

struct _IWABDOCHOST;
typedef struct _IWABDOCHOST *LPIWABDOCHOST;



/* IWDH_OLEWINDOW ------------------------------------------------------ */
#define CBIWDH_OLEWINDOW sizeof(IWDH_OLEWINDOW)

/* This contains these interfaces ...

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

*/

#define IWDH_OLEWINDOW_METHODS(IPURE)	                    \
    MAPIMETHOD(GetWindow)                                       \
        (THIS_  HWND *                  phWnd)          IPURE;  \
    MAPIMETHOD(ContextSensitiveHelp)                            \
        (THIS_  BOOL                    fEnterMode)     IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleWindow
DECLARE_MAPI_INTERFACE_(IWDH_OleWindow, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWDH_OLEWINDOW_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEWINDOW

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEWINDOW_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEWINDOW_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEWINDOW_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEWINDOW_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEWINDOW_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEWINDOW_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEWINDOW_METHODS(IMPL)
};


typedef struct _IWDH_OLEWINDOW
{
    MAPIX_BASE_MEMBERS(IWDH_OLEWINDOW)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEWINDOW, * LPIWABDOCHOST_OLEWINDOW;

/* ----------------------------------------------------------------------------------------------*/




/* IWDH_OLEINPLACEFRAME ------------------------------------------------------ */
#define CBIWDH_OLEINPLACEFRAME sizeof(IWDH_OLEINPLACEFRAME)

/* This contains these interfaces ...

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 
    
    // *** IOleInPlaceFrame methods ***
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);

*/

#undef TranslateAccelerator

#define IWDH_OLEINPLACEFRAME_METHODS(IPURE)	                    \
    MAPIMETHOD(GetBorder)                                       \
        (THIS_  LPRECT                  lprc)           IPURE;  \
    MAPIMETHOD(RequestBorderSpace)                              \
        (THIS_  LPCBORDERWIDTHS         pborderwidths)  IPURE;  \
    MAPIMETHOD(SetBorderSpace)                                  \
        (THIS_  LPCBORDERWIDTHS         pborderwidths)  IPURE;  \
    MAPIMETHOD(SetActiveObject)                                 \
        (THIS_  IOleInPlaceActiveObject * pActiveObject,        \
                LPCOLESTR               lpszObjName)    IPURE;  \
    MAPIMETHOD(InsertMenus)                                     \
        (THIS_  HMENU                   hMenu,                  \
                LPOLEMENUGROUPWIDTHS    lpMenuWidths)   IPURE;  \
    MAPIMETHOD(SetMenu)                                         \
        (THIS_  HMENU                   hMenu,                  \
                HOLEMENU                hOleMenu,               \
                HWND                    hWnd)           IPURE;  \
    MAPIMETHOD(RemoveMenus)                                     \
        (THIS_  HMENU                   hMenu)          IPURE;  \
    MAPIMETHOD(SetStatusText)                                   \
        (THIS_  LPCOLESTR               pszStatusText)  IPURE;  \
    MAPIMETHOD(EnableModeless)                                  \
        (THIS_  BOOL                    fEnable)        IPURE;  \
    MAPIMETHOD(TranslateAccelerator)                            \
        (THIS_  MSG *                   lpmsg,                  \
                WORD                    wID)            IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleInPlaceFrame
DECLARE_MAPI_INTERFACE_(IWDH_OleInPlaceFrame, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
    	IWDH_OLEWINDOW_METHODS(PURE)
        IWDH_OLEINPLACEFRAME_METHODS(PURE)
};

#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEINPLACEFRAME

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEINPLACEFRAME_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEINPLACEFRAME_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACEFRAME_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEINPLACEFRAME_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACEFRAME_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEINPLACEFRAME_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEWINDOW_METHODS(IMPL)
	IWDH_OLEINPLACEFRAME_METHODS(IMPL)
};


typedef struct _IWDH_OLEINPLACEFRAME
{
    MAPIX_BASE_MEMBERS(IWDH_OLEINPLACEFRAME)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEINPLACEFRAME, * LPIWABDOCHOST_OLEINPLACEFRAME;

/* ----------------------------------------------------------------------------------------------*/



/* IWDH_OLEINPLACESITE ------------------------------------------------------ */
#define CBIWDH_OLEINPLACESITE sizeof(IWDH_OLEINPLACESITE)

/* This contains these interfaces ...

    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

*/

#define IWDH_OLEINPLACESITE_METHODS(IPURE)	                    \
    MAPIMETHOD(CanInPlaceActivate)                              \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnInPlaceActivate)                               \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnUIActivate)                                    \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(GetWindowContext)                                \
        (THIS_  LPOLEINPLACEFRAME *     ppFrame,                \
                LPOLEINPLACEUIWINDOW *  ppDoc,                  \
                LPRECT                  lprcPosRect,            \
                LPRECT                  lprcClipRect,           \
                LPOLEINPLACEFRAMEINFO   lpFrameInfo)    IPURE;  \
    MAPIMETHOD(Scroll)                                          \
        (THIS_  SIZE                    scrollExtent)   IPURE;  \
    MAPIMETHOD(OnUIDeactivate)                                  \
        (THIS_  BOOL                    fUndoable)      IPURE;  \
    MAPIMETHOD(OnInPlaceDeactivate)                             \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(DiscardUndoState)                                \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(DeactivateAndUndo)                               \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnPosRectChange)                                 \
        (THIS_  LPCRECT                 lprcPosRect)    IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleInPlaceSite
DECLARE_MAPI_INTERFACE_(IWDH_OleInPlaceSite, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
    	IWDH_OLEWINDOW_METHODS(PURE)
        IWDH_OLEINPLACESITE_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEINPLACESITE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEINPLACESITE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEINPLACESITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACESITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEINPLACESITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
    	IWDH_OLEWINDOW_METHODS(IMPL)
        IWDH_OLEINPLACESITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEINPLACESITE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEWINDOW_METHODS(IMPL)
	IWDH_OLEINPLACESITE_METHODS(IMPL)
};


typedef struct _IWDH_OLEINPLACESITE
{
    MAPIX_BASE_MEMBERS(IWDH_OLEINPLACESITE)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEINPLACESITE, * LPIWABDOCHOST_OLEINPLACESITE;

/* ----------------------------------------------------------------------------------------------*/



/* IWDH_OLECLIENTSITE ------------------------------------------------------ */
#define CBIWDH_OLECLIENTSITE sizeof(IWDH_OLECLIENTSITE)

/* This contains these interfaces ...

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

*/

#define IWDH_OLECLIENTSITE_METHODS(IPURE)	                    \
    MAPIMETHOD(SaveObject)                                      \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(GetMoniker)                                      \
        (THIS_  DWORD                   dwAssign,               \
                DWORD                   dwWhichMoniker,         \
                LPMONIKER *             ppmnk)          IPURE;  \
    MAPIMETHOD(GetContainer)                                    \
        (THIS_  LPOLECONTAINER *        ppCont)         IPURE;  \
    MAPIMETHOD(ShowObject)                                      \
        (THIS)                                          IPURE;  \
    MAPIMETHOD(OnShowWindow)                                    \
        (THIS_  BOOL                    fShow)          IPURE;  \
    MAPIMETHOD(RequestNewObjectLayout)                          \
        (THIS)                                          IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleClientSite
DECLARE_MAPI_INTERFACE_(IWDH_OleClientSite, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWDH_OLECLIENTSITE_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLECLIENTSITE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLECLIENTSITE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLECLIENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLECLIENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLECLIENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLECLIENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLECLIENTSITE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLECLIENTSITE_METHODS(IMPL)
};


typedef struct _IWDH_OLECLIENTSITE
{
    MAPIX_BASE_MEMBERS(IWDH_OLECLIENTSITE)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLECLIENTSITE, * LPIWABDOCHOST_OLECLIENTSITE;

/* ----------------------------------------------------------------------------------------------*/








/* IWDH_OLEDOCUMENTSITE ------------------------------------------------------ */
#define CBIWDH_OLEDOCUMENTSITE sizeof(IWDH_OLEDOCUMENTSITE)

/* This contains these interfaces ...

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

*/

#define IWDH_OLEDOCUMENTSITE_METHODS(IPURE)	                    \
    MAPIMETHOD(ActivateMe)                                      \
        (THIS_  LPOLEDOCUMENTVIEW       pViewToActivate)IPURE;  \


#undef           INTERFACE
#define          INTERFACE      IWDH_OleDocumentSite
DECLARE_MAPI_INTERFACE_(IWDH_OleDocumentSite, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        IWDH_OLEDOCUMENTSITE_METHODS(PURE)
};


#undef  INTERFACE
#define INTERFACE       struct _IWDH_OLEDOCUMENTSITE

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWDH_OLEDOCUMENTSITE_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWDH_OLEDOCUMENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEDOCUMENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWDH_OLEDOCUMENTSITE_)
        MAPI_IUNKNOWN_METHODS(IMPL)
        IWDH_OLEDOCUMENTSITE_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWDH_OLEDOCUMENTSITE_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	IWDH_OLEDOCUMENTSITE_METHODS(IMPL)
};


typedef struct _IWDH_OLEDOCUMENTSITE
{
    MAPIX_BASE_MEMBERS(IWDH_OLEDOCUMENTSITE)

    LPIWABDOCHOST lpIWDH;

} IWABDOCHOST_OLEDOCUMENTSITE, * LPIWABDOCHOST_OLEDOCUMENTSITE;

/* ----------------------------------------------------------------------------------------------*/








/*********************************************/


#undef           INTERFACE
#define          INTERFACE      IWABDocHost
DECLARE_MAPI_INTERFACE_(IWABDocHost, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
};

#undef	INTERFACE
#define INTERFACE	struct _IWABDOCHOST


#undef  METHOD_PREFIX
#define METHOD_PREFIX       IWABDOCHOST_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM         lpvtbl

#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, IWABDOCHOST_)
		MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define	MAPIMETHOD_(type, method)	MAPIMETHOD_TYPEDEF(type, method, IWABDOCHOST_)
		MAPI_IUNKNOWN_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABDOCHOST_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
};



typedef struct _IWABDOCHOST
{
    MAPIX_BASE_MEMBERS(IWABDOCHOST)

    // Pointer to self ...
    LPIWABDOCHOST lpIWDH;

    LPIWABDOCHOST_OLEWINDOW lpIWDH_OleWindow;

    LPIWABDOCHOST_OLEINPLACEFRAME lpIWDH_OleInPlaceFrame;
    
    LPIWABDOCHOST_OLEINPLACESITE lpIWDH_OleInPlaceSite;

    LPIWABDOCHOST_OLECLIENTSITE lpIWDH_OleClientSite;

    LPIWABDOCHOST_OLEDOCUMENTSITE lpIWDH_OleDocumentSite;


    //protected
    HWND                        m_hwnd;
    HWND                        m_hwndDocObj;
    LPOLEOBJECT                 m_lpOleObj;
    LPOLEDOCUMENTVIEW           m_pDocView;
    BOOL                        m_fInPlaceActive;
    BOOL                        m_fUIActive;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
    //LPOLEINPLACEACTIVEOBJECT    m_pIPObj;
    LPOLEINPLACEOBJECT          m_pIPObj;

       
} IWABDOCHOST, * LPIWABDOCHOST;




// Exposed functions 

// Create a new WAB DocHost object
HRESULT HrNewWABDocHostObject(LPVOID * lppIWABDOCHOST);
void ReleaseDocHostObject(LPIWABDOCHOST lpIWABDocHost);
void UninitTrident();
// Loads the URL from the URL string
HRESULT HrLoadURL(LPIWABDOCHOST lpIWABDocHost, LPTSTR lpszURL);
// Initialization
HRESULT HrInit(LPIWABDOCHOST lpIWABDocHost, HWND hwndParent, int idDlgItem, DWORD dhbBorder);


/////////////////


typedef HRESULT (STDMETHODCALLTYPE CREATEURLMONIKER)
(
    LPMONIKER pMkCtx, 
    LPCWSTR szURL, 
    LPMONIKER FAR * ppmk             
);

typedef CREATEURLMONIKER FAR * LPCREATEURLMONIKER;


// statics
//static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

// Not ported over ...
//
// BOOL WMNotify(int idFrom, NMHDR *pnmh) PURE;
// BOOL WMCommand(HWND, int, WORD) PURE;
// void OnDownloadComplete();
// HWND Hwnd();


//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//
typedef HRESULT (STDMETHODCALLTYPE DLLGETVERSIONPROCOE)(DLLVERSIONINFO *);
typedef DLLGETVERSIONPROCOE FAR * LPDLLGETVERSIONPROCOE;

 
#endif //_DOCHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\wabapi\_huntype.h ===
/*
 * HUNTYPE.H - Hungarian typedefs internal header file
 *
 * Contains various common hungarian typedefs used throughout the MAPI
 * project.  If you need to include this file in your subsystem, #define
 * ___huntype_h_, then #include <mapi>
 */


//	Byte counts

typedef USHORT		 CB;		//	16-bit count of bytes
typedef ULONG		 LCB;		//	32-bit count of bytes
typedef CB			*PCB;
typedef LCB			*PLCB;

//	Character counts

typedef USHORT		CCH;
								//	Note: PCCH defined elsewise by WINNT.H


//	Index into byte array

typedef USHORT		 IB;
typedef ULONG		 LIB;
typedef IB			*PIB;
typedef LIB			*PLIB;


//	Pointers to other things...

typedef LPVOID		 PV;		//	pointer to void
typedef LPVOID *	 PPV;		//	pointer to pointer to void
typedef LPBYTE		 PB;		//