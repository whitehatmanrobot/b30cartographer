          NULL,
                                        NULL,
                                        (LPTSTR)lpVal->md.pbMDData,
                                        MetaType2RegType(lpVal->md.dwMDDataType),
                                        lpVal->val_attrib,
                                        APPLICATION_DATA_METABASE);
            if (FAILED(hResult))
            {
                DPF(APPerr,L"IIS:AddRegValueRename:Failed with HR = %d (%#x)", hResult, hResult);
                break;
            }

            lpVal = lpVal->pvl_next;
        }
        RemoveValueList (lpValList);
    }
    if (SUCCEEDED(hResult))
    {
        hResult = S_OK;
    }
    return hResult;
}

//-----------------------------------------------------------------------//
//
// RecursiveEnumKey()
//
// DESCRIPTION:
// Recursive enumerate metabase key
//
// pcAdmCom:      Point to IMSAdminBase
// lpFullKey:     Full key path
// lpRegStr:      Input parameter structure
//-----------------------------------------------------------------------//
HRESULT RecursiveEnumKey (
    IMSAdminBase        *pcAdmCom,
    LPTSTR              lpFullKey,
    PREG_STRING_REPLACE lpRegStr,
    BOOL                bStrChk)
{
    HRESULT  hresError;
    DWORD    dwDataIndex, dwKeyIndex;
    DWORD    dwRequiredSize;
    BOOL     bAllocBuf;
    METADATA_RECORD md_Rec;
    METADATA_HANDLE hmdHandle;
    PVALLIST lpValList = NULL, lpTemp;
    LPBYTE   lpDataBuf;
    TCHAR    szDataBuf[MAX_PATH];
    TCHAR    szNewKeyPath[METADATA_MAX_NAME_LEN+1];
    TCHAR    szChildPathName[METADATA_MAX_NAME_LEN+1];

    hresError = pcAdmCom->OpenKey (METADATA_MASTER_ROOT_HANDLE,
                          lpFullKey,
                          METADATA_PERMISSION_READ,   // | METADATA_PERMISSION_WRITE,
                          MD_DEFAULT_TIMEOUT,
                          &hmdHandle);

    if (FAILED(hresError))
    {
        DPF(APPerr,
            L"RecursiveEnumKey: OpenKey1 failed at the key %s", lpFullKey);
        goto Exit;
    }

    dwDataIndex = 0;
    do
    {
        bAllocBuf = FALSE;
        md_Rec.dwMDIdentifier = 0;
        md_Rec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        md_Rec.dwMDUserType = 0;
        md_Rec.dwMDDataType = 0;
        md_Rec.dwMDDataLen = sizeof(szDataBuf);
        md_Rec.pbMDData = (unsigned char*)szDataBuf;

        hresError = pcAdmCom->EnumData (
                    hmdHandle,
                    L"/",
                    &md_Rec,
                    dwDataIndex,
                    &dwRequiredSize);

        if (SUCCEEDED(hresError))
        {
            lpDataBuf = (LPBYTE)szDataBuf;
            goto DataAnalysis;
        } else if (HRESULT_CODE(hresError) == ERROR_INSUFFICIENT_BUFFER)
        {
            lpDataBuf = (LPBYTE)calloc(dwRequiredSize, 1);
            if (!lpDataBuf)
            {
                DPF(APPerr,
                    L"RecursiveEnumKey: No enough memory at the key %s", lpFullKey);
                pcAdmCom->CloseKey (hmdHandle);
                goto Exit;
            }

            bAllocBuf = TRUE;
            md_Rec.dwMDIdentifier = 0;
            md_Rec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
            md_Rec.dwMDUserType = 0;
            md_Rec.dwMDDataType = 0;
            md_Rec.dwMDDataLen = dwRequiredSize;
            md_Rec.pbMDData = (unsigned char*)lpDataBuf;

            hresError = pcAdmCom->EnumData (
                    hmdHandle,
                    L"/",
                    &md_Rec,
                    dwDataIndex,
                    &dwRequiredSize);

        }
        else if (HRESULT_CODE(hresError) == ERROR_NO_MORE_ITEMS)
        {
            hresError = S_OK;
            break;
        } else if(HRESULT_CODE(hresError) == ERROR_ACCESS_DENIED)
        {
            DPF(APPerr,
                L"RecursiveEnumKey:  Access is denied under the key %s",
                   lpFullKey);
            hresError = S_OK;
            goto NextKey;
        } else
        {
            DPF(APPerr,
                L"RecursiveEnumKey: EnumData failed at the key %s hresError=%d", lpFullKey, hresError);
            hresError = S_OK;
            goto NextKey;
        }

DataAnalysis:
        if (SUCCEEDED(hresError) &&
               (md_Rec.dwMDDataType == EXPANDSZ_METADATA ||
                md_Rec.dwMDDataType == MULTISZ_METADATA ||
                md_Rec.dwMDDataType == STRING_METADATA))
        {
            hresError = QueryData (
                                &md_Rec,
                                lpFullKey,
                                &lpValList,
                                lpRegStr,
                                bStrChk);
            if (SUCCEEDED(hresError))
            {
                lpTemp = lpValList;

                if (lpTemp)
                {
                    while (lpTemp->pvl_next)
                    {
                        lpTemp = lpTemp->pvl_next;
                    }
                    if (lpTemp->md.dwMDIdentifier == 0x00FFFFFF)
                    {
                        lpTemp->md.dwMDIdentifier = md_Rec.dwMDIdentifier;
                        lpTemp->md.dwMDAttributes = md_Rec.dwMDAttributes;
                        lpTemp->md.dwMDUserType = md_Rec.dwMDUserType;
                        lpTemp->md.dwMDDataType = md_Rec.dwMDDataType;
                        lpTemp->md.dwMDDataLen = lpTemp->ve.ve_valuelen;
                        lpTemp->md.pbMDData = (unsigned char *)lpTemp->ve.ve_valueptr ;
                        lpTemp->md.dwMDDataTag = md_Rec.dwMDDataTag;
                    }
                }
            } else
                DPF(APPerr, L"RecursiveEnumKey: QueryData fails at key %s hresError = %d",
                        lpFullKey, hresError);
        }
        
NextKey:        
        if (bAllocBuf)
            free(lpDataBuf);

        dwDataIndex++;
    } while (SUCCEEDED(hresError));

    SetDataValueChange (pcAdmCom, hmdHandle, &lpValList, lpFullKey);

    pcAdmCom->CloseKey (hmdHandle);

    //
    // Now Enumerate all of the keys
    //
    dwKeyIndex = 0;
    do
    {
        hresError = pcAdmCom->OpenKey (METADATA_MASTER_ROOT_HANDLE,
                          lpFullKey,
                          METADATA_PERMISSION_READ,   // | METADATA_PERMISSION_WRITE,
                          MD_DEFAULT_TIMEOUT,
                          &hmdHandle);

        if (FAILED(hresError))
        {
            DPF(APPerr,
                L"RecursiveEnumKey: OpenKey2 failed at the key %s", lpFullKey);
            break;
        }

        hresError = pcAdmCom->EnumKeys (
                    hmdHandle,
                    L"/",
//                    METADATA_MASTER_ROOT_HANDLE,
//                    lpFullKey,
                    szChildPathName,
                    dwKeyIndex);

        pcAdmCom->CloseKey (hmdHandle);

        if (FAILED(hresError))
        {
            if (HRESULT_CODE(hresError) != ERROR_NO_MORE_ITEMS)
            {
                DPF(APPerr, L"RecursiveEnumKey: EnumKeys failed at the key %s", lpFullKey);
            }            
            break;
        }

        // copy the full path to the child and call RecursiveEnumKey
        if (FAILED(hresError = StringCchCopy (szNewKeyPath, METADATA_MAX_NAME_LEN, lpFullKey)))
        {
            DPF(APPerr, L"RecursiveEnumKey: Buffer szNewKeyPath is too small, EnumKeys failed at the key %s", lpFullKey);
            break;
        }
        if (FAILED(hresError = StringCchCat (szNewKeyPath, METADATA_MAX_NAME_LEN, szChildPathName)))
        {
            DPF(APPerr, L"RecursiveEnumKey: Buffer szNewKeyPath is too small, EnumKeys failed at the key %s", lpFullKey);
            break;
        }
        if (FAILED(hresError = StringCchCat (szNewKeyPath, METADATA_MAX_NAME_LEN, L"/")))
        {
            DPF(APPerr, L"RecursiveEnumKey: Buffer szNewKeyPath is too small, EnumKeys failed at the key %s", lpFullKey);
            break;
        }

        hresError = RecursiveEnumKey (pcAdmCom, szNewKeyPath, lpRegStr, bStrChk);

        if (FAILED(hresError))
        {
            if(HRESULT_CODE(hresError) == ERROR_ACCESS_DENIED) // continue to query next key
            {
                DPF(APPerr, L"RecursiveEnumKey: Access is denied in the key %s", szNewKeyPath);
                hresError = ERROR_SUCCESS;
            }
            else
                DPF(APPerr,L"RecursiveEnumKey fail in the key %s", szNewKeyPath);
        }

        dwKeyIndex++;
    } while (SUCCEEDED(hresError));

    if (HRESULT_CODE(hresError) == ERROR_NO_MORE_ITEMS)
        hresError = ERROR_SUCCESS;

Exit:
    return hresError;
}

HRESULT InitInstance(
IMSAdminBase **pcAdmCom,
IClassFactory **pcsfFactory)
{
    size_t cchSize;
    HRESULT hresError;
    METADATA_HANDLE hMDHandle;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    LPTSTR lpMachineName;


    //fill the structure for CoGetClassObject
    csiMachineName.pAuthInfo = NULL;
    csiMachineName.dwReserved1 = 0;
    csiMachineName.dwReserved2 = 0;
    pcsiParam = &csiMachineName;

    // Get Machine Name for COM
    cchSize = ExpandEnvironmentStrings (L"%COMPUTERNAME%", NULL, 0);
    if (cchSize == 0)
    {
        hresError = E_INVALIDARG;
        goto Exit;
    }

    lpMachineName = (LPTSTR) calloc (cchSize+1, sizeof(TCHAR));
    if (!lpMachineName)
    {
        hresError = E_OUTOFMEMORY;
        goto Exit;
    }

    ExpandEnvironmentStrings(L"%COMPUTERNAME%", lpMachineName, cchSize);

    csiMachineName.pwszName = lpMachineName;    
    
    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) pcsfFactory);

    if (FAILED(hresError))
        goto Exit1;
    else
    {
        hresError = (*pcsfFactory)->CreateInstance(NULL, IID_IMSAdminBase, (void **) pcAdmCom);
        if (FAILED(hresError)) 
        {
            DPF (APPerr, L"SetMetabaseValue: CreateInstance Failed! Error: %d (%#x)\n", hresError, hresError);
            (*pcsfFactory)->Release();
        }
    }

Exit1:
    free (lpMachineName);

Exit:
    return hresError;
}

//-----------------------------------------------------------------------//
//
// MetabaseAnalyze()
//
// DESCRIPTION:
// Enumerate metabase and replace localized string to English.
//
// lpRegStr:  Input parameter structure
//
//-----------------------------------------------------------------------//
HRESULT MetabaseAnalyze (
    LPTSTR              lpRoot,
    PREG_STRING_REPLACE lpRegStr,
    BOOL                bStrChk)
{
    HRESULT       hresError;
    IMSAdminBase *pcAdmCom = NULL;
    IClassFactory *pcsfFactory = NULL;

    DPF(APPmsg, L"Enter MetabaseAnalyze: ");

    if (!lpRegStr || lpRegStr->lpSearchString == NULL || lpRegStr->lpReplaceString == NULL)
    {
        hresError = E_INVALIDARG;
        goto Exit;
    }
    lpRegStr->cchMaxStrLen = GetMaxStrLen (lpRegStr);

    hresError = InitInstance(&pcAdmCom, &pcsfFactory);
    if (FAILED(hresError))
    {
        if (IsServiceRunning(L"iisadmin"))
        {
            DoMessageBox(GetConsoleWindow(), IDS_IIS_ERROR, IDS_MAIN_TITLE, MB_OK);
            DPF (APPerr, L"MetabaseAnalyze: CoGetClassObject Failed! Error: %d (%#x)\n", hresError, hresError);
        } else
            hresError = S_OK;
        goto Exit;
    }

    if (!lpRoot)
    {
        hresError = RecursiveEnumKey (pcAdmCom, L"/", lpRegStr, bStrChk);
    }
    else
    {
        hresError = RecursiveEnumKey (pcAdmCom, lpRoot, lpRegStr, bStrChk);
    }
    if (FAILED(hresError))
    {
        DPF (APPerr, L"MetabaseAnalyze: Recursive data dump FAILED! Error: %d (%#x)\n", hresError, hresError);
    }

    // Release the object
    pcAdmCom->Release();
    pcsfFactory->Release();

Exit:
    DPF(APPmsg, L"Exit MetabaseAnalyze: ");
    return hresError;
}

DWORD RegType2MetaType(DWORD dwType)
{
    switch (dwType)
    {
        case REG_SZ:
             return STRING_METADATA;
        break;
        case REG_EXPAND_SZ:
            return EXPANDSZ_METADATA;
        break;
        case REG_MULTI_SZ:
            return MULTISZ_METADATA;
        break;
    }
    return (-1);
}


DWORD MetaType2RegType(DWORD dwType)
{
    switch (dwType)
    {
        case STRING_METADATA:
             return REG_SZ;
        break;
        case EXPANDSZ_METADATA:
            return REG_EXPAND_SZ;
        break;
        case MULTISZ_METADATA:
            return REG_MULTI_SZ;
        break;
    }
    return (-1);
}

//-----------------------------------------------------------------------//
//
// SetMetabaseValue()
//
// DESCRIPTION:
// Set metabase value
//
// lpValList:     Updated value list
// lpFullKey:     Full sub-key path
//-----------------------------------------------------------------------//
HRESULT SetMetabaseValue (
LPCTSTR lpFullKey,
LPCTSTR lpValueID,
DWORD   dwType,
LPCTSTR lpValueData)
{
    HRESULT         hresError;
    IMSAdminBase   *pcAdmCom = NULL;
    IClassFactory  *pcsfFactory = NULL;
    LPBYTE          lpDataBuf = NULL;
    METADATA_RECORD md_Rec;
    METADATA_HANDLE hmdHandle;
    DWORD           dwRequiredSize;
    DWORD           dwSize;
    TCHAR           szDataBuf[MAX_PATH];

    DPF(APPmsg, L"Enter SetMetabaseValue: ");

    hresError = InitInstance(&pcAdmCom, &pcsfFactory);
    if (FAILED(hresError))
    {
        if (IsServiceRunning(L"iisadmin"))
        {
            DoMessageBox(GetConsoleWindow(), IDS_IIS_ERROR, IDS_MAIN_TITLE, MB_OK);
            DPF (APPerr, L"SetMetabaseValue: CoGetClassObject Failed! Error: %d (%#x)\n", hresError, hresError);
        } else
            hresError = S_OK;
        goto Exit;
    }

    hresError = pcAdmCom->OpenKey (METADATA_MASTER_ROOT_HANDLE,
                          lpFullKey,
                          METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                          MD_DEFAULT_TIMEOUT,
                          &hmdHandle);

    if (FAILED(hresError))
    {
        if ( (HRESULT_CODE(hresError) == ERROR_FILE_NOT_FOUND)
             || (HRESULT_CODE(hresError) == ERROR_PATH_NOT_FOUND) )
        {
            DPF(APPwar, L"SetMetabaseValue: OpenKey failed at the key %s ,hr = %d , error = %d", lpFullKey,hresError,HRESULT_CODE(hresError));
            hresError = S_FALSE;
        }
        else
        {
            DPF(APPerr, L"SetMetabaseValue: OpenKey failed at the key %s ,hr = %d , error = %d", lpFullKey,hresError,HRESULT_CODE(hresError));
        }
        goto Exit1;
    }

    md_Rec.dwMDIdentifier = (DWORD)_tstoi(lpValueID);
    md_Rec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    md_Rec.dwMDUserType = 0;
    md_Rec.dwMDDataType = 0;
    md_Rec.dwMDDataLen = sizeof(szDataBuf);
    md_Rec.pbMDData = (unsigned char*)szDataBuf;
    hresError = pcAdmCom->GetData (hmdHandle,
                                   L"/",
                                   &md_Rec,
                                   &dwRequiredSize);

    if (FAILED(hresError))
    {
        if (HRESULT_CODE(hresError) == ERROR_INSUFFICIENT_BUFFER)
        {
            lpDataBuf = (LPBYTE)calloc(dwRequiredSize, 1);
            if (!lpDataBuf)
            {
                DPF(APPerr,
                    L"SetMetabaseValue: No enough memory at the key %s", lpFullKey);
                goto Exit2;
            }

            md_Rec.dwMDDataLen = dwRequiredSize;
            md_Rec.pbMDData = (unsigned char*)lpDataBuf;
            hresError = pcAdmCom->GetData (hmdHandle,
                                   L"/",
                                   &md_Rec,
                                   &dwRequiredSize);
            if (FAILED(hresError))
            {
                DPF(APPerr, L"SetMetabaseValue: GetData failed at the key %s", lpFullKey);
                goto Exit3;
            }
        } else
        {
            DPF(APPerr, L"SetMetabaseValue: GetData failed at the key %s", lpFullKey);
            goto Exit2;
        }
    }

    if (md_Rec.dwMDDataType != dwType)
    {
        DPF(APPerr, L"SetMetabaseValue: Wrong data type at the key %s", lpFullKey);
        goto Exit3;
    }

    switch (dwType)
    {
        case EXPANDSZ_METADATA:
        case STRING_METADATA:
            dwSize = (lstrlen(lpValueData)+1)*sizeof(TCHAR);
            break;

        case MULTISZ_METADATA:
            dwSize = MultiSzLen(lpValueData)*sizeof(TCHAR);
            break;

        default:
            goto Exit3;
    }

    md_Rec.dwMDDataLen = dwSize;
    md_Rec.pbMDData = (unsigned char*)lpValueData;

    hresError = pcAdmCom->SetData (hmdHandle,
                        L"/",
                        &md_Rec);
        
    if (SUCCEEDED(hresError))
        DPF (APPinf, L"SetMetabaseValue: replace the data of valueID %d under the key %s",
                        md_Rec.dwMDIdentifier , lpFullKey);
    else
        DPF (APPerr, L"SetMetabaseValue: Failed hResult=%x the data of valueID %d under the key %s",
                     hresError, md_Rec.dwMDIdentifier , lpFullKey);

Exit3:
    if (lpDataBuf)
        free(lpDataBuf);

Exit2:
    pcAdmCom->CloseKey (hmdHandle);

Exit1:
    // Release the object
    pcAdmCom->Release();
    pcsfFactory->Release();

Exit:
    DPF(APPmsg, L"Exit SetMetabaseValue: ");
    return hresError;
}


HRESULT BatchUpateIISMetabase(
    HINF            hInf, 
    LPTSTR          lpszSection)
{
    HRESULT hr;
    UINT LineCount,LineNo,nFieldIndex;
    INFCONTEXT InfContext;    
#define REG_UPDATE_FIELD_COUNT          5
    int    i;
    TCHAR  szUpdateType[MAX_PATH],szStrType[MAX_PATH];
    DWORD  dwUpdateType, dwStrType;
    DWORD  pdwSizeRequired[REG_UPDATE_FIELD_COUNT+1] = {0,ARRAYSIZE(szUpdateType),0,0,0,0};    
    LPTSTR lpszField[REG_UPDATE_FIELD_COUNT+1] = {NULL, szUpdateType, NULL, NULL, NULL, NULL};
    
    //check the INF file handle
    if(hInf == INVALID_HANDLE_VALUE) 
    {        
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!lpszSection || !lpszSection[0])
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }    
    //here we got the section name and then try to get how many lines there
    LineCount = (UINT)SetupGetLineCount(hInf,lpszSection);
    if ((LONG)LineCount <= 0)
    {   
        hr = S_FALSE;
        goto Cleanup;
    }

    //Scan the INF file section to get the max buf required for each field
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {        
        DWORD dwNumField; 
        DWORD dwDataStart;
        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);
            continue;    
        }
        dwNumField = SetupGetFieldCount(&InfContext);
        if ( dwNumField < 4 )
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,lpszField[1],pdwSizeRequired[1],NULL))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);
            continue;
        }
        dwUpdateType = _tstoi(lpszField[1]);
        switch (dwUpdateType)
        {
            case CONSTANT_REG_VALUE_DATA_RENAME:
                if (!SetupGetStringField(&InfContext,2,szStrType,ARRAYSIZE(szStrType),NULL))
                {
                    DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);
                    continue;
                }
                dwStrType = _tstoi(szStrType);
                dwDataStart = 3;
                break;
            case CONSTANT_REG_VALUE_NAME_RENAME:                
            case CONSTANT_REG_KEY_RENAME:                
                dwDataStart = 2;
                break;
        }
        for (nFieldIndex = dwDataStart ; nFieldIndex <= min(dwNumField,REG_UPDATE_FIELD_COUNT) ; nFieldIndex++)
        {      
            BOOL    bRet;
            DWORD   cchReqSize;
            if ((nFieldIndex == REG_UPDATE_FIELD_COUNT) && (dwStrType == REG_MULTI_SZ))
            {
                bRet = SetupGetMultiSzField(&InfContext,nFieldIndex,NULL,0,&cchReqSize);
            }
            else
            {
                bRet = SetupGetMultiSzField(&InfContext,nFieldIndex,NULL,0,&cchReqSize);
            }
            if (!bRet)
            {
                DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);
                continue;    
            }
            pdwSizeRequired[nFieldIndex] = max(pdwSizeRequired[nFieldIndex],cchReqSize);
        }
    }    
    
    for (i = 2; i<= REG_UPDATE_FIELD_COUNT; i++)
    {
        if (pdwSizeRequired[i])
        {
            if ( NULL == (lpszField[i] = (LPTSTR)malloc(++pdwSizeRequired[i] * sizeof(TCHAR))))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }       

    for(LineNo=0; LineNo<LineCount; LineNo++)
    {
        SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext);
        SetupGetStringField(&InfContext,1,lpszField[1],pdwSizeRequired[1],NULL);
        dwUpdateType = _tstoi(lpszField[1]);
        switch (dwUpdateType)
        {
               case CONSTANT_REG_VALUE_DATA_RENAME:
                SetupGetStringField(&InfContext,2,szStrType,ARRAYSIZE(szStrType),NULL);
                dwStrType = _tstoi(szStrType);
                SetupGetStringField(&InfContext,3,lpszField[3],pdwSizeRequired[3],NULL);
                SetupGetStringField(&InfContext,4,lpszField[4],pdwSizeRequired[4],NULL);
                
                if ( (dwStrType == REG_EXPAND_SZ) || (dwStrType == REG_SZ))
                {
                    SetupGetStringField(&InfContext,5,lpszField[5],pdwSizeRequired[5],NULL);
                }
                else 
                {
                    SetupGetMultiSzField(&InfContext,5,lpszField[5],pdwSizeRequired[5],NULL);
                }
                dwStrType = RegType2MetaType(dwStrType);
                SetMetabaseValue (lpszField[3],lpszField[4],dwStrType,lpszField[5]);
                break;
            case CONSTANT_REG_VALUE_NAME_RENAME:
            case CONSTANT_REG_KEY_RENAME:
                for (i = 2; i <= 4 ;i++)
                {
                    SetupGetStringField(&InfContext,i,lpszField[i],pdwSizeRequired[i],NULL);
                }            
                break;            
        }
    }
    hr = S_OK;
Cleanup:
    for (i = 2; i< ARRAYSIZE(lpszField); i++)
    {
        FreePointer(lpszField[i]);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\inf.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    inf.c

Abstract:

    Miscellaneous routines for the INF File Operation

Author:

    Xiaofeng Zang (xiaoz) 17-Sep-2001  Created

Revision History:

    <alias> <date> <comments>

--*/

#include "StdAfx.h"
#include "clmt.h"

HRESULT RegistryRename(HINF hInf, LPTSTR lpszSection,HKEY hKeyRoot,LPTSTR lpszUser);
HRESULT FolderMove(HINF hInf, LPTSTR lpszSection,BOOL bAnalyze);
HRESULT ChangeServiceStartupType(LPCTSTR, DWORD, DWORD);






HRESULT
RegistryRename(HINF hInf, LPTSTR lpszSection,HKEY hKeyRoot,LPTSTR lpszUser)
{
    UINT LineCount,LineNo;
    INFCONTEXT InfContext;
    DWORD dwStrType;
    LPTSTR pSubKeyPath;
    HKEY hKey;
    TCHAR szRenameType[MAX_PATH],szStringType[MAX_PATH];
    DWORD dwRenameType,dwStringType;
    DWORD cchMaxOldKeyPathLength = 0;
    DWORD cchMaxNewKeyPathLength = 0;
    DWORD cchMaxOldNameLength = 0;
    DWORD cchMaxNewNameLength = 0;
    DWORD cchMaxOldDataLength = 0;
    DWORD cchMaxNewDataLength = 0;
    DWORD dwAttrib = 0;
    LPTSTR lpszOldKey,lpszNewKey,lpszOldName,lpszNewName,lpszOldValue,lpszNewValue;
    HRESULT hr;
    LONG    lstatus;
    

    lpszOldKey = lpszNewKey = lpszOldName = lpszNewName
         = lpszOldValue = lpszNewValue = NULL;
    LineCount = (UINT)SetupGetLineCount(hInf,lpszSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        DPF(INFwar ,TEXT("section name %s is empty  failed !"),lpszSection);
        goto Cleanup;
    }
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {
        DWORD  cchTmpOldKeyPathLength,cchTmpNewKeyPathLength ,cchTmpOldNameLength ,
           cchTmpNewNameLength,cchTmpOldDataLength,cchTmpNewDataLength;

        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);            
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,szRenameType,MAX_PATH,NULL))
        {
            DPF(INFwar ,TEXT("get [%s] 's line %n 's Field 0 failed  !"),lpszSection, LineNo);
            continue;
        }
        
        cchTmpOldKeyPathLength = cchTmpNewKeyPathLength = cchTmpOldNameLength
         = cchTmpNewNameLength = cchTmpOldDataLength = cchTmpNewDataLength = 0;
        dwRenameType = _tstoi(szRenameType);
        switch (dwRenameType)
        {
            case TYPE_VALUE_RENAME:
                if (!SetupGetStringField(&InfContext,2,szStringType,MAX_PATH,NULL)
                    || !SetupGetStringField(&InfContext,3,NULL,0,&cchTmpOldKeyPathLength)
                    || !SetupGetStringField(&InfContext,4,NULL,0,&cchTmpOldNameLength)
                    || ! SetupGetStringField(&InfContext,5,NULL,0,&cchTmpOldDataLength)
                    || ! SetupGetStringField(&InfContext,6,NULL,0,&cchTmpNewDataLength))
                {
                    DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 2,3,4,5,6 failed  !"),lpszSection ,InfContext.Line);
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto Cleanup;
                }
            break;
            case TYPE_VALUENAME_RENAME:
                if (!SetupGetStringField(&InfContext,2,NULL,0,&cchTmpOldKeyPathLength)
                    || !SetupGetStringField(&InfContext,3,NULL,0,&cchTmpOldNameLength)
                    || ! SetupGetStringField(&InfContext,4,NULL,0,&cchTmpNewNameLength))
                {
                    DPF(INFerr ,TEXT("get [%s] 's line %d 's Field ,3,4,5 failed  !"),lpszSection ,InfContext.Line);
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto Cleanup;
                }
            break;
        case TYPE_KEY_RENAME:
                if (!SetupGetStringField(&InfContext,2,NULL,0,&cchTmpOldKeyPathLength)
                    || !SetupGetStringField(&InfContext,3,NULL,0,&cchTmpNewKeyPathLength))
                {
                    DPF(INFerr ,TEXT("get [%s] 's line %d 's Field ,3,4 failed  !"),lpszSection ,InfContext.Line);
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto Cleanup;
                }
            break;
        }
        cchMaxOldKeyPathLength = max(cchTmpOldKeyPathLength,cchMaxOldKeyPathLength);
        cchMaxNewKeyPathLength = max(cchTmpNewKeyPathLength,cchMaxNewKeyPathLength);
        cchMaxOldNameLength = max(cchTmpOldNameLength,cchMaxOldNameLength);
        cchMaxNewNameLength = max(cchTmpNewNameLength,cchMaxNewNameLength);
        cchMaxOldDataLength = max(cchTmpOldDataLength,cchMaxOldDataLength);
        cchMaxNewDataLength = max(cchTmpNewDataLength,cchMaxNewDataLength);              
    }
    if (cchMaxOldKeyPathLength)
    {
        if (!(lpszOldKey = malloc(++cchMaxOldKeyPathLength * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxNewKeyPathLength)
    {
        if (!(lpszNewKey = malloc(++cchMaxNewKeyPathLength * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxOldNameLength)
    {
        if (!(lpszOldName = malloc(++cchMaxOldNameLength * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxNewNameLength)
    {
        if (!(lpszNewName = malloc(++cchMaxNewNameLength * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxOldDataLength)
    {
        if (!(lpszOldValue = malloc(++cchMaxOldDataLength * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxNewDataLength)
    {
        if (!(lpszNewValue = malloc(++cchMaxNewDataLength * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {
        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);            
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,szRenameType,MAX_PATH,NULL))
        {
            DPF(INFwar ,TEXT("get [%s] 's line %n 's Field 0 failed  !"),lpszSection, LineNo);
            continue;
        }
        dwRenameType = _tstoi(szRenameType);
        switch (dwRenameType)
        {
            case TYPE_VALUE_RENAME:
                if (!SetupGetStringField(&InfContext,2,szStringType,MAX_PATH,NULL)
                    || !SetupGetStringField(&InfContext,3,lpszOldKey,cchMaxOldKeyPathLength,NULL)
                    || ! SetupGetStringField(&InfContext,4,lpszOldName,cchMaxOldNameLength,NULL)
                    || ! SetupGetStringField(&InfContext,5,lpszOldValue,cchMaxOldDataLength,NULL)
                    || ! SetupGetStringField(&InfContext,6,lpszNewValue ,cchMaxNewDataLength,NULL))
                {
                    DPF(INFerr ,TEXT("get [%s] 's line %d 's Field ,3,4,5 failed  !"),lpszSection ,InfContext.Line);
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto Cleanup;
                }
                if (!Str2KeyPath(lpszOldKey,&hKey,&pSubKeyPath))
                {
                    DPF(INFerr ,TEXT("format errorin line %d: %s  !"),LineNo,lpszOldKey);
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto Cleanup;
                }
                if (hKeyRoot)
                {
                    hKey = hKeyRoot;
                }
                dwStringType = _tstoi(szStringType);
                lstatus = RegResetValue(hKey, pSubKeyPath,lpszOldName,dwStringType,lpszOldValue,lpszOldValue, 0, NULL);
                if (lstatus == ERROR_SUCCESS)
                {
                    hr = AddRegValueRename(pSubKeyPath,lpszOldName,NULL,lpszOldValue,lpszNewValue,dwStringType,dwAttrib,lpszUser);
                    //Add error checking here
                }
                break;
            case TYPE_VALUENAME_RENAME:
                break;
            case TYPE_KEY_RENAME:
                break;
        }
    }

    
Cleanup:
    FreePointer(lpszOldKey);
    FreePointer(lpszNewKey);
    FreePointer(lpszOldName);
    FreePointer(lpszNewName);
    FreePointer(lpszOldValue);
    FreePointer(lpszNewValue);
    return hr;
}


HRESULT FolderMove(HINF hInf, LPTSTR lpszSection,BOOL bAnalyze)
{
    LPTSTR          lpszOldFolder = NULL,lpszNewFolder = NULL,lpExcludeFileList = NULL;
    DWORD           cchMaxOldFolderSize = 0,cchMaxNewFolderSize = 0,cchMaxExcludeFileListSize = 0;
    HRESULT         hr;
    UINT            LineCount,LineNo;
    INFCONTEXT      InfContext;
    TCHAR           szType[MAX_PATH];
    DWORD           dwType;
 

    if( (hInf == INVALID_HANDLE_VALUE) || (!lpszSection) )
    {   
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,lpszSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        DPF(INFwar ,TEXT("section name %s is empty  failed !"),lpszSection);
        goto Cleanup;
    }   
    
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {
        DWORD  cchTmpOldFolderSize = 0,cchTmpNewFolderSize = 0,cchTmpExcludeFileListSize = 0;
        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);            
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,szType,MAX_PATH,NULL))
        {
            DPF(INFwar ,TEXT("get [%s] 's line %d 's Field 0 failed  !"),lpszSection, LineNo);
            continue;
        }
        
        dwType = _tstoi(szType);
        switch (dwType)
        {
            case TYPE_SFPFILE_MOVE:
            case TYPE_FILE_MOVE:
            case TYPE_DIR_MOVE:
                if (!SetupGetStringField(&InfContext,2,NULL,0,&cchTmpOldFolderSize)
                   || ! SetupGetStringField(&InfContext,3,NULL,0,&cchTmpNewFolderSize))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 2,3failed  !"),lpszSection ,LineNo);
                    goto Cleanup;
                }
                if (TYPE_DIR_MOVE == dwType)
                {
                    BOOL   bTmp;
                    bTmp = SetupGetMultiSzField(&InfContext,4,NULL,0,&cchTmpExcludeFileListSize);
                    if  (!( bTmp && (cchTmpExcludeFileListSize >= sizeof(TCHAR))))
                    {
                        cchTmpExcludeFileListSize = 0;
                    }                    
                }
                break;
            default:
                DPF(INFerr ,TEXT(" [%s] 's line %d 's Field 1 invalid value !"),lpszSection, LineNo);
                hr = E_FAIL;
                goto Cleanup;
                break;
        }
        cchMaxOldFolderSize = max(cchTmpOldFolderSize,cchMaxOldFolderSize);
        cchMaxNewFolderSize = max(cchTmpNewFolderSize,cchMaxNewFolderSize);
        cchMaxExcludeFileListSize = max(cchTmpExcludeFileListSize,cchMaxExcludeFileListSize);
    }
    if (cchMaxOldFolderSize)
    {   // add one more TCHAR space incase the file is SFPed in which case we need
        // provide a multisz string to UnProtectSFPFiles
        cchMaxOldFolderSize += 2; 
        if (!(lpszOldFolder = malloc(cchMaxOldFolderSize * sizeof(TCHAR))))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    if (cchMaxNewFolderSize)
    {
        if (!(lpszNewFolder = malloc(++cchMaxNewFolderSize * sizeof(TCHAR))))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    if (cchMaxExcludeFileListSize)
    {
        if (!(lpExcludeFileList = malloc(++cchMaxExcludeFileListSize * sizeof(TCHAR))))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {
        LPTSTR lpTmpExcludeList = NULL;

        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSection);            
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,szType,MAX_PATH,NULL))
        {
            DPF(INFwar ,TEXT("get [%s] 's line %d 's Field 0 failed  !"),lpszSection, LineNo);
            continue;
        }
        dwType = _tstoi(szType);
        if (!SetupGetStringField(&InfContext,2,lpszOldFolder,cchMaxOldFolderSize,NULL)
                   || ! SetupGetStringField(&InfContext,3,lpszNewFolder,cchMaxNewFolderSize,NULL))
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 2,3failed  !"),lpszSection ,LineNo);
            goto Cleanup;
        }
        switch (dwType)
        {  
            case TYPE_DIR_MOVE:
                    if (cchMaxExcludeFileListSize)
                    {
                        DWORD  dwSize;
                        BOOL   bTmp = SetupGetMultiSzField(&InfContext,4,lpExcludeFileList,
                                                            cchMaxExcludeFileListSize,&dwSize);
                        if  (!( bTmp && dwSize >= sizeof(TCHAR)))
                        {
                            lpTmpExcludeList = lpExcludeFileList;
                        }
                    }
                    else
                    {
                        lpTmpExcludeList = NULL;
                    }
            case TYPE_SFPFILE_MOVE:
            case TYPE_FILE_MOVE:
                if (bAnalyze)
                {
                    AddFolderRename(lpszOldFolder,lpszNewFolder,dwType,lpTmpExcludeList);
                }
                else
                {
                    if (lpTmpExcludeList)
                    {
                        LPTSTR lp = lpTmpExcludeList;
                        while (*lp)
                        {
                            if (!MoveFileEx(lp,NULL,MOVEFILE_DELAY_UNTIL_REBOOT))
                            {
                                DWORD dw = GetLastError();
                                DPF(INFerr, TEXT("MoveFileEx(delete) failed %s,win32 error = %d"),lp,dw);
                            }
                            lp += (lstrlen(lp)+1);
                        }
                    }
                    if (dwType == TYPE_SFPFILE_MOVE)
                    {
                        lpszOldFolder[lstrlen(lpszOldFolder)+1] = TEXT('\0');
                        UnProtectSFPFiles(lpszOldFolder,NULL);
                    }
                    if (!MoveFileEx(lpszOldFolder,lpszNewFolder,MOVEFILE_DELAY_UNTIL_REBOOT))
                    {
                        DWORD dw = GetLastError();
                        DPF(INFerr, TEXT("MoveFileEx(%s,%s) failed win32 error = %d"),lpszOldFolder,lpszNewFolder,dw);
                    }
                }
                break;
        }        
    }


Cleanup:
    FreePointer(lpszOldFolder);
    FreePointer(lpszNewFolder);
    FreePointer(lpExcludeFileList);
    return hr;
}



HRESULT EnsureDoItemInfFile(
    LPTSTR lpszInfFile,
    size_t CchBufSize)
{

    LPWSTR                      lpszHeader = L"[Version]\r\nsignature=\"$Windows NT$\"\r\nClassGUID={00000000-0000-0000-0000-000000000000}\r\nlayoutfile=LAYOUT.INF\r\n";
    HANDLE                      hFile = INVALID_HANDLE_VALUE;
    HRESULT                     hr = S_OK;
    DWORD                       dwWritten;
    DWORD                       dwStatusinReg;
    BOOL                        bCureMode = FALSE;
    WORD                        wBOM=0xFEFF;    
    SECURITY_ATTRIBUTES         sa;
    PSECURITY_DESCRIPTOR        pSD = NULL;
    
    
    if (!GetSystemWindowsDirectory(lpszInfFile, CchBufSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPF(INFerr, TEXT("Failed to get system directory, hr = 0x%X"), hr);
        goto Exit;
    }
    if (!ConcatenatePaths(lpszInfFile,CLMT_BACKUP_DIR,CchBufSize))
    {
        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        DPF(INFerr, TEXT("buffer size too small when creating clmtdo.inf"));
        goto Exit;
    }
    if (!ConcatenatePaths(lpszInfFile,TEXT("CLMTDO.INF"),CchBufSize))
    {
        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        DPF(INFerr, TEXT("buffer size too small when creating clmtdo.inf"));
        goto Exit;
    }
    
    hr = CLMTGetMachineState(&dwStatusinReg);
    //If we 've done running clmt.exe and called again, usually it's in /cure mode...
    //on this case, we will append the INF file
    if ( (hr != S_OK) 
        || ( (CLMT_STATE_MIGRATION_DONE != dwStatusinReg) 
              &&  (CLMT_STATE_FINISH != dwStatusinReg)
              &&  (CLMT_STATE_PROGRAMFILES_CURED != dwStatusinReg)) )
    {
        hr = CreateAdminsSd(&pSD);
        if (hr != S_OK)
        {
            goto Exit;
        }
        sa.nLength        = sizeof(sa);
        sa.bInheritHandle = FALSE;
        sa.lpSecurityDescriptor = pSD;
        hFile = CreateFile(lpszInfFile,GENERIC_WRITE|GENERIC_READ,0,
                                &sa,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);

        hr = InitChangeLog();
    }
    else
    {
        bCureMode = TRUE;
        hFile = CreateFile(lpszInfFile,GENERIC_WRITE|GENERIC_READ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
    }

    if (INVALID_HANDLE_VALUE == hFile)
    {
        DWORD dw = GetLastError();
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPF(INFerr, TEXT("Create file %s failed with hr = 0x%X"),lpszInfFile,hr);
        goto Exit;
    }

    if (!bCureMode)
    {
        if(! WriteFile(hFile,&wBOM,sizeof(WORD),&dwWritten,NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF(INFerr, TEXT("write to file %s failed with hr = 0x%X"),lpszInfFile,hr);
            goto Exit;
        }
        if(! WriteFile(hFile,lpszHeader,lstrlenW(lpszHeader)*sizeof(TCHAR),&dwWritten,NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF(INFerr, TEXT("write to file %s failed with hr = 0x%X"),lpszInfFile,hr);
            goto Exit;
        }
    }
Exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }    
    if (pSD)
    {
        LocalFree(pSD);
    }
    return hr;
}

HRESULT GetMaxLenEachField(
    HINF    hInf,
    LPTSTR  lpSection,
    BOOL    bExitOnError,
    DWORD   dwMinFieldCount,
    DWORD   dwMaxFieldCount,
    PDWORD  pdwFieldValidFlag,
    PDWORD  pdwSizeRequired,
    BOOL    bMultiSZ
    )
{
    HRESULT     hr;
    UINT        LineCount,LineNo;
    UINT        nFieldCount, nFieldIndex;
    INFCONTEXT  InfContext;
    UINT        i;
    UINT        cchReqSize;


    if( (hInf == INVALID_HANDLE_VALUE) || !lpSection )
    {   
        hr = E_INVALIDARG;
        goto Exit;
    }
    if (!dwMinFieldCount || !dwMaxFieldCount 
                || ( dwMaxFieldCount < dwMinFieldCount)
                || !pdwSizeRequired)
    {   
        hr = E_INVALIDARG;
        goto Exit;
    }
    for (i = 0; i < dwMaxFieldCount; i++)
    {
        pdwSizeRequired[i] = 0;
    }

    LineCount = (UINT)SetupGetLineCount(hInf,lpSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        DPF(INFwar ,TEXT("section name %s is empty  failed !"),lpSection);
        goto Exit;
    }
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {        
        DWORD dwNumField; 
        if (!SetupGetLineByIndex(hInf,lpSection,LineNo,&InfContext))
        {
            if (bExitOnError)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            else
            {
                DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpSection);
                continue;
            }            
        }
        dwNumField = SetupGetFieldCount(&InfContext);
        if ( (dwNumField < dwMinFieldCount) || (dwNumField > dwMaxFieldCount) )
        {
            if (bExitOnError)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
            else
            {
                DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpSection);
                continue;
            }
        }
        for (nFieldIndex = 1 ; nFieldIndex <= dwNumField ; nFieldIndex++)
        {
            BOOL        bRet;

            if (pdwFieldValidFlag && !pdwFieldValidFlag[nFieldIndex])
            {
                continue;
            }
            if ((nFieldIndex == dwMaxFieldCount) && bMultiSZ)
            {
                bRet = SetupGetMultiSzField(&InfContext,nFieldIndex,NULL,0,&cchReqSize);
            }
            else
            {
                bRet = SetupGetStringField(&InfContext,nFieldIndex,NULL,0,&cchReqSize);
            }
            if (!bRet)
            {
                if (bExitOnError)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Exit;
                }
                else
                {
                    DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpSection);
                    continue;
                }            
            }
            pdwSizeRequired[nFieldIndex-1] = max(pdwSizeRequired[nFieldIndex-1],cchReqSize);
        }
    }
    hr = S_OK;
Exit:
    return hr;
}





HRESULT RegUpdate(HINF hInf, HKEY hKeyUser , LPTSTR lpszUsersid)
{
#define REG_UPDATE_FIELD_COUNT          5
    HRESULT hr;
    LPTSTR  lpszSectionName = NULL;
    DWORD   cChSecBuffeSize, dwRequestSize = 0;        
    LPTSTR lpszSectionSuffix = NULL;
    UINT LineCount,LineNo,nFieldIndex;
    INFCONTEXT InfContext;
    TCHAR szRegUpdateType[MAX_PATH],szStrType[MAX_PATH];
    DWORD dwRegUpdateType,dwStrType;
    LPTSTR lpszField[REG_UPDATE_FIELD_COUNT+1] = {NULL, szRegUpdateType, NULL, NULL, NULL, NULL};
    HKEY   hKey;
    LPTSTR lpSubKey;
    DWORD  pdwSizeRequired[REG_UPDATE_FIELD_COUNT+1] = {0,MAX_PATH,0,0,0,0};
    int    i;
    
    //check the INF file handle
    if(hInf == INVALID_HANDLE_VALUE) 
    {        
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!lpszUsersid || !MyStrCmpI(lpszUsersid,TEXT("Default_User_SID")))
    {
        //If user sid  is NULL it means default user
        cChSecBuffeSize = lstrlen(TEXT("REG.Update.Default User")) + 1 ;
        lpszSectionSuffix = DEFAULT_USER;
    }
    else if (!lpszUsersid[0])
    {
        //If user sid is  "", it means system wide regsitry
        cChSecBuffeSize = lstrlen(TEXT("REG.Update.Sys")) + 1 ;
        lpszSectionSuffix = TEXT("SYS");
    }  else
    {
        //If it's normal user , the section name is "REG.Update.%userSID%"
        
        cChSecBuffeSize = lstrlen(TEXT("REG.Update.")) + lstrlen(lpszUsersid)+2;
    }

    //Alloc memory and contruct the section name
    if (!(lpszSectionName = (LPTSTR) malloc(cChSecBuffeSize * sizeof(TCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    if (lpszSectionSuffix)
    {
        if (FAILED(StringCchPrintf(lpszSectionName,cChSecBuffeSize,TEXT("%s%s"),TEXT("REG.Update."),
                        lpszSectionSuffix)))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        if (FAILED(StringCchPrintf(lpszSectionName,cChSecBuffeSize,TEXT("%s%s"),TEXT("REG.Update."),
                        lpszUsersid)))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }   

    //here we got the section name and then try to get how many lines there
    LineCount = (UINT)SetupGetLineCount(hInf,lpszSectionName);
    if ((LONG)LineCount < 0)
    {   
        //BUGBUG: xiaoz:The error value here needs to be revisted
        hr = E_FAIL;
        goto Cleanup;
    }

    //Scan the INF file section to get the max buf required for each field
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {        
        DWORD dwNumField; 
        DWORD dwDataStart;
        if (!SetupGetLineByIndex(hInf,lpszSectionName,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSectionName);
            continue;    
        }
        dwNumField = SetupGetFieldCount(&InfContext);
        if ( dwNumField < 4 )
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSectionName);
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,lpszField[1],pdwSizeRequired[1],NULL))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSectionName);
            continue;
        }
        dwRegUpdateType = _tstoi(lpszField[1]);
        switch (dwRegUpdateType)
        {
            case CONSTANT_REG_VALUE_DATA_RENAME:
                if (!SetupGetStringField(&InfContext,2,szStrType,ARRAYSIZE(szStrType),NULL))
                {
                    DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSectionName);
                    continue;
                }
                dwStrType = _tstoi(szStrType);
                dwDataStart = 3;
                break;
            case CONSTANT_REG_VALUE_NAME_RENAME:                
            case CONSTANT_REG_KEY_RENAME:                
                dwDataStart = 2;
                break;
        }
        for (nFieldIndex = dwDataStart ; nFieldIndex <= min(dwNumField,REG_UPDATE_FIELD_COUNT) ; nFieldIndex++)
        {      
            BOOL    bRet;
            DWORD   cchReqSize;
            if ((nFieldIndex == REG_UPDATE_FIELD_COUNT) && (dwStrType == REG_MULTI_SZ))
            {
                bRet = SetupGetMultiSzField(&InfContext,nFieldIndex,NULL,0,&cchReqSize);
            }
            else
            {
                bRet = SetupGetMultiSzField(&InfContext,nFieldIndex,NULL,0,&cchReqSize);
            }
            if (!bRet)
            {
                DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpszSectionName);
                continue;    
            }
            pdwSizeRequired[nFieldIndex] = max(pdwSizeRequired[nFieldIndex],cchReqSize);
        }
    }    
    
    for (i = 2; i<= REG_UPDATE_FIELD_COUNT; i++)
    {
        if (pdwSizeRequired[i])
        {
            if ( NULL == (lpszField[i] = malloc(++pdwSizeRequired[i] * sizeof(TCHAR))))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }       
    for(LineNo=0; LineNo<LineCount; LineNo++)
    {
        SetupGetLineByIndex(hInf,lpszSectionName,LineNo,&InfContext);
        SetupGetStringField(&InfContext,1,lpszField[1],pdwSizeRequired[1],NULL);
        dwRegUpdateType = _tstoi(lpszField[1]);
        switch (dwRegUpdateType)
        {
               case CONSTANT_REG_VALUE_DATA_RENAME:
                SetupGetStringField(&InfContext,2,szStrType,ARRAYSIZE(szStrType),NULL);
                dwStrType = _tstoi(szStrType);
                SetupGetStringField(&InfContext,3,lpszField[3],pdwSizeRequired[3],NULL);
                SetupGetStringField(&InfContext,4,lpszField[4],pdwSizeRequired[4],NULL);
                
                if ((dwStrType & 0xffff) == REG_MULTI_SZ)
                {
                    SetupGetMultiSzField(&InfContext,5,lpszField[5],pdwSizeRequired[5],NULL);
                }
                else if ((dwStrType & 0xffff) == REG_BINARY)
                {
                    if (!SetupGetBinaryField(&InfContext,5,(LPBYTE)lpszField[5],pdwSizeRequired[5]*sizeof(TCHAR),&dwRequestSize) &&
                        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        free(lpszField[5]);
                        if ((lpszField[5] = (LPTSTR)malloc(dwRequestSize)) == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }
                        SetupGetBinaryField(&InfContext,5,(LPBYTE)lpszField[5],dwRequestSize,NULL);
                    }
                }
                else
                {
                    SetupGetStringField(&InfContext,5,lpszField[5],pdwSizeRequired[5],NULL);
                }

                if (!(*lpszField[3]))
                {
                    lpSubKey = NULL;
                }
                else
                {
                    Str2KeyPath(lpszField[3],&hKey,&lpSubKey);
                }
                if (hKeyUser)
                {
                    hKey = hKeyUser;
                }
                if ( (dwStrType & 0xffff) == REG_DWORD)
                {
                    MyRegSetDWValue(hKey,lpSubKey,lpszField[4],lpszField[5]);
                }
                else
                {
                    RegResetValue(hKey,lpSubKey,lpszField[4],dwStrType,TEXT(""),lpszField[5],dwRequestSize,lpszUsersid);
                }
                break;
            case CONSTANT_REG_VALUE_NAME_RENAME:
            case CONSTANT_REG_KEY_RENAME:
                for (i = 2; i <= 4 ;i++)
                {
                    SetupGetStringField(&InfContext,i,lpszField[i],pdwSizeRequired[i],NULL);
                }
                Str2KeyPath(lpszField[2],&hKey,&lpSubKey);
                if (hKeyUser)
                {
                    hKey = hKeyUser;
                }
                if (dwRegUpdateType == CONSTANT_REG_VALUE_NAME_RENAME)
                {
                    RegResetValueName(hKey,lpSubKey,lpszField[3],lpszField[4], lpszUsersid);
                }
                else
                {
                    RegResetKeyName(hKey, lpSubKey, lpszField[3], lpszField[4]);
                }
                break;            
        }
    }
    hr = S_OK;
Cleanup:
    FreePointer(lpszSectionName);        
    for (i = 2; i< ARRAYSIZE(lpszField); i++)
    {
        FreePointer(lpszField[i]);
    }
    return hr;
}

HRESULT INFCreateHardLink(
    HINF    hInf,
    LPTSTR  lpszSection,
    BOOL    bMakeLinkHidden)
{
    HRESULT         hr;
    INT             LineCount,LineNo,nFieldIndex;
    INFCONTEXT      InfContext;
    TCHAR           szFileName[MAX_PATH+1],szExistingFileName[MAX_PATH+1],szHidden[MAX_PATH];
    TCHAR           szType[10];
    DWORD           dwType;
    TCHAR           lpszInf[MAX_PATH+1];
    HINF            hMyInf;
    BOOL            bLocalHidden = bMakeLinkHidden;
    
    //check the INF file handle
    hMyInf = hInf;
    if(hMyInf == INVALID_HANDLE_VALUE) 
    {   
        hr = EnsureDoItemInfFile(lpszInf,ARRAYSIZE(lpszInf));
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        hMyInf = SetupOpenInfFile(lpszInf,
                                  NULL,
                                  INF_STYLE_WIN4,
                                  NULL);
        if (hMyInf == INVALID_HANDLE_VALUE)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    LineCount = (UINT)SetupGetLineCount(hMyInf,lpszSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        goto Cleanup;
    }
    for (LineNo = LineCount -1 ; LineNo >= 0; LineNo--)
    {
        BOOL b1,b2,b3,b4;

        if (!SetupGetLineByIndex(hMyInf,lpszSection,LineNo,&InfContext))
        {
            continue;
        }
        b1 = SetupGetStringField(&InfContext,1,szType,ARRAYSIZE(szType),NULL);
        b2 = SetupGetStringField(&InfContext,2,szFileName,ARRAYSIZE(szFileName),NULL);
        b3 = SetupGetStringField(&InfContext,3,szExistingFileName,ARRAYSIZE(szExistingFileName),NULL);
        if (!b1 || !b2 || !b3)
        {
            continue;
        }
        b4 = SetupGetStringField(&InfContext,4,szHidden,ARRAYSIZE(szHidden),NULL);
        
        bLocalHidden = bMakeLinkHidden;
        if (b4)
        {
            DWORD dwHiddenType;
            
            dwHiddenType = _tstoi(szHidden);
            if (!dwHiddenType)
            {
                bLocalHidden = FALSE;
            }
            else
            {
                bLocalHidden = TRUE;
            }
        }        
        dwType = _tstoi(szType);
#ifdef CREATE_MINI_HARDLIN
        if (g_dwRunningStatus == CLMT_CURE_PROGRAM_FILES)
        {
            if (dwType == 0)
            {
                continue;
            }
        }
#endif
#ifdef CONSOLE_UI
        wprintf(TEXT("create reparse point between folder %s and %s\n"),szFileName,szExistingFileName);
#endif

        if (CreateSymbolicLink(szFileName,szExistingFileName,bLocalHidden))
        {
            //hr = S_OK;
        }
        else
        {
            //hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    hr  = S_OK;
Cleanup:
    if ( (hInf == INVALID_HANDLE_VALUE) && (hMyInf != INVALID_HANDLE_VALUE) )
    {
        SetupCloseInfFile(hMyInf);        
    }
    return hr;   
}


//-----------------------------------------------------------------------
//
//  Function:   AnalyzeServicesStatus
//
//  Descrip:    Analyze the services running on the system and see if
//              they need to be stopped or not
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    04/30/2002 rerkboos created
//              07/08/2002 rerkboos modified
//              09/06/2002 rerkboos modified
//
//  Notes:      Format of the section in clmt.inf:
//              <service name to be stopped>, <action>
//
//-----------------------------------------------------------------------
HRESULT AnalyzeServicesStatus(
    HINF    hInf,           // Handle to Migration INF
    LPCTSTR lpInfSection    // Section to be read from INF
)
{
    HRESULT    hr = S_OK;
    BOOL       bRet = TRUE;
    LONG       lLineCount;
    LONG       lLineIndex;
    INFCONTEXT context;
    TCHAR      szServiceName[128];
    TCHAR      szControl[8];
    TCHAR      szCleanupControl[8];
    INT        iRunningStatus;
    INT        iServiceControl;
    DWORD      dwCleanupControl;
    SC_HANDLE      schService;
    SC_HANDLE      schSCManager;
    SERVICE_STATUS ssStatus;

    if (hInf == INVALID_HANDLE_VALUE || lpInfSection == NULL)
    {
        return E_INVALIDARG;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager != NULL)
    {
        // Read the list of services to be reset from INF
        lLineCount = SetupGetLineCount(hInf, lpInfSection);
        for (lLineIndex = 0 ; lLineIndex < lLineCount && bRet ; lLineIndex++)
        {
            bRet = SetupGetLineByIndex(hInf,
                                       lpInfSection,
                                       (DWORD) lLineIndex,
                                       &context);
            if (bRet)
            {
                bRet = SetupGetStringField(&context,
                                           1,
                                           szServiceName,
                                           ARRAYSIZE(szServiceName),
                                           NULL)
                       && SetupGetIntField(&context,
                                           2,
                                           &iRunningStatus)
                       && SetupGetIntField(&context,
                                           3,
                                           &iServiceControl);
                if (bRet)
                {
                    schService = OpenService(schSCManager, szServiceName, SERVICE_ALL_ACCESS);
                    if (schService != NULL)
                    {
                        QueryServiceStatus(schService, &ssStatus);
                        if (ssStatus.dwCurrentState == (DWORD) iRunningStatus)
                        {
                            switch (iServiceControl)
                            {
                            case SERVICE_CONTROL_STOP:
                                dwCleanupControl = 0;   // 0 means start the service
                                break;

                            case SERVICE_CONTROL_PAUSE:
                                dwCleanupControl = SERVICE_CONTROL_CONTINUE;
                                break;
                            }

                            _itot(iServiceControl, szControl, 10);
                            _ultot(dwCleanupControl, szCleanupControl, 10);

                            WritePrivateProfileString(TEXT_SERVICE_STATUS_SECTION,
                                                        szServiceName,
                                                        szControl,
                                                        g_szToDoINFFileName);

                            WritePrivateProfileString(TEXT_SERVICE_STATUS_CLEANUP_SECTION,
                                                        szServiceName,
                                                        szCleanupControl,
                                                        g_szToDoINFFileName);
                        }

                        CloseServiceHandle(schService);
                    }
                }
            }
        }

        CloseServiceHandle(schSCManager);
    }
    else
    {
        bRet = FALSE;
    }

    hr = (bRet == TRUE ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   AnalyzeServicesStartUp
//
//  Descrip:    Analyze services startup type. Some components in the system
//              need to be stopped and not to start automatically until 
//              upgraded to .NET server. So, we might need to change those
//              services to "Manually Start".
//              Change the Service Start Type, there are following type availabe now
//              SERVICE_AUTO_START
//              SERVICE_BOOT_START
//              SERVICE_DEMAND_START
//              SERVICE_DISABLED
//              SERVICE_SYSTEM_START
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    09/07/2002 rerkboos created
//
//  Notes:      Format of the section in clmt.inf:
//              <service name>, <current start type in system>, <new start type>
//
//-----------------------------------------------------------------------
HRESULT AnalyzeServicesStartUp(
    HINF    hInf,
    LPCTSTR lpInfSection
)
{
    HRESULT    hr = S_OK;
    BOOL       bRet = TRUE;
    LONG       lLineCount;
    LONG       lLineIndex;
    INFCONTEXT context;
    WCHAR      szServiceName[64];
    WCHAR      szCurrentStartupType[8];
    WCHAR      szNewStartupType[8];
    INT        iCurrentStartupType;
    INT        iNewStartupType;
    DWORD      dwBytesNeeded;
    SC_HANDLE      schService;
    SC_HANDLE      schSCManager;
    SERVICE_STATUS ssStatus;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;

    if (hInf == INVALID_HANDLE_VALUE)
    {
        return E_INVALIDARG;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager != NULL)
    {
        lLineCount = SetupGetLineCount(hInf, lpInfSection);
        for (lLineIndex = 0 ; lLineIndex < lLineCount && bRet ; lLineIndex++)
        {
            bRet = SetupGetLineByIndex(hInf,
                                    lpInfSection,
                                    (DWORD) lLineIndex,
                                    &context);
            if (bRet)
            {
                bRet = SetupGetStringField(&context,
                                            1,
                                            szServiceName,
                                            ARRAYSIZE(szServiceName),
                                            NULL)
                        && SetupGetIntField(&context,
                                            2,
                                            &iCurrentStartupType)
                        && SetupGetIntField(&context,
                                            3,
                                            &iNewStartupType);
                if (bRet)
                {
                    schService = OpenService(schSCManager, szServiceName, SERVICE_QUERY_CONFIG);
                    if (schService != NULL)
                    {
                        lpqscBuf = (LPQUERY_SERVICE_CONFIG) MEMALLOC(4096);
                        if (lpqscBuf != NULL)
                        {
                            bRet = QueryServiceConfig(schService,
                                                    lpqscBuf,
                                                    4096,
                                                    &dwBytesNeeded);
                            if (bRet)
                            {
                                if (lpqscBuf->dwStartType == (DWORD) iCurrentStartupType)
                                {
                                    _itot(iCurrentStartupType, szCurrentStartupType, 10);
                                    _itot(iNewStartupType, szNewStartupType, 10);
                                    
                                    WritePrivateProfileString(TEXT_SERVICE_STARTUP_SECTION,
                                                            szServiceName,
                                                            szNewStartupType,
                                                            g_szToDoINFFileName);
                                    WritePrivateProfileString(TEXT_SERVICE_STARTUP_CLEANUP_SECTION,
                                                            szServiceName,
                                                            szCurrentStartupType,
                                                            g_szToDoINFFileName);
                                }
                            }

                            MEMFREE(lpqscBuf);
                        }
                        else
                        {
                            SetLastError(ERROR_OUTOFMEMORY);
                        }

                        CloseServiceHandle(schService);
                    }
                }
            }
        }

        CloseServiceHandle(schSCManager);
    }
    else
    {
        bRet = FALSE;
    }

    hr = (bRet == TRUE ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   ResetServicesStatus
//
//  Descrip:    Reset the services listed in specified section of INF
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    04/30/2002 rerkboos created
//              07/08/2002 rerkboos modified
//
//  Notes:      Format of the section in clmt.inf:
//              <service name to be stopped>, <action>
//
//-----------------------------------------------------------------------
HRESULT ResetServicesStatus(
    HINF    hInf,           // Handle to INF
    LPCTSTR lpInfSection    // Section to be read from INF
)
{
    HRESULT    hr = S_OK;
    BOOL       bRet = TRUE;
    LONG       lLineCount;
    LONG       lLineIndex;
    INFCONTEXT context;
    WCHAR      szServiceName[128];
    INT        iServiceControl;

    if (hInf == INVALID_HANDLE_VALUE || lpInfSection == NULL)
    {
        return E_INVALIDARG;
    }

    // Read the list of services to be reset from INF
    lLineCount = SetupGetLineCount(hInf, lpInfSection);
    for (lLineIndex = 0 ; lLineIndex < lLineCount && bRet ; lLineIndex++)
    {
        bRet = SetupGetLineByIndex(hInf,
                                    lpInfSection,
                                    (DWORD) lLineIndex,
                                    &context);
        if (bRet)
        {
            bRet = SetupGetStringField(&context,
                                       0,
                                       szServiceName,
                                       ARRAYSIZE(szServiceName),
                                       NULL)
                   && SetupGetIntField(&context,
                                       1,
                                       &iServiceControl);
            if (bRet)
            {
                hr = ResetServiceStatus(szServiceName,
                                        (DWORD) iServiceControl,
                                        10);
            }
        }
    }

    hr = (bRet == TRUE ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   ResetServicesStartUp
//
//  Descrip:    Reconfigure services start type. Some components in the system
//              need to be stopped and not to start automatically until 
//              upgraded to .NET server. So, we might need to change those
//              services to "Manually Start".
//              Change the Service Start Type, there are following type availabe now
//              SERVICE_AUTO_START 
//              SERVICE_BOOT_START 
//              SERVICE_DEMAND_START 
//              SERVICE_DISABLED 
//              SERVICE_SYSTEM_START 
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    04/30/2002 rerkboos created
//
//  Notes:      Format of the section in clmt.inf:
//              <service name>, <current start type in system>, <new start type>
//
//-----------------------------------------------------------------------
HRESULT ResetServicesStartUp(
    HINF    hInf,
    LPCTSTR lpInfSection
)
{
    HRESULT    hr = S_OK;
    BOOL       bRet = TRUE;
    LONG       lLineCount;
    LONG       lLineIndex;
    INFCONTEXT context;
    WCHAR      szServiceName[64];
    INT        iNewStartupType;

    if (hInf == INVALID_HANDLE_VALUE)
    {
        return E_INVALIDARG;
    }

    lLineCount = SetupGetLineCount(hInf, lpInfSection);
    for (lLineIndex = 0 ; lLineIndex < lLineCount && bRet ; lLineIndex++)
    {
        bRet = SetupGetLineByIndex(hInf,
                                   lpInfSection,
                                   (DWORD) lLineIndex,
                                   &context);
        if (bRet)
        {
            bRet = SetupGetStringField(&context,
                                       0,
                                       szServiceName,
                                       ARRAYSIZE(szServiceName),
                                       NULL)
                   && SetupGetIntField(&context,
                                       1,
                                       &iNewStartupType);
            if (bRet)
            {
                hr = ChangeServiceStartupType(szServiceName,
                                              iNewStartupType,
                                              10);
            }
        }
    }

    hr = (bRet == TRUE ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

    return hr;
}



HRESULT ChangeServiceStartupType(
    LPCTSTR lpServiceName,
    DWORD   dwNewStartupType,
    DWORD   dwMaxWait
) 
{ 
    SC_LOCK                     sclLock = NULL; 
    SERVICE_DESCRIPTION         sdBuf;
    DWORD                       dwBytesNeeded;
    DWORD                       dwStartType; 
    SC_HANDLE                   schSCManager = NULL;
    SC_HANDLE                   schService = NULL;
    DWORD                       dwErr = ERROR_SUCCESS;
    HRESULT                     hr = S_OK;
    DWORD                       dwCnt;
    BOOL                        bRet;
 
    if (lpServiceName == NULL)
    {
        return E_INVALIDARG;
    }

    schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS);
    if (!schSCManager)
    {
        dwErr = GetLastError();
        goto cleanup;
    } 
    
    // Need to acquire database lock before reconfiguring. 
    for(dwCnt = 0 ; dwCnt < dwMaxWait ; dwCnt++)
    {
        sclLock = LockServiceDatabase(schSCManager); 
        if (sclLock == NULL) 
        { 
            // Exit if the database is not locked by another process. 
            dwErr = GetLastError();
            if (dwErr != ERROR_SERVICE_DATABASE_LOCKED) 
            {
                goto cleanup;
            }
            else
            {
                Sleep(1000);
            }
        }
        else
        {
            break;
        } 
    }

    if (sclLock != NULL)
    {
        // The database is locked, so it is safe to make changes. 
        // Open a handle to the service. 
        schService = OpenService(schSCManager,           // SCManager database 
                                lpServiceName,          // name of service 
                                SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG );
        if (schService != NULL) 
        {
            // Make the changes
            bRet = ChangeServiceConfig(schService,          // handle of service 
                                    SERVICE_NO_CHANGE,   // service type: no change 
                                    dwNewStartupType,    // change service start type 
                                    SERVICE_NO_CHANGE,   // error control: no change 
                                    NULL,                // binary path: no change 
                                    NULL,                // load order group: no change 
                                    NULL,                // tag ID: no change 
                                    NULL,                // dependencies: no change 
                                    NULL,                // account name: no change 
                                    NULL,                // password: no change 
                                    NULL);               // display name: no change
            if (!bRet)
            {
                dwErr = GetLastError();
            }

            CloseServiceHandle(schService);
        }
        else
        {
            dwErr = GetLastError();
        }

        UnlockServiceDatabase(sclLock);
    }

    hr = S_OK;

cleanup:

    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    if (schSCManager)
    {
        CloseServiceHandle(schSCManager);
    }

    return hr;
} 



BOOL   LnkFileUpdate(LPTSTR lpszFile)
{
    HRESULT hr ;
    hr = AddNeedUpdateLnkFile(lpszFile,&g_StrReplaceTable );
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL SecTempUpdate(LPTSTR lpszFile)
{
    HRESULT hr ;
    hr = UpdateSecurityTemplates(lpszFile,&g_StrReplaceTable );
    if (SUCCEEDED(hr))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//-----------------------------------------------------------------------
//
//  Function:   ResetServiceStatus
//
//  Descrip:    Reset the running (start/pause/stop) status of 
//              the specified service
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    07/09/2002 rerkboos created
//
//  Notes:      Format of the section in clmt.inf:
//              <service name>, <control>
//
//-----------------------------------------------------------------------
HRESULT ResetServiceStatus(
    LPCTSTR lpServiceName,      // Service name
    DWORD   dwControl,          // Control for the specified service
    DWORD   dwMaxWait           // Timeout in seconds
)
{
    HRESULT        hr = E_FAIL;
    BOOL           bRet = FALSE;
    SC_HANDLE      schService;
    SC_HANDLE      schSCManager;
    SERVICE_STATUS ssStatus;
    DWORD          dwSec;
    DWORD          dwFinalStatus;

    switch (dwControl)
    {
    case SERVICE_CONTROL_CONTINUE:
        dwFinalStatus = SERVICE_RUNNING;
        break;

    case SERVICE_CONTROL_PAUSE:
        dwFinalStatus = SERVICE_PAUSED;
        break;

    case SERVICE_CONTROL_STOP:
        dwFinalStatus = SERVICE_STOPPED;
        break;
        
    case 0: // Start service
        dwFinalStatus = SERVICE_RUNNING;
        break;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager != NULL)
    {
        schService = OpenService(schSCManager, lpServiceName, SERVICE_ALL_ACCESS);
        if (schService != NULL)
        {
            if (dwControl == 0)
            {
                // Start service
                bRet = StartService(schService, 0, NULL);
            }
            else
            {
                // Continue, Pause, Stop service
                bRet = ControlService(schService, dwControl, &ssStatus);
            }

            if (bRet)
            {
                dwSec = 0;
                hr = S_FALSE;

                while (QueryServiceStatus(schService, &ssStatus)
                       && dwSec < dwMaxWait)
                {
                    if (ssStatus.dwCurrentState != dwFinalStatus)
                    {
                        Sleep(1000);
                        dwSec++;
                    }
                    else
                    {
                        hr = S_OK;
                        break;
                    }
                }

                if (hr != S_OK)
                {
                    DPF(APPwar, 
                        TEXT("  Warning! - [%s] service status cannot change from %d to %d\n"),
                        lpServiceName,
                        ssStatus.dwCurrentState,
                        dwFinalStatus);
                }
            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }

    if (FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



HRESULT FinalUpdateRegForUser(HKEY hKeyUser, 
                           LPTSTR UserName, 
                           LPTSTR DomainName,
                           LPTSTR UserSid)
{
    RegUpdate(g_hInfDoItem, hKeyUser, UserSid);
    return S_OK;
}

/*++

Routine Description:

    This routine does the per user registry search and replace, the string replace table 
    is in global variable g_StrReplaceTable

Arguments:

    hKeyUser - user registry key handle
    UserName - user name that hKeyUser belongs to 
    DomainName  - domain name the UserName belongs to 
Return Value:

    NULL
--*/
HRESULT   UpdateRegPerUser       (HKEY hKeyUser, 
                              LPTSTR UserName, 
                              LPTSTR DomainName,
                              LPTSTR UserSid)
{
    return RegistryAnalyze(hKeyUser,UserName,UserSid,&g_StrReplaceTable,NULL,0,NULL,TRUE);
}




HRESULT UpdateDSObjProp(
    HINF    hInf,
    LPTSTR lpInfSection)
{
#define DSOBJNUMOFFIELD   3
    DWORD       dwFileValid[DSOBJNUMOFFIELD] = {1,1,1};
    DWORD       arrSizeNeeded[DSOBJNUMOFFIELD];
    LPTSTR      lpField[DSOBJNUMOFFIELD];
    UINT        LineCount,LineNo;
    INFCONTEXT  InfContext;
    HRESULT     hr;
    int         i;

    for ( i = 0; i < DSOBJNUMOFFIELD; i++)
    {
        lpField[i] = NULL;
    }
    hr = GetMaxLenEachField(hInf,lpInfSection,FALSE,DSOBJNUMOFFIELD,DSOBJNUMOFFIELD,
                                (PDWORD)dwFileValid,arrSizeNeeded,FALSE);
   
    if (hr != S_OK)
    {
        goto cleanup;
    }
    for (i = 0; i < DSOBJNUMOFFIELD; i++)
    {
        if (!(lpField[i] = malloc(arrSizeNeeded[i]*sizeof(TCHAR))))
        {
            goto cleanup;
        }
    }
    LineCount = (UINT)SetupGetLineCount(hInf,lpInfSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        goto cleanup;
    }

    //Scan the INF file section to get the max buf required for each field
    for (LineNo = 0; LineNo < LineCount; LineNo++)
    {
        if (!SetupGetLineByIndex(hInf,lpInfSection,LineNo,&InfContext))
        {
            DPF(INFwar ,TEXT("can not get line %d of section %s !"),LineNo, lpInfSection);            
            continue;
        }
        for (i = 1; i <= DSOBJNUMOFFIELD; i++)
        {
            SetupGetStringField(&InfContext,i,lpField[i-1],arrSizeNeeded[i-1],NULL);
        }
        PropertyValueHelper( lpField[0],lpField[1],NULL,lpField[2]);
    }
    hr =S_OK;
cleanup:
    for (i = 0; i < DSOBJNUMOFFIELD; i++)
    {
        FreePointer(lpField[i]);
    }
    return hr;

}



void DoServicesAnalyze()
{
    AnalyzeServicesStatus(g_hInf, TEXT_SERVICE_STATUS_SECTION);
    AnalyzeServicesStartUp(g_hInf, TEXT_SERVICE_STARTUP_SECTION);
}



HRESULT INFVerifyHardLink(
    HINF    hInf,
    LPTSTR  lpszSection)
{
    HRESULT         hr;
    INT             LineCount,LineNo,nFieldIndex;
    INFCONTEXT      InfContext;
    TCHAR           szFileName[MAX_PATH+1],szExistingFileName[MAX_PATH+1],szCurrLink[MAX_PATH];
    TCHAR           lpszInf[MAX_PATH+1];
    HINF            hMyInf;
    
    //check the INF file handle
    hMyInf = hInf;
    if(hMyInf == INVALID_HANDLE_VALUE) 
    {   
        hr = EnsureDoItemInfFile(lpszInf,ARRAYSIZE(lpszInf));
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        hMyInf = SetupOpenInfFile(lpszInf,
                                  NULL,
                                  INF_STYLE_WIN4,
                                  NULL);
        if (hMyInf == INVALID_HANDLE_VALUE)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    LineCount = (UINT)SetupGetLineCount(hMyInf,lpszSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        goto Cleanup;
    }
    for (LineNo = 0 ; LineNo < LineCount; LineNo++)
    {
        BOOL b1,b2,b3,b4;

        if (!SetupGetLineByIndex(hMyInf,lpszSection,LineNo,&InfContext))
        {
            continue;
        }
        b2 = SetupGetStringField(&InfContext,2,szFileName,ARRAYSIZE(szFileName),NULL);
        b3 = SetupGetStringField(&InfContext,3,szExistingFileName,ARRAYSIZE(szExistingFileName),NULL);
        if (!b2 || !b3)
        {
            continue;
        }
        if (GetSymbolicLink(szFileName,szCurrLink,ARRAYSIZE(szCurrLink)))
        {
            if (!IsDirExisting(szCurrLink))
            {
                RemoveDirectory(szFileName);
            }
        }        
    }
    hr  = S_OK;
Cleanup:
    if ( (hInf == INVALID_HANDLE_VALUE) && (hMyInf != INVALID_HANDLE_VALUE) )
    {
        SetupCloseInfFile(hMyInf);        
    }
    return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\log.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Log debug information.

Author:

    Geoffrey Guo (geoffguo) 27-Sep-2001  Created

Revision History:

    <alias> <date> <comments>

--*/
#include "StdAfx.h"
#include "clmt.h"

void MyDbgPrint (LPWSTR lpwStr);

BOOL       g_bDbgPrintEnabled;
DEBUGLEVEL g_DebugLevel;
DWORD      g_DebugArea;

//Log file
FILE      *pLogFile;


void
DebugPrintfEx(
DWORD  dwDetail,
LPWSTR pszFmt,
...
)
/*++
    Return: void

    Desc:   This function prints debug spew in the debugger and log file.
--*/
{
    WCHAR   szT[1024];
    va_list arglist;
    int     len;
    DWORD   dwLevel, dwArea;
    HRESULT hr;

    dwLevel = dwDetail & 0x0F;
    dwArea = dwDetail & 0xF0;

    if (dwLevel == dlNone ||
       (dwArea != g_DebugArea && g_DebugArea != DEBUG_ALL))
        return;

    va_start(arglist, pszFmt);
    // we do not need check the StringCbVPrintf return value,
    // we just print whatever szT size allowed, if more data there
    // it will be truncated 
    hr = StringCbVPrintf(szT, ARRAYSIZE(szT), pszFmt, arglist);
    szT[1022] = 0;
    va_end(arglist);

    
    //
    // Make sure we have a '\n' at the end of the string
    //
    len = lstrlen(szT);

    if (szT[len - 1] != L'\n')  
    {
        hr = StringCchCopy((LPTSTR)(szT + len), sizeof(szT)/sizeof(TCHAR)-len, L"\r\n");
        if (FAILED(hr))
        {
            //BUGBUG:what about if we fail here
        }
    }

    if (dwLevel <= (DWORD)g_DebugLevel) {
        switch (dwLevel) {
        case dlPrint:
            MyDbgPrint(L"[MSG] ");
            g_LogReport.dwMsgNum++;
            break;

        case dlFail:
            MyDbgPrint(L"[FAIL] ");
            g_LogReport.dwFailNum++;
            break;

        case dlError:
            MyDbgPrint(L"[ERROR] ");
            g_LogReport.dwErrNum++;
            break;

        case dlWarning:
            MyDbgPrint(L"[WARN] ");
            g_LogReport.dwWarNum++;
            break;

        case dlInfo:
            MyDbgPrint(L"[INFO] ");
            g_LogReport.dwInfNum++;
            break;
        }

        MyDbgPrint(szT);
    }
}

void
MyDbgPrint (LPWSTR lpwStr)
{
    if (g_bDbgPrintEnabled)
        OutputDebugString (lpwStr);
    if (pLogFile)
    {
        fputws (lpwStr, pLogFile);
        fflush (pLogFile);
    }
}

void
SetDebugLevel (LPTSTR lpLevel)
{
    switch (*lpLevel) {
    case L'1':
        g_DebugLevel = dlPrint;
        break;

    case L'2':
        g_DebugLevel = dlFail;
        break;

    case L'3':
        g_DebugLevel = dlError;
        break;

    case L'4':
        g_DebugLevel = dlWarning;
        break;

    case L'5':
        g_DebugLevel = dlInfo;
        break;

    case L'0':
    default:
        g_DebugLevel = dlNone;
        g_bDbgPrintEnabled = FALSE;
        break;
    }
}

HRESULT
InitDebugSupport(DWORD dwMode)
/*++
    Return: 

    Desc:   This function initializes g_bDbgPrintEnabled based on an env variable.
--*/
{
    DWORD           dwNum;
    WCHAR           wszEnvValue[MAX_PATH+1];
    WCHAR           UnicodeFlag[2] = {0xFEFF, 0x0};
    HRESULT         hr;

    dwNum = GetSystemWindowsDirectory(wszEnvValue,ARRAYSIZE(wszEnvValue));
    if (!dwNum ||(dwNum >= ARRAYSIZE(wszEnvValue)))
    {
        return E_FAIL;
    }

    hr = StringCbCat(wszEnvValue, sizeof(wszEnvValue), LOG_FILE_NAME);
    if (FAILED(hr))
    {
        return hr;
    }
    pLogFile = _wfopen (wszEnvValue, L"a+b");
    if (pLogFile)
    {
        fputws (UnicodeFlag, pLogFile);
    }
    else
    {
        return E_FAIL;
    }

    dwNum = GetEnvironmentVariableW(L"CLMT_DEBUG_LEVEL", wszEnvValue, 3);

    g_bDbgPrintEnabled = TRUE;
    g_DebugLevel = dlError;
    g_DebugArea = DEBUG_ALL;

    g_LogReport.dwMsgNum = 0;
    g_LogReport.dwFailNum = 0;
    g_LogReport.dwErrNum = 0;
    g_LogReport.dwWarNum = 0;
    g_LogReport.dwInfNum = 0;

    if (dwNum == 1) 
    {
        SetDebugLevel(&wszEnvValue[0]);
    } 
    else if (dwNum == 2)
    {
        switch (wszEnvValue[0]) {
        case L'A':
        case L'a':
            g_DebugArea = DEBUG_APPLICATION;
            break;

        case L'I':
        case L'i':
            g_DebugArea = DEBUG_INF_FILE;
            break;

        case L'P':
        case L'p':
            g_DebugArea = DEBUG_PROFILE;
            break;

        case L'R':
        case L'r':
            g_DebugArea = DEBUG_REGISTRY;
            break;

        case L'S':
        case L's':
            g_DebugArea = DEBUG_SHELL;
            break;

        default:
            g_DebugArea = DEBUG_ALL;
            break;
        }

        SetDebugLevel(&wszEnvValue[1]);
    }
    return S_OK;
}

void
CloseDebug (void)
{
    if (pLogFile)
        fclose (pLogFile);
}


//-----------------------------------------------------------------------
//
//  Function:   InitChangeLog
//
//  Descrip:    Initialize the change log file. The change log contains
//              the information about files, folders and services that
//              have been changed by CLMT. The log will be displayed to
//              user later.
//
//  Returns:    S_OK if function succeeded.
//              S_FALSE if source directory does not exist
//              else if error occured
//
//  Notes:      none
//
//  History:    05/02/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT InitChangeLog(VOID)
{
#define     TEXT_CHANGE_LOG_FILE        TEXT("CLMTchg.log")

    HRESULT hr;
    WCHAR   szWindir[MAX_PATH];
    HANDLE  hFile;

    // Get CLMT backup directory
    if (GetSystemWindowsDirectory(szWindir, ARRAYSIZE(szWindir)) != 0)
    {
        hr = StringCchPrintf(g_szChangeLog,
                             ARRAYSIZE(g_szChangeLog),
                             TEXT("%s\\%s\\%s"),
                             szWindir,
                             CLMT_BACKUP_DIR,
                             TEXT_CHANGE_LOG_FILE);
        if (SUCCEEDED(hr))
        {
            // Create a change log file, always overwrite the old one
            hFile = CreateFile(g_szChangeLog,
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                CloseHandle(hFile);
                hr = S_OK;
                g_dwIndex = 0;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   AddFileChangeLog
//
//  Descrip:    Add the File/Folder changes into Change log
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    05/02/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT AddFileChangeLog(
    DWORD   dwType,
    LPCTSTR lpOldFile,
    LPCTSTR lpNewFile
)
{
    HRESULT hr;
    BOOL    bRet;
    LPTSTR  lpChangedItem;
    DWORD   cchChangedItem;
    TCHAR   szIndex[8];

    // Alloc enough memory for the change list
    cchChangedItem = lstrlen(lpOldFile) + lstrlen(lpNewFile) + 8;
    lpChangedItem = (LPWSTR) MEMALLOC(cchChangedItem * sizeof(TCHAR));

    if (lpChangedItem == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = StringCchPrintf(lpChangedItem,
                         cchChangedItem,
                         TEXT("\"%s\", \"%s\""),
                         lpOldFile,
                         lpNewFile);
    if (SUCCEEDED(hr))
    {
        _ultot(g_dwIndex, szIndex, 10);

        switch (dwType)
        {
        case TYPE_FILE_MOVE:
        case TYPE_SFPFILE_MOVE:
            // Log the change into Change Log file
            bRet = WritePrivateProfileString(TEXT("Files"),
                                             szIndex,
                                             lpChangedItem,
                                             g_szChangeLog);
            break;

        case TYPE_DIR_MOVE:
            bRet = WritePrivateProfileString(TEXT("Directories"),
                                             szIndex,
                                             lpChangedItem,
                                             g_szChangeLog);
            break;
        }

        g_dwIndex++;
    }

    if (lpChangedItem)
    {
        MEMFREE(lpChangedItem);
    }
                              
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   AddServiceChangeLog
//
//  Descrip:    Add the Servicer changes into Change log
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    05/02/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT AddServiceChangeLog(
    LPCTSTR lpServiceName,
    DWORD   dwBefore,
    DWORD   dwAfter
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    TCHAR   szBefore[12];
    TCHAR   szAfter[12];
    LPWSTR  lpChangedItem;
    DWORD   cchChangedItem;

    _ultot(dwBefore, szBefore, 16);
    _ultot(dwAfter, szAfter, 16);

    cchChangedItem = 11 + 11 + 3;
    lpChangedItem = (LPWSTR) MEMALLOC(cchChangedItem * sizeof (TCHAR));

    if (lpChangedItem)
    {
        hr = StringCchPrintf(lpChangedItem,
                             cchChangedItem,
                             TEXT("0x%.8x, 0x%.8x"),
                             dwBefore,
                             dwAfter);
        if (SUCCEEDED(hr))
        {
            bRet = WritePrivateProfileString(TEXT("Services"),
                                             lpServiceName,
                                             lpChangedItem,
                                             g_szChangeLog);
        }

        MEMFREE(lpChangedItem);
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   AddUserNameChangeLog
//
//  Descrip:    Add the User name changes into Change log
//
//  Returns:    S_OK if function succeeded.
//              else if error occured
//
//  Notes:      none
//
//  History:    05/02/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT AddUserNameChangeLog(
    LPCTSTR lpOldUserName,
    LPCTSTR lpNewUserName
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;

    bRet = WritePrivateProfileString(TEXT("UserName"),
                                     lpNewUserName,
                                     lpOldUserName,
                                     g_szChangeLog);
    if (!bRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   GetUserNameChangeLog
//
//  Descrip:    Get the User name changes from Change log
//
//  Returns:    TRUE if change log for new user name is found
//              FALSE, otherwise
//
//  Notes:      none
//
//  History:    05/29/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL GetUserNameChangeLog(
    LPCTSTR lpNewUserName,
    LPTSTR  lpOldUserName,
    DWORD   cchOldUserName
)
{
    BOOL    bRet = FALSE;
    DWORD   dwCopied;

    dwCopied = GetPrivateProfileString(TEXT("UserName"),
                                       lpNewUserName,
                                       TEXT(""),
                                       lpOldUserName,
                                       cchOldUserName,
                                       g_szChangeLog);
    if (dwCopied > 0)
    {
        bRet = TRUE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\loopuser.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    loopuser.c

Abstract:

    Loop each user and call ApplyUserSettings with user profile.

Author:

    Geoffrey Guo (geoffguo) 22-Sep-2001  Created

Revision History:

    <alias> <date> <comments>

--*/
#include "StdAfx.h"
#include "clmt.h"


TOKEN_PRIVILEGES     PrevTokenPriv;

//--------------------------------------------------------------------------
//
//  LoopUser
//
//  Enumerate users and call ApplyUserSettings with user profile.
//  
//
//--------------------------------------------------------------------------
BOOL LoopUser(USERENUMPROC lpUserEnumProc)
{
    BOOL     fRet = TRUE;
    TCHAR    UserSid[MAX_PATH];
    DWORD    ValueType   = 0;
    DWORD    cbUserSid   = 0;
    DWORD    cbValueType = 0;
    LONG     lRet;
    HKEY     hKey;
    PTCHAR   ptr = NULL;
    FILETIME ft;
    TCHAR    szSysDrv[3];
    HRESULT  hr;
    TCHAR   szDomainUserName[MAX_PATH];
    
    DPF (REGmsg, L"Enter LoopUser: ");

    if (ExpandEnvironmentStrings(L"%SystemDrive%", 
                              szSysDrv, 
                              sizeof(szSysDrv) / sizeof(TCHAR)) > 3)
    {
        fRet = FALSE;
        DPF (REGerr, L"LoopUser: Incorrect SystemDrive: %s", szSysDrv);
        goto Exit;
    }

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       g_cszProfileList,
                       0,
                       KEY_READ,
                       &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        DWORD dwIndex = 0;

        //
        // Enumerate and get the Sids for each user.
        //

        while ( TRUE )
        {
            *UserSid  = 0;
            cbUserSid = sizeof(UserSid)/sizeof(TCHAR);

            lRet = RegEnumKeyEx( hKey,
                               dwIndex,
                               UserSid,
                               &cbUserSid,
                               0,
                               NULL,
                               0,
                               &ft);
            if (lRet != ERROR_SUCCESS)
            {
                if (lRet != ERROR_NO_MORE_ITEMS)
                {
                    DPF (REGerr, L"LoopUser:  RegEnumKeyEx fails. lResult=%d", lRet);
                    fRet = FALSE;
                }
                
                break;
            }

            CharUpper( UserSid );

            //
            // User Process
            //

            if (cbUserSid > 0)
            {
                LONG  lLoadUser;
                HKEY  hKeyUser, hKeyEnv, hKeyProfileList;
                TCHAR UserProfilePath[MAX_PATH];
                TCHAR UserProfileHive[MAX_PATH];
                TCHAR UserName[MAX_PATH];
                TCHAR DomainName[MAX_PATH];
                DWORD UserNameLen = sizeof(UserName)/sizeof(TCHAR);
                DWORD DomainNameLen = sizeof(DomainName)/sizeof(TCHAR);
                DWORD cbUserProfilePath = 0;
                PSID  pSid = NULL;
                SID_NAME_USE sidUse;
                BOOL  bRet;

                ConvertStringSidToSid(UserSid,&pSid);
                if (!IsValidSid(pSid))
                {
                    DPF (REGmsg, L"LoopUser:  SID %s is not valid ", UserSid );
                    dwIndex++;
                    continue; 
                }
                bRet = LookupAccountSid( NULL, pSid, UserName, &UserNameLen,
                          DomainName, &DomainNameLen, &sidUse );
                
                if ( pSid )
                {
                     LocalFree ( pSid );
                     pSid = NULL;
                }
                
                if ( !bRet )
                {
                     DWORD dwErr = GetLastError();
                     if (ERROR_NONE_MAPPED == dwErr)
                     {
                        dwIndex++;
                        continue; 
                     }
                     else
                     {
                        DPF (REGerr, L"LoopUser:   LookupAccountSid fails for %s with win32 error = %d", UserSid,dwErr);
                        fRet = FALSE;
                        break;
                     }
                }

                lRet = RegOpenKeyEx( hKey,
                                      UserSid,
                                      0,
                                      KEY_READ,
                                      &hKeyProfileList );
                
                if ( lRet == ERROR_SUCCESS )
                {
                     DWORD Type;

                     cbUserProfilePath = sizeof( UserProfilePath );

                     lRet = RegQueryValueEx( hKeyProfileList,
                                              g_cszProfileImagePath,
                                              NULL,
                                              &Type,
                                              (PBYTE)UserProfilePath,
                                              &cbUserProfilePath );

                     RegCloseKey( hKeyProfileList );

                     if ( lRet != ERROR_SUCCESS )
                     {
                         DPF (REGerr, L"LoopUser:  RegQueryValueEx fails. lResult=%d", lRet);
                         fRet = FALSE;
                         dwIndex++;
                         continue; 
                     }
                }
                else
                {
                    DPF (REGerr, L"LoopUser:  RegOpenKeyEx fails. lResult=%d", lRet);
                    fRet = FALSE;
                    dwIndex++;
                    continue; 
                }
               
                lRet = RegOpenKeyEx( HKEY_USERS,
                          UserSid,
                          0,
                          KEY_ALL_ACCESS,
                          &hKeyUser);
                
                lLoadUser = ERROR_FILE_NOT_FOUND;

                if (lRet == ERROR_FILE_NOT_FOUND) 
                {
                     //
                     // Create NTUSER.Dat path from the user profile path
                     //

                     if (ExpandEnvironmentStrings( UserProfilePath, 
                                          UserProfileHive, 
                                          sizeof(UserProfileHive) / sizeof(TCHAR)) > MAX_PATH)
                     {
                         DPF (REGerr, L"LoopUser: Incorrect UserProfile %s", UserProfileHive);
                         fRet = FALSE;
                         goto Exit;
                     }

                     if (UserProfileHive[0] != szSysDrv[0])
                     {
                        DPF (REGwar, L"LoopUser: UserProfilePath=%s is not in System Drive, skipped.", UserProfileHive);
                        dwIndex++;
                        continue; 
                     }

                     if (FAILED(StringCchCopy(UserProfilePath, MAX_PATH, UserProfileHive)))
                     {
                         DPF (REGerr, L"LoopUser: UserProfilePath too samll for  %s", UserProfileHive);
                         fRet = FALSE;
                         goto Exit;
                     }
                     if (FAILED(StringCchCat(UserProfileHive, MAX_PATH, TEXT("\\NTUSER.DAT"))))
                     {
                         DPF (REGerr, L"LoopUser: UserProfilePath too samll for  %s", UserProfileHive);
                         fRet = FALSE;
                         goto Exit;
                     }

                     // load the hive
                     // Note: if the specified hive is already loaded
                     // this call will return ERROR_SHARING_VIOLATION
                     // We don't worry about this because if the 
                     // hive were loaded, we shouldn't be here
                     lLoadUser = RegLoadKey(HKEY_USERS, UserSid, UserProfileHive);

                     if ( lLoadUser != ERROR_SUCCESS )
                     {
                         DPF (REGerr, L"LoopUser:  RegLoadKey fails. lResult=%d", lLoadUser);
                         fRet = FALSE;
                         dwIndex++;
                         continue; 
                     }

                     lRet = RegOpenKeyEx( HKEY_USERS,
                                          UserSid,
                                          0,
                                          KEY_ALL_ACCESS,
                                          &hKeyUser);
                }
                else if (lRet != ERROR_SUCCESS)
                {
                    DPF (REGerr, L"LoopUser:  RegOpenKeyEx fails. lResult=%d", lRet);
                    fRet = FALSE;
                }
                
                // give Call back function a chance to excute
                if (DomainName[0] != TEXT('\0'))
                {
                    hr = StringCchCopy(szDomainUserName,
                                       ARRAYSIZE(szDomainUserName),
                                       DomainName);
                    if (SUCCEEDED(hr))
                    {
                        hr = StringCchCat(szDomainUserName,
                                          ARRAYSIZE(szDomainUserName),
                                          TEXT("\\"));
                        hr = StringCchCat(szDomainUserName,
                                          ARRAYSIZE(szDomainUserName),
                                          UserName);
                        if (FAILED(hr))
                        {
                            hr = StringCchCopy(szDomainUserName,
                                               ARRAYSIZE(szDomainUserName),
                                               UserName);
                        }
                    }
                }

                hr = lpUserEnumProc(hKeyUser, szDomainUserName, DomainName,UserSid);
                if (FAILED(hr))
                {
                    fRet = FALSE;
                }                  

                RegCloseKey( hKeyUser );
                if ( lLoadUser == ERROR_SUCCESS )
                     RegUnLoadKey(HKEY_USERS, UserSid);
            }

            dwIndex++;
        }

        RegCloseKey( hKey );
    }
    else
    {
        DPF (REGerr, L"LoopUser:  Open profile list fails. lResult=%d", lRet);
        fRet = FALSE;
        goto Exit;
    }

    // For Default User Setting
    // Note the assumption here is the default user name is not localized
    if (fRet)
    {
        lRet = RegOpenKeyEx(HKEY_USERS,
                            _T(".DEFAULT"),
                            0,
                            KEY_ALL_ACCESS,
                            &hKey);
    
        if (lRet != ERROR_SUCCESS)
        {
            DPF (REGerr, L"LoopUser:  Open Default User key fails. lResult=%d", lRet);
            fRet = FALSE;
            goto Exit;
        }

        hr = lpUserEnumProc(hKey, DEFAULT_USER, NULL,TEXT("Default_User_SID"));
        if (FAILED(hr))
        {
            fRet = FALSE;
        }                  
        RegCloseKey( hKey );
    }

Exit:
    DPF (REGmsg, L"Exit LoopUser with return %d", fRet);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\main.c ===
#include "StdAfx.h"
#include "clmt.h"
#include <shellapi.h>

#define CMD_ERR_CONFLICT_OPERATION          1

const TCHAR *pstrUsage[] =
{
    _T("Cross Language Migration Tool:\n\n"),
    _T("CLMT           start running the tool.\n"),
    _T("CLMT /Cure     Use this option if an application fails to start after running \n"),
    _T("               CLMT, and you want the fix to apply to all user and group \n"),
    _T("               profiles on this machine. This option creates reparse points \n"),
    _T("               between all localized and English folders that have been \n"),
    _T("               converted to English by this tool.  It can only be used on \n"),
    _T("               NTFS file systems.\n"),
    _T("               Please see the Readme.txt file for more information.\n"),    
    NULL
};




void Usage()
{
    register i = 0;
    while (pstrUsage[i] != NULL)
    {
        _ftprintf(stderr, TEXT("%s"), pstrUsage[i++]);
    }
    fflush(stderr);
}


BOOL ProcessCommandLine(LPDWORD lpMode)
{
    LPTSTR* lplpArgv;
    LPTSTR* argv;
    INT     nArgc;
    DWORD   dwErr;
    BOOL    bRet = TRUE;

    lplpArgv = CommandLineToArgvW(GetCommandLine(), &nArgc);
    argv = lplpArgv;

    dwErr = 0;
    *lpMode = 0;

    while (--nArgc > 0 && ++argv)
    {
        if (argv[0][0] != TEXT('/'))
        {
            bRet = FALSE;
            break;
        }
        if (MyStrCmpI(&argv[0][1], TEXT("NOWINNT32")) == 0)
        {
            //
            // This is "/NOWINNT32" parameters
            // Will not run Winnt32 Checkupgrade option
            //
            g_fRunWinnt32 = FALSE;
        }
        else if (MyStrCmpI(&argv[0][1], TEXT("cure")) == 0)
        {
            //
            // This is "/Cure" parameters
            //

            if (*lpMode > 0)
            {
                dwErr = CMD_ERR_CONFLICT_OPERATION;
                break;
            }

            *lpMode = CLMT_CURE_PROGRAM_FILES;
        }
        else if (MyStrCmpI(&argv[0][1], TEXT("cureall")) == 0)
        {
            //
            // This is "/Cureall" parameters
            //

            if (*lpMode > 0)
            {
                dwErr = CMD_ERR_CONFLICT_OPERATION;
                break;
            }

            *lpMode = CLMT_CURE_ALL;
        }
        else if (MyStrCmpI(&argv[0][1], TEXT("NoAppChk")) == 0)
        {
            //
            // This is "/NoAppChk" parameters
            //
            g_fNoAppChk = TRUE;
        }
        else if (MyStrCmpI(&argv[0][1], TEXT("reminder")) == 0)
        {
            //
            // This is "/reminder" parameters
            //

            if (*lpMode > 0)
            {
                dwErr = CMD_ERR_CONFLICT_OPERATION;
                break;
            }

            *lpMode = CLMT_REMINDER;
        }
        else if (MyStrCmpI(&argv[0][1], TEXT("INF")) == 0)
        {
            //
            // This is "/INF <inf file>" parameters
            // Tell the tool to use user-supply CLMT.INF
            //
            nArgc--;

            if (nArgc <= 0)
            {
                bRet = FALSE;
                break;
            }
            else
            {
                argv++;

                if (argv[0][0] == TEXT('/'))
                {
                    // next argument is not file name
                    bRet = FALSE;
                    break;
                }
                else
                {
                    if (FAILED(StringCchCopy(g_szInfFile, ARRAYSIZE(g_szInfFile), argv[0])))
                    {
                        bRet = FALSE;
                        break;
                    }

                    g_fUseInf = TRUE;
                }
            }
        }
        else if (MyStrCmpI(&argv[0][1], TEXT("final")) == 0)
        {
            //
            // This is "/final" parameters
            //

            if (*lpMode > 0)
            {
                if (*lpMode == CLMT_CURE_PROGRAM_FILES)
                {
                    *lpMode = CLMT_CURE_AND_CLEANUP;
                }
                else
                {
                    dwErr = CMD_ERR_CONFLICT_OPERATION;
                    break;
                }
            }
            else
            {
                *lpMode = CLMT_CLEANUP_AFTER_UPGRADE;
            }
        }
        else
        {
            bRet = FALSE;
            break;
        }
    }

    GlobalFree(lplpArgv);

    if (*lpMode == 0 && bRet == TRUE)
    {
        //
        // No switch is specified, we assume this is a DOMIG operation
        //

        *lpMode = CLMT_DOMIG;
    }

    if (dwErr == CMD_ERR_CONFLICT_OPERATION)
    {
        _ftprintf(stderr, TEXT("Only one operation can be specified in command line!\n\n"));
        bRet = FALSE;
    }

    return bRet;
}





int __cdecl _tmain()
{
    DWORD dwStatus;

    // Set locale for run-time functions (user-default code page)
    _tsetlocale(LC_ALL, TEXT(""));

    SetConsoleCtrlHandler(NULL,TRUE);

    if (ProcessCommandLine(&dwStatus))
    {
        g_dwRunningStatus = dwStatus;
        return DoMig(dwStatus);
    }
    else
    {
        Usage();
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\outlook.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Outlook.cpp

Abstract:

    Replace the path in Outlook private data.

Author:

    Geoffrey Guo (geoffguo) 1-Jul-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#define NOT_USE_SAFE_STRING  
#include "clmt.h"
#define STRSAFE_LIB
#include <strsafe.h>

#define OUTLOOK_VALUENAME TEXT("01020fff")

//-----------------------------------------------------------------------//
//
// ReplaceOutlookPSTPath()
//
// DESCRIPTION:
// Replace Outlook PST data file path
//
// lpDataIn:      Input data buffer
// dwcbInSize:    Input data size
// lpDataOut:     Output data buffer
// lpcbOutSize:   Output data size
// lpRegStr:      Input parameter structure
//-----------------------------------------------------------------------//
LONG ReplaceOutlookPSTPath (
LPBYTE              lpDataIn,
DWORD               dwcbInSize,
LPBYTE             *lpDataOut,
LPDWORD             lpcbOutSize,
PREG_STRING_REPLACE lpRegStr)
{
    LONG    lRet = ERROR_INVALID_PARAMETER;
	DWORD   dwSize, dwAttrib, dwHeadSize;
    LPWSTR  lpWideInputBuf = NULL;
    LPWSTR  lpWideOutputBuf = NULL;
    int     j;

    // Check if path contains ".pst"
    if (MyStrCmpIA((LPSTR)(lpDataIn + dwcbInSize - 5), ".pst") != 0)
        goto Cleanup;

    // Since EntryID's format is 0x.......00 00 (this is last part of GUID) 00 (followed by path)
    // Search from back for the beginning of path
    for (j = dwcbInSize - 1; j--; (j> 0))
    {
        if ( (lpDataIn[j] == (BYTE)0) && (lpDataIn[j-1] == (BYTE)0))
        {
            dwHeadSize = j + 1;
            dwSize = MultiByteToWideChar (CP_ACP, 0, (LPSTR)(&lpDataIn[j+1]), -1, NULL, 0);
            lpWideInputBuf = (LPWSTR)calloc (dwSize+1, sizeof(TCHAR));
            if (!lpWideInputBuf)
            {
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            MultiByteToWideChar (CP_ACP, 0, (LPSTR)(&lpDataIn[j+1]), -1, lpWideInputBuf, dwSize+1);
            lpRegStr->cchMaxStrLen = GetMaxStrLen (lpRegStr);

            lpWideOutputBuf = ReplaceSingleString (
                               lpWideInputBuf,
                               REG_SZ,
                               lpRegStr,
                               NULL,
                               &dwAttrib,
                               TRUE);
            if (lpWideOutputBuf)
            {
                dwSize = WideCharToMultiByte(CP_ACP, 0, lpWideOutputBuf, -1, 0, 0, NULL, NULL);
                *lpcbOutSize = dwHeadSize + dwSize;
                *lpDataOut = (LPBYTE)calloc (*lpcbOutSize, 1);
                if (*lpDataOut)
                {
                    memcpy (*lpDataOut, lpDataIn, dwHeadSize);
                    WideCharToMultiByte(CP_ACP, 0, lpWideOutputBuf, -1, (LPSTR)&((*lpDataOut)[dwHeadSize]), dwSize+1, NULL, NULL);
                    lRet = ERROR_SUCCESS;
                }
                else
                    lRet = ERROR_NOT_ENOUGH_MEMORY;
               
                free (lpWideOutputBuf);
            }
            free (lpWideInputBuf);

            break;
        }
    }
Cleanup:
    return lRet;
}

HRESULT UpdatePSTpath(
    HKEY    hRootKey,
    LPTSTR  lpUserName,
    LPTSTR  lpSubKeyName,
    LPTSTR  lpValueName,
    PREG_STRING_REPLACE lpRegStr)
{
    HRESULT hr = S_OK;
    HKEY    hKey = NULL;
    HKEY    hSubKey = NULL;
    DWORD   i, j, dwType, dwSizePath, cbOutSize;
    DWORD   dwCchsizeforRenameValueData;
    LPBYTE  lpOutputBuf = NULL;
	LONG	lRet = ERROR_SUCCESS;
    LPTSTR  lpszSectionName = NULL;
    LPTSTR  szRenameValueDataLine = NULL;
    TCHAR   szKeyName[MAX_PATH];
	TCHAR	szBuf[MAX_PATH+1];
    TCHAR   szIndex[MAX_PATH];    


    DPF(APPmsg, L"Enter UpdatePSTpath: ");

	lRet = RegOpenKeyEx(
			hRootKey,
			lpSubKeyName,
			0,
			KEY_READ,
			&hKey);

    if (lRet != ERROR_SUCCESS)
    {
        if ( ( ERROR_FILE_NOT_FOUND == lRet)
                || (ERROR_PATH_NOT_FOUND == lRet) )
        {
            hr = S_FALSE;
            DPF (APPwar, L"UpdatePSTpath: RegOpenKeyEx Failed! error code: %d", lRet);
        }
        else
        {
            DPF (APPerr, L"UpdatePSTpath: RegOpenKeyEx Failed! Error: %d", lRet);
            hr = HRESULT_FROM_WIN32(lRet);
        }
        goto Exit;
    }

    i = 0;
    while (TRUE) 
    {
        if (lRet = RegEnumKey(hKey, i++, szKeyName, MAX_PATH) != ERROR_SUCCESS)
            break;

        if (lRet = RegOpenKeyEx(hKey, szKeyName, 0, KEY_ALL_ACCESS, &hSubKey) == ERROR_SUCCESS) 
        {           
            dwSizePath = MAX_PATH;
            if (lRet = RegQueryValueEx(
                    hSubKey, 
                    OUTLOOK_VALUENAME, 
                    0, 
                    &dwType, 
                    (LPBYTE)szBuf, 
                    &dwSizePath) == ERROR_SUCCESS)
            {
                lRet = ReplaceOutlookPSTPath (
                                (LPBYTE)szBuf,
                                dwSizePath,
                                &lpOutputBuf,
                                &cbOutSize,
                                lpRegStr);
                if (lRet == ERROR_SUCCESS)
                {
                    hr = SetSectionName (lpUserName, &lpszSectionName);

                    dwCchsizeforRenameValueData = lstrlen(lpSubKeyName) +
                                          lstrlen(OUTLOOK_VALUENAME) +
                                          cbOutSize * 4 + MAX_PATH;
                    szRenameValueDataLine = (TCHAR*)calloc(dwCchsizeforRenameValueData, sizeof(TCHAR));
                    if (!szRenameValueDataLine)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    hr = StringCchPrintf(szRenameValueDataLine,dwCchsizeforRenameValueData,
                            TEXT("%d,%u,\"%s\\%s\",\"%s\", "), CONSTANT_REG_VALUE_DATA_RENAME,
                            dwType,lpSubKeyName,szKeyName,OUTLOOK_VALUENAME);
                    if (FAILED(hr))
                        break;

                    dwSizePath = lstrlen(szRenameValueDataLine);
                    for (j = 0; j < cbOutSize-1; j++)
                        hr = StringCchPrintf(&szRenameValueDataLine[dwSizePath+j*4],dwCchsizeforRenameValueData-dwSizePath-j*4,
                                       TEXT("%02x, "), lpOutputBuf[j]);

                    hr = StringCchPrintf(&szRenameValueDataLine[dwSizePath+j*4],dwCchsizeforRenameValueData-dwSizePath-j*4,
                                       TEXT("%02x"), lpOutputBuf[j]);

                    g_dwKeyIndex++;
                    _itot(g_dwKeyIndex,szIndex,16);
                    if (!WritePrivateProfileString(lpszSectionName,szIndex,szRenameValueDataLine,g_szToDoINFFileName))
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        break;
                    }
                    if (szRenameValueDataLine)
                    {
                        free (szRenameValueDataLine);
                        szRenameValueDataLine = NULL;
                    }
                    if (lpszSectionName)
                    {
                        free (lpszSectionName);
                        lpszSectionName = NULL;
                    }
                }
            }
            RegCloseKey(hSubKey);
        }
        else
        {
            DPF (APPerr, L"UpdatePSTpath: RegQueryValue Failed! Error: %d", lRet);
            hr = HRESULT_FROM_WIN32(lRet);
            break;
        }
    }

    RegCloseKey(hKey);
    if ( (lRet == ERROR_NO_MORE_ITEMS) ||(lRet == ERROR_INVALID_FUNCTION) )
    {
        lRet = ERROR_SUCCESS;
    }

    if (szRenameValueDataLine)
        free (szRenameValueDataLine);
    if (lpszSectionName)
        free (lpszSectionName);

    hr = HRESULT_FROM_WIN32(lRet);
Exit:
    DPF(APPmsg, L"Exit UpdatePSTpath: %d", lRet);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\regfind.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    regfind.c

Abstract:

    Search registry and reset the specific value data.

Author:

    Geoffrey Guo (geoffguo) 08-Oct-2001  Created

Revision History:

    <alias> <date> <comments>

--*/
#include "StdAfx.h"
#include "clmt.h"

LONG QueryValue(HKEY, LPTSTR, LPTSTR, PREG_STRING_REPLACE, PVALLIST*, LPTSTR, DWORD, BOOL);
LONG QueryEnumerateKey(HKEY, LPTSTR,LPTSTR,PREG_STRING_REPLACE, LPTSTR, LPTSTR, DWORD, BOOL);
LONG SetRegValueChange (HKEY, LPTSTR, PVALLIST*, LPTSTR);


//-----------------------------------------------------------------------//
//
// RegistryAnalyze()
//
// hRootKey          :  Regsitry handle
// lpRegStr          :  Input parameter structure
// lpRegExclusionList:  MultiSZ string tells a list of Keypath RegRepace should skip
//
//-----------------------------------------------------------------------//
HRESULT RegistryAnalyze(
HKEY                hRootKey,
LPTSTR              szUserName,
LPTSTR              szUserSid,
PREG_STRING_REPLACE lpRegStr,
LPTSTR              lpRegExclusionList,
DWORD               TreatAsType,
LPTSTR              lpRootKeyPath,
BOOL                bStrChk)
{
    TCHAR                       szRoot[MAX_PATH];
    LPTSTR                      lpRoot = TEXT("\0");
    HRESULT                     hResult = S_FALSE;
    LONG                        lResult;

    if (szUserName)
    {
        DPF(REGmsg, L"Enter RegistryAnalyze: szUserName=%s hKey=%d", szUserName, hRootKey);
    }
    else if (hRootKey == HKEY_CLASSES_ROOT)
    {
        DPF(REGmsg, L"Enter RegistryAnalyze: HKEY_CLASSES_ROOT");
    }
    else if (hRootKey == HKEY_LOCAL_MACHINE)
    {
        DPF(REGmsg, L"Enter RegistryAnalyze: HKEY_LOCAL_MACHINE");
    }
    else
    {
        DPF(REGmsg, L"Enter RegistryAnalyze: hKey=%d", hRootKey);
    }

    if (lpRegExclusionList)
    {
        hResult = ReplaceCurrentControlSet(lpRegExclusionList);
        if (FAILED(hResult))
        {
            return hResult;
        }
    }
    if (lpRegStr->lpSearchString && lpRegStr->lpReplaceString)
    {
        UpdateProgress();

        lpRegStr->cchMaxStrLen = GetMaxStrLen (lpRegStr);

        if (lpRootKeyPath)
        {
            lpRoot = lpRootKeyPath;
        }
        else
        {
            if (HKey2Str(hRootKey,szRoot,MAX_PATH))
            {
                lpRoot = szRoot;
            }
        }

        lResult = QueryEnumerateKey(hRootKey, szUserName, szUserSid, lpRegStr, 
                                    lpRoot,lpRegExclusionList,TreatAsType, bStrChk);
        hResult = HRESULT_FROM_WIN32(lResult);
    }
    DPF(REGmsg, L"Exit RegistryAnalyze:");

    return hResult;
}

//-----------------------------------------------------------------------//
//
// ReadValue()
//
// hKey:          Registry key
// szValueName:   Value name
// lpType:        Value type
// lpBuf:         Vaule data buffer
// lpSize:        Value data size
// lpFullKey:     Full sub-key path
//-----------------------------------------------------------------------//
LONG ReadValue (
HKEY    hKey,
LPTSTR  szValueName,
LPDWORD lpType,
LPBYTE  *lpBuf,
LPDWORD lpSize,
LPTSTR  lpFullKey)
{
    LONG lResult;

    //
    // First find out how much memory to allocate.
    //
    lResult = My_QueryValueEx(hKey,
                              szValueName,
                              0,
                              lpType,
                              NULL,
                              lpSize);

    if (lResult != ERROR_SUCCESS)
    {
        DPF (REGerr, L"ReadValue1: RegQueryValueEx failed. lResult=%d", lResult);
        return lResult;
    }

    //There is a bug in W2K HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\VideoUpgradeDisplaySettings".
    //When the value name = Driver1, *lpSize will be 3. To cover Odd number of size, incease one byte for data buffer.
    *lpBuf = (LPBYTE) calloc(*lpSize+sizeof(TCHAR)+1, sizeof(BYTE));

    if (!(*lpBuf)) {
        DPF (REGerr, L"ReadValue: No enough memory");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now get the data
    //
    lResult = My_QueryValueEx(hKey,
                              szValueName,
                              0,
                              lpType,
                              *lpBuf,
                              lpSize);


    if (lResult != ERROR_SUCCESS)
    {
        if (*lpBuf)
            free(*lpBuf);
        DPF (REGerr, L"ReadValue2: RegQueryValueEx fail. lResult=%d", lResult);
        return lResult;
    }

    return ERROR_SUCCESS;
}


//-----------------------------------------------------------------------//
//
// SetRegValueChange()
//
// Set registry value based on the value list
//
// hKey:          Registry key
// lpValList:     Updated value list
// lpFullKey:     Full sub-key path
//-----------------------------------------------------------------------//
LONG SetRegValueChange (
HKEY     hKey,
LPTSTR   szUserName,
PVALLIST *lpValList,
LPTSTR   lpFullKey)
{
    LONG     lResult = ERROR_SUCCESS;
    HRESULT  hResult;
    DWORD    dwType;
    DWORD    dwOldValueSize = 1, dwNewValueSize;
    LPBYTE   lpBuf;
    LPTSTR   lpOldValueData, lpNewValueData, lpNewValueName;
    PVALLIST lpVal;

    if (*lpValList)
    {
        lpVal = *lpValList;
        
        while (lpVal)
        {
            UpdateProgress();

            //Read old value data
            lResult = ReadValue(hKey,
                                lpVal->lpPre_valuename,
                                &dwType,
                                &lpBuf,
                                &dwOldValueSize,
                                lpFullKey);

            if (lResult != ERROR_SUCCESS)
            {
                DPF (REGerr, L"SetRegValueChange: ReadValue failed");
                goto NextData;
            }

/*          //Set new value name or value data
            lResult = RegSetValueEx (hKey,
                        lpVal->ve.ve_valuename,
                        0,
                        lpVal->ve.ve_type,
                        (LPBYTE)(lpVal->ve.ve_valueptr),
                        lpVal->ve.ve_valuelen);
*/        
            //Set old value name or value data
            lResult = RegSetValueEx (hKey,
                        lpVal->lpPre_valuename,
                        0,
                        dwType,
                        lpBuf,
                        dwOldValueSize);

            if (lResult == ERROR_SUCCESS)
            {
                if (lpVal->val_type & REG_CHANGE_VALUENAME)
                {
                    //Delete old value if value name changed
//                    lResult = RegDeleteValue(hKey, lpVal->lpPre_valuename);

//                    if (lResult == ERROR_SUCCESS)
                        DPF (REGinf, L"SetRegValueChange: Rename value %s to %s Key=%s",
                            lpVal->lpPre_valuename, lpVal->ve.ve_valuename, lpFullKey);
//                    else
//                        DPF (REGerr, L"SetRegValueChange: RegDelValue failed. ValueName=%s Key=%s lResult=%d",
//                            lpVal->lpPre_valuename, lpFullKey, lResult);
                }
                else
                    DPF (REGinf, L"SetRegValueChange: Replace value data. Key=%s\\%s",
                        lpFullKey, lpVal->ve.ve_valuename);
            } else
                DPF (REGerr, L"SetRegValueChange: RegSetValueEx Failed. Error=%d", lResult);

            if (lpVal->val_type & REG_CHANGE_VALUENAME)
                lpNewValueName = lpVal->ve.ve_valuename;
            else
                lpNewValueName = NULL;

            if (lpVal->val_type & REG_CHANGE_VALUEDATA)
            {
                lpOldValueData = (LPTSTR)lpBuf;
                dwNewValueSize = lpVal->ve.ve_valuelen;
                lpNewValueData = (LPTSTR)lpVal->ve.ve_valueptr;
            } else
            {
                dwOldValueSize = 0;
                lpOldValueData = NULL;
                dwNewValueSize = 0;
                lpNewValueData = NULL;
            }

            //Add registry value change information to INF file
            hResult = AddRegValueRename(
                                        lpFullKey,
                                        lpVal->lpPre_valuename,
                                        lpNewValueName,
                                        lpOldValueData,
                                        lpNewValueData,
                                        lpVal->ve.ve_type,
                                        lpVal->val_attrib,
                                        szUserName);

            lResult = HRESULT_CODE(hResult);

            if (lResult != ERROR_SUCCESS)
            {
                DPF (REGerr, L"SetRegValueChange: AddRegValueRename failed. Key = %s, error = %d", lpFullKey,lResult);
                if(lpBuf)
                {
                    free(lpBuf);
                    lpBuf = NULL;
                }
                break;
            }
            if(lpBuf)
            {
                free(lpBuf);
                lpBuf = NULL;
            }

NextData:
            lpVal = lpVal->pvl_next;

        }
        RemoveValueList (lpValList);
    }

    return lResult;
}


//-----------------------------------------------------------------------//
//
// QueryValue()
//
// hKey:          Registry key
// szUserName:    User name
// szValueName:   Value name
// lpRegStr:      Input parameter structure
// lpValList:     Updated value list
// lpFullKey:     Full sub-key path
//-----------------------------------------------------------------------//
LONG QueryValue(
    HKEY                hKey,
    LPTSTR              szUserName,
    LPTSTR              szValueName,
    PREG_STRING_REPLACE lpRegStr,
    PVALLIST            *lpValList,
    LPTSTR              lpFullKey,
    DWORD               TreatAsType,
    BOOL                bStrChk)
{
    LONG        lResult;
    HRESULT     hResult;
    DWORD       dwType;
    DWORD       cbSize = 1;
    LPBYTE      lpBuf = NULL;

    lResult = ReadValue(hKey,
                        szValueName,
                        &dwType,
                        &lpBuf,
                        &cbSize,
                        lpFullKey);

    if (lResult != ERROR_SUCCESS)
        goto Exit;

    switch (dwType)
    {
        case REG_MULTI_SZ:
        case REG_EXPAND_SZ:
        case REG_LINK:
        case REG_SZ:
        case REG_DWORD:
            hResult = ReplaceValueSettings (
                                         szUserName,
                                         (LPTSTR)lpBuf,
                                         cbSize,
                                         szValueName,
                                         dwType,
                                         lpRegStr,
                                         lpValList,
                                         lpFullKey,
                                         bStrChk);
            lResult = HRESULT_CODE(hResult);
            break;

        default:
        if ( TreatAsType )
        {
            dwType = dwType <<16;
            dwType = dwType + TreatAsType;
            hResult = ReplaceValueSettings (
                                         szUserName,
                                         (LPTSTR)lpBuf,
                                         cbSize,
                                         szValueName,
                                         dwType,
                                         lpRegStr,
                                         lpValList,
                                         lpFullKey,
                                         bStrChk);
            lResult = HRESULT_CODE(hResult);
        }
            break;
    }

Exit:
    if(lpBuf)
        free(lpBuf);

    return lResult;
}


//-----------------------------------------------------------------------//
//
// QueryEnumerateKey() - Recursive
//
// hKey:                Registry key
// szUserName:          User name
// lpRegStr:            Input parameter structure
// lpFullKey:           Full sub-key path
// lpRegExclusionList:  MultiSZ string tells a list of Keypath RegRepace should skip
//-----------------------------------------------------------------------//
LONG QueryEnumerateKey(
HKEY                hKey,
LPTSTR              szUserName,
LPTSTR              szUserSid,
PREG_STRING_REPLACE lpRegStr,
LPTSTR              szFullKey,
LPTSTR              lpRegExclusionList,
DWORD               TreatAsType,
BOOL                bStrChk)
{
    LONG     lResult;
    HRESULT  hResult;
    UINT     i;
    DWORD    cchSize, cchLen;
    DWORD    dwNum;
    BOOL     dwAccessDenied;
    HKEY     hSubKey;
    TCHAR*   szNameBuf = NULL;
    TCHAR*   szKeyPath;
    TCHAR*   szNewKeyPath;
    PVALLIST lpValList;

    // query source key info
    DWORD   cchLenOfKeyName, cchLenOfValueName;
    TCHAR   szKeyName[2*MAX_PATH];

    UpdateProgress();

    if (lpRegExclusionList && IsStrInMultiSz(szFullKey,lpRegExclusionList))
    {
        lResult = S_OK;
        goto Cleanup;
    }    
    lResult = RegQueryInfoKey(hKey,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              &cchLenOfKeyName,
                              NULL,
                              NULL,
                              &cchLenOfValueName,
                              NULL,
                              NULL,
                              NULL);

    if (lResult != ERROR_SUCCESS)
    {
        DPF (REGerr, L"QueryEnumerateKey1: RegQueryInfoKey failed. Key=%s lResult=%d", szFullKey, lResult);
        return ERROR_SUCCESS;
    }

    // create buffer
    cchLenOfValueName++;
    szNameBuf = (TCHAR*) calloc(cchLenOfValueName, sizeof(TCHAR));
    if (!szNameBuf) 
    {
        DPF (REGerr, L"QueryEnumerateKey1: No enough memory");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // enumerate all of the values
    //
    i = 0;
    lpValList = NULL;
    do
    {
        UpdateProgress();

        cchSize = cchLenOfValueName;
        lResult = RegEnumValue(hKey,
                               i,
                               szNameBuf,
                               &cchSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (lResult == ERROR_MORE_DATA)
        {
            free(szNameBuf);

            //RegQueryInfoKey has a bug. *lpcMaxValueNameLen return 1 when
            //Key=HKLM\\SYSTEM\\ControlSet002\\Control\\Lsa\\SspiCache.
            cchSize = MAX_PATH;
            szNameBuf = (TCHAR*) calloc(cchSize+1, sizeof(TCHAR));
            if (!szNameBuf) 
            {
                DPF (REGerr, L"QueryEnumerateKey2: No enough memory");
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            cchLenOfValueName = cchSize+1;
            lResult = RegEnumValue(hKey,
                               i,
                               szNameBuf,
                               &cchSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        }
        
        if (lResult == ERROR_SUCCESS)
        {
            lResult = QueryValue(hKey, szUserName, szNameBuf, lpRegStr, &lpValList, 
                                 szFullKey, TreatAsType, bStrChk);

            // continue to query
            if(lResult == ERROR_ACCESS_DENIED)
            {
                DPF(REGerr, L"QueryEnumerateKey: Access denied ValueName=%s Key=%s", szNameBuf, szFullKey);
            } 
            else if (lResult != ERROR_SUCCESS)
            {
                DPF(REGerr, L"QueryEnumerateKey: QueryValue failed. ValueName=%s Key=%s hResult=%d", szNameBuf, szFullKey, lResult);
            }
            lResult = ERROR_SUCCESS;
        } 
        else if (lResult == ERROR_NO_MORE_ITEMS)
        {
           break;
        }
        else
        {
            DPF(REGerr, L"QueryEnumerateKey: RegEnumValue fails. Index=%d Key=%s Error=%d",
                i, szFullKey, lResult);
        }
        i++;
    } while (1);

    lResult = SetRegValueChange (hKey, szUserName, &lpValList, szFullKey);
    if (lResult != ERROR_SUCCESS)
    {
        DPF(REGerr, L"QueryEnumerateKey: SetRegValueChange failed ,error = %d",lResult);
        goto Cleanup;
    }

    if(szNameBuf)
    {
        free(szNameBuf);
    }

    //
    // Now Enumerate all of the keys
    //
    cchLenOfKeyName++;
    szNameBuf = (TCHAR*) calloc(cchLenOfKeyName, sizeof(TCHAR));
    if (!szNameBuf) 
    {
        DPF (REGerr, L"QueryEnumerateKey4: No enough memory");
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    i = 0;
    do
    {
        UpdateProgress();

        cchSize = cchLenOfKeyName;
        lResult = RegEnumKeyEx(hKey,
                               i,
                               szNameBuf,
                               &cchSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (lResult == ERROR_MORE_DATA)
        {
            free(szNameBuf);

            //It should not get here except lpcMaxValueLen return wrong.
            cchSize = MAX_PATH;
            szNameBuf = (TCHAR*) calloc(cchSize+1, sizeof(TCHAR));
            if (!szNameBuf) 
            {
                DPF (REGerr, L"QueryEnumerateKey3: No enough memory");
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            cchLenOfKeyName = cchSize+1;
            lResult = RegEnumKeyEx(hKey,
                               i,
                               szNameBuf,
                               &cchSize,
                               NULL,
                               NULL,
                               NULL,
                               NULL);
        }

        if (lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_NO_MORE_ITEMS)
            {
                lResult = ERROR_SUCCESS;
            }
            else
            {
                DPF (REGerr, L"QueryEnumerateKey: RegEnumKeyEx failed. Key=%s Error=%d", szFullKey, lResult);
            }

            break;
        }

        //BUGBUG:XIAOZ following code is doubtful, why we need lpRegExclusionList != NULL
        //to exclude current control set, we should always exlcude it for performace
        //and it should be in lpRegExclusionList, we do not any special processing for this

        dwAccessDenied = FALSE;
        if (lpRegExclusionList)
        {
            //skip CurrentControlSet since it is a link to existing control set
            if (MyStrCmpI(szFullKey, L"HKLM\\SYSTEM") == 0 &&
                MyStrCmpI(szNameBuf, L"CurrentControlSet") == 0)
            {
                goto NextKey;
            }
        }

        //skip exclusive registry keys
        if (MyStrCmpI(szFullKey, TEXT("HKLM")) == 0 &&
            (MyStrCmpI(szNameBuf, TEXT("SAM")) == 0 || MyStrCmpI(szNameBuf, TEXT("SECURITY")) == 0) ||
            MyStrCmpI(szFullKey, TEXT("HKLM\\SYSTEM\\ControlSet001\\Enum\\PCI\\VEN_8086&DEV_7110&SUBSYS_00000000&REV_02\\2&ebb567f&0&38\\Device Parameters")) == 0 &&
            MyStrCmpI(szNameBuf, TEXT("BiosConfig")) == 0 )
            goto NextKey;

TryAgain:

        //
        // open up the subkey, and enumerate it
        //
        lResult = RegOpenKeyEx(hKey,
                               szNameBuf,
                               0,
                               KEY_ALL_ACCESS
//                               | ACCESS_SYSTEM_SECURITY
                               ,
                               &hSubKey);

        if (lResult != ERROR_SUCCESS)
        {
            if(lResult == ERROR_ACCESS_DENIED) // Try Read_Only
            {
                lResult = RegOpenKeyEx(hKey,
                               szNameBuf,
                               0,
                               KEY_READ,
                               &hSubKey);

                if (lResult == ERROR_SUCCESS)
                {
                    DPF(REGwar, L"QueryEnumerateKey: RegOpenKeyEx: Key=%s\\%s Read Only", szFullKey, szNameBuf);
                    goto DoKey;
                }

                if (dwAccessDenied)
                {
                    DPF(REGerr, L"QueryEnumerateKey: RegOpenKeyEx: Access Denied. Key=%s\\%s", szFullKey, szNameBuf);
                    goto NextKey;
                }

                hResult = RenameRegRoot(szFullKey, szKeyName, 2*MAX_PATH-1, szUserSid, szNameBuf);
                AdjustObjectSecurity(szKeyName, SE_REGISTRY_KEY, TRUE);
                dwAccessDenied = TRUE;
                goto TryAgain;
            }

            DPF(REGerr, L"QueryEnumerateKey: RegOpenKeyEx failed. Key=%s\\%s Error=%d", szFullKey, szNameBuf, lResult);
            //skip the current key since it cannot be opened.
            goto NextKey;
        }
DoKey:
        //
        // Build up the needed string and go down enumerating again
        //
        cchLen = lstrlen(szFullKey) + lstrlen(szNameBuf) + 2;
        szKeyPath = (TCHAR*) calloc(cchLen, sizeof(TCHAR));
        if (!szKeyPath) 
        {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
            DPF (REGerr, L"QueryEnumerateKey5: No enough memory");
            RegCloseKey(hSubKey);
            goto Cleanup;
        }

        //We calculte the buffer for szKeyPath, so here StringCchCopy should be
        //always success, assinging return value just make prefast happy 
        hResult = StringCchCopy(szKeyPath, cchLen, szFullKey);
        hResult = StringCchCat(szKeyPath, cchLen, L"\\");
        hResult = StringCchCat(szKeyPath, cchLen, szNameBuf);

        dwNum = StrNumInMultiSZ(szNameBuf, lpRegStr->lpSearchString);
        if (dwNum != 0xFFFFFFFF)
        {
            LPTSTR lpKeyName;

            lpKeyName = GetStrInMultiSZ(dwNum, lpRegStr->lpReplaceString);
            cchLen = lstrlen(szFullKey) + lstrlen(lpKeyName) + 2;
            szNewKeyPath = (TCHAR*) calloc(cchLen, sizeof(TCHAR));
            if (!szNewKeyPath) {
                lResult = ERROR_NOT_ENOUGH_MEMORY;
                DPF (REGerr, L"QueryEnumerateKey6: No enough memory");
                RegCloseKey(hSubKey);
                free(szKeyPath);
                goto Cleanup;
            }

            if (szFullKey)
            {
                //We calculte the buffer for szNewKeyPath, so here StringCchCopy should be
                //always success, assinging return value just make prefast happy 
                hResult = StringCchCopy(szNewKeyPath, cchLen, szFullKey);
            }

            //We calculte the buffer for szNewKeyPath, so here StringCchCopy should be
            //always success, assinging return value just make prefast happy 
            hResult = StringCchCat(szNewKeyPath, cchLen, L"\\");
            hResult = StringCchCat(szNewKeyPath, cchLen, lpKeyName);
            
            hResult = AddRegKeyRename(szFullKey, szNameBuf, lpKeyName, szUserName);

            if (FAILED(hResult))
            {
                DPF(REGerr, L"QueryEnumerateKey: AddRegKeyRename failed. Key=%s", szKeyPath);
            }
            else
            {
                DPF(REGinf, L"QueryEnumerateKey: AddRegKeyRename succeed. Key=%s", szKeyPath);
            }

            free (szNewKeyPath);
        }


        // recursive query
        lResult = QueryEnumerateKey(hSubKey,
                                    szUserName,
                                    szUserSid,
                                    lpRegStr,
                                    szKeyPath,
                                    lpRegExclusionList,
                                    TreatAsType,
                                    bStrChk);

        if(lResult != ERROR_SUCCESS)
        {
            if (lResult == ERROR_NOT_ENOUGH_MEMORY)
            {
                if (szKeyPath)
                    free(szKeyPath);

                RegCloseKey(hSubKey);
                goto Cleanup;
            } else
                DPF(REGerr, L"QueryEnumerateKey: QueryEnumerateKey failed. Key=%s lResult=%d", szKeyPath, lResult);
        }

        RegCloseKey(hSubKey);

        if(szKeyPath)
            free(szKeyPath);

NextKey:
        if (dwAccessDenied)
            AdjustObjectSecurity(szKeyName, SE_REGISTRY_KEY, FALSE);

        i++;
    } while (1);

Cleanup:
    if(szNameBuf)
        free(szNameBuf);

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\registry.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    registry.c

Abstract:

    Miscellaneous routines for the Registry Operation

Author:

    Xiaofeng Zang (xiaoz) 17-Sep-2001  Created(most code stole from base\fs\utils\regedit)


Revision History:

    <alias> <date> <comments>
     xiaoz   09/25/01   add RegResetValue

--*/

#include "StdAfx.h"
#include "clmt.h"
#include <strsafe.h>

#define MAXVALUENAME_LENGTH 256
#define MAXKEYNAME          256
#define ExtraAllocLen(Type) (IsRegStringType((Type)) ? sizeof(TCHAR) : 0)
#define IsRegStringType(x)  (((x) == REG_SZ) || ((x) == REG_EXPAND_SZ) || ((x) == REG_MULTI_SZ))

#define TEXT_REG_RESET_PER_USER_SECTION     TEXT("RegistryResetPerUser")
#define TEXT_REG_RESET_PER_SYSTEM_SECTION   TEXT("RegistryResetPerSystem")

HRESULT MigrateRegSchemes(HINF, HKEY, LPCTSTR);
HRESULT DoRegReset(HKEY, HINF, LPCTSTR, LPCTSTR);
HRESULT RegBinaryDataReset (HKEY, LPTSTR, LPTSTR, PREG_STRING_REPLACE, LPTSTR[]);
HRESULT RegValueDataReset(HKEY, LPTSTR, LPTSTR, LPTSTR, LPTSTR[]);
HRESULT RegValueNameReset(HKEY, LPTSTR, LPTSTR, LPTSTR, LPTSTR[]);
HRESULT RegKeyNameReset(HKEY, LPTSTR, LPTSTR, LPTSTR, LPTSTR[]);
HRESULT RegWideMatchReset(HKEY, LPTSTR, LPTSTR, LPTSTR, LPTSTR[]);
BOOL    bIsValidRegStr(DWORD dwType, DWORD cbLen);




/*******************************************************************************
*
*  CopyRegistry
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hSourceKey,
*     hDestinationKey,
*
*************************************************************************************/

BOOL
CopyRegistry(
    HKEY hSourceKey,
    HKEY hDestinationKey
    )
{

    BOOL  fSuccess = TRUE;
    DWORD EnumIndex;
    DWORD cchValueName;
    DWORD cbValueData;
    DWORD Type;
    HKEY  hSourceSubKey;
    HKEY  hDestinationSubKey;
    TCHAR ValueNameBuffer[MAXVALUENAME_LENGTH];
    TCHAR KeyNameBuffer[MAXKEYNAME];

    //
    //  Copy all of the value names and their data.
    //

    EnumIndex = 0;

    while (TRUE)
    {
        PBYTE pbValueData;
        cchValueName = ARRAYSIZE(ValueNameBuffer);

        // VALUE DATA
        // Query for data size
        if (RegEnumValue(hSourceKey, EnumIndex++, ValueNameBuffer,
            &cchValueName, NULL, &Type, NULL, &cbValueData) != ERROR_SUCCESS)
        {
            break;
        }

        // allocate memory for data
        pbValueData =  LocalAlloc(LPTR, cbValueData+ExtraAllocLen(Type));
        if (pbValueData)
        {
            if (My_QueryValueEx(hSourceKey, ValueNameBuffer,
                NULL, &Type, pbValueData, &cbValueData) == ERROR_SUCCESS)
            {
                RegSetValueEx(hDestinationKey, ValueNameBuffer, 0, Type,
                    pbValueData, cbValueData);
            }
            else
            {
                fSuccess = FALSE;
            }
            LocalFree(pbValueData);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if (fSuccess)
    {
        //
        //  Copy all of the subkeys and recurse into them.
        //

        EnumIndex = 0;

        while (TRUE) {

            if (RegEnumKey(hSourceKey, EnumIndex++, KeyNameBuffer, MAXKEYNAME) !=
                ERROR_SUCCESS)
                break;

            if(RegOpenKeyEx(hSourceKey,KeyNameBuffer,0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSourceSubKey) ==
                ERROR_SUCCESS) {

                if (RegCreateKey(hDestinationKey, KeyNameBuffer,
                    &hDestinationSubKey) == ERROR_SUCCESS) {

                    CopyRegistry(hSourceSubKey, hDestinationSubKey);

                    RegCloseKey(hDestinationSubKey);

                }

                RegCloseKey(hSourceSubKey);

            }

        }
    }

    return fSuccess;
}



/*******************************************************************************
*
*  RegDeleteKeyRecursive
*
*  DESCRIPTION:
*     Adapted from \\kernel\razzle3,mvdm\wow32\wshell.c,WOWRegDeleteKey().
*     The Windows 95 implementation of RegDeleteKey recursively deletes all
*     the subkeys of the specified registry branch, but the NT implementation
*     only deletes leaf keys.
*
*  PARAMETERS:
*     (see below)
*
*******************************************************************************/

LONG
RegDeleteKeyRecursive(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey
    )

/*++

Routine Description:

    There is a significant difference between the Win3.1 and Win32
    behavior of RegDeleteKey when the key in question has subkeys.
    The Win32 API does not allow you to delete a key with subkeys,
    while the Win3.1 API deletes a key and all its subkeys.

    This routine is a recursive worker that enumerates the subkeys
    of a given key, applies itself to each one, then deletes itself.

    It specifically does not attempt to deal rationally with the
    case where the caller may not have access to some of the subkeys
    of the key to be deleted.  In this case, all the subkeys which
    the caller can delete will be deleted, but the api will still
    return ERROR_ACCESS_DENIED.

Arguments:

    hKey - Supplies a handle to an open registry key.

    lpszSubKey - Supplies the name of a subkey which is to be deleted
                 along with all of its subkeys.

Return Value:

    ERROR_SUCCESS - entire subtree successfully deleted.

    ERROR_ACCESS_DENIED - given subkey could not be deleted.

--*/

{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;

    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
                          lpszSubKey,
                          0,
                          KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
                          &Key);
    if (Status != ERROR_SUCCESS) 
    {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
        return(RegDeleteKey(hKey,lpszSubKey));
    }

    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
                             NULL,
                             &ClassLength,
                             0,
                             &SubKeys,
                             &MaxSubKey,
                             &MaxClass,
                             &Values,
                             &MaxValueName,
                             &MaxValueData,
                             &SecurityLength,
                             &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER)) 
    {
        RegCloseKey(Key);
        return(Status);
    }

    NameBuffer = (LPTSTR) LocalAlloc(LPTR, (MaxSubKey + 1)*sizeof(TCHAR));
    if (NameBuffer == NULL) 
    {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i=0;
    do 
    {
        Status = RegEnumKey(Key,
                            i,
                            NameBuffer,
                            MaxSubKey+1);
        if (Status == ERROR_SUCCESS) 
        {
            Status = RegDeleteKeyRecursive(Key,NameBuffer);
        }

        if (Status != ERROR_SUCCESS) 
        {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }

    } while ( (Status != ERROR_NO_MORE_ITEMS) && (i < SubKeys) );

    LocalFree((HLOCAL) NameBuffer);
    RegCloseKey(Key);
    return(RegDeleteKey(hKey,lpszSubKey));
}



//-----------------------------------------------------------------------------
//
//  Function:   RegRenameValueName
//
//  Synopsis:   Rename the value name in registry by copying the data from
//              old value to new value, then delete the old value.
//
//  Returns:    Win32 Error Code
//
//  History:    09/17/2001  Xiaoz       Created
//              02/14/2001  rerkboos    Add dynamic buffer allocation
//              03/05/2002  rerkboos    Code clean up
//
//  Notes:      hKey parameter must have been opened with KEY_SET_VALUE access
//
//-----------------------------------------------------------------------------
LONG RegRenameValueName(
    HKEY    hKey,           // Handle to registry key containing the value
    LPCTSTR lpOldValName,   // Old value name to be changed
    LPCTSTR lpNewValName    // New value name
)
{
    LONG   lResult;
    DWORD  dwType;
    DWORD  cbData;
    LPBYTE lpData = NULL;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;

    if (lpOldValName == NULL || lpNewValName == NULL)
    {
        // invalid parameter
        return ERROR_INVALID_PARAMETER;
    }

    if (MyStrCmpI(lpOldValName, lpNewValName) == LSTR_EQUAL)
    {
        return ERROR_SUCCESS;
    }

    //
    // Get the registry info under hkey
    //
    lResult = RegQueryInfoKey(hKey,
                              NULL,
                              &ClassLength,
                              0,
                              &SubKeys,
                              &MaxSubKey,
                              &MaxClass,
                              &Values,
                              &MaxValueName,
                              &MaxValueData,
                              &SecurityLength,
                              &LastWriteTime);
    if ((lResult != ERROR_SUCCESS) &&
        (lResult != ERROR_MORE_DATA) &&
        (lResult != ERROR_INSUFFICIENT_BUFFER)) 
    {
            goto Cleanup;
    }
    MaxValueData += 2*sizeof(TCHAR);

    if (NULL == (lpData = malloc(MaxValueData)))
    {
        lResult = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    //
    // Query the value of old value name
    //
    cbData = MaxValueData;
    lResult = My_QueryValueEx(hKey,
                              lpOldValName,
                              0,
                              &dwType,
                              lpData,
                              &cbData);

    if (ERROR_SUCCESS != lResult)
    {
        goto Cleanup;
    }    
    //
    // Create a new value name using old data
    //
    lResult = RegSetValueEx(hKey,
                            lpNewValName,
                            0,
                            dwType,
                            lpData,
                            cbData);

    if (lResult != ERROR_SUCCESS) 
    {

        DPF(dlError, 
            TEXT("RegRenameValueName: Failed to create value [%s]"),
            lpNewValName);        
        goto Cleanup;
    }
    //
    // Delete the old value name, after successfully created a new one
    //
    lResult = RegDeleteValue(hKey, lpOldValName);

    if (lResult != ERROR_SUCCESS) 
    {
        DPF(dlError,
            TEXT("RegRenameValueName: Cannot delete old value [%s]"),
            lpOldValName);
        
        // if we cannot delete old value, new value shouldn't be created
        RegDeleteValue(hKey, lpNewValName);

        goto Cleanup;
    }

Cleanup:
    // BUG 561546: Free the allocated buffer
    if (lpData)
    {
        free(lpData);
    }

    return lResult;
}


/**
Routine Description:

  RegResetValue check whether the current value equals szOldValue,
  if yes , change the value to szNewValue,otherwise it does not do anything
  however if szOldValue  is NULL, then , it will always set value 
          if szOldValue  is "",   then , it will add this value

Arguments:

  hKeyRoot - Specifies the root of registry key

  szKeyName - Specifies registry key path
            

  szValueName - Specifies the name of value field 

  dwType - specifies string type, should be one of REG_SZ/REG_EXPAND_SZ/REG_MULTI_SZ

  szOldValue - specifies the expected old value
  
  szNewValue - specifies the new value


Return Value:

  TRUE - Success 
  FALSE - Failure

--*/


LONG RegResetValue(
    HKEY     hKeyRoot,      // Root of registry key
    LPCTSTR  lpKeyName,     // Registry key path
    LPCTSTR  lpValueName,   // Name of value field 
    DWORD    dwType,        // Value type
    LPCTSTR  lpOldValue,    // Expected old value
    LPCTSTR  lpNewValue,    // New value to be set
    DWORD    dwValueSize,   // New value data size
    LPCTSTR  lpszUsersid    // User Sid
)
{
    LONG        lResult;
    HKEY        hKey = NULL;
    DWORD       dw;
    DWORD       ClassLength=0;
    DWORD       SubKeys;
    DWORD       MaxSubKey;
    DWORD       MaxClass;
    DWORD       Values;
    DWORD       MaxValueName;
    DWORD       MaxValueData;
    DWORD       SecurityLength;
    FILETIME    LastWriteTime;
    LPTSTR      szData = NULL;
    DWORD       dwSize = 0;
    BOOL        bTry = TRUE;
    BOOL        bNeedCLoseKey = TRUE;
    
    //if lpOldValue is NULL , mean Set to lpNewValue and do not care the old one    
    if ( !lpOldValue || !lpOldValue[0])
    {
        if (!lpKeyName)
        {
            hKey = hKeyRoot;
            bNeedCLoseKey = FALSE;
            goto SkipKeyOpen;
        }

        if (lpOldValue)
        {
            DWORD dwDisposition;
TryAgain1:
            lResult = RegCreateKeyEx(hKeyRoot,
                                     lpKeyName,
                                     0,
                                     NULL,
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                    &hKey,
                                    &dwDisposition);

            if (lResult != ERROR_SUCCESS) 
            {
                if (bTry && lResult == ERROR_ACCESS_DENIED)
                {
                    AdjustRegSecurity(hKeyRoot, lpKeyName, lpszUsersid, TRUE);
                    bTry = FALSE;
                    goto TryAgain1;
                }
                goto Cleanup;
            }
        }
        else
        {
TryAgain2:
            lResult = RegOpenKeyEx(hKeyRoot,
                              lpKeyName,
                              0,
                              KEY_ALL_ACCESS,
                              &hKey);
            if (lResult != ERROR_SUCCESS) 
            {
                if (bTry && lResult == ERROR_ACCESS_DENIED)
                {
                    AdjustRegSecurity(hKeyRoot, lpKeyName, lpszUsersid, TRUE);
                    bTry = FALSE;
                    goto TryAgain2;
                }
                goto Cleanup;
            }
        }
SkipKeyOpen:
        switch (dwType & 0xffff)
        {
            case REG_SZ:
            case REG_EXPAND_SZ:            
                dwSize = (lstrlen(lpNewValue) + 1) * sizeof(TCHAR);
                break;
            case REG_MULTI_SZ:
                dwSize = MultiSzLen(lpNewValue) * sizeof(TCHAR);
                break;
            case REG_BINARY:
                dwSize = dwValueSize;
                break;
        }
    }    
    else 
    {
TryAgain3:
        //if lpOldValue !="", it mean set the lpNewValue, but check whether the current
        //                    registry value is szOldValue
    
        //Open the subket and got the handle in hKey
        lResult = RegOpenKeyEx(hKeyRoot,
                              lpKeyName,
                              0,
                              KEY_ALL_ACCESS,
                              &hKey);
        if (lResult != ERROR_SUCCESS) 
        {
            if (bTry && lResult == ERROR_ACCESS_DENIED)
            {
                AdjustRegSecurity(hKeyRoot, lpKeyName, lpszUsersid, TRUE);
                bTry = FALSE;
                goto TryAgain3;
            }
            goto Cleanup;
        }
        lResult = RegQueryInfoKey(hKey,
                                  NULL,
                                  &ClassLength,
                                  0,
                                  &SubKeys,
                                  &MaxSubKey,
                                  &MaxClass,
                                  &Values,
                                  &MaxValueName,
                                  &MaxValueData,
                                  &SecurityLength,
                                  &LastWriteTime);
        if ((lResult != ERROR_SUCCESS) &&
                (lResult != ERROR_MORE_DATA) &&
                (lResult != ERROR_INSUFFICIENT_BUFFER)) 
        {
            goto Cleanup;
        }
        MaxValueData += 2*sizeof(TCHAR);

        if (NULL == (szData = malloc(MaxValueData)))
        {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        dwSize = MaxValueData;
        lResult = My_QueryValueEx (hKey,
                                   lpValueName,
                                   0,
                                   &dw,
                                   (LPBYTE) szData,
                                   &dwSize);
        if (lResult != ERROR_SUCCESS) 
        {
            goto Cleanup;
        }
        if ( ((dwType & 0xffff) == REG_SZ) || ((dwType & 0xffff) == REG_EXPAND_SZ) )
        {
            if (MyStrCmpI(szData, lpOldValue) != LSTR_EQUAL)
            {
                lResult = ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                dwSize = (lstrlen(lpNewValue) + 1) * sizeof(TCHAR);
            }
        }
        else
        {//dwType == REG_MULTI_SZ
            if (!CmpMultiSzi(szData, lpOldValue))
            {
                lResult = ERROR_SUCCESS;
                goto Cleanup;
            }
            else
            {
                dwSize = MultiSzLen(lpNewValue) * sizeof(TCHAR);
            }
        }
        if ( dwType & 0xffff0000)
        {
            if ((dwType & 0xffff0000)>>16 != dw )            
            {
                // Key type in registry mismatches the caller-supplied type
                lResult = ERROR_SUCCESS;
                goto Cleanup;
            }        
        }
        else
        {
            if (dwType != dw)
            {
                // Key type in registry mismatches the caller-supplied type
                lResult = ERROR_SUCCESS;
                goto Cleanup;
            }        
        }
    }
    //
    // Set the new value
    //
    if ( dwType & 0xffff0000)
    {
        dwType = (dwType & 0xffff0000)>>16;
    }
    
    lResult = RegSetValueEx(hKey,
                            lpValueName,
                            0,
                            dwType,
                            (LPBYTE) lpNewValue,
                            dwSize);

Cleanup:

    if (hKey && bNeedCLoseKey)
    {
        RegCloseKey(hKey);
    }
    if (!bTry)
    {
        AdjustRegSecurity(hKeyRoot, lpKeyName, lpszUsersid, FALSE);
    }
    FreePointer(szData);
    return lResult;    
}



//-----------------------------------------------------------------------------
//
//  Function:   RegResetValueName
//
//  Synopsis:   Reset value name to new name if the old name matches the
//              user-supply lpOldValueName.
//
//  Returns:    Win32 Error Code
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
LONG RegResetValueName(
    HKEY    hRootKey,           // Root key
    LPCTSTR lpSubKeyName,       // Sub key name under HKEY_Users\{user hive}
    LPCTSTR lpOldValueName,     // Old value name to be changed
    LPCTSTR lpNewValueName,     // New value name
    LPCTSTR lpszUsersid         // User Sid
)
{
    LONG  lRet;
    HKEY  hKey;
    BOOL  bTry = TRUE;

    
TryAgain:
    lRet = RegOpenKeyEx(hRootKey,
                        lpSubKeyName,
                        0,
                        KEY_WRITE | KEY_READ,
                        &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegRenameValueName(hKey,
                                  lpOldValueName,
                                  lpNewValueName);
        RegCloseKey(hKey);

        if (!bTry)
            AdjustRegSecurity(hRootKey, lpSubKeyName, lpszUsersid, FALSE);
    } else if (bTry && lRet == ERROR_ACCESS_DENIED)
    {
        AdjustRegSecurity(hRootKey, lpSubKeyName, lpszUsersid, TRUE);
        bTry = FALSE;
        goto TryAgain;
    }

    return lRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   RegResetKeyName
//
//  Synopsis:   Reset the registry key
//
//  Returns:    Win32 Error Code
//
//  History:    05/06/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
LONG RegResetKeyName(
    HKEY    hRootKey,            // Root key
    LPCTSTR lpSubKey,            // Sub key
    LPCTSTR lpOldKeyName,        // Old key name to be changed
    LPCTSTR lpNewKeyName         // New key name
)
{
    LONG lRet;
    HKEY hKey;
    HKEY hOldKey;
    HKEY hNewKey;

    lRet = RegOpenKeyEx(hRootKey,
                        lpSubKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegOpenKeyEx(hKey,
                            lpOldKeyName,
                            0,
                            KEY_READ | KEY_WRITE,
                            &hOldKey);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hKey,
                                  lpNewKeyName,
                                  0,
                                  TEXT(""),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_WRITE | KEY_READ,
                                  NULL,
                                  &hNewKey,
                                  NULL);
            if (lRet == ERROR_SUCCESS)
            {
                if (CopyRegistry(hOldKey, hNewKey))
                {
                    RegDeleteKeyRecursive(hKey, lpOldKeyName);
                }

                RegCloseKey(hNewKey);
            }

            RegCloseKey(hOldKey);
        }

        RegCloseKey(hKey);
    }

    return lRet;
}




LONG RegGetValue(
    HKEY    hKeyRoot,
    LPTSTR  szKeyName,
    LPTSTR  szValueName,
    LPDWORD lpType,
    LPBYTE  lpData,                   
    LPDWORD lpcbData)

{
    LONG lResult ;
    HKEY hKey = NULL;

    
    lResult = RegOpenKeyEx(hKeyRoot,
                           szKeyName,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult != ERROR_SUCCESS) 
    {
        goto Cleanup;
    }    
    lResult = My_QueryValueEx (hKey,
                               szValueName,
                               0,
                               lpType,
                               lpData,
                               lpcbData);
Cleanup:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return lResult;    
}


HRESULT MigrateRegSchemes(
    HINF    hInf,           // Handle to template INF
    HKEY    hKey,           // Handle to root key
    LPCTSTR lpUserName      // User name
)
{
    HRESULT    hr = E_FAIL;
    BOOL       bRet;
    LONG       lComponentCount;
    LONG       lLineIndex;
    INFCONTEXT context;
    LPCTSTR    lpSectionName;

    const TCHAR szPerSystemSection[] = TEXT_REG_RESET_PER_SYSTEM_SECTION;
    const TCHAR szPerUserSection[] = TEXT_REG_RESET_PER_USER_SECTION;

    if (hInf == INVALID_HANDLE_VALUE)
    {
        return E_INVALIDARG;
    }

    DPF(REGmsg, TEXT("Enter MigrateRegSchemes:"));

    lpSectionName = (lpUserName ? szPerUserSection : szPerSystemSection);

    // Get all components from appropriate section
    lComponentCount = SetupGetLineCount(hInf, lpSectionName);
    for (lLineIndex = 0 ; lLineIndex < lComponentCount ; lLineIndex++)
    {
        bRet = SetupGetLineByIndex(hInf,
                                   lpSectionName,
                                   lLineIndex,
                                   &context);
        if (bRet)
        {
            TCHAR szComponentName[MAX_PATH];
            DWORD cchReqSize;

            bRet = SetupGetStringField(&context,
                                       1,
                                       szComponentName,
                                       ARRAYSIZE(szComponentName),
                                       &cchReqSize);
            if (bRet)
            {
                //
                // Do the registry reset
                //
                hr = DoRegReset(hKey, hInf, szComponentName, lpUserName);

                if (FAILED(hr))
                {
                    DPF(REGerr,
                        TEXT("Failed to do registry migration for [%s] schemes"),
                        szComponentName);
                    break;
                }
            }
        }

        if (!bRet)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    DPF(REGmsg, TEXT("Exit MigrateRegSchemes:"));

    return hr;
}


HRESULT DoRegReset(
    HKEY    hKey,           // Handle to root key
    HINF    hInf,           // Handle to template INF
    LPCTSTR lpSection,      // Section name in INF
    LPCTSTR lpUserName      // User name
)
{
#define     MAX_VALUE_DATA_RESET_FIELD      6
#define     MAX_VALUE_NAME_RESET_FIELD      4
#define     MAX_KEY_NAME_RESET_FIELD        4

    HRESULT    hr = S_OK;
    BOOL       bRet;
    HKEY       hRootKey;
    LONG       lItemCount;
    LONG       lLineCount;
    INFCONTEXT context;
    LPTSTR     lpSubKey;
    LPTSTR     lpOutputKey;
    LPTSTR     lpField[16];
    DWORD      i;
    DWORD      dwLastField[] = { 
        MAX_VALUE_DATA_RESET_FIELD,
        MAX_VALUE_NAME_RESET_FIELD,
        MAX_KEY_NAME_RESET_FIELD,
        MAX_KEY_NAME_RESET_FIELD,
    };
    
    if (hInf == INVALID_HANDLE_VALUE || lpSection == NULL)
    {
        return E_INVALIDARG;
    }

    DPF(REGmsg, TEXT("Enter DoRegReset for [%s] component"), lpSection);

    // Loop through all lines under current component section
    lItemCount = SetupGetLineCount(hInf, lpSection);
    for (lLineCount = 0 ; lLineCount < lItemCount ; lLineCount++)
    {
        // Get the INF context for each line under current component
        bRet = SetupGetLineByIndex(hInf, lpSection, lLineCount, &context);
        if (bRet)
        {
            TCHAR  szResetType[2];
            DWORD  dwReqSize;
            
            // Get the reset-type from field 1
            bRet = SetupGetStringField(&context,
                                       1,
                                       szResetType,
                                       ARRAYSIZE(szResetType),
                                       &dwReqSize);
            if (bRet)
            {
                LONG lResetType = _ttol(szResetType);

                hr = ReadFieldFromContext(&context, lpField, 2, dwLastField[lResetType]);
                if (SUCCEEDED(hr))
                {
                    if (hKey == NULL)
                    {
                        //
                        // Per-System reg key
                        //
                        lpOutputKey = lpField[2];
                        Str2KeyPath2(lpField[2], &hRootKey, &lpSubKey);
                    }
                    else
                    {
                        //
                        // Per-User reg key
                        //
                        lpOutputKey = lpField[2];
                        lpSubKey = lpField[2];
                        hRootKey = hKey;
                    }

                    switch (lResetType)
                    {
                    case 0:
                        if (MyStrCmpI(lpField[3], TEXT("REG_BINARY")) == 0)
                            hr = RegBinaryDataReset (hRootKey,
                                                     (LPTSTR) lpUserName,
                                                     lpSubKey,
                                                     &g_StrReplaceTable,
                                                     lpField);
                        else
                            hr = RegValueDataReset(hRootKey,
                                               (LPTSTR) lpUserName,
                                               lpSubKey,
                                               lpOutputKey,
                                               lpField);
                        break;

                    case 1:
                        hr = RegValueNameReset( hRootKey,
                                               (LPTSTR) lpUserName,
                                               lpSubKey,
                                               lpOutputKey,
                                               lpField);
                        break;
                    case 2:
                        hr = RegKeyNameReset(hRootKey,
                                             (LPTSTR) lpUserName,
                                             lpSubKey,
                                             lpOutputKey,
                                             lpField);
                        break;
                    case 3:
                        hr = RegWideMatchReset(hRootKey,
                                              (LPTSTR) lpUserName,
                                              lpSubKey,
                                              lpOutputKey,
                                              lpField);
                        break;
                    }                   

                    for (i = 0 ; i <= dwLastField[lResetType] ; i++)
                    {
                        MEMFREE(lpField[i]);
                    }
                }
            }
        }

        if (!bRet)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    DPF(REGmsg, TEXT("Exit DoRegReset for [%s] component:"), lpSection);

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   MigrateRegSchemesPerSystem
//
//  Synopsis:   Migrate Per-System scheme settings in registry to English.
//              Scheme settings can be registry value data or 
//              registry value name.
//
//  Returns:    S_OK if operation succeed
//
//  History:    03/15/2002 Rerkboos     Created
//
//  Notes:      Per-System means that the registry data is not under HKEY_USERS
//
//-----------------------------------------------------------------------------
HRESULT MigrateRegSchemesPerSystem(
    HINF hInf
)
{
    return MigrateRegSchemes(hInf, NULL, NULL);
}



//-----------------------------------------------------------------------------
//
//  Function:   MigrateRegSchemesPerUser
//
//  Synopsis:   Migrate Per-User scheme settings in registry to English.
//              Scheme settings can be registry value data or 
//              registry value name.
//
//  Returns:    S_OK if operation succeed
//
//  History:    03/15/2002 Rerkboos     Created
//
//  Notes:      This is a callback function for LoopUser() function.
//              It will be called everytime LoopUser() loads registry hive for
//              each user available in the system.
//
//-----------------------------------------------------------------------------
HRESULT MigrateRegSchemesPerUser(
    HKEY    hKeyUser,       // Handle to user's root key
    LPCTSTR lpUserName,     // User name
    LPCTSTR lpDomainName,   // Domain name of user name
    LPCTSTR lpUserSid       // Sid of user
)
{
    return MigrateRegSchemes(g_hInf, hKeyUser, lpUserName);
}

HRESULT RegBinaryDataReset (
    HKEY                hRootKey,     // Handle to root key
    LPTSTR              lpUserName,   // (optional) name of user for current hRootKey
    LPTSTR              lpSubKey,     // Sub key used to search in registry
    PREG_STRING_REPLACE lpRegStr,     // String table
    LPTSTR              lpField[])    // Pointer to field value from template file
{
    HRESULT hr = S_OK;

    if (MyStrCmpI(lpField[5], TEXT("UpdatePSTpath")) == 0)
    {
        hr = UpdatePSTpath(hRootKey, lpUserName, lpSubKey, lpField[4], lpRegStr);
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   RegValueDataReset
//
//  Synopsis:   Reset the value data in registry, one value data at a time.
//              The value data to be reset is retrieved from INF line context.
//
//  Returns:    S_OK if operation succeeded
//
//  History:    03/15/2002 Rerkboos     Created
//
//  Notes:      lpUserName can be NULL if this function is to reset per-system
//              registry settings. Otherwise, lpUserName contains user name
//              for the supplied hRootKey.
//
//-----------------------------------------------------------------------------
HRESULT RegValueDataReset(
    HKEY    hRootKey,       // Handle to root key
    LPTSTR  lpUserName,     // (optional) name of user for current hRootKey
    LPTSTR  lpSubKey,       // Sub key used to search in registry
    LPTSTR  lpOutputKey,    // Output registry to save in CLMTDO.inf
    LPTSTR  lpField[]       // Pointer to field value from template file
)
{
    HRESULT hr = S_OK;
    HKEY    hKey;
    DWORD   cbSize;
    DWORD   dwAttrib = 0;
    LONG    lRet;

    lRet = RegOpenKeyEx(hRootKey,
                        lpSubKey,
                        0,
                        KEY_WRITE | KEY_READ,
                        &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = GetRegistryValue(hRootKey,
                                lpSubKey,       // Sub key
                                lpField[4],     // Value name
                                NULL,
                                &cbSize);
        if (lRet == ERROR_SUCCESS)
        {
            LPWSTR lpValue;
            DWORD  dwType = Str2REG(lpField[3]); // Registry type

            lpValue = (LPWSTR) MEMALLOC(cbSize);
            if (lpValue)
            {
                GetRegistryValue(hRootKey,
                                 lpSubKey,
                                 lpField[4],
                                 (LPBYTE) lpValue,
                                 &cbSize);

                // Old value matches, do reg value reset
                if (MyStrCmpI(lpValue, lpField[5]) == LSTR_EQUAL)
                {
                    DPF(REGinf, TEXT("Reset registry value [%s]"), lpField[4]);

                    //
                    // Add the value data to be rename into CLMTDO.INF
                    //
                    hr = AddRegValueRename(lpOutputKey,     // Reg key
                                           lpField[4],      // Value name
                                           NULL,
                                           lpField[5],      // Old value data
                                           lpField[6],      // New value data
                                           dwType,
                                           dwAttrib,
                                           (LPTSTR) lpUserName);
                    if (FAILED(hr))
                    {
                        DPF(REGwar,
                            TEXT("Failed to add registry value [%s] to defer change"),
                            lpField[4]);
                    }
                }

                MEMFREE(lpValue);
            }
        }
        else if (lRet == ERROR_FILE_NOT_FOUND)
        {
            DPF(REGwar, TEXT("Value [%s] not found in registry"), lpField[4]);
            hr = S_FALSE;
        }
        else
        {
            DPF(REGerr, TEXT("Failed to read value [%s]"), lpField[4]);
            hr = HRESULT_FROM_WIN32(lRet);
        }

        RegCloseKey(hKey);
    }
    else if (lRet == ERROR_FILE_NOT_FOUND)
    {
        DPF(REGwar, TEXT("Key [%s] not found in registry"), lpOutputKey);
        hr = S_FALSE;
    }
    else
    {
        DPF(REGerr, TEXT("Failed to open key [%s]"), lpOutputKey);
        hr = HRESULT_FROM_WIN32(lRet);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   RegValueNameReset
//
//  Synopsis:   Reset the value name in registry, one value name at a time.
//              The value name to be reset is retrieved from INF line context.
//
//  Returns:    S_OK if operation succeeded
//
//  History:    03/15/2002 Rerkboos     Created
//
//  Notes:      lpUserName can be NULL if this function is to reset per-system
//              registry settings. Otherwise, lpUserName contains user name
//              for the supplied hRootKey.
//
//-----------------------------------------------------------------------------
HRESULT RegValueNameReset(
    HKEY    hRootKey,       // Handle to root key
    LPTSTR  lpUserName,     // (optional) name of user for current hRootKey
    LPTSTR  lpSubKey,       // Sub key used to search in registry
    LPTSTR  lpOutputKey,    // Output registry to save in CLMTDO.inf
    LPTSTR  lpField[]       // Pointer to field value from template file
)
{
    HRESULT hr = S_OK;
    HKEY    hKey;
    DWORD   cbSize;
    DWORD   dwAttrib = 0;
    LONG    lRet;

    // Do value name reset If old value name and new value name in INF are different
    if (lstrcmp((LPCTSTR) lpField[3], (LPCTSTR) lpField[4]) != LSTR_EQUAL)
    {
        lRet = RegOpenKeyEx(hRootKey,
                            lpSubKey,
                            0,
                            KEY_WRITE | KEY_READ,
                            &hKey);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = GetRegistryValue(hRootKey,
                                    lpSubKey,
                                    lpField[3],   // Old value name
                                    NULL,
                                    &cbSize);
            if (lRet == ERROR_SUCCESS)
            {
                DPF(REGinf, TEXT("Reset registry value name [%s]"), lpField[3]);

                hr = AddRegValueRename(lpOutputKey,
                                       lpField[3],      // Old value name
                                       lpField[4],      // New value name
                                       NULL,
                                       NULL,
                                       0,
                                       dwAttrib,
                                       (LPTSTR) lpUserName);
                if (FAILED(hr))
                {
                    DPF(REGwar,
                        TEXT("Failed to add registry value name [%s] to defer change list"),
                        lpField[3]);
                }
            }
            else if (lRet == ERROR_FILE_NOT_FOUND)
            {
                DPF(REGwar, TEXT("Value [%s] not found in registry"), lpField[3]);
                hr = S_FALSE;
            }
            else
            {
                DPF(REGerr, TEXT("Failed to read value [%s]"), lpField[3]);
                hr = HRESULT_FROM_WIN32(lRet);
            }

            RegCloseKey(hKey);
        }
        else if (lRet == ERROR_FILE_NOT_FOUND)
        {
            DPF(REGwar, TEXT("Key [%s] not found in registry"), lpOutputKey);
            hr = S_FALSE;
        }
        else
        {
            DPF(REGerr, TEXT("Failed to open key [%s]"), lpOutputKey);
            hr = HRESULT_FROM_WIN32(lRet);
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   RegKeyNameReset
//
//  Synopsis:   Reset the key name in registry,
//
//  Returns:    S_OK if operation succeeded
//
//  History:    03/15/2002 Rerkboos     Created
//
//  Notes:      lpUserName can be NULL if this function is to reset per-system
//              registry settings. Otherwise, lpUserName contains user name
//              for the supplied hRootKey.
//
//-----------------------------------------------------------------------------
HRESULT RegKeyNameReset(
    HKEY   hRootKey,        // Handle to root key
    LPTSTR lpUserName,      // (optional) name of user for current hRootKey
    LPTSTR lpSubKey,        // Sub key used to search in registry
    LPTSTR lpOutputKey,     // Output registry sub key to save in CLMTDO.inf
    LPTSTR lpField[]        // Pointer to field value from template file
)
{
    HRESULT hr;
    LONG    lRet;
    HKEY    hKey;
    HKEY    hOldKey;
    HKEY    hNewKey;

    // Do the key rename if old key name and new key name in INF are different
    if (lstrcmpi(lpField[3], lpField[4]) == LSTR_EQUAL)
    {
        return S_FALSE;
    }

    // Check if we can access the subkey or not
    lRet = RegOpenKeyEx(hRootKey,
                        lpSubKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        // Check the existence of old registry key
        lRet = RegOpenKeyEx(hKey,
                            lpField[3],
                            0,
                            KEY_READ | KEY_WRITE,
                            &hOldKey);
        if (lRet == ERROR_SUCCESS)
        {
            // Old reg key exists. Then, check the existence of new registry key
            lRet = RegOpenKeyEx(hKey,
                                lpField[4],
                                0,
                                KEY_READ,
                                &hNewKey);
            if (lRet == ERROR_SUCCESS)
            {
                hr = S_FALSE;
                RegCloseKey(hNewKey);
            }
            else if (lRet == ERROR_FILE_NOT_FOUND)
            {
                // New key does not exist, ok to rename the old reg key
                hr = AddRegKeyRename(lpOutputKey,
                                     lpField[3],
                                     lpField[4],
                                     lpUserName);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DPF(REGerr, TEXT("Failed to open key [%s\\%s], hr = 0x%x"), lpSubKey, lpField[4], hr);
            }

            RegCloseKey(hOldKey);
        }
        else if (lRet == ERROR_FILE_NOT_FOUND)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lRet);
            DPF(REGerr, TEXT("Failed to open key [%s\\%s], hr = 0x%x"), lpSubKey, lpField[3], hr);
        }

        RegCloseKey(hKey);
    }
    else if (lRet == ERROR_FILE_NOT_FOUND)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(lRet);
        DPF(REGerr, TEXT("Failed to open key [%s], hr = 0x%x"), lpSubKey, hr);
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   ReadFieldFromContext
//
//  Synopsis:   Read fields from INFCONTEXT
//
//  Returns:    S_OK if succeeded
//
//  History:    03/14/2001  Rerkboos    Created
//
//  Notes:      Caller must free the memory allocated in lpField[]
//
//-----------------------------------------------------------------------------
HRESULT ReadFieldFromContext(
    PINFCONTEXT lpContext,      // INFCONTEXT for each line
    LPWSTR      lpField[],      // Pointer point to each field
    DWORD       dwFirstField,   // First field to read
    DWORD       dwLastField     // Last field to read
)
{
    HRESULT hr = S_OK;
    DWORD   dwFieldIndex;
    DWORD   cchField;
    DWORD   cchReqSize;

    for (dwFieldIndex = 0 ; dwFieldIndex <= dwLastField ; dwFieldIndex++)
    {
        lpField[dwFieldIndex] = NULL;
    }

    //
    // Read data INF context into field buffer
    //
    for (dwFieldIndex = dwFirstField ; dwFieldIndex <= dwLastField ; dwFieldIndex++)
    {
        // Get the require size big enough to store data
        if (SetupGetStringField(lpContext,
                                dwFieldIndex,
                                NULL,
                                0,
                                &cchField))
        {
            //Add one more space in case the string converted to MultiSZ
            cchField ++;
            lpField[dwFieldIndex] = (LPWSTR) MEMALLOC(cchField * sizeof(TCHAR));

            if (lpField[dwFieldIndex] == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            // Read data from INF to buffer
            SetupGetStringField(lpContext,
                                dwFieldIndex,
                                lpField[dwFieldIndex],
                                cchField,
                                &cchReqSize);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    }

    // Free all the allocated memory if any error occured
    if (FAILED(hr))
    {
        for (dwFieldIndex = 0 ; dwFieldIndex <= dwLastField ; dwFieldIndex++)
        {
            if (lpField[dwFieldIndex])
            {
                MEMFREE(lpField[dwFieldIndex]);
            }
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetRegistryValue
//
//  Synopsis:   Wrapper function to get registry value
//
//  Returns:    ERROR_SUCCESS if value is successefully get
//
//  History:    03/14/2001  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
LONG GetRegistryValue(
    HKEY    hRootKey,
    LPCTSTR lpSubKey,
    LPCTSTR lpValueName,
    LPBYTE  lpBuffer,
    LPDWORD lpcbBuffer
)
{
    LONG  lStatus;
    HKEY  hKey;
    DWORD dwSize;

    lStatus = RegOpenKeyEx(hRootKey,
                           lpSubKey,
                           0,
                           KEY_READ,
                           &hKey);
    if (lStatus == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);
        lStatus = RegQueryValueEx(hKey,
                                  lpValueName,
                                  NULL,
                                  NULL,
                                  lpBuffer,
                                  lpcbBuffer);
        RegCloseKey(hKey);
    }

    return lStatus;
}



//-----------------------------------------------------------------------------
//
//  Function:   SetRegistryValue
//
//  Synopsis:   Wrapper function to set registry value
//
//  Returns:    ERROR_SUCCESS if value is successefully set
//
//  History:    03/14/2001  Rerkboos    Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
LONG SetRegistryValue(
    HKEY    hRootKey,
    LPCTSTR lpSubKey,
    LPCTSTR lpValueName,
    DWORD   dwType,
    LPBYTE  lpData,
    DWORD   cbData
)
{
    LONG lStatus;
    HKEY hKey;

    lStatus = RegCreateKeyEx(hRootKey,
                             lpSubKey,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKey,
                             NULL);
    if (lStatus == ERROR_SUCCESS)
    {
        lStatus = RegSetValueEx(hKey,
                                lpValueName,
                                0,
                                dwType,
                                lpData,
                                cbData);
        RegCloseKey(hKey);
    }

    return lStatus;
}


//--------------------------------------------------------------------------
//
//  My_QueryValueEx
//
//  wraps RegQueryValueEx and ensures that the returned string is NULL-
//  terminated
//
//--------------------------------------------------------------------------

LONG My_QueryValueEx(
    HKEY hKey,            // handle to key
    LPCTSTR lpValueName,  // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // type buffer
    LPBYTE lpData,        // data buffer
    LPDWORD lpcbData      // size of data buffer
)
{
    DWORD   dwMyType;
    LONG    lRes;
    LPDWORD lpCurrType = &dwMyType;
    DWORD   cbOriginalDataSize = 0;
    LPBYTE  lpBuf = NULL;

    if (lpType)
    {
        lpCurrType = lpType;
    }
    if (lpcbData)
    {
        cbOriginalDataSize = *lpcbData;
    }
    
    lRes = RegQueryValueEx(hKey, lpValueName, lpReserved, lpCurrType, lpData, lpcbData);

    if (lRes == ERROR_SUCCESS
        && IsRegStringType(*lpCurrType)
        && lpcbData
        && bIsValidRegStr(*lpCurrType,*lpcbData)
        )
    {
        LPTSTR psz;
        int cch = (int)(*lpcbData/sizeof(TCHAR));

        if (!lpData) // in this case user is query the buffer size needed
        {
            lpBuf = (LPBYTE) calloc(*lpcbData, sizeof(BYTE));
            if (!lpBuf) {
                lRes = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }

            lRes = RegQueryValueEx(hKey, lpValueName, lpReserved, lpCurrType, lpBuf, lpcbData);
            if (lRes != ERROR_SUCCESS)
                goto Exit;

            psz = (LPTSTR)lpBuf;
            if (psz[cch-1])
                *lpcbData += 2 * sizeof(TCHAR);
            else if (psz[cch-2])
                *lpcbData += sizeof(TCHAR);
        }
        else
        {
            psz = (LPTSTR)lpData;
            if (REG_MULTI_SZ == *lpCurrType) 
            {    
                if (psz[cch-1])
                {
                    if (*lpcbData >= (cbOriginalDataSize-sizeof(TCHAR)))
                    {
                        lRes = ERROR_MORE_DATA;
                    }
                    else
                    {
                        psz[cch] = 0;
                        psz[cch+1] = 0;
                        *lpcbData += 2 * sizeof(TCHAR);
                    }
                }
                else if (psz[cch-2])
                {
                    if (*lpcbData >= cbOriginalDataSize)
                    {
                        lRes = ERROR_MORE_DATA;
                    }
                    else
                    {
                        psz[cch] = 0;
                        *lpcbData += sizeof(TCHAR);
                    }
                }
            }
            else
            {
                if (psz[cch-1])
                {
                    if (*lpcbData >= cbOriginalDataSize)
                    {
                        lRes = ERROR_MORE_DATA;
                    }
                    else
                    {
                        psz[cch] = 0;
                        *lpcbData += sizeof(TCHAR);
                    }
                }
            }
        }
    }

Exit:
    if (lpBuf)
        free (lpBuf);

    return lRes;
}

BOOL bIsValidRegStr(
    DWORD dwType,
    DWORD cbLen)
{
    if (!IsRegStringType(dwType))
    {
        return FALSE;
    }
    if (dwType == REG_MULTI_SZ)
    {
        if (cbLen < 2 * sizeof(TCHAR))
        {
            return FALSE;
        }
    }
    else
    {
        if (cbLen <  sizeof(TCHAR))
        {
            return FALSE;
        }
    }
#ifdef UNICODE
    if ( (cbLen % sizeof(TCHAR)) == 1 )
    {
        return FALSE;
    }
#endif
    return TRUE;
}

LONG MyRegSetDWValue(
    HKEY    hRootKey,           // Root key
    LPCTSTR lpSubKeyName,       // Sub key name under HKEY_Users\{user hive}
    LPCTSTR lpValueName,        //  value name to be changed
    LPCTSTR lpNewValue)         // New value
{
    LONG        lRet;
    HKEY        hKey = NULL;
    DWORD       dwVal;
    lRet = RegOpenKeyEx(hRootKey,
                        lpSubKeyName,
                        0,
                        KEY_WRITE | KEY_READ,
                        &hKey);
    if (ERROR_SUCCESS != lRet)
    {
        hKey = NULL;
        goto exit;
    }
    dwVal = _tstoi(lpNewValue);
    lRet = RegSetValueEx(hKey,lpValueName,0,REG_DWORD,(LPBYTE)&dwVal,sizeof(DWORD));
exit:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return lRet;    
}

HRESULT RegWideMatchReset(
    HKEY   hRootKey,        // Handle to root key
    LPTSTR lpUserName,      // (optional) name of user for current hRootKey
    LPTSTR lpSubKey,        // Sub key used to search in registry
    LPTSTR lpOutputKey,     // Output registry sub key to save in CLMTDO.inf
    LPTSTR lpField[])       // Pointer to field value from template file
{
    REG_STRING_REPLACE          myTable;
    HKEY                        hKey;
    LONG                        lRet;
    HRESULT                     hr;

    hr = Sz2MultiSZ(lpField[3],TEXT(';'));
    if (FAILED(hr))
    {
        goto exit;
    }
    hr = Sz2MultiSZ(lpField[4],TEXT(';'));
    if (FAILED(hr))
    {
        goto exit;
    }
    hr = ConstructUIReplaceStringTable(lpField[3], lpField[4],&myTable);
    if (FAILED(hr))
    {
        goto exit;
    }
    lRet = RegOpenKeyEx(hRootKey,
                        lpSubKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey);
    if (ERROR_SUCCESS != lRet)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        goto exit;
    }
    hr = RegistryAnalyze(hKey,lpUserName,NULL,&myTable,NULL,0,lpOutputKey,FALSE);
exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\stdafx.h ===
#include "clmt.h"
#include <shlwapi.h>
#include <objbase.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\table.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    Cross Language Migration Tools String-Search/Replacemet Util

Author:

    Xiaofeng Zang (xiaoz) 17-Sep-2001  Created

Revision History:
    
--*/


#include "StdAfx.h"
#include "clmt.h"


#ifdef NEVER
LONG UpdateMszTableInReg(HKEY,LPTSTR,LPTSTR*,LPTSTR);
LONG UpdateDWORDArrayInReg(HKEY,LPTSTR,PDWORD*,DWORD);
#endif

BOOL AddItemToStrRepaceTable(
     LPTSTR szUserName,
     LPTSTR szOriginalStr,
     LPTSTR szReplacingStr,
     LPTSTR szFullPathStr,
     DWORD  nId,
     PREG_STRING_REPLACE pTable)
{
    if (!szUserName || !szOriginalStr || !szReplacingStr || !szFullPathStr)
    {
        return FALSE;
    }
    if (!szUserName[0] || !szOriginalStr[0] || !szReplacingStr[0] || !szFullPathStr[0])
    {
        return FALSE;
    }
    if (!MyStrCmpI(szOriginalStr,szReplacingStr))
    {
        return TRUE;
    }

    if (!AppendSzToMultiSz(szUserName,
                      &(pTable->szUserNameLst),
                      &(pTable->cchUserName)))
    {
        return FALSE;
    }


    if (!AppendSzToMultiSz(szOriginalStr,
                      &(pTable->lpSearchString),
                      &(pTable->cchSearchString)))
    {
        return FALSE;
    }
    if (!AppendSzToMultiSz(szReplacingStr,
                      &(pTable->lpReplaceString),
                      &(pTable->cchReplaceString)))
    {
        return FALSE;
    }

    if (!AppendSzToMultiSz(szFullPathStr,
                      &(pTable->lpFullStringList),
                      &(pTable->cchFullStringList)))
    {
    }
    if ((pTable->nNumOfElem+1) > pTable->cchAttribList)
    {
        LPDWORD lpTmp = malloc( (pTable->cchAttribList + DWORD_BUF_DELTA) * sizeof(DWORD) );
        if (!lpTmp)
        {
            return FALSE;
        }
        memcpy((PBYTE)lpTmp,(PBYTE)pTable->lpAttrib,pTable->cchAttribList * sizeof(DWORD));
        free(pTable->lpAttrib);
        pTable->lpAttrib = lpTmp;
        pTable->cchAttribList += DWORD_BUF_DELTA;
    }
    pTable->lpAttrib[pTable->nNumOfElem] = nId;
    pTable->nNumOfElem++;

    return TRUE;
}






BOOL InitStrRepaceTable()
{
    BOOL        bRet = TRUE;
    int         i, n;

  
    //Initialize the global table used to do string replacement

    g_StrReplaceTable.nNumOfElem = 0;


    g_StrReplaceTable.szUserNameLst = malloc(MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    if (!g_StrReplaceTable.szUserNameLst )
    {
        bRet = FALSE;
        goto Cleanup;
    }
    memset(g_StrReplaceTable.szUserNameLst,0,MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    
    g_StrReplaceTable.cchUserName = MULTI_SZ_BUF_DELTA;

    
    g_StrReplaceTable.lpSearchString = malloc(MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    if (!g_StrReplaceTable.lpSearchString )
    {
        bRet = FALSE;
        goto Cleanup;
    }
    memset(g_StrReplaceTable.lpSearchString,0,MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    
    g_StrReplaceTable.cchSearchString = MULTI_SZ_BUF_DELTA;
    

    g_StrReplaceTable.lpReplaceString = malloc(MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    if (!g_StrReplaceTable.lpReplaceString )
    {
        bRet = FALSE;
        goto Cleanup;
    }
    memset(g_StrReplaceTable.lpReplaceString,0,MULTI_SZ_BUF_DELTA * sizeof(TCHAR));    
    g_StrReplaceTable.cchReplaceString = MULTI_SZ_BUF_DELTA;


    g_StrReplaceTable.lpFullStringList = malloc(MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    if (!g_StrReplaceTable.lpFullStringList )
    {
        bRet = FALSE;
        goto Cleanup;
    }
    g_StrReplaceTable.cchFullStringList = MULTI_SZ_BUF_DELTA;
    memset(g_StrReplaceTable.lpFullStringList,0,MULTI_SZ_BUF_DELTA * sizeof(TCHAR));
    
    
    
    g_StrReplaceTable.lpAttrib = malloc(DWORD_BUF_DELTA * sizeof(DWORD)) ;
    if (!g_StrReplaceTable.lpAttrib)
    {
        bRet = FALSE;
        goto Cleanup;
    }
    memset(g_StrReplaceTable.lpAttrib,0,DWORD_BUF_DELTA * sizeof(DWORD));
    g_StrReplaceTable.cchAttribList = DWORD_BUF_DELTA;

Cleanup:
    if (!bRet)
    {
        if (g_StrReplaceTable.lpSearchString)
        {
            free(g_StrReplaceTable.lpSearchString);
            g_StrReplaceTable.lpSearchString = NULL;
        }
        if (g_StrReplaceTable.lpReplaceString)
        {
            free(g_StrReplaceTable.lpReplaceString);
            g_StrReplaceTable.lpReplaceString = NULL;
        }
        if (g_StrReplaceTable.lpAttrib)
        {
            free(g_StrReplaceTable.lpAttrib);
            g_StrReplaceTable.lpAttrib = NULL;
        }       
        if (g_StrReplaceTable.lpFullStringList)
        {
            free(g_StrReplaceTable.lpFullStringList);
            g_StrReplaceTable.lpFullStringList = NULL;
        }       
    }
    return bRet;
}



void DeInitStrRepaceTable()
{
    if (g_StrReplaceTable.lpSearchString)
    {
        free(g_StrReplaceTable.lpSearchString);
        g_StrReplaceTable.lpSearchString = NULL;
    }
    if (g_StrReplaceTable.lpReplaceString)
    {
        free(g_StrReplaceTable.lpReplaceString);
        g_StrReplaceTable.lpReplaceString = NULL;
    }
    if (g_StrReplaceTable.lpAttrib)
    {
        free(g_StrReplaceTable.lpAttrib);
        g_StrReplaceTable.lpAttrib = NULL;
    }       
    if (g_StrReplaceTable.lpFullStringList)
    {
        free(g_StrReplaceTable.lpFullStringList);
        g_StrReplaceTable.lpFullStringList = NULL;
    }   
    if (g_StrReplaceTable.szUserNameLst)
    {
        free(g_StrReplaceTable.szUserNameLst);
        g_StrReplaceTable.szUserNameLst = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\resource.h ===
#define IDS_ADMIN                       1000
#define IDS_REBOOT_STRING               1001
#define IDS_LOGOFF_STRING               1002
#define IDS_MAIN_TITLE                  1003
#define IDS_NT5                         1004
#define IDS_OUT_OF_MEMORY               1005
#define IDS_ALREADY_RUNNING             1006
#define IDS_CREATE_INF_FAILURE          1007
#define IDS_GENERAL_WRITE_FAILURE       1008
#define IDS_OPEN_INF_FAILURE            1009
#define IDS_NEC98                       1010
#define IDS_IA64                        1011
#define IDS_ON_TS_CLIENT                1012
#define IDS_TS_ENABLED                  1013
#define IDS_TS_CLOSE_SESSION            1014
#define IDS_ASKFORWINNT32               1015
#define IDS_TRY_AGAIN                   1016
#define IDS_OPERATION_NOT_LEGAL         1017
#define IDS_IIS_SERVICE                 1018
#define IDS_IIS_ERROR                   1019
#define IDS_WINNT32_CANCEL              1020
#define IDS_UNLOCALIZED_WARNING         1021
#define IDS_BLOCKING_WARNING            1022
#define IDS_ASKING_CONVERT_TO_NTFS      1023
#define IDS_OK                          1024
#define IDS_START                       1025
#define IDS_CANCEL                      1026
#define IDS_REMIND_DO_CRITICAL          1027
#define IDS_REBOOTING                   1028
#define IDS_CONFIRM                     1029
#define IDS_CRITICALUPDATING            1030
#define IDS_REMIND_HARDLINK             1031
#define IDS_OWNERSHIP                   1032
#define IDS_ADMINCHANGE                 1033
#define IDS_LANG_NOTSUPPORTED           1034
#define IDS_SDBERROR                    1035
#define IDS_FATALERROR                  1036
#define IDS_PRODUCT_NAME                1037
#define IDS_CLOSE_APP_TEXT              1038
#define IDS_ADMIN_LOGON_DOTNET          1039
#define IDS_CLMT_ACCT_CHANGE_TITLE      1040
#define IDS_BAD_OPERATION_ORIGINAL      1041
#define IDS_BAD_OPERATION_MIGDONE       1042
#define IDS_BAD_OPERATION_FINISH        1043
#define IDS_NT5SP2                      1044
#define IDS_DC_REPLICA_OFFLINE          1045
#define IDS_README_NOT_FOUND            1046
#define IDS_STARTUP_DLG_HEADER          1047
#define IDS_STARTUP_DLG_INFO            1048
#define IDS_ADMIN_RELOGON               1049
#define IDS_WRONG_CD                    1050
#define IDS_CONFIRM_OPERATION           1051

#define IDC_TEXT                        1500
#define IDC_STATIC                      1501
#define IDC_PROGRESS                    1502
#define IDC_ADMINTEXT                   1503
#define IDC_STARTUP_TEXT                1504

#define ID_CONTINUE                     1600
#define ID_STOP                         1601
#define ID_CAPTION1                     1602
#define ID_CAPTION2                     1603
#define ID_BUTTON_1                     1604
#define ID_BUTTON_2                     1605
#define ID_STARTUP_DLG_HEADER           1606
#define ID_STARTUP_DLG_NEXT             1607
#define ID_STARTUP_DLG_README           1608
#define ID_STARTUP_DLG_CANCEL           1609
#define ID_STARTUP_DLG_INFO             1610
#define ID_UPDATE_DONE                  1611

#define IDD_UPGRADE_LOG_TEXT            2000
#define IDD_UPDATESYSTEM                2001
#define IDD_STARTUP_DLG                 2002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\shell.c ===
#include "StdAfx.h"
#include "clmt.h"

HRESULT VerifyRegistryLinesWithSystemRegistry(HKEY, HINF, LPCTSTR, BOOL*);
HRESULT UpdateSystemRegistryWithRegistryLines(HKEY, HINF, LPCTSTR, LPCTSTR);
HRESULT CheckAndAddHardLinkLine(HINF, LPCTSTR, LPTSTR);



#define FOLDER(csidl, strid,ids, valuename)   \
    { csidl, strid, ids, valuename}

FOLDER_INFO c_rgFolderInfo[] = 
{
FOLDER(             CSIDL_DESKTOPDIRECTORY, 
                    TEXT("CSIDL_DESKTOPDIRECTORY"),
                    0, 
                    TEXT("Desktop")),

    // _STARTUP is a subfolder of _PROGRAMS is a subfolder of _STARTMENU -- keep that order
FOLDER(             CSIDL_STARTUP,    
                    TEXT("CSIDL_STARTUP"),
                    0, 
                    TEXT("Startup")),
                    
FOLDER(             CSIDL_PROGRAMS,   
                    TEXT("CSIDL_PROGRAMS"),
                    0, 
                    TEXT("Programs")),

FOLDER(             CSIDL_STARTMENU,  
                    TEXT("CSIDL_STARTMENU"),
                    0, 
                    TEXT("Start Menu")),

FOLDER(             CSIDL_RECENT,
                    TEXT("CSIDL_RECENT"),
                    0, 
                    TEXT("Recent")),

FOLDER(             CSIDL_SENDTO,     
                    TEXT("CSIDL_SENDTO"),
                    0, 
                    TEXT("SendTo")),

FOLDER(             CSIDL_PERSONAL,   
                    TEXT("CSIDL_PERSONAL"),
                    0, 
                    TEXT("Personal")),
                    
FOLDER(             CSIDL_FAVORITES,  
                    TEXT("CSIDL_FAVORITES"),
                    0, 
                    TEXT("Favorites")),

FOLDER(             CSIDL_NETHOOD,    
                    TEXT("CSIDL_NETHOOD"),
                    0, 
                    TEXT("NetHood")),

FOLDER(             CSIDL_PRINTHOOD,  
                    TEXT("CSIDL_PRINTHOOD"),
                    0, 
                    TEXT("PrintHood")),
                    
FOLDER(             CSIDL_TEMPLATES,  
                    TEXT("CSIDL_TEMPLATES"),
                    0, 
                    TEXT("Templates")),

    // Common special folders

    // _STARTUP is a subfolder of _PROGRAMS is a subfolder of _STARTMENU -- keep that order

FOLDER(             CSIDL_COMMON_STARTUP,  
                    TEXT("CSIDL_COMMON_STARTUP"),
                    0,    
                    TEXT("Common Startup")),
                    
FOLDER(             CSIDL_COMMON_PROGRAMS,  
                    TEXT("CSIDL_COMMON_PROGRAMS"),
                    0,  
                    TEXT("Common Programs")),
                    
FOLDER(             CSIDL_COMMON_STARTMENU, 
                    TEXT("CSIDL_COMMON_STARTMENU"),
                    0, 
                    TEXT("Common Start Menu")),
                    
FOLDER(             CSIDL_COMMON_DESKTOPDIRECTORY, 
                    TEXT("CSIDL_COMMON_DESKTOPDIRECTORY"),
                    0, 
                    TEXT("Common Desktop")),
                    
FOLDER(             CSIDL_COMMON_FAVORITES, 
                    TEXT("CSIDL_COMMON_FAVORITES"),
                    0, 
                    TEXT("Common Favorites")),

FOLDER(             CSIDL_COMMON_APPDATA,   
                    TEXT("CSIDL_COMMON_APPDATA"),
                    0,   
                    TEXT("Common AppData")),

FOLDER(             CSIDL_COMMON_TEMPLATES, 
                    TEXT("CSIDL_COMMON_TEMPLATES"),
                    0, 
                    TEXT("Common Templates")),
                    
FOLDER(             CSIDL_COMMON_DOCUMENTS, 
                    TEXT("CSIDL_COMMON_DOCUMENTS"),
                    0, 
                    TEXT("Common Documents")),

    // Application Data special folder
FOLDER(             CSIDL_APPDATA, 
                    TEXT("CSIDL_APPDATA"),
                    0, 
                    TEXT("AppData")),
                    
FOLDER(             CSIDL_LOCAL_APPDATA, 
                    TEXT("CSIDL_LOCAL_APPDATA"),
                    0, 
                    TEXT("Local AppData")),

    // Per-user Internet-related folders

FOLDER(             CSIDL_INTERNET_CACHE, 
                    TEXT("CSIDL_INTERNET_CACHE"),
                    0, 
                    TEXT("Cache")),
                    
FOLDER(             CSIDL_COOKIES, 
                    TEXT("CSIDL_COOKIES"),
                    0, 
                    TEXT("Cookies")),

FOLDER(             CSIDL_HISTORY, 
                    TEXT("CSIDL_HISTORY"),
                    0, 
                    TEXT("History")),

                   
FOLDER(             CSIDL_MYPICTURES, 
                    TEXT("CSIDL_MYPICTURES"),
                    0,
                    TEXT("My Pictures")),


FOLDER(             CSIDL_ADMINTOOLS,         
                    TEXT("CSIDL_ADMINTOOLS"),
                    0, 
                    TEXT("Administrative Tools")),

FOLDER(             CSIDL_COMMON_ADMINTOOLS,  
                    TEXT("CSIDL_COMMON_ADMINTOOLS"),                        
                    0, 
                    TEXT("Common Administrative Tools")),

FOLDER(             CSIDL_MYMUSIC, 
                    TEXT("CSIDL_MYMUSIC"),
                    0, 
                    TEXT("My Music")),


FOLDER(             CSIDL_COMMON_PICTURES,
                    TEXT("CSIDL_COMMON_PICTURES"),
                    0, 
                    TEXT("CommonPictures")),

FOLDER(             CSIDL_COMMON_MUSIC, 
                    TEXT("CSIDL_COMMON_MUSIC"),
                    0, 
                    TEXT("CommonMusic")),
//Private defined ID , points to %USERPROFILE%\Local Settings
FOLDER(             CSIDL_QUICKLAUNCH, 
                    TEXT("CSIDL_QUICKLAUNCH"),
                    0, 
                    TEXT("Quick Launch")),
FOLDER(             CSIDL_COMMON_COMMONPROGRAMFILES_SERVICES, 
                    TEXT("CSIDL_COMMON_COMMONPROGRAMFILES_SERVICES"),
                    0, 
                    TEXT("Services")),
FOLDER(             CSIDL_COMMON_PROGRAMFILES_ACCESSARIES, 
                    TEXT("CSIDL_COMMON_PROGRAMFILES_ACCESSARIES"),
                    0, 
                    TEXT("Accessaries")),
FOLDER(             CSIDL_COMMON_PROGRAMFILES_WINNT_ACCESSARIES, 
                    TEXT("CSIDL_COMMON_PROGRAMFILES_WINNT_ACCESSARIES"),
                    0, 
                    TEXT("Accessaries")),
FOLDER(             CSIDL_LOCAL_SETTINGS, 
                    TEXT("CSIDL_LOCAL_SETTINGS"),
                    0, 
                    TEXT("Local Settings")),
//Private defined ID , points to %ALLUSERSPROFILE%\%Start_Menu%\%Programs%\%Accessories%
FOLDER(             CSIDL_COMMON_ACCESSORIES, 
                    TEXT("CSIDL_COMMON_ACCESSORIES"),
                    0, 
                    TEXT("Local Settings")),
//Private defined ID , points to "%USERPROFILE%\%Start_Menu%\%Programs%\%Accessories%
FOLDER(             CSIDL_ACCESSORIES, 
                    TEXT("CSIDL_ACCESSORIES"),
                    0, 
                    TEXT("Local Settings")),

FOLDER(             CSIDL_PF_ACCESSORIES, 
                    TEXT("CSIDL_PF_ACCESSORIES"),
                    0, 
                    TEXT("PF_AccessoriesName")),

FOLDER(             CSIDL_PROGRAM_FILES_COMMON, 
                    TEXT("CSIDL_PROGRAM_FILES_COMMON"),
                    0, 
                    TEXT("CommonFilesDir")),

FOLDER(             CSIDL_PROGRAM_FILES, 
                    TEXT("CSIDL_PROGRAM_FILES"),
                    0, 
                    TEXT("ProgramFilesDir")),

FOLDER(             CSIDL_PROFILES_DIRECTORY, 
                    TEXT("CSIDL_PROFILES_DIRECTORY"),
                    0, 
                    TEXT("ProfilesDirectory")),
//Private defined ID , points to "%USERPROFILE%\%Start_Menu%\%Programs%\%Accessories%
FOLDER(             CSIDL_COMMON_ACCESSORIES_ACCESSIBILITY, 
                    TEXT("CSIDL_COMMON_ACCESSORIES_ACCESSIBILITY"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_ACCESSORIES_ENTERTAINMENT, 
                    TEXT("CSIDL_COMMON_ACCESSORIES_ENTERTAINMENT"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_ACCESSORIES_SYSTEM_TOOLS, 
                    TEXT("CSIDL_COMMON_ACCESSORIES_SYSTEM_TOOLS"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS, 
                    TEXT("CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_ACCESSORIES_MS_SCRIPT_DEBUGGER, 
                    TEXT("CSIDL_COMMON_ACCESSORIES_MS_SCRIPT_DEBUGGER"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_ACCESSORIES_GAMES,
                    TEXT("CSIDL_COMMON_ACCESSORIES_GAMES"),
                    0,
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_WINDOWSMEDIA, 
                    TEXT("CSIDL_COMMON_WINDOWSMEDIA"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_COVERPAGES, 
                    TEXT("CSIDL_COMMON_COVERPAGES"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_RECEIVED_FAX, 
                    TEXT("CSIDL_COMMON_RECEIVED_FAX"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_SENT_FAX, 
                    TEXT("CSIDL_COMMON_SENT_FAX"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_FAX, 
                    TEXT("CSIDL_COMMON_FAX"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_COMMON_PICTURES, 
                    TEXT("CSIDL_COMMON_PICTURES"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_FAVORITES_LINKS, 
                    TEXT("CSIDL_FAVORITES_LINKS"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_FAVORITES_MEDIA, 
                    TEXT("CSIDL_FAVORITES_MEDIA"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_ACCESSORIES_ACCESSIBILITY, 
                    TEXT("CSIDL_ACCESSORIES_ACCESSIBILITY"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_ACCESSORIES_SYSTEM_TOOLS, 
                    TEXT("CSIDL_ACCESSORIES_SYSTEM_TOOLS"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_ACCESSORIES_ENTERTAINMENT, 
                    TEXT("CSIDL_ACCESSORIES_ENTERTAINMENT"),
                    0, 
                    TEXT("ProfilesDirectory")),
FOLDER(             CSIDL_ACCESSORIES_COMMUNICATIONS,
                    TEXT("CSIDL_ACCESSORIES_COMMUNICATIONS"),
                    0,
                    TEXT("ProfileDirectory")),
FOLDER(             CSIDL_ACCESSORIES_COMMUNICATIONS_HYPERTERMINAL,
                    TEXT("CSIDL_ACCESSORIES_COMMUNICATIONS_HYPERTERMINAL"),
                    0,
                    TEXT("ProfileDirectory")),
FOLDER(             CSIDL_UAM_VOLUME,
                    TEXT("CSIDL_UAM_VOLUME"),
                    0,
                    TEXT("Microsoft UAM Volume")),
FOLDER(             CSIDL_COMMON_SHAREDTOOLS_STATIONERY,
                    TEXT("CSIDL_COMMON_SHAREDTOOLS_STATIONERY"),
                    0,
                    TEXT("Stationery")),
FOLDER(             CSIDL_NETMEETING_RECEIVED_FILES,
                    TEXT("CSIDL_NETMEETING_RECEIVED_FILES"),
                    0,
                    TEXT("Received Files")),
FOLDER(             CSIDL_COMMON_NETMEETING_RECEIVED_FILES,
                    TEXT("CSIDL_COMMON_NETMEETING_RECEIVED_FILES"),
                    0,
                    TEXT("Received Files")),                   
FOLDER(             CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS_FAX,
                    TEXT("CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS_FAX"),
                    0,
                    TEXT("Fax")),                   
FOLDER(             CSIDL_FAX_PERSONAL_COVER_PAGES,
                    TEXT("CSIDL_FAX_PERSONAL_COVER_PAGES"),
                    0,
                    TEXT("Personal Coverpages")),                   
FOLDER(             CSIDL_FAX,
                    TEXT("CSIDL_FAX"),
                    0,
                    TEXT("Fax")),                   
FOLDER              (-1, NULL, 0, NULL)
};




/*++

Routine Description:

    This routine does the shell folder renaming, notice folders may not be strictly
    Shell folder, since we extended CSIDL_????? by adding out private one in .h file

Arguments:

    csidl - shell ID(maybe our private one )
    hKeyRoot - Registry Key
    hInf - INF file handle
    szUserName - user name hKeyRoot belongs to
Return Value:

    S_OK if succeeds
--*/

HRESULT  FixFolderPath(
    INT                 csidl, 
    HKEY                hKeyRoot,
    HINF                hInf,
    LPTSTR              szUserName,
    BOOL                bCreateHardLink)
{
    const FOLDER_INFO   *pfi;
    HRESULT              hr;
    HKEY                 hk = NULL;
    TCHAR               szSection[MAX_PATH];
    INFCONTEXT          context ;
    TCHAR               szTypeReg[MAX_PATH];
    TCHAR               szKeyReg[MAX_PATH];
    TCHAR               szValueNameReg[MAX_PATH];
    TCHAR               szOrgValueReg[MAX_PATH];
    TCHAR               szNewValueReg[MAX_PATH];
    DWORD               dwTypeReg;

    int                 nOriIndexFldr,nNewIndexFldr;
    TCHAR               szPlatformFldr[MAX_PATH];
    TCHAR               szTypeFldr[MAX_PATH];
    TCHAR               szOrgValueFldr[MAX_PATH];
    TCHAR               szNewValueFldr[MAX_PATH];
    DWORD               dwPlatformFldr;
    DWORD               dwTypeFldr;
    DWORD               dwAttrib = 0;
        
    TCHAR               szPathInReg[2*MAX_PATH];
    LONG                lStatus;
    HKEY                hKey;
    LPTSTR              pSubKeyPath;
    DWORD               dwSize;
    LPTSTR              pExcluseFileList = NULL;
    BOOL                bRegistryLineAvailable = TRUE;
    TCHAR               szOrgLongPath[MAX_PATH],szNewLongPath[MAX_PATH];
    TCHAR               szOrgShortPath[MAX_PATH],szNewShortPath[MAX_PATH];
    TCHAR               szOrgShortPathTemplate[MAX_PATH],szNewShortPathTemplate[MAX_PATH];
    TCHAR               szFullPath[MAX_PATH];
    int                 nOrgPathTemplate,nNewPathTemplate;
    PREG_STRING_REPLACE pCurrTable;


    //If INF file handle is invalid, just return
    if (!hInf)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    //Try to search ID table ,see whether it's valid
    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->id == csidl)
        {
            break;
        }
    }
    
    //if it's not in our pre-defined id table, return with failure
    if (pfi->id == -1 )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    //Get the ID section name in INF file eg. [ShellFolder.CSIDL_COOKIES]
    hr = StringCchCopy(szSection,MAX_PATH,SHELL_FOLDER_PREFIX);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = StringCchCat(szSection,MAX_PATH,pfi->pszIdInString);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    
    //In folder   line , the 3rd field is localized folder name
    //                   the 4th field is english folder name
    //In the case of we are running before migration and in undo mode
    //the source is English string , while the new string should be localized one

    nOriIndexFldr = 3;
    nNewIndexFldr  = 4;

    nOrgPathTemplate = 1;
    nNewPathTemplate = 2;

    pCurrTable = &g_StrReplaceTable;


    // RERKBOOS: Change here!!!
    //
    // Check if there is a Registry line for this CSIDL_XXX section or not
    // If there is, check if we need to modify system registry following the 
    // Registry line or not
    //
    hr = VerifyRegistryLinesWithSystemRegistry(hKeyRoot,
                                               hInf,
                                               szSection,
                                               &bRegistryLineAvailable);
    if (hr != S_OK)
    {
        goto Cleanup;
    }

    //if we arrive here , it means we need to rename that folder
    //Before we change folder, we need to know the original path's shortpatt 
    //value

    hr = StringCchCopy(szOrgLongPath,MAX_PATH,TEXT(""));
    hr = StringCchCopy(szNewLongPath,MAX_PATH,TEXT(""));
    hr = StringCchCopy(szOrgShortPathTemplate,MAX_PATH,TEXT(""));
    hr = StringCchCopy(szNewShortPathTemplate,MAX_PATH,TEXT(""));

    if (SetupFindFirstLine(hInf, szSection,SHELL_FOLDER_LONGPATH_TEMPLATE,&context))
    {
        if (!SetupGetStringField(&context,nOrgPathTemplate,szOrgLongPath,MAX_PATH,NULL)
            || !SetupGetStringField(&context,nNewPathTemplate,szNewLongPath,MAX_PATH,NULL))
        {
            hr = StringCchCopy(szOrgLongPath,MAX_PATH,TEXT(""));
            hr = StringCchCopy(szNewLongPath,MAX_PATH,TEXT(""));
        }       
    } 


    if (SetupFindFirstLine(hInf, szSection,SHELL_FOLDER_SHORTPATH_TEMPLATE,&context))
    {
        if (!SetupGetStringField(&context,nOrgPathTemplate,szOrgShortPathTemplate,MAX_PATH,NULL)
            || !SetupGetStringField(&context,nNewPathTemplate,szNewShortPathTemplate,MAX_PATH,NULL))
        {
            hr = StringCchCopy(szOrgShortPathTemplate,MAX_PATH,TEXT(""));
            hr = StringCchCopy(szNewShortPathTemplate,MAX_PATH,TEXT(""));
            hr = StringCchCopy(szFullPath,ARRAYSIZE(szFullPath),TEXT(""));
        }
        else
        {
            hr = StringCchCopy(szFullPath,ARRAYSIZE(szFullPath),szOrgShortPathTemplate);
            if (!GetShortPathName(szOrgShortPathTemplate,szOrgShortPath,MAX_PATH))
            {
                hr = StringCchCopy(szOrgShortPathTemplate,MAX_PATH,TEXT(""));
                hr = StringCchCopy(szNewShortPathTemplate,MAX_PATH,TEXT(""));
            }            
        }
    } 

    //Get the first folder line for the section just found
    if (!SetupFindFirstLine(hInf, szSection,SHELL_FOLDER_FOLDER,&context))
    {
        DWORD dw = GetLastError();
        hr = HRESULT_FROM_WIN32(dw);
        DPF (dlError,TEXT("can not find folder Key in section [%s] error %n"),szSection,dw);
        goto Cleanup;    
    } 

    do
    {
        //Folder Line has 4 basic fields
        //Field 1 :Platform means whether this should be excuted 
        //         0 = should be run both before and after migration
        //         1 = should be run only after  migration
        //         2 = should be run only before migration
        //Field 2 :Type means whether it's a folder op or file op 
        //         0 = foler opration
        //         1 = file  opration

        //Field 3/4:Original and new folder name 
        //String after Field 4 : This only happens when run after migration,
        //it contains a list of files/folders that we need to delete in original 
        //folder before we move to new folder

        if (!SetupGetStringField(&context,1,szPlatformFldr,MAX_PATH,NULL)
            || !SetupGetStringField(&context,2,szTypeFldr,MAX_PATH,NULL)
            || ! SetupGetStringField(&context,nOriIndexFldr,szOrgValueFldr,MAX_PATH,NULL)
            || ! SetupGetStringField(&context,nNewIndexFldr,szNewValueFldr,MAX_PATH,NULL))
        {
            DWORD dw = GetLastError();
            hr = HRESULT_FROM_WIN32(dw);
            DPF(dlError,TEXT("get registry info failed  in [%n],line %n  with %n !"),context.Section ,context.Line,dw);
            goto Cleanup;
        }

        dwPlatformFldr = _tstoi(szPlatformFldr);
        dwTypeFldr = _tstoi(szTypeFldr);

        if (!g_bBeforeMig )
        {
            if (dwPlatformFldr == 2)
            {
                continue;
            }
            //running after migration, we try to get exclude folder list in MultiSZ
            //if it's a folder entry
            if (dwTypeFldr == 0)
            {
                BOOL bTmp;

                bTmp = SetupGetMultiSzField(&context,5,NULL,0,&dwSize);
                if  ( bTmp && (dwSize > 1) )
                {
                    LPTSTR p;

                    pExcluseFileList = malloc(dwSize * sizeof(TCHAR));
                    if (!pExcluseFileList)
                    {
                        goto Cleanup;
                    }
                    if (!SetupGetMultiSzField(&context,5,pExcluseFileList,dwSize,&dwSize))
                    {
                        goto Cleanup;
                    }
                    p = pExcluseFileList;
                    //loop MulitSZ string and delete each file/folder
                    while (*p)
                    {
                        TCHAR szTmpFile[2*MAX_PATH];

                        hr = StringCchCopy(szTmpFile,2*MAX_PATH,szOrgValueFldr);
                        ConcatenatePaths(szTmpFile,p,MAX_PATH);
                        DeleteFile(szTmpFile);                
                        p += (lstrlen(p)+1);
                    }
                    free(pExcluseFileList);
                    pExcluseFileList = NULL;
                }
            }
        }
        else
        {
            if (dwPlatformFldr == 1)
            {
                continue;
            }
        }
        if (dwTypeFldr == 0)
        {
            hr = MyMoveDirectory(szOrgValueFldr,szNewValueFldr,TRUE,TRUE,bCreateHardLink,pfi->id);
            if (hr != S_OK)
            {
                if (FAILED(hr))
                {
                    DPF (dlError,TEXT("can not move folder from %s to %s Error: %d (%#x)"), 
                         szOrgValueFldr,szNewValueFldr,hr,hr);
                }
                goto Cleanup;
            }
        }
        else
        if (dwTypeFldr == 1)
        {
            hr = MyMoveFile(szOrgValueFldr,szNewValueFldr,TRUE,FALSE);
            //hr = MyMoveFile(szOrgValueFldr,szNewValueFldr,FALSE,FALSE);
            if (FAILED(hr))
              {
                DPF (dlError,TEXT("can not move file from %s to %s "),szOrgValueFldr,szNewValueFldr);
                goto Cleanup;
            }

        }        
    }while (SetupFindNextMatchLine(&context,SHELL_FOLDER_FOLDER,&context));

    CheckAndAddHardLinkLine(hInf,szSection,szUserName);

    //If we arrive here, we can update the registry now
    if (bRegistryLineAvailable)
    {
        hr = UpdateSystemRegistryWithRegistryLines(hKeyRoot,
                                                   hInf,
                                                   szSection,
                                                   szUserName);
    }
    if (szOrgLongPath[0])
    {
        
        if (!AddItemToStrRepaceTable(szUserName,szOrgLongPath,szNewLongPath,szFullPath,pfi->id,pCurrTable))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }
    if (szOrgShortPathTemplate[0])
    {
        TCHAR *lpOldName,*lpNewName;
        TCHAR szRoot[MAX_PATH],szOldShortPath[MAX_PATH];
        TCHAR *lpOldShortName,szNewShortName[MAX_PATH];

        if (GetShortPathName(szOrgShortPathTemplate,szOldShortPath,ARRAYSIZE(szOldShortPath)))
        {
            lpOldName = _tcsrchr(szOrgShortPathTemplate,TEXT('\\'));
            lpNewName = _tcsrchr(szNewShortPathTemplate,TEXT('\\'));
            lpOldShortName  = _tcsrchr(szOldShortPath,TEXT('\\'));
            if (lpOldName && lpNewName && lpOldShortName)
            {       
                *lpOldName = TEXT('\0');
                hr = StringCchCopy(szRoot,ARRAYSIZE(szRoot),szOrgShortPathTemplate);
                *lpOldName = TEXT('\\');
                hr = MyGetShortPathName(szRoot,lpOldName+1,lpNewName+1,
                                        szNewShortName,ARRAYSIZE(szNewShortName));

                if ( (S_OK == hr) && MyStrCmpI(lpOldShortName,szNewShortName))
                {
                    if (!AddItemToStrRepaceTable(szUserName,
                                            lpOldShortName+1,
                                            szNewShortName,
                                            szOldShortPath,
                                            pfi->id|0xffff0000,
                                            pCurrTable))
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                }
            }
        }
    }
    hr = S_OK;    
Cleanup:
    if (pExcluseFileList)
    {
        free(pExcluseFileList);
    }
    return (hr);
}


/*++

Routine Description:

    This routine does the shell folder renaming, notice folders may not be strictly
    Shell folder, since we extended CSIDL_????? by adding out private one in .h file

Arguments:

    hInf - INF file Handle
    hKey - Registry Key
    szUsername - user name the hKey belongs to
Return Value:

    NULL
--*/
HRESULT DoShellFolderRename(HINF hInf, HKEY hKey, LPTSTR szUsername)
{
    TCHAR               szSection[MAX_PATH];
    UINT                LineCount,LineNo;
    INFCONTEXT          InfContext;
    TCHAR               szShellCSIDL[MAX_PATH];
    const FOLDER_INFO   *pfi;
    PREG_STRING_REPLACE pCurrTable;
    HRESULT             hr;
    TCHAR               szHardLink[MAX_PATH];
    BOOL                bErrorOccured = FALSE;
    
    
#define     STRING_SHELL_FOLDER_PROCESS_PERUSER  TEXT("Shell.Folders.RenameList.PerUser")
#define     STRING_SHELL_FOLDER_PROCESS_PERSYS  TEXT("Shell.Folders.RenameList.PerSystem")
#define     ID_SHELL_FOLDER_PROCESS_PERUSER  0
#define     ID_SHELL_FOLDER_PROCESS_PERSYS  1

    if(hInf == INVALID_HANDLE_VALUE) 
    {   
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (hKey)
    {
        hr = StringCchCopy(szSection,MAX_PATH,STRING_SHELL_FOLDER_PROCESS_PERUSER);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else 
    {
        hr = StringCchCopy(szSection,MAX_PATH,STRING_SHELL_FOLDER_PROCESS_PERSYS);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    
    LineCount = (UINT)SetupGetLineCount(hInf,szSection);
    if ((LONG)LineCount < 0)
    {   
        hr = S_FALSE;
        goto Cleanup;
    }
    pCurrTable = &g_StrReplaceTable;

    for(LineNo=0; LineNo<LineCount; LineNo++)
    {
        BOOL  bCreateHardLink =  FALSE;
        if (!SetupGetLineByIndex(hInf,szSection,LineNo,&InfContext))
        {
            continue;
        }
        if (!SetupGetStringField(&InfContext,1,szShellCSIDL,MAX_PATH,NULL))
        {           
            continue;
        }
            //Try to search ID table ,see whether it's valid
        for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
        {
            if (!MyStrCmpI(pfi->pszIdInString,szShellCSIDL))
            {
                break;
            }
        }
        if (pfi->id == -1 )
        {
            continue;
        }
        if (SetupGetStringField(&InfContext,2,szHardLink,MAX_PATH,NULL))
        {           
            bCreateHardLink =  TRUE;
        }
        hr = FixFolderPath(pfi->id, hKey,hInf,szUsername,bCreateHardLink);
        if (FAILED(hr))
        {
            bErrorOccured = TRUE;
        }
    }
    if (bErrorOccured)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
    }
Cleanup:
    return hr;;
}



HRESULT VerifyRegistryLinesWithSystemRegistry(
    HKEY    hKeyRoot,
    HINF    hInf,
    LPCTSTR lpSection,
    BOOL    *pbRegistryLineAvailable
)
{
    HRESULT    hr = S_OK;
    BOOL       bRet;
    LONG       lRet;
    INFCONTEXT context;
    BOOL       bRegistryLineAvailable;
    BOOL       bNeedRegReset = TRUE;
    TCHAR      szResetType[4];
    TCHAR      szRegType[4];
    TCHAR      szValueName[MAX_PATH];
    TCHAR      szNewValueName[MAX_PATH];
    TCHAR      szNewRegKeyName[MAX_PATH];
    TCHAR      szRegKey[MAX_PATH];
    TCHAR      szOldValue[512];
    TCHAR      szNewValue[512];
    TCHAR      szValueInReg[512];
    HKEY       hKey;
    LPTSTR     lpSubKeyPath;
    LPTSTR     lpEnd;
    DWORD      cbValueInReg;
    DWORD      dwResetType;
    DWORD      dwRegType;
    DWORD      dwType;

    // Get the Registry Lines for the section just found
    bRet = SetupFindFirstLine(hInf, lpSection, SHELL_FOLDER_REGISTRY, &context);
    if (!bRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPF(dlError,
            TEXT("Cannot find Registry Key in section [%s], hr = 0x%X"),
            lpSection,
            hr);
        goto EXIT;
    }

    *pbRegistryLineAvailable = FALSE;
    bNeedRegReset = TRUE;
    while (bRet)
    {
        bRet = SetupGetStringField(&context, 1, szResetType, ARRAYSIZE(szResetType), NULL)
               && SetupGetStringField(&context, 2, szRegType, ARRAYSIZE(szRegType), NULL)
               && SetupGetStringField(&context, 3, szRegKey, ARRAYSIZE(szRegKey), NULL);
        if (bRet)
        {
            // Check if there is a registry key specified in Registry line or not
            if (szRegKey[0] != '\0')
            {
                *pbRegistryLineAvailable = TRUE;

                if (!Str2KeyPath(szRegKey, &hKey, &lpSubKeyPath))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto EXIT;
                }
 
                if (hKeyRoot)
                {
                    hKey = hKeyRoot;
                }

                dwResetType = _tcstoul(szResetType, &lpEnd, 10);
                switch (dwResetType)
                {
                //
                // Value Data reset
                //
                case 0:
                    bRet = SetupGetStringField(&context,
                                               4,
                                               szValueName,
                                               ARRAYSIZE(szValueName),
                                               NULL)
                           && SetupGetStringField(&context,
                                                  5,
                                                  szOldValue,
                                                  ARRAYSIZE(szOldValue),
                                                  NULL)
                           && SetupGetStringField(&context,
                                                  6,
                                                  szNewValue,
                                                  ARRAYSIZE(szNewValue),
                                                  NULL);
                    if (!bRet)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        DPF(dlError,
                            TEXT("Get registry info failed in section[%s], line [%d] - hr = 0x%X"),
                            context.Section,
                            context.Line,
                            hr);
                        goto EXIT;
                    }

                    if (MyStrCmpI(szOldValue, TEXT("")) != LSTR_EQUAL)
                    {
                        cbValueInReg = ARRAYSIZE(szValueInReg) * sizeof(TCHAR);
                        lRet = RegGetValue(hKey,
                                           lpSubKeyPath,
                                           szValueName,
                                           &dwType,
                                           (LPBYTE) szValueInReg,
                                           &cbValueInReg);
                        if (lRet != ERROR_SUCCESS)
                        {
                            hr = HRESULT_FROM_WIN32(lRet);
                            if (lRet == ERROR_FILE_NOT_FOUND)
                            {
                                bNeedRegReset = FALSE;
                            }
                            goto EXIT;
                        }

                        dwRegType = _tcstoul(szRegType, &lpEnd, 10);
                        switch (dwRegType)
                        {
                        case REG_SZ:
                        case REG_EXPAND_SZ:
                            if (g_bBeforeMig)
                            {
                                //If we run before upgrade, and the string in registry is not the
                                //same as original one defined in INF file, that means user customized
                                //that shell folder, we just simple return as success with failure
                                if (MyStrCmpI(szValueInReg, szOldValue) != LSTR_EQUAL)
                                {
                                    bNeedRegReset = FALSE;
                                    goto EXIT;
                                }
                            }
                            else
                            {
                                //If we run after upgrade, and the string in registry is neither the
                                //same as original one defined in INF file,nor the English string , that 
                                //means user customized that shell folder, we just simple return as 
                                //success with failure
                                if (MyStrCmpI(szValueInReg, szOldValue) != LSTR_EQUAL
                                    && MyStrCmpI(szValueInReg, szNewValue) != LSTR_EQUAL)
                                {
                                    bNeedRegReset = FALSE;
                                    goto EXIT;
                                }
                            }
                            
                            break;

                        case REG_MULTI_SZ:
                            if (g_bBeforeMig)
                            {
                                if (!MultiSzSubStr(szOldValue, szValueInReg))
                                {
                                    bNeedRegReset = FALSE;
                                    goto EXIT;
                                }
                            }
                            else
                            {
                                if (!MultiSzSubStr(szOldValue, szValueInReg)
                                    && !MultiSzSubStr(szNewValue, szValueInReg))
                                {
                                    bNeedRegReset = FALSE;
                                    goto EXIT;
                                }
                            }
                            break;
                        }
                    }

                    break;

                //
                // Value Name reset
                //
                case 1:
                    bRet = SetupGetStringField(&context,
                                               4,
                                               szValueName,
                                               ARRAYSIZE(szValueName),
                                               NULL)
                           && SetupGetStringField(&context,
                                                  5,
                                                  szNewValueName,
                                                  ARRAYSIZE(szNewValueName),
                                                  NULL);
                    if (!bRet)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        DPF(dlError,
                            TEXT("Get registry info failed in section[%s], line [%d] - hr = 0x%X"),
                            context.Section,
                            context.Line,
                            hr);
                        goto EXIT;
                    }

                    cbValueInReg = ARRAYSIZE(szValueInReg) * sizeof(TCHAR);
                    
                    if (g_bBeforeMig)
                    {
                        lRet = RegGetValue(hKey,
                                           lpSubKeyPath,
                                           szValueName,
                                           &dwType,
                                           (LPBYTE) szValueInReg,
                                           &cbValueInReg);
                        if (lRet != ERROR_SUCCESS && lRet == ERROR_FILE_NOT_FOUND)
                        {
                            bNeedRegReset = FALSE;
                            goto EXIT;
                        }
                    }
                    else
                    {
                        lRet = RegGetValue(hKey,
                                           lpSubKeyPath,
                                           szValueName,
                                           &dwType,
                                           (LPBYTE) szValueInReg,
                                           &cbValueInReg);
                        if (lRet != ERROR_SUCCESS && lRet == ERROR_FILE_NOT_FOUND)
                        {
                            lRet = RegGetValue(hKey,
                                               lpSubKeyPath,
                                               szNewValueName,
                                               &dwType,
                                               (LPBYTE) szValueInReg,
                                               &cbValueInReg);
                            if (lRet != ERROR_SUCCESS && lRet == ERROR_FILE_NOT_FOUND)
                            {
                                bNeedRegReset = FALSE;
                                goto EXIT;
                            }
                        }
                    }

                    break;

                //
                // Registry Key reset
                //
                case 2:
                    bRet = SetupGetStringField(&context,
                                               4,
                                               szNewRegKeyName,
                                               ARRAYSIZE(szNewRegKeyName),
                                               NULL);
                    if (!bRet)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        DPF(dlError,
                            TEXT("Get registry info failed in section[%s], line [%d] - hr = 0x%X"),
                            context.Section,
                            context.Line,
                            hr);
                        goto EXIT;
                    }

                    break;

                // Invalid type
                default:
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    DPF(dlError,
                        TEXT("Invalid Reset Type [%d], section [%s], line [%d]"),
                        dwResetType,
                        context.Section,
                        context.Line);
                    goto EXIT;
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF(dlError,
                TEXT("Get registry info failed in section [%s], line [%d] - hr = 0x%X"),
                context.Section,
                context.Line,
                hr);
            goto EXIT;
        }

        bRet = SetupFindNextMatchLine(&context, SHELL_FOLDER_REGISTRY, &context);
    }

EXIT:
    if (!bNeedRegReset)
    {
        hr = S_FALSE;
    }
    return hr;
}



HRESULT UpdateSystemRegistryWithRegistryLines(
    HKEY    hKeyRoot,
    HINF    hInf,
    LPCTSTR lpSection,
    LPCTSTR lpUserName
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    LONG    lRet;
    HKEY    hKey;
    TCHAR   szResetType[4];
    TCHAR   szRegType[4];
    TCHAR   szRegKey[MAX_PATH];
    TCHAR   szOldKeyName[MAX_PATH];
    TCHAR   szNewKeyName[MAX_PATH];
    TCHAR   szValueName[MAX_PATH];
    TCHAR   szNewValueName[MAX_PATH];
    TCHAR   szOldValue[512];
    TCHAR   szNewValue[512];
    TCHAR   szValueInReg[512];
    DWORD   cbValueInReg;
    LPTSTR  lpEnd;
    LPTSTR  lpSubKeyPath = NULL;
    DWORD   dwResetType;
    DWORD   dwRegType;
    DWORD   dwType;
    INFCONTEXT context;

    bRet = SetupFindFirstLine(hInf, lpSection, SHELL_FOLDER_REGISTRY, &context);
    while (bRet && SUCCEEDED(hr))
    {
        SetupGetStringField(&context, 1, szResetType, ARRAYSIZE(szResetType), NULL);
        SetupGetStringField(&context, 2, szRegType, ARRAYSIZE(szRegType), NULL);
        SetupGetStringField(&context, 3, szRegKey, ARRAYSIZE(szRegKey), NULL);

        dwResetType = _tcstoul(szResetType, &lpEnd, 10);
        dwRegType = _tcstoul(szRegType, &lpEnd, 10);

        switch (dwResetType)
        {
        case 0:
            SetupGetStringField(&context, 4, szValueName, ARRAYSIZE(szValueName), NULL);
            SetupGetStringField(&context, 5, szOldValue, ARRAYSIZE(szOldValue), NULL);
            SetupGetStringField(&context, 6, szNewValue, ARRAYSIZE(szNewValue), NULL);

            if (dwRegType == REG_MULTI_SZ)
            {
                if (!Str2KeyPath(szRegKey, &hKey, &lpSubKeyPath))
                {
                    goto EXIT;
                }

                if (hKeyRoot)
                {
                    hKey = hKeyRoot;
                }

                cbValueInReg = ARRAYSIZE(szValueInReg) * sizeof (TCHAR);

                lRet = RegGetValue(hKey,
                                   lpSubKeyPath,
                                   szValueName,
                                   &dwType,
                                   (LPBYTE) szValueInReg,
                                   &cbValueInReg);
                if (lRet == ERROR_SUCCESS)
                {
                    TCHAR   szNewMultiSz[MAX_PATH];
                    DWORD   cchNewMultiSz;
                    LPCTSTR lpNextSz;
                    LPTSTR  lpStart;
                    LPTSTR  lpMultiSz;

                    szNewMultiSz[0] = TEXT('\0');
                    szNewMultiSz[1] = TEXT('\0');
                    cchNewMultiSz = ARRAYSIZE(szNewMultiSz);
                    lpMultiSz = szNewMultiSz;

                    lpNextSz = MultiSzTok(szValueInReg);
                    while (lpNextSz != NULL)
                    {
                        lpStart = StrStrI(lpNextSz, szOldValue);
                        if (lpStart)
                        {
                            TCHAR szTemp[MAX_PATH];
                            INT   nStartReplace;
                            
                            nStartReplace = (INT) (lpStart - lpNextSz);
                            lstrcpyn(szTemp,
                                     lpNextSz,
                                     nStartReplace + 1);
                            hr = StringCchCat(szTemp,
                                              ARRAYSIZE(szTemp),
                                              szNewValue);
                            if (FAILED(hr))
                            {
                                goto EXIT;
                            }

                            nStartReplace += lstrlen(szOldValue);
                            hr = StringCchCat(szTemp,
                                              ARRAYSIZE(szTemp),
                                              (lpNextSz + nStartReplace));
                            if (FAILED(hr))
                            {
                                goto EXIT;
                            }

                            AppendSzToMultiSz(szTemp,
                                              &lpMultiSz,
                                              &cchNewMultiSz);
                        }
                        else
                        {
                            AppendSzToMultiSz(lpNextSz,
                                              &lpMultiSz,
                                              &cchNewMultiSz);
                        }

                        lpNextSz = MultiSzTok(NULL);
                    }

                    hr = AddRegValueRename(szRegKey,
                                           szValueName,
                                           NULL,
                                           szValueInReg,
                                           szNewMultiSz,
                                           dwRegType,
                                           0,
                                           (LPTSTR) lpUserName);
                }
            }
            else
            {
                hr = AddRegValueRename(szRegKey,
                                       szValueName,
                                       NULL,
                                       szOldValue,
                                       szNewValue,
                                       dwRegType,
                                       0,
                                       (LPTSTR) lpUserName);
            }
            break;

        case 1:
            SetupGetStringField(&context, 4, szValueName, ARRAYSIZE(szValueName), NULL);
            SetupGetStringField(&context, 5, szNewValueName, ARRAYSIZE(szNewValueName), NULL);

            hr = AddRegValueRename(szRegKey,
                                   szValueName,
                                   szNewValueName,
                                   NULL,
                                   NULL,
                                   dwRegType,
                                   0,
                                   (LPTSTR) lpUserName);
            break;

        case 2:
            SetupGetStringField(&context, 4, szOldKeyName, ARRAYSIZE(szOldKeyName), NULL);
            SetupGetStringField(&context, 5, szNewKeyName, ARRAYSIZE(szNewKeyName), NULL);

            hr = AddRegKeyRename(szRegKey,
                                 szOldKeyName,
                                 szNewKeyName,
                                 (LPTSTR) lpUserName);
            break;
        }

        bRet = SetupFindNextMatchLine(&context, SHELL_FOLDER_REGISTRY, &context);
    }

EXIT:
    return hr;
}



HRESULT CheckAndAddHardLinkLine(
    HINF    hInf,
    LPCTSTR lpSection,
    LPTSTR  lpUser
)
{
    HRESULT             hr = S_OK;
    INFCONTEXT          context;
    TCHAR               szType[10],szLinkValue[MAX_PATH+1],szLinkName[MAX_PATH+1];

    
    if (!SetupFindFirstLine(hInf, lpSection, TEXT("HardLink"), &context))
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    if (!SetupGetStringField(&context,1,szType,ARRAYSIZE(szType),NULL)
            || !SetupGetStringField(&context,2,szLinkName,ARRAYSIZE(szLinkName),NULL)
            || !SetupGetStringField(&context,3,szLinkValue,ARRAYSIZE(szLinkValue),NULL))
    {
        DWORD dw = GetLastError();
        hr = HRESULT_FROM_WIN32(dw);
        DPF(dlError,TEXT("get Hardlink info failed  in [%n],line %n  with %n !"),context.Section ,context.Line,dw);
        goto Cleanup;
    }    
    if (!lpUser || !MyStrCmpI(lpUser,TEXT("System")) || !MyStrCmpI(lpUser,DEFAULT_USER))
    {
        hr = AddHardLinkEntry(szLinkName, szLinkValue, szType, lpUser, NULL, NULL);
    }
Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\user.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    user.c

Abstract:

    user related option functions

Author:

    Xiaofeng Zang (xiaoz) 17-Sep-2001  Created

Revision History:

    <alias> <date> <comments>

--*/



#include "StdAfx.h"
#include "clmt.h"
#include <dsrole.h>
#include <Ntdsapi.h>
#include <wtsapi32.h>


#define MAX_FIELD_COUNT     7

#define OP_USER             0
#define OP_GRP              1
#define OP_PROFILE          2
#define OP_DOMAIN_GRP       3

#define TYPE_USER_PROFILE_PATH      1
#define TYPE_USER_SCRIPT_PATH       2
#define TYPE_USER_HOME_DIR          3
#define TYPE_TS_INIT_PROGRAM        4
#define TYPE_TS_WORKING_DIR         5
#define TYPE_TS_PROFILE_PATH        6
#define TYPE_TS_HOME_DIR            7

//
// Function prototypes used in user.c
//
HRESULT RenameDocuments_and_Settings(HINF, BOOL);

HRESULT ChangeUserInfo(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, BOOL, BOOL, BOOL);
HRESULT ChangeGroupInfo(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, BOOL, BOOL, BOOL);

HRESULT ChangeUserName(LPTSTR, LPTSTR, BOOL, BOOL);
HRESULT ChangeUserDesc(LPTSTR, LPTSTR, LPTSTR, BOOL);
HRESULT ChangeUserFullName(LPTSTR, LPTSTR, LPTSTR, BOOL);

HRESULT SetUserNetworkProfilePath(LPCTSTR, LPCTSTR);
HRESULT SetUserLogOnScriptPath(LPCTSTR, LPCTSTR);
HRESULT SetUserHomeDir(LPCTSTR, LPCTSTR);
HRESULT SetTSUserPath(LPCTSTR, LPCTSTR, WTS_CONFIG_CLASS);

HRESULT ChangeGroupName(LPTSTR, LPTSTR, BOOL, BOOL);
HRESULT ChangeGroupDesc(LPTSTR, LPTSTR, LPTSTR, BOOL, BOOL);

HRESULT ChangeRDN(LPTSTR, LPTSTR, LPTSTR, BOOL);

HRESULT AddProfileChangeItem(DWORD, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);

HRESULT PolicyGetPrivilege(LPTSTR, PLSA_HANDLE, PLSA_UNICODE_STRING*, PULONG);
HRESULT PolicySetPrivilege(LPTSTR, LSA_HANDLE, PLSA_UNICODE_STRING, ULONG);

HRESULT PreFixUserProfilePath(LPCTSTR, LPCTSTR, LPTSTR, DWORD);
BOOL   IsPathLocal(LPCTSTR);
HRESULT CheckNewBuiltInUserName(LPCTSTR, LPTSTR, DWORD);

HRESULT AddProfilePathItem(LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR, DWORD);
HRESULT AddTSProfilePathItem(LPCTSTR, LPCTSTR, LPCTSTR, WTS_CONFIG_CLASS);


//-----------------------------------------------------------------------------
//
//  Function:   UsrGrpAndDoc_and_SettingsRename
//
//  Descrip:    This routine renames user/group name and profile directory
//              specified in section [UserGrp.ObjectRename] of the INF file
//
//  Returns:    TRUE if succeeds, FALSE otherwise
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT UsrGrpAndDoc_and_SettingsRename(
    HINF hInf,      // Handle to INF file
    BOOL bTest
)
{
    INFCONTEXT InfContext;
    LONG       nLineCount, nLineIndex;
    LONG       nFieldCount, nFieldIndex;
    TCHAR      szType[MAX_PATH];
    TCHAR      szOldName[MAX_PATH];
    TCHAR      szNewName[MAX_PATH];
    TCHAR      szOldFullName[MAX_PATH];
    TCHAR      szNewFullName[MAX_PATH];
    LPTSTR     *lplpOldName;
    LPTSTR     *lplpNewName;
    LPTSTR     *lplpOldDesc;
    LPTSTR     *lplpNewDesc;
    LPTSTR     *lplpOldFullName;
    LPTSTR     *lplpNewFullName;
    LPTSTR     lpString[MAX_FIELD_COUNT + 1];
    DWORD      dwType;
    BOOL       bRet;
    BOOL       bCurrentUserRenamed;
    HRESULT    hr = S_OK;
    BOOL       bErrorOccured = FALSE;
    LPTSTR     lpszOldComment,lpszNewComment;
    size_t     cchMaxFieldLen[MAX_FIELD_COUNT + 1]; 
    DWORD      dwErr;
    PBYTE      pdsInfo;
    WCHAR      szDomainName[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL       fIsDC;


    lpszOldComment = lpszNewComment = NULL;
    for (nFieldIndex = 0 ; nFieldIndex <= MAX_FIELD_COUNT ; nFieldIndex++)
    {
        cchMaxFieldLen[nFieldIndex] = MAX_PATH;
    }
    // 1 for type, 2 one old name , 3 for new name
    // 4 and 5 are for old and new comments
    cchMaxFieldLen[4] = cchMaxFieldLen[5] = 0; 

    if (hInf == INVALID_HANDLE_VALUE) 
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //
    // Check if the machine is Domain Controller or not
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              &pdsInfo);
    if (dwErr == ERROR_SUCCESS)
    {
        DSROLE_MACHINE_ROLE dsMachineRole;

        dsMachineRole = ((DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pdsInfo)->MachineRole;

        if (dsMachineRole == DsRole_RoleBackupDomainController ||
            dsMachineRole == DsRole_RolePrimaryDomainController)
        {
            fIsDC = TRUE;
            hr = StringCchCopy(szDomainName,
                               ARRAYSIZE(szDomainName),
                               ((DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pdsInfo)->DomainNameFlat);
            if (FAILED(hr))
            {
                goto Exit;
            }
        }
        else
        {
            fIsDC = FALSE;
        }

        DsRoleFreeMemory(pdsInfo);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }
                                              

    nLineCount = SetupGetLineCount(hInf, USERGRPSECTION);
    if (nLineCount < 0)
    {   
        DPF(PROwar, TEXT("section name [%s] is empty !"), USERGRPSECTION);
        hr = S_FALSE;
        goto Exit;
    }
    

    // here we scan the whole section and find out how much space
    // needed for comments
    for(nLineIndex = 0 ; nLineIndex < nLineCount ; nLineIndex++)
    {
        if (SetupGetLineByIndex(hInf, USERGRPSECTION, nLineIndex, &InfContext))
        {
            nFieldCount = SetupGetFieldCount(&InfContext);

            // We need at least 3 fields to be valid input
            if (nFieldCount < 3)
            {
                DPF(PROerr, TEXT("section name [%s] line %d error:missing field !"), USERGRPSECTION,nLineIndex);
                hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                goto Exit;
            }

            //if there is no comments field, just skip
            if (nFieldCount < 4)
            {
                continue;
            }

            for (nFieldIndex = 4 ; nFieldIndex <= 5 ; nFieldIndex++)
            {
                DWORD cchReqSize;

                if (!SetupGetStringField(&InfContext, 
                                         nFieldIndex,
                                         NULL,
                                         0,
                                         &cchReqSize))
                {
                    DPF(PROerr,
                        TEXT("Failed to get field [%d] from line [%d] in section [%s]"),
                        nFieldIndex,
                        nLineIndex,
                        USERGRPSECTION);

                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Exit;
                }
                if (cchMaxFieldLen[nFieldIndex] < cchReqSize)
                {
                    cchMaxFieldLen[nFieldIndex] = cchReqSize;
                }
            }            
        }
        else
        {
            DPF(PROerr,
                TEXT("can not get line [%d] of section [%s]!"),
                nLineIndex,
                USERGRPSECTION);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }        
    }
    if (cchMaxFieldLen[4])
    {
        cchMaxFieldLen[4]++;
        lpszOldComment = malloc(cchMaxFieldLen[4]*sizeof(TCHAR));
    }
    if (cchMaxFieldLen[5])
    {
        cchMaxFieldLen[5]++;
        lpszNewComment = malloc(cchMaxFieldLen[5]*sizeof(TCHAR));
    }
    if ( (!lpszNewComment && lpszOldComment) || (lpszNewComment && !lpszOldComment) )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //here we do real stuff
    for(nLineIndex = 0 ; nLineIndex < nLineCount ; nLineIndex++)
    {
        // we think user name and full name should not exceed MAX_PATH
        // if we meet this, we will just ignored(skipp this line)
        // the following variable is used to flag whether we meed
        // such field.
        BOOL bMeetUnexpectedLongField = FALSE;

        lpString[1] = szType;
        lpString[2] = szOldName;
        lpString[3] = szNewName;
        lpString[4] = lpszOldComment;
        lpString[5] = lpszNewComment;
        lpString[6] = szOldFullName;
        lpString[7] = szNewFullName;

        lplpOldName     = &lpString[2];
        lplpNewName     = &lpString[3];
        lplpOldDesc  = &lpString[4];
        lplpNewDesc  = &lpString[5];
        lplpOldFullName = &lpString[6];
        lplpNewFullName = &lpString[7];

        //
        // Fetch data from INF file
        //
        if (SetupGetLineByIndex(hInf, USERGRPSECTION, nLineIndex, &InfContext))
        {
            nFieldCount = SetupGetFieldCount(&InfContext);

            // We need at least 3 fields to be valid input
            if (nFieldCount < 3)
            {
                DPF(PROerr, TEXT("section name [%s] line %d error:missing field !"), USERGRPSECTION,nLineIndex);
                hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                goto Exit;
            }

            // Read all the fields in INF line
            // Field index for values starts from 1, field 0 is key name
            for (nFieldIndex = 1 ; nFieldIndex <= nFieldCount ; nFieldIndex++)
            {
                DWORD cchReqSize;

                if (!SetupGetStringField(&InfContext, 
                                         nFieldIndex,
                                         lpString[nFieldIndex],
                                         cchMaxFieldLen[nFieldIndex],
                                         &cchReqSize))
                {
                    dwErr = GetLastError();
                    if (dwErr == ERROR_MORE_DATA)
                    {
                        bMeetUnexpectedLongField = TRUE;                     
                        continue;
                    }
                    else
                    {
                        DPF(PROerr,
                            TEXT("Failed to get field [%d] from line [%d] in section [%s]"),
                            nFieldIndex,
                            nLineIndex,
                            USERGRPSECTION);    
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto Exit;
                    }
                }
            }
            
            if (bMeetUnexpectedLongField)
            {
                DPF(PROwar, TEXT("user name or full name too long in  line [%d] in section [%s]"),
                            nLineIndex,
                            USERGRPSECTION);    
                continue;
            }
            // If INF line does not supply all the field, 
            // set the pointers to the rest of fields to NULL
            for (nFieldIndex = nFieldCount + 1 ; nFieldIndex <= MAX_FIELD_COUNT ; nFieldIndex++)
            {
                lpString[nFieldIndex] = NULL;
            }
        }
        else
        {
            DPF(PROerr,
                TEXT("can not get line [%d] of section [%s]!"),
                nLineIndex,
                USERGRPSECTION);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        //
        // Process the fetched data
        //
        dwType = _tstoi(szType);

        switch (dwType & 0xFFFF)
        {
            case OP_USER:

                hr = ChangeUserInfo(*lplpOldName,
                                    *lplpNewName,
                                    *lplpOldDesc,
                                    *lplpNewDesc,
                                    *lplpOldFullName,
                                    *lplpNewFullName,
                                    szDomainName,
                                    bTest,
                                    fIsDC,
                                    dwType & 0xFFFF0000 ? TRUE:FALSE);
                if (FAILED(hr))
                {
                    DPF(PROerr,
                        TEXT("UsrGrpAndDoc_and_SettingsRename: Failed to change user info for account <%s>"),
                        *lplpOldName);
                    bErrorOccured = TRUE;
                }

                break;

            case OP_GRP:

                hr = ChangeGroupInfo(*lplpOldName,
                                     *lplpNewName,
                                     *lplpOldDesc,
                                     *lplpNewDesc,
                                     szDomainName,
                                     bTest,
                                     fIsDC,
                                     FALSE);
                if (FAILED(hr))
                {
                    DPF(PROerr,
                        TEXT("UsrGrpAndDoc_and_SettingsRename: Failed to change group info for account <%s>"),
                        *lplpOldName);
                    bErrorOccured = TRUE;
                }

                break;

            case OP_PROFILE:

                hr = RenameDocuments_and_Settings(hInf,bTest);
                if (FAILED(hr))
                {
                    DPF(PROerr,TEXT("changing profiled directory failed"));
                    bErrorOccured = TRUE;
                }

                break;

            case OP_DOMAIN_GRP:

                if (fIsDC)
                {
                    hr = ChangeGroupInfo(*lplpOldName,
                                         *lplpNewName,
                                         *lplpOldDesc,
                                         *lplpNewDesc,
                                         szDomainName,
                                         bTest,
                                         fIsDC,
                                         TRUE);
                    if (FAILED(hr))
                    {
                        DPF(PROerr,
                            TEXT("UsrGrpAndDoc_and_SettingsRename: Failed to change group info for account <%s>"),
                            *lplpOldName);
                        bErrorOccured = TRUE;
                    }
                }

                break;
        }

        if ((hr == S_OK) && bTest)
        {
            hr =  AddProfileChangeItem(dwType & 0xFFFF,
                                       *lplpOldName,
                                       *lplpNewName,
                                       *lplpOldDesc,
                                       *lplpNewDesc,
                                       *lplpOldFullName,
                                       *lplpNewFullName);
        }                
    }

    if (bErrorOccured)
    {
        hr = E_FAIL;
    }

Exit:
    FreePointer(lpszOldComment);
    FreePointer(lpszNewComment);
    return hr;
}


/*++

Routine Description:

    This routine renames a user name and updated all related setting(eg user's profile
    directory,current logon default name , comments...
    
Arguments:

    szUsrName - original user name
    szNewUsrName - the new user name 
    szComments  - comments of new user name
    szFullName  - Full name of the new user name

Return Value:

    TRUE if succeeds
--*/
HRESULT ChangeUserInfo(
    LPTSTR lpOldName,       // Old user name
    LPTSTR lpNewName,       // New user name
    LPTSTR lpOldDesc,       // Old user description
    LPTSTR lpNewDesc,       // New user description
    LPTSTR lpOldFullName,   // (optional) Old user full name
    LPTSTR lpNewFullName,   // (optional) New user full name
    LPTSTR lpDomainName,    // (optional) Machine domain name
    BOOL   bTest,           // Analyze mode or not
    BOOL   fIsDC,           // Is the machine a Domain Controller
    BOOL   bCreateHardLink
)
{
    HRESULT        hr = S_OK;
    DWORD          dwErr;
    NET_API_STATUS status;
    USER_INFO_0    usrinfo0;
    BOOL           bNameChanged = FALSE;
    
    if (lpOldName == NULL || lpNewName == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //
    // Reset the Comment for the User
    //
    if (lpOldDesc != NULL && lpNewDesc != NULL)
    {
        hr = ChangeUserDesc(lpOldName, lpOldDesc, lpNewDesc, bTest);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangerUserInfo: Failed to change description for user <%s>"),
                lpOldName);
            goto Exit;
        }
    }

    //
    // Reset the Full Name of the User
    //
    if (lpOldFullName != NULL && lpNewFullName != NULL)
    {
        hr = ChangeUserFullName(lpOldName, lpOldFullName, lpNewFullName, bTest);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangeUserInfo: Failed to change Full Name for user <%s>"),
                lpOldName);
            goto Exit;
        }
    }

    //
    // Reset the user CN name for the user (RDN)
    //
    if (fIsDC)
    {
        hr = ChangeRDN(lpOldName, lpNewName, lpDomainName, bTest);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangeUserInfo: Failed to change RDN for user <%s>"),
                lpOldName);
            goto Exit;
        }
    }

    //
    // Reset the user name (SAM account name)
    //
    if (MyStrCmpI(lpOldName, lpNewName) != LSTR_EQUAL)
    {
        hr = ChangeUserName(lpOldName, lpNewName, bTest,bCreateHardLink);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangeUserInfo: Failed to change SAM account name for user <%s>"), 
                lpOldName);
            goto Exit;
        }
    }

Exit:
    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeGroupInfo
//
//  Descrip:    Chage the local group information
//                  - Account name (SAM account name)
//                  - Account RDN
//                  - Description
//
//  Returns:    S_OK - Group information is okay to change
//              S_FALSE - Group name cannot be changed (not an error)
//              otherwise - error occured
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ChangeGroupInfo(
    LPTSTR lpOldName,       // Old user name
    LPTSTR lpNewName,       // New user name
    LPTSTR lpOldDesc,       // Old user description
    LPTSTR lpNewDesc,       // New user description
    LPTSTR lpDomainName,    // (optional) Machine domain name
    BOOL   bTest,           // Analyze mode or not
    BOOL   fIsDC,           // Is the machine a Domain Controller
    BOOL   bUseDomainAPI    // Use domain API or not
)
{
    HRESULT hr = S_OK;

    if (lpOldName == NULL || lpNewName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Change group description
    //
    if (lpOldDesc && lpNewDesc)
    {
        hr = ChangeGroupDesc(lpOldName,
                             lpOldDesc,
                             lpNewDesc,
                             bTest,
                             bUseDomainAPI);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangeGroupInfo: Failed to change description for group <%s>"),
                lpOldName);
            goto Exit;
        }
    }

    //
    // Change group RDN
    //
    if (fIsDC)
    {
        hr = ChangeRDN(lpOldName, lpNewName, lpDomainName, bTest);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangeGroupInfo: Failed to change RDN for group <%s>"),
                lpOldName);
            goto Exit;
        }
    }

    //
    // Change group name (SAM)
    //
    if (MyStrCmpI(lpOldName, lpNewName) != LSTR_EQUAL)
    {
        hr = ChangeGroupName(lpOldName, lpNewName, bTest, bUseDomainAPI);
        if (FAILED(hr))
        {
            DPF(PROerr,
                TEXT("ChangeGroupInfo: Failed to change SAM account name for group <%s>"),
                lpOldName);
            goto Exit;
        }
    }

Exit:
    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeUserName
//
//  Descrip:    Chage the User name (SAM account name)
//
//  Returns:    S_OK - User name is okay to change
//              S_FALSE - User name cannot be changed (not an error)
//              otherwise - error occured
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ChangeUserName(
    LPTSTR lpOldName,       // Old user name
    LPTSTR lpNewName,       // New user name
    BOOL   bTest,           // Analyze mode or not
    BOOL   bCreateHardLink
)
{
    LPUSER_INFO_0  lpUsrInfo0;
    USER_INFO_1052 usrinfo1052;
    USER_INFO_0    usrinfo0New;
    NET_API_STATUS nStatus;
    DWORD          dwErr, dwLen;
    HRESULT        hr;
    TCHAR          szProfilePath[MAX_PATH],szNewProfilePath[MAX_PATH];
    TCHAR          szExpProfilePath[MAX_PATH],szExpNewProfilePath[MAX_PATH];
    TCHAR          szLogonName[MAX_PATH];    
    LPTSTR         lpCurrProfileDir;
    LPTSTR         lpCurrUsername;
    BOOL           bCheckRegistry = TRUE;

    if (lpOldName == NULL || lpNewName == NULL)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (MyStrCmpI(lpOldName, lpNewName) == 0)
    {
        hr = S_OK;
        goto Exit;
    }

    hr = GetSetUserProfilePath(lpOldName, 
                               szProfilePath, 
                               MAX_PATH, 
                               PROFILE_PATH_READ, 
                               REG_EXPAND_SZ);
    if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
    {
        bCheckRegistry = FALSE;
    }
    else  if (FAILED(hr))
    {
        goto Exit;
    }

    if (bCheckRegistry)
    {
        // Compute a new unique profile directory name
        if ( !ComputeLocalProfileName(lpOldName,
                                      lpNewName,
                                      szNewProfilePath,
                                      ARRAYSIZE(szNewProfilePath),
                                      REG_EXPAND_SZ) )
        {
            hr = E_FAIL;
            goto Exit;
        }
    }
    if (bTest)
    {
        lpCurrProfileDir = szProfilePath;
        lpCurrUsername = lpOldName;
    }
    else
    {
        lpCurrProfileDir = szNewProfilePath;
        lpCurrUsername = lpNewName;
    }

    // Search for the old user name in the system
    nStatus = NetUserGetInfo(NULL,
                             lpOldName,
                             0,
                             (LPBYTE *) &lpUsrInfo0);
    switch (nStatus)
    {
        case NERR_Success:
            // user name found, reset the name to new one
            usrinfo0New.usri0_name = lpCurrUsername;
            nStatus = NetUserSetInfo(NULL,
                                     lpOldName,
                                     0,
                                     (LPBYTE) &usrinfo0New,
                                     &dwErr);
            if (nStatus == NERR_Success)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(nStatus);
            }

            NetApiBufferFree(lpUsrInfo0);
            break;

        case NERR_UserNotFound:
            // user name is not found on the system
            hr = S_FALSE;
            break;

        default:
            // error occured
            hr = HRESULT_FROM_WIN32(nStatus);
            break;
    }
    
    if (hr != S_OK)
    {
        goto Exit;
    }
    //here it means we succeeded change (or test changing) the user name 
    //change user profile path through netapi if necessary
    if (bCheckRegistry)
    {        
        //Expand the original and new profile path
        if (!ExpandEnvironmentStrings(szProfilePath, szExpProfilePath, MAX_PATH)) 
        {
            goto Exit;
        }
        if (!ExpandEnvironmentStrings(szNewProfilePath, szExpNewProfilePath, MAX_PATH)) 
        {
            goto Exit;
        }

        //If it's not test, we do real renaming)
        if (!bTest)
        {
        }
        else
        {
            LPTSTR lpOld,lpNew;

            hr = MyMoveDirectory(szExpProfilePath,szExpNewProfilePath,TRUE,bTest,FALSE,0);
            if(FAILED(hr))
            {
                DPF (APPerr, L"Move Dir from %s to %s failed ! Error Code %d (%#x)", 
                    szExpProfilePath,szExpNewProfilePath,hr, hr);
                goto Exit;
            }
            if (bCreateHardLink)
            {
                TCHAR szCommonPerfix[MAX_PATH+1];
                TCHAR szLinkName[2 * MAX_PATH], szLinkValue[2 * MAX_PATH];

                if (PathCommonPrefix(szExpProfilePath,szExpNewProfilePath,szCommonPerfix))
                {
                    LPTSTR lpszOlduserName = szExpProfilePath,lpszNewuserName = szExpNewProfilePath;

                    lpszOlduserName += lstrlen(szCommonPerfix);
                    lpszNewuserName += lstrlen(szCommonPerfix);
                    szCommonPerfix[1] = TEXT('\0');
                    if (lpszOlduserName && lpszNewuserName) 
                    {
                        HRESULT myhr, myhr1;
                        myhr = StringCchCopy(szLinkName,ARRAYSIZE(szLinkName),szCommonPerfix);
                        myhr = StringCchCat(szLinkName,ARRAYSIZE(szLinkName),TEXT(":\\Documents and Settings\\"));


                        myhr = StringCchCopy(szLinkValue,ARRAYSIZE(szLinkValue),szCommonPerfix);
                        myhr = StringCchCat(szLinkValue,ARRAYSIZE(szLinkValue),TEXT(":\\Documents and Settings\\"));

                        myhr = StringCchCat(szLinkName,ARRAYSIZE(szLinkName),lpszOlduserName);
                        myhr1 = StringCchCat(szLinkValue,ARRAYSIZE(szLinkValue),lpszNewuserName);
                        if ( (myhr == S_OK) && (myhr1 == S_OK) )
                        {
                            hr = AddHardLinkEntry(szLinkName,szLinkValue,TEXT("0"),NULL,NULL,NULL);
                        }
                    }
                    
                }
            }
            AddUserNameChangeLog(lpOldName, lpNewName);

            lpOld = StrRChrI(szExpProfilePath,NULL,TEXT('\\'));
            lpNew = StrRChrI(szExpNewProfilePath,NULL,TEXT('\\'));
            if (lpOld && lpNew)
            {
                if (!AddItemToStrRepaceTable((LPTSTR) lpOldName,
                                             (LPTSTR) lpOld+1,
                                             (LPTSTR) lpNew+1,
                                             szExpProfilePath,
                                             CSIDL_USERNAME_IN_USERPROFILE,
                                             &g_StrReplaceTable))
                {
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }
        }

        //Get current login user name
        dwLen = ARRAYSIZE(szLogonName);
        if (!GetUserName(szLogonName, &dwLen))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        // rename the profile path, if the current user profile path needs to be changed
        // we have to do a delayed renaming
        if (!MyStrCmpI(szLogonName,lpOldName))
        {       
        #define DEFAULT_USERNAME_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")

            hr = RegResetValue(HKEY_LOCAL_MACHINE,
                              DEFAULT_USERNAME_KEY,
                              TEXT("DefaultUserName"),
                              REG_SZ,
                              lpOldName,
                              lpCurrUsername,
                              0,
                              NULL);
            if(FAILED(hr))
            {
                goto Exit;
            }

            hr = RegResetValue(HKEY_LOCAL_MACHINE,
                               DEFAULT_USERNAME_KEY,
                               TEXT("AltDefaultUserName"),
                               REG_SZ,
                               lpOldName,
                               lpCurrUsername,
                               0,
                               NULL);
            if(FAILED(hr))
            {
                goto Exit;
            }
        }
    }
    hr = S_OK;
Exit:
    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeGroupName
//
//  Descrip:    Chage the Group name (SAM account name)
//
//  Returns:    S_OK - group name is okay to change
//              S_FALSE - group name cannot be changed (not an error)
//              otherwise - error occured
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ChangeGroupName(
    LPTSTR lpOldName,       // Old user name
    LPTSTR lpNewName,       // New user name
    BOOL   bTest,           // Analyze mode or not
    BOOL   bDomainAPI       // Local group API or not
)
{
    HRESULT             hr = S_OK;
    NET_API_STATUS      nStatus;
    DWORD               dwErr;   
    PLOCALGROUP_INFO_1  plgrpi1LocalGroup = NULL;
    PGROUP_INFO_1       pgrpi1DomainGroup = NULL;
    LOCALGROUP_INFO_0   lgrpi0NewName;
    GROUP_INFO_0        grpi0NewName;
    PPVOID              ppvGroupInfo;
    PPVOID              ppvNewGroupInfo;
    LPTSTR              lpCurrentName;
    PVOID               pvNewGroupNameInfo;
    LSA_HANDLE          PolicyHandle;
    PLSA_UNICODE_STRING pPrivileges;
    ULONG               CountOfRights;
    BOOL                bGotGP = FALSE;

    DWORD (*pfnGroupGetInfo)(LPCWSTR, LPCWSTR, DWORD, LPBYTE *);
    DWORD (*pfnGroupSetInfo)(LPCWSTR, LPCWSTR, DWORD, LPBYTE, LPDWORD);

    if (lpOldName == NULL || lpNewName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Choose which set of APIs/variables we will use
    //
    if (bDomainAPI)
    {
        // Domain group
        ppvGroupInfo = &pgrpi1DomainGroup;
        ppvNewGroupInfo = &pgrpi1DomainGroup;
        pvNewGroupNameInfo = &grpi0NewName;
        pfnGroupGetInfo = &NetGroupGetInfo;
        pfnGroupSetInfo = &NetGroupSetInfo;
    }
    else
    {
        // Local group
        ppvGroupInfo = &plgrpi1LocalGroup;
        ppvNewGroupInfo = &plgrpi1LocalGroup;
        pvNewGroupNameInfo = &lgrpi0NewName;
        pfnGroupGetInfo = &NetLocalGroupGetInfo;
        pfnGroupSetInfo = &NetLocalGroupSetInfo;
    }

    //
    // Check whether the new group name has already been used in the system or not
    //
    nStatus = (*pfnGroupGetInfo)(NULL,
                                 lpNewName,
                                 1,
                                 (LPBYTE *) ppvNewGroupInfo);
    if (nStatus == NERR_Success)
    {
        // New group name already exists in the system,
        // don't change the group name
        NetApiBufferFree(*ppvNewGroupInfo);
        return S_FALSE;
    }

    //
    // Check wheter the old user name exists in the system or not
    //
    nStatus = (*pfnGroupGetInfo)(NULL,
                                 lpOldName,
                                 1,
                                 (LPBYTE *) ppvGroupInfo);
    switch (nStatus)
    {
        case NERR_Success:

            if (bDomainAPI)
            {
                lpCurrentName = pgrpi1DomainGroup->grpi1_name ;
            }
            else
            {
                lpCurrentName = plgrpi1LocalGroup->lgrpi1_name;
            }
            if (bTest)
            {
                // in analyzing mode, use the old group name
                lgrpi0NewName.lgrpi0_name = lpCurrentName;
                grpi0NewName.grpi0_name = lpCurrentName;
            }
            else
            {
                // in modifying mode, use the new group name from INF
                lgrpi0NewName.lgrpi0_name = lpNewName;
                grpi0NewName.grpi0_name = lpNewName;
            }

            if (!bTest)
            {
                HRESULT hrGP = PolicyGetPrivilege(lpOldName,
                                                  &PolicyHandle,
                                                  &pPrivileges,
                                                  &CountOfRights);
                if (hrGP == S_OK)
                {
                    bGotGP = TRUE;
                }
            }

            //
            // Set the new group name (SAM account name)
            //
            nStatus = (*pfnGroupSetInfo)(NULL,
                                         lpOldName,
                                         0,
                                         (LPBYTE) pvNewGroupNameInfo,
                                         &dwErr);
            if (nStatus == NERR_Success)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(nStatus);
            }

            if (bGotGP)
            {
                if (SUCCEEDED(hr))
                {
                    // Reset the policy
                    hr = PolicySetPrivilege(lpNewName,
                                            PolicyHandle,
                                            pPrivileges,
                                            CountOfRights);
                }

                LsaFreeMemory(pPrivileges);
                LsaClose(PolicyHandle);
            }

            NetApiBufferFree(*ppvGroupInfo);
            break;

        case ERROR_NO_SUCH_ALIAS:
        case NERR_GroupNotFound:

            hr = S_FALSE;
            break;

        default:
            hr = HRESULT_FROM_WIN32(nStatus);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeUserDesc
//
//  Descrip:    Chage the User description
//
//  Returns:    S_OK - User description is okay to change
//              S_FALSE - User description cannot be changed (not an error)
//              otherwise - error occured
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ChangeUserDesc(
    LPTSTR lpUserName,      // User name
    LPTSTR lpOldDesc,       // Old user description
    LPTSTR lpNewDesc,       // New user description
    BOOL   bTest            // Anylyze mode or not
)
{
    LPUSER_INFO_10 lpUsrInfo10;
    USER_INFO_1007 usri1007New;
    NET_API_STATUS nStatus;
    DWORD          dwErr;
    HRESULT        hr;

    if (lpUserName == NULL || lpOldDesc == NULL || lpNewDesc == NULL)
    {
        return E_INVALIDARG;
    }

    if (MyStrCmpI(lpOldDesc, lpNewDesc) == LSTR_EQUAL)
    {
        return S_OK;
    }

    // Get the current comment for user
    nStatus = NetUserGetInfo(NULL,
                             lpUserName,
                             10,
                             (LPBYTE *) &lpUsrInfo10);
    switch (nStatus)
    {
        case NERR_Success:
            // old comment found
            if (MyStrCmpI(lpUsrInfo10->usri10_comment, lpOldDesc) == 0)
            {
                if (bTest)
                {
                    usri1007New.usri1007_comment = lpOldDesc;
                }
                else
                {
                    usri1007New.usri1007_comment = lpNewDesc;
                }
                nStatus = NetUserSetInfo(NULL,
                                         lpUserName,
                                         1007,
                                         (LPBYTE) &usri1007New,
                                         &dwErr);
                if (nStatus == NERR_Success)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(nStatus);
                }
            }
            else
            {
                hr = S_OK;
            }

            NetApiBufferFree(lpUsrInfo10);
            break;
        case NERR_UserNotFound:
            hr = S_FALSE;
            break;
        default:
            // error occured
            hr = HRESULT_FROM_WIN32(nStatus);
            break;
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeGroupDesc
//
//  Descrip:    Chage the group description
//
//  Returns:    S_OK - Group description is okay to change
//              S_FALSE - Group description cannot be changed (not an error)
//              otherwise - error occured
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      We will change commments first if we meet following 3 conditions
//              1. Both old and new comments are present
//              2. Old description (from INF file which is OS default) is same as
//                 current group's comment
//              3. Old and new comments are different
//
//-----------------------------------------------------------------------------
HRESULT ChangeGroupDesc(
    LPTSTR lpGroupName,     // User name
    LPTSTR lpOldDesc,       // Old description
    LPTSTR lpNewDesc,       // New description
    BOOL   bTest,           // Anylyze mode or not
    BOOL   bDomainAPI       // Is Domain Net API
)
{
    HRESULT             hr;
    NET_API_STATUS      nStatus;
    PLOCALGROUP_INFO_1  plgrpi1LocalGroup = NULL;
    PGROUP_INFO_1       pgrpi1DomainGroup = NULL;
    LOCALGROUP_INFO_1   lgrpi1NewComment;
    GROUP_INFO_1        grpi1NewComment;
    PPVOID              ppvGroupInfo;
    PVOID               pvNewGroupCommentInfo;
    LPTSTR              lpCurrentComment;
    DWORD               dwErr;

    DWORD (*pfnGroupGetInfo)(LPCWSTR, LPCWSTR, DWORD, LPBYTE *);
    DWORD (*pfnGroupSetInfo)(LPCWSTR, LPCWSTR, DWORD, LPBYTE, LPDWORD);

    if (lpGroupName == NULL || lpOldDesc == NULL || lpNewDesc == NULL)
    {
        return E_INVALIDARG;
    }

    if (MyStrCmpI(lpOldDesc, lpNewDesc) == LSTR_EQUAL)
    {
        // Default group description are the same, do nothing
        return S_FALSE;
    }

    //
    // Choose which set of APIs/variables we will use
    //
    if (bDomainAPI)
    {
        // Domain group
        ppvGroupInfo = &pgrpi1DomainGroup;
        pvNewGroupCommentInfo = &grpi1NewComment;
        pfnGroupGetInfo = &NetGroupGetInfo;
        pfnGroupSetInfo = &NetGroupSetInfo;
    }
    else
    {
        // Local group
        ppvGroupInfo = &plgrpi1LocalGroup;
        pvNewGroupCommentInfo = &lgrpi1NewComment;
        pfnGroupGetInfo = &NetLocalGroupGetInfo;
        pfnGroupSetInfo = &NetLocalGroupSetInfo;
    }

    // Get the current group description
    nStatus = (*pfnGroupGetInfo)(NULL,
                                 lpGroupName,
                                 1,
                                 (LPBYTE *) ppvGroupInfo);
    switch (nStatus)
    {
    case NERR_Success:
        
        if (bDomainAPI)
        {
            lpCurrentComment = pgrpi1DomainGroup->grpi1_comment ;
        }
        else
        {
            lpCurrentComment = plgrpi1LocalGroup->lgrpi1_comment;
        }

        if (bTest)
        {
            //In analyzing mode , we do a reset old value to see whether we will succeed
            lgrpi1NewComment.lgrpi1_comment = lpCurrentComment;
            grpi1NewComment.grpi1_comment = lpCurrentComment;
        }
        else
        {
            // in modifying mode, use the new group comment from INF
            lgrpi1NewComment.lgrpi1_comment = lpNewDesc;
            grpi1NewComment.grpi1_comment = lpNewDesc;
        }  

        //
        // Set the new group comment
        //
        nStatus = (*pfnGroupSetInfo)(NULL,
                                     lpGroupName,
                                     1,
                                     (LPBYTE) pvNewGroupCommentInfo,
                                     &dwErr);
        if (nStatus == NERR_Success)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(nStatus);
        }        

        NetApiBufferFree(*ppvGroupInfo);
        break;

    case ERROR_NO_SUCH_ALIAS:
    case NERR_GroupNotFound:

        hr = S_FALSE;
        break;

    default:
        hr = HRESULT_FROM_WIN32(nStatus);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeUserFullName
//
//  Descrip:    Chage the User full name
//
//  Returns:    S_OK - User full name is okay to change
//              S_FALSE - User full name cannot be changed (not an error)
//              otherwise - error occured
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ChangeUserFullName(
    LPTSTR lpUserName,      // User name
    LPTSTR lpOldFullName,   // Old full name
    LPTSTR lpNewFullName,   // New full name
    BOOL   bTest            // Anylyze mode or not
)
{
    LPUSER_INFO_10   lpUsrInfo10;
    USER_INFO_1011   usri1011New;
    NET_API_STATUS   nStatus;
    DWORD            dwErr;
    HRESULT          hr;

    if (lpUserName == NULL || lpOldFullName == NULL || lpNewFullName == NULL)
    {
        return E_INVALIDARG;
    }

    if (MyStrCmpI(lpOldFullName, lpNewFullName) == 0)
    {
        return S_OK;
    }

    // Get the current comment for user
    nStatus = NetUserGetInfo(NULL,
                             lpUserName,
                             10,
                             (LPBYTE *) &lpUsrInfo10);
    switch (nStatus)
    {
        case NERR_Success:
            // old comment found
            if (MyStrCmpI(lpUsrInfo10->usri10_full_name, lpOldFullName) == 0)
            {
                if (bTest)
                {
                    usri1011New.usri1011_full_name = lpOldFullName;
                }
                else
                {
                    usri1011New.usri1011_full_name = lpNewFullName;
                }
                nStatus = NetUserSetInfo(NULL,
                                         lpUserName,
                                         1011,
                                         (LPBYTE) &usri1011New,
                                         &dwErr);
                if (nStatus == NERR_Success)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(nStatus);
                }
            }
            else
            {
                hr = S_OK;
            }

            NetApiBufferFree(lpUsrInfo10);
            break;
        case NERR_UserNotFound:
            hr = S_FALSE;
            break;
        default:
            // error occured
            hr = HRESULT_FROM_WIN32(nStatus);
            break;
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   SetUserNetworkProfilePath
//
//  Descrip:    Set the path to network user's profile.
//
//  Returns:    S_OK - profile path is changed correctly
//
//  History:    05/20/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT SetUserNetworkProfilePath(
    LPCTSTR lpUserName,     // User Name
    LPCTSTR lpNewPath       // New Path
)
{
    HRESULT        hr = S_OK;
    NET_API_STATUS nStatus;
    USER_INFO_1052 usri1052;

    if (lpNewPath == NULL || *lpNewPath == TEXT('\0'))
    {
        return S_FALSE;
    }

    usri1052.usri1052_profile = (LPTSTR) lpNewPath;
    nStatus = NetUserSetInfo(NULL,
                             lpUserName,
                             1052,
                             (LPBYTE) &usri1052,
                             NULL);
    if (nStatus != NERR_Success)
    {
        hr = HRESULT_FROM_WIN32(nStatus);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   SetUserLogOnScriptPath
//
//  Descrip:    Set the path to users's logon script file.
//
//  Returns:    S_OK - profile path is changed correctly
//
//  History:    05/20/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT SetUserLogOnScriptPath(
    LPCTSTR lpUserName,     // User Name
    LPCTSTR lpNewPath       // New path
)
{
    HRESULT        hr = S_OK;
    NET_API_STATUS nStatus;
    USER_INFO_1009 usri1009;

    if (lpNewPath == NULL || *lpNewPath == TEXT('\0'))
    {
        return S_FALSE;
    }

    usri1009.usri1009_script_path = (LPTSTR) lpNewPath;
    nStatus = NetUserSetInfo(NULL,
                             lpUserName,
                             1009,
                             (LPBYTE) &usri1009,
                             NULL);
    if (nStatus != NERR_Success)
    {
        hr = HRESULT_FROM_WIN32(nStatus);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   SetUserHomeDir
//
//  Descrip:    Set the path of the home directory for the user
//
//  Returns:    S_OK - profile path is changed correctly
//
//  History:    05/20/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT SetUserHomeDir(
    LPCTSTR lpUserName,     // User Name
    LPCTSTR lpNewPath       // New path
)
{
    HRESULT        hr = S_OK;
    NET_API_STATUS nStatus;
    USER_INFO_1006 usri1006;

    if (lpNewPath == NULL || *lpNewPath == TEXT('\0'))
    {
        return S_FALSE;
    }

    usri1006.usri1006_home_dir = (LPTSTR) lpNewPath;
    nStatus = NetUserSetInfo(NULL,
                             lpUserName,
                             1006,
                             (LPBYTE) &usri1006,
                             NULL);
    if (nStatus != NERR_Success)
    {
        hr = HRESULT_FROM_WIN32(nStatus);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   SetTSUserPath
//
//  Descrip:    Set the Terminal Services related profile path. The type of 
//              profile path is determined by WTSConfigClass parameter.
//
//  Returns:    S_OK - profile path is changed correctly
//
//  History:    05/20/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT SetTSUserPath(
    LPCTSTR lpUserName,         // User Name
    LPCTSTR lpNewProfilePath,   // New path
    WTS_CONFIG_CLASS WTSConfigClass // TS configuration class
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    DWORD   cbNewProfilePath;

    cbNewProfilePath = lstrlen(lpNewProfilePath) * sizeof(TCHAR);
    bRet = WTSSetUserConfig(WTS_CURRENT_SERVER_NAME,
                            (LPTSTR) lpUserName,
                            WTSConfigClass,
                            (LPTSTR) lpNewProfilePath,
                            cbNewProfilePath);
    if (!bRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   PreFixUserProfilePath
//
//  Descrip:    Replace the "%documents_and_settings%\OldUserName\..." to
//              "%documents_and_settings%\NewUserName\...". The function will
//              not fix the paths after "%documents_and_settings%\OldUserName",
//              they will just get append to the new profile path.
//
//  Returns:    S_OK - Path has been fixed
//              S_FALSE - Path does not need the fix
//              Else - error occurred
//
//  History:    05/20/2002 Rerkboos   Created
//              06/16/2002 Rerkboos   Change to return HRESULT
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT PreFixUserProfilePath(
    LPCTSTR lpOldPath,          // Old path
    LPCTSTR lpNewProfilePath,   // Expected new profile path (with unloc user name)
    LPTSTR  lpPath,             // Buffer to store new profile path
    DWORD   cchPath             // Size of buffer (in TCHAR)
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    TCHAR   szNewPath[MAX_PATH];
    DWORD   cchNewProfilePath;
    TCHAR   chEnd;

    cchNewProfilePath = lstrlen(lpNewProfilePath);
    if (StrCmpNI(lpNewProfilePath, lpOldPath, cchNewProfilePath) == LSTR_EQUAL)
    {
        chEnd = *(lpOldPath + cchNewProfilePath);

        if (chEnd == TEXT('\\'))
        {
            hr = StringCchCopy(szNewPath, ARRAYSIZE(szNewPath), lpNewProfilePath);
            if (SUCCEEDED(hr))
            {
                bRet = ConcatenatePaths(szNewPath,
                                        (lpOldPath + cchNewProfilePath + 1),
                                        ARRAYSIZE(szNewPath));
                if (bRet)
                {
                    if ((DWORD) lstrlen(szNewPath) < cchPath)
                    {
                        hr = StringCchCopy(lpPath, cchPath, szNewPath);
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        else if (chEnd == TEXT('\0'))
        {
            if ((DWORD) lstrlen(lpNewProfilePath) < cchPath)
            {
                hr = StringCchCopy(lpPath, cchPath, lpNewProfilePath);
            }
        }
    }
    else
    {
        hr = StringCchCopy(lpPath, cchPath, lpOldPath);
        hr = (FAILED(hr) ? hr : S_FALSE);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ReplaceLocStringInPath
//
//  Descrip:    This is a simplify version of ReplaceSingleString() from utils.c
//              The function will replace all localized strings in path without
//              checking that the path is valid or not. As we are already know
//              that the input path MUST be valid one.
//
//  Returns:    Address to newly allocated string buffer if the function does
//              replace localized string(s).
//              NULL otherwise.
//
//  History:    05/22/2002 rerkboos      created
//
//  Notes:      Caller must free the allocated memory using HeapFree() API or
//              MEMFREE() macro.
//
//-----------------------------------------------------------------------------
LPTSTR ReplaceLocStringInPath(
    LPCTSTR lpOldString,
    BOOL    bVerifyPath
)
{
    LPTSTR lpNewString = NULL;
    DWORD  cchNewString;
    DWORD  dwMatchNum;
    DWORD  dwNumReplaced;
    BOOL   bRet;

    if (lpOldString == NULL || *lpOldString == TEXT('\0'))
    {
        return NULL;
    }

    dwMatchNum = GetMaxMatchNum((LPTSTR) lpOldString, &g_StrReplaceTable);

    if (dwMatchNum > 0)
    {
        cchNewString = lstrlen(lpOldString) 
                       + (g_StrReplaceTable.cchMaxStrLen * dwMatchNum);
        lpNewString = (LPTSTR) MEMALLOC(cchNewString * sizeof(TCHAR));

        if (lpNewString != NULL)
        {
            bRet = ReplaceMultiMatchInString((LPTSTR) lpOldString,
                                             lpNewString,
                                             cchNewString,
                                             dwMatchNum,
                                             &g_StrReplaceTable,
                                             &dwNumReplaced,
                                             bVerifyPath);
            if (!bRet)
            {
                MEMFREE(lpNewString);
                lpNewString = NULL;
            }
        }
    }

    return lpNewString;
}



//-----------------------------------------------------------------------------
//
//  Function:   ChangeRDN
//
//  Descrip:    Chage the User/group RDN
//
//  Returns:    S_OK - User/group RDN is okay to change
//              S_FALSE - User/group RDN cannot be changed (not an error)
//              otherwise - error occured
//
//  History:    09/17/2001 xiaoz      created
//              04/25/2002 Rerkboos   Modified to work with domain group
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ChangeRDN(
    LPTSTR lpOldRDN,        // Old user/group RDN
    LPTSTR lpNewRDN,        // New user/group RDN
    LPTSTR lpDomainName,    // Machine domain name
    BOOL   bTest            // Analyze mode or not
)
{
    HRESULT hr;
    LPTSTR  lpOldFQDN;
    BOOL    bRDNChangeNeeded = FALSE;
    LPTSTR  lpNewRDNWithCN = NULL;
    DWORD   cchNewRDNWithCN;
    LPTSTR  lpOldFQDNWithLDAP = NULL;
    DWORD   cchOldFQDNWithLDAP;
    LPTSTR  lpContainerPathWithLDAP = NULL;
    DWORD   cchContainerPathWithLDAP;
    LPTSTR  lpContainerPath;

    //
    // First, try to get a FQDN of the old RDN
    //
    hr = GetFQDN(lpOldRDN, lpDomainName, &lpOldFQDN);
    if (hr == S_OK)
    {
        // Old RDN exists in the system, find out more if we should rename it
        hr = GetFQDN(lpNewRDN, lpDomainName, NULL);
        if (hr == S_FALSE)
        {
            // New name doesn't exits, we are ok to rename old RDN
            bRDNChangeNeeded = TRUE;
        }
    }

    if (!bRDNChangeNeeded)
    {
        goto EXIT;
    }
    
    //
    // Next, if the old RDN exists then we prepare some value to use in next step
    //
    lpContainerPath = StrStrI(lpOldFQDN, TEXT("=Users"));
    if (lpContainerPath)
    {
        // Make container path points to "CN=Users, CN=...., CN=com"
        lpContainerPath -= 2;
        cchContainerPathWithLDAP = lstrlen(lpContainerPath) + lstrlen(TEXT("LDAP://")) + 1;
        lpContainerPathWithLDAP = (LPTSTR) MEMALLOC(cchContainerPathWithLDAP * sizeof(TCHAR));
        if (lpContainerPathWithLDAP)
        {
            hr = StringCchPrintf(lpContainerPathWithLDAP,
                                 cchContainerPathWithLDAP,
                                 TEXT("LDAP://%s"),
                                 lpContainerPath);
            if (FAILED(hr))
            {
                goto EXIT;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto EXIT;
        }
    }
    else
    {
        hr = S_FALSE;
        goto EXIT;
    }

    // Compose the string "CN=new RDN name"
    cchNewRDNWithCN = lstrlen(lpNewRDN) + lstrlen(lpOldRDN) 
                      + lstrlen(TEXT("CN=")) + 1;
    lpNewRDNWithCN = (LPTSTR) MEMALLOC(cchNewRDNWithCN * sizeof(TCHAR));
    if (lpNewRDNWithCN)
    {
        if (bTest)
        {
            hr = StringCchPrintf(lpNewRDNWithCN,
                                 cchNewRDNWithCN,
                                 TEXT("CN=%s"),
                                 lpOldRDN);
        }
        else
        {
            hr = StringCchPrintf(lpNewRDNWithCN,
                                 cchNewRDNWithCN,
                                 TEXT("CN=%s"),
                                 lpNewRDN);
        }

        if (FAILED(hr))
        {
            goto EXIT;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto EXIT;
    }

    // Compose the string "LDAP://CN=Old RDN, OU=Users, ...."
    cchOldFQDNWithLDAP = lstrlen(lpOldFQDN) + lstrlen(TEXT("LDAP://")) + 1;
    lpOldFQDNWithLDAP = (LPTSTR) MEMALLOC(cchOldFQDNWithLDAP * sizeof(TCHAR));
    if (lpOldFQDNWithLDAP)
    {
        hr = StringCchPrintf(lpOldFQDNWithLDAP,
                             cchOldFQDNWithLDAP,
                             TEXT("LDAP://%s"),
                             lpOldFQDN);
        if (FAILED(hr))
        {
            goto EXIT;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto EXIT;
    }

    //
    // Now, this is the part to do an RDN renaming
    //
    hr = RenameRDN(lpContainerPathWithLDAP, lpOldFQDNWithLDAP, lpNewRDNWithCN);
    if (FAILED(hr))
    {
        DPF(PROerr, TEXT("ChangeDomainGroupName: Unable to change RDN name for %s"), lpOldRDN);
    }

EXIT:
    if (lpNewRDNWithCN)
    {
        MEMFREE(lpNewRDNWithCN);
    }

    if (lpOldFQDNWithLDAP)
    {
        MEMFREE(lpOldFQDNWithLDAP);
    }

    if (lpContainerPathWithLDAP)
    {
        MEMFREE(lpContainerPathWithLDAP);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetFQDN
//
//  Descrip:    Get Fully Qualified Domain Name
//
//  Returns:    S_OK - Successfully get FQDN
//              S_FALSE - FQDN for the account not found
//              otherwise - error occured
//
//  History:    04/25/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT GetFQDN(
    LPTSTR lpAccountName,   // Account name
    LPTSTR lpDomainName,    // Machine domain name
    LPTSTR *plpFQDN         // Address of the pointer to FQDN of the account
)
{
    HRESULT hr = E_FAIL;
    HANDLE  hDS;
    DWORD   dwErr;
    LPTSTR  lpFQDN = NULL;
    LPTSTR  lpOldSamAccount = NULL;
    DWORD   cchOldSamAccount;

    dwErr = DsBind(NULL, lpDomainName, &hDS);
    if (dwErr == NO_ERROR)
    {
        cchOldSamAccount = lstrlen(lpDomainName) + lstrlen(lpAccountName) + 2;
        lpOldSamAccount = (LPTSTR) MEMALLOC(cchOldSamAccount * sizeof(TCHAR));

        if (lpOldSamAccount)
        {
            // Compose a SAM account name DOMAIN\USERNAME
            hr = StringCchPrintf(lpOldSamAccount,
                                 cchOldSamAccount,
                                 TEXT("%s\\%s"),
                                 lpDomainName,
                                 lpAccountName);
            if (SUCCEEDED(hr))
            {
                PDS_NAME_RESULT pdsName;

                // Get an FQDN name of a specified SAM account name
                dwErr = DsCrackNames(hDS,
                                     DS_NAME_NO_FLAGS,
                                     DS_NT4_ACCOUNT_NAME,
                                     DS_FQDN_1779_NAME,
                                     1,
                                     &lpOldSamAccount,
                                     &pdsName);
                if (dwErr == DS_NAME_NO_ERROR)
                {
                    if (pdsName->rItems->status == DS_NAME_NO_ERROR)
                    {
                        if (plpFQDN)
                        {
                            *plpFQDN = pdsName->rItems->pName;
                        }

                        hr = S_OK;
                    }
                    else if (pdsName->rItems->status == DS_NAME_ERROR_NOT_FOUND)
                    {
                        hr = S_FALSE;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(pdsName->rItems->status);
                    }
                }
            }

            MEMFREE(lpOldSamAccount);
        }

        DsUnBind(&hDS);
    }
    
    if (dwErr != NO_ERROR)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}



HRESULT RenameDocuments_and_Settings( 
    HINF hInf,
    BOOL bTest)
{
    const FOLDER_INFO       *pfi;
    HRESULT                 hr = S_OK;
    TCHAR                   szSection[MAX_PATH];
    INFCONTEXT              context ;
    int                     nOriIndexFldr, nNewIndexFldr;
    TCHAR                   szOriFld[MAX_PATH], szNewFld[MAX_PATH];

    if (!bTest)
    {
        return S_OK;
    }
    for (pfi = c_rgFolderInfo; pfi->id != -1; pfi++)
    {
        if (pfi->id == CSIDL_PROFILES_DIRECTORY)
        {
            break;
        }
    }
    if (pfi->id == -1 )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    //Get the folder Line for the section just found
    if (FAILED(hr = StringCchCopy(szSection,MAX_PATH,SHELL_FOLDER_PREFIX)))
    {
        goto Cleanup;
    }
    if (FAILED(hr = StringCchCat(szSection,MAX_PATH,pfi->pszIdInString)))
    {
        goto Cleanup;
    }

    if (!SetupFindFirstLine(hInf, szSection,SHELL_FOLDER_FOLDER,&context))
    {
        hr = E_FAIL;
        goto Cleanup;
    } 

    nOriIndexFldr = 3;
    nNewIndexFldr  = 4;

    if (!SetupGetStringField(&context,nOriIndexFldr,szOriFld,MAX_PATH,NULL)
        || !SetupGetStringField(&context,nNewIndexFldr,szNewFld,MAX_PATH,NULL))
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    if (!MyStrCmpI(szOriFld,szNewFld))
    {
        hr = S_FALSE;
        goto Cleanup;
    }    
    hr = FixFolderPath(pfi->id, NULL,hInf,TEXT("System"),FALSE);
Cleanup:
    return hr;
}



HRESULT AddProfileChangeItem(
    DWORD  dwType,
    LPTSTR lpOldName,
    LPTSTR lpNewName,
    LPTSTR lpOldDesc,
    LPTSTR lpNewDesc,
    LPTSTR lpOldFullName,
    LPTSTR lpNewFullName)
{
    LPTSTR lpszOneline = NULL;
    size_t ccbOneline;
    TCHAR  szIndex[MAX_PATH];
    HRESULT hr;
 
    if (lpOldName == NULL || lpNewName == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if ( (dwType != OP_USER)
         && (dwType != OP_GRP)
         && (dwType != OP_PROFILE)
         && (dwType != OP_DOMAIN_GRP) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if ( (!lpOldDesc && lpNewDesc )||(lpOldDesc && !lpNewDesc) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if ( (!lpOldFullName && lpNewFullName )||(lpOldFullName && !lpNewFullName) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    ccbOneline = lstrlen(lpOldName) + lstrlen(lpNewName)+ MAX_PATH;
    if (lpOldDesc)
    {
        ccbOneline += (lstrlen(lpOldDesc) + lstrlen(lpNewDesc));
    }
    if (lpOldFullName)
    {
        ccbOneline += (lstrlen(lpOldFullName)+ lstrlen(lpNewFullName));
    }
    if (!(lpszOneline = malloc(ccbOneline * sizeof(TCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    switch (dwType)
    {
        case OP_USER://fall through, no break here
        case OP_GRP:
        case OP_DOMAIN_GRP:
            if (lpOldDesc && lpOldFullName)
            {   // if comments and fill name are both presented
                if (FAILED(StringCchPrintf(lpszOneline,ccbOneline,TEXT("%d,\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\""),
                    dwType,lpOldName,lpNewName,lpOldDesc,lpNewDesc,lpOldFullName,lpNewFullName)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else if (!lpOldDesc && !lpOldFullName)
            {
                // if comments and fill name are both not presented
                if (FAILED(StringCchPrintf(lpszOneline,ccbOneline,TEXT("%d,\"%s\",\"%s\""),dwType,lpOldName,lpNewName)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

            }
            else if (lpOldDesc)
            {
                // if only comments are there
                if (FAILED(StringCchPrintf(lpszOneline,ccbOneline,TEXT("%d,\"%s\",\"%s\",\"%s\",\"%s\""),
                    dwType,lpOldName,lpNewName,lpOldDesc,lpNewDesc)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }            
            else
            {   // if only full name  are there
                if (FAILED(StringCchPrintf(lpszOneline,ccbOneline,TEXT("%d,\"%s\",\"%s\",\"\",\"\",\"%s\",\"%s\""),dwType,
                    lpOldName,lpNewName,lpOldFullName,lpNewFullName)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            break;
        case OP_PROFILE:
            if (FAILED(StringCchPrintf(lpszOneline,ccbOneline,TEXT("%d,\"%s\",\"%s\""),dwType,
                    lpOldName,lpNewName)))
            {
                    hr = E_FAIL;
                    goto Cleanup;
            }
            break;
    }
    g_dwKeyIndex++;
    _itot(g_dwKeyIndex,szIndex,16);
    if (!WritePrivateProfileString(USERGRPSECTION,szIndex,lpszOneline,g_szToDoINFFileName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    hr = S_OK;
Cleanup:
    FreePointer(lpszOneline);    
    return hr;
}


HRESULT 
PolicyGetPrivilege(
    LPTSTR               userName,
    PLSA_HANDLE          pPolicyHandle,
    PLSA_UNICODE_STRING  *ppPrivileges,
    PULONG               pCountOfRights)

{
    LSA_OBJECT_ATTRIBUTES   ObjectAttributes ;
    NTSTATUS                status;
    PSID                    psid = NULL;
    HRESULT                 hr;


    hr = GetSIDFromName(userName,&psid);
    if (hr != S_OK)
    {
        goto cleanup;
    }
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    status = LsaOpenPolicy(NULL,&ObjectAttributes, POLICY_ALL_ACCESS,pPolicyHandle);
    if (STATUS_SUCCESS != status)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
        goto cleanup;
    }
    status = LsaEnumerateAccountRights(*pPolicyHandle,psid,ppPrivileges,pCountOfRights);
    if (STATUS_SUCCESS != status)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
        goto cleanup;
    }
cleanup:
    if (psid)
    {
        free(psid);
    }
    return hr;
}

HRESULT 
PolicySetPrivilege(
    LPTSTR               userName,
    LSA_HANDLE           PolicyHandle,
    PLSA_UNICODE_STRING  pPrivileges,
    ULONG                CountOfRights)
{
    NTSTATUS                status;
    PSID                    psid = NULL;
    HRESULT                 hr;


    hr = GetSIDFromName(userName,&psid);
    if (hr != S_OK)
    {
        goto cleanup;
    }
    
    status = LsaAddAccountRights(PolicyHandle,psid,pPrivileges,CountOfRights);
    if (STATUS_SUCCESS != status)
    {
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
        goto cleanup;
    }  
cleanup:
    if (psid)
    {
        free(psid);
    }
    return hr;

}



//-----------------------------------------------------------------------------
//
//  Function:   IsPathLocal
//
//  Descrip:    Check if the path is a local system drive, not UNC.
//
//  Returns:    TRUE - Path is on local system drive
//              FALSE - otherwise
//
//  History:    04/25/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL IsPathLocal(
    LPCTSTR lpPath
)
{
    BOOL  bIsPathLocal = FALSE;
    TCHAR szSysWinDir[MAX_PATH];
    TCHAR szExpPath[MAX_PATH];
    UINT  uRet;

    if (lpPath == NULL || *lpPath == TEXT('\0'))
    {
        return FALSE;
    }

    ExpandEnvironmentStrings(lpPath, szExpPath, ARRAYSIZE(szExpPath));
    uRet = GetSystemWindowsDirectory(szSysWinDir, ARRAYSIZE(szSysWinDir));
    if (uRet > 0)
    {
        // Compare the first 2 characters for a Drive letter
        if (StrCmpNI(szSysWinDir, szExpPath, 2) == LSTR_EQUAL)
        {
            bIsPathLocal = TRUE;
        }
    }

    return bIsPathLocal;
}



HRESULT EnumUserProfile(PROFILEENUMPROC pfnProfileProc)
{
    HRESULT        hr = S_FALSE;
    BOOL           bRet;
    LPUSER_INFO_0  lpusri0 = NULL;
    LPUSER_INFO_0  lpTmp;
    NET_API_STATUS nStatus;
    DWORD          dwEntriesRead = 0;
    DWORD          dwTotalEntries = 0;
    DWORD          dwResumeHandle = 0;
    LPVOID         lpSid = NULL;
    DWORD          cbSid;
    LPTSTR         lpStringSid = NULL;
    TCHAR          szDomain[MAX_PATH];
    DWORD          cbDomain;
    SID_NAME_USE   SidUse;
    DWORD          i;
    DWORD          dwLevel = 0;

    cbSid = SECURITY_MAX_SID_SIZE;
    lpSid = MEMALLOC(cbSid);
    if (lpSid == NULL)
    {
        return E_OUTOFMEMORY;
    }

    do
    {
        nStatus = NetUserEnum(NULL,     // This server
                              0,
                              FILTER_NORMAL_ACCOUNT,
                              (LPBYTE *) &lpusri0,
                              MAX_PREFERRED_LENGTH,
                              &dwEntriesRead,
                              &dwTotalEntries,
                              &dwResumeHandle);
        if (nStatus == NERR_Success || nStatus == ERROR_MORE_DATA)
        {
            lpTmp = lpusri0;
            if (lpTmp != NULL)
            {
                // Loop through all entries
                for (i = 0 ; i < dwEntriesRead ; i++)
                {
                    cbDomain = ARRAYSIZE(szDomain) * sizeof(TCHAR);
                    bRet = LookupAccountName(NULL,
                                             lpTmp->usri0_name,
                                             (PSID) lpSid,
                                             &cbSid,
                                             szDomain,
                                             &cbDomain,
                                             &SidUse);
                    if (bRet)
                    {
                        bRet = ConvertSidToStringSid((PSID) lpSid, &lpStringSid);
                        if (bRet)
                        {
                            hr = pfnProfileProc(lpTmp->usri0_name, lpStringSid);

                            LocalFree(lpStringSid);

                            if (FAILED(hr))
                            {
                                goto EXIT;
                            }
                        }
                    }

                    if (!bRet)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto EXIT;
                    }

                    lpTmp++;
                }

                NetApiBufferFree(lpusri0);
                lpusri0 = NULL;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(nStatus);
            goto EXIT;
        }
    }
    while (nStatus == ERROR_MORE_DATA);

EXIT:
    if (lpusri0 != NULL)
    {
        NetApiBufferFree(lpusri0);
    }

    if (lpSid != NULL)
    {
        MEMFREE(lpSid);
    }

    return hr;
}

//-----------------------------------------------------------------------------
//
//  Function:   AnalyzeMiscProfilePathPerUser
//
//  Synopsis:   Analyze the user's profile path. If the profile paths need to
//              be changed, the function will add entries to CLMTDO.INF. These
//              entries will be set by ResetMiscProfilePathPerUser() function
//              later in the DoCritical state.
//
//  Returns:    S_OK, we don't care the error
//
//  History:    06/03/2002  Rerkboos    Created
//
//  Notes:      This is a call-back function for LoopUser() function.
//
//-----------------------------------------------------------------------------
HRESULT AnalyzeMiscProfilePathPerUser(
    LPCTSTR lpUserName,     // User name
    LPCTSTR lpUserSid       // User's SID
)
{
    HRESULT        hr;
    BOOL           bRet;
    NET_API_STATUS nStatus;
    LPUSER_INFO_3  lpusri3;
    TCHAR          szNewUserName[MAX_PATH];
    TCHAR          szNewProfilePath[MAX_PATH * 2];
    TCHAR          szNewEngProfilePath[MAX_PATH * 2];
    LPTSTR         lpNewEngProfilePath = NULL;
    DWORD          cchNewEngProfilePath;

    DPF(APPmsg, TEXT("Enter AnalyzeMiscProfilePathPerUser:"));

    // If lpUserName is built-in account, we will get the unlocalized name
    // from INF file
    hr = CheckNewBuiltInUserName(lpUserName,
                                 szNewUserName,
                                 ARRAYSIZE(szNewUserName));
    if (SUCCEEDED(hr))
    {
        if (hr == S_FALSE)
        {
            // Username is not built-in account,
            // we will not change the account name.
            hr = StringCchCopy(szNewUserName,
                               ARRAYSIZE(szNewUserName),
                               lpUserName);
            if (FAILED(hr))
            {
                goto EXIT;
            }
        }

        // Compute a new unique profile directory for the new unlocalized name
        // we don't want the new profile directory to duplicate.
        bRet = ComputeLocalProfileName(lpUserName,
                                       szNewUserName,
                                       szNewProfilePath,
                                       ARRAYSIZE(szNewProfilePath),
                                       REG_SZ);
        if (!bRet)
        {
            // This user does not have profile path set in the registry
            // Assume it is %documents and settings%\user name
            DWORD cchNewProfilePath = ARRAYSIZE(szNewProfilePath);
            bRet = GetProfilesDirectory(szNewProfilePath,
                                        &cchNewProfilePath);
            if (bRet)
            {
                bRet = ConcatenatePaths(szNewProfilePath,
                                        lpUserName,
                                        ARRAYSIZE(szNewProfilePath));
                if (bRet)
                {
                    if (IsDirExisting(szNewProfilePath))
                    {
                        // %documents and settings%\user name dir alreay exists,
                        // cannot use this dir, we just ignore this user
                        hr = S_FALSE;
                        goto EXIT;
                    }
                }
            }

            if (!bRet)
            {
                hr = E_FAIL;
                goto EXIT;
            }
        }

        // szNewProfilePath should be "%Loc_documents_and_settings%\NewUser"
        // We have to fix it to "%Eng_documents_and_settings%\NewUser"
        lpNewEngProfilePath = ReplaceLocStringInPath(szNewProfilePath, TRUE);
        if (lpNewEngProfilePath == NULL)
        {
            // If Loc string and Eng string are the same,
            // duplicate the old string to new string
            hr = DuplicateString(&lpNewEngProfilePath,
                                 &cchNewEngProfilePath,
                                 szNewProfilePath);
            if (FAILED(hr))
            {
                goto EXIT;
            }
        }
    }
    else
    {
        goto EXIT;
    }

    // Get current information of current user name,
    // and we will add entries to CLMTDO.INF if the change is needed.
    nStatus = NetUserGetInfo(NULL, lpUserName, 3, (LPBYTE *) &lpusri3);
    if (nStatus == NERR_Success)
    {
        // Check the User's Profile path
        hr = AddProfilePathItem(lpUserName,
                                lpUserSid,
                                lpusri3->usri3_profile,
                                lpNewEngProfilePath,
                                TYPE_USER_PROFILE_PATH);

        hr = AddProfilePathItem(lpUserName,
                                lpUserSid,
                                lpusri3->usri3_script_path,
                                lpNewEngProfilePath,
                                TYPE_USER_SCRIPT_PATH);
        
        hr = AddProfilePathItem(lpUserName,
                                lpUserSid,
                                lpusri3->usri3_home_dir,
                                lpNewEngProfilePath,
                                TYPE_USER_HOME_DIR);

        NetApiBufferFree(lpusri3);
    }

    hr = AddTSProfilePathItem(lpUserName,
                              lpUserSid,
                              lpNewEngProfilePath,
                              WTSUserConfigInitialProgram);

    hr = AddTSProfilePathItem(lpUserName,
                              lpUserSid,
                              lpNewEngProfilePath,
                              WTSUserConfigWorkingDirectory);

    hr = AddTSProfilePathItem(lpUserName,
                              lpUserSid,
                              lpNewEngProfilePath,
                              WTSUserConfigTerminalServerProfilePath);

    hr = AddTSProfilePathItem(lpUserName,
                              lpUserSid,
                              lpNewEngProfilePath,
                              WTSUserConfigTerminalServerHomeDir);

    DPF(APPmsg, TEXT("Exit AnalyzeMiscProfilePathPerUser:"));

EXIT:
    if (lpNewEngProfilePath != NULL)
    {
        MEMFREE(lpNewEngProfilePath);
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
//
//  Function:   ResetMiscProfilePathPerUser
//
//  Synopsis:   Reset the profile paths for the user. The function will read
//              the entries for each user from CLMTDO.INF. The entries were
//              added by AnalyzeMiscProfilePathPerUser() function.
//
//  Returns:    S_OK if function succeeded
//
//  History:    06/03/2002  Rerkboos    Created
//
//  Notes:      This is a call-back function for LoopUser() function.
//
//-----------------------------------------------------------------------------
HRESULT ResetMiscProfilePathPerUser(
    LPCTSTR lpUserName,     // User Name
    LPCTSTR  lpUserSid      // User's SID
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    TCHAR   szSectionName[MAX_PATH];
    TCHAR   szProfilePath[MAX_PATH];
    LONG    lLineCount;
    LONG    lLineIndex;
    INT     iType;
    INFCONTEXT context;

    DPF(APPmsg, TEXT("Enter ResetProfilePathPerUser:"));

    hr = StringCchPrintf(szSectionName,
                         ARRAYSIZE(szSectionName),
                         TEXT("PROFILE.UPDATE.%s"),
                         lpUserSid);
    if (FAILED(hr))
    {
        goto EXIT;
    }

    lLineCount = SetupGetLineCount(g_hInfDoItem, szSectionName);
    for (lLineIndex = 0 ; lLineIndex < lLineCount ; lLineIndex++)
    {
        bRet = SetupGetLineByIndex(g_hInfDoItem,
                                   szSectionName,
                                   lLineIndex,
                                   &context);
        if (bRet)
        {
            bRet = SetupGetIntField(&context, 0, &iType)
                   && SetupGetStringField(&context,
                                          1,
                                          szProfilePath, 
                                          ARRAYSIZE(szProfilePath),
                                          NULL);
            if (bRet)
            {
                switch (iType)
                {
                case TYPE_USER_PROFILE_PATH:
                    hr = SetUserNetworkProfilePath(lpUserName, szProfilePath);
                    break;

                case TYPE_USER_SCRIPT_PATH:
                    hr = SetUserLogOnScriptPath(lpUserName, szProfilePath);
                    break;

                case TYPE_USER_HOME_DIR:
                    hr = SetUserHomeDir(lpUserName, szProfilePath);
                    break;

                case TYPE_TS_INIT_PROGRAM:
                    hr = SetTSUserPath(lpUserName, 
                                       szProfilePath,
                                       WTSUserConfigInitialProgram);
                    break;

                case TYPE_TS_WORKING_DIR:
                    hr = SetTSUserPath(lpUserName, 
                                       szProfilePath,
                                       WTSUserConfigWorkingDirectory);
                    break;

                case TYPE_TS_PROFILE_PATH:
                    hr = SetTSUserPath(lpUserName, 
                                       szProfilePath,
                                       WTSUserConfigTerminalServerProfilePath);
                    break;

                case TYPE_TS_HOME_DIR:
                    hr = SetTSUserPath(lpUserName, 
                                       szProfilePath,
                                       WTSUserConfigTerminalServerHomeDir);
                    break;
                }
            }
        }

        if (!bRet)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto EXIT;
        }
    }

    DPF(APPmsg, TEXT("Exit ResetProfilePathPerUser:"));

EXIT:
    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   CheckNewBuiltInUserName
//
//  Synopsis:   Check the user name with the built-in accounts listed in 
//              CLMT.INF. If the user name matches, the function will return
//              the associaged English user name.
//
//  Returns:    S_OK if the user name is built-in account
//              S_FALSE if the user name is not built-in account
//              Otherwise, error occurred
//
//  History:    06/03/2002  Rerkboos    Created
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT CheckNewBuiltInUserName(
    LPCTSTR lpUserName,     // Localized User name
    LPTSTR  lpNewUserName,  // Buffer to store associated English User name
    DWORD   cchNewUserName  // Size of the buffer (in TCHAR)
)
{
    HRESULT    hr = S_FALSE;
    BOOL       bRet;
    LONG       lLineCount;
    LONG       lLineIndex;
    INT        iType;
    INFCONTEXT context;
    TCHAR      szOldUserName[MAX_PATH];

    lLineCount = SetupGetLineCount(g_hInf, USERGRPSECTION);
    for (lLineIndex = 0 ; lLineIndex < lLineCount ; lLineIndex++)
    {
        SetupGetLineByIndex(g_hInf, USERGRPSECTION, lLineIndex, &context);
        bRet = SetupGetIntField(&context, 1, &iType);
        if (iType == OP_USER)
        {
            bRet = SetupGetStringField(&context,
                                       2,
                                       szOldUserName,
                                       ARRAYSIZE(szOldUserName),
                                       NULL);
            if (bRet)
            {
                if (MyStrCmpI(szOldUserName, lpUserName) == LSTR_EQUAL)
                {
                    bRet = SetupGetStringField(&context,
                                               3,
                                               lpNewUserName,
                                               cchNewUserName,
                                               NULL);
                    if (bRet)
                    {
                        hr = S_OK;
                        goto EXIT;
                    }
                }
            }

            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto EXIT;
            }
        }
    }

EXIT:
    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   AddProfilePathItem
//
//  Synopsis:   Add the user's path that needs to be changed to CLMTDO.INF
//
//  Returns:    S_OK if the path needs to be changed, and added to CLMTDO.INF
//              S_FALSE if it's not neccessary to change the path
//              otherwise, error occurred
//
//  History:    06/03/2002  Rerkboos    Created
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT AddProfilePathItem(
    LPCTSTR lpUserName,             // User name
    LPCTSTR lpUserSid,              // User's SID
    LPCTSTR lpOldLocProfilePath,    // Current path
    LPCTSTR lpNewEngProfilePath,    // New English profile path
    DWORD   dwType)
{
    HRESULT hr = S_FALSE;
    BOOL    bRet;
    LPTSTR  lpOldEngProfilePath;
    TCHAR   szFinalPath[MAX_PATH];
    TCHAR   szSectionName[MAX_PATH];
    TCHAR   szType[4];
    TCHAR   szExpandedOldLocPath[MAX_PATH];
    TCHAR   szExpandedNewEngPath[MAX_PATH];

    if (lpUserName == NULL || *lpUserName == TEXT('\0')
        || lpOldLocProfilePath == NULL || *lpOldLocProfilePath == TEXT('\0')
        || lpNewEngProfilePath == NULL || *lpNewEngProfilePath == TEXT('\0'))
    {
        return S_FALSE;
    }

    ExpandEnvironmentStrings(lpOldLocProfilePath,
                             szExpandedOldLocPath,
                             ARRAYSIZE(szExpandedOldLocPath));

    ExpandEnvironmentStrings(lpNewEngProfilePath,
                             szExpandedNewEngPath,
                             ARRAYSIZE(szExpandedNewEngPath));

    if (IsPathLocal(szExpandedOldLocPath))
    {
        // szExpandedOldLocPath should be "%Loc_documents_and_settings%\OldUser"
        // We have to fix it to "%Eng_documents_and_settings%\OldUser"
        lpOldEngProfilePath = ReplaceLocStringInPath(szExpandedOldLocPath, TRUE);
        if (lpOldEngProfilePath != NULL)
        {
            // Loc path is NOT the same as Eng path
            hr = PreFixUserProfilePath(lpOldEngProfilePath,
                                       szExpandedNewEngPath,
                                       szFinalPath,
                                       ARRAYSIZE(szFinalPath));

            MEMFREE(lpOldEngProfilePath);

            if (SUCCEEDED(hr))
            {
                hr = StringCchPrintf(szSectionName,
                                     ARRAYSIZE(szSectionName),
                                     TEXT("PROFILE.UPDATE.%s"),
                                     lpUserSid);
                if (SUCCEEDED(hr))
                {
                    _ultot(dwType, szType, 10);

                    // Add entry to CLMTDO.INF
                    WritePrivateProfileString(szSectionName,
                                              szType,
                                              szFinalPath,
                                              g_szToDoINFFileName);
                }
            }
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   AddTSProfilePathItem
//
//  Synopsis:   Add the Terminal Services Realted user's path that needs to be
//              changed to CLMTDO.INF
//
//  Returns:    S_OK if the path needs to be changed, and added to CLMTDO.INF
//              S_FALSE if it's not neccessary to change the path
//              otherwise, error occurred
//
//  History:    06/03/2002  Rerkboos    Created
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT AddTSProfilePathItem(
    LPCTSTR lpUserName,             // User name
    LPCTSTR lpUserSid,              // User's SID
    LPCTSTR lpNewEngProfilePath,    // New English profile path
    WTS_CONFIG_CLASS WTSConfigClass // TS Path config class
)
{
    HRESULT hr = S_FALSE;
    BOOL    bRet;
    LPTSTR  lpTSDir;
    DWORD   cbTSDir;
    DWORD   dwType;

    bRet = WTSQueryUserConfig(WTS_CURRENT_SERVER_NAME,
                              (LPTSTR) lpUserName,
                              WTSConfigClass,
                              &lpTSDir,
                              &cbTSDir);
    if (bRet)
    {
        switch (WTSConfigClass)
        {
        case WTSUserConfigInitialProgram:
            dwType = TYPE_TS_INIT_PROGRAM;
            break;

        case WTSUserConfigWorkingDirectory:
            dwType = TYPE_TS_WORKING_DIR;
            break;

        case WTSUserConfigTerminalServerProfilePath:
            dwType = TYPE_TS_PROFILE_PATH;
            break;

        case WTSUserConfigTerminalServerHomeDir:
            dwType = TYPE_TS_HOME_DIR;
            break;
        }

        hr = AddProfilePathItem(lpUserName,
                                lpUserSid,
                                lpTSDir,
                                lpNewEngProfilePath,
                                dwType);

        WTSFreeMemory(lpTSDir);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\utils.c ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       utils.c
//
//  Contents:   Cross Language Migration Tools utility function
//
//  History:    09/17/2001 Xiaofeng Zang (xiaoz) Created
//
//  Notes:
//
//-----------------------------------------------------------------------


#include "StdAfx.h"
#include "clmt.h"
#include <esent97.h>
#include <dsrole.h>
#include <Ntdsapi.h>


HRESULT MakeDOInfCopy();

//-----------------------------------------------------------------------
//
//  Function:   ConcatenatePaths
//
//  Descrip:    Concat the 2 paths into 1 into Target
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      if buffer is small to hold the concated string, return value 
//              will be false,however, the truncated string still got copied
//
//-----------------------------------------------------------------------
BOOL
ConcatenatePaths(
    LPTSTR  Target,
    LPCTSTR Path,
    UINT    TargetBufferSize )

{
    UINT TargetLength,PathLength;
    BOOL TrailingBackslash,LeadingBackslash;
    UINT EndingLength;

    TargetLength = lstrlen(Target);
    PathLength = lstrlen(Path);

    //
    // See whether the target has a trailing backslash.
    //
    if(TargetLength && (Target[TargetLength-1] == TEXT('\\'))) 
    {
        TrailingBackslash = TRUE;
        TargetLength--;
    } 
    else 
    {
         TrailingBackslash = FALSE;
    }

     //
     // See whether the path has a leading backshash.
     //
     if(Path[0] == TEXT('\\')) 
     {
         LeadingBackslash = TRUE;
         PathLength--;
     } 
     else 
     {
         LeadingBackslash = FALSE;
     }

     //
     // Calculate the ending length, which is equal to the sum of
     // the length of the two strings modulo leading/trailing
     // backslashes, plus one path separator, plus a nul.
     //
     EndingLength = TargetLength + PathLength + 2;

     if(!LeadingBackslash && (TargetLength < TargetBufferSize)) 
     {
         Target[TargetLength++] = TEXT('\\');
     }

     if(TargetBufferSize > TargetLength) 
     {
         lstrcpyn(Target+TargetLength,Path,TargetBufferSize-TargetLength);
     }

     //
     // Make sure the buffer is nul terminated in all cases.
     //
     if (TargetBufferSize) 
     {
         Target[TargetBufferSize-1] = 0;
     }

     return(EndingLength <= TargetBufferSize);
 }



//-----------------------------------------------------------------------
//
//  Function:   StrToUInt
//
//  Descrip:    
//
//  Returns:    UINT
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
UINT StrToUInt(
    LPTSTR lpszNum)
{
    LPTSTR lpszStop;

#ifdef UNICODE
    return (wcstoul(lpszNum, &lpszStop, 16));
#else
    return (strtoul(lpszNum, &lpszStop, 16));
#endif
}



//-----------------------------------------------------------------------
//
//  Function:   INIFile_ChangeSectionName
//
//  Descrip:    change a section name in the INF file
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL INIFile_ChangeSectionName(
    LPCTSTR szIniFileName,
    LPCTSTR szIniOldSectionName,
    LPCTSTR szIniNewSectionName)
{

    LPTSTR pBuf = NULL;
    BOOL  bRetVal = FALSE;
    DWORD ccbBufsize = 0x7FFFF;
    DWORD copied_chars;

    DPF (INFmsg ,TEXT("[INIFile_ChangeSectionName] Calling ,%s,%s,%s !"),
        szIniFileName,szIniOldSectionName,szIniNewSectionName);
    //
    // allocate max size of buffer
    //    
    do 
    {
        if (pBuf)
        {
            free(pBuf);
            ccbBufsize *= 2;
        }
        pBuf = (LPTSTR) malloc(ccbBufsize * sizeof(TCHAR));
        if (!pBuf) 
        {
            DPF (INFerr,TEXT("[INIFile_ChangeSectionName] memory allocate error !"));       
            goto Exit1;
        }
        copied_chars = GetPrivateProfileSection(szIniOldSectionName,
                                               pBuf,
                                               ccbBufsize,
                                               szIniFileName);
    } while (copied_chars == ccbBufsize -2);

    if (! copied_chars) 
    {
        //
        // this section is not in INI file
        //
        // do nothing
        //
        DPF (INFerr,TEXT("[INIFile_ChangeSectionName] No %s section in %s !"),szIniOldSectionName);
        goto Exit2;
    }
    bRetVal =  WritePrivateProfileSection(
                   szIniNewSectionName,
                   pBuf,
                   szIniFileName);
    if (! bRetVal) 
    {
        //
        // write failure
        //
        DPF (dlError,TEXT("[INIFile_ChangeSectionName] WritePrivateProfileSection fail!"));
        goto Exit2;
    }
    //Delete the old section
    WritePrivateProfileSection(
        szIniOldSectionName,
        NULL,
        szIniFileName);
    //
    // at this step, even old section is not deleted, it's still OK
    //
    bRetVal = TRUE;

Exit2:

    if (pBuf) 
    {
        free(pBuf);
    }

Exit1:
    return bRetVal;
}



//-----------------------------------------------------------------------
//
//  Function:   INIFile_ChangeSectionName
//
//  Descrip:    change a section name in the INF file
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL INIFile_Merge2Section(
    LPCTSTR szIniFileName,
    LPCTSTR szSourceSection,
    LPCTSTR szDestSection)
{

    LPTSTR pBufSource = NULL, pBufDest = NULL, pBufMerged = NULL;
    BOOL  bRetVal = FALSE;
    DWORD cchBufsize;
    DWORD srccopied_chars, dstcopied_chars;

    DPF (INFmsg ,TEXT("[INIFile_Merger2Section] Calling ,%s,%s,%s !"),
        szIniFileName,szSourceSection,szDestSection);
    //
    // allocate max size of buffer
    //    
    cchBufsize = 0x7FFFF;
    do 
    {
        if (pBufDest)
        {
            free(pBufDest);
            cchBufsize *= 2;
        }
        pBufDest = (LPTSTR) malloc(cchBufsize * sizeof(TCHAR));
        if (!pBufDest) 
        {
            DPF (INFerr,TEXT("[INIFile_ChangeSectionName] memory allocate error !"));       
            goto Exit;
        }
        dstcopied_chars = GetPrivateProfileSection(szDestSection,
                                                   pBufDest,
                                                   cchBufsize,
                                                   szIniFileName);
    } while (dstcopied_chars == cchBufsize -2);

    if (! dstcopied_chars) 
    {
        //
        // this section is not in INI file
        //
        // do nothing
        //
        DPF (INFerr,TEXT("[INIFile_Merger2Section] No %s section in %s !"),szDestSection);
        goto Exit;
    }

    
    cchBufsize = 0x7FFFF;
    do 
    {
        if (pBufSource)
        {
            free(pBufSource);
            cchBufsize *= 2;
        }
        pBufSource = (LPTSTR) malloc(cchBufsize * sizeof(TCHAR));
        if (!pBufSource) 
        {
            DPF (INFerr,TEXT("[INIFile_ChangeSectionName] memory allocate error !"));       
            goto Exit;
        }
        srccopied_chars = GetPrivateProfileSection(szSourceSection,
                                                   pBufSource,
                                                   cchBufsize,
                                                   szIniFileName);
    } while (srccopied_chars == cchBufsize -2);

    if (! srccopied_chars) 
    {
        //
        // this section is not in INI file
        //
        // do nothing
        //
        DPF (INFerr,TEXT("[INIFile_Merger2Section] No %s section in %s !"),szSourceSection);
        goto Exit;
    }
    
    pBufMerged = (LPTSTR) malloc((srccopied_chars + dstcopied_chars + 1) * sizeof(TCHAR));
    if (!pBufMerged) 
    {
        DPF (INFerr,TEXT("[INIFile_ChangeSectionName] memory allocate error !"));       
        goto Exit;
    }
    memmove((LPBYTE)pBufMerged,(LPBYTE)pBufDest,dstcopied_chars * sizeof(TCHAR));
    memmove((LPBYTE)(pBufMerged + dstcopied_chars),(LPBYTE)pBufSource,srccopied_chars * sizeof(TCHAR));
    pBufMerged[srccopied_chars + dstcopied_chars] = TEXT('\0');
    
    bRetVal =  WritePrivateProfileSection(
                   szDestSection,
                   pBufMerged,
                   szIniFileName);
    if (! bRetVal) 
    {
        //
        // write failure
        //
        DPF (dlError,TEXT("[INIFile_ChangeSectionName] WritePrivateProfileSection fail!"));
        goto Exit;
    }        
    bRetVal = TRUE;

Exit:
    FreePointer(pBufSource);
    FreePointer(pBufDest);
    FreePointer(pBufMerged);
    return bRetVal;
}



//-----------------------------------------------------------------------------
//
//  Function:   INIFile_IsSectionExist
//
//  Synopsis:   Find out whether the section name is existed in INF file or not
//
//  Returns:    TRUE if found, FALSE otherwise
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
BOOL INIFile_IsSectionExist(
    LPCTSTR lpSection,      // Section name to be searched
    LPCTSTR lpINFFile       // INF file name
)
{
    HINF hInf;
    BOOL fRet = FALSE;

    if (NULL == lpSection || NULL == lpINFFile)
    {
        return FALSE;
    }

    hInf = SetupOpenInfFile(lpINFFile, NULL, INF_STYLE_WIN4, NULL);
    if (INVALID_HANDLE_VALUE != hInf)
    {
        if (SetupGetLineCount(hInf, lpSection) > 0)
        {
            fRet = TRUE;
        }

        SetupCloseInfFile(hInf);
    }

    return fRet;
}



//-----------------------------------------------------------------------
//
//  Function:   IntToString
//
//  Descrip:    
//
//  Returns:    void
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
void IntToString( 
    DWORD i, 
    LPTSTR sz)
{
#define CCH_MAX_DEC 12         // Number of chars needed to hold 2^32

    TCHAR szTemp[CCH_MAX_DEC];
    int iChr;


    iChr = 0;

    do {
        szTemp[iChr++] = TEXT('0') + (TCHAR)(i % 10);
        i = i / 10;
    } while (i != 0);

    do {
        iChr--;
        *sz++ = szTemp[iChr];
    } while (iChr != 0);

    *sz++ = TEXT('\0');
}



//-----------------------------------------------------------------------
//
//  Function:   IsDirExisting
//
//  Descrip:    Check whether the Dir exists or not
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL IsDirExisting(LPTSTR Dir)
{
    LONG lResult = GetFileAttributes(Dir);

    DPF (dlInfo,TEXT("[IsDirExisting]  %s  lResult:%X"),Dir,lResult);

    if ((lResult == 0xFFFFFFFF) ||
        (!(lResult & FILE_ATTRIBUTE_DIRECTORY))) 
    { 
        return FALSE;
    } 
    else 
    {
        return TRUE;
    }
}


LONG IsDirExisting2(LPTSTR Dir, PBOOL pbExit)
{
    LONG lResult = GetFileAttributes(Dir);

    DPF (dlInfo,TEXT("[IsDirExisting]  %s  lResult:%X"),Dir,lResult);

    if (lResult == INVALID_FILE_ATTRIBUTES)
    {
        DWORD dwErr = GetLastError();
        if ( (dwErr == ERROR_FILE_NOT_FOUND)
             || (dwErr == ERROR_PATH_NOT_FOUND) )
        {
            *pbExit = FALSE;
            return ERROR_SUCCESS;
        }
        else
        {
            return dwErr;
        }
    }
    else
    {
        *pbExit = TRUE;
        return ERROR_SUCCESS;
    }
}



//-----------------------------------------------------------------------
//
//  Function:   IsFileFolderExisting
//
//  Descrip:    Check whether the File exists or not
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
BOOL IsFileFolderExisting( LPTSTR File)
{
    LONG lResult = GetFileAttributes(File);

    DPF (dlInfo,TEXT("[IsFileFolderExisting]  %s  lResult:%X"),File,lResult);

    if (lResult == 0xFFFFFFFF)
    { 
        return FALSE;
    } 
    else 
    {
        return TRUE;
    }
}

//-----------------------------------------------------------------------
//
//  Function:   MyMoveFile
//
//  Descrip:    Rename a file or direcory 
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT MyMoveFile(
     LPCTSTR lpExistingFileName, // file name
     LPCTSTR lpNewFileName,      // new file name
     BOOL    bAnalyze,           // if it's analyze mode, it will add an entry in INF file
                                 // for future renaming
     BOOL    bIsFileProtected)
{
    LPCTSTR lpMyNewFileName = lpNewFileName;

    if (!lpExistingFileName)
    {
        return E_INVALIDARG;
    }
    if (!IsFileFolderExisting((LPTSTR)lpExistingFileName)) 
    {
        return S_FALSE;
    }
    if (!MyStrCmpI(lpExistingFileName,lpNewFileName))
    {
        return S_FALSE;
    }

    if (!lpNewFileName || !lpNewFileName[0]) 
    {
        lpMyNewFileName = NULL;
    }
    if (bAnalyze)
    {
        HRESULT hr;
        DWORD dwType;

        if (bIsFileProtected)
        {
            dwType = TYPE_SFPFILE_MOVE;
        }
        else
        {
            dwType = TYPE_FILE_MOVE;
        }
        return (AddFolderRename((LPTSTR)lpExistingFileName,(LPTSTR)lpMyNewFileName,dwType,NULL));
    }
    else
    {
        if (MoveFileEx(lpExistingFileName,lpMyNewFileName,MOVEFILE_DELAY_UNTIL_REBOOT))
        {
            return S_OK;
        }
        else
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
}

//-----------------------------------------------------------------------
//
//  Function:   AddHardLinkEntry
//
//  Descrip:    add an entry in hardlink section
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    04/10/2002 xiaoz created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT AddHardLinkEntry(
    LPTSTR szLinkName, //Link Name to created
    LPTSTR szLinkValue, //the name you want to link to
    LPTSTR szType,
    LPTSTR lpUser,
    LPTSTR lpHiddenType,
	LPTSTR lpKeyname
    )
{
    LPTSTR lpszSectionName;
    LPTSTR szOneLine = NULL;
    size_t CchOneLine = MAX_PATH;
    TCHAR  szIndex[MAX_PATH];
	LPTSTR lpCurrIndex = szIndex;
    HRESULT hr;


    if (!szLinkName ||!szLinkValue || !szType || !szLinkName[0] || !szLinkValue[0] || !szType[0])
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    CchOneLine += lstrlen(szLinkName)+lstrlen(szLinkValue) +lstrlen(szType);
    szOneLine = malloc(CchOneLine * sizeof(TCHAR));
    if (!szOneLine)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    if (!lpHiddenType)
    {
        hr = StringCchPrintf(szOneLine,CchOneLine,TEXT("%s,\"%s\",\"%s\""),
                            szType,szLinkName,szLinkValue);
    }
    else
    {
        hr = StringCchPrintf(szOneLine,CchOneLine,TEXT("%s,\"%s\",\"%s\",\"%s\""),
                            szType,szLinkName,szLinkValue,lpHiddenType);
    }
    if (FAILED(hr))
    {
        goto Cleanup;
    }
	if (lpKeyname && (g_dwKeyIndex < 0xFFFF))
	{
		g_dwKeyIndex = 0xFFFF;
        _itot(g_dwKeyIndex,szIndex,16);
	}
	else
	{
		g_dwKeyIndex++;
		_itot(g_dwKeyIndex,szIndex,16);
	}

    if (lpUser && !MyStrCmpI(lpUser,DEFAULT_USER))
    {
        lpszSectionName = TEXT("Folder.HardLink.Peruser");
    }
    else
    {
        lpszSectionName = TEXT("Folder.HardLink");
    }
   if (!WritePrivateProfileString(lpszSectionName,lpCurrIndex,szOneLine,g_szToDoINFFileName))
   {
       hr = HRESULT_FROM_WIN32(GetLastError());
       goto Cleanup;
   }
   hr = S_OK;
Cleanup:
    if (szOneLine)
    {
        free(szOneLine);
    }
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   MyMoveDirectory
//
//  Descrip:    Rename SourceDir to DestDir
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      if the directory is in use, a deferred move will be
//              performed and we set the system reboot statue
//              MoveFileEx will fail for directory when DestDir is
//              already exitsing
//              if bTakeCareBackupDir is TRUE, this function will make 
//              a backup for DestDir if it exists.
//-----------------------------------------------------------------------
HRESULT MyMoveDirectory(
    LPTSTR SourceDir,
    LPTSTR DestDir,
    BOOL   bTakeCareBackupDir,
    BOOL   bAnalyze,
    BOOL   bCreateHardLink,
    DWORD  dwShellID)
{
    HRESULT     hr;
    size_t      cChSourceDir, cChDestDir ;
    LPTSTR      lpSourceBackupDir, lpDestBackupDir;
    BOOL        bDirExist;
    DWORD       dwStatus;
    
    lpSourceBackupDir = lpDestBackupDir = NULL;

    dwStatus = IsDirExisting2(SourceDir,&bDirExist);
    if (ERROR_SUCCESS == dwStatus) 
    {
        if (!bDirExist)
        {
            hr =  S_FALSE;
            goto Cleanup;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        DPF(APPerr, TEXT("Error: current user maybe can not access folder %s "),SourceDir);
        goto Cleanup;
    }

    if (!MyStrCmpI(SourceDir,DestDir))
    {
        hr =  S_FALSE;
        goto Cleanup;
    }

    if (bAnalyze)
    {
        BOOL    bAccess;
        LPTSTR  lp = StrRChrI(SourceDir,NULL,TEXT('\\'));
        TCHAR   cCh;
        if (!lp)
        {
            hr =  S_FALSE;
            goto Cleanup;
        }
        //Try self first
        hr = IsObjectAccessiablebyLocalSys(SourceDir,SE_FILE_OBJECT,&bAccess);
        if (hr != S_OK)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            DPF(APPerr, TEXT("Error: LocalSystem or Local Administartors Group or Anyone can not access folder %s "),SourceDir);
            goto Cleanup;
        }

        //try parent
        if (*(lp-1) == TEXT(':'))
        {
            lp++;
        }
        cCh = *lp;
        *lp = TEXT('\0');
        hr = IsObjectAccessiablebyLocalSys(SourceDir,SE_FILE_OBJECT,&bAccess);
        if (hr != S_OK)
        {
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            DPF(APPerr, TEXT("Error: LocalSystem or Local Administartors Group or Anyone can not access folder %s "),SourceDir);
            goto Cleanup;
        }
        if (!bAccess)
        {
            DPF(APPerr, TEXT("Error: LocalSystem or Local Administartors Group or Anyone can not access folder %s "),SourceDir);
            hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            goto Cleanup;
        }
        *lp = cCh;
        if (bTakeCareBackupDir && IsDirExisting(DestDir))
        {
            LPTSTR lpOld,lpNew,lpLastSlash;
   	        //
	        // RERKBOOS: Add more code here...
	        // We merge the content from Backup English folder to localized folder
	        // then we will rename localized folder to English folder
	        //
#ifdef NEVER
            //Testing team decides to change mind and better not to add this code
            //we will just follow here
	        hr = MergeDirectory(DestDir, SourceDir);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
#endif

            //We need to make sure DestDir does not exist
            cChDestDir = lstrlen(DestDir)+ MAX_PATH;
            lpDestBackupDir = malloc(cChDestDir * sizeof(TCHAR));
            if (!lpDestBackupDir)
            {            
                hr =  E_OUTOFMEMORY;
                goto Cleanup;
            }
            if (!GetBackupDir( DestDir,lpDestBackupDir,cChDestDir,FALSE))
            {
                hr =  E_FAIL;
                goto Cleanup;
            }
            if (FAILED(hr = AddFolderRename(DestDir,lpDestBackupDir,TYPE_DIR_MOVE,NULL)))
            {
                goto Cleanup;
            }
            lpOld = StrRChrI(DestDir,NULL,TEXT('\\'));
            lpNew = StrRChrI(lpDestBackupDir,NULL,TEXT('\\'));
            lpLastSlash = lpOld;
            if (lpOld && lpNew)
            {
                lpOld++;
                lpNew++;
                //*lpLastSlash = TEXT('\0');

                if (!AddItemToStrRepaceTable(TEXT("SYSTEM"),lpOld,lpNew,DestDir,
                                                dwShellID,&g_StrReplaceTable))
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                //*lpLastSlash = TEXT('\\');
            }

        }
        else
        {
            //We need to make sure DestDir does not exist
            cChDestDir = lstrlen(DestDir)+ MAX_PATH;
            lpDestBackupDir = malloc(cChDestDir * sizeof(TCHAR));
            if (lpDestBackupDir)
            {
                if (GetBackupDir( DestDir,lpDestBackupDir,cChDestDir,FALSE))
                {
                     AddFolderRename(DestDir,lpDestBackupDir,TYPE_DIR_MOVE,NULL);
                }
            }        
        }
    }
    
    //if we are here we are safe to move source dir to destination
    if (bAnalyze)
    {
        if (FAILED(hr = AddFolderRename(SourceDir,DestDir,TYPE_DIR_MOVE,NULL)))
        {
            goto Cleanup;
        }
        /*if (bCreateHardLink)
        {
            if (FAILED(hr = AddHardLinkEntry(SourceDir,DestDir)))
            {
                goto Cleanup;
            }
        }*/
    }
    else
    {
        if (!MoveFileEx(SourceDir,DestDir,MOVEFILE_DELAY_UNTIL_REBOOT))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }        
    }

    if (bAnalyze && bTakeCareBackupDir)
    {
        cChSourceDir = lstrlen(SourceDir)+ MAX_PATH;
        lpSourceBackupDir = malloc(cChSourceDir * sizeof(TCHAR));
        if (!lpSourceBackupDir)
        {
            hr =  E_OUTOFMEMORY;
            goto Cleanup;
        }
        if (GetBackupDir( SourceDir,lpSourceBackupDir,cChSourceDir,TRUE))
        {
            LPTSTR lpOld,lpNew,lpLastSlash;

            if (FAILED(hr = AddFolderRename(lpSourceBackupDir,SourceDir,TYPE_DIR_MOVE,NULL)))
            {
                goto Cleanup;
            }
            lpOld = StrRChrI(lpSourceBackupDir,NULL,TEXT('\\'));
            lpNew = StrRChrI(SourceDir,NULL,TEXT('\\'));
            lpLastSlash = lpOld;
            if (lpOld && lpNew)
            {
                lpOld++;
                lpNew++;
                //*lpLastSlash = TEXT('\0');

                if (!AddItemToStrRepaceTable(TEXT("SYSTEM"),lpOld,lpNew,lpSourceBackupDir,
                                                dwShellID,&g_StrReplaceTable))
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                //*lpLastSlash = TEXT('\\');
            }

        }
    }
    hr = S_OK;
Cleanup:
    FreePointer(lpSourceBackupDir);
    FreePointer(lpDestBackupDir);
    return hr;
}




//-----------------------------------------------------------------------
//
//  Function:   UpdateINFFileSys
//
//  Descrip:    adding ALLUSERSPROFILE/HOMEDRIVE/WINDIR Key in [String] section
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz        created
//              03/05/2002 rerkboos     modified
//
//  Notes:    
//
//-----------------------------------------------------------------------
HRESULT UpdateINFFileSys(
    LPTSTR lpInfFile
)
{
    HRESULT hr = E_FAIL;
    DWORD   dwSize;
    TCHAR   szStringSection[32];
    TCHAR   szProfileDir[MAX_PATH];
    TCHAR   szWindir[MAX_PATH+1];
    TCHAR   szHomeDrive[MAX_PATH];
    TCHAR   szSystemDrive[MAX_PATH];
    TCHAR   szStr[MAX_PATH];
    TCHAR   szComputerName[16];
    TCHAR   szBackupDir[MAX_PATH];
    TCHAR   szFirstNTFSDrive[4];
    INT     i;

    struct _EnvPair
    {
        LPCTSTR lpEnvVarName;
        LPCTSTR lpValue;
    };

    struct _EnvPair epCLMT[] = {
        TEXT("ALLUSERSPROFILE"), szProfileDir,
        TEXT("HOMEDRIVE"),       szHomeDrive,
        TEXT("WINDIR"),          szWindir,
        TEXT("SYSTEMDRIVE"),     szSystemDrive,
        TEXT("COMPUTERNAME"),    szComputerName,
        TEXT("MUIBACKUPDIR"),    szBackupDir,
        TEXT("FIRSTNTFSDRIVE"),  szFirstNTFSDrive,
        NULL,                    NULL
       };


    if (lpInfFile == NULL)
    {
        return E_INVALIDARG;
    }

    DPF(APPmsg, TEXT("Enter UpdateINFFileSys:"));

    //
    // Get neccessary environment variables from system
    //
    dwSize = ARRAYSIZE(szProfileDir);
    if (!GetAllUsersProfileDirectory(szProfileDir, &dwSize))
    {
        DPF(APPerr, TEXT("Failed to get ALLUSERPROFILE"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto EXIT;
    }

    dwSize = ARRAYSIZE(szComputerName);
    if (!GetComputerName(szComputerName, &dwSize))
    {
        DPF(APPerr, TEXT("Failed to get computer name"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto EXIT;
    }

    if (!GetSystemWindowsDirectory(szWindir, ARRAYSIZE(szWindir)))
    {
        DPF(APPerr, TEXT("Failed to get WINDIR"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto EXIT;
    }

    if (!GetEnvironmentVariable(TEXT("HOMEDRIVE"), szHomeDrive, ARRAYSIZE(szHomeDrive)))
    {
        DWORD dw = GetLastError();
        DPF(APPerr, TEXT("Failed to get HOMEDRIVE"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto EXIT;
    }

    if (!GetEnvironmentVariable(TEXT("SystemDrive"), szSystemDrive, ARRAYSIZE(szSystemDrive)))
    {
        DPF(APPerr, TEXT("Failed to get SystemDrive"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto EXIT;
    }

    hr = StringCchCopy(szBackupDir, ARRAYSIZE(szBackupDir), szWindir);
    if (SUCCEEDED(hr))
    {
        ConcatenatePaths(szBackupDir, CLMT_BACKUP_DIR, ARRAYSIZE(szBackupDir));
        if (!CreateDirectory(szBackupDir, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (HRESULT_CODE(hr) != ERROR_ALREADY_EXISTS)
            {
                goto EXIT;
            }
        }
    }
    else
    {  
        goto EXIT;
    }

    hr = GetFirstNTFSDrive(szFirstNTFSDrive, ARRAYSIZE(szFirstNTFSDrive));
    if (FAILED(hr))
    {
        DPF(APPerr, TEXT("Failed to get first NTFS drive in system"));
        goto EXIT;
    }

    //
    // Generate strings section depend on operation mode
    //
    hr = InfGenerateStringsSection(lpInfFile,
                                   szStringSection,
                                   ARRAYSIZE(szStringSection));
    if (FAILED(hr))
    {
        DPF(APPerr, TEXT("InfGenerateStringsSection failed"));
        goto EXIT;
    }

    //
    // Update private environment variables to INF file
    //
    for (i = 0 ; epCLMT[i].lpEnvVarName != NULL ; i++)
    {
        hr = StringCchPrintf(szStr,
                             ARRAYSIZE(szStr),
                             TEXT("\"%s\""),
                             epCLMT[i].lpValue);
        if (SUCCEEDED(hr))
        {
            BOOL  bRet;
            bRet = WritePrivateProfileString(szStringSection,
                                             epCLMT[i].lpEnvVarName,
                                             szStr,
                                             lpInfFile);
            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DPF(APPerr, TEXT("Failed to append private variable to INF file"));
                break;
            }
        }
        else
        {
            DPF(APPerr, TEXT("StringCchPrintf failed"));
            break;
        }
    }

EXIT:

    DPF(APPmsg, TEXT("Exit UpdateINFFileSys:"));

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   InfGenerateStringsSection
//
//  Descrip:    Generate [Strings] section from localized and English
//              sections. If the operation is normal source strings are
//              from localized section and destination strings are from
//              English section. vice versa if the operation is Undo.
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    03/05/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
HRESULT InfGenerateStringsSection(
    LPCTSTR lpInfFile,       // INF file name
    LPTSTR  lpFinalSection,  // Output section name that stores required strings
    SIZE_T  cchFinalSection  // Size of lpFinalSection in TCHAR
)
{
    LPVOID  lpBuffer;
    LPVOID  lpOldBuffer;
    LPCTSTR lpSection;
    LPCTSTR lpSrcSection;
    LPCTSTR lpDstSection;
    DWORD   cbBuffer;
    DWORD   cchRead;
    TCHAR   szLocSection[16];
    BOOL    bRet = TRUE;
    HRESULT hr = S_OK;
    LCID    lcidOriginal;

    const TCHAR szFinalSection[] = TEXT("Strings");
    const TCHAR szEngSection[] = TEXT("Strings.0409");
    const TCHAR szPrefixSRC[] = TEXT("SRC_");
    const TCHAR szPrefixDST[] = TEXT("DST_");


    if (lpInfFile == NULL || lpFinalSection == NULL)
    {
        return E_INVALIDARG;
    }

    hr = GetSavedInstallLocale(&lcidOriginal);
    if (SUCCEEDED(hr))
    {
        hr = StringCchPrintf(szLocSection,
                             ARRAYSIZE(szLocSection),
                             TEXT("Strings.%04X"),
                             lcidOriginal);
    }
    if (FAILED(hr))
    {
        return hr;
    }
    if (MyStrCmpI(szLocSection,szEngSection) == LSTR_EQUAL)
    {
        return E_NOTIMPL;
    }

    cbBuffer = 8192;
    lpBuffer = MEMALLOC(cbBuffer);
    if (lpBuffer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    cchRead = GetPrivateProfileSectionNames(lpBuffer,
                                            cbBuffer / sizeof(TCHAR),
                                            lpInfFile);
    while (cchRead == (cbBuffer / sizeof(TCHAR)) - 2)
    {
        // Buffer is too small, reallocate until we have enough
        lpOldBuffer = lpBuffer;
        cbBuffer += 8192;

        lpBuffer = MEMREALLOC(lpOldBuffer, cbBuffer);
        if (lpBuffer == NULL)
        {
            MEMFREE(lpOldBuffer);
            return E_OUTOFMEMORY;
        }

        // Read the data from section again
        cchRead = GetPrivateProfileSectionNames(lpBuffer,
                                                cbBuffer / sizeof(TCHAR),
                                                lpInfFile);
    }

    // At this point we have big enough buffer and data in it
    if (cchRead > 0)
    {
        lpSection = MultiSzTok(lpBuffer);
        while (lpSection != NULL)
        {
            if (StrStrI(lpSection, TEXT("Strings.")) != NULL)
            {
                // This is one of Strings sections,
                // Delete all sections that do not match current locale and English
                if (MyStrCmpI(lpSection, szLocSection) != LSTR_EQUAL &&
                    MyStrCmpI(lpSection, szEngSection) != LSTR_EQUAL)
                {
                    bRet = WritePrivateProfileSection(lpSection, NULL, lpInfFile);
                    if (!bRet)
                    {
                        break;
                    }
                }
            }

            // Get next section name
            lpSection = MultiSzTok(NULL);
        }

        // no error occured
        bRet = TRUE;
    }
    else
    {
        SetLastError(ERROR_NOT_FOUND);
        bRet = FALSE;
    }

    MEMFREE(lpBuffer);

    if (!bRet)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Merge strings from Loc and Eng section to [Strings] section
    //
    if (g_dwRunningStatus != CLMT_UNDO_PROGRAM_FILES
        && g_dwRunningStatus != CLMT_UNDO_APPLICATION_DATA
        && g_dwRunningStatus != CLMT_UNDO_ALL)
    {
        lpSrcSection = szLocSection;
        lpDstSection = szEngSection;
    }
    else
    {
        lpSrcSection = szEngSection;
        lpDstSection = szLocSection;
    }

    // Copy source strings to [Strings] section with SRC_ prefix
    hr = InfCopySectionWithPrefix(lpSrcSection,
                                  szFinalSection,
                                  szPrefixSRC,
                                  lpInfFile);
    if (SUCCEEDED(hr))
    {
        // Copy destination strings to [Strings] section with DSTs_ prefix
        hr = InfCopySectionWithPrefix(lpDstSection,
                                      szFinalSection,
                                      szPrefixDST,
                                      lpInfFile);
        if (SUCCEEDED(hr))
        {
            WritePrivateProfileSection(lpSrcSection, NULL, lpInfFile);
            WritePrivateProfileSection(lpDstSection, NULL, lpInfFile);
            hr = StringCchCopy(lpFinalSection, cchFinalSection, szFinalSection);
        }
    }

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   InfCopySectionWithPrefix
//
//  Descrip:    Copy keys from source section to destination and append
//              prefix to key name in destination section
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    03/05/2002 rerkboos     Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------
HRESULT InfCopySectionWithPrefix(
    LPCTSTR lpSrcSection,   // Source section name
    LPCTSTR lpDstSection,   // Destination section name
    LPCTSTR lpPrefix,       // Prefix to add to key name
    LPCTSTR lpInfFile       // Inf file name
)
{
    HRESULT hr = E_NOTIMPL;
    BOOL    bRet;
    LPVOID  lpBuffer;
    LPVOID  lpOldBuffer;
    DWORD   cbBuffer;
    DWORD   cchRead;
    LPTSTR  lpSz;
    LPTSTR  lpKey;
    LPTSTR  lpValue;
    TCHAR   szPrefixedKey[MAX_PATH];

    if (lpSrcSection == NULL || lpDstSection == NULL || lpInfFile == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Read data from source section into memory
    //
    cbBuffer = 65536;
    lpBuffer = MEMALLOC(cbBuffer);
    if (lpBuffer == NULL)
    {
        return E_OUTOFMEMORY;
    }

    cchRead = GetPrivateProfileSection(lpSrcSection,
                                       lpBuffer,
                                       cbBuffer / sizeof(TCHAR),
                                       lpInfFile);
    while (cchRead == (cbBuffer / sizeof(TCHAR)) - 2)
    {
        // Buffer is too small, reallocate until we have enough
        lpOldBuffer = lpBuffer;
        cbBuffer += 65536;
        lpBuffer = MEMREALLOC(lpOldBuffer, cbBuffer);
        
        if (lpBuffer == NULL)
        {
            MEMFREE(lpOldBuffer);
            return E_OUTOFMEMORY;
        }

        // Read the data from section again
        cchRead = GetPrivateProfileSection(lpSrcSection,
                                           lpBuffer,
                                           cbBuffer / sizeof(TCHAR),
                                           lpInfFile);

    }

    //
    // Write key with prefix to destination section
    //
    lpKey = (LPTSTR) MultiSzTok((LPCTSTR) lpBuffer);
    while (lpKey != NULL)
    {
        lpValue = StrStr(lpKey, TEXT("="));
        *lpValue = TEXT('\0');

        hr = StringCchPrintf(szPrefixedKey,
                             ARRAYSIZE(szPrefixedKey),
                             TEXT("%s%s"),
                             lpPrefix,
                             lpKey);
        if (FAILED(hr))
        {
            break;
        }

        *lpValue = TEXT('=');
        lpValue++;

        bRet = WritePrivateProfileString(lpDstSection,
                                         szPrefixedKey,
                                         lpValue,
                                         lpInfFile);
        if (!bRet)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // Get next Sz value
        lpKey = (LPTSTR) MultiSzTok(NULL);
    }

    MEMFREE(lpBuffer);
        
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   UpdateINFFilePerUser
//
//  Descrip:    adding user specific key name in [Strings] section
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz        created
//              03/08/2002 rerkboos     modified to work with SRC/DST format
//
//  Notes:    
//
//-----------------------------------------------------------------------
HRESULT UpdateINFFilePerUser(
    LPCTSTR lpInfFile,
    LPCTSTR lpUserName,
    LPCTSTR lpUserSid,
    BOOL    bCureMode
)
{
    HRESULT         hr = S_OK;
    BOOL            bRet = FALSE;
    DWORD           dwSize;
    TCHAR           szExpandedUserProfilePath[MAX_PATH];
    TCHAR           szStr[MAX_PATH + 2];
    UINT            uInstLocale;
    TCHAR           szRegKey[MAX_PATH];
    HRESULT         hRes;
    LONG            lRet;
    DWORD           cbStr;
    
    const TCHAR szStringsSection[] = TEXT("Strings");

    if (lpInfFile == NULL || lpUserName == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    DPF(APPmsg, TEXT("Enter UpdateINFFilePerUser"));

    dwSize = MAX_PATH;
    if (GetDefaultUserProfileDirectory(szExpandedUserProfilePath, &dwSize))
    {
        if (MyStrCmpI(DEFAULT_USER, lpUserName))
        {
            hr = StringCchCopy(szRegKey, ARRAYSIZE(szRegKey), g_cszProfileList);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(szRegKey, ARRAYSIZE(szRegKey), TEXT("\\"));
                hr = StringCchCat(szRegKey, ARRAYSIZE(szRegKey), lpUserSid);
                if (SUCCEEDED(hr))
                {
                    cbStr = sizeof(szStr);
                    lRet = GetRegistryValue(HKEY_LOCAL_MACHINE,
                                            szRegKey,
                                            g_cszProfileImagePath,
                                            (LPBYTE) szStr,
                                            &cbStr);
                    if (lRet == ERROR_SUCCESS)
                    {
                        ExpandEnvironmentStrings(szStr,
                                                 szExpandedUserProfilePath,
                                                 ARRAYSIZE(szExpandedUserProfilePath));
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }

            if (FAILED(hr))
            {
                DPF(APPerr, TEXT("Failed to get profile directory for user"));
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = StringCchPrintf(szStr,
                                 ARRAYSIZE(szStr),
                                 TEXT("\"%s\""),
                                 szExpandedUserProfilePath);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPF(APPerr, TEXT("Failed to get default user profile directory"));
        goto Cleanup;
    }
    if (SUCCEEDED(hr))
    {
        if (bCureMode)
        {
            if (!WritePrivateProfileString(szStringsSection,
                                           lpUserSid,
                                           szStr,
                                           lpInfFile))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DPF(APPerr, TEXT("Failed to write environment variable"));
            }

        }
        else
        {
            if (!WritePrivateProfileString(szStringsSection,
                                           TEXT("USERPROFILE"),
                                           szStr,
                                           lpInfFile))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DPF(APPerr, TEXT("Failed to write environment variable"));
            }
        }
    }

    if (!bCureMode)
    {
        if (!WritePrivateProfileString(szStringsSection,
                                       TEXT("USER_SID"),
                                       lpUserSid,
                                       lpInfFile))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF(APPerr, TEXT("Failed to write environment variable"));
            goto Cleanup;
        }
    }

    hr = S_OK;
    DPF(APPmsg, TEXT("Exit UpdateINFFilePerUser"));
    
Cleanup:
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   GetInfFilePath
//
//  Descrip:    Get a file name for temp INF file
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz        created
//              03/06/2002 rerkboos     Read INF from resource 
//
//  Notes:    
//
//-----------------------------------------------------------------------
HRESULT GetInfFilePath(
    LPTSTR lpInfFile,   // Output buffer store INF file name
    SIZE_T cchInfFile   // Len of buffer in TCHAR
)
{
    HRESULT hr = S_OK;
    BOOL    bRet = FALSE;
    TCHAR   *p;
    TCHAR   szSysDir[MAX_PATH];
    TCHAR   szInfSource[MAX_PATH];
    TCHAR   szTempName[MAX_PATH];
    LPTSTR  lpFileName;
    
    if (!lpInfFile)
    {
        return E_INVALIDARG;
    }

    DPF(dlPrint, TEXT("Enter GetInfFilePath:"));

    // Contruct a tmp file name for our INF in szSysDir
    // The temp INF file is in %windir%\system32\clmt*.tmp
    if (GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
    {
        if (GetTempFileName(szSysDir, TEXT("clmt"), 0, szTempName))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPF(dlError, TEXT("Failed to get temp file name"));
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DPF(dlError, TEXT("Failed to get system directory"));
    }
    
    if (SUCCEEDED(hr))
    {
        // We will use template from inf file if user supply /INF switch
        // otherwise we will grab it from resource section
        if (g_fUseInf)
        {
            //
            // Use user-supply INF as template
            //
            if (GetFullPathName(g_szInfFile,
                                ARRAYSIZE(szInfSource),
                                szInfSource,
                                &lpFileName))
            {
                // Copy the source INF file to %windir%\system32\clmt*.tmp
                if (CopyFile(szInfSource, szTempName, FALSE))
                {
                    DPF(dlPrint, TEXT("Use inf from %s"), g_szInfFile);
                    hr = StringCchCopy(lpInfFile, cchInfFile, szTempName);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DPF(dlError, TEXT("Failed to copy temporary INF file"));
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DPF(dlError, TEXT("%s not found."), g_szInfFile);
            }
        }
        else
        {
            //
            // Use template from resource
            //
            DPF(dlPrint, TEXT("Use INF from resource"));

            hr = GetInfFromResource(szTempName);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCopy(g_szInfFile, ARRAYSIZE(g_szInfFile), szTempName);
                hr = StringCchCopy(lpInfFile, cchInfFile, szTempName);
            }
            else
            {
                DPF(dlError, TEXT("Failed to read INF file from resource"));
            }
        }
    }

    DPF(dlPrint, TEXT("Exit GetInfFilePath:"));

    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   GetInfFromResource
//
//  Descrip:    Read INF file from resource section and write it to output
//              file.
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    03/08/2002 rerkboos     Created
//
//  Notes:    
//
//-----------------------------------------------------------------------
HRESULT GetInfFromResource(
    LPCTSTR lpDstFile       // Output file name
)
{
    HRESULT hr = E_FAIL;
    HMODULE hExe;
    BOOL    bRet = FALSE;

    if (lpDstFile == NULL)
    {
        return E_INVALIDARG;
    }

    // Get the handle to our executable
    hExe = GetModuleHandle(NULL);
    if (hExe)
    {
        // Inf is stored in RCDATA type with the name "CLMTINF"
        HRSRC hRsrc = FindResource(hExe, TEXT("CLMTINF"), RT_RCDATA);
        if (hRsrc)
        {
            DWORD  cbBuffer;
            LPVOID lpBuffer;

            cbBuffer = SizeofResource(hExe, hRsrc);
            if (cbBuffer > 0)
            {
                lpBuffer = MEMALLOC(cbBuffer);
               
                if (lpBuffer)
                {
                    HGLOBAL hGlobal = LoadResource(hExe, hRsrc);
                    if (hGlobal)
                    {
                        LPVOID lpLockGlobal = LockResource(hGlobal);
                        if (lpLockGlobal)
                        {
                            HANDLE hFile;

                            CopyMemory(lpBuffer, lpLockGlobal, cbBuffer);
                            
                            hFile = CreateFile(lpDstFile,
                                               GENERIC_WRITE,
                                               FILE_SHARE_READ,
                                               NULL,
                                               CREATE_ALWAYS,
                                               FILE_ATTRIBUTE_TEMPORARY,
                                               NULL);
                            if (hFile != INVALID_HANDLE_VALUE)
                            {
                                DWORD cbWritten;

                                bRet = WriteFile(hFile,
                                                 lpBuffer,
                                                 cbBuffer,
                                                 &cbWritten,
                                                 NULL);
                                
                                CloseHandle(hFile);
                            }
                        }
                    }

                    MEMFREE(lpBuffer);
                }
                else
                {
                    SetLastError(ERROR_OUTOFMEMORY);
                }
            }
        }
    }

    if (!bRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}


//*************************************************************
// ReplaceString
//
// Purpose:    Replace a string
//
// Parameter:  lpszOldStr:          Orignal string
//             lpszReplaceStr:      Search string
//             lpszReplacedWithStr: String to be replaced with
//             lpszOutputStr:       Output buffer
//             cbszOutputStr:       size of output buffer
//             lpszTailCheck:       point to predefined tail character
//             lpSysPath:           point to standard system path
//             lpAttrib:            point to string attribute
//             bStrCheck:           True -- do it, or False -- skip it
//
// History:    12/10/2001 geoffguo created
//
// Note: Tail check is right side check.
//       For example, "Documents" and "Documents and Settings". if you search
//       "Documents", to avoid mismatch, we check the next character of "Documents".
//*************************************************************
BOOL ReplaceString(
    LPCTSTR lpszOldStr,
    LPCTSTR lpszReplaceStr,
    LPCTSTR lpszReplacedWithStr,
    LPTSTR  lpszOutputStr,
    size_t  cbszOutputStr,
    LPCTSTR lpszTailCheck,
    LPCTSTR lpSysPath,
    LPDWORD lpAttrib,
    BOOL    bStrCheck)
{
    BOOL   bRet = FALSE;
    DWORD  dwLen, dwStrNum;
    LPTSTR pszAnchor = NULL;
    TCHAR  cTemp;
    TCHAR  *p;

    if (!lpszOldStr || !lpszReplaceStr || !lpszReplacedWithStr || !lpszOutputStr)
    {
        return bRet;
    }

    dwStrNum = 0;
    dwLen = lstrlen(lpszReplaceStr);
    p = (LPTSTR)lpszOldStr;
    lpszOutputStr[0] = TEXT('\0');

    while (*p)
    {
        //get the first occurance of the string needs to be replaced
        pszAnchor = StrStrI(p,lpszReplaceStr);

        if (pszAnchor) 
        {
            dwStrNum++;
            if (!bStrCheck || StringValidationCheck(lpszOldStr, lpszReplaceStr, lpSysPath, lpszTailCheck, lpAttrib, dwStrNum))
            {
                cTemp = *pszAnchor;
                *pszAnchor = L'\0';
                if (FAILED(StringCchCat(lpszOutputStr,cbszOutputStr,p)))
                {
                    bRet = FALSE;
                    goto Exit;
                }
                if (FAILED(StringCchCat(lpszOutputStr,cbszOutputStr,lpszReplacedWithStr)))
                {
                    bRet = FALSE;
                    goto Exit;
                }                
                *pszAnchor = cTemp;        
                bRet = TRUE;    
            } else //Copy invalid matching string
            {
                cTemp = *(pszAnchor+dwLen);
                *(pszAnchor+dwLen) = L'\0';
                if (FAILED(StringCchCat(lpszOutputStr,cbszOutputStr,p)))
                {
                    bRet = FALSE;
                    goto Exit;
                }                
                *(pszAnchor+dwLen) = cTemp;        
            }
            p = pszAnchor+dwLen;
        }
        else //Copy string
        {
            if (FAILED(StringCchCat(lpszOutputStr,cbszOutputStr,p)))
            {
                bRet = FALSE;
                goto Exit;
            }                
            break;
        }
    }

Exit:
    return bRet;
}


//-----------------------------------------------------------------------
//
//  Function:   StringMultipleReplacement
//
//  Descrip:    string replacement with multiple replace pair
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:    
//          lpszOldStr : The source string
//          lpszReplaceMSzStr : multi string instance that needs to be replaced
//          lpszReplacedWithMSzStr : multi string instance that will replace to 
//          lpszOutputStr: output buffer
//          cbszOutputStr:buffer size for lpszOutputStr
//
//-----------------------------------------------------------------------
HRESULT StringMultipleReplacement(
    LPCTSTR lpszOldStr,
    LPCTSTR lpszReplaceMSzStr,
    LPCTSTR lpszReplacedWithMSzStr,
    LPTSTR  lpszOutputStr,
    size_t  cchOutputStr)
{
    HRESULT hr;
    DWORD  dwLen;
    LPTSTR pszAnchor = NULL;
    TCHAR  cTemp;
    LPTSTR pOld,pNew;
    LPTSTR pTmp = NULL;
    TCHAR  cNonChar = TEXT('\xFFFF');
    

    if (!lpszOldStr || !lpszReplaceMSzStr || !lpszReplacedWithMSzStr || !lpszOutputStr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    
    pOld = (LPTSTR)lpszReplaceMSzStr;
    pNew = (LPTSTR)lpszReplacedWithMSzStr;

    //alloc temp buffer for intermediate string
    pTmp = malloc(cchOutputStr*sizeof(TCHAR));
    if (!pTmp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    if (FAILED(hr = StringCchCopy(pTmp,cchOutputStr,lpszOldStr)))
    {
        goto Cleanup;
    }
    while (*pOld && *pNew)
    {
        if (!ReplaceString(pTmp,pOld,pNew,lpszOutputStr, cchOutputStr,&cNonChar, NULL, NULL, TRUE))
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        pOld += (lstrlen(pOld) + 1);
        pNew += (lstrlen(pNew) + 1);
        if (FAILED(hr = StringCchCopy(pTmp,cchOutputStr,lpszOutputStr)))
        {
            goto Cleanup;
        }
    }
    hr = S_OK;
Cleanup:
    FreePointer(pTmp);
    return hr;
}



//-----------------------------------------------------------------------
//
//  Function:   MultiSzSubStr
//
//  Descrip:    multiSZ version of substr
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:    return TRUE is szString is a sub string of a string in  szMultiSz
//
//-----------------------------------------------------------------------
BOOL
MultiSzSubStr (
    LPTSTR szString,
    LPTSTR szMultiSz)
{
    TCHAR *p = szMultiSz;
    
    while (*p)
    {
        if (StrStrI(p,szString))
        {
            return TRUE;
        }
        p += (lstrlen(p) + 1);
    }
    return FALSE;
}


//-----------------------------------------------------------------------
//
//  Function:   IsStrInMultiSz
//
//  Descrip:    check whether is string is in MultiSz
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//
//-----------------------------------------------------------------------
BOOL
IsStrInMultiSz (
    LPCTSTR szString,
    LPCTSTR szMultiSz)
{
    LPCTSTR p = szMultiSz;
    
    while (*p)
    {
        if (!MyStrCmpI(p,szString))
        {
            return TRUE;
        }
        p += (lstrlen(p) + 1);
    }
    return FALSE;
}



//-----------------------------------------------------------------------
//
//  Function:   MultiSzLen
//
//  Descrip:    Returns the length (in characters) of the buffer required to hold a multisz,
//              INCLUDING the trailing null.
//
//  Returns:    DWORD
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//              Example: MultiSzLen("foo\0bar\0") returns 9
//
//-----------------------------------------------------------------------
DWORD MultiSzLen(LPCTSTR szMultiSz)
{
    TCHAR *p = (LPTSTR) szMultiSz;
    DWORD dwLen = 0;

    if (!p)
    {
        return 0;
    }
    if (!*p)
    {
        return 2;
    }
    while (*p)
    {
        dwLen += (lstrlen(p) +1);
        p += (lstrlen(p) + 1);
    }
     // add one for the trailing null character
    return (dwLen+1);
}



//-----------------------------------------------------------------------
//
//  Function:   MultiSzTok
//
//  Descrip:    Extract an sz string from multisz string
//              (work similar to strtok, but use '\0' as seperator)
//
//  Returns:    Pointer to next Sz string
//              NULL if no string left
//
//  Notes:      
//
//  History:    03/05/2002 rerkboos     Created
//
//  Notes:      Supply the pointer to multisz string the first time calling
//              this function. Supply NULL for subsequent call to get
//              next sz string in multisz.
//
//-----------------------------------------------------------------------
LPCTSTR MultiSzTok(
    LPCTSTR lpMultiSz       // Pointer to multisz string
)
{
    LPCTSTR        lpCurrentSz;
    static LPCTSTR lpNextSz;

    if (lpMultiSz != NULL)
    {
        lpNextSz = lpMultiSz;
    }

    lpCurrentSz = lpNextSz;

    // Advance pointer to next Sz
    while (*lpNextSz != TEXT('\0'))
    {
        lpNextSz++;
    }
    lpNextSz++;

    return (*lpCurrentSz == TEXT('\0') ? NULL : lpCurrentSz);
}



//-----------------------------------------------------------------------
//
//  Function:   CmpMultiSzi
//
//  Descrip:    check whether 2 multisz is equal(case insensitive)
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      here if stra ="foo1\0foo2\0" and strb = "foo2\0foo1\0"
//              it will return equal , in other words, the string order 
//              in multi-sz is not playing role in comparing
//
//-----------------------------------------------------------------------
BOOL CmpMultiSzi(
    LPCTSTR szMultiSz1,
    LPCTSTR szMultiSz2)
{
    LPCTSTR p;

    if (MultiSzLen(szMultiSz1) != MultiSzLen(szMultiSz2))
    {
        return FALSE;
    }
    p = szMultiSz1;
    while (*p)
    {
        if (!IsStrInMultiSz(p,szMultiSz2))
        {
            return FALSE;
        }
        p += (lstrlen(p) + 1);
    }
    return TRUE;
}


//-----------------------------------------------------------------------
//
//  Function:   AppendSzToMultiSz
//
//  Descrip:    appending a string to multiSZ
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      return true if succeed, since it will do malloc and the current multiSZ
//              string buffer is too small to append a string, so the API will possible 
//              return false, call GetLastError to get error code
//
//-----------------------------------------------------------------------
BOOL
AppendSzToMultiSz(
    IN     LPCTSTR  SzToAppend,
    IN OUT LPTSTR  *MultiSz,
    IN OUT PDWORD  pcchMultiSzLen  //MultiSz buffer size in char
    )
{
    DWORD               cchszLen;
    DWORD               cchmultiSzLen;
    LPTSTR              newMultiSz = NULL;
    LPTSTR              lpStartPoint = NULL;
    LPTSTR              lpSpTChar = NULL;
    BOOL                bMemEnlarged = FALSE;
    DWORD               cchLen;
    BOOL                bRet = FALSE;
    HRESULT             hr;

    //SzToAppend can not be null or empty
    if (!SzToAppend || !SzToAppend[0])
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }
    //Multi-SZ must be initialzed , not NULL pointer, at least 2 '\0'
    if (!MultiSz || *pcchMultiSzLen < 2)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Exit;
    }

    // get the size, of the two buffers in TCHAR
    cchszLen = lstrlen(SzToAppend)+1;
    cchmultiSzLen = MultiSzLen(*MultiSz);

    if (cchszLen + cchmultiSzLen > *pcchMultiSzLen)
    {
        newMultiSz = (LPTSTR)malloc( (cchszLen+cchmultiSzLen+MULTI_SZ_BUF_DELTA) * sizeof(TCHAR) );
        if( newMultiSz == NULL )
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Exit;
        }
        // recopy the old MultiSz into proper position into the new buffer.
        // the (char*) cast is necessary, because newMultiSz may be a wchar*, and
        // szLen is in bytes.

        memcpy( ((char*)newMultiSz), *MultiSz, cchmultiSzLen * sizeof(TCHAR));
        bMemEnlarged = TRUE;
        cchLen = cchszLen + cchmultiSzLen + MULTI_SZ_BUF_DELTA;
    }
    else
    {
        newMultiSz = *MultiSz;
        cchLen = *pcchMultiSzLen;
    }

    
    //the existing sz ended with 2 NULL, we need to start to copy the string
    // from second null char
    //lpStartPoint = (char*)newMultiSz + (multiSzLen - 1) * sizeof(TCHAR);
    if (cchmultiSzLen == 2)
    {
        //if it's empty MultiSz, we do not need to keep the 1st NULL
        cchmultiSzLen = 0;
        lpStartPoint = newMultiSz;
    }
    else
    {
        lpStartPoint = newMultiSz + (cchmultiSzLen - 1);
    }
    
    // copy in the new string
    lpSpTChar = (TCHAR*) lpStartPoint;
    if (FAILED(hr = StringCchCopy(lpSpTChar,cchLen - (cchmultiSzLen - 1) , SzToAppend )))
    {
        SetLastError(HRESULT_CODE(hr));
        goto Exit;
    }
       
        
    //Add the ending NULL
    *(lpSpTChar+lstrlen(SzToAppend)+1) = 0;
   

    if (bMemEnlarged)
    {
        free( *MultiSz );
        *MultiSz = newMultiSz;
        *pcchMultiSzLen = cchszLen + cchmultiSzLen + MULTI_SZ_BUF_DELTA;
    }
    SetLastError(ERROR_SUCCESS);    
    bRet = TRUE;
Exit:
    if (!bRet)
    {
        if (newMultiSz)
        {
            free(newMultiSz);
        }
    }
    return bRet;
}

//-----------------------------------------------------------------------
//
//  Function:   PrintMultiSz
//
//  Descrip:    
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      internal used for debug perpose
//
//-----------------------------------------------------------------------
void PrintMultiSz(LPTSTR MultiSz)
{
    TCHAR *p = MultiSz;

    while (*p)
    {
        _tprintf(TEXT("  %s"),p);
        _tprintf(TEXT("\n"));
        p += (lstrlen(p) + 1);
    }

}



//-----------------------------------------------------------------------
//
//  Function:   GetSetUserProfilePath
//
//  Descrip:    Get or Set User Profile path from registry
//
//  Returns:    BOOL
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//              szUserName: User name 
//              szPath : Profile path for set and buffer to get profile path for read
//              nOperation: PROFILE_PATH_READ for get path and PROFILE_PATH_WRITE for 
//                          set path
//              nType     : Specifes string type, only used to read though
//                          REG_SZ        : for unicode string
//                          REG_EXPAND_SZ : for unicode string conatins enviroment variable
//
//-----------------------------------------------------------------------
HRESULT GetSetUserProfilePath(
    LPCTSTR szUserName,
    LPTSTR  szPath,
    size_t  cchPath,
    UINT    nOperation,
    UINT    nType)
{
    PSID  pSID =NULL; 
    DWORD cbSID = 1024; 
    TCHAR lpszDomain[MAXDOMAINLENGTH]; 
    DWORD cchDomainName = MAXDOMAINLENGTH; 
    SID_NAME_USE  snuType;
    LPTSTR  szStrSid = NULL;
    LPTSTR  lpszRegRegProfilePath = NULL;
    HKEY hKeyProfileList = NULL;    
    DWORD  dwErr, dwType, cbUserProfilePath;
    DWORD dwSize;
    size_t cchLen;
    TCHAR szUserProfilePath[MAX_PATH],szExpandedUserProfilePath[MAX_PATH];
    LPTSTR lpszUserProfilePath = szUserProfilePath;
    LPTSTR lpszExpandedUserProfilePath = szExpandedUserProfilePath;
    HRESULT hr;


    pSID = (PSID) LocalAlloc(LPTR, cbSID); 
    if (!pSID)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!LookupAccountName(NULL,szUserName,pSID,&cbSID,lpszDomain,
                           &cchDomainName,&snuType))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }
    if (!IsValidSid(pSID)) 
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    if (!ConvertSidToStringSid(pSID,&szStrSid))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    cchLen = lstrlen(g_cszProfileList)+ lstrlen(szStrSid) + 3;
    if (!(lpszRegRegProfilePath = malloc(cchLen * sizeof(TCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    if (FAILED(hr = StringCchPrintf(lpszRegRegProfilePath,cchLen,_T("%s\\%s"),g_cszProfileList,szStrSid)))
    {
        goto Cleanup;
    }
    
    if ( (dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       lpszRegRegProfilePath,
                       0,
                       KEY_ALL_ACCESS,
                       &hKeyProfileList )) != ERROR_SUCCESS )

    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Cleanup;
    }

    if (nOperation == PROFILE_PATH_READ)
    {
         cbUserProfilePath = MAX_PATH;
         dwErr = RegQueryValueEx( hKeyProfileList,
                                  g_cszProfileImagePath,
                                  NULL,
                                  &dwType,
                                  (PBYTE)lpszUserProfilePath,
                                  &cbUserProfilePath );
         if (dwErr == ERROR_MORE_DATA)
         {
            lpszUserProfilePath = malloc(cbUserProfilePath * sizeof(TCHAR));
            if (!lpszUserProfilePath)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            dwErr = RegQueryValueEx(hKeyProfileList,
                                    g_cszProfileImagePath,
                                    NULL,
                                    &dwType,
                                    (PBYTE)lpszUserProfilePath,
                                    &cbUserProfilePath );
         }
    }
    else
    { // for witre operation
        dwErr = RegSetValueEx(hKeyProfileList,
                           g_cszProfileImagePath,
                           0,
                           REG_EXPAND_SZ,
                           (const BYTE *)szPath,
                           (lstrlen(szPath)+1)*sizeof(TCHAR));
    }

    if ( dwErr != ERROR_SUCCESS )
    {
       hr = HRESULT_FROM_WIN32(GetLastError());
       goto Cleanup;
    }       
    //The string saved in registry contains enviroment variable, so
    //if user want expanded version, we will do it here
    if (nOperation == PROFILE_PATH_READ)
    {     
        if (nType == REG_SZ)
        {
            size_t cchLenForExpandedStr;
            cchLenForExpandedStr = ExpandEnvironmentStrings(
                                          lpszUserProfilePath, 
                                          lpszExpandedUserProfilePath,
                                          MAX_PATH);
            if (!cchLenForExpandedStr)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }
            else if (cchLenForExpandedStr >= MAX_PATH)
            {
                lpszExpandedUserProfilePath = malloc(cchLenForExpandedStr * sizeof(TCHAR));
                if (!lpszExpandedUserProfilePath)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                if (!ExpandEnvironmentStrings(lpszUserProfilePath, 
                                              lpszExpandedUserProfilePath,
                                              cchLenForExpandedStr))
                {
                   hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Cleanup;
                }
            }
            if (FAILED(hr = StringCchCopy(szPath,cchPath,lpszExpandedUserProfilePath)))
            {
                goto Cleanup;
            }
        }
        else
        {
            if (FAILED(StringCchCopy(szPath,cchPath,lpszUserProfilePath)))
            {
                goto Cleanup;
            }
        }
     }

    hr = S_OK;

Cleanup:
    if (hKeyProfileList)
    {
        RegCloseKey( hKeyProfileList );
    }
    if (pSID)
    {
        FreeSid(pSID);
    }
    if (szStrSid)
    {
        LocalFree(szStrSid);
    }
    FreePointer(lpszRegRegProfilePath);
    if (!lpszUserProfilePath && (lpszUserProfilePath != szUserProfilePath))
    {
        free(lpszUserProfilePath);
    }
    if (!lpszExpandedUserProfilePath && (lpszExpandedUserProfilePath != szUserProfilePath))
    {
        free(lpszExpandedUserProfilePath);
    }
    return (hr);
}



//-----------------------------------------------------------------------
//
//  Function:   ReStartSystem
//
//  Descrip:    logoff or reboot the system
//
//  Returns:    none
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//
//-----------------------------------------------------------------------
void ReStartSystem(UINT uFlags)
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;

    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                // Set the state settings so that all privileges are enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }

                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    //ExitWindowsEx(uFlags, 0);
                    InitiateSystemShutdownEx(NULL,NULL,0,TRUE,TRUE,
                        SHTDN_REASON_MAJOR_OPERATINGSYSTEM|SHTDN_REASON_MINOR_UPGRADE);
                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }

    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}



//-----------------------------------------------------------------------
//
//  Function:   DoMessageBox
//
//  Descrip:    Wrapper for MessageBox
//
//  Returns:    UINT
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//
//-----------------------------------------------------------------------
int DoMessageBox(HWND hwndParent, UINT uIdString, UINT uIdCaption, UINT uType)
{
   TCHAR szString[MAX_PATH+MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   szString[0] = szCaption[0] = TEXT('\0');

   if (uIdString)
       LoadString(g_hInstDll, uIdString, szString, MAX_PATH+MAX_PATH-1);

   if (uIdCaption)
       LoadString(g_hInstDll, uIdCaption, szCaption, MAX_PATH-1);

   return MessageBox(hwndParent, szString, szCaption, uType);
}



//-----------------------------------------------------------------------
//
//  Function:   DoMessageBox
//
//  Descrip:    Wrapper for MessageBox
//
//  Returns:    UINT
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//
//-----------------------------------------------------------------------
BOOL
Str2KeyPath(
    IN  LPTSTR          String,
    OUT PHKEY           Data,
    OUT LPTSTR          *pSubKeyPath
    )
{
    UINT                i;
    TCHAR               *p,ch;
    DWORD               cchStrlen;

    STRING_TO_DATA InfRegSpecTohKey[] = {
        TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE,
        TEXT("HKLM")              , HKEY_LOCAL_MACHINE,
        TEXT("HKEY_CLASSES_ROOT") , HKEY_CLASSES_ROOT,
        TEXT("HKCR")              , HKEY_CLASSES_ROOT,
        TEXT("HKR")               , NULL,
        TEXT("HKEY_CURRENT_USER") , HKEY_CURRENT_USER,
        TEXT("HKCU")              , HKEY_CURRENT_USER,
        TEXT("HKEY_USERS")        , HKEY_USERS,
        TEXT("HKU")               , HKEY_USERS,
        TEXT("")                  , NULL
    };

    PSTRING_TO_DATA Table = InfRegSpecTohKey;

    if ( !String || !String[0])
    {
        *pSubKeyPath = NULL;
        *Data = NULL;
        return TRUE;
    }
    for(i=0; Table[i].String[0]; i++) 
    {
        cchStrlen = _tcslen(Table[i].String);
        if (_tcslen(String) < cchStrlen)
        {
            continue;
        }
        ch = String[cchStrlen];
        String[cchStrlen] = 0;
        if(!MyStrCmpI(Table[i].String,String)) 
        {
            *Data = Table[i].Data;
            String[cchStrlen] = ch;
            *pSubKeyPath = &(String[cchStrlen+1]);
            return(TRUE);
        }
        String[cchStrlen] = ch;
    }
    //if we can not find the prefix defined 
    //we think it's for user registery
    //In this case ,we return PHKEY as NULL, and pSubKeyPath = String
    *pSubKeyPath = String;
    *Data = NULL;
    return TRUE;
}



BOOL
HKey2Str(
     IN  HKEY            hKey,
     IN  LPTSTR          pKeyPath,
     IN  size_t          cbKeyPath
     )
 {
     UINT i;
     TCHAR *p,ch;
     size_t nStrlen;

     STRING_TO_DATA InfRegSpecTohKey[] = {
            TEXT("HKLM")              , HKEY_LOCAL_MACHINE,
            TEXT("HKCR")              , HKEY_CLASSES_ROOT,
            TEXT("HKCU")              , HKEY_CURRENT_USER,
            TEXT("HKU")               , HKEY_USERS,
            TEXT("")                  , NULL
    };

    PSTRING_TO_DATA Table = InfRegSpecTohKey;

    for(i=0; Table[i].Data; i++) 
     {
         if (hKey == Table[i].Data)
         {
            if (SUCCEEDED(StringCchCopy(pKeyPath,cbKeyPath,Table[i].String)))
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
         }
     }
     return(FALSE);
 }



//-----------------------------------------------------------------------------
//
//  Function:   Str2KeyPath2
//
//  Synopsis:   Return the HKEY_xxx value associcated with string value
//
//  Returns:    REG_xxx value
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL Str2KeyPath2(
    LPCTSTR  lpHKeyStr,
    PHKEY    pHKey,
    LPCTSTR* pSubKeyPath
)
{
    int     i;
    LPCTSTR lpStart;

    STRING_TO_DATA InfRegSpecTohKey[] = {
        TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE,
        TEXT("HKLM")              , HKEY_LOCAL_MACHINE,
        TEXT("HKEY_CLASSES_ROOT") , HKEY_CLASSES_ROOT,
        TEXT("HKCR")              , HKEY_CLASSES_ROOT,
        TEXT("HKR")               , NULL,
        TEXT("HKEY_CURRENT_USER") , HKEY_CURRENT_USER,
        TEXT("HKCU")              , HKEY_CURRENT_USER,
        TEXT("HKEY_USERS")        , HKEY_USERS,
        TEXT("HKU")               , HKEY_USERS,
        TEXT("")                  , NULL
    };

    PSTRING_TO_DATA Table = InfRegSpecTohKey;

    if (NULL == lpHKeyStr)
    {
        return FALSE;
    }

    for(i = 0 ; Table[i].String[0] != TEXT('\0') ; i++) 
    {
        lpStart = _tcsstr(lpHKeyStr, Table[i].String);
        if (lpStart == lpHKeyStr)
        {
            //
            // Assign the values back to caller, if caller supply the pointers
            //

            if (NULL != pHKey)
            {
                *pHKey = Table[i].Data;
            }

            if (NULL != pSubKeyPath)
            {
                lpStart += lstrlen(Table[i].String);
                if (*lpStart == TEXT('\0'))
                {
                    *pSubKeyPath = lpStart;
                }
                else
                {
                    *pSubKeyPath = lpStart + 1;
                }
            }
            
            return TRUE;
        }
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
//
//  Function:   Str2REG
//
//  Synopsis:   Convert the registry type string to REG_xxx value
//
//  Returns:    REG_xxx value
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
DWORD Str2REG(
    LPCTSTR lpStrType   // String of registry type
)
{
    INT nIndex;

    struct _STRING_TO_REG
    {
        TCHAR szStrType[32];
        DWORD dwType;
    };

    // Mapping table from string to REG_xxx value
    struct _STRING_TO_REG arrRegEntries[] = {
        TEXT("REG_BINARY"),              REG_BINARY,
        TEXT("REG_DWORD"),               REG_DWORD,
        TEXT("REG_DWORD_LITTLE_ENDIAN"), REG_DWORD_LITTLE_ENDIAN,
        TEXT("REG_DWORD_BIG_ENDIAN"),    REG_DWORD_BIG_ENDIAN,
        TEXT("REG_EXPAND_SZ"),           REG_EXPAND_SZ,
        TEXT("REG_LINK"),                REG_LINK,
        TEXT("REG_MULTI_SZ"),            REG_MULTI_SZ,
        TEXT("REG_NONE"),                REG_NONE,
        TEXT("REG_QWORD"),               REG_QWORD,
        TEXT("REG_QWORD_LITTLE_ENDIAN"), REG_QWORD_LITTLE_ENDIAN,
        TEXT("REG_RESOUCE_LIST"),        REG_RESOURCE_LIST,
        TEXT("REG_SZ"),                  REG_SZ,
        TEXT(""),                        0
    };

    if (lpStrType == NULL)
    {
        return REG_NONE;
    }

    for (nIndex = 0 ; arrRegEntries[nIndex].szStrType[0] != TEXT('\0') ; nIndex++)
    {
        if (MyStrCmpI(lpStrType, arrRegEntries[nIndex].szStrType) == 0)
        {
            return arrRegEntries[nIndex].dwType;
        }
    }

    return REG_NONE;
}








//*************************************************************
// GetFirstEnvStrLen
//
// Purpose:    Get the environment string length if it is at the beginning.
//
// Parameter:  lpStr: Input string
//
// Notes:      none
//
// History:    3/25/2001 geoffguo created
//*************************************************************
DWORD GetFirstEnvStrLen (LPTSTR lpStr)
{
    DWORD dwLen = 0;
    DWORD dwSize, i;
    TCHAR cTemp;

    if (lpStr[0] == L'%')
    {
        dwSize = lstrlen(lpStr);
        for (i = 1; i < dwSize; i++)
            if (lpStr[i] == L'%')
                break;

        if (i < dwSize)
        {
            cTemp = lpStr[i+1];
            lpStr[i+1] = (TCHAR)'\0';
            dwLen = ExpandEnvironmentStrings (lpStr, NULL, 0);
            lpStr[i+1] = cTemp;
        }
    }

    return dwLen;
}

//*************************************************************
// StringValidationCheck
//
// Purpose:    Check the string to see if it is a valid system path
//
// Parameter:  lpOriginalStr: Data string to be checked
//             lpSearchStr:   Search string
//             lpSysPath:     Point to standard system path
//             lpszTailCheck: Point to predefined tail character
//             lpAttrib:      Folder attribute
//             dwStrNum:      The number of matching string
//
// Notes:      none
//
// History:    3/18/2001 geoffguo created
//*************************************************************
BOOL StringValidationCheck (
    LPCTSTR  lpOriginalStr,
    LPCTSTR  lpSearchStr,
    LPCTSTR  lpSysPath,
    LPCTSTR  lpTailCheck,
    LPDWORD  lpAttrib,
    DWORD    dwStrNum)
{
    BOOL     bRet = TRUE;
    DWORD    i, dwLen;
    LPTSTR   lpOrgStr, lpTemp1, lpTemp2;

    if (lpAttrib == NULL || lpSysPath == NULL)
        goto Exit;

    dwLen = ExpandEnvironmentStrings (lpOriginalStr, NULL, 0);
    if (dwLen == 0)
    {
        bRet = FALSE;
        goto Exit;
    }
    lpOrgStr = calloc (dwLen+1, sizeof(TCHAR));
    if (!lpOrgStr)
    {
        bRet = FALSE;
        goto Exit;
    }    
    ExpandEnvironmentStrings (lpOriginalStr, lpOrgStr, dwLen+1);

    dwLen = lstrlen(lpSearchStr);
    
    //To avoid hit Documents and Settings wrongly,
    //skip the environment variable at the beginning of the string.
    lpTemp1 = lpOrgStr + GetFirstEnvStrLen((LPTSTR)lpOriginalStr);

    for (i = 0; i < dwStrNum; i++)
    {
        lpTemp2 = StrStrI(lpTemp1, lpSearchStr);
        if (!lpTemp2)
        {
            bRet = FALSE;
            goto Exit1;
        }
        lpTemp1 = lpTemp2+dwLen;
    }

    if (*(lpTemp2+dwLen) == *lpTailCheck)
    {
        bRet = FALSE;
        goto Exit1;
    }
    
    if (StrStrI(lpOriginalStr, L"\\Device\\HarddiskVolume"))
    {
        bRet = TRUE;
        goto Exit1;
    }

    switch (*lpAttrib & 0xffff)
    {
    /*
    CSIDL_DESKTOP                  // <desktop>
    CSIDL_INTERNET                 // Internet Explorer (icon on desktop)
    CSIDL_CONTROLS                 // My Computer\Control Panel
    CSIDL_PRINTERS                 // My Computer\Printers
    CSIDL_BITBUCKET                // <desktop>\Recycle Bin
    CSIDL_MYDOCUMENTS              // logical "My Documents" desktop icon
    CSIDL_DRIVES                   // My Computer
    CSIDL_NETWORK                  // Network Neighborhood (My Network Places)
    CSIDL_FONTS                    // windows\fonts
    CSIDL_ALTSTARTUP               // non localized startup
    CSIDL_COMMON_ALTSTARTUP        // non localized common startup
    CSIDL_WINDOWS                  // GetWindowsDirectory()
    CSIDL_SYSTEM                   // GetSystemDirectory()
    CSIDL_CONNECTIONS              // Network and Dial-up Connections
    CSIDL_PROFILE                  // USERPROFILE
    CSIDL_SYSTEMX86                // x86 system directory on RISC
    CSIDL_PROGRAM_FILESX86         // x86 C:\Program Files on RISC
    CSIDL_PROGRAM_FILES_COMMONX86  // x86 Program Files\Common on RISC
    CSIDL_RESOURCES                // Resource Direcotry
    CSIDL_RESOURCES_LOCALIZED      // Localized Resource Direcotry
    CSIDL_COMMON_OEM_LINKS         // Links to All Users OEM specific apps
    CSIDL_COMPUTERSNEARME          // Computers Near Me (computered from Workgroup membership)
    */
        case CSIDL_COMMON_APPDATA:           // All Users\Application Data
        case CSIDL_COMMON_DESKTOPDIRECTORY:  // All Users\Desktop
        case CSIDL_COMMON_STARTMENU:         // All Users\Start Menu
        case CSIDL_COMMON_TEMPLATES:         // All Users\Templates
        case CSIDL_COMMON_FAVORITES:
        case CSIDL_COMMON_STARTUP:           // All Users\Start Menu\Startup
        case CSIDL_COMMON_MUSIC:             // All Users\My Music
        case CSIDL_COMMON_PICTURES:          // All Users\My Pictures
        case CSIDL_COMMON_VIDEO:             // All Users\My Video
        case CSIDL_COMMON_ADMINTOOLS:        // All Users\Start Menu\Programs\Administrative Tools
        case CSIDL_COMMON_PROGRAMS:          // All Users\Start Menu\Programs
        case CSIDL_COMMON_ACCESSORIES:       // All Users\Start Menu\Programs\Accessaries
        case CSIDL_COMMON_DOCUMENTS:         // All Users\Documents
        case CSIDL_STARTMENU:                // <user name>\Start Menu
        case CSIDL_DESKTOPDIRECTORY:         // <user name>\Desktop
        case CSIDL_NETHOOD:                  // <user name>\nethood
        case CSIDL_TEMPLATES:                // <user name>\Templates
        case CSIDL_APPDATA:                  // <user name>\Application Data
        case CSIDL_LOCAL_SETTINGS:           // <user name>\Local Settings
        case CSIDL_PRINTHOOD:                // <user name>\PrintHood
        case CSIDL_FAVORITES:                // <user name>\Favorites
        case CSIDL_RECENT:                   // <user name>\Recent
        case CSIDL_SENDTO:                   // <user name>\SendTo
        case CSIDL_COOKIES:                  // <user name>\Cookies
        case CSIDL_HISTORY:                  // <user name>\History
        case CSIDL_PERSONAL:                 // <user name>\My Documents
        case CSIDL_MYMUSIC:                  // <user name>\My Document\My Music
        case CSIDL_MYPICTURES:               // <user name>\My Document\My Pictures
        case CSIDL_ADMINTOOLS:               // <user name>\Start Menu\Programs\Administrative Tools
        case CSIDL_PROGRAMS:                 // <user name>\Start Menu\Programs
        case CSIDL_STARTUP:                  // <user name>\Start Menu\Programs\Startup
        case CSIDL_ACCESSORIES:              // <user name>\Start Menu\Programs\Accessaries
        case CSIDL_LOCAL_APPDATA:            // <user name>\Local Settings\Applicaiton Data (non roaming)
        case CSIDL_INTERNET_CACHE:           // <user name>\Local Settings\Temporary Internet Files
        case CSIDL_PROGRAM_FILES_COMMON:     // C:\Program Files\Common
        case CSIDL_PF_ACCESSORIES:           // C:\Program Files\Accessaries
        case CSIDL_PROGRAM_FILES:            // C:\Program Files
        case CSIDL_COMMON_COMMONPROGRAMFILES_SERVICES:   //for %CommonProgramFiles%\services
        case CSIDL_COMMON_PROGRAMFILES_ACCESSARIES:      //for %ProgramFiles%\accessaries
        case CSIDL_COMMON_PROGRAMFILES_WINNT_ACCESSARIES: //for %ProgramFiles%\Windows NT\accessaries
        case CSIDL_MYVIDEO:                  // "My Videos" folder
        case CSIDL_CDBURN_AREA:              // USERPROFILE\Local Settings\Application Data\Microsoft\CD Burning
        case CSIDL_COMMON_ACCESSORIES_ACCESSIBILITY:
        case CSIDL_COMMON_ACCESSORIES_ENTERTAINMENT:
        case CSIDL_COMMON_ACCESSORIES_SYSTEM_TOOLS:
        case CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS:
        case CSIDL_COMMON_ACCESSORIES_MS_SCRIPT_DEBUGGER:
        case CSIDL_COMMON_ACCESSORIES_GAMES:
        case CSIDL_COMMON_WINDOWSMEDIA:
        case CSIDL_COMMON_COVERPAGES:
        case CSIDL_COMMON_RECEIVED_FAX:
        case CSIDL_COMMON_SENT_FAX:
        case CSIDL_COMMON_FAX:
        case CSIDL_FAVORITES_LINKS:
        case CSIDL_FAVORITES_MEDIA:
        case CSIDL_ACCESSORIES_ACCESSIBILITY:
        case CSIDL_ACCESSORIES_SYSTEM_TOOLS:
        case CSIDL_ACCESSORIES_ENTERTAINMENT:
        case CSIDL_ACCESSORIES_COMMUNICATIONS:
        case CSIDL_ACCESSORIES_COMMUNICATIONS_HYPERTERMINAL:
        case CSIDL_PROFILES_DIRECTORY:
        case CSIDL_USERNAME_IN_USERPROFILE:
        case CSIDL_UAM_VOLUME:
        case CSIDL_COMMON_SHAREDTOOLS_STATIONERY:
        case CSIDL_NETMEETING_RECEIVED_FILES:
        case CSIDL_COMMON_NETMEETING_RECEIVED_FILES:
        case CSIDL_COMMON_ACCESSORIES_COMMUNICATIONS_FAX:
        case CSIDL_FAX_PERSONAL_COVER_PAGES:
        case CSIDL_FAX:
            bRet = ReverseStrCmp(lpTemp2, lpSysPath);
            break;
        default:
            break;
    }

Exit1:
    free (lpOrgStr);

Exit:
    return bRet;
}



//*************************************************************
// ReplaceMultiMatchInString
//
// Purpose:    Replace the string at multiple place in data string
//
// Parameter:  lpOldStr:      Data string to be checked
//             lpNewStr:      Output string buffer
//             cbNewStr:      Size of output string buffer
//             dwMaxMatchNum: Max posible match number
//             lpRegStr:      String and attribute table
//             bStrCheck:     True -- do it, or False -- skip it
//
// Notes:      none
//
// History:    12/10/2001 geoffguo created
//*************************************************************
BOOL ReplaceMultiMatchInString(
    LPTSTR   lpOldStr,
    LPTSTR   lpNewStr,
    size_t   cbNewStr,
    DWORD    dwMaxMatchNum,
    PREG_STRING_REPLACE lpRegStr,
    LPDWORD  pAttrib,
    BOOL     bStrCheck)
{
    BOOL     bRet = FALSE;
    LPCTSTR  lpSearchStr;
    LPCTSTR  lpReplaceStr;
    LPTSTR   lpMiddleStr;
    LPCTSTR  lpPath;
    LPDWORD  lpAttrib;
    TCHAR    cNonChar = L'\xFFFF';
    TCHAR    cSpaceChar = L' ';
    TCHAR    cDotChar = L'.';
    TCHAR    cRightChar;
    DWORD    cchMiddleStr;


    cchMiddleStr = lstrlen(lpOldStr) + lpRegStr->cchMaxStrLen * dwMaxMatchNum;
    lpMiddleStr = (LPTSTR) calloc(cchMiddleStr, sizeof(TCHAR));
    if (!lpMiddleStr)
    {
        goto Exit;
    }

    if (FAILED(StringCchCopy(lpMiddleStr, cchMiddleStr,lpOldStr)))
    {
        goto Exit;
    }
    lpSearchStr = lpRegStr->lpSearchString;
    lpReplaceStr = lpRegStr->lpReplaceString;
    lpAttrib = lpRegStr->lpAttrib;
    if (lpRegStr->lpFullStringList)
    {
        lpPath = lpRegStr->lpFullStringList;
    }
    else
    {
        lpPath = NULL;
    }
    while (*lpSearchStr && *lpReplaceStr)
    {
        if (bStrCheck)
        {
            if (*lpAttrib == CSIDL_COMMON_DOCUMENTS)
            {
                cRightChar = cSpaceChar;
            } else if (*lpAttrib == CSIDL_USERNAME_IN_USERPROFILE)
            {
                cRightChar = cDotChar;
            }
            else
            {
                cRightChar = cNonChar;
            }
        }

        if(ReplaceString(lpMiddleStr, lpSearchStr, lpReplaceStr, lpNewStr, cchMiddleStr, &cRightChar, lpPath, lpAttrib, bStrCheck))
        {
            if (bStrCheck)
            {
                *pAttrib |= *lpAttrib;
            }
            bRet = TRUE;
        }

        if (FAILED(StringCchCopy(lpMiddleStr, cchMiddleStr,lpNewStr)))
            goto Exit;

        lpSearchStr += lstrlen(lpSearchStr) + 1;
        lpReplaceStr += lstrlen(lpReplaceStr) + 1;
        if (lpPath)
        {
            lpPath += lstrlen(lpPath) + 1;
        }
        if (lpAttrib)
        {
            lpAttrib++;
        }
    }
    
Exit:
    if(lpMiddleStr)
    {
        free(lpMiddleStr);
    }
    return bRet;
}


//-----------------------------------------------------------------------------
//
//  Function:   ComputeLocalProfileName
//
//  Synopsis:   Constructs the pathname of the local profile for user.
//              It will attempt to create user profile directory using
//              username. If the directory exists, it will append a counter
//              after users name e.g. %documentsettings%\username.001
//
//  Returns:    TRUE if succeeded, FALSE otherwise
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL ComputeLocalProfileName(
    LPCTSTR lpOldUserName,      // Old user name
    LPCTSTR lpNewUserName,      // New user name
    LPTSTR  lpNewProfilePath,   // Output buffer store new profile path
    size_t  cchNewProfilePath,  // Size of profile path buffer (in WCHAR)
    UINT    nRegType            // Read the output in REG_SZ or REG_EXPAND_SZ
)
{
    HANDLE hFile;
    TCHAR  szProfilePath[MAX_PATH];
    TCHAR  szUserProfilePath[MAX_PATH];
    TCHAR  szExpUserProfilePath[MAX_PATH];
    TCHAR  szComputerName[16];
    DWORD  cbSize;
    DWORD  dwType;
    LONG   lRet;
    DWORD  cchSize;
    size_t nCounter;
    HKEY   hKey;
    HRESULT hr;
    WIN32_FIND_DATA fd;

    if (lpOldUserName == NULL || lpOldUserName[0] == TEXT('\0') ||
        lpNewUserName == NULL || lpNewUserName[0] == TEXT('\0') ||
        lpNewProfilePath == NULL)
    {
        return FALSE;
    }

    //
    // If user name does not change, return the current user's profile path
    //
    if (MyStrCmpI(lpOldUserName, lpNewUserName) == 0)
    {
        hr = GetSetUserProfilePath(lpOldUserName,
                                   lpNewProfilePath,
                                   cchNewProfilePath,
                                   PROFILE_PATH_READ,
                                   nRegType);
        if (SUCCEEDED(hr))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    //
    // Get ProfilesDirectory from registry
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     g_cszProfileList,
                     0,
                     KEY_READ,
                     &hKey)
        == ERROR_SUCCESS)
    {
        cbSize = sizeof(szProfilePath);
        
        lRet = RegQueryValueEx(hKey,
                               PROFILES_DIRECTORY, 
                               NULL, 
                               &dwType, 
                               (LPBYTE) szProfilePath, 
                               &cbSize);
        RegCloseKey(hKey);

        if (lRet != ERROR_SUCCESS)
        {
            DPF(dlError,
                TEXT("ComputeLocalProfileName: Unable to query reg value <%s>"),
                PROFILES_DIRECTORY);
            return FALSE;
        }
    }
    else
    {
        DPF(dlError,
            TEXT("ComputeLocalProfileName: Unable to open reg key <%s>"),
            g_cszProfileList);
        return FALSE;
    }

    // Compose a new user profile directory
    hr = StringCchPrintf(szUserProfilePath,
                         ARRAYSIZE(szUserProfilePath),
                         TEXT("%s\\%s"),
                         szProfilePath,
                         lpNewUserName);
    if ( FAILED(hr) )
    {
        return FALSE;
    }

    // Profile path still contains environment strings, need to expand it
    ExpandEnvironmentStrings(szUserProfilePath,
                             szExpUserProfilePath,
                             ARRAYSIZE(szExpUserProfilePath));

    // Does this directory exist?
    hFile = FindFirstFile(szExpUserProfilePath, &fd);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        //
        // Directory does not exist, use this name
        //
        hr = StringCchCopy(lpNewProfilePath, cchNewProfilePath, szUserProfilePath);
        if ( FAILED(hr) )
        {
            return FALSE;
        }

        return TRUE;
    }
    else
    {
        //
        // Directory exists, try different name
        //
        FindClose(hFile);

        // Try appending username with computer Name
        cchSize = ARRAYSIZE(szComputerName);
        GetComputerName(szComputerName, &cchSize);

        hr = StringCchPrintf(szUserProfilePath,
                             ARRAYSIZE(szUserProfilePath),
                             TEXT("%s\\%s.%s"),
                             szProfilePath,
                             lpNewUserName,
                             szComputerName);
        if ( FAILED(hr) )
        {
            return FALSE;
        }

        // Profile path still contains environment strings, need to expand it
        ExpandEnvironmentStrings(szUserProfilePath,
                                 szExpUserProfilePath,
                                 ARRAYSIZE(szExpUserProfilePath));

        // Does the new directory name exist?
        hFile = FindFirstFile(szExpUserProfilePath, &fd);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            // Directory does not exist, use this one
            hr = StringCchCopy(lpNewProfilePath, cchNewProfilePath, szUserProfilePath);
            if ( FAILED(hr) )
            {
                return FALSE;
            }

            return TRUE;
        }
        else
        {
            //
            // This directory also exists
            //
            FindClose(hFile);

            for (nCounter = 0 ; nCounter < 1000 ; nCounter++)
            {
                // Try appending counter after user name
                hr = StringCchPrintf(szUserProfilePath,
                                     ARRAYSIZE(szUserProfilePath),
                                     TEXT("%s\\%s.%.3d"),
                                     szProfilePath,
                                     lpNewUserName,
                                     nCounter);
                if ( FAILED(hr) )
                {
                    return FALSE;
                }

                // Profile path still contains environment strings, need to expand it
                ExpandEnvironmentStrings(szUserProfilePath,
                                         szExpUserProfilePath,
                                         ARRAYSIZE(szExpUserProfilePath));

                // Does this directory name exist?
                hFile = FindFirstFile(szExpUserProfilePath, &fd);
                if (INVALID_HANDLE_VALUE == hFile)
                {
                    // Directory does not exist, use this one
                    hr = StringCchCopy(lpNewProfilePath,
                                       cchNewProfilePath,
                                       szUserProfilePath);
                    if ( FAILED(hr) )
                    {
                        return FALSE;
                    }

                    return TRUE;
                }
                else
                {
                    // Directory exists, keep finding...
                    FindClose(hFile);
                }
            }
        }
    }

    // If we reach here, we could not find a new profile directory for this user
    return FALSE;
}


//-----------------------------------------------------------------------------
//
//  Function:   UpdateProgress
//
//  Synopsis:   Simple progress clock, display the progress during 
//              long operation.
//
//  Returns:    none.
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
void UpdateProgress()
{
    static unsigned short n;
    const TCHAR clock[] = TEXT("-\\|/");

    wprintf(TEXT("%lc\r"), clock[n]);
    n++;
    n %= 4;
}



//-----------------------------------------------------------------------//
//
// GetMaxStrLen()
//
// Get Maximum searching strings and replace strings length for string
// buffer memery allocation.
//
// lpRegStr:  Input parameter structure
//
// Notes:      none
//
// History:    12/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
DWORD GetMaxStrLen (
PREG_STRING_REPLACE lpRegStr)
{
    DWORD   dwLen = 0;
    DWORD   dwMaxLen;
    LPTSTR  lpStr;


    lpStr = lpRegStr->lpReplaceString;
    dwMaxLen = 0;

    while (*lpStr)
    {
        dwLen = lstrlen(lpStr);

        //dwMaxLen is the max-length in replacement multi-strings
        if (dwLen > dwMaxLen)
            dwMaxLen = dwLen;

        lpStr += dwLen + 1;
    }

    lpStr = lpRegStr->lpSearchString;
    while (*lpStr)
    {
        dwLen = lstrlen(lpStr);

        //dwMaxLen is the max-length in search and replacement multi-strings
        if (dwLen > dwMaxLen)
            dwMaxLen = dwLen;

        lpStr += dwLen + 1;
    }

    return dwMaxLen;
}

//-----------------------------------------------------------------------//
//
// AddNodeToList()
//
// lpVal:      The node needed to add.
// lpValList:  The head of the list.
//
// Notes:      none
//
// History:    12/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
DWORD AddNodeToList (
PVALLIST lpVal,
PVALLIST *lpValList)
{
    DWORD    nResult = ERROR_SUCCESS;
    PVALLIST lpTemp;

    if (!*lpValList)
    {
        *lpValList = lpVal;
    } else
    {
        lpTemp = *lpValList;

        while (lpTemp->pvl_next)
            lpTemp = lpTemp->pvl_next;
        
        lpTemp->pvl_next = lpVal;
    }

    return nResult;
}

//-----------------------------------------------------------------------//
//
// RemoveValueList()
//
// lpValList:  The head of the list.
//
// Notes:      none
//
// History:    12/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
DWORD RemoveValueList (
PVALLIST *lpValList)
{
    DWORD    nResult = ERROR_SUCCESS;
    PVALLIST lpTemp, lpDel;

    if (*lpValList)
    {
        lpTemp = *lpValList;

        while (lpTemp)
        {
            lpDel = lpTemp;
            lpTemp = lpTemp->pvl_next;
            if (lpDel->ve.ve_valuename)
                free (lpDel->ve.ve_valuename);
            if (lpDel->ve.ve_valueptr)
                free ((LPBYTE)(lpDel->ve.ve_valueptr));
            if (lpDel->lpPre_valuename)
                free (lpDel->lpPre_valuename);
            free (lpDel);
        }
    }

    return nResult;
}

//-----------------------------------------------------------------------//
//
// FreeStrList()
//
// lpStrList:   The head of the list.
//
//
// Notes:      none
//
// History:    12/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
void FreeStrList (
PSTRLIST lpStrList)
{
    if (lpStrList->pst_next)
        FreeStrList (lpStrList->pst_next);

    if (lpStrList->lpstr)
        free (lpStrList->lpstr);

    free (lpStrList);
}

//-----------------------------------------------------------------------//
//
// GetMaxMatchNum()
//
// Get maximum string match number.
//
// lpDataStr:  Search string
// lpRegStr:   Input parameter structure
//
// Notes:      none
//
// History:    12/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
DWORD
GetMaxMatchNum (
LPTSTR lpDataStr,
PREG_STRING_REPLACE lpRegStr)
{
    DWORD  dwMatchNum, dwLen;
    LPTSTR lpTemp;
    LPTSTR lpSearchStr;
    LPTSTR lpFound;

    lpSearchStr = lpRegStr->lpSearchString;
    dwMatchNum = 0;

    while (*lpSearchStr)
    {
        lpTemp = lpDataStr;

        while (lpFound = StrStrI(lpTemp, lpSearchStr))
        {
            dwMatchNum++;
            lpTemp = lpFound + 1;
        }
        
        dwLen = lstrlen(lpSearchStr);
        lpSearchStr += dwLen + 1;
    }

    return dwMatchNum;
}

//-----------------------------------------------------------------------//
//
// ReplaceSingleString()
//
// DESCRIPTION:
// Analize a single string and replace localized string to English.
//
// lpOldDataStr:  String data
// dwType:        Type of string
// lpRegStr:      Input parameter structure
// lpFullKey:     Full sub-key path
//
// Notes:      none
//
// History:    11/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
LPTSTR ReplaceSingleString (
    LPTSTR                  lpOldDataStr,
    DWORD                   dwType,
    PREG_STRING_REPLACE     lpRegStr,
    LPTSTR                  lpFullKey,
    LPDWORD                 pAttrib,
    BOOL                    bStrChk)
{
    DWORD    dwMatchNum;
    LPTSTR   lpNewDataStr = NULL;
    size_t   cbNewDataStr;

    if (!lpOldDataStr)
        goto Exit;

    dwMatchNum = GetMaxMatchNum (lpOldDataStr, lpRegStr);

    if (dwMatchNum > 0)
    {
        if (dwType != REG_DWORD && *lpOldDataStr)
        {
            cbNewDataStr = lstrlen(lpOldDataStr) + lpRegStr->cchMaxStrLen * dwMatchNum;
            lpNewDataStr = (LPTSTR) calloc(cbNewDataStr, sizeof(TCHAR));
            if (!lpNewDataStr)
            {
                DPF (dlError, L"ReplaceSingleString: No enough memory");
                goto Exit;
            } 
            
            if (!ReplaceMultiMatchInString(lpOldDataStr, lpNewDataStr, cbNewDataStr, dwMatchNum, lpRegStr, pAttrib, bStrChk))
            {
                free (lpNewDataStr);
                lpNewDataStr = NULL;
            }
        }
    }

Exit:
    return lpNewDataStr;
}

//-----------------------------------------------------------------------//
//
// ReplaceValueSettings()
//
// Rename value setting based on input parameter
//
// szUserName:    User name
// lpOldDataStr:  String value data
// dwSize:        Size of string data
// lpOldValueName:Value name
// dwType:        Type of string
// lpRegStr:      Input parameter structure
// lpValList:     Updated value list
// lpFullKey:     Full sub-key path
//
// Notes:      none
//
// History:    11/10/2001 geoffguo created
//
//-----------------------------------------------------------------------//
HRESULT ReplaceValueSettings (
    LPTSTR              szUserName,
    LPTSTR              lpOldDataStr,
    DWORD               dwSize,
    LPTSTR              lpOldValueName,
    DWORD               dwType,
    PREG_STRING_REPLACE lpRegStr,
    PVALLIST            *lpValList,
    LPTSTR              lpFullKey,
    BOOL                bStrChk)
{
    BOOL     bValueName = FALSE;
    BOOL     bValueData = FALSE;
    HRESULT  hResult = S_OK;
    DWORD    dwOutputSize = 0, dwMatchNum = 0;
    LPTSTR   lpNewDataStr = NULL;
    LPTSTR   lpNewValueName = NULL;
    LPTSTR   lpOutputValueName;
    LPTSTR   lpEnd;
    LPBYTE   lpOutputData;
    PVALLIST lpVal = NULL;
    PSTRLIST lpStrList = NULL;
    PSTRLIST lpLastList = NULL;
    PSTRLIST lpTempList = NULL;
    size_t   cbPre_valuename;
    DWORD    dwAttrib = 0;


    lpStrList = (PSTRLIST) calloc(sizeof(STRLIST), 1);
    lpLastList = lpStrList;
    if (!lpLastList)
    {
        hResult = E_OUTOFMEMORY;
        DPF (dlError, L"ReplaceValueSettings1: No enough memory");
        goto Exit;
    }
    
    if ( (dwType & 0xffff)== REG_MULTI_SZ)
    {
        lpEnd = lpOldDataStr;

        while(lpEnd < (lpOldDataStr + dwSize/sizeof(TCHAR)))
        {
            if(*lpEnd == (TCHAR)'\0')
            {
                //empty string
                dwOutputSize += sizeof(TCHAR);
                lpEnd++;
            }
            else
            {
               lpNewDataStr = ReplaceSingleString (
                                            lpEnd,
                                            dwType,
                                            lpRegStr,
                                            lpFullKey,
                                            &dwAttrib,
                                            bStrChk);
               if (lpNewDataStr)
               {
                   lpLastList->lpstr = lpNewDataStr;
                   bValueData = TRUE;
               }
               else
               {
                   size_t cbBufLen = lstrlen(lpEnd)+1;
                   lpLastList->lpstr = calloc(cbBufLen, sizeof(TCHAR));
                   if (!lpLastList->lpstr)
                   {
                       hResult = E_OUTOFMEMORY;
                       DPF (dlError, L"ReplaceValueSettings2: No enough memory");
                       goto Exit;
                   }
                   hResult = StringCchCopy(lpLastList->lpstr, cbBufLen,lpEnd);
                   if (FAILED(hResult))
                   {
                       DPF (dlError, L"ReplaceValueSettings: buffer too small for %s",lpEnd);
                       goto Exit;
                   }
               }

               dwOutputSize += (lstrlen(lpLastList->lpstr)+1)*sizeof(TCHAR);
               lpEnd += lstrlen(lpEnd)+1;
            }
            lpLastList->pst_next = (PSTRLIST) calloc(sizeof(STRLIST), 1);
            if (!lpLastList->pst_next)
            {
                hResult = E_OUTOFMEMORY;
                DPF (dlError, L"ReplaceValueSettings3: No enough memory");
                goto Exit;
            }

            lpLastList->pst_next->pst_prev = lpLastList;
            lpLastList = lpLastList->pst_next;
            lpLastList->pst_next = NULL;
            lpLastList->lpstr = NULL;
        }
        if (lpLastList != lpStrList)
        {
            lpLastList = lpLastList->pst_prev;
            free (lpLastList->pst_next);
            lpLastList->pst_next = NULL;
        }
    }
    else
    {
        lpNewDataStr = ReplaceSingleString (
                                    lpOldDataStr,
                                    dwType,
                                    lpRegStr,
                                    lpFullKey,
                                    &dwAttrib,
                                    bStrChk);

        if (lpNewDataStr)
        {
            lpLastList->lpstr = lpNewDataStr;
            bValueData = TRUE;
        }
        else
        {
            lpLastList->lpstr = calloc(dwSize+sizeof(TCHAR), 1);
            if (!lpLastList->lpstr)
            {
                hResult = E_OUTOFMEMORY;
                DPF (dlError, L"ReplaceValueSettings4: No enough memory");
                goto Exit;
            }

            hResult = StringCbCopy(lpLastList->lpstr, dwSize+sizeof(TCHAR), lpOldDataStr);
            if (FAILED(hResult))
            {
                goto Exit;
            }
        }

        lpLastList->pst_next = NULL;
        dwOutputSize = (lstrlen(lpLastList->lpstr)+1)*sizeof(TCHAR);
    }

    if (lpOldValueName)
        dwMatchNum = GetMaxMatchNum (lpOldValueName, lpRegStr);
    else
        dwMatchNum = 0;

    if (dwMatchNum > 0)
    {
        if (*lpOldValueName)
        {
            size_t cbNewValueName = lstrlen(lpOldValueName) + lpRegStr->cchMaxStrLen * dwMatchNum;
            lpNewValueName = (LPTSTR) calloc(cbNewValueName, sizeof(TCHAR));
            if (!lpNewValueName)
            {
                hResult = E_OUTOFMEMORY;
                DPF (dlError, L"ReplaceValueSettings5: No enough memory");
                goto Exit;
            }
            bValueName = ReplaceMultiMatchInString(lpOldValueName, lpNewValueName,cbNewValueName, dwMatchNum, lpRegStr, &dwAttrib, bStrChk);
        }
    }

    if (bValueData || bValueName)
    {
        lpVal = (PVALLIST) calloc(sizeof(VALLIST), 1);

        if (!lpVal)
        {
            hResult = E_OUTOFMEMORY;
            DPF (dlError, L"ReplaceValueSettings6: No enough memory");
            goto Exit;
        }

        if (bValueData)
        {
            lpVal->val_type |= REG_CHANGE_VALUEDATA;
        }

        if (bValueName)
        {
            lpOutputValueName = lpNewValueName;
            lpVal->val_type |= REG_CHANGE_VALUENAME;
        } else
            lpOutputValueName = lpOldValueName;
        
        if (lpOutputValueName)
        {
            HRESULT  hr;    
            
            size_t cbValname = lstrlen(lpOutputValueName) + 1;
            lpVal->ve.ve_valuename = (LPTSTR) calloc(cbValname, sizeof(TCHAR));
            if (!lpVal->ve.ve_valuename)
            {
                hResult = E_OUTOFMEMORY;
                DPF (dlError, L"ReplaceValueSettings7: No enough memory");
                goto Exit;
            }
            //We calculte the buffer for lpVal->lpPre_valuename, so here StringCchCopy should be
            //always success, assinging return value just make prefast happy 
            hr = StringCchCopy (lpVal->ve.ve_valuename, cbValname, lpOutputValueName);
        } else
            lpVal->ve.ve_valuename = NULL;

        lpVal->ve.ve_valueptr = (DWORD_PTR) calloc(dwOutputSize, 1);
        if (!lpVal->ve.ve_valueptr)
        {
            free (lpVal->ve.ve_valuename);
            hResult = E_OUTOFMEMORY;
            DPF (dlError, L"ReplaceValueSettings8: No enough memory");
            goto Exit;
        }

        if (lpOldValueName)
        {
            cbPre_valuename = lstrlen(lpOldValueName)+1;
            lpVal->lpPre_valuename = (LPTSTR)calloc(cbPre_valuename, sizeof(TCHAR));
            if (!lpVal->lpPre_valuename)
            {
                free (lpVal->ve.ve_valuename);
                free ((LPBYTE)(lpVal->ve.ve_valueptr));
                hResult = E_OUTOFMEMORY;
                DPF (dlError, L"ReplaceValueSettings9: No enough memory");
                goto Exit;
            }
        } else
            lpVal->lpPre_valuename = NULL;

        lpVal->val_attrib = dwAttrib;

        lpOutputData = (LPBYTE)(lpVal->ve.ve_valueptr);

        lpTempList = lpStrList;
        do {
            if (lpTempList->lpstr)
                memcpy (lpOutputData, (LPBYTE)lpTempList->lpstr, (lstrlen(lpTempList->lpstr)+1)*sizeof(TCHAR));
            else
            {
                lpOutputData[0] = (BYTE)0;
                lpOutputData[1] = (BYTE)0;
            }
            lpOutputData += (lstrlen((LPTSTR)lpOutputData)+1)*sizeof(TCHAR);
            lpTempList = lpTempList->pst_next;
        } while (lpTempList != NULL);

        if (lpOldValueName)
        {
            HRESULT  hr;    
            //We calculte the buffer for lpVal->lpPre_valuename, so here StringCchCopy should be
            //always success, assinging return value just make prefast happy 
            hr = StringCchCopy(lpVal->lpPre_valuename, cbPre_valuename, lpOldValueName);
        }

        lpVal->ve.ve_valuelen = dwOutputSize;
        lpVal->ve.ve_type = dwType;
        lpVal->pvl_next = NULL;
        lpVal->md.dwMDIdentifier = 0x00FFFFFF;

        AddNodeToList(lpVal, lpValList);
    }
    else
        hResult = S_OK;

Exit:
    if (lpStrList)
    {
        FreeStrList (lpStrList);
    }

    if(lpNewValueName)
    {
        free(lpNewValueName);
    }
    return hResult;
}


//-----------------------------------------------------------------------
//
//  Function:   IsAdmin
//
//  Descrip:    Check whether current user is in administrators group
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//                         
//-----------------------------------------------------------------------

BOOL IsAdmin()
{
    // get the administrator sid        
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    BOOL bIsAdmin = FALSE;

    
    if(!AllocateAndInitializeSid(&siaNtAuthority, 2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0,
        &psidAdministrators))
    {
        return FALSE;
    }

    // on NT5, we should use the CheckTokenMembershipAPI to correctly handle cases where
    // the Adiminstrators group might be disabled. bIsAdmin is BOOL for 

    // CheckTokenMembership checks if the SID is enabled in the token. NULL for
    // the token means the token of the current thread. Disabled groups, restricted
    // SIDS, and SE_GROUP_USE_FOR_DENY_ONLY are all considered. If the function
    // returns false, ignore the result.
    if (!CheckTokenMembership(NULL, psidAdministrators, &bIsAdmin))
    {
        bIsAdmin = FALSE;
    }
   
    FreeSid(psidAdministrators);
    return bIsAdmin;
}


//-----------------------------------------------------------------------
//
//  Function:   DoesUserHavePrivilege
//
//  Descrip:    
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz copied from NTSETUP
//
//  Routine Description:

//  This routine returns TRUE if the caller's process has
//  the specified privilege.  The privilege does not have
//  to be currently enabled.  This routine is used to indicate
//  whether the caller has the potential to enable the privilege.
//  Caller is NOT expected to be impersonating anyone and IS
//  expected to be able to open their own process and process
//  token.

// Arguments:

//    Privilege - the name form of privilege ID (such as
//        SE_SECURITY_NAME).

//Return Value:

//  TRUE - Caller has the specified privilege.

//   FALSE - Caller does not have the specified privilege.


BOOL
DoesUserHavePrivilege(
    PTSTR PrivilegeName
    )
{
    HANDLE Token;
    ULONG BytesRequired;
    PTOKEN_PRIVILEGES Privileges;
    BOOL b;
    DWORD i;
    LUID Luid;


    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Privileges = NULL;

    //
    // Get privilege information.
    //
    if(!GetTokenInformation(Token,TokenPrivileges,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Privileges = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenPrivileges,Privileges,BytesRequired,&BytesRequired)
    && LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {

        //
        // See if we have the requested privilege
        //
        for(i=0; i<Privileges->PrivilegeCount; i++) {

            if(!memcmp(&Luid,&Privileges->Privileges[i].Luid,sizeof(LUID))) {

                b = TRUE;
                break;
            }
        }
    }

    //
    // Clean up and return.
    //

    if(Privileges) {
        LocalFree((HLOCAL)Privileges);
    }

    CloseHandle(Token);

    return(b);
}


//-----------------------------------------------------------------------
//
//  Function:   EnablePrivilege
//
//  Descrip:    
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz copied from NTSETUP
//
//  Notes:      
//                         
//-----------------------------------------------------------------------
BOOL
EnablePrivilege(
    IN PTSTR PrivilegeName,
    IN BOOL  Enable
    )
{
    HANDLE Token;
    BOOL b;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;


    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        return(FALSE);
    }

    if(!LookupPrivilegeValue(NULL,PrivilegeName,&Luid)) {
        CloseHandle(Token);
        return(FALSE);
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;

    b = AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

    return(b);
}
//-----------------------------------------------------------------------
//
//  Function:   GetCurrentControlSet
//
//  Descrip:    
//
//  Returns:    INT
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      the HKLM\SYSTEM\CurrentControlSet is actually is copy of
//              HKLM\SYSTEM\ControlSetXXX, the XXX is specified in 
//              HKLM\SYSTEM\Select\Current . This API returns this XXX, 
//              if it failed , it returns -1
//                         
//-----------------------------------------------------------------------
INT GetCurrentControlSet()
{
    DWORD dwErr;
    DWORD dwCurrrent,dwSize;
    HKEY  hKey = NULL;

    dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\Select"),
                          0,
                          KEY_READ,
                          &hKey );

 
    // if failed to open registry key , return -1
    if( dwErr != ERROR_SUCCESS ) 
    {
        dwCurrrent = -1;
        hKey = NULL;
        goto Cleanup;
    }


    dwSize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hKey,
                            TEXT("Current"),
                            NULL,  //reserved
                            NULL,  //type
                            (LPBYTE) &dwCurrrent,
                            &dwSize );

    if(dwErr != ERROR_SUCCESS) 
    {
        dwCurrrent = -1;
        goto Cleanup;
    }
    //Notes:here we succeeded in geting the value, do we need to do
    //a registry open to make sure the actual HKLM\SYSTEM\ControlSetXXX
    //is there
Cleanup:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    return dwCurrrent;    
}


//-----------------------------------------------------------------------
//
//  Function:   ReplaceCurrentControlSet
//
//  Descrip:    
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      replace CurrentControlSet with ControlSetXXX
//                         
//-----------------------------------------------------------------------
HRESULT ReplaceCurrentControlSet(LPTSTR strList)
{
    INT     nCurrent;
    TCHAR   szCurrCrtlSet[MAX_PATH];
    DWORD   dwStrLen;
    TCHAR   *lpTmpBuf;
    HRESULT hr;

    //If the string list is empty .we just return
    dwStrLen = MultiSzLen(strList);
    if (dwStrLen < 3)
    {
        return S_OK;
    }    

    //If there is no CurrentControlSet in the String list, just return
    if (!MultiSzSubStr (TEXT("CurrentControlSet"),strList))
    {
        return S_FALSE;
    }
    //Get the CurrentControlSet #, this is specified in registry , detail see GetCurrentControlSet
    nCurrent = GetCurrentControlSet();

    // if we can not get, just bail out
    if (nCurrent < 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //This indeed will never fail, unless this registry value has been tamnpered, 
    // we will bail out then
    if (FAILED(hr = StringCchPrintf(szCurrCrtlSet,MAX_PATH,TEXT("ControlSet%03d\0"),nCurrent)))
    {
        return hr;
    }

    //Get a Temp buffer for saving replaced string, dwStrLen already includes the last NULL
    // in this multi-sz string
    lpTmpBuf = malloc( dwStrLen * sizeof(TCHAR) );
    if (!lpTmpBuf)
    {
        return E_OUTOFMEMORY;
    }

    memmove((BYTE*)lpTmpBuf,(BYTE*)strList,dwStrLen * sizeof(TCHAR));
    hr = StringMultipleReplacement(lpTmpBuf,TEXT("CurrentControlSet\0"),szCurrCrtlSet,strList,dwStrLen);
    if (FAILED(hr))
    {
        memmove(strList,lpTmpBuf,dwStrLen * sizeof(TCHAR));
    }
    free(lpTmpBuf);
    return hr;
}


//-----------------------------------------------------------------------
//
//  Function:   UnProtectSFPFiles
//
//  Descrip:    
//
//  Returns:    DWORD
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      Unprotect a list of files specified by multiSzFileList which
//              is multi-sz string. pdwResult is an array of DWORD which will 
//              be specifed whether success or failure of each unprotect action
//              if can be NULL if called does not care this information.
//              the retuan value is BOOL,if is FALSE, it means starting SFP
//              service failed.                 
//                         
//-----------------------------------------------------------------------
BOOL UnProtectSFPFiles(
    IN LPTSTR multiSzFileList,
    IN OUT LPDWORD pdwResult)
{
    HANDLE hSfp = INVALID_HANDLE_VALUE;
    DWORD bResult = TRUE;
    LPTSTR lp;
    LPDWORD lpdw;
    DWORD dw;


    //If the no string there, we just return success
    if (!multiSzFileList)
    {
        goto Cleanup;
    }
    //Connect to SFP service
    hSfp = SfcConnectToServer( NULL );
    if (INVALID_HANDLE_VALUE == hSfp)
    {
        bResult = FALSE;
        goto Cleanup;
    }
    //lp points to Path while lpdw points to the result array
    lp = multiSzFileList;
    lpdw = pdwResult;
    while (*lp)
    {
        DWORD dwResult = NO_ERROR;

        //if the file pointed by lp is in the file protection list
        // unprotect it and put the return value to array
        if (SfcIsFileProtected(hSfp,lp)) 
        {
            dwResult = SfcFileException(hSfp,lp, SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME);
        }
          else
        {
            dw = GetLastError();
        }
        if (lpdw)
        {
            *lpdw = dwResult;
            lpdw++;
        }
        lp = lp + lstrlen(lp) + 1;
    }

Cleanup:
    if (hSfp)
    {
       SfcClose(hSfp);
    }
    return bResult;
    
}



/*++

Routine Description:

    This routine returns TRUE if the caller's process has
    the specified privilege.  The privilege does not have
    to be currently enabled.  This routine is used to indicate
    whether the caller has the potential to enable the privilege.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    lpDir - the direcory which is to be backuped
    lpBackupDir - the backup directory name we got , it should be %lpDir%.CLMTxxx
                - where xxx is 000,001,...
    cChBackupDir is the lpBackupDir's size in TCHAR 
    bFindExist  - if this is TRUE , it means the lpDir has already been backuiped
                - and caller wants to get that dir name
                - if this is FALSE , it means the caller want to find an appriate backup 
                - dir name for lpDir
Return Value:

    TRUE - The directory name found.

    FALSE - The directory can not be found
--*/

BOOL GetBackupDir( 
    LPCTSTR lpDir,
    LPTSTR  lpBackupDir,
    size_t  cChBackupDir,
    BOOL    bFindExist)
{
    BOOL    bResult = FALSE;
    HRESULT hr;
    int     nCounter;
    HANDLE  hFile;
    WIN32_FIND_DATA fd;

    if (!lpDir && !lpDir[0])
    {
        goto Exit;
    }

    if (!lpBackupDir)
    {
        goto Exit;
    }
    
    for (nCounter = 0 ; nCounter < 1000 ; nCounter++)
    {
         // Try appending counter after 
        TCHAR szCounter[10];
        
        _itot(nCounter,szCounter,10);
        hr = StringCchPrintf(lpBackupDir,cChBackupDir, 
                                TEXT("%s.%s%03s"),lpDir,TEXT("clmt"),szCounter);
        if ( FAILED(hr) )
        {
            goto Exit;
        }

        // Does this directory name exist?
        hFile = FindFirstFile(lpBackupDir, &fd);

        if (INVALID_HANDLE_VALUE == hFile)
        {
            // Directory does not exist, use this one
            FindClose(hFile);
            break;
        }
        else
        {   // Directory exists, keep finding...
            FindClose(hFile);
        }
    }//end of for nCounter
    if (nCounter < 1000)
    {
        //we  found a dir name that does not exist
        if (bFindExist)
        {
            if (nCounter > 0)
            {
                TCHAR szCounter[10];
                
                nCounter--;
                _itot(nCounter,szCounter,10);
                hr = StringCchPrintf(lpBackupDir,cChBackupDir, 
                                TEXT("%s.%s%03s"),lpDir,TEXT("clmt"),szCounter);
                if ( FAILED(hr) )
                {
                    goto Exit;
                }
            }
            else
            {
                goto Exit;
            }
        }
        bResult = TRUE;
    }
Exit:
    return (bResult);

}



//Add an entry in INF file for key rename
//szOldKeyPath --- the key needs to be renamed
//szNewKeyPath --- to name to be renamed to 
//szUsername   --- if it's HKLM, HKCR, this needs to be NULL
//               ---- otherwise it's the username for registry

HRESULT AddRegKeyRename(
    LPTSTR lpszKeyRoot,
    LPTSTR lpszOldKeyname,
    LPTSTR lpszNewKeyname,
    LPTSTR szUsername)
{
    TCHAR           *lpszOneLine =NULL;
    TCHAR           *lpszSectionName = NULL;
    DWORD           cchOneLine;
    DWORD           cchSectionNameLen;
    HRESULT         hr;
    TCHAR           szIndex[MAX_PATH];
    LPTSTR          lpUserStringSid = NULL;
    PSID            pSid = NULL;
    LPTSTR          lpszKeyRootWithoutBackSlash = lpszKeyRoot;
    LPTSTR          lpszKeyRootWithoutBackSlash1 = NULL,lpszOldKeyname1 = NULL,lpszNewKeyname1 = NULL;


    if ( !lpszKeyRoot || !lpszOldKeyname || !lpszNewKeyname)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    cchOneLine = lstrlen(lpszKeyRoot)+lstrlen(lpszOldKeyname)+lstrlen(lpszNewKeyname)+MAX_PATH;
    if (szUsername)
    {
        cchSectionNameLen = lstrlen(szUsername)+lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
    }
    else
    {
        cchSectionNameLen = lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
    }
    lpszOneLine = malloc(cchOneLine*sizeof(TCHAR));
    lpszSectionName = malloc(cchSectionNameLen*sizeof(TCHAR));

    if (!lpszOneLine || !lpszSectionName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (lpszKeyRoot[0]==TEXT('\\'))
    {
        lpszKeyRootWithoutBackSlash = lpszKeyRoot + 1;
    }
    if (!szUsername ||!MyStrCmpI(szUsername,TEXT("System")))
    {  
        hr = StringCchCopy(lpszSectionName,cchSectionNameLen,REG_PERSYS_UPDATE);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        if (!MyStrCmpI(szUsername,DEFAULT_USER)
            ||!MyStrCmpI(szUsername,APPLICATION_DATA_METABASE))
        {
            hr = StringCchPrintf(lpszSectionName,cchSectionNameLen,TEXT("%s%s"),
                            REG_PERUSER_UPDATE_PREFIX,szUsername);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        else
        {
            hr = GetSIDFromName(szUsername,&pSid);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
            if (!ConvertSidToStringSid(pSid,&lpUserStringSid))
            {
                lpUserStringSid = NULL;
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }
            if (cchSectionNameLen < (DWORD)(lstrlen(lpUserStringSid)+lstrlen(REG_PERUSER_UPDATE_PREFIX)
                                        + lstrlen(REG_PERSYS_UPDATE)))
            {
                LPTSTR pTmp;
                cchSectionNameLen = lstrlen(lpUserStringSid)+lstrlen(REG_PERUSER_UPDATE_PREFIX)
                                        + lstrlen(REG_PERSYS_UPDATE);                
                pTmp = realloc(lpszSectionName,cchSectionNameLen*sizeof(TCHAR));
                if (!pTmp)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                else
                {
                    lpszSectionName = pTmp;
                }
            }
            hr = StringCchPrintf(lpszSectionName,cchSectionNameLen,TEXT("%s%s"),
                            REG_PERUSER_UPDATE_PREFIX,lpUserStringSid);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
    }   
    AddExtraQuoteEtc(lpszKeyRootWithoutBackSlash,&lpszKeyRootWithoutBackSlash1);
    AddExtraQuoteEtc(lpszOldKeyname,&lpszOldKeyname1);
    AddExtraQuoteEtc(lpszNewKeyname,&lpszNewKeyname1);

    hr = StringCchPrintf(lpszOneLine,cchOneLine,TEXT("%d,\"%s\",\"%s\",\"%s\""),
                   CONSTANT_REG_KEY_RENAME,lpszKeyRootWithoutBackSlash1,
                   lpszOldKeyname1,lpszNewKeyname1);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    g_dwKeyIndex++;
    _itot(g_dwKeyIndex,szIndex,16);
    if (!WritePrivateProfileString(lpszSectionName,szIndex,lpszOneLine,g_szToDoINFFileName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        hr = S_OK;
    }
Cleanup:
    FreePointer(lpszOneLine);
    FreePointer(lpszSectionName);
    
    FreePointer(lpszKeyRootWithoutBackSlash1);
    FreePointer(lpszOldKeyname1);
    FreePointer(lpszNewKeyname1);

    if (lpUserStringSid)
    {
        LocalFree(lpUserStringSid);
    }
    FreePointer(pSid);    
    return (hr);
}

HRESULT SetSectionName (
    LPTSTR   szUsername,
    LPTSTR  *lpszSectionName)
{
    HRESULT hr;
    PSID    pSid = NULL;
    LPTSTR  lpUserStringSid = NULL;
    DWORD   dwCchSectionNameLen;

    if (szUsername)
    {
        dwCchSectionNameLen = lstrlen(szUsername)+lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
    }
    else
    {
        dwCchSectionNameLen = lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
    }

    *lpszSectionName = malloc(dwCchSectionNameLen*sizeof(TCHAR));
    if (!*lpszSectionName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    if (!szUsername 
        ||!MyStrCmpI(szUsername,TEXT("System")))
    {  
        //We calculte the buffer for lpszSectionName, so here StringCchCopy should be
        //always success, assinging return value just make prefast happy 
        hr = StringCchCopy(*lpszSectionName,dwCchSectionNameLen,REG_PERSYS_UPDATE);
    }
    else
    {
        if (!MyStrCmpI(szUsername,DEFAULT_USER)
            ||!MyStrCmpI(szUsername,APPLICATION_DATA_METABASE))
        {
            hr = StringCchPrintf(*lpszSectionName,dwCchSectionNameLen,TEXT("%s%s"),
                            REG_PERUSER_UPDATE_PREFIX,szUsername);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        else
        {
            LPTSTR pTmp;
            hr = GetSIDFromName(szUsername,&pSid);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
            if (!ConvertSidToStringSid(pSid,&lpUserStringSid))
            {
                lpUserStringSid = NULL;
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }
            dwCchSectionNameLen = lstrlen(lpUserStringSid)+lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
            pTmp = realloc(*lpszSectionName,dwCchSectionNameLen*sizeof(TCHAR));
            if (!pTmp)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            else
            {
                *lpszSectionName = pTmp;
            }
            hr = StringCchPrintf(*lpszSectionName,dwCchSectionNameLen,TEXT("%s%s"),
                            REG_PERUSER_UPDATE_PREFIX,lpUserStringSid);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
    }

Cleanup:
    if (lpUserStringSid)
    {
        LocalFree(lpUserStringSid);
    }
    if (FAILED(hr))
        FreePointer(*lpszSectionName);

    FreePointer(pSid);    
    return hr;
}


//Add an entry in INF file for Value rename
//szKeyPath:      Key path
//szOldValueName: Old value name
//szNewValueName: New value name. Set to NULL if value name is not changed.
//szOldValueData: Old value data. Set to NULL if value data is not changed.
//szNewValueData: New value data. Set to NULL if value data is not changed.
//dwType:         Date type REG_SZ,REG_EXPAND_SZ,REG_MULTI_SZ
//dwAttrib:       Value string attribute
//szUsername:     If it's HKLM, HKCR, this needs to be NULL
//                otherwise it's the username for registry

HRESULT AddRegValueRename(
    LPTSTR szKeyPath,
    LPTSTR szOldValueName,
    LPTSTR szNewValueName,
    LPTSTR szOldValueData,
    LPTSTR szNewValueData,
    DWORD  dwType,
    DWORD  dwAttrib,
    LPTSTR szUsername)
{
    HRESULT hr;
    TCHAR *szRenameValueDataLine = NULL;
    TCHAR *szRenameValueNameLine = NULL;
    DWORD dwCchsizeforRenameValueData;
    DWORD dwCchsizeforRenameValueName = MAX_PATH ;
    TCHAR *lpszSectionName = NULL;
    DWORD dwCchSectionNameLen;
    TCHAR szIndex[MAX_PATH];    
    LPTSTR lpUserStringSid = NULL;
    PSID  pSid = NULL;
    LPTSTR lpszKeyPathWithoutBackSlash = NULL,lpszKeyPathWithoutBackSlash1 = NULL;
    LPTSTR lpszOldNameWithExtraQuote = NULL, lpszNewNameWithExtraQuote = NULL;
    LPTSTR lpszValueDataExtraQuote = NULL;

    if (szUsername)
    {
        dwCchSectionNameLen = lstrlen(szUsername)+lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
    }
    else
    {
        dwCchSectionNameLen = lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
    }

    lpszSectionName = malloc(dwCchSectionNameLen*sizeof(TCHAR));
    if (!lpszSectionName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    if (!szUsername 
        ||!MyStrCmpI(szUsername,TEXT("System")))
    {  
        lpszKeyPathWithoutBackSlash = szKeyPath;
        //We calculte the buffer for lpszSectionName, so here StringCchCopy should be
        //always success, assinging return value just make prefast happy 
        hr = StringCchCopy(lpszSectionName,dwCchSectionNameLen,REG_PERSYS_UPDATE);        
    }
    else
    {
        if (szKeyPath[0]==TEXT('\\'))
        {
            lpszKeyPathWithoutBackSlash = szKeyPath + 1;
        }
        else
        {
            lpszKeyPathWithoutBackSlash = szKeyPath;
        }
        if (!MyStrCmpI(szUsername,DEFAULT_USER)
            ||!MyStrCmpI(szUsername,APPLICATION_DATA_METABASE))
        {
            hr = StringCchPrintf(lpszSectionName,dwCchSectionNameLen,TEXT("%s%s"),
                            REG_PERUSER_UPDATE_PREFIX,szUsername);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        else
        {
            LPTSTR pTmp;
            hr = GetSIDFromName(szUsername,&pSid);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
            if (!ConvertSidToStringSid(pSid,&lpUserStringSid))
            {
                lpUserStringSid = NULL;
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }
            dwCchSectionNameLen = lstrlen(lpUserStringSid)+lstrlen(REG_PERUSER_UPDATE_PREFIX)+ lstrlen(REG_PERSYS_UPDATE);
            pTmp = realloc(lpszSectionName,dwCchSectionNameLen*sizeof(TCHAR));
            if (!pTmp)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            else
            {
                lpszSectionName = pTmp;
            }
            hr = StringCchPrintf(lpszSectionName,dwCchSectionNameLen,TEXT("%s%s"),
                            REG_PERUSER_UPDATE_PREFIX,lpUserStringSid);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
    }
    hr = AddExtraQuoteEtc(lpszKeyPathWithoutBackSlash,&lpszKeyPathWithoutBackSlash1);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = AddExtraQuoteEtc(szOldValueName,&lpszOldNameWithExtraQuote);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (szNewValueData)
    {
        if ((dwType & 0xffff) == REG_MULTI_SZ)
        {
            LPTSTR lpString = NULL;
            hr = MultiSZ2String(szNewValueData,TEXT(','),&lpString);
            if (FAILED(hr))
            {
                goto Cleanup;
            }            
            dwCchsizeforRenameValueData = lstrlen(lpszKeyPathWithoutBackSlash1) +
                                          lstrlen(szOldValueName) +
                                          lstrlen(lpString) + MAX_PATH;
            szRenameValueDataLine = malloc(dwCchsizeforRenameValueData*sizeof(TCHAR));
            if (!szRenameValueDataLine)
            {
                hr = E_OUTOFMEMORY;
                FreePointer(lpString);
                goto Cleanup;
            }
            hr = StringCchPrintf(szRenameValueDataLine,dwCchsizeforRenameValueData,
                            TEXT("%d,%d,\"%s\",\"%s\",%s"),CONSTANT_REG_VALUE_DATA_RENAME,
                            dwType,lpszKeyPathWithoutBackSlash1,szOldValueName,lpString);
            FreePointer(lpString);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        else
        {
            hr = AddExtraQuoteEtc(szNewValueData,&lpszValueDataExtraQuote);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
            
            dwCchsizeforRenameValueData = lstrlen(lpszKeyPathWithoutBackSlash1) +
                                          lstrlen(szOldValueName) +
                                          lstrlen(lpszValueDataExtraQuote) + MAX_PATH;
            szRenameValueDataLine = malloc(dwCchsizeforRenameValueData*sizeof(TCHAR));
            if (!szRenameValueDataLine)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            hr = StringCchPrintf(szRenameValueDataLine,dwCchsizeforRenameValueData,
                            TEXT("%d,%u,\"%s\",\"%s\",\"%s\""), CONSTANT_REG_VALUE_DATA_RENAME,
                            dwType,lpszKeyPathWithoutBackSlash1,lpszOldNameWithExtraQuote, lpszValueDataExtraQuote);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        }
        g_dwKeyIndex++;
        _itot(g_dwKeyIndex,szIndex,16);
        if (!WritePrivateProfileString(lpszSectionName,szIndex,szRenameValueDataLine,g_szToDoINFFileName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
    }
    if (szNewValueName)
    {   
        hr = AddExtraQuoteEtc(szNewValueName,&lpszNewNameWithExtraQuote);
        if (FAILED(hr))
        {
            goto Cleanup;
        }        
        dwCchsizeforRenameValueName  = lstrlen(lpszKeyPathWithoutBackSlash1) +
                                       lstrlen(lpszOldNameWithExtraQuote) +
                                       lstrlen(lpszNewNameWithExtraQuote) + MAX_PATH;
        szRenameValueNameLine = malloc(dwCchsizeforRenameValueName*sizeof(TCHAR));
        if (!szRenameValueNameLine)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = StringCchPrintf(szRenameValueNameLine,dwCchsizeforRenameValueName,TEXT("%d,\"%s\",\"%s\",\"%s\""),
                        CONSTANT_REG_VALUE_NAME_RENAME,lpszKeyPathWithoutBackSlash1,
                        lpszOldNameWithExtraQuote,lpszNewNameWithExtraQuote);        
        if (FAILED(hr))
        {
            goto Cleanup;
        }
        g_dwKeyIndex++;
        _itot(g_dwKeyIndex,szIndex,16);
        if (!WritePrivateProfileString(lpszSectionName,szIndex,szRenameValueNameLine,g_szToDoINFFileName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
    }
    hr = S_OK;
Cleanup:
    if (lpUserStringSid)
    {
        LocalFree(lpUserStringSid);
    }
    FreePointer(lpszOldNameWithExtraQuote);
    FreePointer(lpszNewNameWithExtraQuote);
    FreePointer(lpszValueDataExtraQuote);
    FreePointer(szRenameValueDataLine);
    FreePointer(szRenameValueNameLine);
    FreePointer(lpszSectionName);
    FreePointer(pSid);    
    FreePointer(lpszKeyPathWithoutBackSlash1);
    return (hr);
}


HRESULT AddFolderRename(
    LPTSTR szOldName,
    LPTSTR szNewName,    
    DWORD  dwType,
    LPTSTR lpExcludeList)
{
    LPTSTR  szSectionName = TEXT("Folder.ObjectRename");
    LPTSTR  szOneLine = NULL;
    size_t  CchOneLine = MAX_PATH;
    TCHAR   szIndex[MAX_PATH];
    HRESULT hr;
    LPTSTR  lpString = NULL;

    switch (dwType)
    {
        case TYPE_DIR_MOVE:
            if (lpExcludeList)
            {
                hr = MultiSZ2String(lpExcludeList,TEXT(','),&lpString);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
                CchOneLine +=lstrlen(lpString)+lstrlen(szOldName)+lstrlen(szNewName);
                szOneLine = malloc(CchOneLine * sizeof(TCHAR));
                if (!szOneLine)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                hr = StringCchPrintf(szOneLine,CchOneLine,TEXT("%d,\"%s\",\"%s\",%s"),
                            dwType,szOldName,szNewName,lpString);
                free(lpString);
                if (FAILED(hr))
                {
                    goto Cleanup;
                }
                break;
            }

            else
            {
    
            }
        case TYPE_SFPFILE_MOVE:
        case TYPE_FILE_MOVE:
            CchOneLine += lstrlen(szOldName)+lstrlen(szNewName);
            szOneLine = malloc(CchOneLine * sizeof(TCHAR));
            if (!szOneLine)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            hr = StringCchPrintf(szOneLine,CchOneLine,TEXT("%d,\"%s\",\"%s\""),dwType,szOldName,szNewName);
            if (FAILED(hr))
            {
                goto Cleanup;
            }
        break;
    }
    g_dwKeyIndex++;
    _itot(g_dwKeyIndex,szIndex,16);
   if (!WritePrivateProfileString(szSectionName,szIndex,szOneLine,g_szToDoINFFileName))
   {
       hr = HRESULT_FROM_WIN32(GetLastError());
       goto Cleanup;
   }

   // Add the file/folder rename to Change log
   // Does not care about return value
   hr = AddFileChangeLog(dwType, szOldName, szNewName);

   hr = S_OK;
Cleanup:
    if (szOneLine)
    {
        free(szOneLine);
    }
    if (lpString)
    {
        free(lpString);
    }
    return hr;

}

LONG EnsureCLMTReg()
{
    HKEY hkey = NULL;
    LONG lStatus;

    lStatus = RegCreateKey(HKEY_LOCAL_MACHINE,CLMT_REGROOT,&hkey);
    if (lStatus == ERROR_SUCCESS)
    {   
       RegCloseKey(hkey);
    }
    return lStatus;
}

HRESULT SaveInstallLocale(void)
{
    HKEY hkey = NULL;
    LONG lStatus;
    HRESULT hr;
    LCID lcid;
    TCHAR szLocale[MAX_PATH];
    TCHAR szStr[16];

    lcid = GetInstallLocale();
    if (!lcid)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (!IsValidLocale(lcid,LCID_INSTALLED))
    {
        hr = E_FAIL;
        goto Exit;
    }
    _itot(lcid,szStr,16);
    //StringCchCopy should be always success, since we called IsValidLocale to make sure
    //it is a valid locale which should be less than MAX_PATH chars
    hr = StringCchPrintf(szLocale,ARRAYSIZE(szLocale),TEXT("%08s"),szStr);

    lStatus = RegCreateKey(HKEY_LOCAL_MACHINE,CLMT_REGROOT,&hkey);
    if (lStatus != ERROR_SUCCESS)
    {   
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }
    lStatus = RegSetValueEx(hkey,
                            CLMT_OriginalInstallLocale,
                            0,  //reserved
                            REG_SZ,//type
                            (LPBYTE) szLocale,
                            (lstrlen(szLocale)+1)*sizeof(TCHAR));
    if( lStatus != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }
    hr = S_OK;
Exit:
    if (hkey)
    {
        RegCloseKey(hkey);
    }
    return hr;
}


HRESULT GetSavedInstallLocale(LCID *plcid)
{
    HKEY hkey = NULL;
    LONG lStatus;
    HRESULT hr;
    LCID lcid;
    TCHAR szLocale[MAX_PATH];
    TCHAR *pStop;
    DWORD dwSize;

    if ( !plcid )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    lStatus = RegOpenKey(HKEY_LOCAL_MACHINE,CLMT_REGROOT,&hkey);
    if (lStatus != ERROR_SUCCESS)
    {   
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }      
    dwSize = MAX_PATH *sizeof(TCHAR);
    lStatus = RegQueryValueEx(hkey,
                              CLMT_OriginalInstallLocale,
                              NULL,  //reserved
                              NULL,//type
                              (LPBYTE) szLocale,
                              &dwSize);
    if( lStatus != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }
    *plcid = _tcstol(szLocale, &pStop, 16);
    if (!IsValidLocale(*plcid,LCID_INSTALLED))
    {
        hr = E_FAIL;
        goto Exit;
    }
    hr = S_OK;
Exit:
    if (hkey)
    {
        RegCloseKey(hkey);
    }
    return hr;
}




HRESULT SetCLMTStatus(DWORD dwRunStatus)
{
    HKEY hkey = NULL;
    LONG lStatus;
    HRESULT hr;

    if ( (dwRunStatus != CLMT_DOMIG)
          && (dwRunStatus != CLMT_UNDO_PROGRAM_FILES)
          && (dwRunStatus != CLMT_UNDO_APPLICATION_DATA)
          && (dwRunStatus != CLMT_UNDO_ALL)
          && (dwRunStatus != CLMT_DOMIG_DONE)
          && (dwRunStatus != CLMT_UNDO_PROGRAM_FILES_DONE)
          && (dwRunStatus != CLMT_UNDO_APPLICATION_DATA_DONE)
          && (dwRunStatus != CLMT_UNDO_ALL_DONE)
          && (dwRunStatus != CLMT_CURE_PROGRAM_FILES)
          && (dwRunStatus != CLMT_CLEANUP_AFTER_UPGRADE) )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    lStatus = RegCreateKey(HKEY_LOCAL_MACHINE,CLMT_REGROOT,&hkey);
    if (lStatus != ERROR_SUCCESS)
    {   
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }

    lStatus = RegSetValueEx(hkey,
                            CLMT_RUNNING_STATUS,
                            0,  //reserved
                            REG_DWORD,//type
                            (LPBYTE) &dwRunStatus,
                            sizeof(DWORD));
    if( lStatus != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }
    
    hr = S_OK;
Exit:
    if (hkey)
    {
        RegCloseKey(hkey);
    }
    return hr;
}

HRESULT GetCLMTStatus(PDWORD pdwRunStatus)
{
    HKEY hkey = NULL;
    LONG lStatus;
    HRESULT hr;
    DWORD dwSize;

    if ( !pdwRunStatus )
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    lStatus = RegOpenKey(HKEY_LOCAL_MACHINE,CLMT_REGROOT,&hkey);
    if (lStatus != ERROR_SUCCESS)
    {   
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    lStatus = RegQueryValueEx(hkey,
                              CLMT_RUNNING_STATUS,
                              NULL,
                              NULL,
                              (LPBYTE)pdwRunStatus,
                              &dwSize);
    if( lStatus != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(lStatus);
        goto Exit;
    }    
    hr = S_OK;
Exit:
    if (hkey)
    {
        RegCloseKey(hkey);
    }
    return hr;
}


//-----------------------------------------------------------------------
//
//  Function:   GetInstallLocale
//
//  Descrip:    Get the OS installed locale
//
//  Returns:    LCID
//
//  Notes:      if fails, the return value is 0, otherwize is the os 's lcid
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      If it returns 0, it means failure, and call GetLastError() to get the detail
//              error code
//
//-----------------------------------------------------------------------
UINT GetInstallLocale(VOID)
{
    LONG            dwErr;
    HKEY            hkey;
    DWORD           dwSize;
    TCHAR           buffer[512];
    LANGID          rcLang;
    UINT            lcid;

    lcid = 0;
    dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Language"),
                          0,
                          KEY_READ,
                          &hkey );

    if( dwErr == ERROR_SUCCESS ) 
    {

        dwSize = sizeof(buffer);
        dwErr = RegQueryValueEx(hkey,
                                TEXT("InstallLanguage"),
                                NULL,  //reserved
                                NULL,  //type
                                (LPBYTE) buffer,
                                &dwSize );

        if(dwErr == ERROR_SUCCESS) 
        {
            lcid = StrToUInt(buffer);
        }
        RegCloseKey(hkey);
    }
    
    return( lcid );
}

//-----------------------------------------------------------------------
//
//  Function:   SetInstallLocale
//
//  Descrip:    Set the OS installed locale
//
//  Returns:    HRESULT
//
//  Notes:      
//
//  History:    09/17/2001 xiaoz created
//
//
//-----------------------------------------------------------------------
HRESULT SetInstallLocale(LCID lcid)
{
    LONG            dwErr;
    HKEY            hkey = NULL;
    TCHAR           szLocale[32],szTmpLocale[32];
    HRESULT         hr;

    if (!IsValidLocale(lcid,LCID_INSTALLED))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    dwErr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\Language"),
                          0,
                          KEY_WRITE,
                          &hkey );

    if( dwErr != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }
    //following 2 sentences should  never fail since we already validated by IsValidLocale
    _itot(lcid,szTmpLocale,16);

    //StringCchCopy should be always success, since we called IsValidLocale to make sure
    //it is a valid locale which should be less than 32 chars
    hr = StringCchPrintf(szLocale,ARRAYSIZE(szLocale),TEXT("%04s"),szTmpLocale);

    dwErr = RegSetValueEx(hkey,
                          TEXT("InstallLanguage"),
                          0,  //reserved
                          REG_SZ,//type
                          (LPBYTE) szLocale,
                          (lstrlen(szLocale)+1)*sizeof(TCHAR));
    if( dwErr != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Exit;
    }

    hr = S_OK;
Exit:
    if (hkey)
    {
        RegCloseKey(hkey);
    }
    return hr;
}

//
//  Function:       ReverseStrCmp
//
//  Description:    Reverse compare strings
//
//  Returns:        TRUE if two strings are equal.
//                  FALSE if different.
//  Notes:      
//
//  History:        3/14/2002 geoffguo created
//
BOOL ReverseStrCmp(
    LPCTSTR lpCurrentChar,
    LPCTSTR lpStrBuf)
{
    BOOL      bRet = FALSE;
    DWORD     i, dwLen;
    LPCTSTR   lpStr1, lpStr2;

    if (!lpCurrentChar || !lpStrBuf)
        goto Exit;

    dwLen = lstrlen(lpStrBuf);
    do
    {
        bRet = TRUE;
        lpStr1 = lpCurrentChar;
        lpStr2 = &lpStrBuf[dwLen-1];
        for (i = 0; i < dwLen; i++)
        {
            if (IsBadStringPtr(lpStr1, 1) || *lpStr1 == (TCHAR)'\0' ||
                towupper(*lpStr1) != towupper(*lpStr2) &&
                *lpStr2 != L':' &&   //solve MS Installer path issue: G?\Program Files
                *lpStr2 != L'\\')    //solve MS FrontPage URL format issue: D:/Document and Settings
            {
                bRet = FALSE;
                break;
            }
            lpStr1--;
            lpStr2--;
        }

        if (bRet)
            break;

        dwLen--;
    } while (lpStrBuf[dwLen-1] != (TCHAR)'\\' && dwLen > 0);

Exit:
    return bRet;
}

DWORD MultiSZNumOfString(IN  LPTSTR lpMultiSZ)
{
    DWORD dwNum = 0;
    LPTSTR lpStr = lpMultiSZ;
    
    if (!lpMultiSZ)
    {
        return 0;
    }
    while (*lpStr)
    {
        dwNum++;
        lpStr = lpStr + lstrlen(lpStr)+1;
    }
    return dwNum;

}


//
//  Function:       StrNumInMultiSZ
//
//  Description:    Get string number in multi-string
//
//  Returns:        String number or 0xFFFFFFFF if not find.
//
//  Notes:      
//
//  History:        3/21/2002 geoffguo created
//
DWORD StrNumInMultiSZ(
    LPCTSTR lpStr,
    LPCTSTR lpMultiSZ)
{
    DWORD  dwNum = 0xFFFFFFFF;
    LPTSTR lpTemp;
    
    if (!lpMultiSZ || !lpStr)
    {
        goto Exit;
    }
    
    lpTemp = (LPTSTR)lpMultiSZ;
    dwNum = 0;
    while (*lpTemp)
    {
        if(MyStrCmpI(lpStr, lpTemp) == 0)
            break;

        dwNum++;
        lpTemp = lpTemp + lstrlen(lpTemp)+1;
    }

    if (*lpTemp == (TCHAR)NULL)
        dwNum = 0xFFFFFFFF;

Exit:
    return dwNum;
}

//
//  Function:       GetStrInMultiSZ
//
//  Description:    Get string in multi-string based on string number.
//
//  Returns:        Point to the string or NULL.
//
//  Notes:      
//
//  History:        3/21/2002 geoffguo created
//
LPTSTR GetStrInMultiSZ(
    DWORD   dwNum,
    LPCTSTR lpMultiSZ)
{
    DWORD  i;
    LPTSTR lpTemp = NULL;
    
    if (!lpMultiSZ)
    {
        goto Exit;
    }
    
    lpTemp = (LPTSTR)lpMultiSZ;
    i = 0;
    while (*lpTemp)
    {
        if(i == dwNum)
            break;

        i++;
        lpTemp = lpTemp + lstrlen(lpTemp)+1;
    }

    if (*lpTemp == (TCHAR)NULL)
        lpTemp = NULL;

Exit:
    return lpTemp;
}


HRESULT MultiSZ2String(
    IN  LPTSTR lpMultiSZ,
    IN  TCHAR  chSeperator,
    OUT LPTSTR *lpString)
{
    LPTSTR      lpSource = NULL,lpDest = NULL,lpDestStart = NULL,lpTmpBuf = NULL;
    DWORD       cchLen ;
    HRESULT     hr;
    DWORD       dwNumofStringInMSZ;

    if (!lpMultiSZ || !lpString )
    {
        hr = E_INVALIDARG;        
        goto Cleanup;
    }
    cchLen =  MultiSzLen(lpMultiSZ);
    if (cchLen < 3)
    {        
        hr = E_INVALIDARG;
        *lpString = NULL;
        goto Cleanup;
    }

    dwNumofStringInMSZ = MultiSZNumOfString(lpMultiSZ);

    lpDest = malloc( (cchLen + dwNumofStringInMSZ * 2) * sizeof(TCHAR));
    lpDestStart = lpDest;
    lpTmpBuf = malloc( (cchLen + dwNumofStringInMSZ * 2) * sizeof(TCHAR));
    if (!lpDest || !lpTmpBuf)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    lpSource = lpMultiSZ;
    while (*lpSource)
    { 
        //We calculte the buffer for lpTmpBuf, so here StringCchCopy should be
        //always success, assinging return value just make prefast happy 
        hr = StringCchPrintf(lpTmpBuf,cchLen + dwNumofStringInMSZ * 2,TEXT("\"%s\""),lpSource);
        memcpy((BYTE*)lpDest,(BYTE*)lpTmpBuf,lstrlen(lpTmpBuf) * sizeof(TCHAR));
        lpSource = lpSource + lstrlen(lpSource)+1;
        lpDest = lpDest + lstrlen(lpTmpBuf);
        *lpDest = chSeperator;
        lpDest++;
    }
    lpDest--;
    *lpDest = TEXT('\0');
    hr = S_OK;
Cleanup:
    if (lpTmpBuf)
    {
        free(lpTmpBuf);
    }
    if FAILED(hr)
    {
        if (lpDestStart)
        {
            free(lpDestStart);
        }
        lpDestStart = NULL;
    }
    *lpString = lpDestStart;
    return hr;
}

void FreePointer(void *lp)
{
    if (lp)
    {
        free(lp);
    }
}

HRESULT GetSIDFromName(
    IN LPTSTR lpszUserName,
    OUT PSID *ppSid)
{
    PSID pSid = NULL;
    DWORD cbSid = 1024;
    SID_NAME_USE Use ;
    HRESULT hr;
    DWORD dwDomainNameLen = MAX_PATH;
    TCHAR szDomain[MAX_PATH];

    if (!lpszUserName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    pSid = (PSID)malloc( cbSid);
    if(!pSid)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    if (LookupAccountName(NULL,lpszUserName,pSid,&cbSid,szDomain,&dwDomainNameLen,&Use)== FALSE)
    {
        DWORD dwErr = GetLastError();
        if(dwErr != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Cleanup;
        }
        else
        {
            free(pSid);
            pSid = (PSID)malloc( cbSid);
            if(!pSid)
            {
                hr =  E_OUTOFMEMORY;
                goto Cleanup;
            }
            dwDomainNameLen = MAX_PATH;
            if (LookupAccountName(NULL,lpszUserName,pSid,&cbSid,szDomain,&dwDomainNameLen,&Use)== FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
            }
        }
    }
    //Check the SID
    if(!IsValidSid(pSid))
    {
        hr = E_FAIL;
        goto Cleanup;    
    }
    hr = S_OK;
Cleanup:
    if FAILED(hr)
    {
        if (pSid)
        {
            free(pSid);
        }
        *ppSid = NULL;
    }
    else
    {
        *ppSid = pSid;
    }
    return hr;
}

void BoostMyPriority()
{
    HANDLE hProcess;

    hProcess = GetCurrentProcess();
    SetPriorityClass(hProcess,HIGH_PRIORITY_CLASS);
}



//***************************************************************************
//
//  BOOL StopService
//
//  DESCRIPTION:
//
//  Stops and then removes the service. 
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StopService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    DWORD dwCnt;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                         );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                for(dwCnt=0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}



//***************************************************************************
//
//  HRESULT ReconfigureServiceStartType
//
//  DESCRIPTION:
//
//  Change the Service Start Type, there are following type availabe now
//      SERVICE_AUTO_START 
//      SERVICE_BOOT_START 
//      SERVICE_DEMAND_START 
//      SERVICE_DISABLED 
//      SERVICE_SYSTEM_START 

//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwOldType           service current start type 
//  dwNewType           start type  you want to change to
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:       S_OK if change successfully
//
//  Note:               if current start type is dwOldType, the function will try to 
//                      change start type to dwNewType.
//                      if current start type is NOT dwOldType, it will not do any 
//                      change, in this S_FALSE is returned.
//                      If you want change service start type to dwNewType, no mater
//                      current start type, specify dwOldType >=0xFFFF
//
//***************************************************************************
HRESULT ReconfigureServiceStartType(
    IN LPCTSTR          pServiceName,
    IN DWORD            dwOldType,
    IN DWORD            dwNewType,
    IN DWORD            dwMaxWait) 
{ 
    SC_LOCK                     sclLock = NULL; 
    SERVICE_DESCRIPTION         sdBuf;
    DWORD                       dwBytesNeeded, dwStartType; 
    SC_HANDLE                   schSCManager = NULL;
    SC_HANDLE                   schService = NULL;
    DWORD                       dwErr = ERROR_SUCCESS;
    LPQUERY_SERVICE_CONFIG      lpqscBuf = NULL;
    HRESULT                     hr = S_OK;
    DWORD                       dwCnt;

 
    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                         );
    if (!schSCManager)
    {
        dwErr = GetLastError();
        goto cleanup;
    } 
    
    // Need to acquire database lock before reconfiguring. 
    for(dwCnt=0; dwCnt < dwMaxWait ; dwCnt++)
    {
        sclLock = LockServiceDatabase(schSCManager); 
        if (sclLock == NULL) 
        { 
            // Exit if the database is not locked by another process. 
            dwErr = GetLastError();
            if (dwErr != ERROR_SERVICE_DATABASE_LOCKED) 
            {
                goto cleanup;
            }
            else
            {
                Sleep(1000);
            }
        }
        else
        {
            break;
        } 
    }
    if (!sclLock)
    {
        goto cleanup;
    }
    
    // The database is locked, so it is safe to make changes. 
 
    // Open a handle to the service. 
 
    schService = OpenService( 
        schSCManager,           // SCManager database 
        pServiceName,           // name of service 
        SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG ); // need CHANGE access 

    if (schService == NULL) 
    {
        dwErr = GetLastError();
        goto cleanup;
    }   
    lpqscBuf = (LPQUERY_SERVICE_CONFIG) LocalAlloc(LPTR, 4096); 
    if (lpqscBuf == NULL) 
    {
        dwErr = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    if (!QueryServiceConfig(schService,     // handle to service
                            lpqscBuf,       // buffer
                            4096,           // size of buffer
                            &dwBytesNeeded))
    {
        dwErr = GetLastError();
        goto cleanup;
    }
    if (dwOldType < 0xFFFF)
    {
        if (lpqscBuf->dwStartType !=  dwOldType)
        {
            hr = S_FALSE;
            goto cleanup;
        }
    } 
    
    // Make the changes. 
    if (! ChangeServiceConfig(schService,               // handle of service 
                              SERVICE_NO_CHANGE,        // service type: no change 
                              dwNewType,                // change service start type 
                              SERVICE_NO_CHANGE,        // error control: no change 
                              NULL,                     // binary path: no change 
                              NULL,                     // load order group: no change 
                              NULL,                     // tag ID: no change 
                              NULL,                     // dependencies: no change 
                              NULL,                     // account name: no change 
                              NULL,                     // password: no change 
                              NULL) )                   // display name: no change
    {
        dwErr = GetLastError();
        goto cleanup;
    }

    hr = S_OK;
cleanup:
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    if (sclLock)
    {
        UnlockServiceDatabase(sclLock); 
    }
    if (schService)
    {    // Close the handle to the service.  
        CloseServiceHandle(schService); 
    }
    if (schSCManager)
    {
        CloseServiceHandle(schSCManager);
    }
    if (lpqscBuf)
    {
        LocalFree(lpqscBuf);
    }
    return hr;
} 

//-----------------------------------------------------------------------
//
//  Function:   MyGetShortPathName
//
//  Descrip:    
//
//  Returns:    DWORD
//
//  Notes:      none
//
//  History:    09/17/2001 xiaoz created
//
//  Notes:      
//              lpszLongPath is the long path name
//              lpszOriginalPath (optional)is the the original name of lpszLongPath(before we renamed it)
//              lpszShortPath is the buffer to receive the short path name
//              cchBuffer is the buffer size for  lpszShortPath
//              
//-----------------------------------------------------------------------
#define BYTE_COUNT_8_DOT_3                          (24)
HRESULT MyGetShortPathName(
    IN  LPCTSTR lpszPathRoot,
    IN  LPCTSTR lpszOldName,
    IN  LPCTSTR lpszNewName,
    OUT LPTSTR  lpszShortName,
    IN  DWORD   cchBuffer)
{
    
    HRESULT                hr = S_OK;
    GENERATE_NAME_CONTEXT  NameContext;
    WCHAR                  ShortNameBuffer[BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) + 1];
    UNICODE_STRING         FileName,ShortName;
    DWORD                  StringLength;
    LPTSTR                 lpName;
    TCHAR                  szPath[MAX_PATH],szLongPath[MAX_PATH];
    TCHAR                  DriveRoot[_MAX_DRIVE + 2];
#define FILESYSNAMEBUFSIZE 1024 // probably more than we need
    TCHAR                  szFileSystemType[FILESYSNAMEBUFSIZE];
    BOOL                   bIsNTFS = FALSE;
    BOOL                   bTmpDirCreated = FALSE;
    DWORD                  dwAllowExtendedChar;
    BOOLEAN                bAllowExtendedChar;
    DWORD                  dwsizeofdw; 

   
    if (lstrlen(lpszNewName) <= 8)
    {
        hr = StringCchCopy(lpszShortName,cchBuffer,lpszNewName);
        goto Exit;
    }
    
    //
    //  Initialize the short string to use the input buffer.
    //
    ShortName.Buffer = ShortNameBuffer;
    ShortName.MaximumLength = BYTE_COUNT_8_DOT_3;
    
    FileName.Buffer = (LPTSTR)lpszNewName;
    StringLength = lstrlen(lpszNewName);
    FileName.Length = (USHORT)StringLength * sizeof(TCHAR);    
    FileName.MaximumLength = (USHORT)(StringLength + 1)*sizeof(TCHAR);

    //  Initialize the name context.
    //
    RtlZeroMemory( &NameContext, sizeof( GENERATE_NAME_CONTEXT ));
#define EXTENDED_CHAR_MODE_VALUE_NAME TEXT("NtfsAllowExtendedCharacterIn8dot3Name")
#define COMPATIBILITY_MODE_KEY_NAME   TEXT("System\\CurrentControlSet\\Control\\FileSystem")
    dwsizeofdw = sizeof(DWORD);
    if (ERROR_SUCCESS == GetRegistryValue(HKEY_LOCAL_MACHINE,
                                          COMPATIBILITY_MODE_KEY_NAME,
                                          EXTENDED_CHAR_MODE_VALUE_NAME,
                                          (LPBYTE)&dwAllowExtendedChar,
                                          &dwsizeofdw))
    {
        if (dwAllowExtendedChar)
        {
            bAllowExtendedChar = TRUE;
        }
        else
        {
            bAllowExtendedChar = FALSE;
        }
    }
    else
    {
        bAllowExtendedChar = FALSE;
    }
    RtlGenerate8dot3Name( &FileName, bAllowExtendedChar, &NameContext, &ShortName );

    //now ShortName.Buffer contains the shortpath and is NULL ended
    ShortName.Buffer[ShortName.Length /sizeof(TCHAR)] = TEXT('\0');
    
    //check whether the short name is exitsted or now
    hr = StringCchCopy(szPath,ARRAYSIZE(szPath),lpszPathRoot);
    if (FAILED(hr))
    {
        goto Exit;
    }
    if (!ConcatenatePaths(szPath,ShortName.Buffer,ARRAYSIZE(szPath)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        goto Exit;
    }
    if (!IsFileFolderExisting(szPath))
    {
        hr = StringCchCopy(lpszShortName,cchBuffer,ShortName.Buffer); 
        goto Exit;
    }
    _tsplitpath(lpszPathRoot, DriveRoot, NULL, NULL, NULL);
    
    hr = StringCchCat(DriveRoot, ARRAYSIZE(DriveRoot), TEXT("\\"));
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (! GetVolumeInformation(DriveRoot, NULL, 0,
                NULL, NULL, NULL, szFileSystemType, ARRAYSIZE(szFileSystemType)) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (!MyStrCmpI(szFileSystemType,TEXT("NTFS")))
    {
        bIsNTFS = TRUE;
    }
    //Follwing we process the short name path is existing.
    if (!GetLongPathName(szPath,szLongPath,ARRAYSIZE(szLongPath)))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    lpName = StrRChrI(szLongPath,NULL,TEXT('\\'));
    if (!lpName)
    {
        hr = E_FAIL;
        goto Exit;
    }
    if (!MyStrCmpI(lpName+1,lpszOldName))
    {
        if (bIsNTFS)
        {
            hr = StringCchCopy(lpszShortName,cchBuffer,ShortName.Buffer); 
            goto Exit;
        }
    }
    else
    if (!MyStrCmpI(lpName,lpszNewName))
    {
        hr = StringCchCopy(lpszShortName,cchBuffer,ShortName.Buffer); 
        goto Exit;
    }

    //here we need to get the shortpath name by creating it    
    hr = StringCchCopy(szLongPath,ARRAYSIZE(szLongPath),lpszPathRoot);
    if (FAILED(hr))
    {
        goto Exit;
    }
    if (!ConcatenatePaths(szLongPath,lpszNewName,ARRAYSIZE(szLongPath)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        goto Exit;
    }
    if (!CreateDirectory(szLongPath,NULL))
    {
        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_ALREADY_EXISTS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Exit;
        }        
    }
    else
    {
        bTmpDirCreated = TRUE;
    }

    if (!GetShortPathName(szLongPath,szPath,cchBuffer))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (bTmpDirCreated)
    {
        RemoveDirectory(szLongPath);
    }
    if (!(lpName = StrRChrI(szPath,NULL,TEXT('\\'))))
    {
        hr = E_FAIL;
        goto Exit;
    }
    hr = StringCchCopy(lpszShortName,cchBuffer,lpName+1);
Exit:
    return hr;
}


BOOL
MassageLinkValue(
    IN LPCWSTR lpLinkName,
    IN LPCWSTR lpLinkValue,
    OUT PUNICODE_STRING NtLinkName,
    OUT PUNICODE_STRING NtLinkValue,
    OUT PUNICODE_STRING DosLinkValue
    )
{
    PWSTR FilePart;
    PWSTR s, sBegin, sBackupLimit, sLinkName;
    NTSTATUS Status;
    USHORT nSaveNtNameLength;
    ULONG nLevels;

    //
    // Initialize output variables to NULL
    //

    RtlInitUnicodeString( NtLinkName, NULL );
    RtlInitUnicodeString( NtLinkValue, NULL );

    //
    // Translate link name into full NT path.
    //

    if (!RtlDosPathNameToNtPathName_U( lpLinkName,
                                       NtLinkName,
                                       &sLinkName,
                                       NULL
                                     )
       ) 
    {
        return FALSE;
    }

    //
    // All done if no link value.
    //

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        return TRUE;
        }

    //
    // If the target is a device, do not allow the link.
    //

    if (RtlIsDosDeviceName_U( (PWSTR)lpLinkValue )) {
        return FALSE;
        }

    //
    // Convert to DOS path to full path, and get Nt representation
    // of DOS path.
    //

    if (!RtlGetFullPathName_U( lpLinkValue,
                               DosLinkValue->MaximumLength,
                               DosLinkValue->Buffer,
                               NULL
                             )
       ) {
        return FALSE;
        }
    DosLinkValue->Length = wcslen( DosLinkValue->Buffer ) * sizeof( WCHAR );

    //
    // Verify that the link value is a valid NT name.
    //

    if (!RtlDosPathNameToNtPathName_U( DosLinkValue->Buffer,
                                       NtLinkValue,
                                       NULL,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    return TRUE;
}  // MassageLinkValue


BOOL CreateSymbolicLink(
    LPTSTR  szLinkName,
    LPTSTR  szLinkValue,
    BOOL    bMakeLinkHidden
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;

    UNICODE_STRING UnicodeName;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;

    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    IO_STATUS_BLOCK IoStatusBlock;
    BOOL TranslationStatus;

    PVOID FreeBuffer;
    PVOID FreeBuffer2;

    FILE_DISPOSITION_INFORMATION Disposition;

    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer = NULL;
    ULONG ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;
    USHORT ReparseDataLength = 0;

    ULONG FsControlCode     = 0;
    ULONG CreateOptions     = 0;
    ULONG CreateDisposition = 0;
    ULONG DesiredAccess     = SYNCHRONIZE;
    DWORD dwAttrib;
    BOOL  bRet = FALSE;


    // change the name to NT path, eg d:\programme to ??\d:\programme
    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            szLinkName,
                            &UnicodeName,
                            NULL,
                            NULL
                            );

    if (!TranslationStatus) 
    {
        goto exit;
    }

    FreeBuffer = UnicodeName.Buffer;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    //  Set the code of the FSCTL operation.
    //

    FsControlCode = FSCTL_SET_REPARSE_POINT;

    //
    //  Set the open/create options for a directory.
    //

    CreateOptions = FILE_OPEN_REPARSE_POINT;

    //
    //  Set the tag to mount point.
    //

    ReparsePointTag = IO_REPARSE_TAG_MOUNT_POINT;

    //
    //  Open to set the reparse point.
    //

    DesiredAccess |= FILE_WRITE_DATA;
    CreateDisposition = FILE_OPEN;             // the file must be present

    Status = NtCreateFile(&Handle,
                          DesiredAccess,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,              // pallocationsize (none!)
                          FILE_ATTRIBUTE_NORMAL,// attributes to be set if created
                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                          CreateDisposition,
                          CreateOptions,
                          NULL,                         // EA buffer (none!)
                          0);

    //
    //  Create a directory if you do not find it.
    //

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) 
    {
        DesiredAccess = SYNCHRONIZE;
        CreateDisposition = FILE_CREATE;
        CreateOptions = FILE_DIRECTORY_FILE;

        Status = NtCreateFile(&Handle,
                              DesiredAccess,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              NULL,                         // pallocationsize (none!)
                              FILE_ATTRIBUTE_NORMAL,        // attributes to be set if created
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              CreateDisposition,
                              CreateOptions,
                              NULL,                         // EA buffer (none!)
                              0);
        if (!NT_SUCCESS(Status)) 
        {
            goto exit;
        }

        //
        //  Close the handle and re-open.
        //

        NtClose( Handle );

        CreateOptions = FILE_OPEN_REPARSE_POINT;
        DesiredAccess |= FILE_WRITE_DATA;
        CreateDisposition = FILE_OPEN;             // the file must be present

        Status = NtCreateFile(&Handle,
                              DesiredAccess,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              NULL,                         // pallocationsize (none!)
                              FILE_ATTRIBUTE_NORMAL,        // attributes to be set if created
                              FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                              CreateDisposition,
                              CreateOptions,
                              NULL,                         // EA buffer (none!)
                              0);
    }
    RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );
    
    if (!NT_SUCCESS(Status)) 
    {
        goto exit;
    }
    //
    //  Innitialize the DosName buffer.
    //

    DosLinkValue.Buffer = FullPathLinkValue;
    DosLinkValue.MaximumLength = sizeof( FullPathLinkValue );
    DosLinkValue.Length = 0;

    //
    //  Massage all the names.
    //
    
    if (!MassageLinkValue( szLinkName, 
                           szLinkValue, 
                           &NtLinkName, 
                           &NtLinkValue, 
                           &DosLinkValue ))
    {
        RtlFreeUnicodeString( &NtLinkName );
        RtlFreeUnicodeString( &NtLinkValue );
        goto exit;
    }
    
    RtlFreeUnicodeString( &NtLinkName );

    //
    //  Set the reparse point with mount point or symbolic link tag and determine
    //  the appropriate length of the buffer.
    //

    
    ReparseDataLength = (USHORT)((FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer) -
                                REPARSE_DATA_BUFFER_HEADER_SIZE) +
                                NtLinkValue.Length + sizeof(UNICODE_NULL) +
                                DosLinkValue.Length + sizeof(UNICODE_NULL));

    //
    //  Allocate a buffer to set the reparse point.
    //

    ReparseBufferHeader 
        = (PREPARSE_DATA_BUFFER)RtlAllocateHeap(RtlProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseDataLength);

    if (ReparseBufferHeader == NULL) 
    {
        NtClose( Handle );
        RtlFreeUnicodeString( &NtLinkValue );
        goto exit;
    }

    //
    //  Setting the buffer is common for both tags as their buffers have identical fields.
    //

    ReparseBufferHeader->ReparseDataLength = (USHORT)ReparseDataLength;
    ReparseBufferHeader->Reserved = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameOffset = 0;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength = NtLinkValue.Length;
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameOffset = NtLinkValue.Length + sizeof( UNICODE_NULL );
    ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength = DosLinkValue.Length;
    RtlCopyMemory(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer,
                  NtLinkValue.Buffer,
                  NtLinkValue.Length);
    RtlCopyMemory((PCHAR)(ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer)+
                                NtLinkValue.Length + sizeof(UNICODE_NULL),
                          DosLinkValue.Buffer,
                          DosLinkValue.Length);

    RtlFreeUnicodeString( &NtLinkValue );
        
    //
    //  Set the tag 
    //

    ReparseBufferHeader->ReparseTag = ReparsePointTag;

    //
    //  Set the reparse point.
    //

    Status = NtFsControlFile(Handle,
                             NULL,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             FsControlCode,
                             ReparseBufferHeader,
                             REPARSE_DATA_BUFFER_HEADER_SIZE + ReparseBufferHeader->ReparseDataLength,
                             NULL,                // no output buffer
                             0);                    // output buffer length\

    //
    //  Close the file.
    //

    NtClose( Handle );

    if (!NT_SUCCESS(Status)) 
    {
        goto exit;
    }
    bRet = TRUE;
    
    if (bMakeLinkHidden)
    {
        dwAttrib = GetFileAttributes(szLinkName);
        if (INVALID_FILE_ATTRIBUTES == dwAttrib)
        {
            goto exit;
        }
        if (!SetFileAttributes(szLinkName,dwAttrib|FILE_ATTRIBUTE_HIDDEN))
        {            
            DPF (APPmsg, L"SetFileAttributes! Error: %d \n", GetLastError());
            goto exit;
        }
    }
exit:
    return bRet;
}




BOOL GetSymbolicLink(
    LPTSTR      szLinkName,
    LPTSTR      szLinkValue,
    DWORD       cchSize    
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE Handle;

    UNICODE_STRING UnicodeName;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;

    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    IO_STATUS_BLOCK IoStatusBlock;
    BOOL TranslationStatus;

    PVOID FreeBuffer;
    PVOID FreeBuffer2;

    FILE_DISPOSITION_INFORMATION Disposition;

    PREPARSE_DATA_BUFFER ReparseBufferHeader = NULL;
    PCHAR ReparseBuffer = NULL;
    ULONG ReparsePointTag = IO_REPARSE_TAG_RESERVED_ZERO;
    USHORT ReparseDataLength = 0;

    ULONG FsControlCode     = 0;
    ULONG CreateOptions     = 0;
    ULONG CreateDisposition = 0;
    ULONG DesiredAccess     = SYNCHRONIZE;
    DWORD dwAttrib;
    BOOL  bRet = FALSE;


    // change the name to NT path, eg d:\programme to ??\d:\programme
    TranslationStatus = RtlDosPathNameToNtPathName_U(
                            szLinkName,
                            &UnicodeName,
                            NULL,
                            NULL
                            );

    if (!TranslationStatus) 
    {
        goto exit;
    }

    FreeBuffer = UnicodeName.Buffer;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    FsControlCode = FSCTL_GET_REPARSE_POINT;
    DesiredAccess = FILE_READ_DATA | SYNCHRONIZE;
    CreateOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT;
    
    //
    //  Set the tag to mount point.
    //

    ReparsePointTag = IO_REPARSE_TAG_MOUNT_POINT;

    
    Status = NtOpenFile(
                     &Handle,
                     DesiredAccess,
                     &ObjectAttributes,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     CreateOptions
                     );

    RtlFreeHeap( RtlProcessHeap(), 0, FreeBuffer );

    if (!NT_SUCCESS(Status)) 
    {
        goto exit;
    }
    ReparseDataLength = MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
    ReparseBuffer = RtlAllocateHeap(
                            RtlProcessHeap(),
                            HEAP_ZERO_MEMORY,
                            ReparseDataLength
                            );

    if (ReparseBuffer == NULL) 
    {
        goto exit;
    }
    Status = NtFsControlFile(
                     Handle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     FsControlCode,        // no input buffer
                     NULL,                 // input buffer length
                     0,
                     (PVOID)ReparseBuffer,
                     ReparseDataLength
                     );
    if (!NT_SUCCESS(Status)) 
    {
        NtClose( Handle );
        RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
        goto exit;
    }

    NtClose( Handle );
    ReparseBufferHeader = (PREPARSE_DATA_BUFFER)ReparseBuffer;
    if ((ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) ||
        (ReparseBufferHeader->ReparseTag == IO_REPARSE_TAG_SYMBOLIC_LINK)) 
    {

            USHORT Offset = 0;
            NtLinkValue.Buffer = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[Offset];
            NtLinkValue.Length = ReparseBufferHeader->SymbolicLinkReparseBuffer.SubstituteNameLength;
            Offset = NtLinkValue.Length + sizeof(UNICODE_NULL);
            DosLinkValue.Buffer = &ReparseBufferHeader->SymbolicLinkReparseBuffer.PathBuffer[Offset/sizeof(WCHAR)];
            DosLinkValue.Length = ReparseBufferHeader->SymbolicLinkReparseBuffer.PrintNameLength;
            if (cchSize < DosLinkValue.Length / sizeof(TCHAR) +1)
            {
                RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
                goto exit;
            }
            else
            {
                int  cbLen = DosLinkValue.Length;
                LPTSTR lpStart = DosLinkValue.Buffer;

                if (DosLinkValue.Length > 4 * sizeof(TCHAR))
                {
                    if (  (DosLinkValue.Buffer[0] == TEXT('\\'))
                           && (DosLinkValue.Buffer[1] == TEXT('\\')) 
                           && (DosLinkValue.Buffer[2] == TEXT('?')) 
                           && (DosLinkValue.Buffer[3] == TEXT('\\')) )
                    {
                        cbLen -= 4 * sizeof(TCHAR);
                        lpStart += 4;
                    }
                }
                //memmove((PBYTE)szLinkValue,(PBYTE)DosLinkValue.Buffer,DosLinkValue.Length);
                //szLinkValue[DosLinkValue.Length / sizeof(TCHAR)] = TEXT('\0');
                memmove((PBYTE)szLinkValue,(PBYTE)lpStart,cbLen);
                szLinkValue[cbLen / sizeof(TCHAR)] = TEXT('\0');
            }
            
    }
    else
    {
        RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );
        goto exit;
    }



    bRet = TRUE;
    RtlFreeHeap( RtlProcessHeap(), 0, ReparseBufferHeader );        
exit:
    return bRet;
}


typedef struct {
    WORD        wSuiteMask;
    LPTSTR      szSuiteName;    
} SUITE_INFO;

HRESULT LogMachineInfo()
{
    SYSTEMTIME              systime;
    OSVERSIONINFOEX         ov;
    TCHAR                   lpTimeStr[MAX_PATH];
    TCHAR                   lpComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    SUITE_INFO              c_rgSuite_Info[] = {
        {VER_SUITE_BACKOFFICE, TEXT("Microsoft BackOffice")},
        {VER_SUITE_BLADE, TEXT("Windows Server 2003, Web Edition")},
        {VER_SUITE_DATACENTER, TEXT("Datacenter Server")},
        {VER_SUITE_ENTERPRISE, TEXT("Advanced/Enterprise Server")},
        {VER_SUITE_PERSONAL, TEXT("Windows XP Home Edition")},
        {VER_SUITE_SMALLBUSINESS, TEXT("Small Business Server")}, 
        {VER_SUITE_SMALLBUSINESS_RESTRICTED, TEXT("Restricted Small Business Server")},
        {VER_SUITE_TERMINAL, TEXT("Terminal Services")}, 
        {0,NULL}
    };
    SUITE_INFO              *psi;
    LCID                    lcidSys,lcidUser,lcidInstall;
    TCHAR                   szLocalename[MAX_PATH];
    TCHAR                   szSystemDir[MAX_PATH+1];
#define FILESYSNAMEBUFSIZE  1024 // probably more than we need
    TCHAR                   szFileSystemType[FILESYSNAMEBUFSIZE];
    DWORD                   cchSize;
    TCHAR                   szModule[MAX_PATH+1];
    TCHAR                   szCurrRoot[MAX_PATH+1],szExpRoot[MAX_PATH+1];
    DWORD                   cchCurrRoot,cchExpRoot;
    HRESULT                 hr = S_OK;

    if (GetModuleFileName(GetModuleHandle(NULL),szModule,ARRAYSIZE(szModule)-1))
    {
        szModule[ARRAYSIZE(szModule)-1] = TEXT('\0');
        DPF(APPmsg, TEXT("CLMT Version: %s started from %s"),TEXT(VER_FILEVERSION_STR),szModule);
    }
    else
    {
        DPF(APPmsg, TEXT("CLMT Version: %s"),TEXT(VER_FILEVERSION_STR));
    }
    GetSystemTime(&systime);
    if (GetTimeFormat(LOCALE_USER_DEFAULT,0,&systime,NULL,lpTimeStr,ARRAYSIZE(lpTimeStr)))
    {
        DPF(APPmsg, TEXT("CLMT started at %s,%d/%d/%d"),lpTimeStr,systime.wMonth,systime.wDay ,systime.wYear );
    }

    cchSize = ARRAYSIZE(lpComputerName);
    if (GetComputerName(lpComputerName,&cchSize))
    {
        DPF(APPmsg, TEXT("Computer name :  %s"),lpComputerName);
    }
    ov.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO)&ov))
    {
        TCHAR szProductType[MAX_PATH];
        TCHAR szSuiteList[MAX_PATH];
        DPF(APPmsg, TEXT("OS Version: %d.%d"),ov.dwMajorVersion,ov.dwMinorVersion);
        if (ov.szCSDVersion[0])
        {
            DPF(APPmsg, TEXT("Service Pack: %s"),ov.szCSDVersion);
        }
        switch (ov.wProductType )
        {
            case VER_NT_WORKSTATION:
                hr = StringCchCopy(szProductType,ARRAYSIZE(szProductType),TEXT("NT_WORKSTATION"));
                break;
            case VER_NT_DOMAIN_CONTROLLER:
                hr = StringCchCopy(szProductType,ARRAYSIZE(szProductType),TEXT("DOMAIN_CONTROLLER"));
                break;
            case VER_NT_SERVER :
                hr = StringCchCopy(szProductType,ARRAYSIZE(szProductType),TEXT("NT_SERVER"));
                break;
            default:
                hr = StringCchCopy(szProductType,ARRAYSIZE(szProductType),TEXT("Unknow Type"));
        }
        if (FAILED(hr))
        {
            return hr;
        }
        DPF(APPmsg, TEXT("Product Type: %s"),szProductType);
        szSuiteList[0] = TEXT('\0');
        for (psi = c_rgSuite_Info; psi->szSuiteName; psi++)
        {
            if (psi->wSuiteMask & ov.wSuiteMask)
            {
                hr = StringCchCat(szSuiteList,ARRAYSIZE(szSuiteList),psi->szSuiteName);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
        if (FAILED(hr))
        {
            return hr;
        }
        if (szSuiteList[0])
        {
            DPF(APPmsg, TEXT("Suite List: %s"),szSuiteList);
        }
    }
    lcidSys = GetSystemDefaultLCID();
    lcidUser = GetUserDefaultLCID();
    lcidInstall = GetInstallLocale();
    if (GetLocaleInfo(lcidInstall,LOCALE_SENGLANGUAGE,szLocalename,ARRAYSIZE(szLocalename)))
    {
        DPF(APPmsg, TEXT("OS LanguageID/Name: %x,%s"),lcidInstall,szLocalename);
    }
    else
    {
        DPF(APPmsg, TEXT("OS LanguageID/Name: %x"),lcidInstall);
    }

    if (GetLocaleInfo(lcidSys,LOCALE_SENGLANGUAGE,szLocalename,ARRAYSIZE(szLocalename)))
    {
        DPF(APPmsg, TEXT("System locale ID/Name: %x,%s"),lcidSys,szLocalename);
    }
    else
    {
        DPF(APPmsg, TEXT("System locale ID: %x"),lcidSys);
    }
    if (GetLocaleInfo(lcidUser,LOCALE_SENGLANGUAGE,szLocalename,ARRAYSIZE(szLocalename)))
    {
        DPF(APPmsg, TEXT("User Locale ID/Name: %x,%s"),lcidUser,szLocalename);
    }
    else
    {
        DPF(APPmsg, TEXT("User Locale ID: %x"),lcidUser);
    }
    if (GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir)))
    {
        TCHAR                  DriveRoot[_MAX_DRIVE + 2];
        ULARGE_INTEGER FreeBytesAvailable;    // bytes available to caller
        ULARGE_INTEGER TotalNumberOfBytes;    // bytes on disk
        ULARGE_INTEGER TotalNumberOfFreeBytes;

        DPF(APPmsg, TEXT("System Dir is : %s"),szSystemDir);
        _tsplitpath(szSystemDir, DriveRoot, NULL, NULL, NULL);
        if (FAILED(hr = StringCchCat(DriveRoot, ARRAYSIZE(DriveRoot), TEXT("\\"))))
        {
            return hr;
        }
        if ( GetVolumeInformation(DriveRoot, NULL, 0,
                NULL, NULL, NULL, szFileSystemType, ARRAYSIZE(szFileSystemType)) )
        {            
            DPF(APPmsg, TEXT("System Drive File System is : %s"),szFileSystemType);
        }
        if (GetDiskFreeSpaceEx(szSystemDir,&FreeBytesAvailable,&TotalNumberOfBytes,&TotalNumberOfFreeBytes))
        {
            TCHAR szFreeBytesAvailable[64],szTotalNumberOfBytes[64],szTotalNumberOfFreeBytes[64];
            _ui64tot(FreeBytesAvailable.QuadPart,szFreeBytesAvailable,10);
            _ui64tot(TotalNumberOfBytes.QuadPart,szTotalNumberOfBytes,10);
            _ui64tot(TotalNumberOfFreeBytes.QuadPart,szTotalNumberOfFreeBytes,10); 
            DPF(APPmsg, TEXT("Free Space Available for system drive : %s"),szFreeBytesAvailable);
            DPF(APPmsg, TEXT("Total Space Available for system drive : %s"),szTotalNumberOfBytes);
            DPF(APPmsg, TEXT("Total Free Space Available for system drive : %s"),szTotalNumberOfFreeBytes);

        }
    }   
    cchCurrRoot = ARRAYSIZE(szCurrRoot);
    cchExpRoot = ARRAYSIZE(szExpRoot);
    if ( (GetRegistryValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                        TEXT("PathName"),(LPBYTE)szExpRoot,&cchExpRoot)==ERROR_SUCCESS)
         && (GetRegistryValue(HKEY_LOCAL_MACHINE,TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                        TEXT("SystemRoot"),(LPBYTE)szCurrRoot,&cchCurrRoot)==ERROR_SUCCESS) )
    {
        szExpRoot[1] = TEXT('\0');
        szCurrRoot[1] = TEXT('\0');
        if (MyStrCmpI(szExpRoot,szCurrRoot))
        {
            DPF(APPmsg, TEXT("Warning : System Drive is not correct, supposed to be ---%s Drive---, right now is --- %s Drive ---"),szExpRoot,szCurrRoot);
            DPF(APPmsg, TEXT("Warning : This is usually caused by you ghost the image from one partition, and recover to another"));
        }
    }    
    return S_OK;
}
    
HRESULT AddExtraQuoteEtc(
    LPTSTR lpszStrIn,
    LPTSTR *lplpszStrOut)
{
    LPTSTR          lpStart,lpAtSpecialChar,lpDest;
    DWORD           cchSpechialCharCount = 0,cchStrLen;
    HRESULT         hr;
    LPTSTR          szSpecialStrList[] = {TEXT("\""),TEXT("%%"),NULL};
    int             i , nCurrSpecialStr;
    TCHAR           szTemplate[MAX_PATH];
    
            
    if (!lpszStrIn || !lplpszStrOut)
    {
        return E_INVALIDARG;
    }
    i = 0;
    while (szSpecialStrList[i])
    {
        lpStart = lpszStrIn;
        while (lpAtSpecialChar = StrStrI(lpStart,szSpecialStrList[i]))
        {
            cchSpechialCharCount += lstrlen(szSpecialStrList[i]);
            lpStart = lpAtSpecialChar + lstrlen(szSpecialStrList[i]);
        }
        i++;
    }
    if (!cchSpechialCharCount)
    {
        *lplpszStrOut = malloc ( (lstrlen(lpszStrIn) +1) * sizeof(TCHAR));
        if (!*lplpszStrOut)
        {
            return E_OUTOFMEMORY;
        }
        hr = StringCchCopy(*lplpszStrOut,lstrlen(lpszStrIn) +1,lpszStrIn);
        return S_FALSE;
    }     
    cchStrLen = lstrlen(lpszStrIn) + cchSpechialCharCount + 1;
    *lplpszStrOut = malloc (cchStrLen * sizeof(TCHAR));
    if (!*lplpszStrOut)
    {
        return E_OUTOFMEMORY;
    }
    hr = StringCchCopy(*lplpszStrOut,cchStrLen,TEXT(""));

    lpStart = lpszStrIn;
    lpAtSpecialChar = lpszStrIn;

    while (*lpStart)
    {
        LPTSTR lp1stSpecialChar = NULL;

        nCurrSpecialStr = 0;
        for (i = 0; szSpecialStrList[i]; i++)
        {
            lpAtSpecialChar = StrStrI(lpStart,szSpecialStrList[i]);
            if (lpAtSpecialChar && !lp1stSpecialChar)
            {
                lp1stSpecialChar = lpAtSpecialChar;
                nCurrSpecialStr = i;
            }
            else if (lpAtSpecialChar && lp1stSpecialChar)
            {
                if (lpAtSpecialChar < lp1stSpecialChar)
                {
                    lp1stSpecialChar = lpAtSpecialChar;
                    nCurrSpecialStr = i;
                }
            }
        }
        if (lp1stSpecialChar)
        {
            TCHAR  chTmp = *lp1stSpecialChar;
            *lp1stSpecialChar = TEXT('\0');

            hr = StringCchCat(*lplpszStrOut,cchStrLen,lpStart);
            *lp1stSpecialChar = chTmp;
            for (i = 0; i< lstrlen(szSpecialStrList[nCurrSpecialStr])* 2; i++)
            {
                szTemplate[i] = chTmp;
            }
            szTemplate[i] = TEXT('\0');
            hr = StringCchCat(*lplpszStrOut,cchStrLen,szTemplate);            
            lpStart = lp1stSpecialChar + lstrlen(szSpecialStrList[nCurrSpecialStr]);
        }
        else
        {
            hr = StringCchCat(*lplpszStrOut,cchStrLen,lpStart);
            lpStart = lpStart + lstrlen(lpStart);
        }
    }        
    return S_OK;    
}

HRESULT CopyMyselfTo(LPTSTR lpszDestDir)
{
    TCHAR       szModule[2*MAX_PATH+1];
    LPTSTR      lpszNewFile,lpFileName;
    DWORD       cchLen;
    BOOL        bCopied;
    HRESULT     hr;

    if (!lpszDestDir || !lpszDestDir[0])
    {
        return E_INVALIDARG;        
    }
    if (!GetModuleFileName(GetModuleHandle(NULL),szModule,ARRAYSIZE(szModule)-1))
    {
        szModule[ARRAYSIZE(szModule)-1] = TEXT('\0');
        return HRESULT_FROM_WIN32(GetLastError());        
    }
    lpFileName = StrRChrIW(szModule,NULL,TEXT('\\'));
    if (!lpFileName)
    {
        return E_FAIL;
    }
    lpFileName++;
    if (! *lpFileName)
    {
        return E_FAIL;
    }
    cchLen = lstrlen(lpszDestDir)+ lstrlen(lpFileName) + 2; // one for "\\", one for ending NULL
    if (!(lpszNewFile =  malloc(cchLen * sizeof(TCHAR))))
    {
        return E_OUTOFMEMORY;
    }
    //We calculte the buffer for lpszNewFile, so here StringCchCopy should be
    //always success, assinging return value just make prefast happy 
    hr = StringCchCopy(lpszNewFile,cchLen,lpszDestDir);
    ConcatenatePaths(lpszNewFile,lpFileName,cchLen);    
    bCopied = CopyFile(szModule,lpszNewFile,FALSE);
    if (bCopied)
    {
        free(lpszNewFile);
        return S_OK;
    }
    else
    {
        DWORD dw = GetLastError();
        DWORD dwAttrib = GetFileAttributes(lpszNewFile);

        if ( (dwAttrib & FILE_ATTRIBUTE_READONLY) 
             ||(dwAttrib & FILE_ATTRIBUTE_SYSTEM) )
        {
            if (SetFileAttributes(lpszNewFile,FILE_ATTRIBUTE_NORMAL))
            {
                bCopied = CopyFile(szModule,lpszNewFile,FALSE);
                if (bCopied)
                {
                    dw = ERROR_SUCCESS;
                }
                else
                {
                    dw = GetLastError();
                }
            }
        }
        free(lpszNewFile);
        return HRESULT_FROM_WIN32(dw);
    }
}



// local functions


HRESULT  SetRunOnceValue (
    IN LPCTSTR szValueName,
    IN LPCTSTR szValue)
{
	HKEY				hRunOnceKey = NULL;
	DWORD				dwStatus	= ERROR_SUCCESS;
	DWORD				cbData;
    const TCHAR* szRunOnceKeyPath = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
	
	if (NULL == szValueName || TEXT('\0') == szValueName[0])
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto SetRunOnceValueEnd;
	}
    if (NULL == szValue || TEXT('\0') == szValue[0])
	{
		dwStatus = ERROR_INVALID_PARAMETER;
		goto SetRunOnceValueEnd;
	}
	
	dwStatus = RegOpenKey (HKEY_LOCAL_MACHINE, szRunOnceKeyPath, &hRunOnceKey);
	if (ERROR_SUCCESS != dwStatus)
    {
		goto SetRunOnceValueEnd;
    }
	
	
	cbData = ( lstrlen(szValue) + 1)  * sizeof(TCHAR);
	dwStatus = RegSetValueEx (hRunOnceKey,
							  szValueName,
							  0,			// Reserved
							  REG_SZ,
							  (CONST BYTE *) szValue,
							  cbData);

SetRunOnceValueEnd:
    if (hRunOnceKey)
    {
		RegCloseKey(hRunOnceKey);
    }
    return HRESULT_FROM_WIN32(dwStatus);
}



//-----------------------------------------------------------------------
//
//  Function:   SetRunValue
//
//  Descrip:    
//
//  Returns:    BOOL
//
//  Notes:      none
//
//  History:    
//
//  Notes:
//
//-----------------------------------------------------------------------
HRESULT SetRunValue(
    LPCTSTR szValueName,
    LPCTSTR szValue
)
{
    HKEY  hRunKey = NULL;
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD cbData;

    if (NULL == szValueName || TEXT('\0') == szValueName[0] ||
        NULL == szValue || TEXT('\0') == szValue[0])
    {
        return E_INVALIDARG;
    }

    dwStatus = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT_RUN_KEY, &hRunKey);
    if (ERROR_SUCCESS == dwStatus)
    {
        cbData = (lstrlen(szValue) + 1) * sizeof(TCHAR);
        dwStatus = RegSetValueEx(hRunKey,
                                 szValueName,
                                 0,
                                 REG_SZ,
                                 (CONST BYTE *) szValue,
                                 cbData);
        RegCloseKey(hRunKey);
    }

    return (HRESULT_FROM_WIN32(dwStatus));
}


/*************************************************************
*
*   CreateSd(void)
*	Creates a SECURITY_DESCRIPTOR for administrators group.
*
*   NOTES:
*	Caller must free the returned buffer if not NULL.
*
*   RETURN CODES:
*
*************************************************************/
HRESULT CreateAdminsSd( PSECURITY_DESCRIPTOR    *ppSD)
{
    SID_IDENTIFIER_AUTHORITY    sia = SECURITY_NT_AUTHORITY;
	PSID                        BuiltInAdministrators = NULL;
	PSECURITY_DESCRIPTOR        Sd = NULL;
	ULONG                       AclSize;
	ACL                         *Acl;
    HRESULT                     hr;


     if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS,
                  0, 0, 0, 0, 0, 0,
                  &BuiltInAdministrators
            ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
	// 
	// Calculate the size of and allocate a buffer for the DACL, we need
	// this value independently of the total alloc size for ACL init.
	//

	//
	// "- sizeof (ULONG)" represents the SidStart field of the
	// ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
	// SID, this field is counted twice.
	// See detail in InitializeAcl in MSDN

	AclSize = sizeof (ACL) +
		(sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG)) +
		GetLengthSid(BuiltInAdministrators) ;

	Sd = LocalAlloc(LMEM_FIXED + LMEM_ZEROINIT, 
		SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

	if (!Sd) 
	{
		hr = E_OUTOFMEMORY;
        goto Exit;
	} 

	Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

	if (!InitializeAcl(Acl,
			AclSize,
			ACL_REVISION)) 
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
	}	
//#define ACCESS_ALL     GENERIC_ALL | STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL
	if (!AddAccessAllowedAce(Acl,
				ACL_REVISION,
				//GENERIC_READ | GENERIC_WRITE,
                GENERIC_ALL,
				BuiltInAdministrators)) 
	{
		// Failed to build the ACE granting "Built-in Administrators"
		// STANDARD_RIGHTS_ALL access.
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
	}

	
	if (!InitializeSecurityDescriptor(Sd,SECURITY_DESCRIPTOR_REVISION)) 
	{
		// error
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
	}

	if (!SetSecurityDescriptorDacl(Sd,
					TRUE,
					Acl,
					FALSE)) 
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
	} 
    *ppSD = Sd;
    hr = S_OK;

Exit:
	/* A jump of last resort */
    if (hr != S_OK)
    {
        *ppSD = NULL;
	    if (Sd)
        {
		    LocalFree(Sd);
        }		// error
    }
	if (BuiltInAdministrators)
    {
        FreeSid(BuiltInAdministrators);
    }	
	return hr;
}


/*************************************************************
*
*   MyStrCmpIA/W
*	Do locale independent string comparison(case-insensive)
*
*   NOTES:
*	It's just a wrapper for CompareString with LOCALE_INVARIANT
*   we can not use LOCALE_INVARIANT since this is XP+ only
*
*   RETURN CODES: see lstrcmpi in MSDN 
*
*************************************************************/
int MyStrCmpIW(
    LPCWSTR lpString1,
    LPCWSTR lpString2)
{
    return ( CompareStringW(LOCALE_ENGLISH, NORM_IGNORECASE,
                           lpString1, -1, lpString2, -1) - 2);  
}

int MyStrCmpIA(
    LPCSTR lpString1,
    LPCSTR lpString2)
{
    return ( CompareStringA(LOCALE_ENGLISH, NORM_IGNORECASE,
                           lpString1, -1, lpString2, -1) - 2);  
}

//-----------------------------------------------------------------------
//
//  Function:   MergeDirectory
//
//  Descrip:    Merge the contents inside source directory to destination
//              directory. If file/folder in source dir does not exist in
//              destination dir, we will add it to CLMTDO.inf. These files
//              or folders will be moved in DoCriticalWork().
//
//  Returns:    S_OK if function succeeded.
//              S_FALSE if source directory does not exist
//              else if error occured
//
//  Notes:      none
//
//  History:    04/30/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT MergeDirectory(
    LPCTSTR lpSrcDir,
    LPCTSTR lpDstDir
)
{
    HRESULT         hr = S_OK;
    BOOL            bRet;
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFile;
    TCHAR           szDstFile[MAX_PATH];
    TCHAR           szSrcFile[MAX_PATH];
    TCHAR           szSearchPath[MAX_PATH];

    if (!IsDirExisting((LPTSTR) lpSrcDir))
    {
        return S_FALSE;
    }

    // Destination directory does not exist, no need to do a merge
    if (!IsDirExisting((LPTSTR) lpDstDir))
    {
        hr = AddFolderRename((LPTSTR)lpSrcDir, (LPTSTR)lpDstDir, TYPE_DIR_MOVE, NULL);
        return hr;
    }

    hr = StringCchCopy(szSearchPath, ARRAYSIZE(szSearchPath), lpSrcDir);
    if (SUCCEEDED(hr))
    {
        bRet = ConcatenatePaths(szSearchPath, TEXT("*"), ARRAYSIZE(szSearchPath));
        if (!bRet)
        {
            hr = E_UNEXPECTED;
            return hr;
        }
    }
    else
    {
        return hr;
    }

    //
    // Check all files and subdirectores under Source directory
    // Merge contents to destination directory as appropriate
    //
    hFile = FindFirstFileEx(szSearchPath,
                            FindExInfoStandard,
                            &FindFileData,
                            FindExSearchLimitToDirectories,
                            NULL,
                            0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        while (SUCCEEDED(hr))
        {
            // Ignore "." and ".." folders
            if (lstrcmp(FindFileData.cFileName, TEXT(".")) != LSTR_EQUAL
                && lstrcmp(FindFileData.cFileName, TEXT("..")) != LSTR_EQUAL)
            {
                hr = StringCchCopy(szDstFile, ARRAYSIZE(szDstFile), lpDstDir)
                     || StringCchCopy(szSrcFile, ARRAYSIZE(szSrcFile), lpSrcDir);
                if (FAILED(hr))
                {
                    break;
                }

                bRet = ConcatenatePaths(szDstFile, 
                                        FindFileData.cFileName,
                                        ARRAYSIZE(szDstFile))
                       && ConcatenatePaths(szSrcFile,
                                           FindFileData.cFileName,
                                           ARRAYSIZE(szSrcFile));
                if (!bRet)
                {
                    hr = E_UNEXPECTED;
                    break;
                }

                //
                // Check if the file is a directory or not
                //
                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    // The file is a directory, do a recursive call 
                    // to merge contents inside it
                    hr = MergeDirectory(szSrcFile, szDstFile);
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
                else
                {
                    // This is just a file, move the file to destination folder
                    // if file does not exist in destination folder
                    if (!IsFileFolderExisting(szDstFile))
                    {
                        hr = AddFolderRename(szSrcFile, szDstFile, TYPE_FILE_MOVE, NULL);
                        if (FAILED(hr))
                        {
                            break;
                        }
                    }
                }
            }

            // Get the next file in source directory
            bRet = FindNextFile(hFile, &FindFileData);
            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        FindClose(hFile);

        if (HRESULT_CODE(hr) == ERROR_NO_MORE_FILES)
        {
            // No more files in source directory, function succeeded
            hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT IsNTFS(
        IN  LPTSTR lpszPathRoot,
        OUT BOOL   *pbIsNTFS)
{
    TCHAR       DriveRoot[_MAX_DRIVE + 2];
    BOOL        bIsNTFS = FALSE;
    TCHAR       szFileSystemType[FILESYSNAMEBUFSIZE];
    HRESULT     hr = S_OK;

    _tsplitpath(lpszPathRoot, DriveRoot, NULL, NULL, NULL);
    
    if (!pbIsNTFS || !lpszPathRoot || !lpszPathRoot[0])
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    hr = StringCchCat(DriveRoot, ARRAYSIZE(DriveRoot), TEXT("\\"));
    if (FAILED(hr))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (! GetVolumeInformation(DriveRoot, NULL, 0,
                NULL, NULL, NULL, szFileSystemType, ARRAYSIZE(szFileSystemType)) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (!MyStrCmpI(szFileSystemType,TEXT("NTFS")))
    {
        bIsNTFS = TRUE;
    }
    *pbIsNTFS = bIsNTFS;

Exit:    
    return hr;
}

HRESULT IsSysVolNTFS(OUT BOOL   *pbIsNTFS)
{
    TCHAR szWindir[MAX_PATH+1];
    
    if (!GetSystemWindowsDirectory(szWindir, ARRAYSIZE(szWindir)))
    {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }
    return IsNTFS(szWindir,pbIsNTFS);

}



BOOL
CALLBACK
DoCriticalDlgProc(
    HWND   hwndDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    static  HWND     hButton1, hButton2, hProgress, hText,hOK, hAdminText;
    static  TCHAR    szOK[64], szSTART[64],szCANCEL[64],szCRITICALUPDATING[MAX_PATH],
                     szREMIND_DO_CRITICAL[1024],szREBOOTING[MAX_PATH],
                     szAdminChange[512];
    static  DWORD    dwTimerProgressDone = 10000, dwTimerTickIncrement = 500 , dwTimerTicks;
    static  UINT_PTR dwTimer;
    TCHAR            szOldAdminName[MAX_PATH];
    int              nRet;
    BOOL             bRet;
    HRESULT          hr;
    static  BOOL     bSysUpdated;      

#define ID_TIMER 1

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Init the dialog
            ShowWindow(hwndDlg, SW_SHOWNORMAL);

            dwTimerTicks = 0;

            bSysUpdated = FALSE;
    
            LoadString(g_hInstDll,IDS_OK,szOK,ARRAYSIZE(szOK));
            LoadString(g_hInstDll,IDS_START,szSTART,ARRAYSIZE(szSTART));
            LoadString(g_hInstDll,IDS_CANCEL,szCANCEL,ARRAYSIZE(szCANCEL));
            LoadString(g_hInstDll,IDS_REMIND_DO_CRITICAL,szREMIND_DO_CRITICAL,
                        ARRAYSIZE(szREMIND_DO_CRITICAL));
            LoadString(g_hInstDll,IDS_CRITICALUPDATING,szCRITICALUPDATING,
                        ARRAYSIZE(szCRITICALUPDATING));
            LoadString(g_hInstDll,IDS_REBOOTING,szREBOOTING,ARRAYSIZE(szREBOOTING));
          
            hButton1 = GetDlgItem(hwndDlg, ID_BUTTON_1);
            hButton2 = GetDlgItem(hwndDlg, ID_BUTTON_2);
        	hProgress = GetDlgItem(hwndDlg, IDC_PROGRESS);
            hText = GetDlgItem(hwndDlg, IDC_STATIC);
            hOK = GetDlgItem(hwndDlg, IDOK);

            ShowWindow(hProgress,SW_HIDE);
            ShowWindow(hOK,SW_HIDE);
            SetWindowText(hButton1,szSTART);
            SetWindowText(hButton2,szCANCEL);
            SetWindowText(hText,szREMIND_DO_CRITICAL);

            SendMessage(hProgress, PBM_SETRANGE, 0, MAKELPARAM(0, dwTimerProgressDone )); 
            SetForegroundWindow(hwndDlg);            
            break;

        case WM_COMMAND:
            // Handle command buttons
            switch (wParam)
            {
                case ID_BUTTON_1:
                    if (bSysUpdated)
                    {
                        break;
                    }
                    bSysUpdated = TRUE;
                    SetWindowText(hText,szCRITICALUPDATING);
                    ShowWindow(hButton1,SW_HIDE);
                    ShowWindow(hButton2,SW_HIDE);
                    hr = DoCriticalWork();
                    if (SUCCEEDED(hr))
                    {
                        bSysUpdated = TRUE;
                        ShowWindow(hOK,SW_SHOW);
                        SetFocus(hOK);
                        DefDlgProc(hwndDlg,DM_SETDEFID, IDOK, 0);
                        dwTimer = SetTimer(hwndDlg,ID_TIMER,dwTimerTickIncrement,NULL);
                        if (dwTimer)
                        {
                            ShowWindow(hProgress,SW_SHOW);
                            SetWindowText(hText,szREBOOTING);
                        }                        
                    }
                    break;

                case ID_BUTTON_2:
                    nRet = DoMessageBox(GetConsoleWindow(), IDS_CONFIRM, 
                                        IDS_MAIN_TITLE, MB_YESNO|MB_SYSTEMMODAL);
                    if (IDYES == nRet)
                    {
                        EndDialog(hwndDlg, ID_BUTTON_2);
                    }
                    break;
                case IDOK:
                    if (bSysUpdated)
                    {
                        EndDialog(hwndDlg, ID_UPDATE_DONE);
                    }
                    else
                    {
                        EndDialog(hwndDlg, IDOK);
                    }
                    break;
                case ID_UPDATE_DONE:
                    EndDialog(hwndDlg, ID_UPDATE_DONE);
                    break;            
            }
            break;
        case WM_TIMER:
            dwTimerTicks += dwTimerTickIncrement;
            if (dwTimerTicks > dwTimerProgressDone)
		    {
		        KillTimer(hwndDlg, dwTimer);		
		        PostMessage(hwndDlg, WM_COMMAND, ID_UPDATE_DONE, 0);
		    }
            SendMessage(hProgress, PBM_SETPOS,dwTimerTicks,0);
            break;       

        case WM_CLOSE:
            EndDialog(hwndDlg, IDCANCEL);
            break;
        default:
            break;
    }

    return FALSE;
}


HRESULT DoCriticalWork ()
{
#ifdef CONSOLE_UI
    wprintf(TEXT("updating system settings, !!! Do not Interrupt......\n"));
#endif
    DPF(APPmsg, TEXT("Enter DoCriticalWork:"));
    BoostMyPriority();
    MakeDOInfCopy();
    g_hInfDoItem = SetupOpenInfFile(g_szToDoINFFileName,
                                    NULL,
                                    INF_STYLE_WIN4,
                                    NULL);
    if (g_hInfDoItem != INVALID_HANDLE_VALUE)
    {
        Remove16bitFEDrivers();
        ResetServicesStatus(g_hInfDoItem, TEXT_SERVICE_STATUS_SECTION);
        ResetServicesStartUp(g_hInfDoItem, TEXT_SERVICE_STARTUP_SECTION);
        // ReconfigureServices(g_hInf);
        BatchUpateIISMetabase(g_hInfDoItem,TEXT("Reg.Update.$MetaBase"));
        BatchFixPathInLink(g_hInfDoItem,TEXT("LNK"));
        BatchINFUpdate(g_hInfDoItem);
        FolderMove(g_hInfDoItem,TEXT("Folder.ObjectRename"),FALSE);
        LoopUser(FinalUpdateRegForUser);
        // The EnumUserProfile() will be enable after RC 1
        // EnumUserProfile(ResetMiscProfilePathPerUser);
        UsrGrpAndDoc_and_SettingsRename(g_hInfDoItem,FALSE);
        UpdateDSObjProp(g_hInfDoItem,DS_OBJ_PROPERTY_UPDATE);
        INFCreateHardLink(g_hInfDoItem,FOLDER_UPDATE_HARDLINK,FALSE);
        SetInstallLocale(0x0409);
        SetProtectedRenamesFlag(TRUE);
        RegUpdate(g_hInfDoItem, NULL , TEXT(""));        
        SetupCloseInfFile(g_hInfDoItem);
        DPF(APPmsg, TEXT("Leaving DoCriticalWork:"));
        return S_OK;
    }
    DPF(APPmsg, TEXT("Leaving DoCriticalWork:"));
    return HRESULT_FROM_WIN32( GetLastError() );
}


HRESULT RenameRegRoot (
    LPCTSTR   lpSrcStr,
    LPTSTR    lpDstStr,
    DWORD     dwSize,
    LPCTSTR   lpUserSid,
    LPCTSTR   lpKeyName)
{
    HRESULT hResult;
    TCHAR   szKeyBuf[2*MAX_PATH];
    TCHAR   cNonChar = TEXT('\xFFFF');

    if (StrStrI(lpSrcStr, TEXT("HKLM")))
        ReplaceString(lpSrcStr,TEXT("HKLM"),TEXT("MACHINE"),szKeyBuf, MAX_PATH*2,&cNonChar, NULL, NULL, TRUE);
    else if (StrStrI(lpSrcStr, TEXT("HKCR")))
        ReplaceString(lpSrcStr,TEXT("HKCR"),TEXT("CLASSES_ROOT"),szKeyBuf, MAX_PATH*2,&cNonChar, NULL, NULL, TRUE);
    else if (StrStrI(lpSrcStr, TEXT("HKCU")))
        ReplaceString(lpSrcStr,TEXT("HKCU"),TEXT("CURRENT_USER"),szKeyBuf, MAX_PATH*2,&cNonChar, NULL, NULL, TRUE);
    else
        hResult = StringCchPrintf(szKeyBuf, 2*MAX_PATH, TEXT("USERS\\%s%s"), lpUserSid, lpSrcStr);

    if (lpKeyName)
        hResult = StringCchPrintf(lpDstStr, dwSize, TEXT("%s\\%s"), szKeyBuf, lpKeyName);
    else
        hResult = StringCchCopy(lpDstStr, dwSize, szKeyBuf);

    return hResult;
}                    


DWORD AdjustRegSecurity (
HKEY    hRootKey,
LPCTSTR lpSubKeyName,       // Registry sub key path
LPCTSTR lpszUsersid,        // User Sid
BOOL    bSetOrRestore       // set or restore the security setting
)
{
    DWORD dwRet;
    HRESULT hr;
    TCHAR szKeyName[MAX_PATH*2];
    TCHAR szKeyBuf[MAX_PATH*2];

    if (lpszUsersid && *lpszUsersid)
    {
        if (FAILED(hr = StringCchPrintf(szKeyName, MAX_PATH*2-1, TEXT("\\%s"), lpSubKeyName)))
            goto Exit1;
    }
    else if (hRootKey == HKEY_LOCAL_MACHINE)
    {
        if (FAILED(hr = StringCchPrintf(szKeyName, MAX_PATH*2-1, TEXT("HKLM\\%s"), lpSubKeyName)))
            goto Exit1;
    }
    else if (hRootKey == HKEY_CLASSES_ROOT)
    {
        if (FAILED(hr = StringCchPrintf(szKeyName, MAX_PATH*2-1, TEXT("HKCR\\%s"), lpSubKeyName)))
            goto Exit1;
    }
    RenameRegRoot(szKeyName, szKeyBuf, 2*MAX_PATH-1, lpszUsersid, NULL);
    dwRet = AdjustObjectSecurity(szKeyBuf, SE_REGISTRY_KEY, bSetOrRestore);
    goto Exit;

Exit1:
    dwRet = HRESULT_CODE(hr);
Exit:
    return dwRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetFirstNTFSDrive
//
//  Descrip:    Get the first NTFS drive in the system.
//
//  Returns:    S_OK - Found NTFS partition
//              S_FALSE - NTFS partition not found, return system drive instead
//              Else - Error occured
//
//  Notes:      none
//
//  History:    04/25/2002 Rerkboos   Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT GetFirstNTFSDrive(
    LPTSTR lpBuffer,        // Buffer to store first NTFS drive
    DWORD  cchBuffer        // Size of buffer in TCHAR
)
{
    HRESULT hr = S_OK;
    DWORD   dwRet;
    TCHAR   szDrives[MAX_PATH];
    LPCTSTR lpDrive;
    BOOL    bIsNTFS = FALSE;

    dwRet = GetLogicalDriveStrings(ARRAYSIZE(szDrives), szDrives);
    if (dwRet > 0)
    {
        lpDrive = MultiSzTok(szDrives);

        while (lpDrive != NULL)
        {
            hr = IsNTFS((LPTSTR) lpDrive, &bIsNTFS);
            if (SUCCEEDED(hr))
            {
                if (bIsNTFS)
                {
                    lstrcpyn(lpBuffer, lpDrive, 3);
                    return S_OK;
                }
            }

            lpDrive = MultiSzTok(NULL);
        }
    }

    // If we reach here, no NTFS partition is found
    // return System drive to caller instead
    hr = S_FALSE;
    if (!GetEnvironmentVariable(TEXT("HOMEDRIVE"), lpBuffer, cchBuffer))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   DuplicateString
//
//  Synopsis:   Duplicate the orinal string to a newly allocated buffer.
//
//  Returns:    S_OK if succeeded
//
//  History:    06/03/2002      rerkboos    created
//
//  Notes:      Caller need to free the allocated buffer using MEMFREE() macro
//              or HeapFree() API.
//
//-----------------------------------------------------------------------------
HRESULT DuplicateString(
    LPTSTR  *plpDstString,      // Pointer to the newly allocated buffer
    LPDWORD lpcchDstString,     // Pointer to store size of buffer (in TCHAR)
    LPCTSTR lpOrgString         // Original string to duplicate
)
{
    HRESULT hr;

    if (plpDstString == NULL || lpcchDstString == NULL)
    {
        return E_INVALIDARG;
    }

    *lpcchDstString = lstrlen(lpOrgString) + 1;
    *plpDstString = MEMALLOC(*lpcchDstString * sizeof(TCHAR));
    if (*plpDstString != NULL)
    {
        hr = StringCchCopy(*plpDstString,
                           *lpcchDstString,
                           lpOrgString);
        if (FAILED(hr))
        {
            // Free the memory if failed to copy the string
            MEMFREE(*plpDstString);
        }
    }
    else
    {
        *lpcchDstString = 0;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT
SetProtectedRenamesFlag(
    BOOL bSet
    )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    rslt = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                        0,
                        KEY_SET_VALUE,
                        &hKey);

    if (rslt == ERROR_SUCCESS) 
    {
        DWORD Value = bSet ? 1 : 0;
        rslt = RegSetValueEx(hKey,
                             TEXT("AllowProtectedRenames"),
                             0,
                             REG_DWORD,
                             (LPBYTE)&Value,
                             sizeof(DWORD));
        RegCloseKey(hKey);

        if (rslt != ERROR_SUCCESS) 
        {
            hr = HRESULT_FROM_WIN32(rslt);
        }
    } 
    else 
    {
        hr = HRESULT_FROM_WIN32(rslt);            
    }
    return hr;
}

LONG SDBCleanup(
    OUT     LPTSTR    lpSecDatabase,
    IN      DWORD     cchLen,
    OUT     LPBOOL    lpCleanupFailed
    )
{
    char                aszSdbFile[MAX_PATH+1+MAX_PATH];
    TCHAR               wszSdbFile[MAX_PATH+1+MAX_PATH];
    TCHAR               wszWindir[MAX_PATH+1];
    TCHAR               szSdbLogFiles[MAX_PATH+1+MAX_PATH];    
    TCHAR               szSdbLogFileRoot[MAX_PATH+1+MAX_PATH],szBackupLogFileRoot[MAX_PATH+1+MAX_PATH];    
    JET_DBINFOMISC      jetdbinfo;    
    JET_ERR             jetError;    
    long                lerr = ERROR_SUCCESS;   
    HRESULT             hr;
    
    if (!GetSystemWindowsDirectory(wszSdbFile, ARRAYSIZE(wszSdbFile)-MAX_PATH))
    {
        DPF(APPerr, TEXT("Failed to get WINDIR"));
        lerr = GetLastError();
        goto EXIT;
    }
    if (!GetSystemWindowsDirectory(wszWindir, ARRAYSIZE(wszWindir)))
    {
        DPF(APPerr, TEXT("Failed to get WINDIR"));
        lerr = GetLastError();
        goto EXIT;
    }

    hr = StringCchCopy(szSdbLogFiles,ARRAYSIZE(szSdbLogFiles),wszWindir);
    hr = StringCchCopy(szSdbLogFileRoot,ARRAYSIZE(szSdbLogFileRoot),wszWindir);
    hr = StringCchCopy(szBackupLogFileRoot,ARRAYSIZE(szBackupLogFileRoot),wszWindir);

    ConcatenatePaths(szSdbLogFileRoot,TEXT("\\Security"),ARRAYSIZE(szSdbLogFileRoot));
    ConcatenatePaths(szBackupLogFileRoot,TEXT("\\$CLMT_BACKUP$"),ARRAYSIZE(szBackupLogFileRoot));
    ConcatenatePaths(szSdbLogFiles,TEXT("\\Security\\edb?????.log"),ARRAYSIZE(szSdbLogFiles));
    
    hr = StringCbCat(wszSdbFile, ARRAYSIZE(wszSdbFile), TEXT("\\Security\\Database\\secedit.sdb"));
    
    if (lpSecDatabase)
    {
        hr = StringCchCopy(lpSecDatabase,cchLen,wszSdbFile);
    }
    WideCharToMultiByte( CP_ACP, 0, wszSdbFile, -1,aszSdbFile,ARRAYSIZE(aszSdbFile),NULL,NULL);

    jetError = JetGetDatabaseFileInfo(aszSdbFile,&jetdbinfo,sizeof(JET_DBINFOMISC),JET_DbInfoMisc);
    if (jetError != JET_errSuccess)
    {
        if (JET_errFileNotFound == jetError)
        {
            lerr = ERROR_SUCCESS;
        }
        else
        {
            lerr = jetError;
        }
        goto EXIT;
    }    

EXIT:
    if (lerr == ERROR_SUCCESS)
    {    
        if (jetdbinfo.dbstate == 2)
        {
            if (lpCleanupFailed)
            {
                *lpCleanupFailed = TRUE;
            }
        }
        else
        {
            WIN32_FIND_DATA FindFileData;
            HANDLE hFile = FindFirstFile(szSdbLogFiles,&FindFileData);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                do
                {
                    TCHAR szOld[MAX_PATH+1+MAX_PATH],szNew[MAX_PATH+1+MAX_PATH];

                    hr = StringCchCopy(szOld,ARRAYSIZE(szOld),szSdbLogFileRoot);
                    hr = StringCchCopy(szNew,ARRAYSIZE(szNew),szBackupLogFileRoot);

                    ConcatenatePaths(szOld,FindFileData.cFileName ,ARRAYSIZE(szOld));
                    ConcatenatePaths(szNew,FindFileData.cFileName ,ARRAYSIZE(szNew));
                    AddFolderRename(szOld,szNew,TYPE_FILE_MOVE,NULL);                    
                }while (FindNextFile(hFile,&FindFileData));
                FindClose(hFile);
            }
            if (lpCleanupFailed)
            {
                *lpCleanupFailed = FALSE;
            }
        }
    }
    return lerr;
}



//-----------------------------------------------------------------------
//
//  Function:   DeleteDirectory
//
//  Descrip:    Delete the directory and files inside.
//
//  Returns:    S_OK if function succeeded.
//              S_FALSE if source directory does not exist
//              else if error occured
//
//  Notes:      none
//
//  History:    07/13/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT DeleteDirectory(
    LPCTSTR lpDir
)
{
    HRESULT         hr = S_OK;
    BOOL            bRet;
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFile;
    TCHAR           szFile[2 * MAX_PATH];
    TCHAR           szSearchPath[2 * MAX_PATH];

    if (!IsDirExisting((LPTSTR) lpDir))
    {
        return S_FALSE;
    }

    // Compose the file path inside specified directory
    hr = StringCchCopy(szSearchPath, ARRAYSIZE(szSearchPath), lpDir);
    if (SUCCEEDED(hr))
    {
        bRet = ConcatenatePaths(szSearchPath, TEXT("*"), ARRAYSIZE(szSearchPath));
        if (!bRet)
        {
            hr = E_UNEXPECTED;
            return hr;
        }
    }
    else
    {
        return hr;
    }

    //
    // Delete all files and subdirectores under specified directory
    //
    hFile = FindFirstFileEx(szSearchPath,
                            FindExInfoStandard,
                            &FindFileData,
                            FindExSearchLimitToDirectories,
                            NULL,
                            0);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        while (SUCCEEDED(hr))
        {
            // Ignore "." and ".." folders
            if (MyStrCmpI(FindFileData.cFileName, TEXT(".")) != LSTR_EQUAL
                && MyStrCmpI(FindFileData.cFileName, TEXT("..")) != LSTR_EQUAL)
            {
                hr = StringCchCopy(szFile, ARRAYSIZE(szFile), lpDir);
                if (FAILED(hr))
                {
                    break;
                }

                bRet = ConcatenatePaths(szFile,
                                        FindFileData.cFileName,
                                        ARRAYSIZE(szFile));
                if (!bRet)
                {
                    hr = E_UNEXPECTED;
                    break;
                }

                //
                // Check if the file is a directory or not
                //
                if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    // The file is a directory, do a recursive call 
                    // to delete contents inside it
                    hr = DeleteDirectory(szFile);
                    if (FAILED(hr))
                    {
                        break;
                    }
                }
                else
                {
                    // This is just a file, delete it
                    bRet = DeleteFile(szFile);
                    if (!bRet)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        break;
                    }
                }
            }

            // Get the next file in source directory
            bRet = FindNextFile(hFile, &FindFileData);
            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        FindClose(hFile);

        if (HRESULT_CODE(hr) == ERROR_NO_MORE_FILES)
        {
            // Delete itself
            bRet = RemoveDirectory(lpDir);
            if (bRet)
            {
                // function succeeded
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//-----------------------------------------------------------------------
//
//  Function:   MyDeleteFile
//
//  Descrip:    Delete the specified file. The function will set the file
//              attribute to Normal before deletion
//
//  Returns:    S_OK if function succeeded.
//              S_FALSE if source directory does not exist
//              else if error occured
//
//  Notes:      none
//
//  History:    07/13/2002 rerkboos created
//
//  Notes:      none
//
//-----------------------------------------------------------------------
HRESULT MyDeleteFile(
    LPCTSTR lpFile
)
{
    HRESULT hr;
    BOOL    bRet;

    bRet = SetFileAttributes(lpFile, FILE_ATTRIBUTE_NORMAL);
    if (bRet)
    {
        bRet = DeleteFile(lpFile);
    }

    hr = (bRet ? S_OK : HRESULT_FROM_WIN32(GetLastError()));

    return hr;
}



HRESULT GetDCInfo(
    PBOOL       pbIsDC,//whether is a DC
    LPTSTR      lpszDCName,//if is DC, the DC name
    PDWORD      pcchLen)//buffer size for lpszDCName
{
    PBYTE       pdsInfo = NULL;
    DWORD       dwErr = ERROR_SUCCESS;
    HRESULT     hr = S_OK;
    
    if (!pbIsDC)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    //
    // Check if the machine is Domain Controller or not
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              &pdsInfo);
    if (dwErr == ERROR_SUCCESS)
    {
        DSROLE_MACHINE_ROLE dsMachineRole;

        dsMachineRole = ((DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pdsInfo)->MachineRole;

        if (dsMachineRole == DsRole_RoleBackupDomainController ||
            dsMachineRole == DsRole_RolePrimaryDomainController)
        {
            *pbIsDC = TRUE;
            if (pcchLen)
            {
                if (lpszDCName)
                {
                    hr = StringCchCopy(lpszDCName,*pcchLen,
                          ((DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pdsInfo)->DomainNameFlat);
                }
                //
               *pcchLen = lstrlen(((DSROLE_PRIMARY_DOMAIN_INFO_BASIC *) pdsInfo)->DomainNameFlat)+ 1;
            }
        }
        else
        {
            *pbIsDC = FALSE;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        pdsInfo = NULL;
        goto Exit;
    }

Exit:
    if (pdsInfo)
    {
        DsRoleFreeMemory(pdsInfo);
    }
    return hr;

}
HRESULT GetFQDNForExchange2k(LPTSTR *lplpFQDN)
{
    LPTSTR lpExchangeFormat = TEXT("LDAP://CN=1,CN=SMTP,CN=Protocols,CN=%s,CN=Servers,CN=%s,CN=Administrative Groups,CN=%s,CN=Microsoft Exchange,CN=Services,CN=Configuration,%s");
    BOOL    bIsDC;
    TCHAR   szDcName[MAX_PATH+1],szCompname[MAX_PATH+1];
    DWORD   cchSize;
    TCHAR   szCurrUsrname[MAX_PATH+1];
    LPTSTR  lpFQDNCurrUsr = NULL,lpFQDNSuffix,lpFQDNWithldap = NULL;
    DWORD   cchPathWithLDAP;
    TCHAR   szExchgeReg[2*MAX_PATH];
    LPTSTR  lpszAdminGroupName = NULL,lpszOrgName = NULL,lpStart,lpEnd;
    TCHAR   cTmp;
    HRESULT hr;
    LONG    lstatus;

    cchSize = ARRAYSIZE(szCurrUsrname);
    if (!GetUserName(szCurrUsrname, &cchSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    cchSize = ARRAYSIZE(szDcName);
    hr = GetDCInfo(&bIsDC,szDcName,&cchSize);
    if (FAILED(hr) || !bIsDC)
    {
        if (!bIsDC)
        {
            hr =S_FALSE;
        }
        goto Exit;
    }
    cchSize = ARRAYSIZE(szCompname);
    if (!GetComputerName(szCompname,&cchSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (S_OK !=GetFQDN(szCurrUsrname,szDcName,&lpFQDNCurrUsr))
    {
        lpFQDNCurrUsr = NULL;
        goto Exit;
    }
    lpFQDNSuffix = StrStrI(lpFQDNCurrUsr, TEXT("=Users,"));
    if (!lpFQDNSuffix)
    {
        hr = S_FALSE;
        goto Exit;
    }
    lpFQDNSuffix += lstrlen(TEXT("=Users,"));

    cchSize = ARRAYSIZE(szExchgeReg);
    lstatus= RegGetValue(HKEY_LOCAL_MACHINE,
                         TEXT("SYSTEM\\CurrentControlSet\\Services\\SMTPSVC\\Parameters"),
                         TEXT("SiteDN"), NULL, (LPBYTE)szExchgeReg, &cchSize);
    if (ERROR_SUCCESS != lstatus)

    {
        hr = HRESULT_FROM_WIN32(lstatus);
        goto Exit;
    }
    lpszAdminGroupName = malloc(ARRAYSIZE(szExchgeReg) * sizeof(TCHAR));
    lpszOrgName = malloc(ARRAYSIZE(szExchgeReg) * sizeof(TCHAR));
    if (!lpszAdminGroupName || !lpszOrgName)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    //try to get exchnage admin group group name
    //by default it is First Administrative Group
    lpStart = StrStrI(szExchgeReg, TEXT("/ou="));
    if (lpStart)
    {
        lpStart = lpStart + lstrlen(TEXT("/ou="));
        if (!*lpStart)
        {
            hr = S_FALSE;
            goto Exit;
        }
    }
    else
    {
        hr = S_FALSE;
        goto Exit;
    }
    lpEnd = StrStrI(lpStart, TEXT("/"));
    if (lpEnd)
    {
        cTmp = *lpEnd;
        *lpEnd = TEXT('\0');
    }
    hr = StringCchCopy(lpszAdminGroupName,ARRAYSIZE(szExchgeReg),lpStart);
    if (lpEnd)
    {
        *lpEnd = cTmp;
    }


    //try to get ornization name
    lpStart = StrStrI(szExchgeReg, TEXT("/o="));
    if (lpStart)
    {
        lpStart = lpStart + lstrlen(TEXT("/o="));
        if (!*lpStart)
        {
            hr = S_FALSE;
            goto Exit;
        }
    }
    else
    {
        hr = S_FALSE;
        goto Exit;
    }
    lpEnd = StrStrI(lpStart, TEXT("/"));
    if (lpEnd)
    {
        cTmp = *lpEnd;
        *lpEnd = TEXT('\0');
    }
    hr = StringCchCopy(lpszOrgName,ARRAYSIZE(szExchgeReg),lpStart);
    if (lpEnd)
    {
        *lpEnd = cTmp;
    }
    cchPathWithLDAP = lstrlen(lpFQDNSuffix) + lstrlen(szDcName) + lstrlen(szCompname)
                      + lstrlen(lpExchangeFormat) + lstrlen(lpszOrgName) 
                      + lstrlen(lpszAdminGroupName)+ MAX_PATH;
    
    if (! (lpFQDNWithldap = (LPTSTR) malloc(cchPathWithLDAP * sizeof(TCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = StringCchPrintf(lpFQDNWithldap,
                         cchPathWithLDAP,
                         lpExchangeFormat,
                         szCompname,
                         lpszAdminGroupName,
                         lpszOrgName, 
                         lpFQDNSuffix);
Exit:
    if (hr == S_OK)
    {
        *lplpFQDN = lpFQDNWithldap;
    }
    else
    {
        FreePointer(lpFQDNWithldap);
        *lplpFQDN = NULL;
    }
    FreePointer(lpFQDNCurrUsr);
    FreePointer(lpszAdminGroupName);
    FreePointer(lpszOrgName);
    return hr;
}

HRESULT GetFQDNForFrs(LPTSTR *lplpFQDN)
{
    BOOL    bIsDC;
    TCHAR   szDcName[MAX_PATH+1],szCompname[MAX_PATH+1];
    DWORD   cchSize;
    TCHAR   szCurrUsrname[MAX_PATH+1];
    LPTSTR  lpFQDNCurrUsr = NULL,lpFQDNSuffix,lpFQDNWithldap = NULL;
    LPTSTR  lpFrsFormat = TEXT("LDAP://CN=Domain System Volume (SYSVOL share),CN=NTFRS Subscriptions,CN=%s,OU=Domain Controllers,%s");
    DWORD   cchPathWithLDAP;
    HRESULT hr;

    cchSize = ARRAYSIZE(szCurrUsrname);
    if (!GetUserName(szCurrUsrname, &cchSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    cchSize = ARRAYSIZE(szDcName);
    hr = GetDCInfo(&bIsDC,szDcName,&cchSize);
    if (FAILED(hr) || !bIsDC)
    {
        if (!bIsDC)
        {
            hr =S_FALSE;
        }
        goto Exit;
    }
    cchSize = ARRAYSIZE(szCompname);
    if (!GetComputerName(szCompname,&cchSize))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    if (S_OK !=GetFQDN(szCurrUsrname,szDcName,&lpFQDNCurrUsr))
    {
        lpFQDNCurrUsr = NULL;
        goto Exit;
    }
    lpFQDNSuffix = StrStrI(lpFQDNCurrUsr, TEXT("=Users,"));
    if (!lpFQDNSuffix)
    {
        hr =S_FALSE;
        goto Exit;
    }
    lpFQDNSuffix += lstrlen(TEXT("=Users,"));
    
    cchPathWithLDAP = lstrlen(lpFQDNSuffix) + lstrlen(szDcName) 
                            + lstrlen(lpFrsFormat) + MAX_PATH;
    
    if (! (lpFQDNWithldap = (LPTSTR) malloc(cchPathWithLDAP * sizeof(TCHAR))))
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = StringCchPrintf(lpFQDNWithldap,
                         cchPathWithLDAP,
                         lpFrsFormat,
                         szCompname,
                         lpFQDNSuffix);
    
Exit:
    if (hr == S_OK)
    {
        *lplpFQDN = lpFQDNWithldap;
    }
    else
    {
        FreePointer(lpFQDNWithldap);
        *lplpFQDN = NULL;
    }    
    FreePointer(lpFQDNCurrUsr);
    return hr;}



HRESULT AddDSObjPropUpdate2Inf(
    LPTSTR          lpLdpPath,
    LPTSTR          lpPropName,
    LPTSTR          lpValue)
{
    LPTSTR      lpszOneline = NULL;
    DWORD       cchSize ;
    HRESULT     hr = S_OK;
    TCHAR       szIndex[MAX_PATH];
    
    if (!lpLdpPath || !lpPropName || !lpValue)
    {
        hr = E_INVALIDARG;
        goto cleanup;
    }
    cchSize = lstrlen(lpLdpPath) + lstrlen(lpPropName) + lstrlen(lpValue) + MAX_PATH;
    if ( ! (lpszOneline = malloc(cchSize * sizeof(TCHAR)) ))
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    g_dwKeyIndex++;
    _itot(g_dwKeyIndex,szIndex,16);
    hr = StringCchPrintf(lpszOneline, cchSize, TEXT("\"%s\",\"%s\",\"%s\""),lpLdpPath,lpPropName,lpValue);
    if (!WritePrivateProfileString(DS_OBJ_PROPERTY_UPDATE,szIndex,lpszOneline,g_szToDoINFFileName))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }
    hr = S_OK;
cleanup:
    FreePointer(lpszOneline);
    return hr;
}


HRESULT Ex2000Update()
{
    LPTSTR      lpObjPath = NULL;
    LPTSTR      lpBadMailDirectory = NULL, lpPickupDirectory = NULL, lpQueueDirectory = NULL;
    LPTSTR      lpNewBadMailDirectory = NULL, lpNewPickupDirectory = NULL, lpNewQueueDirectory = NULL;
    HRESULT     hr;


    hr = GetFQDNForExchange2k(&lpObjPath);
    if (hr != S_OK)
    {        
        goto exit;
    }    
    hr = PropertyValueHelper(lpObjPath,TEXT("msExchSmtpBadMailDirectory"),&lpBadMailDirectory,NULL);
    if (hr == S_OK)
    {        
        if (lpNewBadMailDirectory =  ReplaceLocStringInPath(lpBadMailDirectory,TRUE))
        {
            AddDSObjPropUpdate2Inf(lpObjPath,TEXT("msExchSmtpBadMailDirectory"),lpNewBadMailDirectory);
        }    
    }    
    hr = PropertyValueHelper(lpObjPath,TEXT("msExchSmtpPickupDirectory"),&lpPickupDirectory,NULL);
    if (hr == S_OK)
    {        
        if (lpNewPickupDirectory =  ReplaceLocStringInPath(lpPickupDirectory,TRUE))
        {
            AddDSObjPropUpdate2Inf(lpObjPath,TEXT("msExchSmtpPickupDirectory"),lpNewPickupDirectory);
        }    
    }    
    hr = PropertyValueHelper(lpObjPath,TEXT("msExchSmtpQueueDirectory"),&lpQueueDirectory,NULL);
    if (hr == S_OK)
    {        
        if (lpNewQueueDirectory =  ReplaceLocStringInPath(lpQueueDirectory,TRUE))
        {
            AddDSObjPropUpdate2Inf(lpObjPath,TEXT("msExchSmtpQueueDirectory"),lpNewQueueDirectory);
        }    
    }    
exit:
    FreePointer(lpObjPath);
    FreePointer(lpBadMailDirectory);
    FreePointer(lpPickupDirectory);
    FreePointer(lpQueueDirectory);
    if (lpNewBadMailDirectory)
    {
        MEMFREE(lpNewBadMailDirectory);
    }
    if (lpNewPickupDirectory)
    {
        MEMFREE(lpNewPickupDirectory);
    }
    if (lpNewQueueDirectory)
    {
        MEMFREE(lpNewQueueDirectory);
    }    
    return hr;
}


HRESULT FRSUpdate()
{
    LPTSTR      lpObjPath = NULL;
    LPTSTR      lpfRSRootPath = NULL, lpfRSStagingPath = NULL;
    LPTSTR      lpNewfRSRootPath = NULL, lpNewfRSStagingPath = NULL;
    BOOL        bChanged = FALSE;
    HRESULT     hr;
    TCHAR       szSysVolPath[2*MAX_PATH],szSysVolPath2[2*MAX_PATH];
    DWORD       cchSize = ARRAYSIZE(szSysVolPath);
    WIN32_FIND_DATA FindFileData;
    HANDLE      hFile ;

    hr = GetFQDNForFrs(&lpObjPath);
    if (hr != S_OK)
    {        
        goto exit;
    }    
    hr = PropertyValueHelper(lpObjPath,TEXT("fRSRootPath"),&lpfRSRootPath,NULL);
    if (hr == S_OK)
    {
        if (lpNewfRSRootPath =  ReplaceLocStringInPath(lpfRSRootPath,TRUE))
        {
            AddDSObjPropUpdate2Inf(lpObjPath,TEXT("fRSRootPath"),lpNewfRSRootPath);
            bChanged = TRUE;
        }    
    }

    hr = PropertyValueHelper(lpObjPath,TEXT("fRSStagingPath"),&lpfRSStagingPath,NULL);
    if (hr == S_OK)
    {
        if (lpNewfRSStagingPath =  ReplaceLocStringInPath(lpfRSStagingPath,TRUE))
        {
            AddDSObjPropUpdate2Inf(lpObjPath,TEXT("fRSStagingPath"),lpNewfRSStagingPath);
            bChanged = TRUE;
        }    
    }
    if (bChanged)
    {
        TCHAR       szVal[MAX_PATH];

        _itot(210,szVal,10);
        hr = AddRegValueRename(TEXT("HKLM\\SYSTEM\\CurrentControlSet\\Services\\NtFrs\\Parameters\\Backup/Restore\\Process at Startup"),
                               TEXT("BurFlags"),
                               NULL,
                               NULL,
                               szVal,
                               REG_DWORD,
                               0,
                               NULL);
        
    }

    if (S_OK != GetSharePath(TEXT("SYSVOL"),szSysVolPath,&cchSize))
    {
        goto exit;
    }    
    hr = StringCchCopy(szSysVolPath2,ARRAYSIZE(szSysVolPath2),szSysVolPath);
    ConcatenatePaths(szSysVolPath2,TEXT("*.*"),ARRAYSIZE(szSysVolPath2));
    hFile = FindFirstFile(szSysVolPath2,&FindFileData);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            TCHAR  szEnrty[MAX_PATH+1+MAX_PATH];
            LPTSTR lpNewLinkPath = NULL, lpNewLinkData = NULL;
            TCHAR  szLinkValue[MAX_PATH+1+MAX_PATH];

            if(0 == MyStrCmpI(FindFileData.cFileName , TEXT(".")))
            {
                continue;
            }
            if(0 == MyStrCmpI(FindFileData.cFileName , TEXT("..")))
            {
                continue;
            }
            hr = StringCchCopy(szEnrty,ARRAYSIZE(szEnrty),szSysVolPath);
            ConcatenatePaths(szEnrty,FindFileData.cFileName ,ARRAYSIZE(szEnrty));
            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT))
            {
                continue;
            }
            if (!GetSymbolicLink(szEnrty,szLinkValue,ARRAYSIZE(szLinkValue)))
            {
                continue;
            }            
            if (!(lpNewLinkPath =  ReplaceLocStringInPath(szLinkValue,TRUE)))
            {
                continue;
            }
            if (!(lpNewLinkData =  ReplaceLocStringInPath(szEnrty,TRUE)))
            {
                lpNewLinkData = szEnrty;
            }
            AddHardLinkEntry(lpNewLinkData,lpNewLinkPath,TEXT("1"),NULL,TEXT("0"),NULL);
            if (lpNewLinkPath && lpNewLinkData != szEnrty)
            {
                MEMFREE(lpNewLinkPath);
            }
            if (lpNewLinkData)
            {
                MEMFREE(lpNewLinkData);
            }
        }while (FindNextFile(hFile,&FindFileData));
        FindClose(hFile);
    }       

exit:
    FreePointer(lpObjPath);
    FreePointer(lpfRSRootPath);
    FreePointer(lpfRSStagingPath);
    if (lpNewfRSRootPath)
    {
        MEMFREE(lpNewfRSRootPath);
    }
    if (lpNewfRSStagingPath)
    {
        MEMFREE(lpNewfRSStagingPath);
    }    
    return hr;

}


HRESULT GetSharePath(
    LPTSTR      lpShareName,
    LPTSTR      lpSharePath,
    PDWORD       pcchSize)
{
    HKEY        hkey = NULL;
    LONG        lstatus;
    HRESULT     hr;
    UINT        i = 0;
    LPTSTR      lpValueName = NULL, lpValueData = NULL;
    DWORD       cchValueName, cchValueData, numofentry;
    BOOL        bNameMatchFound = FALSE;
    LPTSTR      lpPath;


    if (!lpShareName || !pcchSize)
    {
        hr = E_INVALIDARG;
    }
    lstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("SYSTEM\\CurrentControlSet\\Services\\lanmanserver\\Shares"),
                           0,
                           KEY_READ,
                           &hkey);
    if (ERROR_SUCCESS != lstatus)
    {
        hr = HRESULT_FROM_WIN32(lstatus);
        goto exit;
    }
    lstatus = RegQueryInfoKey(hkey,
                              NULL,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              NULL,
                              &numofentry,
                              &cchValueName,
                              &cchValueData,
                              NULL,
                              NULL);
    if ( lstatus != ERROR_SUCCESS ) 
    {
        hr = HRESULT_FROM_WIN32(lstatus);
        goto exit;
    }
    if (!numofentry)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }
    cchValueName++;
    cchValueData++;
    lpValueName = malloc(cchValueName * sizeof(TCHAR));
    lpValueData = malloc(cchValueData * sizeof(TCHAR));
    if (!lpValueName || !lpValueData)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    for (i =0; i< numofentry; i++)
    {
        DWORD   cchCurrValueName, cchCurrValueData;
        DWORD   dwType;

        cchCurrValueName = cchValueName;
        cchCurrValueData = cchValueData;
        lstatus = RegEnumValue(hkey, i, lpValueName, &cchCurrValueName,
                     NULL, &dwType, (LPBYTE)lpValueData,&cchCurrValueData);  
        if ( (lstatus != ERROR_SUCCESS) 
             || (dwType != REG_MULTI_SZ)
             || MyStrCmpI(lpShareName,lpValueName) )
        {
            continue;
        }
        lpPath = lpValueData;
        while (*lpPath)
        {
            if (StrStrI(lpPath, TEXT("Path=")))
            {
                lpPath += lstrlen(TEXT("Path="));
                bNameMatchFound = TRUE;
                break;
            }
            lpPath = lpPath + lstrlen(lpPath) + 1;
        }
        if (bNameMatchFound)
        {
            break;
        }
    }
    if (bNameMatchFound)
    {
        if (*pcchSize < (UINT)lstrlen(lpPath) +1)
        {
            *pcchSize =  lstrlen(lpPath) +1;
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            goto exit;
        }
        *pcchSize =  lstrlen(lpPath) +1;
        if (lpSharePath)
        {
            hr = StringCchCopy(lpSharePath,*pcchSize,lpPath);        
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto exit;
    }
exit:
    FreePointer(lpValueName);
    FreePointer(lpValueData);
    if (hkey)
    {
        RegCloseKey(hkey);
    }
    return hr;
}


HRESULT Sz2MultiSZ(
    IN OUT LPTSTR     lpsz,
    IN  TCHAR         chSeperator)
{
    HRESULT     hr;
    LPTSTR      lp, lpSep;
    
    if (!lpsz)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    lp = lpsz;
    while (*lp && (lpSep = StrChr(lp,chSeperator)))
    {
        *lpSep = TEXT('\0');
        lp = lpSep + 1;
    }
    if (*lp)
    {
        lp = lp + lstrlen(lp) + 1;
        *lp = TEXT('\0');
    }
    hr = S_OK;
Cleanup:    
    return hr;
}


HRESULT ConstructUIReplaceStringTable(
    LPTSTR               lpszOld,
    LPTSTR               lpszNew,
    PREG_STRING_REPLACE pTable)
{

    DWORD      dwNumOld, dwNumNew;

    if (!lpszOld || !lpszNew)
    {
        return E_INVALIDARG;
    }
    dwNumOld = MultiSZNumOfString(lpszOld);
    dwNumNew = MultiSZNumOfString(lpszNew);

    if (!dwNumOld || !dwNumNew || (dwNumOld != dwNumNew))
    {
        return E_INVALIDARG;
    }
    
    pTable->nNumOfElem = dwNumNew;
    pTable->cchUserName = 0;
    pTable->szUserNameLst = NULL;
    pTable->cchSearchString = MultiSzLen(lpszOld);
    pTable->lpSearchString = lpszOld;
    pTable->cchReplaceString = MultiSzLen(lpszNew);
    pTable->lpReplaceString = lpszNew;
    pTable->cchAttribList = 0;
    pTable->lpAttrib = NULL;
    pTable->cchFullStringList = 0;
    pTable->lpFullStringList = NULL;
    pTable->cchMaxStrLen = 0;

    return S_OK;
}


HRESULT MakeDOInfCopy()
{
    TCHAR       szBackupDir[MAX_PATH];
    HRESULT     hr;
    TCHAR       szDoInf[2*MAX_PATH],szDoInfBackup[2*MAX_PATH];

    if (!GetSystemWindowsDirectory(szBackupDir, ARRAYSIZE(szBackupDir)))
    {
        //BUGBUG:Xiaoz:Add DLG pop up for failure
        DPF(APPerr, TEXT("MakeDOInfCopy:Failed to get WINDIR"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    ConcatenatePaths(szBackupDir,CLMT_BACKUP_DIR,ARRAYSIZE(szBackupDir));
    hr = StringCchCopy(szDoInf,ARRAYSIZE(szDoInf),szBackupDir);
    hr = StringCchCopy(szDoInfBackup,ARRAYSIZE(szDoInfBackup),szBackupDir);

    ConcatenatePaths(szDoInf,TEXT("clmtdo.inf"),ARRAYSIZE(szDoInf));
    ConcatenatePaths(szDoInfBackup,TEXT("clmtdo.bak"),ARRAYSIZE(szDoInfBackup));

    if (!CopyFile(szDoInf,szDoInfBackup,FALSE))
    {
        DPF(APPerr, TEXT("MakeDOInfCopy:CopyFile failed"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    hr = S_OK;
Exit:
    return hr;
}


VOID RemoveSubString(
    LPTSTR  lpSrcString,
    LPCTSTR lpSubString
)
{
    LPTSTR lpMatchedStr;
    DWORD  dwSubStrLen;

    lpMatchedStr = StrStr(lpSrcString, lpSubString);
    if (lpMatchedStr != NULL)
    {
        dwSubStrLen = lstrlen(lpSubString);

        while (*(lpMatchedStr + dwSubStrLen) != TEXT('\0'))
        {
            *(lpMatchedStr) = *(lpMatchedStr + dwSubStrLen);
            lpMatchedStr++;
        }

        *lpMatchedStr = TEXT('\0');
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\tools\tokgen\engine.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    engine.c

Abstract:

    Token Generator for Cross Language Migration Tool

Author:

    Rerkboon Suwanasuk   01-May-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <setupapi.h>
#include <shlwapi.h>
#include "Common.h"


//-----------------------------------------------------------------------------
//
//  Function:   GenerateTokenFile
//
//  Synopsis:   Entry function for our program.
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT GenerateTokenFile(VOID)
{
    HRESULT hr;
    BOOL    bRet;
    HINF    hTemplateFile;
    HANDLE  hFile;
    
    WCHAR   wszFullTemplateFilePath[MAX_PATH];
    WCHAR   wszFullOutputFilePath[MAX_PATH];
    WCHAR   wszLCIDSectionName[32];
    LPWSTR  lpOutputFileBuffer = NULL;
    LPWSTR  lpFileName;
    size_t  cbOutputFileBuffer;

    //
    // Set some private environment variables for use in our program
    //
    if (!SetPrivateEnvironmentVar())
    {
        wprintf(TEXT("Error! Cannot set private environment variables.\n"));
        return E_FAIL;
    }

    hTemplateFile = SetupOpenInfFile(g_wszTemplateFile,
                                     NULL,
                                     INF_STYLE_OLDNT,
                                     NULL);
    if (hTemplateFile != INVALID_HANDLE_VALUE)
    {
        //
        // Read the [SourcePath] section from template INF file
        //
        hr = ReadSourcePathData(hTemplateFile);
        if (SUCCEEDED(hr))
        {
            hr = InitOutputFile(g_wszOutputFile,
                                wszLCIDSectionName,
                                ARRAYSIZE(wszLCIDSectionName));
            if (SUCCEEDED(hr))
            {
                //
                // Resolve generic strings
                //
                hr = ResolveStringsSection(hTemplateFile, TEXT("Strings"));
                if (FAILED(hr))
                {
                    goto EXIT;
                }

                //
                // Resolve lang-specific strings
                //
                hr = ResolveStringsSection(hTemplateFile, wszLCIDSectionName);
                if (FAILED(hr))
                {
                    goto EXIT;
                }

                //
                // Remove unneeded sub string
                //
                hr = RemoveUnneededStrings(hTemplateFile);
                if (FAILED(hr))
                {
                    goto EXIT;
                }

                //
                // Extract sub string
                //
                hr = ExtractStrings(hTemplateFile);
                if (FAILED(hr))
                {
                    goto EXIT;
                }
            }
        }
        else
        {
            wprintf( TEXT("Error! Cannot read [SourcePath] section\n") );
        }

        SetupCloseInfFile(hTemplateFile);
    }
    else
    {
        wprintf(TEXT("Error! Cannot open template file: %s\n"), g_wszTemplateFile);
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

EXIT:
    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ReadSourcePathData
//
//  Synopsis:   Read [SourcePath] section from template INF file,
//              then store all the source paths into the structure.
//              This structure will be used to find the location of
//              resource files.
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
HRESULT ReadSourcePathData(
    HINF hTemplateFile
)
{
    HRESULT    hr = E_FAIL;
    BOOL       bRet;
    size_t     nLineIndex;
    WCHAR      wszValue[MAX_PATH];
    WCHAR      wszSrcPathSection[32];
    INFCONTEXT InfContext;

    if (hTemplateFile == INVALID_HANDLE_VALUE)
    {
        return E_INVALIDARG;
    }

    hr = StringCchPrintf(wszSrcPathSection,
                         ARRAYSIZE(wszSrcPathSection),
                         TEXT("SourcePath.%.4x"),
                         g_lcidTarget);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Extract the source paths from INF and save to global structure
    //
    g_dwSrcCount = SetupGetLineCount(hTemplateFile, wszSrcPathSection);

    for (nLineIndex = 0 ; nLineIndex < g_dwSrcCount ; nLineIndex++)
    {
        bRet = SetupGetLineByIndex(hTemplateFile,
                                   wszSrcPathSection,
                                   nLineIndex,
                                   &InfContext);
        if (bRet)
        {
            //
            // Get the name of each source path
            //
            bRet = SetupGetStringField(&InfContext,
                                       0,
                                       wszValue,
                                       ARRAYSIZE(wszValue),
                                       NULL);
            if (bRet)
            {
                hr = StringCchCopy(g_SrcPath[nLineIndex].wszSrcName,
                                   ARRAYSIZE(g_SrcPath[nLineIndex].wszSrcName),
                                   wszValue);
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the path associated to the source name
                    //
                    if (SetupGetStringField(&InfContext,
                                            1,
                                            wszValue,
                                            ARRAYSIZE(wszValue),
                                            NULL))
                    {
                        hr = StringCchCopy(g_SrcPath[nLineIndex].wszPath,
                                           ARRAYSIZE(g_SrcPath[nLineIndex].wszPath),
                                           wszValue);
                    }
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if (FAILED(hr))
        {
            break;
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ResolveStringsSection
//
//  Synopsis:   Resolve all strings under specified section name in template
//              file, then write the resolved strings to output file.
//
//  Returns:    HRESULT
//
//  History:    03/27/2002 Rerkboos     Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT ResolveStringsSection(
    HINF    hTemplateFile,      // Handle to template file
    LPCWSTR lpSectionName       // Section name in template file to resolve
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    LONG    lLineCount;

    if (hTemplateFile == INVALID_HANDLE_VALUE || lpSectionName == NULL)
    {
        return E_INVALIDARG;
    }

    wprintf(TEXT("Start resolving strings in section [%s]:\n"),
            lpSectionName);

    lLineCount = SetupGetLineCount(hTemplateFile, lpSectionName);
    if (lLineCount >= 0)
    {
        INFCONTEXT context;
        LONG       lLineIndex;
        LPWSTR     lpKey;
        LPWSTR     lpValue;
        DWORD      cchKey;
        DWORD      cchValue;
        DWORD      cbWritten;

        //
        // Resolve strings under string section
        //
        for (lLineIndex = 0 ; lLineIndex < lLineCount ; lLineIndex++)
        {
            bRet = SetupGetLineByIndex(hTemplateFile,
                                       lpSectionName,
                                       lLineIndex,
                                       &context);
            if (bRet)
            {
                hr = ResolveLine(&context, &lpKey, &cchKey, &lpValue, &cchValue);
                if (SUCCEEDED(hr))
                {
                    hr = WriteToOutputFile(g_wszOutputFile, lpKey, lpValue);
                    if (FAILED(hr))
                    {
                        wprintf(TEXT("[FAIL] - Cannot write to output file\n"));
                        break;
                    }

                    MEMFREE(lpKey);
                    MEMFREE(lpValue);
                }
                else
                {
                    wprintf(TEXT("[FAIL] - Cannot process line %d in template file\n"),
                            lLineIndex);
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    break;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }
    }
    else 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    wprintf(TEXT("Finish resolving strings in section [%s]: hr = 0x%X\n\n"),
            lpSectionName,
            hr);

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   ResolveLine
//
//  Synopsis:   Resolve a string value from input INF context.
//
//  Returns:    HRESULT
//
//  History:    03/27/2002 Rerkboos     Created
//
//  Notes:      This function will allocate memory for lplpKey and lplpValue,
//              Caller needs to free memory using HeapFree().
//
//-----------------------------------------------------------------------------
HRESULT ResolveLine(
    PINFCONTEXT lpContext,      // INF line context
    LPWSTR      *lplpKey,       // Pointer to newly allocated buffer for Key name
    LPDWORD     lpcchKey,       // Size of allocated buffer for Key name
    LPWSTR      *lplpValue,     // Pointer to newly allocated buffer for Value
    LPDWORD     lpcchValue      // Size of allocated buffer for Value
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    DWORD   cchKey;
    DWORD   cchRequired;

    if (lplpKey == NULL || lpcchKey == NULL ||
        lplpValue == NULL || lpcchValue == NULL)
    {
        return E_INVALIDARG;
    }

    bRet = SetupGetStringField(lpContext, 0, NULL, 0, &cchKey);
    if (bRet)
    {
        *lplpKey = MEMALLOC(cchKey * sizeof(WCHAR));
        if (*lplpKey)
        {
            *lpcchKey = cchKey;

            SetupGetStringField(lpContext, 0, *lplpKey, cchKey, &cchRequired);

            hr = ResolveValue(lpContext, lplpValue, lpcchValue);
            if (FAILED(hr))
            {
                wprintf(TEXT("[FAIL] Cannot resolve Key [%s], hr = 0x%X\n"),
                        *lplpKey,
                        hr);
                MEMFREE(*lplpKey);
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   InitOutputFile
//
//  Synopsis:   Initialize output file. Output file is always a Unicode text
//              file. This function will create a section name [Strings.XXXX]
//              where XXXX is locale ID that user put in command line
//
//  Returns:    S_OK if succeeded
//
//  History:    03/27/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT InitOutputFile(
    LPCWSTR lpFileName,         // Output file name to be created
    LPWSTR  lpSectionName,      // Buffer to store destination section name
    DWORD   cchSectionName      // Size of buffer in WCHAR
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    HANDLE  hFile;

    if (lpSectionName == NULL)
    {
        return E_INVALIDARG;
    }

    hFile = CreateFile(lpFileName,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbWritten;
        WCHAR wszSectionHeader[32];

        // Unicode BOM = 0xFEFF
        wszSectionHeader[0] = 0xFEFF;

        // Create a section name - [Strings.XXXX] where XXXX is locale ID in Hex
        hr = StringCchPrintf(wszSectionHeader + 1,
                             ARRAYSIZE(wszSectionHeader) - 1,
                             TEXT("[Strings.%.4x]\r\n"),
                             g_lcidTarget);
        if (SUCCEEDED(hr))
        {
            // Write Unicode BOM and String section header to output file
            bRet = WriteFile(hFile,
                             wszSectionHeader,
                             lstrlen(wszSectionHeader) * sizeof(WCHAR),
                             &cbWritten,
                             NULL);
            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        CloseHandle(hFile);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // If no error occurred, return target String section back to caller
    if (SUCCEEDED(hr))
    {
        hr = StringCchPrintf(lpSectionName,
                             cchSectionName,
                             TEXT("Strings.%.4x"),
                             g_lcidTarget);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   WriteToOutputFile
//
//  Synopsis:   Write Key and Value to output file
//
//  Returns:    S_OK if succeeded
//
//  History:    03/27/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT WriteToOutputFile(
    LPCWSTR lpFileName,         // Output file name
    LPCWSTR lpKey,              // Key name
    LPCWSTR lpValue             // Value name
)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    LPWSTR  lpQuoted;
    DWORD   cchQuoted;

    static WCHAR wszOutputLCIDSection[32];

    //
    // Create the target string section name in output file
    //
    if (wszOutputLCIDSection[0] == TEXT('\0'))
    {
        hr = StringCchPrintf(wszOutputLCIDSection,
                             ARRAYSIZE(wszOutputLCIDSection),
                             TEXT("Strings.%.4x"),
                             g_lcidTarget);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    //
    // Write the key and value to output file
    //
    cchQuoted = lstrlen(lpValue) + lstrlen(TEXT("\"\"")) + 1;
    lpQuoted = (LPWSTR) MEMALLOC(cchQuoted * sizeof(WCHAR));
    if (lpQuoted)
    {
        hr = StringCchPrintf(lpQuoted,
                             cchQuoted,
                             TEXT("\"%s\""),
                             lpValue);
        if (SUCCEEDED(hr))
        {
            bRet = WritePrivateProfileString(wszOutputLCIDSection,
                                            lpKey,
                                            lpQuoted,
                                            lpFileName);
            if (!bRet)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        MEMFREE(lpQuoted);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   ResolveValue
//
//  Synopsis:   Resolve the string value from various resource.
//              Following is the format in template file
//
//                  Key = INF, [Src], [INF File], [Section], [Key Name]
//                  Key = DLL, [Src], [DLL File], [Resource ID]
//                  Key = MSG, [Src], [DLL File], [Message ID]
//                  Key = STR, [String value]
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer.
//
//-----------------------------------------------------------------------------
HRESULT ResolveValue(
    PINFCONTEXT pInfContext,    // INF line context of template file
    LPWSTR      *lplpValue,     // Address of pointer to newly allocated Value buffer
    LPDWORD     lpcchValue      // Address of pionter to size of Value buffer in WCHAR
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    LPWSTR  lpToken[8];
    LONG    lTokenCount;
    DWORD   cchRequired;
    DWORD   cchBuffer;
    LPWSTR  lpBuffer;
    WCHAR   wszSourceFile[MAX_PATH];

    if (lplpValue == NULL || lpcchValue == NULL)
    {
        return E_INVALIDARG;
    }

    // Query the required size of buffer to store the data
    bRet = SetupGetMultiSzField(pInfContext, 1, NULL, 0, &cchRequired);
    if (!bRet)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Allocate the buffer to store a line from INF
    cchBuffer = cchRequired;
    lpBuffer = (LPWSTR) MEMALLOC(cchBuffer * sizeof(WCHAR));
    if (lpBuffer)
    {
        // Get the data from field 1 to the end of line to allocated buffer
        bRet = SetupGetMultiSzField(pInfContext, 1, lpBuffer, cchBuffer, &cchRequired);
        if (bRet)
        {
            lTokenCount = TokenizeMultiSzString(lpBuffer, cchBuffer, lpToken, 8);
            if (lTokenCount >= 0)
            {
                if (CompareEngString(lpToken[0], TEXT_INF) == CSTR_EQUAL)
                {
                    // INF, [Src], [INF File], [Section], [Key Name]
                    // [0]   [1]       [2]        [3]        [4]
                    if (lTokenCount == 5)
                    {
                        hr = ResolveSourceFile(lpToken[1],
                                               lpToken[2],
                                               wszSourceFile,
                                               ARRAYSIZE(wszSourceFile));
                        if (SUCCEEDED(hr))
                        {
                            hr = GetStringFromINF(wszSourceFile,   // Inf file name
                                                  lpToken[3],      // Section name in Inf
                                                  lpToken[4],      // Key name
                                                  lplpValue,
                                                  lpcchValue);
                        }
                    }
                    else
                    {
                        // Data format is invalid
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    }
                }
                else if (CompareEngString(lpToken[0], TEXT_DLL) == CSTR_EQUAL)
                {
                    // DLL, [Src], [DLL File], [Resource ID]
                    // [0]   [1]      [2]           [3]
                    if (lTokenCount == 4)
                    {
                        hr = ResolveSourceFile(lpToken[1],
                                               lpToken[2],
                                               wszSourceFile,
                                               ARRAYSIZE(wszSourceFile));
                        if (SUCCEEDED(hr))
                        {
                            hr = GetStringFromDLL(wszSourceFile,   // Dll file name
                                                  _wtoi(lpToken[3]),
                                                  lplpValue,
                                                  lpcchValue);
                        }
                    }
                    else
                    {
                        // Data format is invalid
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    }
                }
                else if (CompareEngString(lpToken[0], TEXT_MSG) == CSTR_EQUAL)
                {
                    // MSG, [Src], [DLL File], [Message ID]
                    // [0]   [1]      [2]           [3]
                    if (lTokenCount == 4)
                    {
                        hr = ResolveSourceFile(lpToken[1],
                                               lpToken[2],
                                               wszSourceFile,
                                               ARRAYSIZE(wszSourceFile));
                        if (SUCCEEDED(hr))
                        {
                            hr = GetStringFromMSG(wszSourceFile,   // File name
                                                  _wtoi(lpToken[3]),    // Message ID
                                                  g_lcidTarget,
                                                  lplpValue,
                                                  lpcchValue);
                        }
                    }
                    else
                    {
                        // Data format is invalid
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    }
                }
                else if (CompareEngString(lpToken[0], TEXT_STR) == CSTR_EQUAL)
                {
                    // STR, [String]
                    // [0]     [1]
                    if (lTokenCount == 2)
                    {
                        hr = GetStringFromSTR(lpToken[1], lplpValue, lpcchValue);
                    }
                    else
                    {
                        // Data format is invalid
                        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    }
                }
                else
                {
                    *lplpValue = NULL;
                    *lpcchValue = 0;
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                }
            }
        }

        MEMFREE(lpBuffer);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



HRESULT ResolveSourceFile(
    LPCWSTR lpSrcPathName,
    LPCWSTR lpSrcFileName,
    LPWSTR  lpFullOutputPath,
    DWORD   cchFullOutputPath
)
{
    HRESULT hr;
    WCHAR   wszCabPath[MAX_PATH];
    WCHAR   wszCab[MAX_PATH];
    WCHAR   wszFileInCab[MAX_PATH];
    WCHAR   wszExpandedCabPath[MAX_PATH];
    DWORD   dwErr;

    if (lpFullOutputPath == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Resolve source file name and directory
    //
    hr = GetPathFromSourcePathName(lpSrcPathName, wszCabPath, ARRAYSIZE(wszCabPath));
    if (SUCCEEDED(hr))
    {
        hr = GetCabFileName(lpSrcFileName,
                            wszCab,
                            ARRAYSIZE(wszCab),
                            wszFileInCab,
                            ARRAYSIZE(wszFileInCab));
        if (SUCCEEDED(hr))
        {
            dwErr = ExpandEnvironmentStrings(wszCabPath,
                                             wszExpandedCabPath,
                                             ARRAYSIZE(wszExpandedCabPath));
            if (dwErr > 0)
            {
                hr = CopyCompressedFile(wszCabPath,
                                        wszCab,
                                        wszFileInCab,
                                        lpFullOutputPath,
                                        cchFullOutputPath);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   GetStringFromINF
//
//  Synopsis:   Extract the string value from INF file
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer (HeapFree)
//
//-----------------------------------------------------------------------------
HRESULT GetStringFromINF(
    LPCWSTR lpInfFile,      // Full path name to Inf file
    LPCWSTR lpSection,      // Section name
    LPCWSTR lpKey,          // Key name
    LPWSTR  *lplpValue,     // Address of pointer to point to the allocated buffer
    LPDWORD lpcchValue      //
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    WCHAR   wszFullPath[MAX_PATH];
    HINF    hInf;
    DWORD   dwCharCount;

    if (lplpValue == NULL)
    {
        return E_INVALIDARG;
    }
    
    *lplpValue  = NULL;
    *lpcchValue = 0;

    hInf = SetupOpenInfFile(lpInfFile,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);
    if (hInf != INVALID_HANDLE_VALUE)
    {
        // Find out the size of buffer needed to store the string
        bRet = SetupGetLineText(NULL,
                                hInf,
                                lpSection,
                                lpKey,
                                NULL,           // No returned buffer
                                0,              // No returned buffer size
                                lpcchValue);   // Required size including null terminator
        if (bRet)
        {
            // Allocate memory to store the string
            *lplpValue = (LPWSTR) MEMALLOC(*lpcchValue * sizeof(WCHAR));
            if (*lplpValue != NULL)
            {
                //
                // Read the string from INF file
                //
                bRet = SetupGetLineText(NULL,
                                        hInf,
                                        lpSection,
                                        lpKey,
                                        *lplpValue,
                                        *lpcchValue,
                                        NULL);
                if (bRet)
                {
                    hr = S_OK;
                }
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
            }
        }

        SetupCloseInfFile(hInf);
    }

    // If something was wrong, clean up
    if (hr != S_OK)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        *lpcchValue = 0;
        if (*lplpValue != NULL)
        {
            MEMFREE(*lplpValue);
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetStringFromDLL
//
//  Synopsis:   Extract the string value from String resource in DLL
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT GetStringFromDLL(
    LPCWSTR lpDLLFile,      // Full path to Dll file
    UINT    uStrID,         // String ID
    LPWSTR  *lplpValue,    // Address of pointer to point to the allocated buffer
    LPDWORD lpcchValue     //
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    HMODULE hDLL;
    int     cchCopied;

    if (lplpValue == NULL || lpcchValue == NULL)
    {
        return E_INVALIDARG;
    }

    *lplpValue  = NULL;
    *lpcchValue = 0;

    // Load resource DLL
    hDLL = LoadLibraryEx(lpDLLFile, NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hDLL)
    {
        // Allocate memory to store the string
        // There is no function to calculate buffer size needed, maximum is 65535 (from MSDN)
        // Initially allocate 1024 WCHARs, Reallocate again if it's not big enough
        *lpcchValue = 1024;
        *lplpValue  = (LPWSTR) MEMALLOC(*lpcchValue * sizeof(WCHAR));
        if (*lplpValue != NULL)
        {
            //
            // Load the string from DLL
            //
            cchCopied = LoadString(hDLL, uStrID, *lplpValue, (int) *lpcchValue);
            if (cchCopied > 0)
            {
                hr = S_OK;

                while (cchCopied == (int) (*lpcchValue - 1))
                {
                    // Allocated buffer is too small, reallocate more
                    LPWSTR lpOldBuffer;

                    lpOldBuffer = *lplpValue;
                    *lpcchValue += 1024;

                    *lplpValue = MEMREALLOC(lpOldBuffer, *lpcchValue);
                    if (*lplpValue == NULL)
                    {
                        // Error reallocating more memory
                        *lplpValue = lpOldBuffer;
                        SetLastError(ERROR_OUTOFMEMORY);
                        hr = E_FAIL;
                        break;
                    }
                    else
                    {
                        hr = S_OK;
                    }

                    cchCopied = LoadString(hDLL, uStrID, *lplpValue, (int) *lpcchValue);
                }
            }
        }
        else
        {
            SetLastError(ERROR_OUTOFMEMORY);
        }

        FreeLibrary(hDLL);
    }

    // If something was wrong, clean up
    if (hr != S_OK)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        *lpcchValue = 0;
        if (*lplpValue != NULL)
        {
            MEMFREE(*lplpValue);
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetStringFromMSG
//
//  Synopsis:   Extract the string value from message table
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT GetStringFromMSG(
    LPCWSTR lpDLLFile,      // Full path to resource DLL
    DWORD   dwMsgID,        // Message ID
    DWORD   dwLangID,       // Language ID
    LPWSTR  *lplpValue,    // 
    LPDWORD lpcchValue     // 
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    WCHAR   wszFullPath[MAX_PATH];
    HMODULE hDLL;
    LPWSTR  lpTmpBuffer;
    int     nRet;

    if (lplpValue == NULL || lpcchValue == NULL)
    {
        return E_INVALIDARG;
    }

    *lplpValue = NULL;
    *lpcchValue = 0;

    // Load the resource DLL
    hDLL = LoadLibraryEx(lpDLLFile, NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (hDLL != NULL)
    {
        // Load the string from message table in DLL
        // FormatMessage will allocate buffer for the data using LocalAlloc()
        // need to free with LocalFree()
        bRet = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | 
                               FORMAT_MESSAGE_ALLOCATE_BUFFER |
                               FORMAT_MESSAGE_IGNORE_INSERTS |
                               FORMAT_MESSAGE_MAX_WIDTH_MASK,
                             hDLL,
                             dwMsgID,
                             dwLangID,
                             (LPWSTR) &lpTmpBuffer,
                             0,          // use 0 to query the required buffer size
                             NULL);
        if (bRet)
        {
            // Trim all unnecessary leading and trailing spaces
            RTrim(lpTmpBuffer);

            // Allocate the buffer for returned data
            *lpcchValue = lstrlen(lpTmpBuffer) + 1;
            *lplpValue  = (LPWSTR) MEMALLOC(*lpcchValue * sizeof(WCHAR));
            if (*lplpValue)
            {
                hr = StringCchCopy(*lplpValue, *lpcchValue, lpTmpBuffer);
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
            }

            LocalFree(lpTmpBuffer);
        }

        FreeLibrary(hDLL);
    }

    // If something was wrong, clean up
    if (hr != S_OK)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        *lpcchValue = 0;
        if (*lplpValue != NULL)
        {
            MEMFREE(*lplpValue);
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   GetStringFromSTR
//
//  Synopsis:   Copy the hardcoded string into the newly allocated buffer
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT GetStringFromSTR(
    LPCWSTR lpString,
    LPWSTR  *lplpValue,    // 
    LPDWORD lpcchValue     // 
)
{
    HRESULT hr = E_FAIL;

    if (lplpValue == NULL || lpcchValue == NULL)
    {
        return E_INVALIDARG;
    }

    // Allocate buffer and copy string to buffer
    *lpcchValue = lstrlen(lpString) + 1;
    *lplpValue = (LPWSTR) MEMALLOC(*lpcchValue * sizeof(WCHAR));
    if (*lplpValue)
    {
        hr = StringCchCopy(*lplpValue, *lpcchValue, lpString);
    }

    // If something was wrong, clean up
    if (hr != S_OK)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        *lpcchValue = 0;
        if (*lplpValue != NULL)
        {
            MEMFREE(*lplpValue);
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   SetPrivateEnvironmentVar
//
//  Synopsis:   Set private environment variables to use within our program
//
//  Returns:    TRUE if succeeded, FALSE otherwise
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL SetPrivateEnvironmentVar()
{
    HRESULT hr;
    BOOL    bRet;
    WCHAR   wszValue[MAX_PATH];

    //
    // Set LANGID_DEC to decimal value of the system default UI language
    //
    hr = StringCchPrintf(wszValue,
                         ARRAYSIZE(wszValue),
                         TEXT("%04d"),
                         g_lcidTarget);
    if (SUCCEEDED(hr))
    {
        bRet = SetEnvironmentVariable(TEXT("LANGID_DEC"), wszValue);
    }

    //
    // Set LANGID_HEX to hexadecimal value of the system default UI language
    //
    hr = StringCchPrintf(wszValue,
                         ARRAYSIZE(wszValue),
                         TEXT("%04x"),
                         g_lcidTarget);
    if (SUCCEEDED(hr))
    {
        bRet = SetEnvironmentVariable(TEXT("LANGID_HEX"), wszValue);
    }

    return bRet;
}



//-----------------------------------------------------------------------------
//
//  Function:   RemoveUnneededStrings
//
//  Synopsis:   Remove all unneeded sub strings from the value of
//              specified keys under [Remove] section
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT RemoveUnneededStrings(
    HINF    hTemplateFile   // Handle of template file
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    LONG    lLineCount;
    LONG    lLineIndex;

    lLineCount = SetupGetLineCount(hTemplateFile, TEXT("Remove"));
    for (lLineIndex = 0 ; lLineIndex < lLineCount ; lLineIndex++)
    {
        INFCONTEXT Context;

        bRet = SetupGetLineByIndex(hTemplateFile,
                                   TEXT("Remove"),
                                   lLineIndex,
                                   &Context);
        if (bRet)
        {
            WCHAR wszKey[64];
            WCHAR wszType[8];
            WCHAR wszValue[MAX_PATH];
            DWORD cchRequired;

            // Get type of unneeded string
            bRet = SetupGetStringField(&Context,
                                       0,
                                       wszKey,
                                       ARRAYSIZE(wszKey),
                                       &cchRequired) &&
                   SetupGetStringField(&Context,
                                       1,
                                       wszType,
                                       ARRAYSIZE(wszType),
                                       &cchRequired) &&
                   SetupGetStringField(&Context,
                                       2,
                                       wszValue,
                                       ARRAYSIZE(wszValue),
                                       &cchRequired);
            if (bRet)
            {
                if (CompareEngString(wszType, TEXT("STR")) == CSTR_EQUAL)
                {
                    // STR type
                    hr = RemoveUnneededString(wszKey, wszValue);
                }
                else if (CompareEngString(wszType, TEXT("EXP")) == CSTR_EQUAL)
                {
                    // EXP type
                    WCHAR wszUnneededString[MAX_PATH];

                    hr = GetExpString(wszUnneededString,
                                      ARRAYSIZE(wszUnneededString),
                                      wszValue);
                    if (SUCCEEDED(hr))
                    {
                        hr = RemoveUnneededString(wszKey, wszUnneededString);
                    }
                }
                else
                {
                    SetLastError(ERROR_INVALID_DATA);
                }
            }
        }
    }

    if (hr == E_FAIL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   RemoveUnneededString
//
//  Synopsis:   Remove an unneeded sub string from the value of specified key
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT RemoveUnneededString(
    LPCWSTR lpKey,              // Key name
    LPCWSTR lpUnneededString    // Unneeded sub string
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    WCHAR   wszOldValue[MAX_PATH];
    WCHAR   wszNewValue[MAX_PATH];
    DWORD   cchCopied;

    cchCopied = GetPrivateProfileString(g_wszTargetLCIDSection,
                                        lpKey,
                                        TEXT(""),
                                        wszOldValue,
                                        ARRAYSIZE(wszOldValue),
                                        g_wszOutputFile);
    if (cchCopied > 0)
    {
        if (StrStrI(wszOldValue, lpUnneededString))
        {
            // Unneeded string found
            hr = StringSubstitute(wszNewValue,
                                  ARRAYSIZE(wszNewValue),
                                  wszOldValue,
                                  lpUnneededString,
                                  TEXT(""));
            if (SUCCEEDED(hr))
            {
                WCHAR wszQuoted[MAX_PATH];

                hr = StringCchPrintf(wszQuoted,
                                     ARRAYSIZE(wszQuoted),
                                     TEXT("\"%s\""),
                                     wszNewValue);
                if (SUCCEEDED(hr))
                {
                    bRet = WritePrivateProfileString(g_wszTargetLCIDSection,
                                                     lpKey,
                                                     wszQuoted,
                                                     g_wszOutputFile);
                    if (bRet)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }
        else
        {
            // Unneeded string not found
            hr = S_FALSE;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   ExtractStrings
//
//  Synopsis:   Extract sub strings from the value of
//              specified keys under [Extract] section
//
//  Returns:    HRESULT
//
//  History:    08/01/2002 Geoffguo Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT ExtractStrings(
    HINF    hTemplateFile   // Handle of template file
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    LONG    lLineCount;
    LONG    lLineIndex;
    WCHAR   wszKey[64];
    WCHAR   wszValueName[64];
    WCHAR   wszMatch[64];
    WCHAR   wszLeftDelimitor[8];
    WCHAR   wszRightDelimitor[8];
    DWORD   cchRequired;

    lLineCount = SetupGetLineCount(hTemplateFile, TEXT("Extract"));
    for (lLineIndex = 0 ; lLineIndex < lLineCount ; lLineIndex++)
    {
        INFCONTEXT Context;

        bRet = SetupGetLineByIndex(hTemplateFile,
                                   TEXT("Extract"),
                                   lLineIndex,
                                   &Context);
        if (bRet)
        {
            // Get type of unneeded string
            bRet = SetupGetStringField(&Context,
                                       0,
                                       wszValueName,
                                       ARRAYSIZE(wszValueName),
                                       &cchRequired) &&
                   SetupGetStringField(&Context,
                                       1,
                                       wszKey,
                                       ARRAYSIZE(wszKey),
                                       &cchRequired) &&
                   SetupGetStringField(&Context,
                                       2,
                                       wszMatch,
                                       ARRAYSIZE(wszMatch),
                                       &cchRequired) &&
                   SetupGetStringField(&Context,
                                       3,
                                       wszLeftDelimitor,
                                       ARRAYSIZE(wszLeftDelimitor),
                                       &cchRequired) &&
                   SetupGetStringField(&Context,
                                       4,
                                       wszRightDelimitor,
                                       ARRAYSIZE(wszRightDelimitor),
                                       &cchRequired);
            hr = ExtractString(wszKey,
                               wszValueName,
                               wszMatch,
                               wszLeftDelimitor,
                               wszRightDelimitor);
        }
    }

    bRet = WritePrivateProfileString(g_wszTargetLCIDSection,
                                     wszKey,
                                     NULL,
                                     g_wszOutputFile);
    if (bRet)
        hr = S_OK;

    if (hr == E_FAIL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//-----------------------------------------------------------------------------
//
//  Function:   RemoveUnneededString
//
//  Synopsis:   Remove an unneeded sub string from the value of specified key
//
//  Returns:    HRESULT
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Caller need to free the allocated buffer
//
//-----------------------------------------------------------------------------
HRESULT ExtractString(
    LPCWSTR lpKey,              // Key name
    LPCWSTR lpValueName,
    LPCWSTR lpMatch,
    LPCWSTR lpLeftDelimitor,
    LPCWSTR lpRightDelimitor)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    LPWSTR  lpMatchedStr;
    WCHAR   wszOldValue[MAX_PATH*20];
    WCHAR   wszNewValue[MAX_PATH];
    DWORD   cchCopied;

    cchCopied = GetPrivateProfileString(g_wszTargetLCIDSection,
                                        lpKey,
                                        TEXT(""),
                                        wszOldValue,
                                        ARRAYSIZE(wszOldValue),
                                        g_wszOutputFile);
    if (cchCopied > 0)
    {
        if (lpMatchedStr = StrStrI(wszOldValue, lpMatch))
        {
            hr = ExtractSubString(wszNewValue,
                                  ARRAYSIZE(wszNewValue),
                                  lpMatchedStr,
                                  lpLeftDelimitor,
                                  lpRightDelimitor);
            if (SUCCEEDED(hr))
            {
                WCHAR wszQuoted[MAX_PATH];

                hr = StringCchPrintf(wszQuoted,
                                     ARRAYSIZE(wszQuoted),
                                     TEXT("\"%s\""),
                                     wszNewValue);
                if (SUCCEEDED(hr))
                {
                    bRet = WritePrivateProfileString(g_wszTargetLCIDSection,
                                                     lpValueName,
                                                     wszQuoted,
                                                     g_wszOutputFile);
                    if (bRet)
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
            }
        }
        else
        {
            // Unneeded string not found
            hr = S_FALSE;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT GetExpString(
    LPWSTR  lpUnneededString,       // Returned buffer
    DWORD   cchUnneededString,      // Size of buffer in WCHAR
    LPCWSTR lpString                // String with %Key%
)
{
    HRESULT hr = E_FAIL;
    LPCWSTR lpBegin;
    LPCWSTR lpEnd;

    if (lpUnneededString == NULL || lpString == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // Find the key name from Source string
    //
    lpBegin = StrChr(lpString, TEXT('%'));
    if (lpBegin)
    {
        // Begin of key name    
        lpBegin++;

        // End of key name
        lpEnd = StrChr(lpBegin, TEXT('%'));
        if (lpEnd)
        {
            DWORD cchLen;
            WCHAR wszKey[MAX_PATH];

            cchLen = (DWORD) (lpEnd - lpBegin);
            if (cchLen >= cchUnneededString)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
            else
            {
                // Got the key name, needs one more char for a '\0'
                if (lstrcpyn(wszKey, lpBegin, cchLen + 1))
                {
                    WCHAR wszOldSubStr[MAX_PATH];
                    WCHAR wszNewSubStr[MAX_PATH];
                    DWORD cchCopied;

                    // Get the value of key name from output file
                    cchCopied = GetPrivateProfileString(g_wszTargetLCIDSection,
                                                        wszKey,
                                                        TEXT(""),
                                                        wszNewSubStr,
                                                        ARRAYSIZE(wszNewSubStr),
                                                        g_wszOutputFile);
                    if (cchCopied > 0)
                    {
                        hr = StringCchPrintf(wszOldSubStr,
                                             ARRAYSIZE(wszOldSubStr),
                                             TEXT("%%%s%%"),
                                             wszKey);
                        if (SUCCEEDED(hr))
                        {
                            // Substitute %Key% with the new value
                            hr = StringSubstitute(lpUnneededString,
                                                  cchUnneededString,
                                                  lpString,
                                                  wszOldSubStr,
                                                  wszNewSubStr);
                        }
                    }
                }
            }
        }
    }

    if (hr == E_FAIL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\exe\utils2.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    utils2.c

Abstract:

    utillities to update lnk/msi/... file

Author:

    Xiaofeng Zang (xiaoz) 08-Oct-2001  Created

Revision History:

    <alias> <date> <comments>

--*/

#define NOT_USE_SAFE_STRING  
#include "clmt.h"
#include <objbase.h>
#include <shellapi.h>
#include <shlguid.h>
#include <comdef.h>
#include <iads.h>
#include <adsiid.h>
#include <adshlp.h>
#define STRSAFE_LIB
#include <strsafe.h>


class CServiceHandle
{
public :
    CServiceHandle() { _h = 0; }
    CServiceHandle( SC_HANDLE hSC ) : _h( hSC ) {}
    ~CServiceHandle() { Free(); }
    void Set( SC_HANDLE h ) { _h = h; }
    SC_HANDLE Get() { return _h; }
    BOOL IsNull() { return ( 0 == _h ); }
    void Free() { if ( 0 != _h ) CloseServiceHandle( _h ); _h = 0; }
private:
    SC_HANDLE _h;
};

//+-------------------------------------------------------------------------
//
//  Function:   IsServiceRunning
//
//  Synopsis:   Determines if a service is running
//
//  Arguments:  pwcServiceName -- The name (short or long) of the service
//
//  Returns:    TRUE if the service is running, FALSE otherwise or if the
//              system is low on resources or the status can't be queried.
//
//  History:    3/22/2002 geoffguo  Created
//
//--------------------------------------------------------------------------

BOOL IsServiceRunning(LPCTSTR pwcServiceName)
{
    CServiceHandle xhSC( OpenSCManager( 0, 0, SC_MANAGER_ALL_ACCESS ) );
    if ( xhSC.IsNull() )
        return FALSE;

    CServiceHandle xhService( OpenService( xhSC.Get(),
                                           pwcServiceName,
                                           SERVICE_QUERY_STATUS ) );
    if ( xhSC.IsNull() )
        return FALSE;

    SERVICE_STATUS svcStatus;
    if ( QueryServiceStatus( xhService.Get(), &svcStatus ) )
        return ( SERVICE_RUNNING == svcStatus.dwCurrentState );

    return FALSE;
}

HRESULT AddNeedUpdateLnkFile(
    LPTSTR              pszShortcutFile, 
    PREG_STRING_REPLACE lpStrList)
{
    HRESULT         hr;
    IShellLink      *psl = NULL;
    TCHAR           szGotPath [MAX_PATH];
    TCHAR           szNewPath [2*MAX_PATH];
    TCHAR           szArg[INFOTIPSIZE+1],szNewArg[2*INFOTIPSIZE+1];    
    WIN32_FIND_DATA wfd;
    IPersistFile    *ppf = NULL;
    int             nIcon;
    LPTSTR          lpszOneline = NULL;
    size_t          cchOneline = 0;
    TCHAR           szIndex[MAX_PATH];
    LPTSTR          lpszAppend = TEXT("");
    BOOL            bLnkUpdated = FALSE;
    BOOL            bTargetGot = FALSE;
    BOOL            bTargetUpdated = FALSE;
    DWORD           dwAttrib;
    LPTSTR          lpszStrWithExtraQuote;

    if (!pszShortcutFile || !pszShortcutFile[0] || !lpStrList)
    {
        hr = S_FALSE;
        DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  InValid Parameter(s)"));
        goto Cleanup;
    }

    //Allocate memory for "LnkFile,TargetPath,IconPath,Working Dir,Relative Path and Argument"
    cchOneline = lstrlen(pszShortcutFile) + 5 * MAX_PATH + INFOTIPSIZE+1;
    if (!(lpszOneline = (LPTSTR)malloc(cchOneline * sizeof(TCHAR))))
    {
        hr =  E_OUTOFMEMORY;
        goto Cleanup;
    }
    // Get a pointer to the IShellLink interface.    
    hr = CoCreateInstance (CLSID_ShellLink,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IShellLink,
                           (void **)&psl);

   if (FAILED (hr)) 
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  CoCreateInstance CLSID_ShellLink return %d (%#x)\n"), hr, hr);
       goto Cleanup;
   }
   // Get a pointer to the IPersistFile interface.
   hr = psl->QueryInterface (IID_IPersistFile, (void **)&ppf);
   if (FAILED(hr)) 
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  QueryInterface IID_IPersistFile return %d (%#x)\n"), hr, hr);
       goto Cleanup;
   }
   // Load the shortcut.
   hr = ppf->Load (pszShortcutFile, STGM_READWRITE );
   if (FAILED(hr))
   {
        hr = S_FALSE;
        DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  can not load shortcut file %s"),pszShortcutFile);
        goto Cleanup;
   }
   hr = StringCchPrintf(lpszOneline,cchOneline,TEXT("\"%s\""),pszShortcutFile);
   if (FAILED(hr))
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  buffer lpszOneline is too small for  %s"),pszShortcutFile);
       goto Cleanup;
   }
   // Get the path to the shortcut target.
   hr = psl->GetPath (szGotPath,
                      ARRAYSIZE(szGotPath),
                      (WIN32_FIND_DATA *)&wfd,
                      SLGP_RAWPATH);
   
   if (SUCCEEDED (hr)) 
   {    //Succeeded get the target
        DWORD dwNum ;
        DPF (INFinf,TEXT("AddNeedUpdateLnkFile:  GetPath %s OK "), szGotPath);
        //Set bTargetGot so that it cab be used to set relative target path
        bTargetGot = TRUE;

        //szGotPath contains LNK's target path, if dwNum >0 , it means szGotPath
        //contains (localized) path that we renamed
        dwNum = GetMaxMatchNum(szGotPath,lpStrList);

        //call ReplaceMultiMatchInString ,to replace szGotPath's localized folder
        //with english one, and put new path in szNewPath
        if (dwNum && ReplaceMultiMatchInString(szGotPath,szNewPath,ARRAYSIZE(szNewPath),dwNum,lpStrList, &dwAttrib, TRUE)) 
        {
            lpszAppend = szNewPath;
            bTargetUpdated = TRUE;
            bLnkUpdated = TRUE;
        }
   }
   else
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  GetPath %s Error = %d"), szGotPath,hr);
   }
   if (MyStrCmpI(lpszAppend,TEXT("")))
   {
       hr = AddExtraQuoteEtc(lpszAppend,&lpszStrWithExtraQuote); 
       if (SUCCEEDED(hr))
       {
           if (lpszStrWithExtraQuote)
            {
                lpszAppend = lpszStrWithExtraQuote;
            }
       }
   }
   else
   {
        lpszStrWithExtraQuote = NULL;
   }
   //Append the new quoted target path to lpszOneline
   hr = StringCchPrintf(lpszOneline,cchOneline,TEXT("%s,\"%s\""),lpszOneline,lpszAppend);
   FreePointer(lpszStrWithExtraQuote);
   //check StringCchPrintf here, because we want to free lpszStrWithExtraQuote before
   //we do a jump  (if necessary)
   if (FAILED(hr))
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  buffer lpszOneline is too small for  %s"),lpszAppend);
       goto Cleanup;
   }

   //if we arrive here , we have succeeded in appeneding target to the lszOneline
   //we will update relative target path ,which is relative to where the current
   //lnk resides
   lpszAppend = TEXT("");   
   if (bTargetGot) //this means we succeeded get the target path
   {
        DWORD dwNum ;
        //szNewLnkFilePath is  the lnk full path with localized folder renamed to english one(if any)
        TCHAR szNewLnkFilePath[2*MAX_PATH],szCurrTarget[2*MAX_PATH];
        TCHAR szExpandedCurrTarget[2*MAX_PATH];
        TCHAR szNewTarget[2*MAX_PATH];

        //Check to see whether current pszShortcutFile resides a direcory that contains
        //localized folder we renamed 
        dwNum = GetMaxMatchNum(pszShortcutFile,lpStrList);
        if (dwNum)
        {
            if (!ReplaceMultiMatchInString(pszShortcutFile,szNewLnkFilePath,
                                        ARRAYSIZE(szNewLnkFilePath),dwNum,lpStrList, &dwAttrib, TRUE))
            {
                //szNewLnkFilePath now is full path with localized folder renamed to english one
                //if we fail do ReplaceMultiMatchInString, just clone to szNewLnkFilePath
                hr = StringCchCopy(szNewLnkFilePath,ARRAYSIZE(szNewLnkFilePath),pszShortcutFile);
                if (FAILED(hr))
                {
                    DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  buffer szNewLnkFilePath is too small for  %s"),pszShortcutFile);
                    goto Cleanup;
                }
            }
        }
        else
        {
            //If pszShortcutFile does not contains any localized folder we renamed, 
            //just clone to szNewLnkFilePath
            hr = StringCchCopy(szNewLnkFilePath,ARRAYSIZE(szNewLnkFilePath),pszShortcutFile);
            if (FAILED(hr))
                {
                    DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  buffer szNewLnkFilePath is too small for  %s"),pszShortcutFile);
                    goto Cleanup;
                }
        }
        if (bTargetUpdated)
        {
            if (FAILED(hr = StringCchCopy(szCurrTarget,ARRAYSIZE(szCurrTarget),szNewPath)))
            {
                goto Cleanup;
            }
        }
        else
        {
            if (FAILED(hr = StringCchCopy(szCurrTarget,ARRAYSIZE(szCurrTarget),szGotPath)))
            {
                goto Cleanup;
            }
        }
        //target may contains enviroment variable
        if (!ExpandEnvironmentStrings(szCurrTarget,szExpandedCurrTarget,ARRAYSIZE(szExpandedCurrTarget)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Cleanup;
        }
        //Check whether target contains the folder we renamed
        dwNum = GetMaxMatchNum(szExpandedCurrTarget,lpStrList);
        if (dwNum)
        {
            if (!ReplaceMultiMatchInString(szExpandedCurrTarget,szNewTarget,ARRAYSIZE(szNewTarget),dwNum,lpStrList, &dwAttrib, TRUE))
            {            
                hr = StringCchCopy(szNewTarget,ARRAYSIZE(szNewTarget),szExpandedCurrTarget);
                if (FAILED(hr))
                {
                    DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  buffer szNewTarget is too small for  %s"),szExpandedCurrTarget);
                    goto Cleanup;
                }
            }
        }
        else
        {
            hr = StringCchCopy(szNewTarget,ARRAYSIZE(szNewTarget),szExpandedCurrTarget);
            if (FAILED(hr))
            {
                DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  buffer szNewTarget is too small for  %s"),szExpandedCurrTarget);
                goto Cleanup;
            }
        }
        if (PathRelativePathTo(szNewPath,szNewLnkFilePath,0,szNewTarget,0))
        {
                lpszAppend = szNewPath;
                bLnkUpdated = TRUE;
        }
   }
   if (MyStrCmpI(lpszAppend,TEXT("")))
   {
       hr = AddExtraQuoteEtc(lpszAppend,&lpszStrWithExtraQuote); 
       if (SUCCEEDED(hr))
       {
           if (lpszStrWithExtraQuote)
            {
                lpszAppend = lpszStrWithExtraQuote;
            }
       }       
   }
   else
   {
       lpszStrWithExtraQuote = NULL;
   }
   hr = StringCchPrintf(lpszOneline,cchOneline,TEXT("%s,\"%s\""),lpszOneline,lpszAppend);    
   FreePointer(lpszStrWithExtraQuote);
   if (FAILED(hr))
   {
       goto Cleanup;
   }

   lpszAppend = TEXT("");   
   hr = psl->GetIconLocation (szGotPath,ARRAYSIZE(szGotPath),&nIcon);
   if (SUCCEEDED (hr)) 
   {
        DWORD dwNum ;
        DPF (INFinf,TEXT("AddNeedUpdateLnkFile:  GetIconPath %s OK "), szGotPath);
        dwNum = GetMaxMatchNum(szGotPath,lpStrList);
        if (dwNum && ReplaceMultiMatchInString(szGotPath,szNewPath,ARRAYSIZE(szNewPath),dwNum,lpStrList, &dwAttrib, TRUE)) 
        {
            lpszAppend = szNewPath;
            bLnkUpdated = TRUE;
        }
   }
   else
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  GetIconPath %s Error = %d"), szGotPath,hr);
   }
   if (MyStrCmpI(lpszAppend,TEXT("")))
   {
       hr = AddExtraQuoteEtc(lpszAppend,&lpszStrWithExtraQuote); 
       if (SUCCEEDED(hr))
       {
           if (lpszStrWithExtraQuote)
            {
                lpszAppend = lpszStrWithExtraQuote;
            }
       }
   }   
   else
   {
        lpszStrWithExtraQuote = NULL;
   }
   hr = StringCchPrintf(lpszOneline,cchOneline,TEXT("%s,\"%s\""),lpszOneline,lpszAppend); 
   FreePointer(lpszStrWithExtraQuote);
   if (FAILED(hr))
   {
       goto Cleanup;
   }

   lpszAppend = TEXT("");   
   hr = psl->GetWorkingDirectory (szGotPath,ARRAYSIZE(szGotPath));
   if (SUCCEEDED (hr)) 
   {
        DWORD dwNum ;
        DPF (INFinf,TEXT("AddNeedUpdateLnkFile:  GetWorkingDirPath %s OK "), szGotPath);
        dwNum = GetMaxMatchNum(szGotPath,lpStrList);
        if (dwNum && ReplaceMultiMatchInString(szGotPath,szNewPath,ARRAYSIZE(szNewPath),dwNum,lpStrList, &dwAttrib, TRUE)) 
        {
            bLnkUpdated = TRUE;
            lpszAppend = szNewPath;
        }
   }
   else
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  GetWorkingDirPath %s Error = %d"), szGotPath,hr);
   }
   if (MyStrCmpI(lpszAppend,TEXT("")))
   {
       hr = AddExtraQuoteEtc(lpszAppend,&lpszStrWithExtraQuote); 
       if (SUCCEEDED(hr))
       {
           if (lpszStrWithExtraQuote)
            {
                lpszAppend = lpszStrWithExtraQuote;
            }
       }       
   }
   else
   {
        lpszStrWithExtraQuote = NULL;
   }
   hr = StringCchPrintf(lpszOneline,cchOneline,TEXT("%s,\"%s\""),lpszOneline,lpszAppend); 
   FreePointer(lpszStrWithExtraQuote);
   if (FAILED(hr))
   {
       goto Cleanup;
   }

   lpszAppend = TEXT("");   
   hr = psl->GetArguments (szArg,ARRAYSIZE(szArg));
   if (SUCCEEDED (hr)) 
   {
       DWORD dwNum ;
       DPF (INFinf,TEXT("AddNeedUpdateLnkFile:  GetArguments %s OK "), szArg);
        dwNum = GetMaxMatchNum(szArg,lpStrList);
        if (dwNum && ReplaceMultiMatchInString(szArg,szNewArg,ARRAYSIZE(szNewArg),dwNum,lpStrList, &dwAttrib, TRUE)) 
        {
            bLnkUpdated = TRUE;
            lpszAppend = szNewArg;
        }
   }
   else
   {
       DPF (INFwar,TEXT("AddNeedUpdateLnkFile:  GetArguments %s Error = %d"), pszShortcutFile,hr);
   }
   if (MyStrCmpI(lpszAppend,TEXT("")))
   {
       hr = AddExtraQuoteEtc(lpszAppend,&lpszStrWithExtraQuote); 
       if (SUCCEEDED(hr))
       {
           if (lpszStrWithExtraQuote)
            {
                lpszAppend = lpszStrWithExtraQuote;
            }
       }
   }
   else
   {
        lpszStrWithExtraQuote = NULL;
   }
   hr = StringCchPrintf(lpszOneline,cchOneline,TEXT("%s,\"%s\""),lpszOneline,lpszAppend); 
   FreePointer(lpszStrWithExtraQuote);
   if (FAILED(hr))
   {
       goto Cleanup;
   }

   if (bLnkUpdated)
   {
        g_dwKeyIndex++;
        _itot(g_dwKeyIndex,szIndex,16);
        if (!WritePrivateProfileString(TEXT("LNK"),szIndex,lpszOneline,g_szToDoINFFileName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            hr = S_OK;
        }
   }
   else
   {
         hr = S_OK;
   }
Cleanup:
    if (psl)
    {
        psl->Release ();
    }
    if (ppf)
    {
        ppf->Release ();
    }
    FreePointer(lpszOneline);
    return hr;
}


HRESULT BatchFixPathInLink(
    HINF                hInf,
    LPTSTR              lpszSection)
{
    HRESULT         hr;
    IShellLink      *psl = NULL;    
    WIN32_FIND_DATA wfd;
    IPersistFile    *ppf = NULL;
    int             nIcon;
    BOOL            bSucceedOnce = FALSE;
    UINT            LineCount,LineNo;
    INFCONTEXT      InfContext;
    LPTSTR          lpszLnkFile = NULL,lpszPath = NULL,lpszIcon = NULL,lpszWorkingDir = NULL,
                    lpszRelPath = NULL,lpszArg = NULL;
    DWORD           cchMaxLnkFile = 0,cchMaxPath = 0,cchMaxIcon = 0,cchMaxWorkingDir = 0,
                    cchMaxRelPath = 0,cchMaxArg = 0;  
    DWORD           dwFileAttrib;
    BOOL            bFileAttribChanged ;

    
    if ((hInf == INVALID_HANDLE_VALUE) || !lpszSection)
    {        
      hr = E_INVALIDARG;
      goto Cleanup;
    }
    LineCount = (UINT)SetupGetLineCount(hInf,lpszSection);
    if ((LONG)LineCount <= 0)
    {   
        hr = S_FALSE;
        DPF(INFwar ,TEXT("section name %s is empty  failed !"),lpszSection);
        goto Cleanup;
    }
    for(LineNo=0; LineNo<LineCount; LineNo++)
    {
        DWORD cchTmpLnkFile = 0,cchTmpPath = 0,cchTmpIcon = 0,cchTmpWorkingDir = 0,
              cchTmpRelPath = 0,cchTmpArg = 0;          
        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFerr ,TEXT("can not get line %n of section %s !"),LineNo, lpszSection);
            hr = E_FAIL;
            goto Cleanup;
        }
        if (!SetupGetStringField(&InfContext,1,NULL,0,&cchTmpLnkFile))
        {
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 1 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Cleanup;
        }
        if (!SetupGetStringField(&InfContext,2,NULL,0,&cchTmpPath))
        {
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 2 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Cleanup;
        }
        if (!SetupGetStringField(&InfContext,3,NULL,0,&cchTmpRelPath))
        {
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 3 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Cleanup;
        }

        if (!SetupGetStringField(&InfContext,4,NULL,0,&cchTmpIcon))
        {
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 4 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Cleanup;
        }
        if (!SetupGetStringField(&InfContext,5,NULL,0,&cchTmpWorkingDir))
        {
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 5 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Cleanup;
        }        
        if (!SetupGetStringField(&InfContext,6,NULL,0,&cchTmpArg))
        {
            DPF(INFerr ,TEXT("get [%s] 's line %d 's Field 6 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Cleanup;
        }        
        cchMaxLnkFile  = max(cchMaxLnkFile,cchTmpLnkFile);
        cchMaxPath = max(cchMaxPath,cchTmpPath);
        cchMaxIcon = max(cchMaxIcon,cchTmpIcon);
        cchMaxWorkingDir = max(cchMaxWorkingDir,cchTmpWorkingDir);
        cchMaxRelPath = max(cchMaxRelPath,cchTmpRelPath);
        cchMaxArg = max(cchMaxArg,cchTmpArg);
    }
    if (cchMaxLnkFile)
    {
        if (!(lpszLnkFile = (LPTSTR)malloc(++cchMaxLnkFile * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxPath)
    {
        if (!(lpszPath = (LPTSTR)malloc(++cchMaxPath * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxIcon)
    {
        if (!(lpszIcon = (LPTSTR)malloc(++cchMaxIcon * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxWorkingDir)
    {
        if (!(lpszWorkingDir = (LPTSTR)malloc(++cchMaxWorkingDir * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxRelPath)
    {
        if (!(lpszRelPath = (LPTSTR)malloc(++cchMaxRelPath * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }
    if (cchMaxArg)
    {
        if (!(lpszArg = (LPTSTR)malloc(++cchMaxArg * sizeof(TCHAR))))
        {
           hr = E_OUTOFMEMORY;
           goto Cleanup;
        }
    }

    hr = CoCreateInstance (CLSID_ShellLink,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IShellLink,
                           (void **)&psl);

   if (FAILED (hr)) 
   {
       psl = NULL;
       goto Cleanup;
   }
   // Get a pointer to the IPersistFile interface.
   hr = psl->QueryInterface (IID_IPersistFile, (void **)&ppf);
   if (FAILED(hr)) 
   {
       ppf = NULL;
       goto Cleanup;
   }

   for(LineNo=0; LineNo<LineCount; LineNo++)
    {     
        BOOL bSucceededOnce = FALSE;
        SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext);
        if (lpszLnkFile)
        {
            SetupGetStringField(&InfContext,1,lpszLnkFile,cchMaxLnkFile,NULL);
        }        
        if (lpszPath)
        {
            SetupGetStringField(&InfContext,2,lpszPath,cchMaxPath,NULL);
        }
        if (lpszRelPath)
        {
            SetupGetStringField(&InfContext,3,lpszRelPath,cchMaxRelPath,NULL);
        }
        if (lpszIcon)
        {
            SetupGetStringField(&InfContext,4,lpszIcon,cchMaxIcon,NULL);
        }        
        if (lpszWorkingDir)
        {
            SetupGetStringField(&InfContext,5,lpszWorkingDir,cchMaxWorkingDir,NULL);
        }
        if (lpszArg)
        {
            SetupGetStringField(&InfContext,6,lpszArg,cchMaxArg,NULL);
        }
        bFileAttribChanged = FALSE;
        dwFileAttrib = GetFileAttributes(lpszLnkFile);
        if (INVALID_FILE_ATTRIBUTES == dwFileAttrib)
        {
            //but put a waring log here
            continue;
        }

        if ( (dwFileAttrib & FILE_ATTRIBUTE_READONLY) 
             ||(dwFileAttrib & FILE_ATTRIBUTE_SYSTEM) )
        {
            if (!SetFileAttributes(lpszLnkFile,FILE_ATTRIBUTE_NORMAL))
            {
                //but put a waring log here
                continue;
            }
            bFileAttribChanged = TRUE;
        }
        hr = ppf->Load (lpszLnkFile, STGM_READWRITE );
        if (FAILED(hr))
        {
            //but put a waring log here
            continue;
        }
        if (lpszPath && lpszPath[0])
        {
            hr = psl->SetPath (lpszPath);
            if (SUCCEEDED(hr))
            {
                bSucceededOnce = TRUE;
            }
        }
        if (lpszRelPath && lpszRelPath[0])
        {
            hr = psl->SetRelativePath(lpszRelPath,0);
            if (SUCCEEDED(hr))
            {
                bSucceededOnce = TRUE;
            }
        }
        if (lpszIcon && lpszIcon[0])
        {
            TCHAR szGotPath[MAX_PATH];
            hr = psl->GetIconLocation (szGotPath,ARRAYSIZE(szGotPath),&nIcon);
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIconLocation (lpszIcon,nIcon);
                if (SUCCEEDED(hr))
                {
                    bSucceededOnce = TRUE;
                }
            }
        }
        if (lpszWorkingDir && lpszWorkingDir[0])
        {
            hr = psl->SetWorkingDirectory (lpszWorkingDir);
            if (SUCCEEDED(hr))
            {
                bSucceededOnce = TRUE;
            }
        }
        if (lpszArg && lpszArg[0])
        {
            hr = psl->SetArguments (lpszArg);
            if (SUCCEEDED(hr))
            {
                bSucceededOnce = TRUE;
            }
        }
        if (bSucceededOnce)
        {
            hr = ppf->Save (lpszLnkFile,TRUE);
            if (! SUCCEEDED (hr)) 
            {
                 DPF (dlError,TEXT("FixPathInLink:  Save %s Error = %d"), lpszLnkFile,hr);
            } 
            else 
            {
                 DPF (dlInfo,TEXT("FixPathInLink:  Save %s OK = %d"), lpszLnkFile,hr);
            }
        }
        if (bFileAttribChanged)
        {
            SetFileAttributes (lpszLnkFile, dwFileAttrib);
        }
    }
    hr = S_OK;
Cleanup:
    if (psl)
    {
        psl->Release ();
    }
    if (ppf)
    {
        ppf->Release ();
    }   
    FreePointer(lpszPath);
    FreePointer(lpszIcon);
    FreePointer(lpszRelPath);
    FreePointer(lpszWorkingDir);
    FreePointer(lpszArg);
    FreePointer(lpszLnkFile);
    return hr;
}


HRESULT RenameRDN(
    LPTSTR lpContainerPathWithLDAP,
    LPTSTR lpOldFQDNWithLDAP,
    LPTSTR lpNewRDNWithCN
)
{
    HRESULT hr;
    IADsContainer *pContainer = NULL;
    IDispatch     *pDispatch = NULL;
    BSTR bstrOldFQDNWithLDAP = SysAllocString(lpOldFQDNWithLDAP);
    BSTR bstrNewRDNWithCN = SysAllocString(lpNewRDNWithCN);

    if (!bstrOldFQDNWithLDAP || !bstrNewRDNWithCN )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    hr = ADsGetObject(lpContainerPathWithLDAP,
                      IID_IADsContainer,
                      (VOID **) &pContainer);
    if (SUCCEEDED(hr))
    {
        // Rename the RDN here
        hr = pContainer->MoveHere(bstrOldFQDNWithLDAP,
                                  bstrNewRDNWithCN,
                                  &pDispatch);
        if (SUCCEEDED(hr))
        {
            pDispatch->Release();
        }
            
        pContainer->Release();
    }

Cleanup:
    if (bstrOldFQDNWithLDAP)
    {
        SysFreeString(bstrOldFQDNWithLDAP);
    }
    if (bstrNewRDNWithCN)
    {
        SysFreeString(bstrNewRDNWithCN);
    }
    return hr;
}


// Pass in the interface ptr to the property value 
// will return a BSTR value of the data. 
// The IADsPropertyValue::get_ADsType()  is called to retrieve the  
// ADSTYPE valued enum  
// This enum is then used to determine which IADsPropertyValue method 
// to call to receive the actual data 

// CALLER assumes responsibility for freeing returned BSTR 
HRESULT    GetIADsPropertyValueAsBSTR(BSTR * pbsRet,IADsPropertyEntry *pAdsEntry, IADsPropertyValue * pAdsPV) 
{ 
    HRESULT hr = S_OK; 

    long lAdsType; 
    hr = pAdsPV->get_ADsType(&lAdsType); 
     
    if (FAILED(hr)) 
        return hr; 

    switch (lAdsType) 
    { 
        case ADSTYPE_INVALID : 
        { 
            *pbsRet = SysAllocString(L"<ADSTYPE_INVALID>"); 
        } 
        break; 

        case ADSTYPE_DN_STRING : 
        { 
            hr = pAdsPV->get_DNString(pbsRet); 
        } 
        break; 
        case ADSTYPE_CASE_EXACT_STRING : 
        { 
            hr = pAdsPV->get_CaseExactString(pbsRet); 
        } 
        break; 
        case ADSTYPE_CASE_IGNORE_STRING : 
        { 
            hr = pAdsPV->get_CaseIgnoreString(pbsRet); 
        } 
        break; 
        case ADSTYPE_PRINTABLE_STRING : 
        { 
            hr = pAdsPV->get_PrintableString(pbsRet); 
        } 
        break; 
        case ADSTYPE_NUMERIC_STRING : 
        { 
            hr = pAdsPV->get_NumericString(pbsRet); 
        } 
        break; 
        case ADSTYPE_BOOLEAN : 
        { 
            long b; 
            hr = pAdsPV->get_Boolean(&b); 
            if (SUCCEEDED(hr)) 
            { 
                if (b) 
                    *pbsRet = SysAllocString(L"<TRUE>"); 
                else 
                    *pbsRet = SysAllocString(L"<FALSE>"); 
            } 
        } 
        break; 
        case ADSTYPE_INTEGER : 
        { 
            long lInt; 
            hr = pAdsPV->get_Integer(&lInt); 
            if (SUCCEEDED(hr)) 
            { 
                WCHAR wOut[100]; 
                hr = StringCchPrintf(wOut,ARRAYSIZE(wOut),L"%d",lInt); 
                *pbsRet = SysAllocString(wOut); 
            } 
        } 
        break; 
        case ADSTYPE_OCTET_STRING : 
        { 
            *pbsRet = SysAllocString(L"<ADSTYPE_OCTET_STRING>"); 
            BSTR bsName= NULL; 
            VARIANT vOctet; 
            DWORD dwSLBound; 
            DWORD dwSUBound; 
            void HUGEP *pArray; 
            VariantInit(&vOctet); 
     
                //Get the name of the property to handle 
                //the properties we're interested in. 
                pAdsEntry->get_Name(&bsName); 
                hr = pAdsPV->get_OctetString(&vOctet); 
                 
                //Get a pointer to the bytes in the octet string. 
                if (SUCCEEDED(hr)) 
                { 
                    hr = SafeArrayGetLBound( V_ARRAY(&vOctet), 
                                              1, 
                                              (long FAR *) &dwSLBound ); 
                    hr = SafeArrayGetUBound( V_ARRAY(&vOctet), 
                                              1, 
                                              (long FAR *) &dwSUBound ); 
                    if (SUCCEEDED(hr)) 
                    { 
                        hr = SafeArrayAccessData( V_ARRAY(&vOctet), 
                                                  &pArray ); 
                        if (FAILED(hr)) 
                        {
                            break;
                        }
                    } 
                    else
                    {
                        break;
                    }
                    /* Since an Octet String has a specific meaning  
                       depending on the attribute name, handle two  
                       common ones here 
                    */ 
                    if (0==wcscmp(L"objectGUID", bsName)) 
                    { 
                        //LPOLESTR szDSGUID = new WCHAR [39]; 
                        WCHAR szDSGUID[39]; 

                        //Cast to LPGUID 
                        LPGUID pObjectGUID = (LPGUID)pArray; 
                        //Convert GUID to string. 
                        ::StringFromGUID2(*pObjectGUID, szDSGUID, 39);  
                        *pbsRet = SysAllocString(szDSGUID); 

                    } 
                    else if (0==wcscmp(L"objectSid", bsName)) 
                    { 
                        PSID pObjectSID = (PSID)pArray; 

                        //Convert SID to string. 
                        LPOLESTR szSID = NULL; 
                        ConvertSidToStringSid(pObjectSID, &szSID); 
                        *pbsRet = SysAllocString(szSID); 
                        LocalFree(szSID); 
                    } 
                    else 
                    { 
                        *pbsRet = SysAllocString(L"<Value of type Octet String. No Conversion>"); 

                    } 
                        SafeArrayUnaccessData( V_ARRAY(&vOctet) ); 
                        VariantClear(&vOctet); 
                } 

                SysFreeString(bsName); 
                 

        } 
        break; 
        case ADSTYPE_LARGE_INTEGER : 
        { 
            *pbsRet = SysAllocString(L"<ADSTYPE_LARGE_INTEGER>"); 
        } 
        break; 
        case ADSTYPE_PROV_SPECIFIC : 
        { 
            *pbsRet = SysAllocString(L"<ADSTYPE_PROV_SPECIFIC>"); 
        } 
        break; 
        case ADSTYPE_OBJECT_CLASS : 
        { 
            hr = pAdsPV->get_CaseIgnoreString(pbsRet); 
        } 
        break; 
        case ADSTYPE_PATH : 
        { 
            hr = pAdsPV->get_CaseIgnoreString(pbsRet); 
        } 
        break; 
        case ADSTYPE_NT_SECURITY_DESCRIPTOR : 
        { 
            *pbsRet = SysAllocString(L"<ADSTYPE_NT_SECURITY_DESCRIPTOR>"); 
        } 
        break; 
     
        default:  
            *pbsRet = SysAllocString(L"<UNRECOGNIZED>"); 
        break; 
             
    }     
    return hr; 
} 



HRESULT PropertyValueHelper( 
    LPTSTR lpObjPathWithLDAP,
    LPTSTR lpPropName,
    LPTSTR *lplpValue,
    LPTSTR lpNewValue)
{
    IADsPropertyList            *pList = NULL;
    IADsPropertyEntry           *pEntry = NULL;
    IADs                        *pObj = NULL;
    VARIANT                     var,varEnrty;
    long                        valType = ADSTYPE_PATH;
    HRESULT                     hr;
    BSTR                        bstrPropName = NULL;
    BSTR                        bstrNewValue = NULL;
 
    
 
    // bind to directory object
    hr = ADsGetObject(lpObjPathWithLDAP,
                      IID_IADsPropertyList,
                      (void**)&pList);
    if (S_OK != hr)
    {
        pList = NULL;
        goto exit;
    } 
    // initialize the property cache
    hr = pList->QueryInterface(IID_IADs,(void**)&pObj);
    if (S_OK != hr)
    {
        pObj = NULL;
        goto exit;
    } 
    pObj->GetInfo();    
 
    // get a property entry
    VariantInit(&varEnrty);
    bstrPropName = SysAllocString(lpPropName);
    if (!bstrPropName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    hr = pList->GetPropertyItem(bstrPropName, valType, &varEnrty);

    hr = V_DISPATCH(&varEnrty)->QueryInterface(IID_IADsPropertyEntry,
                                      (void**)&pEntry);
    if (S_OK != hr)
    {
        pEntry = NULL;
        goto exit;
    } 

    VariantInit(&var);
 
    hr = pEntry->get_Values(&var);
    if (S_OK != hr)
    {
        goto exit;
    } 
    LONG dwSLBound = 0; 
    LONG dwSUBound = 0; 
    LONG i; 

    hr = SafeArrayGetLBound(V_ARRAY(&var),1,(long FAR *)&dwSLBound); 
    if (S_OK != hr)
    {
        goto exit;
    } 
    hr = SafeArrayGetUBound(V_ARRAY(&var),1,(long FAR *)&dwSUBound); 
    if (S_OK != hr)
    {
        goto exit;
    } 
    if (dwSLBound || dwSLBound)
    {
        //we only interested in one enrty
        goto exit;
    }
    
    VARIANT v; 
    VariantInit(&v); 

    i = 0;
    hr = SafeArrayGetElement(V_ARRAY(&var),(long FAR *)&i,&v); 
    if (FAILED(hr)) 
    {
        goto exit;
    } 
    IDispatch * pDispEntry = V_DISPATCH(&v); 
    IADsPropertyValue * pAdsPV = NULL; 
                                 
    hr = pDispEntry->QueryInterface(IID_IADsPropertyValue,(void **) &pAdsPV); 

    if (SUCCEEDED(hr)) 
    {     
        BSTR bValue; 

        // Get the value as a BSTR 
        hr = GetIADsPropertyValueAsBSTR(&bValue,pEntry,pAdsPV);
        if (hr == S_OK)
        {
            if (lplpValue)
            {
                *lplpValue = (LPTSTR)malloc( (lstrlen(bValue)+1)*sizeof(TCHAR));
                if (!*lplpValue)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                hr = StringCchCopy(*lplpValue,lstrlen(bValue)+1,bValue);
            }
        }
        
    }

    if (lpNewValue)
    {
        bstrNewValue = SysAllocString(lpNewValue);
        if (!bstrNewValue)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        hr = pAdsPV->put_CaseIgnoreString(bstrNewValue);
    }
    i = 0;
    hr = SafeArrayPutElement(V_ARRAY(&var),&i,&v);
    if (hr != S_OK)
    {
        goto exit;
    }
    
    hr = pEntry->put_ControlCode(ADS_PROPERTY_UPDATE);
    
    hr = pEntry->put_Values(var);

    pList->PutPropertyItem(varEnrty);
    pObj->SetInfo();    
    hr = S_OK;

exit:;
    if (bstrPropName)
    {
        SysFreeString(bstrPropName);
    }
    if (bstrNewValue)
    {
        SysFreeString(bstrNewValue);
    }
    if (pEntry)
    {
        pEntry->Release();
    }
    if (pObj)
    {
        pObj->Release();
    }
    if (pList)
    {
        pList->Release();
    }
    
    return hr;
}

BOOL UpdateSecurityTemplatesSection (
    LPTSTR  lpINFFile,
    LPTSTR  lpNewInf,
    LPTSTR  lpszSection,
    PREG_STRING_REPLACE lpStrList)
{
    HRESULT   hr = S_OK;
    DWORD     cchInSection, CchBufSize, cchOutputSize, cchBufLen;
    DWORD     dwAttrib;
    BOOL      bUpdated = FALSE;
    LPTSTR    lpBuf = NULL;
    LPTSTR    lpNewBuf, lpOldBuf, lpLineBuf, lpEnd, lpOutputBuf, lpTemp;
    
    if (lpINFFile && lpszSection)
    {
        //
        // allocate max size of buffer
        //    
        CchBufSize = 0x7FFFF;
        do 
        {
            if (lpBuf)
            {
                MEMFREE(lpBuf);
                CchBufSize *= 2;
            }
            lpBuf = (LPTSTR) MEMALLOC(CchBufSize * sizeof(TCHAR));
            if (!lpBuf) 
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            cchInSection = GetPrivateProfileSection(lpszSection,
                                                   lpBuf,
                                                   CchBufSize,
                                                   lpINFFile);
        } while (cchInSection == CchBufSize -2);

        lpEnd = lpBuf;
        lpOutputBuf = NULL;
        cchOutputSize = 0;
        bUpdated = FALSE;
        while(lpEnd < (lpBuf + cchInSection))
        {
            dwAttrib = 0;
            lpNewBuf = ReplaceSingleString (
                                        lpEnd,
                                        REG_SZ,
                                        lpStrList,
                                        NULL,
                                        &dwAttrib,
                                        TRUE);
            if (!lpNewBuf)
            {
                lpNewBuf = ReplaceSingleString (
                                        lpEnd,
                                        REG_SZ,
                                        lpStrList,
                                        NULL,
                                        &dwAttrib,
                                        FALSE);
            }
            if (!lpNewBuf)
            {
                lpLineBuf = lpEnd;
            }
            else
            {
                bUpdated = TRUE;
                lpLineBuf = lpNewBuf;
                if (StrStrI(lpEnd, L"ProgramFiles") && StrStrI(lpNewBuf, L"Programs"))
                {
                    //Correct the wrong string replacement
                    //the difference between "Programs" and "Program Files" is " File"
                    CchBufSize = lstrlen(lpEnd)+6;
                    free(lpNewBuf);
                    lpNewBuf = (LPTSTR)calloc(CchBufSize, sizeof(TCHAR));
                    if (lpNewBuf)
                    {
                        lpTemp = StrStrI(lpEnd, L"=");
                        if (lpTemp)
                        {
                            *lpTemp = (TCHAR)'\0';
                            hr = StringCchCopy(lpNewBuf, CchBufSize, lpEnd);
                            *lpTemp = (TCHAR)'=';
                            hr = StringCchCat(lpNewBuf, CchBufSize, L"= Program Files");
                            lpLineBuf = lpNewBuf;
                            if (hr != S_OK)
                                DPF(REGerr, L"UpdateSecurityTemplatesSection: StringCchCat failed.");
                        }
                        else
                        {
                            free(lpNewBuf);
                            lpLineBuf = lpEnd;
                            lpNewBuf = NULL;
                            bUpdated = FALSE;
                        }   
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                }
            }

            cchBufLen = lstrlen(lpLineBuf);

            lpOldBuf = NULL;
            if (lpOutputBuf)
            {
                lpOldBuf = lpOutputBuf;
                lpOutputBuf = (LPTSTR)MEMREALLOC(lpOldBuf, (cchOutputSize+cchBufLen+2)*sizeof(TCHAR));
            }
            else
            {
                lpOutputBuf = (LPTSTR)MEMALLOC((cchBufLen+2)*sizeof(TCHAR));
                cchOutputSize = 0;
            }
            if (lpOutputBuf == NULL)
            {
                if (lpOldBuf)
                    MEMFREE(lpOldBuf);
                if (lpBuf)
                    MEMFREE(lpBuf);
                if (lpNewBuf)
                    free(lpNewBuf);
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
                
            hr = StringCchCopy(&lpOutputBuf[cchOutputSize], cchBufLen+1, lpLineBuf);
            if (hr != S_OK)
                DPF(REGerr, L"UpdateSecurityTemplatesSection3: failed.");

            cchOutputSize += cchBufLen+1;
            lpEnd += lstrlen(lpEnd)+1;
            if (lpNewBuf)
                free(lpNewBuf);
        }
        if (lpOutputBuf)
            lpOutputBuf[cchOutputSize] = (TCHAR)'\0';

        //Workarround since the function cannot delete the section: Delete the section
        WritePrivateProfileSection (lpszSection, NULL, lpNewInf);
        if (!WritePrivateProfileSection (lpszSection, lpOutputBuf, lpNewInf))
        {
            DPF(INFerr, L"UpdateSecurityTemplatesSection: the section %s in file %s Update failed", lpszSection, lpNewInf);
        }
        if (lpOutputBuf)
            MEMFREE(lpOutputBuf);
        if (lpBuf)
            MEMFREE(lpBuf);
    }
Exit:
    return bUpdated;
}

HRESULT UpdateSecurityTemplates(
    LPTSTR              lpINFFile, 
    PREG_STRING_REPLACE lpStrList)
{
    HRESULT hr = E_FAIL;
    DWORD   cchRead;
    DWORD   cchBuf = 1024;
    LPTSTR  lpBuf, lpOldBuf;
    LPTSTR  lpSection;
    BOOL    bUpdate;
    TCHAR   szIndex[16];
    TCHAR   szNewInf[MAX_PATH];

    DPF(REGmsg, L"Enter UpdateSecurityTemplates: %s", lpINFFile);

    lpBuf = (LPTSTR)MEMALLOC(cchBuf * sizeof(TCHAR));
    if (lpBuf == NULL)
    {
        return E_OUTOFMEMORY;
    }
    cchRead = GetPrivateProfileSectionNames(lpBuf,
                                            cchBuf,
                                            lpINFFile);
    while (cchRead == (cchBuf - 2))
    {
        // Buffer is too small, reallocate until we have enough
        lpOldBuf = lpBuf;
        cchBuf += 1024;

        lpBuf = (LPTSTR)MEMREALLOC(lpOldBuf, cchBuf * sizeof(TCHAR));
        if (lpBuf == NULL)
        {
            MEMFREE(lpOldBuf);
            return E_OUTOFMEMORY;
        }

        // Read the data from section again
        cchRead = GetPrivateProfileSectionNames(lpBuf,
                                                cchBuf,
                                                lpINFFile);
    }

    // At this point we have big enough buffer and data in it
    if (cchRead > 0)
    {
        hr = StringCchPrintf(szNewInf, MAX_PATH, TEXT("%s.clmt"), lpINFFile);
        CopyFile(lpINFFile, szNewInf, FALSE);
        lpSection = (LPTSTR)MultiSzTok(lpBuf);
        bUpdate = FALSE;
        while (lpSection != NULL)
        {
            if (UpdateSecurityTemplatesSection(lpINFFile, szNewInf, lpSection, lpStrList))
            {
                bUpdate = TRUE;
                DPF(INFmsg, L"UpdateSecurityTemplatesSection: the section %s in file %s Updated", lpSection, lpINFFile);
            }

            // Get next section name
            lpSection = (LPTSTR)MultiSzTok(NULL);
        }
        if (bUpdate)
        {
            g_dwKeyIndex++;
            _itot(g_dwKeyIndex,szIndex,16);
            if (!WritePrivateProfileString(TEXT("INF Update"),szIndex,szNewInf,g_szToDoINFFileName))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    else
    {
        SetLastError(ERROR_NOT_FOUND);
    }

    MEMFREE(lpBuf);
    DPF(REGmsg, L"Exit UpdateSecurityTemplates:");
    return hr;
}

HRESULT BatchINFUpdate(HINF hInf)
{
    HRESULT         hr = S_OK;
    UINT            LineCount,LineNo;
    DWORD           dwRequired;
    INFCONTEXT      InfContext;
    LPTSTR          lpTemp;
    LPTSTR          lpszSection = TEXT("INF Update");
    TCHAR           chTemp;
    TCHAR           szFileNameIn[MAX_PATH];
    TCHAR           szFileNameOut[MAX_PATH];

    DPF(INFmsg ,TEXT("Enter BatchINFUpdate:"));
    if ((hInf == INVALID_HANDLE_VALUE))
    {        
      hr = E_INVALIDARG;
      goto Exit;
    }
    LineCount = (UINT)SetupGetLineCount(hInf,lpszSection);
    if ((LONG)LineCount <= 0)
    {   
        hr = S_FALSE;
        DPF(INFwar ,TEXT("BatchINFUpdate: failed. Section %s is empty!"),lpszSection);
        goto Exit;
    }
    for(LineNo=0; LineNo<LineCount; LineNo++)
    {
        if (!SetupGetLineByIndex(hInf,lpszSection,LineNo,&InfContext))
        {
            DPF(INFerr ,TEXT("BatchINFUpdate: can not get line %n of section %s !"),LineNo, lpszSection);
            hr = E_FAIL;
            goto Exit;
        }
        if (!SetupGetStringField(&InfContext,1,szFileNameIn,MAX_PATH,&dwRequired))
        {
            DPF(INFerr ,TEXT("BatchINFUpdate: get [%s] 's line %d 's Field 1 failed  !"),lpszSection, LineNo);
            hr = E_FAIL;
            goto Exit;
        }
        lpTemp = StrStrI(szFileNameIn, TEXT(".clmt"));
        if (lpTemp)
        {
            *lpTemp = (TCHAR)'\0';
            hr = StringCchPrintf(szFileNameOut, MAX_PATH, TEXT("%s.bak"), szFileNameIn);
            MoveFile(szFileNameIn, szFileNameOut);
            hr = StringCchCopy(szFileNameOut, MAX_PATH, szFileNameIn);
            *lpTemp = (TCHAR)'.';
            MoveFile(szFileNameIn, szFileNameOut);
            DPF(INFinf ,TEXT("BatchINFUpdate: %s is updated and backup file is %s.bak"), szFileNameOut, szFileNameOut);
        }
    }
    
Exit:
    DPF(INFmsg ,TEXT("Exit BatchINFUpdate: hr = %d"), hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\tools\tokgen\common.h ===
/****************************** Module Header ******************************\
* Module Name: common.h
*
* Copyright (c) 1985 - 2002, Microsoft Corporation
*
* Cross Language Migration Tool, Token Generator header file
*
\***************************************************************************/

#ifndef __COMMON_H__
#define __COMMON_H__

#include <windows.h>
#include <winreg.h>
#include <setupapi.h>
#include <stdio.h>
#include <strsafe.h>


#define MAX_SRC_PATH                16
#define MAX_KEYS                    1024
#define MAX_CHAR                    512

#define LSTR_EQUAL                  0

#define TEXT_STRING_SECTION         TEXT("Strings")
#define TEXT_INF                    TEXT("INF")
#define TEXT_DLL                    TEXT("DLL")
#define TEXT_MSG                    TEXT("MSG")
#define TEXT_STR                    TEXT("STR")

#define TEXT_DEFAULT_TEMPLATE_FILE  TEXT("CLMTOK.TXT")
#define TEXT_DEFAULT_OUTPUT_FILE    TEXT("CLMTOK.OUT")

#define TEXT_TOKGEN_TEMP_PATH_NAME  TEXT("CLMTOK")

#define ARRAYSIZE(s)                (sizeof(s) / sizeof(s[0]))

// Macros for heap memory management
#define MEMALLOC(cb)        HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)
#define MEMFREE(pv)         HeapFree(GetProcessHeap(), 0, pv);
#define MEMREALLOC(pv, cb)  HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pv, cb)

// Structure to keep source paths
typedef struct _SRC_PATH
{
    WCHAR wszSrcName[32];           // Name of source path
    WCHAR wszPath[MAX_PATH];        // Path
} SRC_PATH, *PSRC_PATH;

typedef struct _STRING_TO_DATA {
    TCHAR String[50];
    HKEY  Data;
} STRING_TO_DATA, *PSTRING_TO_DATA;

typedef struct _STRING_TO_HKEY
{
    TCHAR String[50];                       // HKEY name string
    HKEY  hKey;                             // HKEY value associated to the name
} STRING_TO_HKEY, *PSTRING_TO_HKEY;


//
// Global variables
//
WCHAR g_wszTemplateFile[MAX_PATH];      // Template file name
WCHAR g_wszOutputFile[MAX_PATH];        // Output file name
WCHAR g_wszTempFolder[MAX_PATH];        // Temp folder used in our program
WCHAR g_wszTargetLCIDSection[32];       // String section name with lcid - Strings.XXXX
LCID  g_lcidTarget;                     // LCID of token file to be generated
BOOL  g_bUseDefaultTemplate;            // Use default template file
BOOL  g_bUseDefaultOuputFile;           // Use default output file

SRC_PATH g_SrcPath[MAX_SRC_PATH];
DWORD    g_dwSrcCount;


//
// Function Prototypes
//
// Engine.c
HRESULT GenerateTokenFile(VOID);
HRESULT ReadSourcePathData(HINF);
HRESULT ResolveStringsSection(HINF, LPCWSTR);
HRESULT ResolveLine(PINFCONTEXT, LPWSTR*, LPDWORD, LPWSTR*, LPDWORD);
HRESULT InitOutputFile(LPCWSTR, LPWSTR, DWORD);
HRESULT WriteToOutputFile(LPCWSTR, LPCWSTR, LPCWSTR);
HRESULT ResolveValue(PINFCONTEXT, LPWSTR*, LPDWORD);
HRESULT ResolveSourceFile(LPCWSTR, LPCWSTR, LPWSTR, DWORD);
HRESULT GetStringFromINF(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR*, LPDWORD);
HRESULT GetStringFromDLL(LPCWSTR, UINT, LPWSTR*, LPDWORD);
HRESULT GetStringFromMSG(LPCWSTR, DWORD, DWORD, LPWSTR*, LPDWORD);
HRESULT GetStringFromSTR(LPCWSTR, LPWSTR*, LPDWORD);
BOOL SetPrivateEnvironmentVar();
HRESULT RemoveUnneededStrings(HINF);
HRESULT GetExpString(LPWSTR, DWORD, LPCWSTR);
HRESULT RemoveUnneededString(LPCWSTR, LPCWSTR);
HRESULT ExtractStrings(HINF);
HRESULT ExtractString(LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR);

// From Utils.c
LONG TokenizeMultiSzString(LPCWSTR, DWORD, LPCWSTR[], DWORD);
LONG ExtractTokenString(LPWSTR, LPWSTR[], LPCWSTR, DWORD);
HRESULT ConcatFilePath(LPCWSTR, LPCWSTR, LPWSTR, DWORD);
HRESULT CopyCompressedFile(LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, DWORD);
HRESULT LaunchProgram(LPWSTR, LPWSTR);
HRESULT GetPathFromSourcePathName(LPCWSTR, LPWSTR, DWORD);
HRESULT GetCabFileName(LPCWSTR, LPWSTR, DWORD, LPWSTR, DWORD);
HRESULT GetCabTempDirectory(LPCWSTR);
HRESULT CreateTempDirectory(LPWSTR, DWORD);
void LTrim(LPWSTR);
void RTrim(LPWSTR);
BOOL Str2KeyPath(LPCWSTR, PHKEY, LPCWSTR*);
HRESULT StringSubstitute(LPWSTR, DWORD, LPCWSTR, LPCWSTR, LPCWSTR);
int CompareEngString(LPCTSTR, LPCTSTR);
HRESULT ExtractSubString(LPWSTR, DWORD, LPCWSTR, LPCWSTR, LPCWSTR);         // Right delimitor

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\tools\tokgen\main.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    engine.c

Abstract:

    Token Generator for Cross Language Migration Tool

Author:

    Rerkboon Suwanasuk   01-May-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#include "common.h"
#include <stdio.h>
#include <stdlib.h>
#include <shellapi.h>
#include <locale.h>


BOOL ProcessCommandLine()
{
    LPWSTR  *plpwszArgv;
    LPWSTR  *argv;
    LPWSTR  lpFilePart;
    DWORD   dwErr;
    INT     nArgc;
    BOOL    bRet = TRUE;
    HRESULT hr;

    plpwszArgv = CommandLineToArgvW(GetCommandLine(), &nArgc);
    argv = plpwszArgv;

    g_bUseDefaultTemplate = TRUE;
    g_bUseDefaultOuputFile = TRUE;

    while (--nArgc > 0 && ++argv)
    {
        if (argv[0][0] != TEXT('-'))
            continue;

        if (CompareEngString(&argv[0][1], TEXT("LCID")) == CSTR_EQUAL)
        {
            //
            // This is "-LCID [lcid]" parameters (required)
            //
            LPWSTR lpStop;

            nArgc--;
            if (nArgc == 0)
            {
                return FALSE;
            }

            argv++;

            g_lcidTarget = wcstol(argv[0], &lpStop, 0);
        }
        else if (CompareEngString(&argv[0][1], TEXT("i")) == CSTR_EQUAL)
        {
            //
            // This is "-i [TemplateFile]" parameters (optional)
            // Default will use "clmres.txt"
            //
            nArgc--;
            if (nArgc == 0)
            {
                return FALSE;
            }

            argv++;
            
            g_bUseDefaultTemplate = FALSE;

            if (!GetFullPathName(argv[0],
                                 ARRAYSIZE(g_wszTemplateFile),
                                 g_wszTemplateFile,
                                 &lpFilePart))
            {
                return FALSE;
            }

            g_bUseDefaultTemplate = FALSE;
        }
        else if (CompareEngString(&argv[0][1], TEXT("o")) == CSTR_EQUAL)
        {
            //
            // This is "-o [OutputFile]" parameters (optional)
            // Default
            //
            nArgc--;
            if (nArgc == 0)
            {
                return FALSE;
            }

            argv++;

            if (!GetFullPathName(argv[0],
                                 ARRAYSIZE(g_wszOutputFile),
                                 g_wszOutputFile,
                                 &lpFilePart))
            {
                return FALSE;
            }

            g_bUseDefaultOuputFile = FALSE;
        }
        else
        {
            return FALSE;
        }
    }

    GlobalFree(plpwszArgv);

    if (!IsValidLocale(g_lcidTarget, LCID_SUPPORTED))
    {
        wprintf(TEXT("Error! Invalid locale ID - 0x%X\n"), g_lcidTarget);
        return FALSE;
    }

    if (g_bUseDefaultTemplate)
    {
        dwErr = GetFullPathName(TEXT_DEFAULT_TEMPLATE_FILE,
                                ARRAYSIZE(g_wszTemplateFile),
                                g_wszTemplateFile,
                                &lpFilePart);
        if (dwErr == 0)
        {
            bRet = FALSE;
        }
    }

    if (g_bUseDefaultOuputFile)
    {
        dwErr = GetFullPathName(TEXT_DEFAULT_OUTPUT_FILE,
                                ARRAYSIZE(g_wszOutputFile),
                                g_wszOutputFile,
                                &lpFilePart);
        if (dwErr == 0)
        {
            bRet = FALSE;
        }
    }

    return bRet;
}


VOID PrintUsage(VOID)
{
    DWORD i;

    LPCWSTR lpUsage[] = {
        TEXT("Usage:\n"),
        TEXT("  CLMTOK -lcid LocaleID [-i TemplateFile] [-o OutputFile]\n"),
        NULL
    };

    for (i = 0 ; lpUsage[i] != NULL ; i++)
    {
        wprintf(TEXT("%s"), lpUsage[i]);
    }
}


HRESULT InitGlobalVariables()
{
    HRESULT hr;

    hr = CreateTempDirectory(g_wszTempFolder, ARRAYSIZE(g_wszTempFolder));
    if (FAILED(hr))
    {
        return hr;
    }

    hr = StringCchPrintf(g_wszTargetLCIDSection,
                         ARRAYSIZE(g_wszTargetLCIDSection),
                         TEXT("Strings.%.4X"),
                         g_lcidTarget);

    return hr;
}



int __cdecl wmain()
{
    HRESULT hr;
    HMODULE hDLL;

    // Set the locale to default
    _wsetlocale(LC_ALL, TEXT(""));

    // Verify the command line
    if (!ProcessCommandLine())
    {
        PrintUsage();
        return -1;
    }

    hr = InitGlobalVariables();
    if (FAILED(hr))
    {
        return hr;
    }

    hr = GenerateTokenFile();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\component.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    Component.h
//
//  Abstract:
//
//    This file contains the Component object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _COMPONENT_H_
#define _COMPONENT_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class Component
{
public:
    Component(LPSTR name, LPSTR folderName, LPSTR infName, LPSTR sectionName)
    {
        HRESULT hr;
        BOOL bSuccess = TRUE;
        
        hr = StringCchCopyA(m_Name, ARRAYLEN(m_Name), name);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }

        hr = StringCchCopyA(m_FolderName, ARRAYLEN(m_FolderName), folderName);
       if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }

        hr = StringCchCopyA(m_InfName, ARRAYLEN(m_InfName), infName);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }

        hr = StringCchCopyA(m_InfInstallSectionName, ARRAYLEN(m_InfInstallSectionName), sectionName);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }
        
        m_Next = NULL;
        m_Previous = NULL;
        if(!bSuccess )
            printf("Error in Component::Component() \n");
    
    };

    LPSTR getName() { return (m_Name);};
    LPSTR getFolderName() { return (m_FolderName); };
    LPSTR getInfName() { return (m_InfName); };
    LPSTR getInfInstallSectionName() { return (m_InfInstallSectionName); };
    Component* getNext() { return (m_Next); };
    Component* getPrevious() { return (m_Previous); };
    void setNext(Component *next) { m_Next = next; };
    void setPrevious(Component *previous) { m_Previous = previous; };

private:
    CHAR m_Name[MAX_PATH];
    CHAR m_FolderName[MAX_PATH];
    CHAR m_InfName[MAX_PATH];
    CHAR m_InfInstallSectionName[MAX_PATH];
    Component *m_Next;
    Component *m_Previous;
};

#endif //_COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\clmt\tools\tokgen\utils.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    engine.c

Abstract:

    Token Generator for Cross Language Migration Tool

Author:

    Rerkboon Suwanasuk   01-May-2002  Created

Revision History:

    <alias> <date> <comments>

--*/

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <Shlwapi.h>
#include "common.h"


//-----------------------------------------------------------------------------
//
//  Function:   TokenizeMultiSzString
//
//  Synopsis:   Extract array of strings in buffer. Each pointer in array of
//              pointers will point to each string in buffer.
//              Strings in buffer are separated by a single '\0'
//              End of strings array is indicated by two consecutive "\0\0"
//
//  Returns:    Number of strings in the buffer
//              0 if no strings in the buffer
//              -1 if error occurs
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none.
//
//-----------------------------------------------------------------------------
LONG TokenizeMultiSzString(
    LPCWSTR lpBuffer,       // MultiSZ string buffer
    DWORD   cchBuffer,      // Size of buffer (in WCHAR)
    LPCWSTR lpToken[],      // Array of pointer that will point to each SZ
    DWORD   dwArrSize       // Maximum array size
)
{
    DWORD dwTokenIndex;
    DWORD i;

    if (lpBuffer == NULL || lpToken == NULL)
    {
        // Invalid parameters
        return -1;
    }

    if (*lpBuffer == TEXT('\0') && *(lpBuffer + 1) == TEXT('\0'))
    {
        // No SZ in buffer
        return 0;
    }

    dwTokenIndex = 0;
    lpToken[dwTokenIndex] = lpBuffer;

    for (i = 0 ; i < cchBuffer ; i++)
    {
        if (*(lpBuffer + i) == TEXT('\0'))
        {
            // Reach the end of current string, check the next character in buffer
            i++;
            if (*(lpBuffer + i) == TEXT('\0'))
            {
                // Two consecutive '\0', it is the end of MultiSz string
                // return the number of SZ string in buffer
                return (dwTokenIndex + 1);
            }
            else
            {
                // Beginning of next string, assign the pointer to next string
                dwTokenIndex++;

                if (dwTokenIndex < dwArrSize)
                {
                    // Enough pointer in array to use
                    lpToken[dwTokenIndex] = lpBuffer + i;
                }
                else
                {
                    // Array of pointer is too small to extract strings from buffer
                    return -1;
                }
            }
        }
    }

    // Buffer is not null terminated correctly if we reach here
    return -1;
}



//-----------------------------------------------------------------------------
//
//  Function:   ExtractTokenString
//
//  Synopsis:   Tokenize the string using caller-supplied separators.
//              Each pointer in pointer array will point to the token in source
//              string, each token is null terminated.
//
//  Returns:    Number of token after tokenized
//              -1 if error occurs
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      Source string will be modified, caller need to make sure
//              that original source string is backed up.
//
//-----------------------------------------------------------------------------
LONG ExtractTokenString(
    LPWSTR  lpString,       // Source string to be tokenized
    LPWSTR  lpToken[],      // Array of pointers to token
    LPCWSTR lpSep,          // List of separator characters
    DWORD   nArrSize        // Size of token array
)
{
    DWORD nTokIndex = 0;
    LPWSTR lpTmpToken;

    if (NULL == lpString || NULL == lpToken || NULL == lpSep)
    {
        // Invalid parameters
        return -1;
    }

    // Get first token
    lpTmpToken = wcstok(lpString, lpSep);

    // Loop until no more token left in the string
    while (NULL != lpTmpToken)
    {
        if (nTokIndex < nArrSize)
        {
            // Enough pointer in array to use, so get next token
            lpToken[nTokIndex] = lpTmpToken;
            nTokIndex++;

            lpTmpToken = wcstok(NULL, lpSep);
        }
        else
        {
            // Array size is too small to handle all the tokens
            return -1;
        }
    }
    
    // nTokIndex hold the number of token at this point
    return nTokIndex;
}



//-----------------------------------------------------------------------------
//
//  Function:   ConcatFilePath
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT ConcatFilePath(
    LPCWSTR lpPath,
    LPCWSTR lpFile,
    LPWSTR  lpFilePath,
    DWORD   cchFilePath
)
{
    HRESULT hr = E_FAIL;
    DWORD   dwPathBackSlashIndex;
    LPCWSTR lpFormat;

    const   WCHAR wszWithSlash[] = TEXT("%s\\%s");
    const   WCHAR wszWithoutSlash[] = TEXT("%s%s");

    if (lpFilePath == NULL)
    {
        return E_INVALIDARG;
    }

    dwPathBackSlashIndex = lstrlen(lpPath) - 1;

    if (*(lpPath + dwPathBackSlashIndex) == TEXT('\\'))
    {
        // Path is already ended with a '\'
        lpFormat = wszWithoutSlash;
    }
    else
    {
        // Path is not ended with a '\', need a '\'
        lpFormat = wszWithSlash;
    }

    hr = StringCchPrintf(lpFilePath,
                         cchFilePath,
                         lpFormat,
                         lpPath, 
                         lpFile);

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT CopyCompressedFile(
    LPCWSTR lpCabPath,
    LPCWSTR lpCabFile,          // Absolute path with CAB file name
    LPCWSTR lpFileInCab,        // File name in CAB file
    LPWSTR  lpUncompressedFile,
    DWORD   cchUncompressedFile
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet;
    DWORD   dwRet;
    WCHAR   wszAppName[MAX_PATH];
    WCHAR   wszArg[MAX_PATH * 3];
    WCHAR   wszFullCabFilePath[MAX_PATH];
    
    hr = ConcatFilePath(lpCabPath,
                        lpCabFile,
                        wszFullCabFilePath,
                        ARRAYSIZE(wszFullCabFilePath));
    if (FAILED(hr))
    {
        return hr;
    }

    if (lpFileInCab == NULL || *lpFileInCab == TEXT('\0'))
    {
        DWORD dwEnd = lstrlen(lpCabFile);

        if (lpCabFile[dwEnd - 1] == TEXT('_'))
        {
            // Stand alone compressed file
            dwRet = ExpandEnvironmentStrings(TEXT("%SystemRoot%\\system32\\Extrac32.exe"),
                                             wszAppName,
                                             ARRAYSIZE(wszAppName));
            if (dwRet > 0)
            {
                hr = ConcatFilePath(g_wszTempFolder,
                                    lpCabFile,
                                    lpUncompressedFile,
                                    cchUncompressedFile);
                if (SUCCEEDED(hr))
                {
                    hr = StringCchPrintf(wszArg,
                                         ARRAYSIZE(wszArg), 
                                         TEXT("Extrac32.exe /Y \"%s\" \"%s\""),
                                         wszFullCabFilePath,
                                         lpUncompressedFile);
                    if (SUCCEEDED(hr))
                    {
                        hr = LaunchProgram(wszAppName, wszArg);
                    }
                }
            }
        }
        else
        {
            // Stand alone uncompressed file
            hr = ConcatFilePath(g_wszTempFolder,
                                lpCabFile,
                                lpUncompressedFile,
                                cchUncompressedFile);
            if (SUCCEEDED(hr))
            {
                bRet = CopyFile(wszFullCabFilePath,
                                lpUncompressedFile,
                                FALSE);
                if (bRet)
                {
                    SetFileAttributes(lpUncompressedFile, FILE_ATTRIBUTE_NORMAL);
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }
    else
    {
        // CAB file
        dwRet = ExpandEnvironmentStrings(TEXT("%SystemRoot%\\system32\\Expand.exe"),
                                         wszAppName,
                                         ARRAYSIZE(wszAppName));
        if (dwRet > 0)
        {
            hr = ConcatFilePath(g_wszTempFolder,
                                lpFileInCab,
                                lpUncompressedFile,
                                cchUncompressedFile);
            if (SUCCEEDED(hr))
            {
                hr = StringCchPrintf(wszArg,
                                     ARRAYSIZE(wszArg),
                                     TEXT("Expand.exe \"%s\" -F:%s \"%s\""),
                                     wszFullCabFilePath,
                                     lpFileInCab,
                                     g_wszTempFolder);
                if (SUCCEEDED(hr))
                {
                    hr = LaunchProgram(wszAppName, wszArg);
                }
            }
        }
    }

    //
    // Double check if the file is uncompressed/copied correctly
    //
    if (SUCCEEDED(hr))
    {
        DWORD dwAttr;
        
        dwAttr = GetFileAttributes(lpUncompressedFile);
        if (dwAttr == INVALID_FILE_ATTRIBUTES)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT LaunchProgram(
    LPWSTR lpAppName,
    LPWSTR lpCmdLine
)
{
    HRESULT hr = E_FAIL;
    BOOL    bRet = FALSE;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    // Construct absolute path to Winnt32.exe
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    si.wShowWindow = SW_SHOWMINIMIZED;

    // CreateProcess call conforms to security guideline
    bRet = CreateProcess(lpAppName,
                         lpCmdLine,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_NO_WINDOW,
                         NULL,
                         NULL,
                         &si,
                         &pi);
    if (bRet)
    {
        // Wait until Expand.exe finished
        hr = S_OK;
        WaitForSingleObject(pi.hProcess, INFINITE);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT GetPathFromSourcePathName(
    LPCWSTR lpSrcPathName,
    LPWSTR  lpPathBuffer,
    DWORD   cchPathBuffer
)
{
    HRESULT hr = S_FALSE;
    DWORD   i;

    if (lpSrcPathName == NULL || lpPathBuffer == NULL)
    {
        return E_INVALIDARG;
    }

    for (i = 0 ; i < g_dwSrcCount ; i++)
    {
        if (lstrcmpi(lpSrcPathName, g_SrcPath[i].wszSrcName) == LSTR_EQUAL)
        {
            hr = StringCchCopy(lpPathBuffer,
                               cchPathBuffer,
                               g_SrcPath[i].wszPath);
        }
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
//
//  Function:   
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT GetCabFileName(
    LPCWSTR lpFileToken,     // File name token from template file
    LPWSTR  lpCab,
    DWORD   cchCab,
    LPWSTR  lpFileInCab,
    DWORD   cchFileInCab
)
{
    HRESULT hr = E_FAIL;
    LPWSTR  lpBuffer;
    LPWSTR  lpStart;
    DWORD   cbBuffer;

    if (lpCab == NULL || lpFileInCab == NULL)
    {
        return E_INVALIDARG;
    }

    cbBuffer = (lstrlen(lpFileToken) + 1) * sizeof(WCHAR);
    lpBuffer = (LPWSTR) MEMALLOC(cbBuffer);
    if (lpBuffer)
    {
        hr = StringCbCopy(lpBuffer, cbBuffer, lpFileToken);
        if (SUCCEEDED(hr))
        {
            lpStart = wcstok(lpBuffer, TEXT("\\"));
            if (lpStart)
            {
                hr = StringCchCopy(lpCab, cchCab, lpStart);
                if (SUCCEEDED(hr))
                {
                    lpStart = wcstok(NULL, TEXT("\\"));
                    if (lpStart)
                    {
                        hr = StringCchCopy(lpFileInCab, cchFileInCab, lpStart);
                    }
                    else
                    {
                        hr = StringCchCopy(lpFileInCab, cchFileInCab, TEXT(""));
                    }
                }
            }
        }

        MEMFREE(lpBuffer);
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT GetCabTempDirectory(
    LPCWSTR lpCab
)
{
    HRESULT hr = S_OK;

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   
//
//  Synopsis:   
//
//  Returns:    
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      
//
//-----------------------------------------------------------------------------
HRESULT CreateTempDirectory(
    LPWSTR lpName,      // Buffer to store temp path
    DWORD  cchName      // Size of buffer (in WCHAR)
)
{
    HRESULT hr = E_FAIL;
    WCHAR   wszTempPath[MAX_PATH];
    DWORD   cchCopied;

    if (lpName == NULL)
    {
        return FALSE;
    }

    cchCopied = GetTempPath(cchName, lpName);
    if (cchCopied > 0)
    {
        hr = StringCchCat(lpName, cchName, TEXT_TOKGEN_TEMP_PATH_NAME);
        if (SUCCEEDED(hr))
        {
            if (GetFileAttributes(lpName) == INVALID_FILE_ATTRIBUTES)
            {
                if (!CreateDirectory(lpName, NULL))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}



//-----------------------------------------------------------------------------
//
//  Function:   LTrim
//
//  Synopsis:   Trim the leading spaces in the string.
//
//  Returns:    none
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
void LTrim(
    LPWSTR lpBuffer
)
{
    int nIndex = 0;
    int nDest = 0;

    if (NULL == lpBuffer || TEXT('\0') == *lpBuffer)
        return;

    while (TEXT(' ') == lpBuffer[nIndex] && TEXT('\0') != lpBuffer[nIndex])
        nIndex++;

    while (TEXT('\0') != lpBuffer[nIndex])
    {
        lpBuffer[nDest] = lpBuffer[nIndex];
        nDest++;
        nIndex++;
    }
    lpBuffer[nDest] = TEXT('\0');
}



//-----------------------------------------------------------------------------
//
//  Function:   RTrim
//
//  Synopsis:   Trim the trailing spaces in the string.
//
//  Returns:    none
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
void RTrim(
    LPWSTR lpBuffer
)
{
    int nIndex = 0;
    int nDest = 0;

    if (NULL == lpBuffer || TEXT('\0') == *lpBuffer)
        return;

    nIndex = lstrlen(lpBuffer) - 1;

    while (nIndex >= 0)
    {
        if (lpBuffer[nIndex] != TEXT(' '))
            break;

        nIndex--;
    }

    lpBuffer[nIndex + 1] = TEXT('\0');
}



//-----------------------------------------------------------------------------
//
//  Function:   Str2KeyPath
//
//  Synopsis:   Convert string value of root key to HKEY value
//
//  Returns:    HKEY value
//
//  History:    02/07/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
BOOL Str2KeyPath(
    LPCWSTR  lpHKeyStr,
    PHKEY    pHKey,
    LPCWSTR* pSubKeyPath
)
{
    int     i;
    LPCWSTR lpStart;

    STRING_TO_DATA InfRegSpecTohKey[] = {
        TEXT("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE,
        TEXT("HKLM")              , HKEY_LOCAL_MACHINE,
        TEXT("HKEY_CLASSES_ROOT") , HKEY_CLASSES_ROOT,
        TEXT("HKCR")              , HKEY_CLASSES_ROOT,
        TEXT("HKR")               , NULL,
        TEXT("HKEY_CURRENT_USER") , HKEY_CURRENT_USER,
        TEXT("HKCU")              , HKEY_CURRENT_USER,
        TEXT("HKEY_USERS")        , HKEY_USERS,
        TEXT("HKU")               , HKEY_USERS,
        TEXT("")                  , NULL
    };

    PSTRING_TO_DATA Table = InfRegSpecTohKey;

    if (NULL == lpHKeyStr)
    {
        return FALSE;
    }

    for(i = 0 ; Table[i].String[0] != TEXT('\0') ; i++) 
    {
        lpStart = wcsstr(lpHKeyStr, Table[i].String);
        if (lpStart == lpHKeyStr)
        {
            *pHKey = Table[i].Data;

            if (NULL != pSubKeyPath)
            {
                lpStart += lstrlen(Table[i].String);
                if (*lpStart == TEXT('\0'))
                {
                    *pSubKeyPath = lpStart;
                }
                else
                {
                    *pSubKeyPath = lpStart + 1;
                }
            }

            return TRUE;
        }
    }

    return FALSE;
}


HRESULT StringSubstitute(
    LPWSTR  lpString,       // New string buffer
    DWORD   cchString,      // Size of buffer in WCHAR
    LPCWSTR lpOldString,    // Old string
    LPCWSTR lpOldSubStr,    // Old sub string to be substituted
    LPCWSTR lpNewSubStr     // New sub string
)
{
    HRESULT hr = E_FAIL;
    LPWSTR  lpSubStrBegin;

    lpSubStrBegin = StrStrI(lpOldString, lpOldSubStr);
    if (lpSubStrBegin)
    {
        // Sub string found in source string
        DWORD cchNewString;

        cchNewString = lstrlen(lpOldString)
                       - lstrlen(lpOldSubStr)
                       + lstrlen(lpNewSubStr);
        if (cchNewString < cchString)
        {
            DWORD dwStartIndex;
            DWORD dwEndIndex;
            DWORD i, j;

            dwStartIndex = (DWORD) (lpSubStrBegin - lpOldString);
            dwEndIndex = dwStartIndex + lstrlen(lpOldSubStr);

            for (i = 0 ; i < dwStartIndex ; i++)
            {
                lpString[i] = lpOldString[i];
            }

            for (j = 0 ; j < (DWORD) lstrlen(lpNewSubStr) ; i++, j++)
            {
                lpString[i] = lpNewSubStr[j];
            }

            for (j = dwEndIndex ; lpOldString[j] != TEXT('\0') ; i++, j++)
            {
                lpString[i] = lpOldString[j];
            }

            lpString[i] = TEXT('\0');
            
            hr = S_OK;
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    else
    {
        // sub string not found
        hr = S_FALSE;
    }

    if (hr == E_FAIL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


HRESULT ExtractSubString(
    LPWSTR  lpString,       // New string buffer
    DWORD   cchString,      // Size of buffer in WCHAR
    LPCWSTR lpOldString,    // Old string
    LPCWSTR lpLeft,         // Left delimitor
    LPCWSTR lpRight         // Right delimitor
)
{
    HRESULT hr = E_FAIL;
    LPWSTR  lpSubStrBegin, lpSubStrEnd;

    lpSubStrBegin = StrStrI(lpOldString, lpLeft);
    if (lpSubStrBegin)
    {
        lpSubStrBegin += lstrlen(lpLeft);
        lpSubStrEnd = StrStrI(lpSubStrBegin, lpRight);
        if (lpSubStrEnd && (DWORD)(lpSubStrEnd-lpSubStrBegin) < cchString)
        {
            while (lpSubStrBegin < lpSubStrEnd)
            {
                *lpString = *lpSubStrBegin;
                lpString++;
                lpSubStrBegin++;
            }
            *lpString = (WCHAR)'\0';
            hr = S_OK;
        }
    }

    return hr;
}

//-----------------------------------------------------------------------------
//
//  Function:   CompareENGString
//
//  Synopsis:   Wrapper of CompareString API, to compare English strings.
//
//  Returns:    Same as CompareString() API
//
//  History:    05/06/2002 Rerkboos Created
//
//  Notes:      none
//
//-----------------------------------------------------------------------------
int CompareEngString(
    LPCTSTR lpString1,
    LPCTSTR lpString2
)
{
    return CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                         NORM_IGNORECASE,
                         lpString1,
                         -1,
                         lpString2,
                         -1);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\componentlist.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    ComponentList.h
//
//  Abstract:
//
//    This file contains the Component List object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _COMPONENTLIST_H_
#define _COMPONENTLIST_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"
#include "Component.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class ComponentList
{
public:
    ComponentList()
    {
        m_Head = NULL;
        m_Tail = NULL;
        m_Entries = 0;
    };

    ~ComponentList()
    {
        Component* temp;

        while ((temp = getFirst()) != NULL)
        {
            remove(temp);
        }
    };

    DWORD getComponentNumber() { return (m_Entries); };
    Component* getFirst() { return (m_Head); };

    void add(Component* item)
    {
        if ((m_Tail == NULL) && (m_Head == NULL))
        {
            m_Tail = item;
            m_Head = item;
        }
        else
        {
            item->setPrevious(m_Tail);
            m_Tail->setNext(item);
            m_Tail = item;
        }
        m_Entries++;
    };
    void remove(Component* item)
    {
        if ((m_Tail == m_Head) && (m_Tail == item))
        {
            m_Tail = NULL;
            m_Head = NULL;
        }
        else
        {
            if (m_Head = item)
            {
                m_Head = item->getNext();
                (item->getNext())->setPrevious(NULL);
            }
            else if (m_Tail = item)
            {
                m_Tail = item->getPrevious();
                (item->getPrevious())->setNext(NULL);
            }
            else
            {
                (item->getPrevious())->setNext(item->getNext());
                (item->getNext())->setPrevious(item->getPrevious());
            }
        }

        delete item;
        item = NULL;
        m_Entries--;
    };

private:
    Component *m_Head;
    Component *m_Tail;
    DWORD m_Entries;
};

#endif //_COMPONENTLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\file.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    file.h
//
//  Abstract:
//
//    This file contains the File layout object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILE_H_
#define _FILE_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
// #include "infparser.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class File
{
public:
    File(LPSTR sname, LPSTR destDir, LPSTR name, LPSTR srcDir, LPSTR srcName, INT dirId)
    {
        // Compute and copy destination directory.
        HRESULT hr;
        BOOL bSuccess = TRUE;
        
        switch(dirId)
        {
        case(10):
            {
                hr = StringCchCopyA(m_DestinationDir, ARRAYLEN(m_DestinationDir), destDir);
                if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                
                m_WindowsDir = TRUE;
                break;
            }
        case(11):
            {
                 hr = StringCchPrintfA(m_DestinationDir , ARRAYLEN(m_DestinationDir), "System32\\%s",destDir);
                 if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                m_WindowsDir = TRUE;
                break;
            }
        case(17):
            {
                hr = StringCchPrintfA(m_DestinationDir , ARRAYLEN(m_DestinationDir),"Inf\\%s",destDir);
                 if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                
                m_WindowsDir = TRUE;
                break;
            }
        case(18):
            {
                hr = StringCchPrintfA(m_DestinationDir , ARRAYLEN(m_DestinationDir),"Help\\%s",destDir);
                 if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                 
                m_WindowsDir = TRUE;
                break;
            }
        case(24):
            {
                LPSTR index;
                index = strchr(destDir, '\\');
                
                hr = StringCchCopyA(m_DestinationDir, ARRAYLEN(m_DestinationDir), index + 1);
                if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                
                m_WindowsDir = FALSE;
                break;
            }
        case(25):
            {
                hr = StringCchCopyA(m_DestinationDir, ARRAYLEN(m_DestinationDir), destDir);
                if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                m_WindowsDir = TRUE;
                break;
            }
        default:
            {
                hr = StringCchCopyA(m_DestinationDir, ARRAYLEN(m_DestinationDir), destDir);
                if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }
                
                m_WindowsDir = FALSE;
                break;
            }
        }

        //
        //  Verify that the last character of the destination dir is not '\'
        //
        if (m_DestinationDir[strlen(m_DestinationDir)-1] == '\\')
        {
            m_DestinationDir[strlen(m_DestinationDir)-1] = '\0';
        }

        // Copy the short destination file name
        
        hr = StringCchCopyA(m_ShortDestName, ARRAYLEN(m_ShortDestName), sname);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }

        // Copy destination file name.
        
        hr = StringCchCopyA(m_DestinationName, ARRAYLEN(m_DestinationName), name);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }
        // Copy source directory.
        
        hr = StringCchCopyA(m_SourceDir, ARRAYLEN(m_SourceDir), srcDir);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }
        // Copy and correct source name.
        
        hr = StringCchCopyA(m_SourceName, ARRAYLEN(m_SourceName), srcName);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }
//        if( m_SourceName[_tcslen(m_SourceName)-1] == '_')
//        {
//            m_SourceName[_tcslen(m_SourceName)-1] = 'I';
//        }

        // Initialize linked-list pointers.
        m_Next = NULL;
        m_Previous = NULL;

        if (!bSuccess) {
            printf("Error in File::File() \n");
         }
            
    };

    LPSTR getDirectoryDestination() { return(m_DestinationDir); };
    LPSTR getShortName() {/*printf("Shortname is %s\n", m_ShortDestName);*/ return (m_ShortDestName); } ;
    LPSTR getName() { return (m_DestinationName);  };
    LPSTR getSrcDir() { return (m_SourceDir); };
    LPSTR getSrcName() { return (m_SourceName); };
    BOOL  isWindowsDir() { return (m_WindowsDir);}
    File* getNext() { return (m_Next); };
    File* getPrevious() { return (m_Previous); };
    void setNext(File *next) { m_Next = next; };
    void setPrevious(File *previous) { m_Previous = previous; };

private:
    CHAR  m_ShortDestName[MAX_PATH];
    CHAR  m_DestinationName[MAX_PATH];
    CHAR  m_DestinationDir[MAX_PATH];
    CHAR  m_SourceName[MAX_PATH];
    CHAR  m_SourceDir[MAX_PATH];
    BOOL  m_WindowsDir;
    File *m_Next;
    File *m_Previous;
};

#endif //_FILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\filelayout.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    filelayout.h
//
//  Abstract:
//
//    This file contains the File layout object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILELAYOUT_H_
#define _FILELAYOUT_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
// #include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class FileLayout
{
public:
    FileLayout(LPSTR originFilename, LPSTR destFilename, DWORD flavorMask)
    {
        HRESULT hr;
        BOOL  bSuccess = TRUE;
        
        hr = StringCchCopyA(m_OriginFilename, ARRAYLEN(m_OriginFilename), originFilename);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }
        
        // strcpy(m_DestFilename, destFilename);
        hr = StringCchCopyA(m_DestFilename, ARRAYLEN(m_DestFilename), destFilename);
        if(!SUCCEEDED(hr)) {
            bSuccess  = FALSE;
        }
        
        m_Flavor = flavorMask;
        m_Next = NULL;
        m_Previous = NULL;

        if(!bSuccess) {
            printf("Error FileLayout::FileLayout() \n");
        }
    };

    BOOL isFlavor(DWORD dwFlavor){ return (dwFlavor & m_Flavor); };
    LPSTR getOriginFileName() { return (m_OriginFilename); };
    LPSTR getDestFileName() { return (m_DestFilename); };
    FileLayout* getNext() { return (m_Next); };
    FileLayout* getPrevious() { return (m_Previous); };
    void setNext(FileLayout *next) { m_Next = next; };
    void setPrevious(FileLayout *previous) { m_Previous = previous; };

private:
    CHAR  m_OriginFilename[MAX_PATH];
    CHAR  m_DestFilename[MAX_PATH];
    DWORD m_Flavor;
    FileLayout *m_Next;
    FileLayout *m_Previous;
};

#endif //_FILELAYOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\filelayoutexceptionlist.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    FileLayoutExceptionList.h
//
//  Abstract:
//
//    This file contains the File Layout Exception List object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILELAYOUTEXCEPTIONLIST_H_
#define _FILELAYOUTEXCEPTIONLIST_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"
#include "FileLayout.h"

///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class FileLayoutExceptionList
{
public:
    FileLayoutExceptionList()
    {
        m_Head = NULL;
        m_Tail = NULL;
        m_Entries = 0;
    };

    ~FileLayoutExceptionList()
    {
        FileLayout* temp;

        while ((temp = getFirst()) != NULL)
        {
            remove(temp);
        }
    };

    DWORD getExceptionsNumber() { return (m_Entries); };
    FileLayout* getFirst() { return (m_Head); };

    void insert(FileLayout* item)
    {
        if ((m_Tail == NULL) && (m_Head == NULL))
        {
            m_Tail = item;
            m_Head = item;
        }
        else
        {
            item->setPrevious(m_Tail);
            m_Tail->setNext(item);
            m_Tail = item;
        }
        m_Entries++;
    };
    void remove(FileLayout* item)
    {
        if ((m_Tail == m_Head) && (m_Tail == item))
        {
            m_Tail = NULL;
            m_Head = NULL;
        }
        else
        {
            if (m_Head = item)
            {
                m_Head = item->getNext();
                (item->getNext())->setPrevious(NULL);
            }
            else if (m_Tail = item)
            {
                m_Tail = item->getPrevious();
                (item->getPrevious())->setNext(NULL);
            }
            else
            {
                (item->getPrevious())->setNext(item->getNext());
                (item->getNext())->setPrevious(item->getPrevious());
            }
        }

        delete item;
        item = NULL;
        m_Entries--;
    };
    FileLayout* search(LPSTR srcName)
    {
        FileLayout* item;

        item = getFirst();
        while (item != NULL)
        {
            if( _tcsicmp(srcName, item->getOriginFileName()) == 0)
            {
                return item;
            }

            item = item->getNext();
        }

        return NULL;
    }
	FileLayout* searchDestName(LPSTR destFileName)
	{
		FileLayout* item;

		item = getFirst();
		while (item != NULL)
		{
			if (_tcsicmp(destFileName, item->getDestFileName()) == 0) 
			{
				return item;
			}
			item = item->getNext();
		}
		return NULL;
	}
	
private:
    FileLayout *m_Head;
    FileLayout *m_Tail;
    DWORD m_Entries;
};

#endif //_FILELAYOUTEXCEPTIONLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\uuid.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    Uuid.h
//
//  Abstract:
//
//    This Uuid contains the Uuid object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __UUID_H_
#define __UUID_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Uuids.
//
///////////////////////////////////////////////////////////////////////////////
// #include "infparser.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class Uuid
{
public:
    Uuid()
    {
        RPC_STATUS     Result;
        unsigned char* UuidPtr;
        HRESULT hr;
        BOOL bSuccess = TRUE;

        //
        //  Create the UUID.
        //
        Result = UuidCreate(&m_Uuid);
        if ((Result == RPC_S_UUID_LOCAL_ONLY) ||
            (Result == RPC_S_OK))
        {
            //
            //  Convert UUID into a string
            //
            if ((Result = UuidToString(&m_Uuid, &UuidPtr)) == RPC_S_OK)
            {
                //
                //  Copy string
                //
                hr = StringCchCopyA(m_UuidString, ARRAYLEN(m_UuidString), (const char*) UuidPtr);
                if(!SUCCEEDED(hr)) {
                    bSuccess  = FALSE;
                }

                //
                //  Free the RpcString
                //
                RpcStringFree(&UuidPtr);

                //
                //  Upper case the string
                //
                _strupr(m_UuidString);
            }
        }

        if (!bSuccess){
            printf("Error in Uuid::Uuid() \n");
        }
    };

    LPSTR getString() { return(m_UuidString); };
    UUID getId() { return(m_Uuid); };
    Uuid* getNext() { return (m_Next); };
    Uuid* getPrevious() { return (m_Previous); };
    void setNext(Uuid *next) { m_Next = next; };
    void setPrevious(Uuid *previous) { m_Previous = previous; };

private:
    UUID  m_Uuid;
    CHAR  m_UuidString[MAX_PATH];
    Uuid *m_Next;
    Uuid *m_Previous;
};

#endif //__UUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__8D69AD93_DBBC_4FB2_ADA1_4F5028797EDC__INCLUDED_)
#define AFX_STDAFX_H__8D69AD93_DBBC_4FB2_ADA1_4F5028797EDC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef WIN32_LEAN_AND_MEAN
	#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8D69AD93_DBBC_4FB2_ADA1_4F5028797EDC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	infparser.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\filelist.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    FileList.h
//
//  Abstract:
//
//    This file contains the File List object definition.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _FILELIST_H_
#define _FILELIST_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "infparser.h"
#include "File.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Class definition.
//
///////////////////////////////////////////////////////////////////////////////
class FileList
{
public:
    FileList()
    {
        m_Head = NULL;
        m_Tail = NULL;
        m_Entries = 0;
    };

    ~FileList()
    {
        free();
    };

    DWORD getFileNumber() { return (m_Entries); };
    File* getFirst() { return (m_Head); };

    void add(File* item)
    {
        if ((m_Tail == NULL) && (m_Head == NULL))
        {
            m_Tail = item;
            m_Head = item;
        }
        else
        {
            item->setPrevious(m_Tail);
            m_Tail->setNext(item);
            m_Tail = item;
        }
        m_Entries++;
    };
    void remove(File* item)
    {
        if ((m_Tail == m_Head) && (m_Tail == item))
        {
            m_Tail = NULL;
            m_Head = NULL;
        }
        else
        {
            if (m_Head == item)
            {
                m_Head = item->getNext();
                (item->getNext())->setPrevious(NULL);
            }
            else if (m_Tail == item)
            {
                m_Tail = item->getPrevious();
                (item->getPrevious())->setNext(NULL);
            }
            else
            {
                (item->getPrevious())->setNext(item->getNext());
                (item->getNext())->setPrevious(item->getPrevious());
            }
        }

        delete item;
        item = NULL;
        m_Entries--;
    };
    BOOL isDirId(BOOL bWindowsDir)
    {
        File* index;

        index = getFirst();
        while (index != NULL)
        {
            if (index->isWindowsDir() == bWindowsDir)
            {
                return (TRUE);
            }
        }
        return (FALSE);
    };
    File* search(File* refNode, LPSTR dirBase)
    {
        File* index;
        LPSTR dirNamePtr;

        index = getFirst();
        while (index != NULL)
        {
            if (index != refNode)
            {
                //
                //  Try a match
                //
                dirNamePtr = index->getDirectoryDestination();
                if (_stricmp(dirNamePtr, dirBase) == 0)
                {
                    return (index);
                }
            }

            //
            //  Continue the loop.
            //
            index = index->getNext();
        }

        return (NULL);
    };
    void free()
    {
        File* temp;

        while ((temp = getFirst()) != NULL)
        {
            remove(temp);
        }
    }

private:
    File *m_Head;
    File *m_Tail;
    DWORD m_Entries;
};

#endif //_FILELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\infparser.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    infparser.h
//
//  Abstract:
//
//    This file contains global definition for the infparser.exe utility.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _INFPARSER_H_
#define _INFPARSER_H_


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include <windows.h>
#include <setupapi.h>
#include <rpc.h>
#include <tchar.h>
#include <strsafe.h>

#include "Component.h"
#include "ComponentList.h"
#include "FileLayout.h"
#include "FileLayoutExceptionList.h"
#include "File.h"
#include "FileList.h"
#include "Uuid.h"




///////////////////////////////////////////////////////////////////////////////
//
//  Enumeration
//
///////////////////////////////////////////////////////////////////////////////
enum flavorList
{
    FLV_UNDEFINED    	= 0x0000,
    FLV_CORE         	= 0x0001,
    FLV_PERSONAL     	= 0x0002,
    FLV_PROFESSIONAL 	= 0x0004,
    FLV_SERVER       	= 0x0008,
    FLV_ADVSERVER    	= 0x0010,
    FLV_DATACENTER   	= 0x0040,
    FLV_WEBBLADE   		= 0x0080,    
    FLV_SMALLBUSINESS   = 0x0100        
};

enum argumentToken
{
    ARG_UNDEFINED 	= 0x0000,
    ARG_BINARY    	= 0x0001,
    ARG_LANG      	= 0x0002,
    ARG_FLAVOR    	= 0x0004,
    ARG_DIR       	= 0x0008,
    ARG_OUT       	= 0x0010,
    ARG_SILENT    	= 0x0020,
    ARG_LOCBIN		= 0x0040,
    ARG_CDLAYOUT 	= 0x0080,
    ARG_CORELOCBIN	= 0x0100
};

enum binaryType
{
    BIN_UNDEFINED = 0x0000,
    BIN_32        = 0x0001,
    BIN_64        = 0x0002,
};


///////////////////////////////////////////////////////////////////////////////
//
//  Type definitions
//
///////////////////////////////////////////////////////////////////////////////
typedef struct LayoutInf
{
    CHAR strLayoutInfPaths[MAX_PATH];
    FileLayoutExceptionList flLayoutCore;
    FileLayoutExceptionList flLayoutX86;
    FileLayoutExceptionList flLayoutIA64;    
    CHAR strSkuName[4];
} LAYOUTINF;

///////////////////////////////////////////////////////////////////////////////
//
//  Global
//
///////////////////////////////////////////////////////////////////////////////
extern BOOL bSilence;
extern DWORD dwComponentCounter;
extern DWORD dwDirectoryCounter;
extern WORD  gBuildNumber;

#endif //_INFPARSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\infparser\infparser.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.
//
//  Module Name:
//
//    infparser.cpp
//
//  Abstract:
//
//    This file contains the entry point of the infparser.exe utility.
//
//  Revision History:
//
//    2001-06-20    lguindon    Created.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
//  Includes Files.
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "infparser.h"
#include "stdlib.h"
#include "windows.h"
#include "string.h"
#include "ctype.h"


///////////////////////////////////////////////////////////////////////////////
//
//  Global Definitions
//
///////////////////////////////////////////////////////////////////////////////
#define NO_INVALIDCHARS     31
#define PRO_SKU_CONDITION   "<Condition><![CDATA[NOT MsiNTSuitePersonal AND MsiNTProductType=1]]></Condition>"
#define SRV_SKU_CONDITION   "<Condition><![CDATA[MsiNTProductType<>1 AND NOT MsiNTSuiteDataCenter AND NOT MsiNTSuiteEnterprise  AND NOT MsiNTSuiteWebServer AND NOT MsiNTSuiteSmallBusiness and NOT MsiNTSuiteSmallBusinessRestricted]]></Condition>"
#define ADV_SKU_CONDITION   "<Condition>MsiNTSuiteEnterprise</Condition>"
#define SBS_SKU_CONDITION   "<Condition>MsiNTSuiteSmallBusinessRestricted OR MsiNTSuiteSmallBusiness</Condition>"
#define DTC_SKU_CONDITION   "<Condition>MsiNTSuiteDataCenter</Condition>"
#define BLA_SKU_CONDITION   "<Condition>MsiNTSuiteWebServer</Condition>"
#define PRO_SKU_INF         "layout.inf"
#define PER_SKU_INF         "perinf\\layout.inf"
#define SRV_SKU_INF         "srvinf\\layout.inf"
#define ADV_SKU_INF         "entinf\\layout.inf"
#define DTC_SKU_INF         "dtcinf\\layout.inf"
#define SBS_SKU_INF         "sbsinf\\layout.inf"
#define BLA_SKU_INF         "blainf\\layout.inf"
#define NO_SKUS             7
#define PRO_SKU_INDEX       0
#define PER_SKU_INDEX       1
#define SRV_SKU_INDEX       2
#define ADV_SKU_INDEX       3
#define DTC_SKU_INDEX       4
#define SBS_SKU_INDEX       5
#define BLA_SKU_INDEX       6


///////////////////////////////////////////////////////////////////////////////
//
//  Global variable.
//
///////////////////////////////////////////////////////////////////////////////
BOOL    bSilence = TRUE;
DWORD   gBinType = BIN_UNDEFINED;
DWORD   dwComponentCounter = 0;
DWORD   dwDirectoryCounter = 1;
WORD    gBuildNumber = 0;
TCHAR   TempDirName[MAX_PATH] = { 0 };
LPSTR   sLDirName = NULL;
LPSTR   sLocBinDir = NULL;
CHAR    InvalidChars[NO_INVALIDCHARS] = {   '`', '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '-', 
                                            '=', '+', '[', '{', ']', '}', '\\', '|', ';', ':', '\'', '\"', ',', '<', 
                                            '>', '/', '?', ' '
                                         };
CHAR        strArchSections[3][30] = {"SourceDisksFiles", "SourceDisksFiles.x86", "SourceDisksFiles.ia64"};
LAYOUTINF   SkuInfs[NO_SKUS];


///////////////////////////////////////////////////////////////////////////////
//
//  Prototypes.
//
///////////////////////////////////////////////////////////////////////////////
BOOL    DirectoryExist(LPSTR dirPath);
BOOL    ValidateLanguage(LPSTR dirPath, LPSTR langName, DWORD binType);
WORD    ConvertLanguage(LPSTR dirPath, LPSTR langName);
int     ListContents(LPSTR filename, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType);
int     ListComponents(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType);
int     ListMuiFiles(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType);
void    PrintFileList(FileList* list, HANDLE hFile, BOOL compressed, BOOL bWinDir, BOOL bPermanent, BOOL bX86OnIA64, DWORD flavor, DWORD binType);
BOOL    PrintLine(HANDLE hFile, LPCSTR lpLine);
HANDLE  CreateOutputFile(LPSTR filename);
VOID    removeSpace(LPSTR src, LPSTR dest);
DWORD   TransNum(LPTSTR lpsz);
void    Usage();
BOOL    GetTempDirName(LPSTR sLangName) ;
BOOL    GetFileShortName(const CHAR * pcIn, CHAR * pcOut, BOOL bInFileExists);
void    ReplaceInvalidChars(CHAR *pcInName);
BOOL    IsInvalidChar(CHAR cCheck);
BOOL    GetFileNameFromFullPath(const CHAR * pcInFullPath, CHAR * pcOutFileName);
void    RenameMuiExtension(CHAR * dstFileName);                    
BOOL    ContainSKUDirs(CHAR *pszSKUSearchPath);
BOOL    GetSKUConditionString(CHAR *pszBuffer, DWORD dwFlavour);
BOOL    IsFileForSKU(LPSTR strFileName, DWORD dwSKU, DWORD dwArch, FileLayoutExceptionList * exceptionList);
BOOL    IsFileInInf(CHAR * strFileName, UINT iSkuIndex, DWORD dwArch);
BOOL    ReadInLayoutInfFiles();

///////////////////////////////////////////////////////////////////////////////
//
//  Main entry point.
//
///////////////////////////////////////////////////////////////////////////////
int __cdecl main(int argc, char* argv[])
{
    LPSTR   sLangName = NULL;
    LPSTR   sDirPath = NULL;
    DWORD   dwFlavor = FLV_UNDEFINED;
    DWORD   dwBinType = BIN_UNDEFINED;
    DWORD   dwArg = ARG_UNDEFINED;
    WORD    wLangID = 0;
    HANDLE  hFile;
    int     argIndex = 1;
    LPSTR   lpFileName = NULL;
    HRESULT hr = S_OK;
    INT     iResult = 0;
    INT     i = 0;
    
    //
    //  Check if we have the minimal number of arguments.
    //
    if (argc < 6)
    {
        printf("Not all required parameters were found when executing infparser.exe.\n");
        Usage();
        return (-1);
    }

    //
    //  Parse the command line.
    //
    while (argIndex < argc)
    {
        if (*argv[argIndex] == '/')
        {
            switch(*(argv[argIndex]+1))
            {
            case('p'):
            case('P'):
                    //
                    //  switch for locating directory to external components this should be same as lang except for psu builds
                    //
                    sLDirName = (argv[argIndex]+3);
                    dwArg |= ARG_CDLAYOUT;                    
                    break;
            case('b'):
            case('B'):
                    //
                    //  Binairy i386 or ia64
                    //
                    if ((*(argv[argIndex]+3) == '3') && (*(argv[argIndex]+4) == '2'))
                    {
                        dwBinType = BIN_32;
                    }
                    else if ((*(argv[argIndex]+3) == '6') && (*(argv[argIndex]+4) == '4'))
                    {
                        dwBinType = BIN_64;
                    }
                    else
                    {
                        return (argIndex);
                    }

                    dwArg |= ARG_BINARY;
                    break;
            case('l'):
            case('L'):
                    //
                    //  Language
                    //
                    sLangName = (argv[argIndex]+3);
                    dwArg |= ARG_LANG;
                    break;
            case('i'):
            case('I'):
                    //
                    //  Inf root location (where localized binaries are located, same as _NTPOSTBLD env variable)
                    //
                    sLocBinDir = (argv[argIndex]+3);
                    dwArg |= ARG_LOCBIN;
                    break;
            case('f'):
            case('F'):
                    //
                    //  Flavor requested
                    //
                    switch(*(argv[argIndex]+3))
                    {
                    case('c'):
                    case('C'):
                            dwFlavor = FLV_CORE;
                            break;
                    case('p'):
                    case('P'):
                            dwFlavor = FLV_PROFESSIONAL;
                            break;
                    case('s'):
                    case('S'):
                            dwFlavor = FLV_SERVER;
                            break;
                    case('a'):
                    case('A'):
                            dwFlavor = FLV_ADVSERVER;
                            break;
                    case('d'):
                    case('D'):
                            dwFlavor = FLV_DATACENTER;
                            break;
                    case('b'):
                    case('B'):
                            dwFlavor = FLV_WEBBLADE;
                            break;
                    case('l'):
                    case('L'):
                            dwFlavor = FLV_SMALLBUSINESS;
                            break;
                    default:
                            return (argIndex);
                    }

                    dwArg |= ARG_FLAVOR;
                    break;
            case('s'):
            case('S'):
                    //
                    //  Binairy location
                    //
                    sDirPath = (argv[argIndex]+3);
                    dwArg |= ARG_DIR;
                    break;
            case('o'):
            case('O'):
                    //
                    //  Output filename
                    //
                    /*
                    if ((hFile = CreateOutputFile(argv[argIndex]+3)) == INVALID_HANDLE_VALUE)
                    {
                        return (argIndex);
                    }
                    */

                    lpFileName = argv[argIndex]+3;

                    dwArg |= ARG_OUT;
                    break;
            case('v'):
            case('V'):
                    //
                    //  Verbose mode
                    //
                    bSilence = FALSE;
                    dwArg |= ARG_SILENT;
                    break;
            default:
                    printf("Invalid parameters found on the command line!\n");                    
                    Usage();
                    return (argIndex);
            }
        }
        else
        {
            printf("Invalid parameters found on the command line!\n");
            Usage();
            return (-1);
        }

        //
        //  Next argument
        //
        argIndex++;
    }

    //
    // Validate arguments passed. Should have all five basic argument in order
    // to continue.
    //
    if ((dwArg == ARG_UNDEFINED) ||
        !((dwArg & ARG_BINARY) &&
          (dwArg & ARG_LANG) &&
          (dwArg & ARG_DIR) &&
          (dwArg & ARG_OUT) &&
          (dwArg & ARG_LOCBIN) &&
          (dwArg & ARG_CDLAYOUT) &&          
          (dwArg & ARG_FLAVOR)))
    {
        Usage();
        return (-1);
    }

    //
    // Validate Source directory
    //
    if (!DirectoryExist(sDirPath))
    {
        return (-2);
    }
    if (!DirectoryExist(sLocBinDir))
    {
        return (-2);
    }

    //
    // Validate Language
    //
    if (!ValidateLanguage(sDirPath, sLangName, dwBinType))
    {
        return (-3);
    }

    //
    //  Get LANGID from the language
    //
    if ( (gBuildNumber = ConvertLanguage(sDirPath, sLangName)) == 0x0000)
    {
        return (-4);
    }

    // update the temp directory global variable
    if (!GetTempDirName(sLangName))
    {
        return (-5);
    }

    gBinType = dwBinType;

    // Generate the layout.inf paths for every sku
    hr = StringCchPrintfA(SkuInfs[PRO_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, PRO_SKU_INF);   // Professional
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchPrintfA(SkuInfs[PER_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, PER_SKU_INF);   // Personal
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchPrintfA(SkuInfs[SRV_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, SRV_SKU_INF);   // standard server
    if (FAILED(hr))
    {
        return (-6);
    }
    hr = StringCchPrintfA(SkuInfs[ADV_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, ADV_SKU_INF);   // advanced server
    if (FAILED(hr))
    {
        return (-6);
    }
    hr = StringCchPrintfA(SkuInfs[DTC_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, DTC_SKU_INF);   // datacenter server
    if (FAILED(hr))
    {
        return (-6);
    }
    hr = StringCchPrintfA(SkuInfs[SBS_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, SBS_SKU_INF);   // small business server
    if (FAILED(hr))
    {
        return (-6);
    }
    hr = StringCchPrintfA(SkuInfs[BLA_SKU_INDEX].strLayoutInfPaths, MAX_PATH, "%s\\%s", sLocBinDir, BLA_SKU_INF);   // web server   
    if (FAILED(hr))
    {
        return (-6);
    }


    hr = StringCchCopyA(SkuInfs[PRO_SKU_INDEX].strSkuName, 4, TEXT("Pro"));   // Professional
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchCopyA(SkuInfs[PER_SKU_INDEX].strSkuName, 4, TEXT("Per"));   // Personal
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchCopyA(SkuInfs[SRV_SKU_INDEX].strSkuName, 4, TEXT("Srv"));   // Standard Server
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchCopyA(SkuInfs[ADV_SKU_INDEX].strSkuName, 4, TEXT("Adv"));   // Advanced Server
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchCopyA(SkuInfs[DTC_SKU_INDEX].strSkuName, 4, TEXT("Dtc"));   // Datacenter
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchCopyA(SkuInfs[SBS_SKU_INDEX].strSkuName, 4, TEXT("Sbs"));   // Small Business Server
    if (FAILED(hr))
    {
        return (-6);
    }       
    hr = StringCchCopyA(SkuInfs[BLA_SKU_INDEX].strSkuName, 4, TEXT("Bla"));   // Blade server
    if (FAILED(hr))
    {
        return (-6);
    }       

    if (FALSE == ReadInLayoutInfFiles())
    {
        if (!bSilence)
        {
            printf("Failed to populate layout.inf file lists.\n");
        }
        return (-7);
    }

    //
    //  Generate the file list
    //
    if ((dwArg & ARG_OUT) && lpFileName)
    {
        iResult =  ListContents(lpFileName, sDirPath, sLangName, dwFlavor, dwBinType);
    }

    return iResult;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ListContents()
//
//  Generate the file list contents.
//
///////////////////////////////////////////////////////////////////////////////
int ListContents(LPSTR filename, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType)
{
    int iRet = 0;
    Uuid* uuid;
    CHAR schemaPath[MAX_PATH] = {0};
    CHAR outputString[4096] = {0};
    FileList fileList, rootfileList;
    HANDLE outputFile = CreateOutputFile(filename);
    HRESULT hr;

    if (outputFile == INVALID_HANDLE_VALUE)
    {
        iRet = -1;
        goto ListContents_EXIT;
    }

    //
    //  Create a UUID for this module and the schema path
    //
    uuid = new Uuid();
    
    hr = StringCchPrintfA(schemaPath, ARRAYLEN(schemaPath), "%s\\msi\\MmSchema.xml", dirPath);
    if (!SUCCEEDED(hr)) {
        iRet = -1;
        goto ListContents_EXIT;
     }
            

    //
    //  Print module header.
    //
    PrintLine(outputFile, "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
    
    hr = StringCchPrintfA(outputString, ARRAYLEN(outputString), "<Module Name=\"MUIContent\" Id=\"%s\" Language=\"0\" Version=\"1.0\" xmlns=\"%s\">", uuid->getString(), schemaPath);
    if (!SUCCEEDED(hr)) {
        iRet = -1;
        goto ListContents_EXIT;
     }
    PrintLine(outputFile, outputString);

    
    hr = StringCchPrintfA(outputString, ARRAYLEN(outputString), "  <Package Id=\"%s\"", uuid->getString());
    if (!SUCCEEDED(hr)) {
         iRet = -1;
         goto ListContents_EXIT;
     }

    PrintLine(outputFile, outputString);
    delete uuid;
    PrintLine(outputFile, "   Description=\"Content module\"");
    if (BIN_32 == binType)
        PrintLine(outputFile, "   Platforms=\"Intel\"");
    else
        PrintLine(outputFile,"    Platforms=\"Intel64\"");   
    PrintLine(outputFile, "   Languages=\"0\"");
    PrintLine(outputFile, "   InstallerVersion=\"200\"");
    PrintLine(outputFile, "   Manufacturer=\"Microsoft Corporation\"");
    PrintLine(outputFile, "   Keywords=\"MergeModule, MSI, Database\"");
    PrintLine(outputFile, "   Comments=\"This merge module contains all the MUI file content\"");
    PrintLine(outputFile, "   ShortNames=\"yes\" Compressed=\"yes\"");
    PrintLine(outputFile, "/>");

    //
    //  Generate components file list
    //
    if ( (iRet = ListComponents(&fileList, dirPath, lang, flavor, binType)) != 0)
    {
        goto ListContents_EXIT;
    }

    //
    //  Generate Mui file list
    //
    if ((iRet =ListMuiFiles(&fileList, dirPath, lang, flavor, binType)) != 0)
    {
        goto ListContents_EXIT;
    }

    //
    //  Add Specific MuiSetup files to a separate file list for output.  Do this only in the core flavour
    //  these files will be printed out as permanent
    //
    if (flavor == FLV_CORE)
    {
        File* file;
        file = new File( TEXT("muisetup.exe"),
                         TEXT("MUI"),
                         TEXT("muisetup.exe"),
                         dirPath,
                         TEXT("muisetup.exe"),
                         10);
        rootfileList.add(file);
        file = new File( TEXT("muisetup.hlp"),
                         TEXT("MUI"),
                         TEXT("muisetup.hlp"),
                         dirPath,
                         TEXT("muisetup.hlp"),
                         10);
        rootfileList.add(file);
        file = new File( TEXT("eula.txt"),
                         TEXT("MUI"),
                         TEXT("eula.txt"),
                         dirPath,
                         TEXT("eula.txt"),
                         10);
        rootfileList.add(file);
        file = new File( TEXT("relnotes.htm"),
                         TEXT("MUI"),
                         TEXT("relnotes.htm"),
                         dirPath,
                         TEXT("relnotes.htm"),
                         10);
        rootfileList.add(file);
        file = new File( TEXT("readme.txt"),
                         TEXT("MUI"),
                         TEXT("readme.txt"),
                         dirPath,
                         TEXT("readme.txt"),
                         10);
        rootfileList.add(file);
        file = new File( TEXT("mui.inf"),
                         TEXT("MUI"),
                         TEXT("mui.inf"),
                         dirPath,
                         TEXT("mui.inf"),
                         10);
        rootfileList.add(file);
    }

    //
    //  Print compressed directory structure.
    //
    PrintLine(outputFile, "<Directory Name=\"SOURCEDIR\">TARGETDIR");
    if (fileList.isDirId(TRUE))
    {
        PrintLine(outputFile, " <Directory Name=\"Windows\" LongName=\"Windows\">WindowsFolder");
        PrintFileList(&rootfileList, outputFile, TRUE, TRUE, TRUE, FALSE, flavor, binType);
        PrintFileList(&fileList, outputFile, TRUE, TRUE, FALSE, FALSE, flavor, binType);
        PrintLine(outputFile, " </Directory>");
    }
    if (fileList.isDirId(FALSE))
    {
        if (binType == BIN_32)
        {
            PrintLine(outputFile, " <Directory Name=\"Progra~1\" LongName=\"ProgramFilesFolder\">ProgramFilesFolder");
            PrintFileList(&fileList, outputFile, TRUE, FALSE, FALSE, FALSE, flavor, binType);
            PrintLine(outputFile, " </Directory>");
        }
        else if (binType == BIN_64)
        {
            // First print out all the files for the programfiles64 folder - these corresponds to all the files which are designated for the "Program Files" folder in IA64 environement
            PrintLine(outputFile, " <Directory Name=\"Progra~1\" LongName=\"ProgramFilesFolder64\">ProgramFilesFolder64");
            PrintFileList(&fileList, outputFile, TRUE, FALSE, FALSE, FALSE, flavor, binType);
            PrintLine(outputFile, " </Directory>");

            // Now print out all the files for the programfiles folder - these corresponds to all the files which are designated for the "Program Files (X86)" folder in IA64 environement
            PrintLine(outputFile, " <Directory Name=\"Progra~2\" LongName=\"ProgramFilesFolder\">ProgramFilesFolder");
            PrintFileList(&fileList, outputFile, TRUE, FALSE, FALSE, TRUE, flavor, binType);
            PrintLine(outputFile, " </Directory>");            
        }
    }    
    PrintLine(outputFile, "</Directory>");

    //
    //  Print module footer.
    //
    PrintLine(outputFile, "</Module>");
    
ListContents_EXIT:
    if (outputFile)
        CloseHandle(outputFile);

    return (iRet);
}

///////////////////////////////////////////////////////////////////////////////
//
//  ListComponents()
//
//  Generate the file list of each components.
//  Note that the external components are now temporarily copied to 
//  MUI\Fallback\LCID\External directory, and then their infs are executed from those 
//  places during the installation.
//
//  The uninstallation happens as before, by executing copies of it from 
//  MUI\Fallback\LCID - this means that there are now two copies of external components
//  on the target drive, but we will have to live with this for now and fix for setup in the
//  next release.
//
//  Another change to this function is that it is now SKU aware, when building for different
//  SKUs, it will check for the SKU directory (see below for example) under the root directory where
//  the external components are located in.  For CORE, it will check under the root external
//  component directory for it and use those if they exist.  If it does not exist there will be no
//  external component files for that SKU.
//
//  Here is a list of SKU directories that the function searches under for:
//
//  1. CORE: \External
//  2. Professional: \External\
//  3. StandardServer: \External\srvinf
//  4. Advanced/EnterpriseServer: \External\entinf
//  5. DatacenterServer: \External\datinf
//  6. BladeServer: \External\blainf
//  7. SmallBusinessServer: \External\sbsinf
//
//
//  The components will be parsed/scanned by looking for the component directory in the 
//  mui.inf file, and each unique component directory will be copied as is to the destination dir.
//
///////////////////////////////////////////////////////////////////////////////
int ListComponents(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType)
{
    HINF hFile;
    CHAR muiFilePath[MAX_PATH];
    CHAR muiExtCompRoot[MAX_PATH];    
    DWORD lineCount, lineNum;
    INFCONTEXT context;
    ComponentList componentList;
    Component* component;
    CHAR muiSKUDir[20];
    HRESULT hr;
    
    // 
    // check the flavour and assign the appropriate SKU subdirectory
    //
    switch (flavor)
    {
        case FLV_PROFESSIONAL:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "");
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        case FLV_SERVER:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "\\srvinf\0"); 
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        case FLV_ADVSERVER:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "\\entinf\0"); 
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        case FLV_DATACENTER:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "\\dtcinf\0"); 
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        case FLV_WEBBLADE:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "\\blainf\0"); 
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        case FLV_SMALLBUSINESS:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "\\sbsinf\0"); 
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        case FLV_CORE:
            
            hr = StringCchCopyA(muiSKUDir, sizeof (muiSKUDir) / sizeof (CHAR), "");
            if (!SUCCEEDED(hr)) {
               goto exit;
            }
            break;
        default:
            return(0);                // invalid sku specified, just exit
            break;
    }

    //
    //  Create the path to open the mui.inf file
    //
    
    hr = StringCchPrintfA(muiFilePath, ARRAYLEN(muiFilePath), "%s\\mui.inf", dirPath);
    if (!SUCCEEDED(hr)) {
         goto exit;
     }

    //
    //  Open the MUI.INF file.
    //
    hFile = SetupOpenInfFile(muiFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (-1);
    }

    //
    //  Get the number of component.
    //
    lineCount = (UINT)SetupGetLineCount(hFile, TEXT("Components"));
    if (lineCount > 0)
    {
        //
        //  Go through all component of the list.
        //
        CHAR componentName[MAX_PATH];
        CHAR componentFolder[MAX_PATH];
        CHAR componentInf[MAX_PATH];
        CHAR componentInst[MAX_PATH];
        for (lineNum = 0; lineNum < lineCount; lineNum++)
        {
            if (SetupGetLineByIndex(hFile, TEXT("Components"), lineNum, &context) &&
                SetupGetStringField(&context, 0, componentName, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 1, componentFolder, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 2, componentInf, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 3, componentInst, MAX_PATH, NULL))
            {
                //
                //  Create the components and add to the list, but only if the componentFolder is unique, since we will be copying
                //  all the files in the same component dirs we shouldn't miss anything
                //
                BOOL bUnique = TRUE;
                Component *pCIndex = NULL;
                pCIndex = componentList.getFirst();

                while (pCIndex)
                {
                    if (_strnicmp(pCIndex->getFolderName(), componentFolder, strlen(componentFolder)) == 0)
                    {
                        bUnique = FALSE;
                        break;
                    }
                    pCIndex = pCIndex->getNext();
                }
                
                if (bUnique)
                {
                    if( (component = new Component( componentName,
                                                    componentFolder,
                                                    componentInf,
                                                    componentInst)) != NULL)
                    {
                        componentList.add(component);
                    }
                }
            }
        }
    }

    //
    //  Close inf handle
    //
    SetupCloseInfFile(hFile);

    //
    //  Output component information
    //
    component = componentList.getFirst();
    while (component != NULL)
    {
        CHAR componentInfPath[MAX_PATH];
        CHAR componentPath[MAX_PATH];
        CHAR SKUSearchPath[MAX_PATH];
        CHAR searchPath[MAX_PATH];
        CHAR srcFileName[MAX_PATH];  
        CHAR dstFileName[MAX_PATH];          
        CHAR shortFileName[MAX_PATH];
        CHAR tempShortPath[MAX_PATH];
        File* file;
        HANDLE hFind;
        WIN32_FIND_DATA wfdFindData;
        BOOL bFinished = FALSE;

        //
        //  Compute the component inf path, we need to get it from the compressed version from old build
        //  e.g. C:\nt.relbins.x86fre\psu\mui\release\x86\Temp\psu\ro.mui\i386
        //
        if (binType == BIN_32)
        {

            hr = StringCchPrintfA(componentInfPath, ARRAYLEN(componentInfPath), 
                "%s\\release\\x86\\Temp\\%s\\%s.mui\\i386\\%s%s\\%s",
                     dirPath,
                     sLDirName,
                     lang,
                     component->getFolderName(),
                     muiSKUDir,                     
                     component->getInfName());
            if (!SUCCEEDED(hr)) {
                goto exit;
             }


             hr = StringCchPrintfA(componentPath, ARRAYLEN(componentPath),
                     "%s\\release\\x86\\Temp\\%s\\%s.mui\\i386\\%s%s",
                     dirPath,
                     sLDirName,
                     lang,
                     component->getFolderName(),
                     muiSKUDir);
            
            if (!SUCCEEDED(hr)) {
                goto exit;
             }

            hr = StringCchPrintfA(SKUSearchPath, ARRAYLEN(SKUSearchPath), 
                   "%s\\release\\x86\\Temp\\%s\\%s.mui\\i386\\%s",
                     dirPath,
                     sLDirName,
                     lang,
                     component->getFolderName());
            if (!SUCCEEDED(hr)) {
                goto exit;
             }
        }
        else
        {

            hr = StringCchPrintfA(componentInfPath, ARRAYLEN(componentInfPath), 
                    "%s\\release\\ia64\\Temp\\%s\\%s.mui\\ia64\\%s%s\\%s",
                     dirPath,
                     sLDirName,
                     lang,
                     component->getFolderName(),
                     muiSKUDir,                     
                     component->getInfName());
            if (!SUCCEEDED(hr)) {
                goto exit;
             }

            hr = StringCchPrintfA(componentPath, ARRAYLEN(componentPath),
                    "%s\\release\\ia64\\Temp\\%s\\%s.mui\\ia64\\%s%s",
                     dirPath,
                     sLDirName,
                     lang,
                     component->getFolderName(),
                     muiSKUDir);
            if (!SUCCEEDED(hr)) {
                goto exit;
             }

            hr = StringCchPrintfA(SKUSearchPath, ARRAYLEN(SKUSearchPath), 
                    "%s\\release\\ia64\\Temp\\%s\\%s.mui\\ia64\\%s",
                     dirPath,
                     sLDirName,
                     lang,
                     component->getFolderName());
            if (!SUCCEEDED(hr)) {
                goto exit;
             }
        }

        // if there are any other subdirectory under this component path, then the root directory files are actually 
        // for the PRO SKU, and we should not add this component to CORE
        if ((FLV_CORE == flavor) && ContainSKUDirs(SKUSearchPath))
        {
            component = component->getNext();     
            if (!bSilence)
            {
                printf("\n*** SKU subdirectory detected for this component and flavour is CORE, skipping  component. %s\n", componentInfPath);
            }
            continue;
        }

        // if there are no other subdirectory under this component path, then the root directory files are actually 
        // for the CORE SKU, and we should not add this component to PRO
        // this is one compromise we have to make right now since the NT SKU subdirs does not give us the ability to distinguish
        // between PRO SKU and something that is for every platform
        if ((FLV_PROFESSIONAL == flavor) && !ContainSKUDirs(SKUSearchPath))
        {
            component = component->getNext();        
            if (!bSilence)
            {
                printf("\n*** SKU subdirectory not detected for this component and flavour is PRO, skipping component. %s\n", componentInfPath);
            }
            continue;
        }

        // form the temp component path on the target
        
        hr = StringCchPrintfA(muiExtCompRoot, ARRAYLEN(muiExtCompRoot), "MUI\\FALLBACK\\%04x\\External\\%s", gBuildNumber, component->getFolderName());
        if (!SUCCEEDED(hr)) {
              goto exit;
         }
            
        hr = StringCchPrintfA(searchPath, ARRAYLEN(searchPath), "%s\\*.*", componentPath);
        if (!SUCCEEDED(hr)) {
            goto exit;
         }
        
        if (!bSilence)
        {
            printf("\n*** Source component inf path is %s\n", componentInfPath);
            printf("\n*** Source component folder path is %s\n", componentPath);            
            printf("\n*** Destination directory for this component is %s\n", muiExtCompRoot);
        }

        //  Get a list of all the files in the component folder
        hFind = FindFirstFile(searchPath, &wfdFindData);

        if (hFind == INVALID_HANDLE_VALUE)
        {
            if (!bSilence)
            {
                printf("\n*** No files found in the component directory %s\n", muiExtCompRoot);
            }
            component = component->getNext();            
            continue;       // skip this component
        }
        else
        {
            bFinished = FALSE;
            while (!bFinished)
            {
                // only process files, not directories
                if ((wfdFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    if (!bSilence)
                    {
                        printf("\n*** Filename is %s\n", wfdFindData.cFileName);
                        printf("\n*** Alternate Filename is %s\n", wfdFindData.cAlternateFileName);                        
                    }
                    
                    hr = StringCchCopyA(srcFileName, ARRAYLEN(srcFileName), wfdFindData.cFileName);
                    if (!SUCCEEDED(hr)) {
                        goto exit;
                    }

                    if (!(wfdFindData.cAlternateFileName) || (strlen(wfdFindData.cAlternateFileName) == 0))
                    {
                        hr = StringCchCopyA(shortFileName, ARRAYLEN(shortFileName), wfdFindData.cFileName);
                         if (!SUCCEEDED(hr)) {
                             goto exit;
                         }
                    }
                    else
                    {
                        hr = StringCchCopyA(shortFileName, ARRAYLEN(shortFileName), wfdFindData.cAlternateFileName);
                        if (!SUCCEEDED(hr)) {
                             goto exit;
                         }
                    }


                    // here, we also need to rename all the files that ends with a .mui extension to .mu_ - since the infs are
                    // expecting this.
//                    RenameMuiExtension(shortFileName);

                    hr = StringCchCopyA(dstFileName, ARRAYLEN(dstFileName), srcFileName);
                    if (!SUCCEEDED(hr)) {
                             goto exit;
                     }
                    
//                    RenameMuiExtension(dstFileName);                    
                    if ((file = new File(shortFileName,
                                        muiExtCompRoot,
                                        dstFileName,
                                        componentPath,
                                        srcFileName,
                                        10)) != NULL)
                    {
                        dirList->add(file);
                    }
                }                
                else
                {
                    if (!bSilence)
                    {
                        printf("\n*** Found a directory in the component dir %s\n", wfdFindData.cFileName);
                    }
                }
                
                if (!FindNextFile(hFind, &wfdFindData))
                {
                    bFinished = TRUE; 
                }
            }
        }

        //
        // Next Component
        //
        component = component->getNext();

    }

    return 0;
exit:
    printf("Error in ListComponents\n");
    return 1;
    
}


///////////////////////////////////////////////////////////////////////////////
//
//  ListMuiFiles()
//
//  Generate the file list for MUI.
//
///////////////////////////////////////////////////////////////////////////////
int ListMuiFiles(FileList *dirList, LPSTR dirPath, LPSTR lang, DWORD flavor, DWORD binType)
{
    HINF hFile;
    CHAR muiFilePath[MAX_PATH];
    CHAR muiFileSearchPath[MAX_PATH];
    int lineCount, lineNum, fieldCount;
    INFCONTEXT context;
    FileLayoutExceptionList exceptionList;
    WIN32_FIND_DATA findData;
    HANDLE fileHandle;
    File* file;
    HRESULT hr;

    //
    //  Create the path to open the mui.inf file
    //
    
     hr = StringCchPrintfA(muiFilePath, ARRAYLEN(muiFilePath), "%s\\mui.inf", dirPath);
     if (!SUCCEEDED(hr)) {
          goto exit;
      }
        

    //
    //  Open the MUI.INF file.
    //
    hFile = SetupOpenInfFile(muiFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (-1);
    }

    //
    //  Get the number of file exception.
    //
    lineCount = (UINT)SetupGetLineCount(hFile, TEXT("File_Layout"));
    if (lineCount > 0)
    {
        //
        //  Go through all file exception of the list.
        //
        CHAR originFilename[MAX_PATH];
        CHAR destFilename[MAX_PATH];
        CHAR fileFlavor[30];
        DWORD dwFlavor;
        for (lineNum = 0; lineNum < lineCount; lineNum++)
        {
            if (SetupGetLineByIndex(hFile, TEXT("File_Layout"), lineNum, &context) &&
                (fieldCount = SetupGetFieldCount(&context)))
            {
                if (SetupGetStringField(&context, 0, originFilename, MAX_PATH, NULL) &&
                    SetupGetStringField(&context, 1, destFilename, MAX_PATH, NULL))
                {
                    FileLayout* fileException;

                    dwFlavor = 0;
                    for(int fieldId = 2; fieldId <= fieldCount; fieldId++)
                    {
                        if(SetupGetStringField(&context, fieldId, fileFlavor, MAX_PATH, NULL))
                        {
                            switch(*fileFlavor)
                            {
                            case('p'):
                            case('P'):
                                    dwFlavor |= FLV_PROFESSIONAL;
                                    break;
                            case('s'):
                            case('S'):
                                    dwFlavor |= FLV_SERVER;
                                    break;
                            case('d'):
                            case('D'):
                                    dwFlavor |= FLV_DATACENTER;
                                    break;
                            case('a'):
                            case('A'):
                                    dwFlavor |= FLV_ADVSERVER;
                                    break;
                            case('b'):
                            case('B'):
                                    dwFlavor |= FLV_WEBBLADE;
                                    break;
                            case('l'):
                            case('L'):
                                    dwFlavor |= FLV_SMALLBUSINESS;
                                    break;
                            }

                        }
                    }

                    //
                    //  Add only information needed for this specific flavor.
                    //
                    fileException = new FileLayout(originFilename, destFilename, dwFlavor);
                    exceptionList.insert(fileException);
                }
            }
        }
    }

    //
    //  Close inf handle
    //
    SetupCloseInfFile(hFile);

    //
    //  Compute the binary source path.
    //
    if (binType == BIN_32)
    {
        
        hr = StringCchPrintfA(muiFileSearchPath, ARRAYLEN(muiFileSearchPath), "%s\\%s\\i386.uncomp", dirPath, lang);
        if (!SUCCEEDED(hr)) {
              goto exit;
          }
        
        hr = StringCchPrintfA(muiFilePath, ARRAYLEN(muiFilePath), "%s\\%s\\i386.uncomp\\*.*", dirPath, lang);
        if (!SUCCEEDED(hr)) {
              goto exit;
          }
    }
    else
    {
        
        hr = StringCchPrintfA(muiFileSearchPath, ARRAYLEN(muiFileSearchPath), "%s\\%s\\ia64.uncomp", dirPath, lang);
        if (!SUCCEEDED(hr)) {
              goto exit;
          }
        
        hr = StringCchPrintfA(muiFilePath, ARRAYLEN(muiFilePath), "%s\\%s\\ia64.uncomp\\*.*", dirPath, lang);
        if (!SUCCEEDED(hr)) {
              goto exit;
          }
    }

    //
    //  Scan uncomp source directory for file information
    //
    if ((fileHandle = FindFirstFile(muiFilePath, &findData)) != INVALID_HANDLE_VALUE)
    {
        //
        //  Look for files
        //
        do
        {
            LPSTR extensionPtr;
            INT dirIdentifier = 0;
            CHAR destDirectory[MAX_PATH] = {0};
            CHAR destName[MAX_PATH] = {0};
            FileLayout* fileException = NULL;

            //
            //  Scan only files at this level.
            //
            if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                continue;
            }

            //
            // Search the extension to determine the destination location and possibly
            // exclude file destined for Personal.
            //
            if ((extensionPtr = strrchr(findData.cFileName, '.')) != NULL)
            {
                if( (_tcsicmp(extensionPtr, TEXT(".chm")) == 0) ||
                    (_tcsicmp(extensionPtr, TEXT(".chq")) == 0) ||
                    (_tcsicmp(extensionPtr, TEXT(".cnt")) == 0) ||
                    (_tcsicmp(extensionPtr, TEXT(".hlp")) == 0))
                {
                    dirIdentifier = 18;
                    
                    hr = StringCchPrintfA(destDirectory, ARRAYLEN(destDirectory), "MUI\\%04x", gBuildNumber);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                      }
                }
                else if (_tcsicmp(extensionPtr, TEXT(".mfl")) == 0)
                {
                    dirIdentifier = 11;
                    
                    hr = StringCchPrintfA(destDirectory, ARRAYLEN(destDirectory), "wbem\\MUI\\%04x", gBuildNumber);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                      }
                }
                else if (_tcsicmp(findData.cFileName, TEXT("hhctrlui.dll")) == 0)
                {
                    dirIdentifier = 11;
                    
                    hr = StringCchPrintfA(destDirectory, ARRAYLEN(destDirectory), "MUI\\%04x", gBuildNumber);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                      }
                }
                else
                {
                    dirIdentifier = 10;
                    
                    hr = StringCchPrintfA(destDirectory, ARRAYLEN(destDirectory), "MUI\\FALLBACK\\%04x", gBuildNumber);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                      }
                }
            }


            // 
            // We need to remove the .MUI extension before passing the filename to search in the
            // mui.inf file rename section
            //
            CHAR strTemp[MAX_PATH];
            BOOL bBinaryFile = FALSE;
            hr = StringCchCopyA(strTemp, ARRAYLEN(strTemp), findData.cFileName);
            if (!SUCCEEDED(hr)){
                goto exit;
            }

            // remove the extension .mui if it is there
            if ((extensionPtr = strrchr(strTemp, '.')) != NULL)
            {
                if (_tcsicmp(extensionPtr, TEXT(".mui")) == 0)
                {
                    *extensionPtr = NULL;
                    bBinaryFile = TRUE;
                }
            }

            //
            //  Search for different destination name in the exception list.
            //
            if ((fileException = exceptionList.search(strTemp)) != NULL )
            {
                if (!bSilence)
                {
                    printf("Source file %s exists in mui.inf.\n", findData.cFileName);
                }
                //
                //  Verify it's the needed flavor
                //  also check that it's not in every flavour if we are not 
                //  building CORE merge modules
                //
                if ((fileException->isFlavor(flavor)) && 
                    !((flavor != FLV_CORE) &&
                    (fileException->isFlavor(FLV_ADVSERVER)) &&
                    (fileException->isFlavor(FLV_SERVER)) &&
                    (fileException->isFlavor(FLV_DATACENTER)) &&
                    (fileException->isFlavor(FLV_WEBBLADE)) &&
                    (fileException->isFlavor(FLV_SMALLBUSINESS))))
                {
                    if (!bSilence)
                    {
                        printf("Flavor is not CORE, Source file %s is for the specified SKU.\n", findData.cFileName);
                    }
                    
                    if (bBinaryFile)
                    {
                        hr = StringCchPrintfA(destName, ARRAYLEN(destName), "%s.mui", fileException->getDestFileName());
                    }
                    else
                    {
                        hr = StringCchPrintfA(destName, ARRAYLEN(destName), "%s", fileException->getDestFileName());
                    }

                    if (!SUCCEEDED(hr))
                    {
                        goto exit;
                    }
                }
                else if ((flavor == FLV_CORE) &&
                    (fileException->isFlavor(FLV_ADVSERVER)) &&
                    (fileException->isFlavor(FLV_SERVER)) &&
                    (fileException->isFlavor(FLV_DATACENTER)) &&
                    (fileException->isFlavor(FLV_WEBBLADE)) &&
                    (fileException->isFlavor(FLV_SMALLBUSINESS)))
                {
                    if (!bSilence)
                    {
                        printf("Flavor is CORE, Source file %s is in every SKU.\n", findData.cFileName);
                    }
                    
                    if (bBinaryFile)
                    {
                        hr = StringCchPrintfA(destName, ARRAYLEN(destName), "%s.mui", fileException->getDestFileName());
                    }
                    else
                    {
                        hr = StringCchPrintfA(destName, ARRAYLEN(destName), "%s", fileException->getDestFileName());
                    }

                    if (!SUCCEEDED(hr))
                    {
                        goto exit;
                    }
                    
                }
                else
                {
                    if (!bSilence)
                    {
                        printf("Source file %s (destination name %s) is not in this SKU.\n", findData.cFileName, fileException->getDestFileName() ? fileException->getDestFileName() : findData.cFileName);
                    }
                    //
                    //  Skip the file. Not need in this flavor.
                    //
                    continue;
                }
            }
            else
            {
                CHAR strOrigName[MAX_PATH];
                hr = StringCchCopyA(strOrigName, ARRAYLEN(strOrigName), findData.cFileName);
                if (!SUCCEEDED(hr)){
                    goto exit;
                }

                // remove the extension .mui if it is there
                if ((extensionPtr = strrchr(strOrigName, '.')) != NULL)
                {
                    if (_tcsicmp(extensionPtr, TEXT(".mui")) == 0)
                    {
                        *extensionPtr = NULL;
                        if (!bSilence)
                        {
                            printf("Filename is %s, original filename is %s.\n", findData.cFileName, strOrigName);
                        }
                    }
                }
            
                if (IsFileForSKU(strOrigName, flavor, binType, &exceptionList))
                {                    
                    hr = StringCchCopyA(destName, ARRAYLEN(destName), findData.cFileName);
                    if (!SUCCEEDED(hr)){
                        goto exit;
                    }
                }
                else
                {
                    continue;
                }
            }

            //
            //  Create a file 
            //
            CHAR sfilename[MAX_PATH]; 
            GetFileShortName(destName, sfilename, FALSE);
            
            if (file = new File(sfilename,
                                destDirectory,
                                destName,
                                muiFileSearchPath,
                                findData.cFileName,
                                dirIdentifier))
            {
                dirList->add(file);
            }
        }
        while (FindNextFile(fileHandle, &findData));

        FindClose(fileHandle);
    }

    return 0;
exit:
    printf("Error in ListMuiFiles\n");
    return 1;
}


///////////////////////////////////////////////////////////////////////////////
//
//  ValidateLanguage()
//
//  Verify if the language given is valid and checks is the files are 
//  available.
//
///////////////////////////////////////////////////////////////////////////////
BOOL ValidateLanguage(LPSTR dirPath, LPSTR langName, DWORD binType)
{
    CHAR langPath[MAX_PATH] = {0};
    HRESULT hr;

    //
    //  Check if the binary type in order to determine the right path.
    //
    if (binType == BIN_32)
    {
        
        hr = StringCchPrintfA(langPath, ARRAYLEN(langPath), "%s\\%s\\i386.uncomp", dirPath, langName);
        if (!SUCCEEDED(hr)) {
              goto exit;
          }
        
    }
    else
    {
        
        hr = StringCchPrintfA(langPath, ARRAYLEN(langPath), "%s\\%s\\ia64.uncomp", dirPath, langName);
        if (!SUCCEEDED(hr)) {
              goto exit;
          }
    }

    return (DirectoryExist(langPath));
exit:
    printf("Error in ValidateLanguage \n");
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  DirectoryExist()
//
//  Verify if the given directory exists and contains files.
//
///////////////////////////////////////////////////////////////////////////////
BOOL DirectoryExist(LPSTR dirPath)
{
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle;

    //
    //  Sanity check.
    //
    if (dirPath == NULL)
    {
        return FALSE;
    }

    //
    //  See if the language group directory exists.
    //
    FindHandle = FindFirstFile(dirPath, &FindData);
    if (FindHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(FindHandle);
        if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            //
            //  Return success.
            //
            return (TRUE);
        }
    }

    //
    //  Return failure.
    //
    if (!bSilence)
    {
        printf("ERR[%s]: No files found in the directory.\n", dirPath);
    }

    return (FALSE);
}


///////////////////////////////////////////////////////////////////////////////
//
//  ConvertLanguage()
//
//  Look into mui.inf file for the corresponding language identifier.
//
///////////////////////////////////////////////////////////////////////////////
WORD ConvertLanguage(LPSTR dirPath, LPSTR langName)
{
    HINF hFile;
    CHAR muiFilePath[MAX_PATH];
    CHAR muiLang[30];
    UINT lineCount, lineNum;
    INFCONTEXT context;
    DWORD langId = 0x00000000;
    HRESULT hr;

    //
    //  Create the path to open the mui.inf file
    //
    
    hr = StringCchPrintfA(muiFilePath, ARRAYLEN(muiFilePath), "%s\\mui.inf", dirPath);
    if (!SUCCEEDED(hr)) {
          goto exit;
     }
    
    
    hr = StringCchPrintfA(muiLang, ARRAYLEN(muiLang), "%s.MUI", langName);
    if (!SUCCEEDED(hr)) {
          goto exit;
     }

    //
    //  Open the MUI.INF file.
    //
    hFile = SetupOpenInfFile(muiFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return (0x0000);
    }

    //
    //  Get the number of Language.
    //
    lineCount = (UINT)SetupGetLineCount(hFile, TEXT("Languages"));
    if (lineCount > 0)
    {
        //
        //  Go through all language of the list to find a .
        //
        CHAR langID[MAX_PATH];
        CHAR name[MAX_PATH];
        for (lineNum = 0; lineNum < lineCount; lineNum++)
        {
            if (SetupGetLineByIndex(hFile, TEXT("Languages"), lineNum, &context) &&
                SetupGetStringField(&context, 0, langID, MAX_PATH, NULL) &&
                SetupGetStringField(&context, 1, name, MAX_PATH, NULL))
            {
                if ( _tcsicmp(name, muiLang) == 0)
                {
                    langId = TransNum(langID);
                    SetupCloseInfFile(hFile);
                    return (WORD)(langId);
                }
            }
        }
    }

    //
    //  Close inf handle
    //
    SetupCloseInfFile(hFile);
exit:
    printf("Error in CovnertLanguage \n");
    return (0x0000);

}


////////////////////////////////////////////////////////////////////////////
//
//  PrintFileList
//
//  Print a file list in XML format.
//
////////////////////////////////////////////////////////////////////////////
void PrintFileList(FileList* list, HANDLE hFile, BOOL compressed, BOOL bWinDir, BOOL bPermanent, BOOL bX86OnIA64, DWORD flavor, DWORD binType)
{
    CHAR szSKUCondition[4096];   
    CHAR szIsWin64[4];
    BOOL bPrintCondition = GetSKUConditionString(szSKUCondition, flavor);
    HRESULT hr;

    if (binType == BIN_32)
    {
        hr = StringCchCopyA(szIsWin64, ARRAYLEN(szIsWin64),"no");
    }
    else
    {
        hr = StringCchCopyA(szIsWin64, ARRAYLEN(szIsWin64),"yes");
    }
    
    if (compressed)
    {
        File* item;
        CHAR  itemDescription[4096];
        CHAR  spaces[30];
        int j;
    
        item = list->getFirst();
        while (item != NULL)
        {
            LPSTR refDirPtr = NULL;
            LPSTR dirPtr = NULL;
            CHAR dirName[MAX_PATH];
            CHAR dirName2[MAX_PATH];
            CHAR dirObjectName[MAX_PATH+1];
            LPSTR dirPtr2 = NULL;
            LPSTR dirLvlPtr = NULL;
            INT dirLvlCnt = 0;
            BOOL componentInit = FALSE;
            BOOL directoryInit = FALSE;
            Uuid* uuid;
            File* toBeRemoved;
            CHAR fileObjectName[MAX_PATH+1];
            UINT matchCount; 


            //
            //  Check destination directory.
            //
            if (item->isWindowsDir() != bWinDir)
            {
                item = item->getNext();
                continue;
            }

            //
            //  Check if the destination directory is base dir
            //
            if (*(item->getDirectoryDestination()) == '\0')
            {
                //
                //  Component
                //
                uuid = new Uuid();
                for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                if (FALSE == bPermanent) {
                    
                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                 }
                else {
                    
                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription),  "%s<Component Id='%s' Permanent='yes' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);                    
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                }
                delete uuid;
                PrintLine(hFile, itemDescription);

                // print a condition line for this component, if needed
                if (TRUE == bPrintCondition)
                {
                    PrintLine(hFile, szSKUCondition);
                }

                //
                //  File
                //
                for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                removeSpace(item->getName(), fileObjectName);
                ReplaceInvalidChars(fileObjectName);
        
                hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription),  
                        "%s<File Name=\"%s\" LongName=\"%s\" src=\"%s\\%s\">_%s.%x.%i</File>",
                         spaces,
                         item->getShortName(),
                         item->getName(),
                         item->getSrcDir(),
                         item->getSrcName(),
                         fileObjectName,
                         flavor,
                         dwComponentCounter);
                
                if (!SUCCEEDED(hr)) {
                      goto exit;
                 }
                PrintLine(hFile, itemDescription);

                //
                // </Component>
                //
                for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                
                hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription),  "%s</Component>", spaces);
                if (!SUCCEEDED(hr)) {
                      goto exit;
                 }
                    
                PrintLine(hFile, itemDescription);
                dwComponentCounter++;

                toBeRemoved = item;
                item = item->getNext();
                list->remove(toBeRemoved);
                continue;
            }

            //
            // Print directory
            //
            
            hr = StringCchCopyA(dirName, ARRAYLEN(dirName), item->getDirectoryDestination());
            if(!SUCCEEDED(hr)) {
                goto exit;
            }

            
            dirPtr = dirName;
            refDirPtr = dirPtr;

            CHAR sdirname[MAX_PATH];                 
            while (dirPtr != NULL)
            {           
                dirLvlPtr = strchr(dirPtr, '\\');
                if (dirLvlPtr != NULL)
                {                
                    *dirLvlPtr = '\0';                   
                    for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    
                    hr = StringCchCopyA(dirObjectName, ARRAYLEN(dirObjectName),dirPtr);
                    if(!SUCCEEDED(hr)) {
                        goto exit;
                    }
                    ReplaceInvalidChars(dirObjectName);  
                    GetFileShortName(dirPtr, sdirname, FALSE);                 


                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Directory Name=\"%s\" LongName=\"%s\">_%s%i", spaces, sdirname, dirPtr, dirObjectName, dwDirectoryCounter);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                    dwDirectoryCounter++;
                    PrintLine(hFile, itemDescription);
                    dirPtr = dirLvlPtr + 1;
                    dirLvlCnt++;

                    //
                    // Print all file under this specific directory
                    //
                    
                    hr = StringCchCopyA(dirName2, ARRAYLEN(dirName2), item->getDirectoryDestination());
                    if(!SUCCEEDED(hr)) {
                        goto exit;
                    }
                    dirName2[dirLvlPtr-refDirPtr] = '\0';
                    File* sameLvlItem = NULL;
                    matchCount = 0;
                    while((sameLvlItem = list->search(item, dirName2)) != NULL)
                    {
                        //
                        //  Component
                        //
                        if (!componentInit)
                        {
                            uuid = new Uuid();
                            for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                            if (FALSE == bPermanent) {

                                hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);
                                if (!SUCCEEDED(hr)) {
                                      goto exit;
                                 }
                            }
                            else{
                                
                                hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Permanent='yes' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);                                
                                if (!SUCCEEDED(hr)) {
                                      goto exit;
                                 }
                            }
                            delete uuid;
                            PrintLine(hFile, itemDescription);
                            dwComponentCounter++;
                            componentInit = TRUE;

                            // print a condition line for this component, if needed
                            if (TRUE == bPrintCondition)
                            {
                                PrintLine(hFile, szSKUCondition);
                            }

                        }

                        //
                        //  File
                        //
                        matchCount++;
                        for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        removeSpace(sameLvlItem->getName(), fileObjectName);
                        ReplaceInvalidChars(fileObjectName);

                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), 
                                "%s<File Name=\"%s\" LongName=\"%s\" src=\"%s\\%s\">_%s.%x.%i</File>",
                                 spaces,
                                 sameLvlItem->getShortName(),
                                 sameLvlItem->getName(),
                                 sameLvlItem->getSrcDir(),
                                 sameLvlItem->getSrcName(),
                                 fileObjectName,
                                 flavor,
                                 dwComponentCounter);

                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }

                       PrintLine(hFile, itemDescription);

                        list->remove(sameLvlItem);
                    }

// kenhsu -this is incorrect, the file we are looking at may be deeper in the directory structure, we shouldn't print it out here
// until we have finished recursing its destination directory.
/*                    if (matchCount)
                    {
                        //
                        //  File
                        //
                        for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        removeSpace(item->getName(), fileObjectName);
                        ReplaceInvalidChars(fileObjectName);                        
                        sprintf( itemDescription,
                                 "%s<File Name=\"%s\" LongName=\"%s\" src=\"%s\\%s\">%s.%i</File>",
                                 spaces,
                                 item->getShortName(),
                                 item->getName(),
                                 item->getSrcDir(),
                                 item->getSrcName(),
                                 fileObjectName,
                                 dwComponentCounter);
                        PrintLine(hFile, itemDescription);
                        dirPtr = NULL;
                    }
*/
                    //
                    //  Close component
                    //
                    if (componentInit)
                    {
                        for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Component>", spaces);
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                                
                        PrintLine(hFile, itemDescription);
                        componentInit = FALSE;
                    }

                    //
                    //  Close directory
                    //
                    if (directoryInit)
                    {
                        dirLvlCnt--;
                        for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Directory>", spaces);
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                        
                        PrintLine(hFile, itemDescription);
                        directoryInit = FALSE;
                    }
                }
                else
                {
                    if (!directoryInit)
                    {                       
                        for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        
                        hr = StringCchCopyA(dirObjectName, ARRAYLEN(dirObjectName), dirPtr);
                        if(!SUCCEEDED(hr)) {
                            goto exit;
                        }
                    
                        ReplaceInvalidChars(dirObjectName);        
                        GetFileShortName(dirPtr, sdirname, FALSE);                 
                        
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Directory Name=\"%s\" LongName=\"%s\">_%s%i", spaces, sdirname, dirPtr, dirObjectName, dwDirectoryCounter);
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                        
                        dwDirectoryCounter++;
                        PrintLine(hFile, itemDescription);
                        dirLvlCnt++;
                        directoryInit = TRUE;
                    }

                    //
                    //  Component
                    //
                    if (!componentInit)
                    {
                        uuid = new Uuid();
                        for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        if (FALSE == bPermanent) {
                            
                            hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);
                            if (!SUCCEEDED(hr)) {
                                  goto exit;
                             }
                         }
                        else {
                            
                            hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Permanent='yes' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);                            
                            if (!SUCCEEDED(hr)) {
                                  goto exit;
                             }
                         }
                        delete uuid;
                        PrintLine(hFile, itemDescription);
                        componentInit = TRUE;

                        // print a condition line for this component, if needed
                        if (TRUE == bPrintCondition)
                        {
                            PrintLine(hFile, szSKUCondition);
                        }
                        
                    }

                    //
                    // Print all file under this specific directory
                    //
                    File* sameLvlItem;
                    while((sameLvlItem = list->search(item, item->getDirectoryDestination())) != NULL)
                    {
                        //
                        //  File
                        //
                        for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        removeSpace(sameLvlItem->getName(), fileObjectName);
                        ReplaceInvalidChars(fileObjectName);        

                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), 
                                "%s<File Name=\"%s\" LongName=\"%s\" src=\"%s\\%s\">_%s.%x.%i</File>",
                                 spaces,
                                 sameLvlItem->getShortName(),
                                 sameLvlItem->getName(),
                                 sameLvlItem->getSrcDir(),
                                 sameLvlItem->getSrcName(),
                                 fileObjectName,
                                 flavor,
                                 dwComponentCounter);
                        
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                            
                        PrintLine(hFile, itemDescription);

                        list->remove(sameLvlItem);
                    }

                    //
                    //  File
                    //
                    for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    removeSpace(item->getName(), fileObjectName);
                    ReplaceInvalidChars(fileObjectName);     
                           
                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), 
                                "%s<File Name=\"%s\" LongName=\"%s\" src=\"%s\\%s\">_%s.%x.%i</File>",
                             spaces,
                             item->getShortName(),
                             item->getName(),
                             item->getSrcDir(),
                             item->getSrcName(),
                             fileObjectName,
                             flavor,
                             dwComponentCounter);
                        
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                        
                    PrintLine(hFile, itemDescription);
                    dwComponentCounter++;
                    dirPtr = NULL;

                    //
                    //  Close component
                    //
                    if (componentInit)
                    {
                        for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Component>", spaces);
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                        
                        PrintLine(hFile, itemDescription);
                        componentInit = FALSE;
                    }

                    //
                    //  Close directory
                    //
                    if (directoryInit)
                    {
                        dirLvlCnt--;
                        for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                        
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Directory>", spaces);
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                        PrintLine(hFile, itemDescription);
                        directoryInit = FALSE;
                    }
                }
            }

            for (int i = dirLvlCnt; i > 0; i--)
            {
                spaces[i] = '\0';
                
                hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Directory>", spaces);
                if (!SUCCEEDED(hr)) {
                      goto exit;
                 }
                PrintLine(hFile, itemDescription);
            }

            if (list->getFileNumber() > 1)
            {
                if (item->getNext() != NULL)
                {
                    item = item->getNext();
                    list->remove(item->getPrevious());
                }
                else
                {
                    list->remove(item);
                    item = NULL;
                }
            }
            else
            {
                list->remove(item);
                item = NULL;
            }
        }
    }
    else
    {
        File* item;
        CHAR  itemDescription[4096];
        CHAR dirObjectName[MAX_PATH+1];        
        CHAR sdirname[MAX_PATH];
        CHAR  spaces[30];
        int j;
    
        item = list->getFirst();
        while (item != NULL)
        {
            LPSTR dirPtr = NULL;
            LPSTR dirLvlPtr = NULL;
            INT dirLvlCnt = 0;

            //
            // Print directory
            //
            dirPtr = item->getDirectoryDestination();
            while (dirPtr != NULL)
            {
                dirLvlPtr = strchr(dirPtr, '\\');
                if (dirLvlPtr != NULL)
                {
                    *dirLvlPtr = '\0';
                    for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    
                    hr = StringCchCopyA(dirObjectName, ARRAYLEN(dirObjectName), dirPtr);
                    if(!SUCCEEDED(hr)) {
                        goto exit;
                    }
                        
                    ReplaceInvalidChars(dirObjectName);  
                    GetFileShortName(dirPtr, sdirname, FALSE);                                 
                    
                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Directory Name=\"%s\" LongName=\"%s\">_%s%i", spaces, sdirname, dirPtr, dirObjectName, dwDirectoryCounter);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                    dwDirectoryCounter++;
                    PrintLine(hFile, itemDescription);
                    dirPtr = dirLvlPtr + 1;
                    dirLvlCnt++;
                }
                else
                {
                    Uuid* uuid = new Uuid();

                    for (j = -1; j < dirLvlCnt; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    
                    hr = StringCchCopyA(dirObjectName, ARRAYLEN(dirObjectName), dirPtr);
                    if(!SUCCEEDED(hr)) {
                        goto exit;
                    }
                    
                    ReplaceInvalidChars(dirObjectName);                                                                   
                    GetFileShortName(dirPtr, sdirname, FALSE);                                 
                    
                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Directory Name=\"%s\" LongName=\"%s\">_%s%i", spaces, sdirname, dirPtr, dirObjectName, dwDirectoryCounter);
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                    
                    dwDirectoryCounter++;
                    PrintLine(hFile, itemDescription);
                    dirLvlCnt++;

                    //
                    //  Component
                    //
                    for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    if (FALSE == bPermanent) {
                       
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                    }
                    else {
                        
                        hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s<Component Id='%s' Permanent='yes' Win64='%s'>Content%x.%i", spaces, uuid->getString(), szIsWin64, flavor, dwComponentCounter);                        
                        if (!SUCCEEDED(hr)) {
                              goto exit;
                         }
                    }
                    delete uuid;
                    PrintLine(hFile, itemDescription);

                    // print a condition line for this component, if needed
                    if (TRUE == bPrintCondition)
                    {
                        PrintLine(hFile, szSKUCondition);
                    }

                    //
                    //  File
                    //
                    for (j = -1; j < dirLvlCnt+2; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
                    CHAR fileObjectName[MAX_PATH+1];
                    removeSpace(item->getName(), fileObjectName);
                    ReplaceInvalidChars(fileObjectName);         

                    hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), 
                            "%s<File Name=\"%s\" LongName=\"%s\" src=\"%s\\%s\">_%s.%x.%i</File>",
                             spaces,
                             item->getShortName(),
                             item->getName(),
                             item->getSrcDir(),
                             item->getSrcName(),
                             fileObjectName,
                             flavor,
                             dwComponentCounter);
                    
                    if (!SUCCEEDED(hr)) {
                          goto exit;
                     }
                        
                    PrintLine(hFile, itemDescription);
                    dwComponentCounter++;
                    dirPtr = NULL;
                }
            }

            for (j = -1; j < dirLvlCnt+1; j++) {spaces[j+1] = ' '; spaces[j+2] =  '\0';}
            hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Component>", spaces);            
            if (!SUCCEEDED(hr)) {
                  goto exit;
             }
            PrintLine(hFile, itemDescription);
            for (int i = dirLvlCnt; i > 0; i--)
            {
                spaces[i] = '\0';
                
                hr = StringCchPrintfA(itemDescription, ARRAYLEN(itemDescription), "%s</Directory>", spaces);
                if (!SUCCEEDED(hr)) {
                      goto exit;
                 }
                PrintLine(hFile, itemDescription);
            }

            item = item->getNext();
        }
    }
    return;
/****************** DEBUG ******************
    File* item;
    CHAR  itemDescription[4096];

    item = list->getFirst();
    while (item != NULL)
    {
        //
        //  Item description
        //
        sprintf(itemDescription,
                "  Source: %s\\%s",
                item->getSrcDir(),
                item->getSrcName());
        PrintLine(hFile, itemDescription);
        sprintf(itemDescription,
                "  Destination: %s\\%s",
                item->getDirectoryDestination(),
                item->getName());
        PrintLine(hFile, itemDescription);
        PrintLine(hFile, "");

        item = item->getNext();
    }
****************** DEBUG ******************/
exit:
    printf("Error in PrintFileList\n");
    return;

}


////////////////////////////////////////////////////////////////////////////
//
//  PrintLine
//
//  Add a line at the end of the file.
//
////////////////////////////////////////////////////////////////////////////
BOOL PrintLine(HANDLE hFile, LPCSTR lpLine)
{
    DWORD dwBytesWritten;

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile( hFile,
               lpLine,
               _tcslen(lpLine) * sizeof(TCHAR),
               &dwBytesWritten,
               NULL );

    SetFilePointer(hFile, 0, NULL, FILE_END);

    WriteFile( hFile,
               TEXT("\r\n"),
               _tcslen(TEXT("\r\n")) * sizeof(TCHAR),
               &dwBytesWritten,
               NULL );

    return (TRUE);
}


///////////////////////////////////////////////////////////////////////////////
//
//  CreateOutputFile()
//
//  Create the file that would received the package file contents.
//
///////////////////////////////////////////////////////////////////////////////
HANDLE CreateOutputFile(LPSTR filename)
{
    SECURITY_ATTRIBUTES SecurityAttributes;

    //
    //  Sanity check.
    //
    if (filename == NULL)
    {
        return INVALID_HANDLE_VALUE;
    }

    //
    //  Create a security descriptor the output file.
    //
    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = FALSE;

    //
    //  Create the file.
    //
    return CreateFile( filename,
                       GENERIC_WRITE,
                       0,
                       &SecurityAttributes,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );
}


////////////////////////////////////////////////////////////////////////////
//
//  removeSpace
//
//  Remove all space from a string.
//
////////////////////////////////////////////////////////////////////////////
VOID removeSpace(LPSTR src, LPSTR dest)
{
    LPSTR strSrcPtr = src;
    LPSTR strDestPtr = dest;

    while (*strSrcPtr != '\0')
    {
        if (*strSrcPtr != ' ')
        {
            *strDestPtr = *strSrcPtr;
            strDestPtr++;
        }
        strSrcPtr++;
    }
    *strDestPtr = '\0';
}


////////////////////////////////////////////////////////////////////////////
//
//  TransNum
//
//  Converts a number string to a dword value (in hex).
//
////////////////////////////////////////////////////////////////////////////
DWORD TransNum(LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;

    while (*lpsz)
    {
        c = *lpsz++;

        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}


///////////////////////////////////////////////////////////////////////////////
//
//  Usage
//
//  Print the fonction usage.
//
///////////////////////////////////////////////////////////////////////////////
void Usage()
{
    printf("Create Merge module MUI WXM files for different OS SKUs\n");
    printf("Usage: infparser /p:[cdlaout] /b:[32|64] /l:<lang> /f:[p|s|a|d] /s:<dir> /o:<file> /v\n");
    printf("   where\n");
    printf("     /p means the pseudo cd layout directory.\n");
    printf("         <cdlayout>: is cd layout directory in mui release share, e.g. cd1 (for jpn), or psu (for psu)\n");    
    printf("     /b means the binary.\n");
    printf("         32: i386\n");
    printf("         64: ia64\n");
    printf("     /l means the language flag.\n");
    printf("         <lang>: is the target language\n");
    printf("     /f means the flavor.\n");
    printf("         p: Professional\n");
    printf("         s: Server\n");
    printf("         a: Advanced Server\n");
    printf("         d: Data Center\n");
    printf("         l: Server for Small Business Server\n");    
    printf("         w: Web Blade\n");
    printf("     /i means the location of the localized binairy files.\n");
    printf("         <dir>: Fully qualified path\n");
    printf("     /s means the location of the binairy data.\n");
    printf("         <dir>: Fully qualified path\n");
    printf("     /o means the xml file contents of specific flavor.\n");
    printf("         <file>: Fully qualified path\n");
    printf("     /v means the verbose mode [optional].\n");
}


///////////////////////////////////////////////////////////////////////////////
//
//  GetTempDirName
//
//  Return the MUI temporary directory name, create it if not found
//
///////////////////////////////////////////////////////////////////////////////
BOOL GetTempDirName(LPSTR sLangName)
{
    CHAR    *pcBaseDirPtr = NULL;
    BOOL    bFoundDir = FALSE;
    HRESULT hr;

    pcBaseDirPtr = getenv(TEXT("_NTPOSTBLD"));
    if (NULL != pcBaseDirPtr)
    {
//      sprintf(TempDirName, "%s\\%s\\%s\\%s\\%s", pcBaseDirPtr, sLangName, "mui", sLangName, "tmp\\infparser");
        // sprintf(TempDirName, "%s\\%s\\%s\\%s", pcBaseDirPtr, "mui", sLangName, "tmp\\infparser");
        hr = StringCchPrintfA(TempDirName, ARRAYLEN(TempDirName), "%s\\%s\\%s\\%s", pcBaseDirPtr, "mui", sLangName, "tmp\\infparser");
        if (!SUCCEEDED(hr)) {
              goto exit;
         }

        // we will create this directory if it does not exist - although it should be by this stage
        if (FALSE == DirectoryExist(TempDirName))
        {
            if (TRUE == CreateDirectory(TempDirName, NULL))
            {
                bFoundDir = TRUE;
                if (!bSilence)
                    printf("Infparser::GetTempDirName() - created MUI temp directory %s \n", TempDirName);              
            }
            else
            {
                if (!bSilence)
                    printf("Infparser::GetTempDirName() - failed to create MUI temp directory %s - The error returned is %d\n", TempDirName, GetLastError());
            }
        }
        else
            bFoundDir = TRUE;
    }

    // if we cannot find the MUI temp directory and directory creation failed, use the default one instead
    if (FALSE == bFoundDir)
    {
        DWORD dwBufferLength = 0;
        dwBufferLength = GetTempPath(MAX_PATH, TempDirName);        // tempdir returned contains an ending slash
        if (dwBufferLength > 0)
        {
            if (TRUE == DirectoryExist(TempDirName))
            {
                bFoundDir = TRUE;
            }
        }
    }

    if (!bSilence)
    {
        if (FALSE == bFoundDir)
            printf("GetTempDirName: Cannot find/create temporary directory!\n");
        else
            printf("GetTempDirName: temporary directory used is %s\n", TempDirName);
    }   
    return bFoundDir;
exit:
    printf("Error in GetTempDirName \n");
    return FALSE;
}


BOOL GetFileShortName(const CHAR * pcInLongName, CHAR * pcOutShortName, BOOL bInFileExists)
{
    CHAR LongFullPath[MAX_PATH];
    CHAR ShortFullPath[MAX_PATH];
    DWORD   dwBufferSize = 0;           // size of the returned shortname
    HANDLE tmpHandle;
    CHAR *  pcIndex = NULL;             // pointer index into src path of the file name
    HRESULT hr;
    
    if (NULL == pcInLongName || NULL == pcOutShortName)
        return FALSE;

    if (!bInFileExists)
    {
        
        hr = StringCchPrintfA(LongFullPath, ARRAYLEN(LongFullPath), "%s\\%s", TempDirName, pcInLongName);
        if (!SUCCEEDED(hr)) {
              goto exit;
         }

        if (!bSilence)
            printf("GetFileShortName: LongFullPath is %s.\n", LongFullPath);
        
        // create a temp file so that GetShortPathName will work
        tmpHandle = CreateFile(LongFullPath, 
                             GENERIC_ALL, FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE, 
                             NULL, 
                             OPEN_ALWAYS, 
                             FILE_ATTRIBUTE_NORMAL, 
                             NULL);
        if (tmpHandle)
            CloseHandle(tmpHandle);
    }       
    else
    {
        
        hr = StringCchCopyA(LongFullPath, ARRAYLEN(LongFullPath), pcInLongName);
        if(!SUCCEEDED(hr)) {
            goto exit;
        }
    }

    dwBufferSize = GetShortPathName(LongFullPath, ShortFullPath, MAX_PATH);     
    
    if (0 == dwBufferSize)
    {
        DWORD dwErrorCode = GetLastError();  
        if (!bSilence)
        {
            printf("GetFileShortName failed!  GetShortPathName returned an error code of %d.  Using longname as shortpath name.  ", dwErrorCode);
            printf("fullpath is %s\n", LongFullPath);
        }
        
        hr = StringCchCopyA(pcOutShortName, MAX_PATH, pcInLongName);
        if(!SUCCEEDED(hr)) {
            goto exit;
        }
    }
    else
    {
        // find the filename from the path, if cannot find it, then use the source name
        GetFileNameFromFullPath(ShortFullPath, pcOutShortName);

        if (!pcOutShortName)
        {
            if (!bSilence)
                printf("GetShortPathName returned an empty string, using source name %s\n", pcInLongName);
            
             hr = StringCchCopyA(pcOutShortName, MAX_PATH, pcInLongName);
             if(!SUCCEEDED(hr)) {
                  goto exit;
             }
        }
    } 
    return TRUE;

exit:
    printf("Error in GetFileShortName\n");
    return FALSE;
}
        

BOOL IsInvalidChar(CHAR cCheck)
{
    int i;
    BOOL bResult = FALSE;

    for (i=0; i < NO_INVALIDCHARS; i++)
    {
        if (cCheck == InvalidChars[i])
        {
            bResult = TRUE;
            break;
        }
    }
    return bResult;
}


void ReplaceInvalidChars(CHAR *pcInName)
{
    // if first char is not a alphabet or underscore, add an underscore to the name
    HRESULT hr;
    if ((!isalpha(*pcInName) && (*pcInName != '_') ))
    {
        CHAR tempBuffer[MAX_PATH+1];
        
        hr = StringCchCopyA(tempBuffer, ARRAYLEN(tempBuffer), pcInName);
        if(!SUCCEEDED(hr)) {
             goto exit;
        }
        
        hr = StringCchCopyA(pcInName, MAX_PATH, tempBuffer);
        if(!SUCCEEDED(hr)) {
             goto exit;
        }

    }
    
    while (*pcInName)
    {
        if (IsInvalidChar(*pcInName))
            *pcInName = '_';        // replace all invalid chars with underscores
            
        pcInName++;
    }

    return;
exit:
    printf("Error in ReplaceInvalidChars \n");
    return;
}


BOOL GetFileNameFromFullPath(const CHAR * pcInFullPath, CHAR * pcOutFileName)
{
    CHAR * pcIndex = NULL;
    HRESULT hr;

    if (!pcInFullPath)
    {
        return FALSE;
    }
    if (!pcOutFileName)
    {
        return FALSE;
    }    
    
    // find the filename from the path, if cannot find it, then use the fullpath as the outputfilename
    pcIndex = strrchr(pcInFullPath, '\\'); 
    if (NULL != pcIndex) 
    {
        pcIndex++;
        if (!bSilence)
            printf("Shortpath used is %s\n", pcIndex);
        
        hr = StringCchCopyA(pcOutFileName, MAX_PATH, pcIndex); // pcOutFileName size is MAX_PATH
        if(!SUCCEEDED(hr)) {
             goto exit;
        }

    }   
    else if (0 < strlen(pcInFullPath))     // we just have the filename, use it as is.
    {
        if (!bSilence)
            printf("GetFileNameFromFullPath returned a path without a \\ in the path.  ShortFileName is %s.\n", pcInFullPath);
        
        hr = StringCchCopyA(pcOutFileName, MAX_PATH, pcInFullPath); // pcOutFileName size is MAX_PATH
        if(!SUCCEEDED(hr)) {
             goto exit;
        }
    }
    else                                // didn't find the filename, use the passed in parameter instead
    {
        if (!bSilence)
            printf("GetFileNameFromFullPath returned an empty string, using source name %s\n", pcInFullPath);
        
        
        hr = StringCchCopyA(pcOutFileName, MAX_PATH, pcInFullPath); // pcOutFileName size is MAX_PATH
        if(!SUCCEEDED(hr)) {
             goto exit;
         }
    }

    return TRUE;
exit:
    printf("Error in GetFileNameFromFullPath\n");
    return TRUE;
    
}


void RenameMuiExtension(CHAR * dstFileName)
{
    int iNameLen = 0;
    
    if (NULL == dstFileName)
        return;

    iNameLen = strlen(dstFileName);
    if (0 == iNameLen)
        return;
   
    // if the last char is a '/' or '\', remove it
    if ((dstFileName[iNameLen-1] == '\\') || (dstFileName[iNameLen-1] == '/'))
    {
        dstFileName[iNameLen-1] = '\0';
        iNameLen --;
    }
    
    // if the last 4 chars are '.mui', replace the 'i' with '_'
    if (iNameLen >= 4)
    {
        if (_stricmp(dstFileName+(iNameLen-4), ".mui") == 0)
        {
            dstFileName[iNameLen-1] = '_';
        }
    }
    return;
    
}


//
// This function checks to see if there are any SKU specific external component INF directories under the supplied component path.
// Note that the SKU subdirectories are as generated by the NT build environment.  And also that the personal edition SKU directory
// "perinf" is not included in the search.  i.e. if perinf dir exists the function still returns false.
//
BOOL ContainSKUDirs(CHAR *pszDirPath)
{
    WIN32_FIND_DATA FindData;
    HANDLE FindHandle = NULL;
    FINDEX_INFO_LEVELS fInfoLevelId;
    INT i;
    CHAR szSKURootPath[MAX_PATH];
    BOOL bResult = FALSE;
    HRESULT hr;

    CHAR *szSKUDirs[5] = {
                                            "blainf\0",
                                            "dtcinf\0",
                                            "entinf\0",
                                            "sbsinf\0",                
                                            "srvinf\0"
                                        };
    
    if (NULL == pszDirPath)
        return FALSE;

    if (0 == strlen(pszDirPath))
        return FALSE;
    
    for (i = 0; i < 5; i++)
    {
        // replace PathCombine(szSKURootPath, pszDirPath, szSKUDirs[i])
        // with normal string operation. 
        // szSKURootPath = pszDirPath + "\\" + szSKUDirs[i];
        
        hr = StringCchPrintfA(szSKURootPath, ARRAYLEN(szSKURootPath), "%s\\%s",pszDirPath,szSKUDirs[i]);
        if (!SUCCEEDED(hr)) {
            return FALSE;
        }

        FindHandle = FindFirstFileEx(szSKURootPath, FindExInfoStandard, &FindData, FindExSearchLimitToDirectories, NULL, 0);
        if (FindHandle != INVALID_HANDLE_VALUE)
        {
            FindClose(FindHandle);
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                bResult = TRUE;
                break;
            }
        }
    }    
    
    return (bResult);
}


BOOL GetSKUConditionString(CHAR *pszBuffer, DWORD dwFlavour)
{
    BOOL bReturn = TRUE;
    HRESULT hr;
    
    if (NULL == pszBuffer)
    {
        bReturn = FALSE;
        // strcpy(pszBuffer, "");
        goto Exit;
    }

    switch (dwFlavour)
    {
        case FLV_PROFESSIONAL:
            
            hr = StringCchCopyA(pszBuffer, 4096, PRO_SKU_CONDITION); 
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            break;
        case FLV_SERVER:
            
            hr = StringCchCopyA(pszBuffer, 4096, SRV_SKU_CONDITION); 
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            break;
        case FLV_ADVSERVER:
            
            hr = StringCchCopyA(pszBuffer, 4096, ADV_SKU_CONDITION); 
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            break;
        case FLV_DATACENTER:
            
            hr = StringCchCopyA(pszBuffer, 4096, DTC_SKU_CONDITION); 
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            break;
        case FLV_WEBBLADE:
            
            hr = StringCchCopyA(pszBuffer, 4096, BLA_SKU_CONDITION); 
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            break;
        case FLV_SMALLBUSINESS:
            
            hr = StringCchCopyA(pszBuffer, 4096, SBS_SKU_CONDITION); 
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            break;
        case FLV_PERSONAL:
        case FLV_UNDEFINED:
        case FLV_CORE:
        default:
            
            hr = StringCchCopyA(pszBuffer, 4096, "");
            if(!SUCCEEDED(hr)) {
                 goto exit;
            }
            bReturn = FALSE;            
            break;
    }

    if (!bSilence)
    {
        printf("\nSKU Condition String is: %s\n", pszBuffer);
    }

Exit:   
    return bReturn;

 exit:
    printf("Error GetSKUConditionString \n");
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// IsFileForSKU: 
//
// This function takes a file name, the SKU flavour, and the processor architecture as an
// argument.  Then it checks to see if it exists as a source file in the SKU specified.
//
// the checking part is done by looking in the built layout.inf file for that sku to make sure 
// the file appears for that SKU only, the layout.inf file for the skus are located at:
//
// PRO sku: _NTPOSTBLD
// PER sku: _NTPOSTBLD\perinf 
// SRV sku: _NTPOSTBLD\srvinf
// ADS sku: _NTPOSTBLD\entinf
// DTC sku: _NTPOSTBLD\dtcinf
// SBS sku: _NTPOSTBLD\sbsinf
// BLA sku: _NTPOSTBLD\blainf
//
// for all skus, check all the inf files for every sku and make sure it doesn't appear in every inf
// but appears at least in the inf file designated for the sku we are searching for.
// For Core sku, it must appear in every infs (the reverse for the above)
// ignore and return false if personal or other undefined skus are specified
// check first in [SourceDisksFiles] (common file section)
// if not in there, we check based on arch, [SourceDiskFiles.x86] and [SourceDiskFiles.ia64]
// note that here, the source and destination file names are the same, since they are not in the exception list
//
// strFileName: source filename to be checked (not the destination name)
// dwSKU: SKU to check for (see infparser.h for the list of values)
// dwArch: Architecture type to check for (see infparser.h for list of values)
//
//  NOTE: this function needs to be reworked if we want to incorporate PER/PRO skus back into 
//  the checking.  Currently it only works for server skus.
//
///////////////////////////////////////////////////////////////////////////
BOOL IsFileForSKU(CHAR * strFileName, DWORD dwSKU, DWORD dwArch, FileLayoutExceptionList * exceptionList)
{
    BOOL        bFound = TRUE;
    BOOL        bCoreFound = TRUE;    
    BOOL        bSkuFound = FALSE; 
    BOOL        bProPerFound = FALSE;
    BOOL        bSrvSkusFound = FALSE;
    UINT        i = 0;              // index variable
    UINT        iDesignated = 0;    // the sku we are searching for.
    
    // validating parameters
    if (NULL == strFileName)
    {
        if (!bSilence)
        {
            printf("IsFileForSKU: Passed in filename is empty.\n");
        }
        return FALSE;
    }

    // determines the inf files that we need to search
    switch (dwSKU)
    {
        case FLV_PROFESSIONAL:
            iDesignated = PRO_SKU_INDEX;
            break;
        case FLV_PERSONAL:
            iDesignated = PER_SKU_INDEX;
            break;
        case FLV_SERVER:       
            iDesignated = SRV_SKU_INDEX;
            break;
        case FLV_ADVSERVER:
            iDesignated = ADV_SKU_INDEX;
            break;
        case FLV_DATACENTER:
            iDesignated = DTC_SKU_INDEX;
            break;
        case FLV_WEBBLADE: 
            iDesignated = BLA_SKU_INDEX;
            break;
        case FLV_SMALLBUSINESS:
            iDesignated = SBS_SKU_INDEX;
            break;
        case FLV_CORE:
            iDesignated = NO_SKUS;
            break;
        default:
            return FALSE;
            break;
    }

    if (!bSilence)
    {
        printf("File %s\n", strFileName);
    }
    // search for the infs
    // NOTE: we search also in personal and professional skus, this is to make sure files we pick up
    // which are in \bin that aren't in the server layout.infs are not also in layout.infs for pro/per
    for (i = PRO_SKU_INDEX; i < NO_SKUS; i++)
    {
        bFound = IsFileInInf(strFileName, i, dwArch);

        if (!bSilence)
        {
            printf("SKU %s: %s  ", SkuInfs[i].strSkuName, bFound ? "yes" : "no");
        }
        
        if (iDesignated == i)
        {
            bSkuFound = bFound;
        }

        if ((i == PRO_SKU_INDEX) || (i == PER_SKU_INDEX))
        {
            bProPerFound = (bProPerFound || bFound);
        }
        else
        {
            bCoreFound = (bFound && bCoreFound);           
            bSkuFound = bFound || bSkuFound;
        }               
    }
    
    if (dwSKU == FLV_CORE)
    {
        bFound =  bCoreFound;

        // for CORE sku, if the file is not found in Pro/Per SKU, we will include it anyways
        // as long as it is not a destination file for any SKU, otherwise we will have
        // a MSI build error
        if ((!bFound) && (!bProPerFound) && (!bSkuFound))
        {
            if (!exceptionList->searchDestName(strFileName))
                bFound = TRUE;
            else
                bFound = FALSE;
        }
    }
    else 
    {
        bFound = (!bCoreFound && bSkuFound);
    }

    if (!bSilence)
    {
        printf("\n");
        if (bFound)
        {
            printf("The file %s is found in this sku.\n", strFileName);
        }
        else
        {
            printf("The file %s is not found in this sku.\n", strFileName);
        }
    }

    return bFound;
}


BOOL IsFileInInf(CHAR * strFileName, UINT iSkuIndex, DWORD dwArch)
{
    UINT    iLineCount = 0;
    UINT    iLineNum = 0;
    FileLayoutExceptionList *flArch = NULL;
    CHAR    * archSection = NULL;
    INFCONTEXT context;
    
    // validating parameters
    if (NULL == strFileName)
    {
        if (!bSilence)
        {
            printf("IsFileInInf: Passed in filename is empty.\n");
        }
        return FALSE;
    }
  
    switch (dwArch)
    {
        case BIN_32:
            flArch = &(SkuInfs[iSkuIndex].flLayoutX86);
            break;
        case BIN_64:
            flArch = &(SkuInfs[iSkuIndex].flLayoutIA64);
            break;
        default:
            if (!bSilence)
            {
                printf("Invalid architecture specified.\n");
            }
            return FALSE;
            break;
    }
    
    if (iSkuIndex > BLA_SKU_INDEX)
    {
        if (!bSilence)
        {
            printf("IsFileInInf: invalid SKU index passed in as parameter: %d.\n", iSkuIndex);
        }
        return FALSE;
    }

    if (SkuInfs[iSkuIndex].flLayoutCore.search(strFileName) != NULL)
    {
        return TRUE;
    }
    else if (flArch->search(strFileName) != NULL)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// This function reads in the layout.inf files for all the skus and stores the file information
// in the filelist structure for later accessing.  We are doing this so that we can gain
// some performance instead of repeatedly using setup apis to read from the inf files itself
// when we have to repeatedly search through these inf files to build the final file list
// 
BOOL ReadInLayoutInfFiles()
{
    UINT i = 0;
    UINT j = 0;
    UINT iLineCount = 0;
    UINT iLineNum = 0;
    INFCONTEXT context;  
    FileLayout *file;
    HINF hInfFile = NULL;
    FileLayoutExceptionList *flist = NULL;
    
    // populate the layout.inf filelists
    for (i = 0; i < NO_SKUS; i++)
    {
        if (!bSilence)
        {
            printf("ReadInLayoutInfFiles: Reading files from %s for %s SKU.\n", SkuInfs[i].strLayoutInfPaths, SkuInfs[i].strSkuName);
        }
        hInfFile = SetupOpenInfFile(SkuInfs[i].strLayoutInfPaths, NULL, INF_STYLE_WIN4, NULL);
        if (INVALID_HANDLE_VALUE == hInfFile)
        {
            if (!bSilence)
            {
                printf("ReadInLayoutInfFiles: Failure opening %s file\n", SkuInfs[i].strLayoutInfPaths);
            }
            return FALSE;
        }

        // read in SourceDisksFiles section
        for (j = 0; j < 3; j++)
        {
            switch(j)
            {
                case (0):
                    flist = &(SkuInfs[i].flLayoutCore);
                    break;
                case (1):
                    flist = &(SkuInfs[i].flLayoutX86);                    
                    break;
                case (2):
                    flist = &(SkuInfs[i].flLayoutIA64);                    
                    break;
                default:
                    // shouldn't happen
                    return FALSE;
            }

            iLineCount = (UINT)SetupGetLineCount(hInfFile, strArchSections[j]);
            if (iLineCount > 0)
            {
                //
                //  try to find the file in sourcedisksfiles.
                //
                CHAR name[MAX_PATH];
                for (iLineNum = 0; iLineNum < iLineCount; iLineNum++)
                {
                    if (SetupGetLineByIndex(hInfFile, strArchSections[j], iLineNum, &context) &&
                        SetupGetStringField(&context, 0, name, MAX_PATH, NULL))
                    {
                        // add the file to the filelist, we are only interested in the source name, pass in bogus stuff for
                        // the other members, we don't care what the sku is, just insert 0 for now.
                        if (file = new FileLayout(name, name, 0))
                        {
                            flist->insert(file);
                        }
                    }
                }
            }
        }
        
        SetupCloseInfFile(hInfFile);
    }    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\vbsconst.inc ===
'<script language='VBScript'>
' wiconsts.inc - VBScript constants
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

' FileSystemObject constants
Const OverwriteIfExist = -1
Const OpenAsASCII      =  0 
Const ForReading       =  1
Const FailIfNotExist   =  0
Const OpenAsDefault    = -2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\ritables.inc ===
'<script language='VBScript'>
' ritables.inc - Redist information table definitions
'
'  2001/05/04 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Database table schema
Dim   RedistInfoTable(4)         : RedistInfoTable(0)                      = "`redist_Info`"
Const RedistInfo_DummyPk = 1 : RedistInfoTable(RedistInfo_DummyPk)      = "`DummyPk` CHAR(15) NOT NULL PRIMARY KEY"  ' dummy primary key to make Windows Installer happy
Const RedistInfo_Description = 2 : RedistInfoTable(RedistInfo_Description)      = "`Description` CHAR(0) LOCALIZABLE"
Const RedistInfo_Distribution = 3 : RedistInfoTable(RedistInfo_Distribution)      = "`Distribution` SHORT"   ' 0 == internal, 1 == external
Const RedistInfo_Type = 4 : RedistInfoTable(RedistInfo_Type)      = "`Type` SHORT"   ' 0 == debug, 1 == ship

'Dim   RedistKeywordsTable(1)         : RedistKeywordsTable(0)                      = "`redist_Keywords`"
'Const RedistKeywords_Keyword = 1 : RedistKeywordsTable(RedistKeywords_Keyword)      = "`Keyword` CHAR(255) NOT NULL LOCALIZABLE PRIMARY KEY"

Dim   RedistContactsTable(1)         : RedistContactsTable(0)                      = "`redist_Contacts`"
Const RedistContacts_Contact = 1 : RedistContactsTable(RedistContacts_Contact)      = "`Contact` CHAR(255) NOT NULL PRIMARY KEY"

Dim   RedistPermissionsTable(2)         : RedistPermissionsTable(0)                      = "`redist_Permissions`"
Const RedistPermissions_Domain = 1 : RedistPermissionsTable(RedistPermissions_Domain)      = "`Domain` CHAR(255) NOT NULL PRIMARY KEY"
Const RedistPermissions_Alias = 2 : RedistPermissionsTable(RedistPermissions_Alias)      = "`Alias` CHAR(255) NOT NULL PRIMARY KEY"

Dim   RedistOsTable(6)         : RedistOsTable(0)                      = "`redist_Os`"
Const RedistOs_DummyPk = 1 : RedistOsTable(RedistOs_DummyPk)      = "`DummyPk` SHORT NOT NULL PRIMARY KEY"  ' dummy primary key to make Windows Installer happy
Const RedistOs_Type = 2 : RedistOsTable(RedistOs_Type)      = "`Type` CHAR(16) NOT NULL"  ' "Windows9x", "Windows32", "Windows64"
Const RedistOs_Flavor = 3 : RedistOsTable(RedistOs_Flavor)      = "`Flavor` CHAR(20)"   ' "workstation", "server","terminalserver","professional",etc.
Const RedistOs_Language = 4 : RedistOsTable(RedistOs_Language)      = "`Language` CHAR(255)"
Const RedistOs_MinVersion = 5 : RedistOsTable(RedistOs_MinVersion)      = "`MinVersion` CHAR(20)"
Const RedistOs_MaxVersion = 6 : RedistOsTable(RedistOs_MaxVersion)      = "`MaxVersion` CHAR(20)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\witables.inc ===
'<script language='VBScript'>
' witables.inc - Windows Installer table definitions
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

'--------------------------------------------------------'
' Boolean attribute to bit translation
'--------------------------------------------------------'
Dim dialogAttributes : dialogAttributes = Array("Hidden","Modeless","NoMinimize","SystemModal","KeepModeless","TrackDiskSpace","CustomPalette","RightToLeft","RightAligned","LeftScroll")
Dim   commonControlAttributes :   commonControlAttributes = Array("Hidden","Disabled","Sunken","Indirect","Integer","RightToLeft","RightAligned","LeftScroll")
Dim     textControlAttributes :     textControlAttributes = Array("Transparent","NoPrefix","NoWrap","FormatSize","UserLanguage")
Dim     editControlAttributes :     editControlAttributes = Array("Multiline", Empty, Empty, Empty,    Empty, "Password")
Dim progressControlAttributes : progressControlAttributes = Array("ProgressBlocks")
Dim   volumeControlAttributes :   volumeControlAttributes = Array("Removable","Fixed","Remote","CDROM","RAMDisk","Floppy","ShowRollbackCost")
Dim  listboxControlAttributes :  listboxControlAttributes = Array("Sorted")
Dim listviewControlAttributes : listviewControlAttributes = Array("Sorted",Empty    , Empty  , Empty, "FixedSize","Icon16","Icon32")
Dim comboboxControlAttributes : comboboxControlAttributes = Array("Sorted","ComboList")
Dim    radioControlAttributes :    radioControlAttributes = Array("Image","PushLike","Bitmap","Icon", "FixedSize","Icon16","Icon32",Empty,"HasBorder")
Dim   buttonControlAttributes :   buttonControlAttributes = Array("Image", Empty    ,"Bitmap","Icon", "FixedSize","Icon16","Icon32")    
Dim     iconControlAttributes :     iconControlAttributes = Array("Image", Empty    , Empty  , Empty, "FixedSize","Icon16","Icon32")
Dim   bitmapControlAttributes :   bitmapControlAttributes = Array("Image", Empty    , Empty  , Empty, "FixedSize")
Dim checkboxControlAttributes : checkboxControlAttributes = Array( Empty, "PushLike","Bitmap","Icon", "FixedSize","Icon16","Icon32")

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Boolean permission to bit translation
Dim standardPermissions : standardPermissions = Array("Delete","ReadPermission","ChangePermission","TakeOwnership","Synchronize")
Dim registryPermissions : registryPermissions = Array("Read",  "Write", "CreateSubkeys","EnumerateSubkeys","Notify","CreateLink")
Dim     filePermissions :     filePermissions = Array("Read",  "Write",   "Append",     "ReadExtendedAttributes","WriteExtendedAttributes","Execute",  Empty,       "ReadAttributes","WriteAttributes")
Dim   folderPermissions :   folderPermissions = Array("Read","CreateFile","CreateChild","ReadExtendedAttributes","WriteExtendedAttributes","Traverse","DeleteChild","ReadAttributes","WriteAttributes")
Dim  genericPermissions :  genericPermissions = Array("GenericAll","GenericExecute","GenericWrite","GenericRead")

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Database table schema
Dim   ActionTextTable(3)         : ActionTextTable(0)                      = "`ActionText`"
Const ActionText_Action      = 1 : ActionTextTable(ActionText_Action)      = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const ActionText_Description = 2 : ActionTextTable(ActionText_Description) = "`Description` CHAR(64) LOCALIZABLE"
Const ActionText_Template    = 3 : ActionTextTable(ActionText_Template)    = "`Template` CHAR(128) LOCALIZABLE"
Dim   AdminExecuteSequenceTable(3)       : AdminExecuteSequenceTable(0)                              = "`AdminExecuteSequence`"
Const AdminExecuteSequence_Action    = 1 : AdminExecuteSequenceTable(AdminExecuteSequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdminExecuteSequence_Condition = 2 : AdminExecuteSequenceTable(AdminExecuteSequence_Condition) = "`Condition` CHAR(255)"
Const AdminExecuteSequence_Sequence  = 3 : AdminExecuteSequenceTable(AdminExecuteSequence_Sequence)  = "`Sequence` SHORT"
Dim   AdminUISequenceTable(3)       : AdminUISequenceTable(0)                         = "`AdminUISequence`"
Const AdminUISequence_Action    = 1 : AdminUISequenceTable(AdminUISequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdminUISequence_Condition = 2 : AdminUISequenceTable(AdminUISequence_Condition) = "`Condition` CHAR(255)"
Const AdminUISequence_Sequence  = 3 : AdminUISequenceTable(AdminUISequence_Sequence)  = "`Sequence` SHORT"
Dim   AdvtExecuteSequenceTable(3)       : AdvtExecuteSequenceTable(0)                             = "`AdvtExecuteSequence`"
Const AdvtExecuteSequence_Action    = 1 : AdvtExecuteSequenceTable(AdvtExecuteSequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdvtExecuteSequence_Condition = 2 : AdvtExecuteSequenceTable(AdvtExecuteSequence_Condition) = "`Condition` CHAR(255)"
Const AdvtExecuteSequence_Sequence  = 3 : AdvtExecuteSequenceTable(AdvtExecuteSequence_Sequence)  = "`Sequence` SHORT"
Dim   AdvtUISequenceTable(3)       : AdvtUISequenceTable(0)                        = "`AdvtUISequence`"
Const AdvtUISequence_Action    = 1 : AdvtUISequenceTable(AdvtUISequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const AdvtUISequence_Condition = 2 : AdvtUISequenceTable(AdvtUISequence_Condition) = "`Condition` CHAR(255)"
Const AdvtUISequence_Sequence  = 3 : AdvtUISequenceTable(AdvtUISequence_Sequence)  = "`Sequence` SHORT"
Dim   AppIdTable(7)                  : AppIdTable(0)                          = "`AppId`"
Const AppId_AppId                = 1 : AppIdTable(AppId_AppId)                = "`AppId` CHAR(38) NOT NULL PRIMARY KEY"
Const AppId_RemoteServerName     = 2 : AppIdTable(AppId_RemoteServerName)     = "`RemoteServerName` CHAR(255)"
Const AppId_LocalService         = 3 : AppIdTable(AppId_LocalService)         = "`LocalService` CHAR(255)"
Const AppId_ServiceParameters    = 4 : AppIdTable(AppId_ServiceParameters)    = "`ServiceParameters` CHAR(255)"
Const AppId_DllSurrogate         = 5 : AppIdTable(AppId_DllSurrogate)         = "`DllSurrogate` CHAR(255)"
Const AppId_ActivateAtStorage    = 6 : AppIdTable(AppId_ActivateAtStorage)    = "`ActivateAtStorage` SHORT"
Const AppId_RunAsInteractiveUser = 7 : AppIdTable(AppId_RunAsInteractiveUser) = "`RunAsInteractiveUser` SHORT"
Dim   AppSearchTable(2)        : AppSearchTable(0)                    = "`AppSearch`"
Const AppSearch_Property   = 1 : AppSearchTable(AppSearch_Property)   = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const AppSearch_Signature_ = 2 : AppSearchTable(AppSearch_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   BBControlTable(9)        : BBControlTable(0)                    = "`BBControl`"
Const BBControl_Billboard_ = 1 : BBControlTable(BBControl_Billboard_) = "`Billboard_` CHAR(50) NOT NULL PRIMARY KEY"
Const BBControl_BBControl  = 2 : BBControlTable(BBControl_BBControl)  = "`BBControl` CHAR(50) NOT NULL PRIMARY KEY"
Const BBControl_Type       = 3 : BBControlTable(BBControl_Type)       = "`Type` CHAR(50) NOT NULL"
Const BBControl_X          = 4 : BBControlTable(BBControl_X)          = "`X` SHORT NOT NULL"
Const BBControl_Y          = 5 : BBControlTable(BBControl_Y)          = "`Y` SHORT NOT NULL"
Const BBControl_Width      = 6 : BBControlTable(BBControl_Width)      = "`Width` SHORT NOT NULL"
Const BBControl_Height     = 7 : BBControlTable(BBControl_Height)     = "`Height` SHORT NOT NULL"
Const BBControl_Attributes = 8 : BBControlTable(BBControl_Attributes) = "`Attributes` LONG"
Const BBControl_Text       = 9 : BBControlTable(BBControl_Text)       = "`Text` CHAR(50) LOCALIZABLE"
Dim   BillboardTable(4)       : BillboardTable(0)                   = "`Billboard`"
Const Billboard_Billboard = 1 : BillboardTable(Billboard_Billboard) = "`Billboard` CHAR(50) NOT NULL PRIMARY KEY"
Const Billboard_Feature_  = 2 : BillboardTable(Billboard_Feature_)  = "`Feature_` CHAR(38) NOT NULL"
Const Billboard_Action    = 3 : BillboardTable(Billboard_Action)    = "`Action` CHAR(50)"
Const Billboard_Ordering  = 4 : BillboardTable(Billboard_Ordering)  = "`Ordering` SHORT"
Dim   BinaryTable(2)  : BinaryTable(0)           = "`Binary`"
Const Binary_Name = 1 : BinaryTable(Binary_Name) = "`Name` CHAR(72) NOT NULL PRIMARY KEY"
Const Binary_Data = 2 : BinaryTable(Binary_Data) = "`Data` OBJECT NOT NULL"
Dim   BindImageTable(2)   : BindImageTable(0)               = "`BindImage`"
Const BindImage_File_ = 1 : BindImageTable(BindImage_File_) = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const BindImage_Path  = 2 : BindImageTable(BindImage_Path)  = "`Path` CHAR(255)"
Dim   CCPSearchTable(1)        : CCPSearchTable(0)                    = "`CCPSearch`"
Const CCPSearch_Signature_ = 1 : CCPSearchTable(CCPSearch_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   CheckBoxTable(2)      : CheckBoxTable(0)                 = "`CheckBox`"
Const CheckBox_Property = 1 : CheckBoxTable(CheckBox_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const CheckBox_Value    = 2 : CheckBoxTable(CheckBox_Value)    = "`Value` CHAR(64)"
Dim   ClassTable(13)             : ClassTable(0)                      = "`Class`"
Const Class_CLSID            = 1 : ClassTable(Class_CLSID)            = "`CLSID` CHAR(38) NOT NULL PRIMARY KEY"
Const Class_Context          = 2 : ClassTable(Class_Context)          = "`Context` CHAR(32) NOT NULL PRIMARY KEY"
Const Class_Component_       = 3 : ClassTable(Class_Component_)       = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const Class_ProgId_Default   = 4 : ClassTable(Class_ProgId_Default)   = "`ProgId_Default` CHAR(255)"
Const Class_Description      = 5 : ClassTable(Class_Description)      = "`Description` CHAR(255) LOCALIZABLE"
Const Class_AppId_           = 6 : ClassTable(Class_AppId_)           = "`AppId_` CHAR(38)"
Const Class_FileTypeMask     = 7 : ClassTable(Class_FileTypeMask)     = "`FileTypeMask` CHAR(255)"
Const Class_Icon_            = 8 : ClassTable(Class_Icon_)            = "`Icon_` CHAR(72)"
Const Class_IconIndex        = 9 : ClassTable(Class_IconIndex)        = "`IconIndex` SHORT"
Const Class_DefInprocHandler =10 : ClassTable(Class_DefInprocHandler) = "`DefInprocHandler` CHAR(32)"
Const Class_Argument         =11 : ClassTable(Class_Argument)         = "`Argument` CHAR(255)"
Const Class_Feature_         =12 : ClassTable(Class_Feature_)         = "`Feature_` CHAR(38) NOT NULL"
Const Class_Attributes       =13 : ClassTable(Class_Attributes)       = "`Attributes` SHORT"
Dim   ComboBoxTable(4)      : ComboBoxTable(0)                 = "`ComboBox`"
Const ComboBox_Property = 1 : ComboBoxTable(ComboBox_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const ComboBox_Order    = 2 : ComboBoxTable(ComboBox_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const ComboBox_Value    = 3 : ComboBoxTable(ComboBox_Value)    = "`Value` CHAR(64) NOT NULL"
Const ComboBox_Text     = 4 : ComboBoxTable(ComboBox_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Dim   CompLocatorTable(3)         : CompLocatorTable(0)                       = "`CompLocator`"
Const CompLocator_Signature_  = 1 : CompLocatorTable(CompLocator_Signature_)  = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const CompLocator_ComponentId = 2 : CompLocatorTable(CompLocator_ComponentId) = "`ComponentId` CHAR(38) NOT NULL"
Const CompLocator_Type        = 3 : CompLocatorTable(CompLocator_Type)        = "`Type` SHORT"
Dim   ComplusTable(2)        : ComplusTable(0)                  = "`Complus`"
Const Complus_Component_ = 1 : ComplusTable(Complus_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const Complus_ExpType    = 2 : ComplusTable(Complus_ExpType)    = "`ExpType` SHORT PRIMARY KEY"
Dim   ComponentTable(6)         : ComponentTable(0)                     = "`Component`"
Const Component_Component   = 1 : ComponentTable(Component_Component)   = "`Component` CHAR(72) NOT NULL PRIMARY KEY"
Const Component_ComponentId = 2 : ComponentTable(Component_ComponentId) = "`ComponentId` CHAR(38)"
Const Component_Directory_  = 3 : ComponentTable(Component_Directory_)  = "`Directory_` CHAR(72) NOT NULL"
Const Component_Attributes  = 4 : ComponentTable(Component_Attributes)  = "`Attributes` SHORT NOT NULL"
Const Component_Condition   = 5 : ComponentTable(Component_Condition)   = "`Condition` CHAR(255)"
Const Component_KeyPath     = 6 : ComponentTable(Component_KeyPath)     = "`KeyPath` CHAR(72)"
Dim   ConditionTable(3)       : ConditionTable(0)                   = "`Condition`"
Const Condition_Feature_  = 1 : ConditionTable(Condition_Feature_)  = "`Feature_` CHAR(38) NOT NULL PRIMARY KEY"
Const Condition_Level     = 2 : ConditionTable(Condition_Level)     = "`Level` SHORT NOT NULL PRIMARY KEY"
Const Condition_Condition = 3 : ConditionTable(Condition_Condition) = "`Condition` CHAR(255)"
Dim   ControlTable(12)         : ControlTable(0)                    = "`Control`"
Const Control_Dialog_      = 1 : ControlTable(Control_Dialog_)      = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const Control_Control      = 2 : ControlTable(Control_Control)      = "`Control` CHAR(50) NOT NULL PRIMARY KEY"
Const Control_Type         = 3 : ControlTable(Control_Type)         = "`Type` CHAR(20) NOT NULL"
Const Control_X            = 4 : ControlTable(Control_X)            = "`X` SHORT NOT NULL"
Const Control_Y            = 5 : ControlTable(Control_Y)            = "`Y` SHORT NOT NULL"
Const Control_Width        = 6 : ControlTable(Control_Width)        = "`Width` SHORT NOT NULL"
Const Control_Height       = 7 : ControlTable(Control_Height)       = "`Height` SHORT NOT NULL"
Const Control_Attributes   = 8 : ControlTable(Control_Attributes)   = "`Attributes` LONG"
Const Control_Property     = 9 : ControlTable(Control_Property)     = "`Property` CHAR(50)"
Const Control_Text         =10 : ControlTable(Control_Text)         = "`Text` LONGCHAR LOCALIZABLE"
Const Control_Control_Next =11 : ControlTable(Control_Control_Next) = "`Control_Next` CHAR(50)"
Const Control_Help         =12 : ControlTable(Control_Help)         = "`Help` CHAR(50) LOCALIZABLE"
Dim   ControlConditionTable(4)       : ControlConditionTable(0)                          = "`ControlCondition`"
Const ControlCondition_Dialog_   = 1 : ControlConditionTable(ControlCondition_Dialog_)   = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const ControlCondition_Control_  = 2 : ControlConditionTable(ControlCondition_Control_)  = "`Control_` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlCondition_Action    = 3 : ControlConditionTable(ControlCondition_Action)    = "`Action` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlCondition_Condition = 4 : ControlConditionTable(ControlCondition_Condition) = "`Condition` CHAR(255) NOT NULL PRIMARY KEY"
Dim   ControlEventTable(6)       : ControlEventTable(0)                      = "`ControlEvent`"
Const ControlEvent_Dialog_   = 1 : ControlEventTable(ControlEvent_Dialog_)   = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const ControlEvent_Control_  = 2 : ControlEventTable(ControlEvent_Control_)  = "`Control_` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlEvent_Event     = 3 : ControlEventTable(ControlEvent_Event)     = "`Event` CHAR(50) NOT NULL PRIMARY KEY"
Const ControlEvent_Argument  = 4 : ControlEventTable(ControlEvent_Argument)  = "`Argument` CHAR(255) NOT NULL PRIMARY KEY"
Const ControlEvent_Condition = 5 : ControlEventTable(ControlEvent_Condition) = "`Condition` CHAR(255) PRIMARY KEY"
Const ControlEvent_Ordering  = 6 : ControlEventTable(ControlEvent_Ordering)  = "`Ordering` SHORT"
Dim   CreateFolderTable(2)        : CreateFolderTable(0)                       = "`CreateFolder`"
Const CreateFolder_Directory_ = 1 : CreateFolderTable(CreateFolder_Directory_) = "`Directory_` CHAR(72) NOT NULL PRIMARY KEY"
Const CreateFolder_Component_ = 2 : CreateFolderTable(CreateFolder_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   CustomActionTable(4)    : CustomActionTable(0)                   = "`CustomAction`"
Const CustomAction_Action = 1 : CustomActionTable(CustomAction_Action) = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const CustomAction_Type   = 2 : CustomActionTable(CustomAction_Type)   = "`Type` SHORT NOT NULL"
Const CustomAction_Source = 3 : CustomActionTable(CustomAction_Source) = "`Source` CHAR(64)"
Const CustomAction_Target = 4 : CustomActionTable(CustomAction_Target) = "`Target` CHAR(255)"
Dim   DialogTable(10)            : DialogTable(0)                      = "`Dialog`"
Const Dialog_Dialog          = 1 : DialogTable(Dialog_Dialog)          = "`Dialog` CHAR(72) NOT NULL PRIMARY KEY"
Const Dialog_HCentering      = 2 : DialogTable(Dialog_HCentering)      = "`HCentering` SHORT NOT NULL"
Const Dialog_VCentering      = 3 : DialogTable(Dialog_VCentering)      = "`VCentering` SHORT NOT NULL"
Const Dialog_Width           = 4 : DialogTable(Dialog_Width)           = "`Width` SHORT NOT NULL"
Const Dialog_Height          = 5 : DialogTable(Dialog_Height)          = "`Height` SHORT NOT NULL"
Const Dialog_Attributes      = 6 : DialogTable(Dialog_Attributes)      = "`Attributes` LONG"
Const Dialog_Title           = 7 : DialogTable(Dialog_Title)           = "`Title` CHAR(128) LOCALIZABLE"
Const Dialog_Control_First   = 8 : DialogTable(Dialog_Control_First)   = "`Control_First` CHAR(50) NOT NULL"
Const Dialog_Control_Default = 9 : DialogTable(Dialog_Control_Default) = "`Control_Default` CHAR(50)"
Const Dialog_Control_Cancel  =10 : DialogTable(Dialog_Control_Cancel)  = "`Control_Cancel` CHAR(50)"
Dim   DirectoryTable(3)              : DirectoryTable(0)                          = "`Directory`"
Const Directory_Directory        = 1 : DirectoryTable(Directory_Directory)        = "`Directory` CHAR(72) NOT NULL PRIMARY KEY"
Const Directory_Directory_Parent = 2 : DirectoryTable(Directory_Directory_Parent) = "`Directory_Parent` CHAR(72)"
Const Directory_DefaultDir       = 3 : DirectoryTable(Directory_DefaultDir)       = "`DefaultDir` CHAR(255) NOT NULL LOCALIZABLE"
Dim   DrLocatorTable(4)        : DrLocatorTable(0)                    = "`DrLocator`"
Const DrLocator_Signature_ = 1 : DrLocatorTable(DrLocator_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const DrLocator_Parent     = 2 : DrLocatorTable(DrLocator_Parent)     = "`Parent` CHAR(72) PRIMARY KEY"
Const DrLocator_Path       = 3 : DrLocatorTable(DrLocator_Path)       = "`Path` CHAR(255) PRIMARY KEY"
Const DrLocator_Depth      = 4 : DrLocatorTable(DrLocator_Depth)      = "`Depth` SHORT"
Dim   DuplicateFileTable(5)        : DuplicateFileTable(0)                        = "`DuplicateFile`"
Const DuplicateFile_FileKey    = 1 : DuplicateFileTable(DuplicateFile_FileKey)    = "`FileKey` CHAR(72) NOT NULL PRIMARY KEY"
Const DuplicateFile_Component_ = 2 : DuplicateFileTable(DuplicateFile_Component_) = "`Component_` CHAR(72) NOT NULL"
Const DuplicateFile_File_      = 3 : DuplicateFileTable(DuplicateFile_File_)      = "`File_` CHAR(72) NOT NULL"
Const DuplicateFile_DestName   = 4 : DuplicateFileTable(DuplicateFile_DestName)   = "`DestName` CHAR(255) LOCALIZABLE"
Const DuplicateFile_DestFolder = 5 : DuplicateFileTable(DuplicateFile_DestFolder) = "`DestFolder` CHAR(72)"
Dim   EnvironmentTable(4)         : EnvironmentTable(0)                       = "`Environment`"
Const Environment_Environment = 1 : EnvironmentTable(Environment_Environment) = "`Environment` CHAR(72) NOT NULL PRIMARY KEY"
Const Environment_Name        = 2 : EnvironmentTable(Environment_Name)        = "`Name` CHAR(255) NOT NULL LOCALIZABLE"
Const Environment_Value       = 3 : EnvironmentTable(Environment_Value)       = "`Value` CHAR(255) LOCALIZABLE"
Const Environment_Component_  = 4 : EnvironmentTable(Environment_Component_)  = "`Component_` CHAR(72) NOT NULL"
Dim   ErrorTable(2)     : ErrorTable(0)             = "`Error`"
Const Error_Error   = 1 : ErrorTable(Error_Error)   = "`Error` SHORT NOT NULL PRIMARY KEY"
Const Error_Message = 2 : ErrorTable(Error_Message) = "`Message` CHAR(255) LOCALIZABLE"
Dim   EventMappingTable(4)       : EventMappingTable(0)                      = "`EventMapping`"
Const EventMapping_Dialog_   = 1 : EventMappingTable(EventMapping_Dialog_)   = "`Dialog_` CHAR(72) NOT NULL PRIMARY KEY"
Const EventMapping_Control_  = 2 : EventMappingTable(EventMapping_Control_)  = "`Control_` CHAR(50) NOT NULL PRIMARY KEY"
Const EventMapping_Event     = 3 : EventMappingTable(EventMapping_Event)     = "`Event` CHAR(50) NOT NULL PRIMARY KEY"
Const EventMapping_Attribute = 4 : EventMappingTable(EventMapping_Attribute) = "`Attribute` CHAR(50) NOT NULL"
Dim   ExtensionTable(5)        : ExtensionTable(0)                    = "`Extension`"
Const Extension_Extension  = 1 : ExtensionTable(Extension_Extension)  = "`Extension` CHAR(255) NOT NULL PRIMARY KEY"
Const Extension_Component_ = 2 : ExtensionTable(Extension_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const Extension_ProgId_    = 3 : ExtensionTable(Extension_ProgId_)    = "`ProgId_` CHAR(255)"
Const Extension_MIME_      = 4 : ExtensionTable(Extension_MIME_)      = "`MIME_` CHAR(64)"
Const Extension_Feature_   = 5 : ExtensionTable(Extension_Feature_)   = "`Feature_` CHAR(38) NOT NULL"
Dim   FeatureTable(8)            : FeatureTable(0)                      = "`Feature`"
Const Feature_Feature        = 1 : FeatureTable(Feature_Feature)        = "`Feature` CHAR(38) NOT NULL PRIMARY KEY"
Const Feature_Feature_Parent = 2 : FeatureTable(Feature_Feature_Parent) = "`Feature_Parent` CHAR(38)"
Const Feature_Title          = 3 : FeatureTable(Feature_Title)          = "`Title` CHAR(64) LOCALIZABLE"
Const Feature_Description    = 4 : FeatureTable(Feature_Description)    = "`Description` CHAR(255) LOCALIZABLE"
Const Feature_Display        = 5 : FeatureTable(Feature_Display)        = "`Display` SHORT"
Const Feature_Level          = 6 : FeatureTable(Feature_Level)          = "`Level` SHORT NOT NULL"
Const Feature_Directory_     = 7 : FeatureTable(Feature_Directory_)     = "`Directory_` CHAR(72)"
Const Feature_Attributes     = 8 : FeatureTable(Feature_Attributes)     = "`Attributes` SHORT NOT NULL"
Dim   FeatureComponentsTable(2)        : FeatureComponentsTable(0)                            = "`FeatureComponents`"
Const FeatureComponents_Feature_   = 1 : FeatureComponentsTable(FeatureComponents_Feature_)   = "`Feature_` CHAR(38) NOT NULL PRIMARY KEY"
Const FeatureComponents_Component_ = 2 : FeatureComponentsTable(FeatureComponents_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Dim   FileTable(8)        : FileTable(0)               = "`File`"
Const File_File       = 1 : FileTable(File_File)       = "`File` CHAR(72) NOT NULL PRIMARY KEY"
Const File_Component_ = 2 : FileTable(File_Component_) = "`Component_` CHAR(72) NOT NULL"
Const File_FileName   = 3 : FileTable(File_FileName)   = "`FileName` CHAR(255) NOT NULL LOCALIZABLE"
Const File_FileSize   = 4 : FileTable(File_FileSize)   = "`FileSize` LONG NOT NULL"
Const File_Version    = 5 : FileTable(File_Version)    = "`Version` CHAR(72)"
Const File_Language   = 6 : FileTable(File_Language)   = "`Language` CHAR(20)"
Const File_Attributes = 7 : FileTable(File_Attributes) = "`Attributes` SHORT"
Const File_Sequence   = 8 : FileTable(File_Sequence)   = "`Sequence` SHORT NOT NULL"
Dim   FontTable(2)       : FontTable(0)              = "`Font`"
Const Font_File_     = 1 : FontTable(Font_File_)     = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const Font_FontTitle = 2 : FontTable(Font_FontTitle) = "`FontTitle` CHAR(128)"
Dim   IconTable(2)  : IconTable(0)         = "`Icon`"
Const Icon_Name = 1 : IconTable(Icon_Name) = "`Name` CHAR(72) NOT NULL PRIMARY KEY"
Const Icon_Data = 2 : IconTable(Icon_Data) = "`Data` OBJECT NOT NULL"
Dim   IniFileTable(8)         : IniFileTable(0)                   = "`IniFile`"
Const IniFile_IniFile     = 1 : IniFileTable(IniFile_IniFile)     = "`IniFile` CHAR(72) NOT NULL PRIMARY KEY"
Const IniFile_FileName    = 2 : IniFileTable(IniFile_FileName)    = "`FileName` CHAR(255) NOT NULL LOCALIZABLE"
Const IniFile_DirProperty = 3 : IniFileTable(IniFile_DirProperty) = "`DirProperty` CHAR(72)"
Const IniFile_Section     = 4 : IniFileTable(IniFile_Section)     = "`Section` CHAR(96) NOT NULL LOCALIZABLE"
Const IniFile_Key         = 5 : IniFileTable(IniFile_Key)         = "`Key` CHAR(128) NOT NULL LOCALIZABLE"
Const IniFile_Value       = 6 : IniFileTable(IniFile_Value)       = "`Value` CHAR(255) NOT NULL LOCALIZABLE"
Const IniFile_Action      = 7 : IniFileTable(IniFile_Action)      = "`Action` SHORT NOT NULL"
Const IniFile_Component_  = 8 : IniFileTable(IniFile_Component_)  = "`Component_` CHAR(72) NOT NULL"
Dim   IniLocatorTable(6)        : IniLocatorTable(0)                     = "`IniLocator`"
Const IniLocator_Signature_ = 1 : IniLocatorTable(IniLocator_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const IniLocator_FileName   = 2 : IniLocatorTable(IniLocator_FileName)   = "`FileName` CHAR(255) NOT NULL"
Const IniLocator_Section    = 3 : IniLocatorTable(IniLocator_Section)    = "`Section` CHAR(96) NOT NULL"
Const IniLocator_Key        = 4 : IniLocatorTable(IniLocator_Key)        = "`Key` CHAR(128) NOT NULL"
Const IniLocator_Field      = 5 : IniLocatorTable(IniLocator_Field)      = "`Field` SHORT"
Const IniLocator_Type       = 6 : IniLocatorTable(IniLocator_Type)       = "`Type` SHORT"
Dim   InstallExecuteSequenceTable(3)       : InstallExecuteSequenceTable(0)                                = "`InstallExecuteSequence`"
Const InstallExecuteSequence_Action    = 1 : InstallExecuteSequenceTable(InstallExecuteSequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const InstallExecuteSequence_Condition = 2 : InstallExecuteSequenceTable(InstallExecuteSequence_Condition) = "`Condition` CHAR(255)"
Const InstallExecuteSequence_Sequence  = 3 : InstallExecuteSequenceTable(InstallExecuteSequence_Sequence)  = "`Sequence` SHORT"
Dim   InstallUISequenceTable(3)       : InstallUISequenceTable(0)                           = "`InstallUISequence`"
Const InstallUISequence_Action    = 1 : InstallUISequenceTable(InstallUISequence_Action)    = "`Action` CHAR(72) NOT NULL PRIMARY KEY"
Const InstallUISequence_Condition = 2 : InstallUISequenceTable(InstallUISequence_Condition) = "`Condition` CHAR(255)"
Const InstallUISequence_Sequence  = 3 : InstallUISequenceTable(InstallUISequence_Sequence)  = "`Sequence` SHORT"
Dim   IsolatedComponentTable(2)                   : IsolatedComponentTable(0)                                       = "`IsolatedComponent`"
Const IsolatedComponent_Component_Shared      = 1 : IsolatedComponentTable(IsolatedComponent_Component_Shared)      = "`Component_Shared` CHAR(72) NOT NULL PRIMARY KEY"
Const IsolatedComponent_Component_Application = 2 : IsolatedComponentTable(IsolatedComponent_Component_Application) = "`Component_Application` CHAR(72) NOT NULL PRIMARY KEY"
Dim   LaunchConditionTable(2)         : LaunchConditionTable(0)                           = "`LaunchCondition`"
Const LaunchCondition_Condition   = 1 : LaunchConditionTable(LaunchCondition_Condition)   = "`Condition` CHAR(255) NOT NULL PRIMARY KEY"
Const LaunchCondition_Description = 2 : LaunchConditionTable(LaunchCondition_Description) = "`Description` CHAR(255) NOT NULL LOCALIZABLE"
Dim   ListBoxTable(4)      : ListBoxTable(0)                = "`ListBox`"
Const ListBox_Property = 1 : ListBoxTable(ListBox_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const ListBox_Order    = 2 : ListBoxTable(ListBox_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const ListBox_Value    = 3 : ListBoxTable(ListBox_Value)    = "`Value` CHAR(64) NOT NULL"
Const ListBox_Text     = 4 : ListBoxTable(ListBox_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Dim   ListViewTable(5)      : ListViewTable(0)                 = "`ListView`"
Const ListView_Property = 1 : ListViewTable(ListView_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const ListView_Order    = 2 : ListViewTable(ListView_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const ListView_Value    = 3 : ListViewTable(ListView_Value)    = "`Value` CHAR(64) NOT NULL"
Const ListView_Text     = 4 : ListViewTable(ListView_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Const ListView_Binary_  = 5 : ListViewTable(ListView_Binary_)  = "`Binary_` CHAR(72)"
Dim   LockPermissionsTable(5)        : LockPermissionsTable(0)                          = "`LockPermissions`"
Const LockPermissions_LockObject = 1 : LockPermissionsTable(LockPermissions_LockObject) = "`LockObject` CHAR(72) NOT NULL PRIMARY KEY"
Const LockPermissions_Table      = 2 : LockPermissionsTable(LockPermissions_Table)      = "`Table` CHAR(32) NOT NULL PRIMARY KEY"
Const LockPermissions_Domain     = 3 : LockPermissionsTable(LockPermissions_Domain)     = "`Domain` CHAR(255) PRIMARY KEY"
Const LockPermissions_User       = 4 : LockPermissionsTable(LockPermissions_User)       = "`User` CHAR(255) NOT NULL PRIMARY KEY"
Const LockPermissions_Permission = 5 : LockPermissionsTable(LockPermissions_Permission) = "`Permission` LONG"
Dim   MIMETable(3)         : MIMETable(0)                = "`MIME`"
Const MIME_ContentType = 1 : MIMETable(MIME_ContentType) = "`ContentType` CHAR(64) NOT NULL PRIMARY KEY"
Const MIME_Extension_  = 2 : MIMETable(MIME_Extension_)  = "`Extension_` CHAR(255) NOT NULL"
Const MIME_CLSID       = 3 : MIMETable(MIME_CLSID)       = "`CLSID` CHAR(38)"
Dim   MediaTable(6)          : MediaTable(0)                  = "`Media`"
Const Media_DiskId       = 1 : MediaTable(Media_DiskId)       = "`DiskId` SHORT NOT NULL PRIMARY KEY"
Const Media_LastSequence = 2 : MediaTable(Media_LastSequence) = "`LastSequence` SHORT NOT NULL"
Const Media_DiskPrompt   = 3 : MediaTable(Media_DiskPrompt)   = "`DiskPrompt` CHAR(64) LOCALIZABLE"
Const Media_Cabinet      = 4 : MediaTable(Media_Cabinet)      = "`Cabinet` CHAR(255)"
Const Media_VolumeLabel  = 5 : MediaTable(Media_VolumeLabel)  = "`VolumeLabel` CHAR(32)"
Const Media_Source       = 6 : MediaTable(Media_Source)       = "`Source` CHAR(32)"
Dim   MoveFileTable(7)          : MoveFileTable(0)                     = "`MoveFile`"
Const MoveFile_FileKey      = 1 : MoveFileTable(MoveFile_FileKey)      = "`FileKey` CHAR(72) NOT NULL PRIMARY KEY"
Const MoveFile_Component_   = 2 : MoveFileTable(MoveFile_Component_)   = "`Component_` CHAR(72) NOT NULL"
Const MoveFile_SourceName   = 3 : MoveFileTable(MoveFile_SourceName)   = "`SourceName` CHAR(255) LOCALIZABLE"
Const MoveFile_DestName     = 4 : MoveFileTable(MoveFile_DestName)     = "`DestName` CHAR(255) LOCALIZABLE"
Const MoveFile_SourceFolder = 5 : MoveFileTable(MoveFile_SourceFolder) = "`SourceFolder` CHAR(72)"
Const MoveFile_DestFolder   = 6 : MoveFileTable(MoveFile_DestFolder)   = "`DestFolder` CHAR(72) NOT NULL"
Const MoveFile_Options      = 7 : MoveFileTable(MoveFile_Options)      = "`Options` SHORT NOT NULL"
Dim   ODBCAttributeTable(3)       : ODBCAttributeTable(0)                       = "`ODBCAttribute`"
Const ODBCAttribute_Driver_   = 1 : ODBCAttributeTable(ODBCAttribute_Driver_)   = "`Driver_` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCAttribute_Attribute = 2 : ODBCAttributeTable(ODBCAttribute_Attribute) = "`Attribute` CHAR(40) NOT NULL PRIMARY KEY"
Const ODBCAttribute_Value     = 3 : ODBCAttributeTable(ODBCAttribute_Value)     = "`Value` CHAR(255) LOCALIZABLE"
Dim   ODBCDataSourceTable(5)               : ODBCDataSourceTable(0)                                = "`ODBCDataSource`"
Const ODBCDataSource_DataSource        = 1 : ODBCDataSourceTable(ODBCDataSource_DataSource)        = "`DataSource` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCDataSource_Component_        = 2 : ODBCDataSourceTable(ODBCDataSource_Component_)        = "`Component_` CHAR(72) NOT NULL"
Const ODBCDataSource_Description       = 3 : ODBCDataSourceTable(ODBCDataSource_Description)       = "`Description` CHAR(255) NOT NULL"
Const ODBCDataSource_DriverDescription = 4 : ODBCDataSourceTable(ODBCDataSource_DriverDescription) = "`DriverDescription` CHAR(255) NOT NULL"
Const ODBCDataSource_Registration      = 5 : ODBCDataSourceTable(ODBCDataSource_Registration)      = "`Registration` SHORT NOT NULL"
Dim   ODBCDriverTable(5)         : ODBCDriverTable(0)                      = "`ODBCDriver`"
Const ODBCDriver_Driver      = 1 : ODBCDriverTable(ODBCDriver_Driver)      = "`Driver` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCDriver_Component_  = 2 : ODBCDriverTable(ODBCDriver_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const ODBCDriver_Description = 3 : ODBCDriverTable(ODBCDriver_Description) = "`Description` CHAR(255) NOT NULL"
Const ODBCDriver_File_       = 4 : ODBCDriverTable(ODBCDriver_File_)       = "`File_` CHAR(72) NOT NULL"
Const ODBCDriver_File_Setup  = 5 : ODBCDriverTable(ODBCDriver_File_Setup)  = "`File_Setup` CHAR(72)"
Dim   ODBCSourceAttributeTable(3)         : ODBCSourceAttributeTable(0)                               = "`ODBCSourceAttribute`"
Const ODBCSourceAttribute_DataSource_ = 1 : ODBCSourceAttributeTable(ODBCSourceAttribute_DataSource_) = "`DataSource_` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCSourceAttribute_Attribute   = 2 : ODBCSourceAttributeTable(ODBCSourceAttribute_Attribute)   = "`Attribute` CHAR(32) NOT NULL PRIMARY KEY"
Const ODBCSourceAttribute_Value       = 3 : ODBCSourceAttributeTable(ODBCSourceAttribute_Value)       = "`Value` CHAR(255) LOCALIZABLE"
Dim   ODBCTranslatorTable(5)         : ODBCTranslatorTable(0)                          = "`ODBCTranslator`"
Const ODBCTranslator_Translator  = 1 : ODBCTranslatorTable(ODBCTranslator_Translator)  = "`Translator` CHAR(72) NOT NULL PRIMARY KEY"
Const ODBCTranslator_Component_  = 2 : ODBCTranslatorTable(ODBCTranslator_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const ODBCTranslator_Description = 3 : ODBCTranslatorTable(ODBCTranslator_Description) = "`Description` CHAR(255) NOT NULL"
Const ODBCTranslator_File_       = 4 : ODBCTranslatorTable(ODBCTranslator_File_)       = "`File_` CHAR(72) NOT NULL"
Const ODBCTranslator_File_Setup  = 5 : ODBCTranslatorTable(ODBCTranslator_File_Setup)  = "`File_Setup` CHAR(72)"
Dim   PatchTable(5)        : PatchTable(0)                = "`Patch`"
Const Patch_File_      = 1 : PatchTable(Patch_File_)      = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const Patch_Sequence   = 2 : PatchTable(Patch_Sequence)   = "`Sequence` SHORT NOT NULL PRIMARY KEY"
Const Patch_PatchSize  = 3 : PatchTable(Patch_PatchSize)  = "`PatchSize` LONG NOT NULL"
Const Patch_Attributes = 4 : PatchTable(Patch_Attributes) = "`Attributes` SHORT NOT NULL"
Const Patch_Header     = 5 : PatchTable(Patch_Header)     = "`Header` OBJECT NOT NULL"
Dim   PatchPackageTable(2)     : PatchPackageTable(0)                    = "`PatchPackage`"
Const PatchPackage_PatchId = 1 : PatchPackageTable(PatchPackage_PatchId) = "`PatchId` CHAR(38) NOT NULL PRIMARY KEY"
Const PatchPackage_Media_  = 2 : PatchPackageTable(PatchPackage_Media_)  = "`Media_` SHORT NOT NULL"
Dim   ProgIdTable(6)           : ProgIdTable(0)                    = "`ProgId`"
Const ProgId_ProgId        = 1 : ProgIdTable(ProgId_ProgId)        = "`ProgId` CHAR(255) NOT NULL PRIMARY KEY"
Const ProgId_ProgId_Parent = 2 : ProgIdTable(ProgId_ProgId_Parent) = "`ProgId_Parent` CHAR(255)"
Const ProgId_Class_        = 3 : ProgIdTable(ProgId_Class_)        = "`Class_` CHAR(38)"
Const ProgId_Description   = 4 : ProgIdTable(ProgId_Description)   = "`Description` CHAR(255) LOCALIZABLE"
Const ProgId_Icon_         = 5 : ProgIdTable(ProgId_Icon_)         = "`Icon_` CHAR(72)"
Const ProgId_IconIndex     = 6 : ProgIdTable(ProgId_IconIndex)     = "`IconIndex` SHORT"
Dim   PropertyTable(2)      : PropertyTable(0)                 = "`Property`"
Const Property_Property = 1 : PropertyTable(Property_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const Property_Value    = 2 : PropertyTable(Property_Value)    = "`Value` LONGCHAR NOT NULL LOCALIZABLE"
Dim   PublishComponentTable(5)         : PublishComponentTable(0)                            = "`PublishComponent`"
Const PublishComponent_ComponentId = 1 : PublishComponentTable(PublishComponent_ComponentId) = "`ComponentId` CHAR(38) NOT NULL PRIMARY KEY"
Const PublishComponent_Qualifier   = 2 : PublishComponentTable(PublishComponent_Qualifier)   = "`Qualifier` CHAR(255) NOT NULL PRIMARY KEY"
Const PublishComponent_Component_  = 3 : PublishComponentTable(PublishComponent_Component_)  = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const PublishComponent_AppData     = 4 : PublishComponentTable(PublishComponent_AppData)     = "`AppData` CHAR(255) LOCALIZABLE"
Const PublishComponent_Feature_    = 5 : PublishComponentTable(PublishComponent_Feature_)    = "`Feature_` CHAR(38) NOT NULL"
Dim   RadioButtonTable(9)      : RadioButtonTable(0)                    = "`RadioButton`"
Const RadioButton_Property = 1 : RadioButtonTable(RadioButton_Property) = "`Property` CHAR(72) NOT NULL PRIMARY KEY"
Const RadioButton_Order    = 2 : RadioButtonTable(RadioButton_Order)    = "`Order` SHORT NOT NULL PRIMARY KEY"
Const RadioButton_Value    = 3 : RadioButtonTable(RadioButton_Value)    = "`Value` CHAR(64) NOT NULL"
Const RadioButton_X        = 4 : RadioButtonTable(RadioButton_X)        = "`X` SHORT NOT NULL"
Const RadioButton_Y        = 5 : RadioButtonTable(RadioButton_Y)        = "`Y` SHORT NOT NULL"
Const RadioButton_Width    = 6 : RadioButtonTable(RadioButton_Width)    = "`Width` SHORT NOT NULL"
Const RadioButton_Height   = 7 : RadioButtonTable(RadioButton_Height)   = "`Height` SHORT NOT NULL"
Const RadioButton_Text     = 8 : RadioButtonTable(RadioButton_Text)     = "`Text` CHAR(64) LOCALIZABLE"
Const RadioButton_Help     = 9 : RadioButtonTable(RadioButton_Help)     = "`Help` CHAR(50) LOCALIZABLE"
Dim   RegLocatorTable(5)        : RegLocatorTable(0)                     = "`RegLocator`"
Const RegLocator_Signature_ = 1 : RegLocatorTable(RegLocator_Signature_) = "`Signature_` CHAR(72) NOT NULL PRIMARY KEY"
Const RegLocator_Root       = 2 : RegLocatorTable(RegLocator_Root)       = "`Root` SHORT NOT NULL"
Const RegLocator_Key        = 3 : RegLocatorTable(RegLocator_Key)        = "`Key` CHAR(255) NOT NULL"
Const RegLocator_Name       = 4 : RegLocatorTable(RegLocator_Name)       = "`Name` CHAR(255)"
Const RegLocator_Type       = 5 : RegLocatorTable(RegLocator_Type)       = "`Type` SHORT"
Dim   RegistryTable(6)        : RegistryTable(0)                   = "`Registry`"
Const Registry_Registry   = 1 : RegistryTable(Registry_Registry)   = "`Registry` CHAR(72) NOT NULL PRIMARY KEY"
Const Registry_Root       = 2 : RegistryTable(Registry_Root)       = "`Root` SHORT NOT NULL"
Const Registry_Key        = 3 : RegistryTable(Registry_Key)        = "`Key` CHAR(255) NOT NULL LOCALIZABLE"
Const Registry_Name       = 4 : RegistryTable(Registry_Name)       = "`Name` CHAR(255) LOCALIZABLE"
Const Registry_Value      = 5 : RegistryTable(Registry_Value)      = "`Value` LONGCHAR LOCALIZABLE"
Const Registry_Component_ = 6 : RegistryTable(Registry_Component_) = "`Component_` CHAR(72) NOT NULL"
Dim   RemoveFileTable(5)         : RemoveFileTable(0)                      = "`RemoveFile`"
Const RemoveFile_FileKey     = 1 : RemoveFileTable(RemoveFile_FileKey)     = "`FileKey` CHAR(72) NOT NULL PRIMARY KEY"
Const RemoveFile_Component_  = 2 : RemoveFileTable(RemoveFile_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const RemoveFile_FileName    = 3 : RemoveFileTable(RemoveFile_FileName)    = "`FileName` CHAR(255) LOCALIZABLE"
Const RemoveFile_DirProperty = 4 : RemoveFileTable(RemoveFile_DirProperty) = "`DirProperty` CHAR(72) NOT NULL"
Const RemoveFile_InstallMode = 5 : RemoveFileTable(RemoveFile_InstallMode) = "`InstallMode` SHORT NOT NULL"
Dim   RemoveIniFileTable(8)           : RemoveIniFileTable(0)                           = "`RemoveIniFile`"
Const RemoveIniFile_RemoveIniFile = 1 : RemoveIniFileTable(RemoveIniFile_RemoveIniFile) = "`RemoveIniFile` CHAR(72) NOT NULL PRIMARY KEY"
Const RemoveIniFile_FileName      = 2 : RemoveIniFileTable(RemoveIniFile_FileName)      = "`FileName` CHAR(255) NOT NULL LOCALIZABLE"
Const RemoveIniFile_DirProperty   = 3 : RemoveIniFileTable(RemoveIniFile_DirProperty)   = "`DirProperty` CHAR(72)"
Const RemoveIniFile_Section       = 4 : RemoveIniFileTable(RemoveIniFile_Section)       = "`Section` CHAR(96) NOT NULL LOCALIZABLE"
Const RemoveIniFile_Key           = 5 : RemoveIniFileTable(RemoveIniFile_Key)           = "`Key` CHAR(128) NOT NULL LOCALIZABLE"
Const RemoveIniFile_Value         = 6 : RemoveIniFileTable(RemoveIniFile_Value)         = "`Value` CHAR(255) LOCALIZABLE"
Const RemoveIniFile_Action        = 7 : RemoveIniFileTable(RemoveIniFile_Action)        = "`Action` SHORT NOT NULL"
Const RemoveIniFile_Component_    = 8 : RemoveIniFileTable(RemoveIniFile_Component_)    = "`Component_` CHAR(72) NOT NULL"
Dim   RemoveRegistryTable(5)            : RemoveRegistryTable(0)                             = "`RemoveRegistry`"
Const RemoveRegistry_RemoveRegistry = 1 : RemoveRegistryTable(RemoveRegistry_RemoveRegistry) = "`RemoveRegistry` CHAR(72) NOT NULL PRIMARY KEY"
Const RemoveRegistry_Root           = 2 : RemoveRegistryTable(RemoveRegistry_Root)           = "`Root` SHORT NOT NULL"
Const RemoveRegistry_Key            = 3 : RemoveRegistryTable(RemoveRegistry_Key)            = "`Key` CHAR(255) NOT NULL LOCALIZABLE"
Const RemoveRegistry_Name           = 4 : RemoveRegistryTable(RemoveRegistry_Name)           = "`Name` CHAR(255) LOCALIZABLE"
Const RemoveRegistry_Component_     = 5 : RemoveRegistryTable(RemoveRegistry_Component_)     = "`Component_` CHAR(72) NOT NULL"
Dim   ReserveCostTable(5)           : ReserveCostTable(0)                         = "`ReserveCost`"
Const ReserveCost_ReserveKey    = 1 : ReserveCostTable(ReserveCost_ReserveKey)    = "`ReserveKey` CHAR(72) NOT NULL PRIMARY KEY"
Const ReserveCost_Component_    = 2 : ReserveCostTable(ReserveCost_Component_)    = "`Component_` CHAR(72) NOT NULL"
Const ReserveCost_ReserveFolder = 3 : ReserveCostTable(ReserveCost_ReserveFolder) = "`ReserveFolder` CHAR(72)"
Const ReserveCost_ReserveLocal  = 4 : ReserveCostTable(ReserveCost_ReserveLocal)  = "`ReserveLocal` LONG NOT NULL"
Const ReserveCost_ReserveSource = 5 : ReserveCostTable(ReserveCost_ReserveSource) = "`ReserveSource` LONG NOT NULL"
Dim   SelfRegTable(2)   : SelfRegTable(0)             = "`SelfReg`"
Const SelfReg_File_ = 1 : SelfRegTable(SelfReg_File_) = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const SelfReg_Cost  = 2 : SelfRegTable(SelfReg_Cost)  = "`Cost` SHORT"
Dim   ServiceControlTable(6)            : ServiceControlTable(0)                             = "`ServiceControl`"
Const ServiceControl_ServiceControl = 1 : ServiceControlTable(ServiceControl_ServiceControl) = "`ServiceControl` CHAR(72) NOT NULL PRIMARY KEY"
Const ServiceControl_Name           = 2 : ServiceControlTable(ServiceControl_Name)           = "`Name` CHAR(255) NOT NULL LOCALIZABLE"
Const ServiceControl_Event          = 3 : ServiceControlTable(ServiceControl_Event)          = "`Event` SHORT NOT NULL"
Const ServiceControl_Arguments      = 4 : ServiceControlTable(ServiceControl_Arguments)      = "`Arguments` CHAR(255) LOCALIZABLE"
Const ServiceControl_Wait           = 5 : ServiceControlTable(ServiceControl_Wait)           = "`Wait` SHORT"
Const ServiceControl_Component_     = 6 : ServiceControlTable(ServiceControl_Component_)     = "`Component_` CHAR(72) NOT NULL"
Dim   ServiceInstallTable(13)           : ServiceInstallTable(0)                             = "`ServiceInstall`"
Const ServiceInstall_ServiceInstall = 1 : ServiceInstallTable(ServiceInstall_ServiceInstall) = "`ServiceInstall` CHAR(72) NOT NULL PRIMARY KEY"
Const ServiceInstall_Name           = 2 : ServiceInstallTable(ServiceInstall_Name)           = "`Name` CHAR(255) NOT NULL"
Const ServiceInstall_DisplayName    = 3 : ServiceInstallTable(ServiceInstall_DisplayName)    = "`DisplayName` CHAR(255) LOCALIZABLE"
Const ServiceInstall_ServiceType    = 4 : ServiceInstallTable(ServiceInstall_ServiceType)    = "`ServiceType` LONG NOT NULL"
Const ServiceInstall_StartType      = 5 : ServiceInstallTable(ServiceInstall_StartType)      = "`StartType` LONG NOT NULL"
Const ServiceInstall_ErrorControl   = 6 : ServiceInstallTable(ServiceInstall_ErrorControl)   = "`ErrorControl` LONG NOT NULL"
Const ServiceInstall_LoadOrderGroup = 7 : ServiceInstallTable(ServiceInstall_LoadOrderGroup) = "`LoadOrderGroup` CHAR(255)"
Const ServiceInstall_Dependencies   = 8 : ServiceInstallTable(ServiceInstall_Dependencies)   = "`Dependencies` CHAR(255)"
Const ServiceInstall_StartName      = 9 : ServiceInstallTable(ServiceInstall_StartName)      = "`StartName` CHAR(255)"
Const ServiceInstall_Password       =10 : ServiceInstallTable(ServiceInstall_Password)       = "`Password` CHAR(255)"
Const ServiceInstall_Arguments      =11 : ServiceInstallTable(ServiceInstall_Arguments)      = "`Arguments` CHAR(255)"
Const ServiceInstall_Component_     =12 : ServiceInstallTable(ServiceInstall_Component_)     = "`Component_` CHAR(72) NOT NULL"
Const ServiceInstall_Description    =13 : ServiceInstallTable(ServiceInstall_Description)    = "`Description` CHAR(255) LOCALIZABLE"
Dim   ShortcutTable(12)        : ShortcutTable(0)                    = "`Shortcut`"
Const Shortcut_Shortcut    = 1 : ShortcutTable(Shortcut_Shortcut)    = "`Shortcut` CHAR(72) NOT NULL PRIMARY KEY"
Const Shortcut_Directory_  = 2 : ShortcutTable(Shortcut_Directory_)  = "`Directory_` CHAR(72) NOT NULL"
Const Shortcut_Name        = 3 : ShortcutTable(Shortcut_Name)        = "`Name` CHAR(128) NOT NULL LOCALIZABLE"
Const Shortcut_Component_  = 4 : ShortcutTable(Shortcut_Component_)  = "`Component_` CHAR(72) NOT NULL"
Const Shortcut_Target      = 5 : ShortcutTable(Shortcut_Target)      = "`Target` CHAR(72) NOT NULL"
Const Shortcut_Arguments   = 6 : ShortcutTable(Shortcut_Arguments)   = "`Arguments` CHAR(255)"
Const Shortcut_Description = 7 : ShortcutTable(Shortcut_Description) = "`Description` CHAR(255) LOCALIZABLE"
Const Shortcut_Hotkey      = 8 : ShortcutTable(Shortcut_Hotkey)      = "`Hotkey` SHORT"
Const Shortcut_Icon_       = 9 : ShortcutTable(Shortcut_Icon_)       = "`Icon_` CHAR(72)"
Const Shortcut_IconIndex   =10 : ShortcutTable(Shortcut_IconIndex)   = "`IconIndex` SHORT"
Const Shortcut_ShowCmd     =11 : ShortcutTable(Shortcut_ShowCmd)     = "`ShowCmd` SHORT"
Const Shortcut_WkDir       =12 : ShortcutTable(Shortcut_WkDir)       = "`WkDir` CHAR(72)"
Dim   SignatureTable(9)        : SignatureTable(0)                    = "`Signature`"
Const Signature_Signature  = 1 : SignatureTable(Signature_Signature)  = "`Signature` CHAR(72) NOT NULL PRIMARY KEY"
Const Signature_FileName   = 2 : SignatureTable(Signature_FileName)   = "`FileName` CHAR(255) NOT NULL"
Const Signature_MinVersion = 3 : SignatureTable(Signature_MinVersion) = "`MinVersion` CHAR(20)"
Const Signature_MaxVersion = 4 : SignatureTable(Signature_MaxVersion) = "`MaxVersion` CHAR(20)"
Const Signature_MinSize    = 5 : SignatureTable(Signature_MinSize)    = "`MinSize` LONG"
Const Signature_MaxSize    = 6 : SignatureTable(Signature_MaxSize)    = "`MaxSize` LONG"
Const Signature_MinDate    = 7 : SignatureTable(Signature_MinDate)    = "`MinDate` LONG"
Const Signature_MaxDate    = 8 : SignatureTable(Signature_MaxDate)    = "`MaxDate` LONG"
Const Signature_Languages  = 9 : SignatureTable(Signature_Languages)  = "`Languages` CHAR(255)"
Dim   TextStyleTable(5)       : TextStyleTable(0)                   = "`TextStyle`"
Const TextStyle_TextStyle = 1 : TextStyleTable(TextStyle_TextStyle) = "`TextStyle` CHAR(72) NOT NULL PRIMARY KEY"
Const TextStyle_FaceName  = 2 : TextStyleTable(TextStyle_FaceName)  = "`FaceName` CHAR(32) NOT NULL"
Const TextStyle_Size      = 3 : TextStyleTable(TextStyle_Size)      = "`Size` SHORT NOT NULL"
Const TextStyle_Color     = 4 : TextStyleTable(TextStyle_Color)     = "`Color` LONG"
Const TextStyle_StyleBits = 5 : TextStyleTable(TextStyle_StyleBits) = "`StyleBits` SHORT"
Dim   TypeLibTable(8)         : TypeLibTable(0)                   = "`TypeLib`"
Const TypeLib_LibID       = 1 : TypeLibTable(TypeLib_LibID)       = "`LibID` CHAR(38) NOT NULL PRIMARY KEY"
Const TypeLib_Language    = 2 : TypeLibTable(TypeLib_Language)    = "`Language` SHORT NOT NULL PRIMARY KEY"
Const TypeLib_Component_  = 3 : TypeLibTable(TypeLib_Component_)  = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const TypeLib_Version     = 4 : TypeLibTable(TypeLib_Version)     = "`Version` SHORT"
Const TypeLib_Description = 5 : TypeLibTable(TypeLib_Description) = "`Description` CHAR(128) LOCALIZABLE"
Const TypeLib_Directory_  = 6 : TypeLibTable(TypeLib_Directory_)  = "`Directory_` CHAR(72)"
Const TypeLib_Feature_    = 7 : TypeLibTable(TypeLib_Feature_)    = "`Feature_` CHAR(38)"
Const TypeLib_Cost        = 8 : TypeLibTable(TypeLib_Cost)        = "`Cost` LONG"
Dim   UITextTable(2)  : UITextTable(0)           = "`UIText`"
Const UIText_Key  = 1 : UITextTable(UIText_Key)  = "`Key` CHAR(72) NOT NULL PRIMARY KEY"
Const UIText_Text = 2 : UITextTable(UIText_Text) = "`Text` CHAR(255) LOCALIZABLE"
Dim   UpgradeTable(7)            : UpgradeTable(0)                      = "`Upgrade`"
Const Upgrade_UpgradeCode    = 1 : UpgradeTable(Upgrade_UpgradeCode)    = "`UpgradeCode` CHAR(38) NOT NULL PRIMARY KEY"
Const Upgrade_VersionMin     = 2 : UpgradeTable(Upgrade_VersionMin)     = "`VersionMin` CHAR(20) PRIMARY KEY"
Const Upgrade_VersionMax     = 3 : UpgradeTable(Upgrade_VersionMax)     = "`VersionMax` CHAR(20) PRIMARY KEY"
Const Upgrade_Language       = 4 : UpgradeTable(Upgrade_Language)       = "`Language` CHAR(255) PRIMARY KEY"
Const Upgrade_Attributes     = 5 : UpgradeTable(Upgrade_Attributes)     = "`Attributes` LONG NOT NULL PRIMARY KEY"
Const Upgrade_Remove         = 6 : UpgradeTable(Upgrade_Remove)         = "`Remove` CHAR(255)"
Const Upgrade_ActionProperty = 7 : UpgradeTable(Upgrade_ActionProperty) = "`ActionProperty` CHAR(72) NOT NULL"
Dim   VerbTable(5)        : VerbTable(0)               = "`Verb`"
Const Verb_Extension_ = 1 : VerbTable(Verb_Extension_) = "`Extension_` CHAR(255) NOT NULL PRIMARY KEY"
Const Verb_Verb       = 2 : VerbTable(Verb_Verb)       = "`Verb` CHAR(32) NOT NULL PRIMARY KEY"
Const Verb_Sequence   = 3 : VerbTable(Verb_Sequence)   = "`Sequence` SHORT"
Const Verb_Command    = 4 : VerbTable(Verb_Command)    = "`Command` CHAR(255) LOCALIZABLE"
Const Verb_Argument   = 5 : VerbTable(Verb_Argument)   = "`Argument` CHAR(255) LOCALIZABLE"
Dim   ValidationTable(10)        : ValidationTable(0)                      = "`_Validation`"
Const Validation_Table       = 1 : ValidationTable(Validation_Table)       = "`Table` CHAR(32) NOT NULL PRIMARY KEY"
Const Validation_Column      = 2 : ValidationTable(Validation_Column)      = "`Column` CHAR(32) NOT NULL PRIMARY KEY"
Const Validation_Nullable    = 3 : ValidationTable(Validation_Nullable)    = "`Nullable` CHAR(4) NOT NULL"
Const Validation_MinValue    = 4 : ValidationTable(Validation_MinValue)    = "`MinValue` LONG"
Const Validation_MaxValue    = 5 : ValidationTable(Validation_MaxValue)    = "`MaxValue` LONG"
Const Validation_KeyTable    = 6 : ValidationTable(Validation_KeyTable)    = "`KeyTable` CHAR(255)"
Const Validation_KeyColumn   = 7 : ValidationTable(Validation_KeyColumn)   = "`KeyColumn` SHORT"
Const Validation_Category    = 8 : ValidationTable(Validation_Category)    = "`Category` CHAR(32)"
Const Validation_Set         = 9 : ValidationTable(Validation_Set)         = "`Set` CHAR(255)"
Const Validation_Description =10 : ValidationTable(Validation_Description) = "`Description` CHAR(255)"

' windows installer 1.5 tables
Dim MsiAssemblyTable(5): MsiAssemblyTable(0) = "`MsiAssembly`"
Const MsiAssembly_Component_ = 1 : MsiAssemblyTable(MsiAssembly_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiAssembly_Feature_ = 2 : MsiAssemblyTable(MsiAssembly_Feature_) = "`Feature_` CHAR(38) NOT NULL"
Const MsiAssembly_File_Manifest = 3 : MsiAssemblyTable(MsiAssembly_File_Manifest)  = "`File_Manifest` CHAR(72)"
Const MsiAssembly_File_Application = 4 : MsiAssemblyTable(MsiAssembly_File_Application)  = "`File_Application` CHAR(72)"
Const MsiAssembly_Attributes = 5 : MsiAssemblyTable(MsiAssembly_Attributes)  = "`Attributes` SHORT NOT NULL"
Dim MsiAssemblyNameTable(3): MsiAssemblyNameTable(0) = "`MsiAssemblyName`"
Const MsiAssemblyName_Component_ = 1 : MsiAssemblyNameTable(MsiAssemblyName_Component_) = "`Component_` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiAssemblyName_Name = 2 : MsiAssemblyNameTable(MsiAssemblyName_Name) = "`Name` CHAR(255) NOT NULL PRIMARY KEY"
Const MsiAssemblyName_Value  = 3 : MsiAssemblyNameTable(MsiAssemblyName_Value)  = "`Value` CHAR(255)"
Dim MsiDigitalCertificateTable(2): MsiDigitalCertificateTable(0) = "`MsiDigitalCertificate`"
Const MsiDigitalCertificate_DigitalCertificate = 1 : MsiDigitalCertificateTable(MsiDigitalCertificate_DigitalCertificate) = "`DigitalCertificate` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiDigitalCertificate_CertData = 2 : MsiDigitalCertificateTable(MsiDigitalCertificate_CertData) = "`CertData` OBJECT NOT NULL"
Dim MsiDigitalSignatureTable(4): MsiDigitalSignatureTable(0) = "`MsiDigitalSignature`"
Const MsiDigitalSignature_Table = 1 : MsiDigitalSignatureTable(MsiDigitalSignature_Table) = "`Table` CHAR(32) NOT NULL PRIMARY KEY"
Const MsiDigitalSignature_SignObject = 2 : MsiDigitalSignatureTable(MsiDigitalSignature_SignObject) = "`SignObject` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiDigitalSignature_DigitalCertificate_ = 3 : MsiDigitalSignatureTable(MsiDigitalSignature_DigitalCertificate_)  = "`DigitalCertificate_` CHAR(72) NOT NULL"
Const MsiDigitalSignature_Hash = 4 : MsiDigitalSignatureTable(MsiDigitalSignature_Hash)  = "`Hash` OBJECT"
Dim MsiFileHashTable(6): MsiFileHashTable(0) = "`MsiFileHash`"
Const MsiFileHash_File_ = 1 : MsiFileHashTable(MsiFileHash_File_) = "`File_` CHAR(72) NOT NULL PRIMARY KEY"
Const MsiFileHash_Options = 2 : MsiFileHashTable(MsiFileHash_Options) = "`Options` SHORT NOT NULL"
Const MsiFileHash_HashPart1 = 3 : MsiFileHashTable(MsiFileHash_HashPart1) = "`HashPart1` LONG NOT NULL"
Const MsiFileHash_HashPart2 = 4 : MsiFileHashTable(MsiFileHash_HashPart2) = "`HashPart2` LONG NOT NULL"
Const MsiFileHash_HashPart3 = 5 : MsiFileHashTable(MsiFileHash_HashPart3) = "`HashPart3` LONG NOT NULL"
Const MsiFileHash_HashPart4 = 6 : MsiFileHashTable(MsiFileHash_HashPart4) = "`HashPart4` LONG NOT NULL"

' merge module only tables
Dim   ModuleSignatureTable(3): ModuleSignatureTable(0)        = "`ModuleSignature`"
Const ModuleSignature_ModuleID = 1 : ModuleSignatureTable(ModuleSignature_ModuleID) = "`ModuleID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleSignature_Language = 2 : ModuleSignatureTable(ModuleSignature_Language) = "`Language` SHORT NOT NULL PRIMARY KEY"
Const ModuleSignature_Version  = 3 : ModuleSignatureTable(ModuleSignature_Version)  = "`Version` CHAR(72) NOT NULL"
Dim   ModuleComponentsTable(3): ModuleComponentsTable(0)         = "`ModuleComponents`"
Const ModuleComponents_Component  = 1 : ModuleComponentsTable(ModuleComponents_Component)  = "`Component` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleComponents_ModuleID   = 2 : ModuleComponentsTable(ModuleComponents_ModuleID)   = "`ModuleID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleComponents_Language   = 3 : ModuleComponentsTable(ModuleComponents_Language)   = "`Language` SHORT NOT NULL PRIMARY KEY"
Dim   ModuleDependencyTable(5)              : ModuleDependencyTable(0)                                 = "`ModuleDependency`"
Const ModuleDependency_ModuleID         = 1 : ModuleDependencyTable(ModuleDependency_ModuleID)         = "`ModuleID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleDependency_ModuleLanguage   = 2 : ModuleDependencyTable(ModuleDependency_ModuleLanguage)   = "`ModuleLanguage` SHORT NOT NULL PRIMARY KEY"
Const ModuleDependency_RequiredID       = 3 : ModuleDependencyTable(ModuleDependency_RequiredID)       = "`RequiredID` CHAR(72) NOT NULL PRIMARY KEY"
Const ModuleDependency_RequiredLanguage = 4 : ModuleDependencyTable(ModuleDependency_RequiredLanguage) = "`RequiredLanguage` SHORT NOT NULL PRIMARY KEY"
Const ModuleDependency_RequiredVersion  = 5 : ModuleDependencyTable(ModuleDependency_RequiredVersion)  = "`RequiredVersion` CHAR(72)"

' patching tables
Dim   ExternalFilesTable(8)           : ExternalFilesTable(0)                           = "`ExternalFiles`"
Const ExternalFiles_Family        = 1 : ExternalFilesTable(ExternalFiles_Family)        = "`Family` CHAR(8) NOT NULL PRIMARY KEY"
Const ExternalFiles_FTK           = 2 : ExternalFilesTable(ExternalFiles_FTK)           = "`FTK` CHAR(128) NOT NULL PRIMARY KEY"
Const ExternalFiles_FilePath      = 3 : ExternalFilesTable(ExternalFiles_FilePath)      = "`FilePath` CHAR(255) NOT NULL PRIMARY KEY"
Const ExternalFiles_SymbolPaths   = 4 : ExternalFilesTable(ExternalFiles_SymbolPaths)   = "`SymbolPaths` CHAR(255)"
Const ExternalFiles_IgnoreOffsets = 5 : ExternalFilesTable(ExternalFiles_IgnoreOffsets) = "`IgnoreOffsets` CHAR(255)"
Const ExternalFiles_IgnoreLengths = 6 : ExternalFilesTable(ExternalFiles_IgnoreLengths) = "`IgnoreLengths` CHAR(255)"
Const ExternalFiles_RetainOffsets = 7 : ExternalFilesTable(ExternalFiles_RetainOffsets) = "`RetainOffsets` CHAR(255)"
Const ExternalFiles_Order         = 8 : ExternalFilesTable(ExternalFiles_Order)         = "`Order` SHORT NOT NULL"
Dim   FamilyFileRangesTable(4)               : FamilyFileRangesTable(0)                             = "`FamilyFileRanges`"
Const FamilyFileRanges_Family         = 1 : FamilyFileRangesTable(FamilyFileRanges_Family)          = "`Family` CHAR(8) NOT NULL PRIMARY KEY"
Const FamilyFileRanges_FTK           = 2 : FamilyFileRangesTable(FamilyFileRanges_FTK)           = "`FTK` CHAR(128) NOT NULL PRIMARY KEY"
Const FamilyFileRanges_RetainOffsets = 3 : FamilyFileRangesTable(FamilyFileRanges_RetainOffsets) = "`RetainOffsets` CHAR(128) NOT NULL"
Const FamilyFileRanges_RetainLengths = 4 : FamilyFileRangesTable(FamilyFileRanges_RetainLengths) = "`RetainLengths` CHAR(128) NOT NULL"
Dim   ImageFamiliesTable(6)               : ImageFamiliesTable(0)                              = "`ImageFamilies`"
Const ImageFamilies_Family            = 1 : ImageFamiliesTable(ImageFamilies_Family)           = "`Family` CHAR(8) NOT NULL PRIMARY KEY"
Const ImageFamilies_MediaSrcPropName  = 2 : ImageFamiliesTable(ImageFamilies_MediaSrcPropName) = "`MediaSrcPropName` CHAR(72) NOT NULL"
Const ImageFamilies_MediaDiskId       = 3 : ImageFamiliesTable(ImageFamilies_MediaDiskId)      = "`MediaDiskId` SHORT NOT NULL"
Const ImageFamilies_FileSequenceStart = 4 : ImageFamiliesTable(ImageFamilies_FileSequenceStart)= "`FileSequenceStart` SHORT NOT NULL"
Const ImageFamilies_DiskPrompt        = 5 : ImageFamiliesTable(ImageFamilies_DiskPrompt)       = "`DiskPrompt` CHAR(128)"
Const ImageFamilies_VolumeLabel       = 6 : ImageFamiliesTable(ImageFamilies_VolumeLabel)      = "`VolumeLabel` CHAR(32)"
Dim   PropertiesTable(2)      : PropertiesTable(0)                   = "`Properties`"
Const Properties_Name = 1 : PropertiesTable(Properties_Name) = "`Name` CHAR(72) NOT NULL PRIMARY KEY"
Const Properties_Value    = 2 : PropertiesTable(Properties_Value)    = "`Value` CHAR(128) NOT NULL LOCALIZABLE"
Dim   TargetFiles_OptionalDataTable(6)               : TargetFiles_OptionalDataTable(0)                              = "`TargetFiles_OptionalData`"
Const TargetFiles_OptionalData_Target            = 1 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_Target)           = "`Target` CHAR(13) NOT NULL PRIMARY KEY"
Const TargetFiles_OptionalData_FTK  = 2 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_FTK) = "`FTK` CHAR(255) NOT NULL PRIMARY KEY"
Const TargetFiles_OptionalData_SymbolPaths       = 3 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_SymbolPaths)      = "`SymbolPaths` CHAR(255)"
Const TargetFiles_OptionalData_IgnoreOffsets = 4 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_IgnoreOffsets)= "`IgnoreOffsets` CHAR(255)"
Const TargetFiles_OptionalData_IgnoreLengths        = 5 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_IgnoreLengths)       = "`IgnoreLengths` CHAR(255)"
Const TargetFiles_OptionalData_RetainOffsets       = 6 : TargetFiles_OptionalDataTable(TargetFiles_OptionalData_RetainOffsets)      = "`RetainOffsets` CHAR(255)"
Dim   TargetImagesTable(7)                   : TargetImagesTable(0)                                  = "`TargetImages`"
Const TargetImages_Target                = 1 : TargetImagesTable(TargetImages_Target)                = "`Target` CHAR(13) NOT NULL PRIMARY KEY"
Const TargetImages_MsiPath               = 2 : TargetImagesTable(TargetImages_MsiPath)               = "`MsiPath` CHAR(255) NOT NULL"
Const TargetImages_SymbolPaths           = 3 : TargetImagesTable(TargetImages_SymbolPaths)           = "`SymbolPaths` CHAR(255)"
Const TargetImages_Upgraded              = 4 : TargetImagesTable(TargetImages_Upgraded)              = "`Upgraded` CHAR(13) NOT NULL"
Const TargetImages_Order                 = 5 : TargetImagesTable(TargetImages_Order)                 = "`Order` SHORT NOT NULL"
Const TargetImages_ProductValidateFlags  = 6 : TargetImagesTable(TargetImages_ProductValidateFlags)  = "`ProductValidateFlags` CHAR(16)"
Const TargetImages_IgnoreMissingSrcFiles = 7 : TargetImagesTable(TargetImages_IgnoreMissingSrcFiles) = "`IgnoreMissingSrcFiles` SHORT NOT NULL"
Dim   UpgradedFilesToIgnoreTable(2)      : UpgradedFilesToIgnoreTable(0)                              = "`UpgradedFilesToIgnore`"
Const UpgradedFilesToIgnore_Upgraded = 1 : UpgradedFilesToIgnoreTable(UpgradedFilesToIgnore_Upgraded) = "`Upgraded` CHAR(13) NOT NULL PRIMARY KEY"
Const UpgradedFilesToIgnore_FTK      = 2 : UpgradedFilesToIgnoreTable(UpgradedFilesToIgnore_FTK)      = "`FTK` CHAR(255) NOT NULL PRIMARY KEY"
Dim   UpgradedFiles_OptionalDataTable(5)              : UpgradedFiles_OptionalDataTable(0)                                      = "`UpgradedFiles_OptionalData`"
Const UpgradedFiles_OptionalData_Upgraded         = 1 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_Upgraded)    = "`Upgraded` CHAR(13) NOT NULL PRIMARY KEY"
Const UpgradedFiles_OptionalData_FTK              = 2 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_FTK)         = "`FTK` CHAR(255) NOT NULL PRIMARY KEY"
Const UpgradedFiles_OptionalData_SymbolPaths      = 3 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_SymbolPaths) = "`SymbolPaths` CHAR(255)"
Const UpgradedFiles_OptionalData_AllowIgnoreOnPatchError = 4 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_AllowIgnoreOnPatchError) = "`AllowIgnoreOnPatchError` SHORT"
Const UpgradedFiles_OptionalData_IncludeWholeFile = 5 : UpgradedFiles_OptionalDataTable(UpgradedFiles_OptionalData_IncludeWholeFile) = "`IncludeWholeFile` SHORT"
Dim   UpgradedImagesTable(5)          : UpgradedImagesTable(0)                           = "`UpgradedImages`"
Const UpgradedImages_Upgraded     = 1 : UpgradedImagesTable(UpgradedImages_Upgraded)     = "`Upgraded` CHAR(13) NOT NULL PRIMARY KEY"
Const UpgradedImages_MsiPath      = 2 : UpgradedImagesTable(UpgradedImages_MsiPath)      = "`MsiPath` CHAR(255) NOT NULL"
Const UpgradedImages_PatchMsiPath = 3 : UpgradedImagesTable(UpgradedImages_PatchMsiPath) = "`PatchMsiPath` CHAR(255)"
Const UpgradedImages_SymbolPaths  = 4 : UpgradedImagesTable(UpgradedImages_SymbolPaths)  = "`SymbolPaths` CHAR(255)"
Const UpgradedImages_Family       = 5 : UpgradedImagesTable(UpgradedImages_Family)       = "`Family` CHAR(8) NOT NULL"

Dim   dictStdDirs                : Set dictStdDirs = CreateObject("Scripting.Dictionary")
   dictStdDirs.Add "AdminToolsFolder", ""
   dictStdDirs.Add "AppDataFolder", ""
   dictStdDirs.Add "CommonAppDataFolder", ""
   dictStdDirs.Add "CommonFilesFolder", ""
   dictStdDirs.Add "DesktopFolder", ""
   dictStdDirs.Add "FavoritesFolder", ""
   dictStdDirs.Add "FontsFolder", ""
   dictStdDirs.Add "LocalAppDataFolder", ""
   dictStdDirs.Add "MyPicturesFolder", ""
   dictStdDirs.Add "PersonalFolder", ""
   dictStdDirs.Add "ProgramFilesFolder", ""
   dictStdDirs.Add "ProgramMenuFolder", ""
   dictStdDirs.Add "SendToFolder", ""
   dictStdDirs.Add "StartMenuFolder", ""
   dictStdDirs.Add "StartupFolder", ""
   dictStdDirs.Add "System16Folder", ""
   dictStdDirs.Add "SystemFolder", ""
   dictStdDirs.Add "TempFolder", ""
   dictStdDirs.Add "TemplateFolder", ""
   dictStdDirs.Add "WindowsFolder", ""
   dictStdDirs.Add "WindowsVolume", ""
   dictStdDirs.Add "CommonFiles64Folder", ""
   dictStdDirs.Add "ProgramFiles64Folder", ""
   dictStdDirs.Add "System64Folder", ""
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\widir.inc ===
'<script language='VBScript'>
' wiconsts.inc - VBScript constants
'
'  2000/06/12 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    ResolveFileSourcePath
'    ResolveDirectorySourcePath
'
'    GetDefaultDir

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveFileSourcePath
Function ResolveFileSourcePath(db, sKey, fLong)
   Dim sDir, sFile
   Dim vw, rec

   Set vw = db.OpenView("SELECT `Directory_`, `FileName` FROM `Component`, `File` WHERE `Component`.`Component`=`File`.`Component_` AND `File`.`File`='" & sKey & "'")
   vw.Execute
   Set rec = vw.Fetch
   If rec Is Nothing Then
      ResolveFileSourcePath = Empty
   Else
      sDir = ResolveDirectorySourcePath(db, rec.StringData(1), fLong)
      sFile = GetDefaultDir(rec.StringData(2), True, fLong)

      ResolveFileSourcePath = sDir & sFile
   End If
End Function   ' ResolveFileSourcePath


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveFileTargetPath
Function ResolveFileTargetPath(db, sKey, fLong)
   Dim sDir, sFile
   Dim vw, rec

   Set vw = db.OpenView("SELECT `Directory_`, `FileName` FROM `Component`, `File` WHERE `Component`.`Component`=`File`.`Component_` AND `File`.`File`='" & sKey & "'")
   vw.Execute
   Set rec = vw.Fetch
   If rec Is Nothing Then
      ResolveFileTargetPath = Empty
   Else
      sDir = ResolveDirectoryTargetPath(db, rec.StringData(1), fLong)
      sFile = GetDefaultDir(rec.StringData(2), False, fLong)

      ResolveFileTargetPath = sDir & sFile
   End If
End Function   ' ResolveFileTargetPath


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveDirectorySourcePath
Function ResolveDirectorySourcePath(db, sKey, fLong)
   Dim vw, rec

   Set vw = db.OpenView("SELECT Directory_Parent, DefaultDir FROM Directory WHERE Directory=?")
   Set rec = installer.CreateRecord(1)
   rec.StringData(1) = sKey
   ResolveDirectorySourcePath = widir_ResolveDirectory(vw, rec, True, fLong)
End Function   ' ResolveDirectorySourcePath


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ResolveDirectoryTargetPath
Function ResolveDirectoryTargetPath(db, sKey, fLong)
   Dim vw, rec

   Set vw = db.OpenView("SELECT Directory_Parent, DefaultDir FROM Directory WHERE Directory=?")
   Set rec = installer.CreateRecord(1)
   rec.StringData(1) = sKey
   ResolveDirectoryTargetPath = widir_ResolveDirectory(vw, rec, False, fLong)
End Function   ' ResolveDirectoryTargetPath


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' widir_ResolveDirectory
Function widir_ResolveDirectory(vw, rec, fSource, fLong)
   Dim sDir, sPath, sTemp

   sPath = Empty
   Do
      sDir = rec.StringData(1)

      vw.Execute rec
      Set rec = vw.Fetch

      If rec Is Nothing Then Exit Do

      If Not fSource Then
         Select Case rec.StringData(1)
         Case "ProgramFilesFolder" : sPath = "PFILES\" & sPath : Exit Do
         Case "WindowsFolder" : sPath = "WIN\" & sPath : Exit Do
         Case "SystemFolder" : sPath = "SYS\" & sPath : Exit Do
         Case "System16Folder" : sPath = "Sys16\" & sPath : Exit Do
         End Select
      End If

      sTemp = GetDefaultDir(rec.StringData(2), fSource, fLong)
      If 0 <  Len(sTemp) And "." <> sTemp Then sPath = sTemp & "\" & sPath
   Loop While (0 < Len(rec.StringData(1)))

   widir_ResolveDirectory = sPath
End Function   ' widir_ResolveDirectory


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' GetDefaultDir
Function GetDefaultDir(ByVal s, fSource, fLong)
   Dim a
   a = Split(s, ":")
   If fSource And 1 = UBound(a) Then s = Split(a(1), "|") Else s = Split(a(0), "|")
   If fLong And 1 = UBound(s) Then GetDefaultDir = s(1) Else GetDefaultDir = s(0)
End Function   ' GetDefaultDir
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\wixerror.inc ===
'<script language='VBScript'>
' wixerror.inc - preprocessor for Windows Installer XML
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'
' entrypoints:
'    Fail
'

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' Fail
Sub Fail(sMsg)
   WScript.Echo sMsg
   WScript.Quit -1
End Sub   ' Fail
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\wiconst.inc ===
'<script language='VBScript'>
' wiconsts.inc - Windows Installer constants
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

'''''''''''''''''''''''''''''''''''''''''''''''''
' Windows Installer definitions - from msidefs.h
Const msiOpenDatabaseModeReadOnly = 0
Const msiOpenDatabaseModeTransact = 1
Const msiOpenDatabaseModeDirect   = 2
Const msiOpenDatabaseModeCreate   = 3
Const msiViewModifySeek     = -1
Const msiViewModifyInsert   = 1
Const msiViewModifyUpdate   = 2
Const msiViewModifyAssign   = 3
Const msiViewModifyReplace  = 4
Const msiViewModifyMerge    = 5
Const msiViewModifyDelete   = 6

' Component.Attributes mapping
Const msidbComponentAttributesSourceOnly   = &h01
Const msidbComponentAttributesOptional   = &h02
Const msidbComponentAttributesRegistryKeyPath   = &h04
Const msidbComponentAttributesSharedDllRefCount = &h08
Const msidbComponentAttributesPermanent         = &h10
Const msidbComponentAttributesODBCDataSource    = &h20
Const msidbComponentAttributesTransitive        = &h40
Const msidbComponentAttributesNeverOverwrite    = &h80
Const msidbComponentAttributes64bit             = &h100

' File.Attributes mapping
Const msidbFileAttributesReadOnly      = &h0001
Const msidbFileAttributesHidden        = &h0002
Const msidbFileAttributesSystem        = &h0004
Const msidbFileAttributesVital         = &h0200
Const msidbFileAttributesChecksum      = &h0400
Const msidbFileAttributesPatchAdded    = &h1000
Const msidbFileAttributesNoncompressed = &h2000
Const msidbFileAttributesCompressed    = &h4000

' Feature.Attributes mapping
Const msidbFeatureAttributesFavorSource            = &h0001
Const msidbFeatureAttributesFollowParent           = &h0002
Const msidbFeatureAttributesFavorAdvertise         = &h0004
Const msidbFeatureAttributesDisallowAdvertise      = &h0008
Const msidbFeatureAttributesUIDisallowAbsent       = &h0010
Const msidbFeatureAttributesNoUnsupportedAdvertise = &h0020

' Class.Attributes mapping
Const msidbClassAttributesRelativePath = &h0001

' ServiceControl.Event
Const msidbServiceControlEventStart           = &h0001
Const msidbServiceControlEventStop            = &h0002
Const msidbServiceControlEventRemove          = &h0008
Const msidbServiceControlEventUninstallStart  = &h0010
Const msidbServiceControlEventUninstallStop   = &h0020
Const msidbServiceControlEventUninstallRemove = &h0080

' ServiceInstall.ServiceType
Const msidbServiceInstallOwnProcess           = &h0010
Const msidbServiceInstallShareProcess         = &h0020
Const msidbServiceInstallInteractive          = &h0100

' ServiceInstall.StartType
Const msidbServiceInstallAutoStart            = &h0002
Const msidbServiceInstallDemandStart          = &h0003
Const msidbServiceInstallDisabled             = &h0004

' ServiceInstall.ErrorControl
Const msidbServiceInstallErrorIgnore          = &h0000
Const msidbServiceInstallErrorNormal          = &h0001
Const msidbServiceInstallErrorCritical        = &h0004
Const msidbServiceInstallErrorControlVital    = &h8000

' IniFile actions
Const msidbIniFileActionAddLine    = 0
Const msidbIniFileActionCreateLine = 1
Const msidbIniFileActionRemoveLine = 2
Const msidbIniFileActionAddTag     = 3
Const msidbIniFileActionRemoveTag  = 4

' CustomAction.Type mapping
Const msidbCustomActionTypeDll            = &h0001 ' Target = entry point name
Const msidbCustomActionTypeExe            = &h0002 ' Target = command line args
Const msidbCustomActionTypeTextData       = &h0003 ' Target = text string to be formatted and set into property
Const msidbCustomActionTypeJScript        = &h0005 ' Target = entry point name, null if none to call
Const msidbCustomActionTypeVBScript       = &h0006 ' Target = entry point name, null if none to call
Const msidbCustomActionTypeInstall        = &h0007 ' Target = property list for nested engine initialization
Const msidbCustomActionTypeBinaryData     = &h0000 ' Source = Binary.Name, data stored in stream
Const msidbCustomActionTypeSourceFile     = &h0010 ' Source = File.File, file part of installation
Const msidbCustomActionTypeDirectory      = &h0020 ' Source = Directory.Directory, folder containing existing file
Const msidbCustomActionTypeProperty       = &h0030 ' Source = Property.Property, full path to executable
Const msidbCustomActionTypeContinue       = &h0040 ' ignore action return status, continue running
Const msidbCustomActionTypeAsync          = &h0080 ' run asynchronously
Const msidbCustomActionTypeFirstSequence  = &h0100 ' skip if UI sequence already run
Const msidbCustomActionTypeOncePerProcess = &h0200 ' skip if UI sequence already run in same process
Const msidbCustomActionTypeClientRepeat   = &h0300 ' run on client only if UI already run on client
Const msidbCustomActionTypeInScript       = &h0400 ' queue for execution within script
Const msidbCustomActionTypeRollback       = &h0100 ' in conjunction with InScript: queue in Rollback script
Const msidbCustomActionTypeCommit         = &h0200 ' in conjunction with InScript: run Commit ops from script on success
Const msidbCustomActionTypeNoImpersonate  = &h0800 ' no impersonation, run in system context
Const msidbCustomActionTypeTSAware        = &h4000 ' Run with user impersonation during per-machine installs on Terminal Server machines

' Dialog.Attributes
Const msidbDialogAttributesVisible          = &h00000001
Const msidbDialogAttributesModal            = &h00000002
Const msidbDialogAttributesMinimize         = &h00000004
Const msidbDialogAttributesSysModal         = &h00000008
Const msidbDialogAttributesKeepModeless     = &h00000010
Const msidbDialogAttributesTrackDiskSpace   = &h00000020
Const msidbDialogAttributesUseCustomPalette = &h00000040
Const msidbDialogAttributesRTLRO            = &h00000080
Const msidbDialogAttributesRightAligned     = &h00000100
Const msidbDialogAttributesLeftScroll       = &h00000200
Const msidbDialogAttributesError            = &h00010000

' Control.Attributes - common
Const msidbControlAttributesVisible         = &h00000001
Const msidbControlAttributesEnabled         = &h00000002
Const msidbControlAttributesSunken          = &h00000004
Const msidbControlAttributesIndirect        = &h00000008
Const msidbControlAttributesInteger         = &h00000010
Const msidbControlAttributesRTLRO           = &h00000020
Const msidbControlAttributesRightAligned    = &h00000040
Const msidbControlAttributesLeftScroll      = &h00000080

' Control.Attributes - Text controls
Const msidbControlAttributesTransparent     = &h00010000
Const msidbControlAttributesNoPrefix        = &h00020000
Const msidbControlAttributesNoWrap          = &h00040000
Const msidbControlAttributesFormatSize      = &h00080000
Const msidbControlAttributesUsersLanguage   = &h00100000

' Control.Attributes - Edit controls
Const msidbControlAttributesMultiline       = &h00010000
Const msidbControlAttributesPasswordInput   = &h00200000

' Control.Attributes - ProgressBar
Const msidbControlAttributesProgress95      = &h00010000

' Control.Attributes - VolumeSelectCombo and DirectoryCombo
Const msidbControlAttributesRemovableVolume = &h00010000
Const msidbControlAttributesFixedVolume     = &h00020000
Const msidbControlAttributesRemoteVolume    = &h00040000
Const msidbControlAttributesCDROMVolume     = &h00080000
Const msidbControlAttributesRAMDiskVolume   = &h00100000
Const msidbControlAttributesFloppyVolume    = &h00200000

' Control.Attributes - VolumeCostList control
Const msidbControlShowRollbackCost          = &h00400000

' Control.Attributes - ListBox and ComboBox controls
Const msidbControlAttributesSorted          = &h00010000
Const msidbControlAttributesComboList       = &h00020000

' Control.Attributes - RadioButton controls
Const msidbControlAttributesHasBorder       = &h01000000

' Control.Attributes - picture button controls
Const msidbControlAttributesImageHandle     = &h00010000
Const msidbControlAttributesPushLike        = &h00020000
Const msidbControlAttributesBitmap          = &h00040000
Const msidbControlAttributesIcon            = &h00080000
Const msidbControlAttributesFixedSize       = &h00100000
Const msidbControlAttributesIconSize16      = &h00200000
Const msidbControlAttributesIconSize32      = &h00400000
Const msidbControlAttributesIconSize48      = &h00600000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\wixload.inc ===
'<script language='VBScript'>
' wixload.inc - preprocessor for Windows Installer XML
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    wixerror.inc
'    xmlconsts.inc
'
' entrypoints:
'    WixLoad
'    WixApplyStyleSheet
'    WixPreProcess
'

Public wixload_dictPreProcessVars       ' As Scripting.Dictionary
Public wixload_sPreProcessIncludePaths  ' As String

Public wixload_fso                      ' As Scripting.FileSystemObject
Public wixload_sLoadDir                 ' As String

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' WixLoad
Function WixLoad(ByVal sPath, ByVal sIncludePaths, ByRef dictVars, ByVal bProcess)
   Dim xmlDoc :  Set xmlDoc = WScript.CreateObject("Microsoft.XMLDOM")
'WScript.Echo "Including: " & sPath
   ' set the global variables
   If Not IsEmpty(sIncludePaths) Then wixload_sPreProcessIncludePaths = sIncludePaths
   If Not IsEmpty(dictVars) Then Set wixload_dictPreProcessVars = dictVars
   If IsEmpty(wixload_dictPreProcessVars) Then Set wixload_dictPreProcessVars = WScript.CreateObject("Scripting.Dictionary")

   If IsEmpty(wixload_fso) Then Set wixload_fso = WScript.CreateObject("Scripting.FileSystemObject")
   If IsEmpty(wixload_sLoadDir) Then
      wixload_sLoadDir = wixload_fso.GetParentFolderName(wixload_fso.GetAbsolutePathName(sPath))
	  Dim nFind : nFind = InStrRev(sPath, "\")
      If 0 < nFind Then sPath = Mid(sPath, nFind + 1)
   End If
   
   ' try to load the document
   xmlDoc.preserveWhiteSpace = False
   xmlDoc.async = False
'   xmlDoc.validateOnParse = False
'   xmlDoc.resolveExternals = False

'WScript.Echo "Xml validate: " & xmlDoc.validateOnParse
'WScript.Echo "Xml resolve: " & xmlDoc.resolveExternals

'   Dim e : Set e = xmlDoc.createEntityReference("foo")
'   Dim n : Set n = xmlDoc.createElement("wazz")
'   n.nodeValue = "up"
'   e.nodeValue = "bar"
'   n.appendChild e
'WScript.Echo "xml: " & e.xml

   Dim bLoaded :  bLoaded = xmlDoc.load(wixload_sLoadDir & "\" & sPath)
   If Not bLoaded Then
      Dim pe :  Set pe = xmlDoc.parseError
      Dim sErr : sErr = "Failed to load XML file: " & pe.url & vbCrLf & "   " & pe.errorCode & " - " & pe.reason & vbCrLf & "   Line:" & pe.line & ", Character: " & pe.linepos
      Fail sErr
   End If

   ' if there is no root return with nothing
   Dim root : Set root = xmlDoc.firstChild
   If root Is Nothing Then 
      Set WixLoad = Nothing
      Exit Function
   End If

   If bProcess Then WixPreProcess root, Empty, Empty

   ' return the preprocessed    
   Set WixLoad = xmlDoc
End Function   ' WixLoad


''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' WixApplyStyleSheet
Function WixApplyStyleSheet(ByRef xmlDoc, ByVal sPath)
   Dim xmlStyle :  Set xmlStyle = WixLoad(sPath, Empty, Empty, False)

   ' if there is no root return with nothing changed
   Dim root : Set root = xmlStyle.firstChild
   If root Is Nothing Then 
      Set WixApplyStyleSheet = xmlDoc
      Exit Function
   End If

   Dim s :  sApplied = xmlDoc.transformNode(xmlStyle)
   xmlDoc.loadXml sApplied
   If xmlDoc.parseError.errorCode <> 0 Then
      Dim pe :  Set pe = xmlDoc.parseError
      Dim sErr : sErr = "Failed to properly apply stylesheet: " & sPath & " to XML file: " & pe.url & vbCrLf & "   " & pe.errorCode & " - " & pe.reason & vbCrLf & "   Line:" & pe.line & ", Character: " & pe.linepos
      Fail sErr
   End If

   Set WixApplyStyleSheet = xmlDoc
End Function   ' WixApplyStyleSheet


''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' WixPreProcess
Function WixPreProcess(ByRef root, ByVal sIncludePaths, ByRef dictVars)
   Dim child, nStartEntity, nEndEntity
'WScript.Echo "WixPreProcess"
   ' set the global variables
   If Not IsEmpty(sIncludePaths) Then wixload_sPreProcessIncludePaths = sIncludePaths
   If Not IsEmpty(dictVars) Then Set wixload_dictPreProcessVars = dictVars
   If IsEmpty(wixload_dictPreProcessVars) Then Set wixload_dictPreProcessVars = WScript.CreateObject("Scripting.Dictionary")

   ' if there is no root return with nothing   
'   Set root = xmlDoc.firstChild
   If root Is Nothing Then
      Set WixPreProcess = Nothing
      Exit Function
   End If
'WScript.Echo "Foo"
   ' loop through all of the nodes in the document
   ' !!! - should root just get children who are processing instructions?
   For Each child In root.childNodes
'WScript.Echo "child: " & child.nodeName
      ' look only at processing instructions
      If NODE_PROCESSING_INSTRUCTION = child.nodeType Then
         Select Case(child.target)
         Case "include" : wixload_WixProcessInclude child, child.parentNode : child.parentNode.removeChild child
         Case "if"      : wixload_WixProcessIf      child, child.parentNode
         Case "define"
            Dim var, name, value
            var = Split(child.data, "=")
            name = wixload_WixFixVarName(var(0))
            If UBound(var) > 0 Then value = var(1) Else value = True
            wixload_dictPreProcessVars.Add name, value
         Case "else"
         Case "endif"
         Case Else      : Fail "Unexpected processor instruction: " & child.target
         End Select
      ElseIf NODE_CDATA_SECTION <> child.nodeType Then	' don't do entity replacments in CDATA Sections
	     nStartEntity = InStr(child.nodeValue, "&")
         If 0 < nStartEntity Then
            nEndEntity = InStr(child.nodeValue, ";")
            If nEndEntity < nStartEntity Then
               Fail "Failed entity lookup for: " & child.nodeValue
            Else
               sVar = Mid(child.nodeValue, nStartEntity + 1, nEndEntity - nStartEntity - 1)
               If Not wixload_dictPreProcessVars.Exists(sVar) Then
                  Fail "Unknown entity reference: " & sVar
               Else
                  child.nodeValue = Left(child.nodeValue, 0, nStartEntity - 1) & wixload_dictPreProcessVars.Item(sVar) & Mid(child.nodeValue, nEndEntity + 1)
               End If
            End If
         End If
      End If
      If child.HasChildNodes Then
'WScript.Echo "Going down"
         WixPreProcess child, Empty, Empty
      End If
   Next

   Set WixPreProcess = root
End Function

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixProcessIf
Function wixload_WixProcessIf(node, nodeParent)
   Dim sEval : sEval = node.data
   Dim fInclude
   Dim fKeep : fKeep = wixload_WixEvaluate(sEval)

   Dim remove  ' node to remove possibly
   Dim sibling : Set sibling = node.nextSibling
   Do Until sibling Is Nothing
      fInclude = False  ' make sure the include flag is always started off

      If NODE_PROCESSING_INSTRUCTION = sibling.nodeType Then
         Select Case sibling.target
         Case "endif"   : Exit Do
         Case "else"    : fKeep = Not fKeep
         Case "include" : fInclude = True
         Case Else      : Fail "Unexepected processor instruction: " & sibling.target
         End Select
      End If

      ' move the sibling along
      Set remove = sibling
      Set sibling = sibling.nextSibling

      ' if we're not keeping nodes toast this one
      If Not fKeep Then 
         nodeParent.removeChild remove
      ElseIf fInclude Then ' if we're keeping nodes and this is an include node
         wixload_WixProcessInclude remove, remove.parentNode
         nodeParent.removeChild remove ' always remove the <?include ?> node
      End If
   Loop
End Function   ' wixload_WixProcessIf

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixProcessInclude
Function wixload_WixProcessInclude(node, nodeParent)
   Dim sOldDir, sLoad, sProcess
'WScript.Echo "Processing include, load: " & sLoad

   sLoad = node.data
   If InStr(sLoad , "\") Or InStr(sLoad, "/") Then
      sProcess = wixload_fso.GetAbsolutePathName(sLoad)
      If wixload_sLoadDir <> wixload_fso.GetParentFolderName(sProcess) Then
         sOldDir = wixload_sLoadDir
         wixload_sLoadDir = wixload_fso.GetParentFolderName(sProcess)
'WScript.Echo "Changing load dir from: " & sOldDir & " to: " & wixload_sLoadDir
         sLoad = wixload_fso.GetFileName(sLoad)
      End If
   End If

   Dim xmlInclude : Set xmlInclude = WixLoad(sLoad, Empty, Empty, True)
   If xmlInclude Is Nothing Then Fail "Failed to include: " & sLoad

   ' reset the wixload directory
   If 0 < Len(sOldDir) Then wixload_sLoadDir = sOldDir

   ' load the fragment and make sure it hooked up correctly
   Dim sParent, nodeFragment : Set nodeFragment = xmlInclude.firstChild
   If "Fragment" <> nodeFragment.nodeName Then Fail "Can only <?include ?> <Fragments />."
   If Not nodeFragment.selectSingleNode("text()") Is Nothing Then
      sParent = nodeFragment.firstChild.nodeValue  ' get the type of <Fragment>
   End If
   If Len(sParent) > 0 And nodeParent.nodeName <> sParent Then Fail "Fragment type: " & sParent & " does not match parent type: " & nodeParent.nodeName

   Dim child
   For Each child In nodeFragment.childNodes
'      If NODE_ELEMENT = child.nodeType Then nodeParent.insertBefore child, node
      nodeParent.insertBefore child, node
   Next
   
   Set wixload_WixProcessInclude = node
End Function   ' wixload_WixProcessInclude


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' helper functions

''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixFixVarName
Function wixload_WixFixVarName(ByVal s)
   If "[" = Left(s, 1) Then s = Mid(s, 2)
   If "]" = Right(s, 1) Then s = Mid(s, 1, Len(s) - 1)
   If Instr(1, s, "]") Or Instr(1, s, "[") Then Fail "Invalid variable name: " & s
   wixload_WixFixVarName = s
End Function   ' wixload_WixFixVarName


''''''''''''''''''''''''''''''''''''''''''''''''''''''''' robmen ''
' wixload_WixEvaluate
Function wixload_WixEvaluate(sExpression)
   sExpression = Replace(sExpression, "[", " wixload_dictPreProcessVars.Item(""")
   sExpression = Replace(sExpression, "]", """) ")
   wixload_WixEvaluate = CBool(Eval(sExpression))
End Function   ' wixload_WixEvaluate
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\cmf.h ===
/*****************************************************************************
    
  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.

  Module Name:

   cmf.h

  Abstract:

    The declaration of class CCompactMUIFile, CMUIFile

  Revision History:

    2001-11-01    sunggch    created.

Revision.

*******************************************************************************/
 // set CMF file name/ MUI file name size under 32.
 
#define   MAX_FILENAME_LENGTH     128

class CMUIFile 
{
    struct COMPACT_MUI {
        USHORT      wHeaderSize; // COMPACT_MUI size // [WORD]
        ULONG       dwFileVersionMS; // [DWORD * 2 ] /major version, minor version.
        ULONG       dwFileVersionLS; 
        BYTE        Checksum[16]; // [DWORD * 4 ] MD5 checksum
        USHORT      wReserved; //  [DWORD ]
        ULONG_PTR   ulpOffset;  //Offset to mui resource of this from COMPACT_MUI_RESOURCE signature. [DWORD]
        ULONG       dwFileSize;
//      DWORD       dwIndex;    // index from the CMF files
        USHORT        wFileNameLenWPad;  // file name lenght + padding;
        WCHAR       wstrFieName[MAX_FILENAME_LENGTH]; // [WCHAR]
//      WORD        wPadding[1]; // [WORD]  // does not calcualte in the tools, but shall be 
                                // included specfication.
    };   // 40 bytes.

    struct UP_COMPACT_MUI {
        USHORT      wHeaderSize; // COMPACT_MUI size // [WORD]
        ULONG       dwFileVersionMS; // [DWORD * 2 ] /major version, minor version.
        ULONG       dwFileVersionLS; 
        BYTE        Checksum[16]; // [DWORD * 4 ] MD5 checksum
        USHORT      wReserved; //  [DWORD ]
        ULONG_PTR   ulpOffset;  //Offset to mui resource of this from COMPACT_MUI_RESOURCE signature. [DWORD]
        ULONG       dwFileSize;
//      DWORD       dwIndex;    // index from the CMF files
        USHORT        wFileNameLenWPad;  // file name lenght + padding;
//      WCHAR       wstrFieName[MAX_FILENAME_LENGTH]; // [WCHAR]
//      WORD        wPadding[1]; // [WORD]  // does not calcualte in the tools, but shall be 
                                // included specfication.
    };   // 40 bytes.



public:

    CMUIFile();
    CMUIFile(CMUIFile & cmf);
    virtual ~CMUIFile();
    CMUIFile &operator=(CMUIFile &cmf);


    BOOL Create (PSTR pszMuiFileName); // load file and fill the structure block. 
    BOOL WriteMUIFile(CMUIFile *pcmui);
    LPCTSTR GetFileNameFromPath(LPCTSTR pszFilePath);

private:
    
    BOOL getChecksumAndVersion (LPCTSTR pszMUIFile, unsigned char **ppMD5Checksum, DWORD *dwFileVersionMS, DWORD *dwFileVersionLS);
    

public:
    COMPACT_MUI m_MUIHeader;
    PBYTE    m_pbImageBase; // real mui file image
    DWORD    m_dwIndex;  // index of MUI files inside CMF files. this will be saved to language-neutral binary files
    PSTR     m_strFileName;
                    
//  LPWSTR   m_wstrMuiFileName; 
    
//  WORD     m_wImageSize;;


};


//typedef CVector <CMUIFile *> cvcmui;

class CCompactMUIFile 
{

public:

    CCompactMUIFile();

    CCompactMUIFile( CCompactMUIFile & ccmf);

    virtual ~CCompactMUIFile();

    CCompactMUIFile& operator= (CCompactMUIFile & ccmf);

    BOOL Create (LPCTSTR pszCMFFileName, PSTR *ppszMuiFiles, DWORD dwNumOfMUIFiles); 

    BOOL Create(LPCTSTR pszCMFFileName );  

    BOOL OpenCMFWithMUI(LPCTSTR  pstCMFFile);

    BOOL LoadAllMui (PSTR *ppszMuiFiles, DWORD dwNumberofMuiFile);

    BOOL UpdateMuiFile( PSTR pszCMFFile, PSTR pszMuiFile);

    //create CMUIFile and replace this data with same name inside  //CMF file and fill new CMF file structure.

    BOOL DisplayHeaders( PSTR pszCMFFile, WORD wLevel = NULL);
      // display CMF or CMF & included MUIs headers.
    BOOL AddFile (PSTR pszCMFFile, PSTR *pszAddedMuiFile, DWORD dwNumOfMUIFiles);

    BOOL SubtractFile ( PSTR pszSubtractedMuiFile , PSTR pszCMFFile = NULL );//elete  from the list,and create file for that.

    BOOL UnCompactCMF (PSTR pszCMFFile);
// add new CMUI file into existing CMF file
    void SubtractFile(CMUIFile* pcmui);

    BOOL GetChecksum(PSTR pszMUIFile, BYTE **ppMD5Checksum);

    BOOL GetFileVersion(PSTR pszMUIFile, DWORD *FileVersionLS, DWORD *FileVersionMS); 

    BOOL UpdateCodeFiles(PSTR pszCodeFilePath, DWORD dwNumbOfFiles );

    BOOL WriteCMFFile();

private:
    
    BOOL updateCodeFile(PSTR pszCodeFile, DWORD dwIndex);



private:

    struct COMPACT_MUI_RESOURCE {

        ULONG  dwSignature;      // L"CM\0\0"
        ULONG  dwHeaderSize;      // COMPACT_MUI_RESOURCE header size //  [WORD]
        ULONG  dwNumberofMui;     // Optional // [WORD]
        ULONG  dwFileSize;
//      COMPACT_MUI aMui[MAX_FILENAME_LENGTH];

    };

    struct UP_COMPACT_MUI_RESOURCE {
        ULONG  dwSignature;      // L"CM\0\0"
        ULONG  dwHeaderSize;      // COMPACT_MUI_RESOURCE header size //  [WORD]
        ULONG  dwNumberofMui;     // Optional // [WORD]
        ULONG  dwFileSize;
    };
    
    HANDLE    m_hCMFFile;   // optional 
    PSTR      m_strFileName;
    PVOID     m_pImageBase; // REVIST; this exist or m_hCMFFile exist. both of them NO!
    CMUIFile *m_pcmui;
    DWORD     m_dwFileSize;
    UP_COMPACT_MUI_RESOURCE  m_upCMFHeader;

    CVector <CMUIFile *> m_pcvector;
    
};


class CError 
{

public:
    void ErrorPrint(PSTR pszErrorModule, PSTR pszErrorLocation, PSTR pszFileName = NULL);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muibld\muibld.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <io.h>
#include <md5.h>

#include <strsafe.h> // safe string

#include "muibld.h"



typedef struct 
{
    BOOL bContainResource;
    MD5_CTX ChecksumContext;
    pCommandLineInfo pInfo;
} CHECKSUM_ENUM_DATA;

void ExitFromOutOfMemory();
void ExitFromSafeStringError();

void DumpResourceDirectory
(
    PIMAGE_RESOURCE_DIRECTORY resDir,
    DWORD resourceBase,
    DWORD level,
    DWORD resourceType
);

int g_bVerbose = FALSE;     // Global flag to contorl verbose output.
WORD wChecksumLangId; 

// The predefined resource types
char *SzResourceTypes[] = {
"???_0", "CURSOR", "BITMAP", "ICON", "MENU", "DIALOG", "STRING", "FONTDIR",
"FONT", "ACCELERATORS", "RCDATA", "MESSAGETABLE", "GROUP_CURSOR",
"???_13", "GROUP_ICON", "???_15", "VERSION"
};

void PrintError()
{
    LPTSTR lpMsgBuf;
    
    if (FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    ))
    {
        printf("GetLastError():\n   %s", lpMsgBuf);
        LocalFree( lpMsgBuf );            
    }
    return;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumNamesFunc
//
//  The callback funciton for enumerating the resource names in the specified module and
//  type.
//  The side effect is that MD5 checksum context (contained in CHECKSUM_ENUM_DATA
//  pointed by lParam) will be updated.
//
//  Return:
//      Always return TRUE so that we can finish all resource enumeration.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam){

    HRSRC hRsrc;
    HGLOBAL hRes;
    const unsigned char* pv;
    LONG ResSize=0L;
    WORD IdFlag=0xFFFF;

    DWORD dwHeaderSize=0L;
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;   


    if(!(hRsrc=FindResourceEx(hModule, lpType, lpName, wChecksumLangId ? wChecksumLangId : 0x409)))
    {
        //
        // If US English resource is not found for the specified type and name, we 
        // will continue the resource enumeration.
        //
        return (TRUE);
    }
    pChecksumEnumData->bContainResource = TRUE;

    if (!(ResSize=SizeofResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not get resource size when generating resource checksum.\n");
        return (TRUE);
    }

    if (!(hRes=LoadResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not load resource when generating resource checksum.\n");
        return (TRUE);
    }
    pv=(unsigned char*)LockResource(hRes);

    //
    // Update MD5 context using the binary data of this particular resource.
    //
    MD5Update(&(pChecksumEnumData->ChecksumContext), pv, ResSize);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumTypesFunc
//
//  The callback function for enumerating the resource types in the specified module.
//  This function will call EnumResourceNames() to enumerate all resource names of
//  the specified resource type.
//
//  Return:
//      TRUE if EnumResourceName() succeeds.  Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumTypesFunc(HMODULE hModule, LPSTR lpType, LONG_PTR lParam)
{
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;

    //
    // Skip the version resource type, so that version is not included in the resource checksum.
    //
    if (lpType == RT_VERSION)
    {
        return (TRUE);
    }    
    
    //
    // If muibld include -i arg. but the lpType is not in the -i arg. values, it does not
    // use lpType for checksum calculation.
    // 
    if(pChecksumEnumData->pInfo->bIncludeFlag && 
        !bTypeIncluded((char *)lpType, pChecksumEnumData->pInfo->pszIncResType)) {
        
        return TRUE;

    }

    if(!EnumResourceNames(hModule, (LPCSTR)lpType, ChecksumEnumNamesFunc, (LONG_PTR)lParam))
    {
        return (FALSE);
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GenerateResourceChecksum
//
//  Generate the resource checksum for the US English resource in the specified file.
//
//  Parameters:
//      pszSourceFileName   The file used to generate resource checksum.
//      pResourceChecksum   Pointer to a 16 bytes (128 bits) buffer for storing
//                          the calcuated MD5 checksum.
//      pInfo               pCommandLineInfo structure.the routine refer to 
//                          pszChecksumFile, pResourceChecksum, pszIncResType.
//  Return:
//      TURE if resource checksum is generated from the given file.  Otherwise FALSE.
//  
//  The following situation may return FALSE:
//      * The specified file does not contain resource.
//      * If the specified file contains resource, but the resource is not US English.
//      * The specified file only contains US English version resource.
//
//  Note. 
//      muibld calculate the checksum only based of included resource types by -i arg.
// 
////////////////////////////////////////////////////////////////////////////////////

BOOL GenerateResourceChecksum(pCommandLineInfo pInfo) // LPCSTR pszSourceFileName, unsigned char* pResourceChecksum)
{
    ULONG i;
    HMODULE hModule = NULL;

    DWORD dwResultLen;
    BOOL  bRet = FALSE;

    //
    // The stucture to be passed into the resource enumeration functions.
    //
    CHECKSUM_ENUM_DATA checksumEnumData;

    checksumEnumData.bContainResource = FALSE;
    checksumEnumData.pInfo = pInfo;

    //
    // Start MD5 checksum calculation by initializing MD5 context.
    //
    MD5Init(&(checksumEnumData.ChecksumContext));
   // Info.pszChecksumFile, Info.pResourceChecksum 
    if (g_bVerbose)
    {
        printf("Generate resource checksum for [%s]\n", pInfo->pszChecksumFile);
    }
    
    if(!(hModule = LoadLibraryEx(pInfo->pszChecksumFile, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE)))
    {
        if (g_bVerbose)
        {
            printf("\nERROR: Error in opening resource checksum module [%s]\n", pInfo->pszChecksumFile);
        }
        PrintError();
        goto GR_EXIT;
    }

    if (g_bVerbose)
    {
        printf("\nLoad checksum file: %s\n", pInfo->pszChecksumFile);
    }

    //
    // we check language id of Version resource if it has wChecksumLangId when wChecksumLangId has value
    //
    
    if (wChecksumLangId && wChecksumLangId != 0x409)
    {
        if(!FindResourceEx(hModule, MAKEINTRESOURCE(16), MAKEINTRESOURCE(1), wChecksumLangId))
        {   //
            // It does not has specifed language id in version resource, we supposed that this binary does not
            // have any language id specified at all, so we set it as 0 in order to use English instead.
            //
            wChecksumLangId = 0;
        }
    }

    //
    //  Enumerate all resources in the specified module.
    //  During the enumeration, the MD5 context will be updated.
    //
    if (!EnumResourceTypes(hModule, ChecksumEnumTypesFunc, (LONG_PTR)&checksumEnumData))
    {
        if (g_bVerbose)
        {
            printf("\nWARNING: Unable to generate resource checksum from resource checksum module [%s]\n", pInfo->pszChecksumFile);
        }
        goto GR_EXIT;
    }    

    if (checksumEnumData.bContainResource)
    {
        //
        // If the enumeration succeeds, and the specified file contains US English
        // resource, get the MD5 checksum from the accumulated MD5 context.
        //
        MD5Final(&checksumEnumData.ChecksumContext);
        memcpy(checksumEnumData.pInfo->pResourceChecksum, checksumEnumData.ChecksumContext.digest, 16);

        if (g_bVerbose)
        {
            printf("Generated checksum: [");
            for (i = 0; i < MD5_CHECKSUM_SIZE; i++)
            {
                printf("%02x ", pInfo->pResourceChecksum[i]);
            }
            printf("]\n");    
        }
        bRet = TRUE;
    }

GR_EXIT:
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return (bRet);
}

int __cdecl main(int argc, char *argv[]){

    struct CommandLineInfo Info;
    HMODULE hModule=0;
    char pszBuffer[400];
    DWORD dwError;
    DWORD dwOffset;
    BOOL bEnumTypesReturn;    

    if(argc==1){
        Usage();
        return 0;
    }

    g_bVerbose=FALSE;
    wChecksumLangId=0;
    
    Info.pszIncResType=0;
    Info.wLanguage=0;
    Info.hFile=0;
    Info.pszSource=0;
    Info.pszTarget=0;
    Info.bContainsOnlyVersion=TRUE;
    Info.bContainsResources=FALSE;
    Info.bLanguageFound=FALSE;
    Info.bIncDependent=FALSE;
    Info.bIncludeFlag=FALSE;    

    Info.pszChecksumFile=NULL;
    Info.bIsResChecksumGenerated = FALSE;

    if(ParseCommandLine(argc, argv, &Info)==FALSE){

        //...If help was the only command line argument, exit
        if(strcmp(argv[1], "-h")==0 && argc==2)
            return 0;

        dwError=ERROR_TOO_FEW_ARGUMENTS;
        dwOffset=0;
        goto Error_Exit;
    }

    //...Open resource module
    if(Info.pszSource){
        if(!(hModule = LoadLibraryEx (Info.pszSource, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE)))
        {
            PrintError();
            if (g_bVerbose)
            {
                printf("\nERROR: Error in opening source module [%s]\n", Info.pszSource);
            }            
            dwError=GetLastError();
            dwOffset=ERROR_OFFSET;
            goto Error_Exit;
        }
    }
    else {
        Usage();
        dwError=ERROR_NO_SOURCE;
        dwOffset=0;
        goto Error_Exit;
    }

    if (Info.pszChecksumFile)
    {
        if (GenerateResourceChecksum(&Info)) // c))
        {
            Info.bIsResChecksumGenerated = TRUE;
        }        
    }
    
    //...Create target file
    if(Info.pszTarget){
        if((Info.hFile=CreateFile(Info.pszTarget, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
        {
            if (g_bVerbose)
            {
                printf("\nERROR: Error in creating target module [%s]\n", Info.pszSource);
            }
            dwError=GetLastError();
            dwOffset=ERROR_OFFSET;
            goto Error_Exit;
        }
    }
    else{
        if (g_bVerbose)
        {
            printf("\nERROR: There is no target file name.");
        }
        Usage();
        dwError=ERROR_NO_TARGET;
        dwOffset=0;
        goto Error_Exit;
    }

    if(Info.wLanguage==0){
        if (g_bVerbose)
        {
            printf("\nERROR: Can not find specified language name in the source module.");
        }
        Usage();
        dwError=ERROR_NO_LANGUAGE_SPECIFIED;
        dwOffset=0;
        goto Error_Exit;
    }

    bInsertHeader(Info.hFile);

    bEnumTypesReturn=EnumResourceTypes(hModule, EnumTypesFunc, (LONG_PTR)&Info);

    //...Check for muibld errors
    if(!Info.bContainsResources){
        if (g_bVerbose)
        {
            printf("\nERROR: There is no resource in the source module.");
        }
        dwError=ERROR_NO_RESOURCES;
        dwOffset=0;
        goto Error_Exit;
    }

    if(!Info.bLanguageFound){
        if (g_bVerbose)
        {
            printf("\nERROR: Resource in the specified language is not found in the source module.");
        }
        dwError=ERROR_LANGUAGE_NOT_IN_SOURCE;
        dwOffset=0;
        goto Error_Exit;
    }

    if(Info.bContainsOnlyVersion){
        if (g_bVerbose)
        {
            printf("\nERROR: The source module only contains version information.");
        }
        dwError=ERROR_ONLY_VERSION_STAMP;
        dwOffset=0;
        goto Error_Exit;
    }

    //...Check for system errors in EnumResourceTypes
    if(bEnumTypesReturn);
    else{
        
        dwError=GetLastError();
        dwOffset=ERROR_OFFSET;
        goto Error_Exit;
    }

    //...Check to see if extra resources were included
    if(Info.bIncDependent){
        CleanUp(&Info, hModule, FALSE);
        return DEPENDENT_RESOURCE_REMOVED;
    }
    CleanUp(&Info, hModule, FALSE);

    if (g_bVerbose)
    {
        printf("Resource file [%s] has been generated successfully.\n", Info.pszTarget);
    }
    return 0;

    Error_Exit:
        CleanUp(&Info, hModule, TRUE);
        if(dwOffset==ERROR_OFFSET){
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, (LPTSTR)pszBuffer, 399, NULL);
            fprintf(stderr, "\n%s\n", pszBuffer );
        }

        return dwError+dwOffset;
}



BOOL ParseCommandLine(int argc, char **argv, pCommandLineInfo pInfo){
    int iCount=1, chOpt=0, iLast=argc;
    int i;
    int iNumInc;
    BOOL bInc1=FALSE, bInc3=FALSE, bInc12=FALSE, bInc14=FALSE;

    HRESULT hr;
    HANDLE hFile;
    iLast=argc;
    

    //...Must have at least: muibld -l langid source
    if(argc>3){

        //...Determine the target and source files.
        hFile = CreateFile(argv[argc-2], 0, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        
        if(hFile !=INVALID_HANDLE_VALUE){
            
            CloseHandle(hFile);

            pInfo->pszSource=LocalAlloc(0, (strlen(argv[argc-2])+1) * sizeof(char));
            if (pInfo->pszSource == NULL)
            {
                ExitFromOutOfMemory();
            }
            // strcpy(pInfo->pszSource, argv[argc-2]);
            hr = StringCchCopyA(pInfo->pszSource, (strlen(argv[argc-2])+1) * sizeof(char),argv[argc-2]);
            
            if ( ! SUCCEEDED(hr)){
                ExitFromSafeStringError();
            }   
        
            pInfo->pszTarget=LocalAlloc(0, (strlen(argv[argc-1])+1) * sizeof(char));
            if (pInfo->pszTarget == NULL)
            {
                ExitFromOutOfMemory();
            }
            // strcpy(pInfo->pszTarget, argv[argc-1]);
            hr = StringCchCopyA(pInfo->pszTarget, (strlen(argv[argc-1])+1) * sizeof(char), argv[argc-1]);
            
            if ( ! SUCCEEDED(hr)){
                ExitFromSafeStringError();
            }   
            iLast=argc-2;
        }

        else {
            pInfo->pszSource=LocalAlloc(0, (strlen(argv[argc-1])+1) * sizeof(char));
            if (pInfo->pszSource == NULL)
            {
                ExitFromOutOfMemory();
            }
            //strcpy(pInfo->pszSource, argv[argc-1]);
            hr = StringCchCopyA(pInfo->pszSource, (strlen(argv[argc-1])+1) * sizeof(char), argv[argc-1]);
            
            if ( ! SUCCEEDED(hr)){
                ExitFromSafeStringError();
            }   

            pInfo->pszTarget=LocalAlloc(0, (strlen(argv[argc-1]) + strlen(ADDED_EXT) + 1) * sizeof(char));
            if (pInfo->pszTarget == NULL)
            {
                ExitFromOutOfMemory();
            }
            //strcpy(pInfo->pszTarget, strcat(argv[argc-1], ADDED_EXT));

            hr = StringCchCatA(argv[argc-1], strlen(argv[argc-1]) + sizeof ADDED_EXT + 1, ADDED_EXT);

            hr = StringCchCopyA(pInfo->pszTarget, (strlen(argv[argc-1]) + strlen(ADDED_EXT) + 1) * sizeof(char), 
                argv[argc-1]);
            
            if ( ! SUCCEEDED(hr)){
                ExitFromSafeStringError();
            }   
            iLast=argc-1;
        }
    }




    //...Read in flags and arguments
    while ( (iCount < iLast)  && (*argv[iCount] == '-' || *argv[iCount] == '/')){

        switch( ( chOpt = *CharLowerA( &argv[iCount][1]))) {

            case '?':
            case 'h':

                printf("\n\n");
                printf("MUIBLD [-h|?] [-v] [-c checksum_file] -l langid [-i resource_type] source_filename\n");
                printf("    [target_filename]\n\n");
                printf("-h(elp) or -?:      Show help screen.\n\n");

                printf("-i(nclude)      Use to include certain resource types,\n");
                printf("resource_type:      e.g. -i 2 to include bitmaps.\n");
                printf("            Multiple inclusion is possible. If this\n");
                printf("            flag is not used, all types are included\n");
                printf("            Standard resource types must be specified\n");
                printf("            by number. See below for list.\n");
                printf("            Types 1 and 12 are always included in pairs,\n");
                printf("            even if only one is specified. Types 3 and 14\n");
                printf("            are always included in pairs, too.\n\n");

                printf("-v(erbose):     Display source filename and target filename.\n\n");

                printf("-l(anguage) langid: Extract only resource in this language.\n");
                printf("            The language resource must be specified. The value is in decimal.\n\n");

                printf("source_filename:    The localized source file (no wildcard support)\n\n");

                printf("target_filename:    Optional. If no target_filename is specified,\n");
                printf("            a second extension.RES is added to the\n");
                printf("            source_filename.\n\n");

                printf("Standard Resource Types: CURSOR(1) BITMAP(2) ICON(3) MENU(4) DIALOG(5)\n");
                printf("STRING(6) FONTDIR(7) FONT(8) ACCELERATORS(9) RCDATA(10) MESSAGETABLE(11)\n");
                printf("GROUP_CURSOR(12) GROUP_ICON(14) VERSION(16)\n");



                iCount++;
                break;

            case 'v':
                g_bVerbose=TRUE;
                iCount++;
                break;

            case 'c':
                iCount++;
                pInfo->pszChecksumFile=LocalAlloc(0, (strlen(argv[iCount])+1) * sizeof(char));
                if (pInfo->pszChecksumFile == NULL)
                {
                    ExitFromOutOfMemory();
                }
                //strcpy(pInfo->pszChecksumFile, argv[iCount]);
                hr = StringCchCopyA(pInfo->pszChecksumFile, (strlen(argv[iCount])+1) * sizeof(char), 
                    argv[iCount]); 
                
                if ( ! SUCCEEDED(hr)){
                    ExitFromSafeStringError();
                }   

                iCount++;                                 
                break;

            case 'b':

               iCount++;
               wChecksumLangId = (WORD)strtoul(argv[iCount], NULL, 0);
               iCount++;
               break;

            case 'i':

                if(argc<4)
                    return FALSE;

                pInfo->bIncludeFlag=TRUE;
                iNumInc=++iCount;

                //...Allocate memory for and copy included types
                while (argv[iNumInc][0]!='-' && iNumInc<iLast){
                    iNumInc++;
                }

                iNumInc-=iCount;

                //... Allocate enough memory for specified included resources
                //    and unspecified resources dependent on them

                pInfo->pszIncResType=LocalAlloc(0 ,(iNumInc+3)*sizeof(char *));
                if (pInfo->pszIncResType == NULL)
                {
                    ExitFromOutOfMemory();
                }


                i=0;
                while(i<iNumInc){
                    pInfo->pszIncResType[i]=LocalAlloc(0, (strlen(argv[iCount])+1) * sizeof(char));
                    if (pInfo->pszIncResType[i] == NULL)
                    {
                        ExitFromOutOfMemory();
                    }
                    //strcpy(pInfo->pszIncResType[i], argv[iCount]);
                    hr = StringCchCopyA(pInfo->pszIncResType[i], (strlen(argv[iCount])+1) * sizeof(char), 
                            argv[iCount]); 
                    if ( ! SUCCEEDED(hr)){
                        ExitFromSafeStringError();
                    }   

                    switch(atoi(argv[iCount])){

                        case 1:
                            bInc1=TRUE;
                            break;

                        case 3:
                            bInc3=TRUE;
                            break;

                        case 12:
                            bInc12=TRUE;
                            break;

                        case 14:
                            bInc14=TRUE;
                            break;

                        default:
                            break;
                    }



                    i++;
                    iCount++;
                }

                //...If 1 or 12 is included, make sure both are included
                if(bInc1 ^ bInc12){

                    pInfo->bIncDependent=TRUE;

                    if(bInc1){
                        pInfo->pszIncResType[i]=LocalAlloc(0, 3 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        // strcpy(pInfo->pszIncResType[i], "12");
                        hr = StringCchCopyA(pInfo->pszIncResType[i], 3 * sizeof(char),"12"); 
                            
                        if ( ! SUCCEEDED(hr)){
                            ExitFromSafeStringError();
                        }   
                        i++;
                    }

                    else{
                        pInfo->pszIncResType[i]=LocalAlloc(0, 2 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        // strcpy(pInfo->pszIncResType[i], "1");
                        hr = StringCchCopyA(pInfo->pszIncResType[i],2 * sizeof(char),"1"); 
                            
                        if ( ! SUCCEEDED(hr)){
                            ExitFromSafeStringError();
                        }   
                        i++;
                    }
                }

                //..If 3 or 14 is included, make sure both are included
                if(bInc3 ^ bInc14){

                    pInfo->bIncDependent=TRUE;

                    if(bInc3){
                        pInfo->pszIncResType[i]=LocalAlloc(0, 3 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        // strcpy(pInfo->pszIncResType[i], "14");
                        hr = StringCchCopyA(pInfo->pszIncResType[i],3 * sizeof(char),"14"); 
                            
                        if ( ! SUCCEEDED(hr)){
                            ExitFromSafeStringError();
                        }   
                        i++;
                    }

                    else{
                        pInfo->pszIncResType[i]=LocalAlloc(0, 2 * sizeof(char));
                        if (pInfo->pszIncResType[i] == NULL)
                        {
                            ExitFromOutOfMemory();
                        }
                        // strcpy(pInfo->pszIncResType[i], "3");
                        hr = StringCchCopyA(pInfo->pszIncResType[i],2 * sizeof(char),"3"); 
                            
                        if ( ! SUCCEEDED(hr)){
                            ExitFromSafeStringError();
                        }   
                        i++;
                    }
                }

                while(i<iNumInc + 3){
                    pInfo->pszIncResType[i++]=NULL;
                }

                break;


            case 'l':

                if(argc<4)
                    return FALSE;

                iCount++;
                pInfo->wLanguage=(WORD)strtol(argv[iCount], NULL, 0);
                iCount++;
                break;

        }
    }

    if(argc<4)
        return FALSE;

    else
        return TRUE;

}


BOOL CALLBACK EnumTypesFunc(HMODULE hModule, LPTSTR lpType, LONG_PTR lParam){

    pCommandLineInfo pInfo;

    pInfo=(pCommandLineInfo)lParam;

    if(!pInfo->bIncludeFlag || bTypeIncluded((char *)lpType, pInfo->pszIncResType)) {

        pInfo->bContainsResources=TRUE;

        //...If the type is a string or a number other than 16...
        if( (PtrToUlong(lpType) & 0xFFFF0000) || ((WORD)PtrToUlong(lpType)!=16) ){
            pInfo->bContainsOnlyVersion=FALSE;
        }

        if(EnumResourceNames(hModule, (LPCTSTR)lpType, EnumNamesFunc, (LONG_PTR)pInfo));
        else {
            return FALSE;
        }
    }


    return TRUE;
}

// This is a Var struct within VarFileInfo for storing checksum for the source file.
// The current size for this structure is 56 bytes.
typedef struct VAR_SRC_CHECKSUM
{
    WORD wLength;
    WORD wValueLength;
    WORD wType;
    WCHAR szResourceChecksum[17];    // For storing "ResourceChecksum" null-terminated string in Unicode.
    DWORD dwChecksum[4];    // 128 bit checksum = 16 bytes = 4 DWORD.
} VarResourceChecksum;

// This is a Var struct within VarFileInfo for stroing the resource types used in this file.
struct VarResourceTypes
{
    WORD wLength;
    WORD wValueLength;
    WORD wType;
    WCHAR szResourceType[13];
    //BYTE padding[0];    // WORD * 3 + UnicodeChar*13 = 32 bytes.  So we need 0 bytes padding for DWORD alignment.
    DWORD* dwTypes;    // 128 bit checksum = 16 bytes = 4 DWORD.
};

BOOL WriteResHeader(
    HANDLE hFile, LONG ResSize, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, DWORD* pdwBytesWritten, DWORD* pdwHeaderSize)
{
    DWORD iPadding;
    WORD IdFlag=0xFFFF;
    unsigned i;
    LONG dwOffset;
    
    //...write the resource's size.
    PutDWord(hFile, ResSize, pdwBytesWritten, pdwHeaderSize);

    //...Put in bogus header size
    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);

    //...Write Resource Type
    if(PtrToUlong(lpType) & 0xFFFF0000)
    {
        PutString(hFile, lpType, pdwBytesWritten, pdwHeaderSize);
    }
    else
    {
        PutWord(hFile, IdFlag, pdwBytesWritten, pdwHeaderSize);
        PutWord(hFile, (USHORT)lpType, pdwBytesWritten, pdwHeaderSize);
    }

    //...Write Resource Name

    if(PtrToUlong(lpName) & 0xFFFF0000){
        PutString(hFile, lpName, pdwBytesWritten, pdwHeaderSize);
    }

    else{
        PutWord(hFile, IdFlag, pdwBytesWritten, pdwHeaderSize);
        PutWord(hFile, (USHORT)lpName, pdwBytesWritten, pdwHeaderSize);
    }


    //...Make sure Type and Name are DWORD-aligned
    iPadding=(*pdwHeaderSize)%(sizeof(DWORD));

    if(iPadding){
        for(i=0; i<(sizeof(DWORD)-iPadding); i++){
            PutByte (hFile, 0, pdwBytesWritten, pdwHeaderSize);
        }
    }

    //...More Win32 header stuff
    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);
    PutWord(hFile, 0x1030, pdwBytesWritten, pdwHeaderSize);


    //...Write Language

    PutWord(hFile, wLanguage, pdwBytesWritten, pdwHeaderSize);

    //...More Win32 header stuff

    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);  //... Version

    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);  //... Characteristics

    dwOffset=(*pdwHeaderSize)-4;

    //...Set file pointer to where the header size is
    if(SetFilePointer(hFile, -dwOffset, NULL, FILE_CURRENT));
    else{
        return FALSE;
    }

    PutDWord(hFile, (*pdwHeaderSize), pdwBytesWritten, NULL);


    //...Set file pointer back to the end of the header
    if(SetFilePointer(hFile, dwOffset-4, NULL, FILE_CURRENT));
    else {
        return FALSE;
    }

    return (TRUE);
}

BOOL WriteResource(HANDLE hFile, HMODULE hModule, WORD wLanguage, LPCSTR lpName, LPCSTR lpType, HRSRC hRsrc)
{
    HGLOBAL hRes;
    PVOID pv;
    LONG ResSize=0L;

    DWORD iPadding;
    unsigned i;

    DWORD dwBytesWritten;
    DWORD dwHeaderSize=0L;


    // Handle other types other than VS_VERSION_INFO
    
    //...write the resource header
    if(!(ResSize=SizeofResource(hModule, hRsrc)))
    {
        return FALSE;
    }

    // 
    // Generate an item in the RES format (*.res) file.
    //

    //
    // First, we generated header for this resource.
    //

    if (!WriteResHeader(hFile, ResSize, lpType, lpName, wLanguage, &dwBytesWritten, &dwHeaderSize))
    {
        return (FALSE);
    }

    //Second, we copy resource data to the .res file
    if (!(hRes=LoadResource(hModule, hRsrc)))
    {
        return FALSE;
    }
    if(!(pv=LockResource(hRes)))
    {
        return FALSE;
    }

    if (!WriteFile(hFile, pv, ResSize, &dwBytesWritten, NULL))
    {
        return FALSE;
    }

    //...Make sure resource is DWORD aligned
    iPadding=dwBytesWritten%(sizeof(DWORD));

    if(iPadding){
        for(i=0; i<(sizeof(DWORD)-iPadding); i++){
            PutByte (hFile, 0, &dwBytesWritten, NULL);
        }
    }
    return TRUE;
}

LPBYTE UpdateAddr(LPBYTE pAddr, WORD size, WORD* len)
{
    *len += size;
    return (pAddr + size);
}

LPBYTE AddPadding(LPBYTE pAddr, WORD* padding, WORD* len)
{
    if ((*padding = *len % 4) != 0)
    {
        *padding = (4 - *padding);
        *len += *padding;
        return (pAddr + *padding);
    }
    return (pAddr);
}

BOOL WriteVersionResource(
    HANDLE hFile, HMODULE hModule, WORD wLanguage, LPCSTR lpName, LPCSTR lpType, HRSRC hRsrc, unsigned char* pbChecksum)
{
    LONG ResSize=0L, OldResSize=0L;
    DWORD dwBytesWritten;
    DWORD dwHeaderSize=0L;
    WORD IdFlag=0xFFFF;
    
    BYTE* newVersionData;
    BYTE* pAddr;
    VarResourceChecksum varResourceChecksum;
    PVOID pv = NULL;
    HGLOBAL hRes;
    WORD len = 0;

    WORD wLength;
    WORD wValueLength;    
    WORD wType;
    LPWSTR szKey;
    WORD wPadding1Count;
    LPBYTE pValue;
    WORD wPadding2Count;
    
    int wTotalLen;
    BOOL isVS_VERSIONINFO = TRUE;
    BOOL isVarFileInfo = FALSE;
    BOOL isStringFileInfo = FALSE;

    BOOL bRet = FALSE;    
    HRESULT hr;

    //
    // Copy resource data from the .res file
    //
    if (hRes=LoadResource(hModule, hRsrc))
    {
        pv=LockResource(hRes);
    }

    if (pv)
    {
        //
        // The first WORD is the size of the VERSIONINFO resource.
        // 
        OldResSize = *((WORD*)pv);
    
        ResSize = OldResSize + sizeof(VarResourceChecksum);
  
        // 
        // Generate an item in the RES format (*.res) file.
        //
    
        //
        // First, we generated header for this resource in the RES file.
        //
        if (WriteResHeader(hFile, ResSize, lpType, lpName, wLanguage, &dwBytesWritten, &dwHeaderSize) &&
            (newVersionData = (BYTE*)LocalAlloc(0, ResSize)))
        {
            bRet = TRUE;

            memcpy(newVersionData, pv, OldResSize);

            // Add the length of new VarResourceChecksum structure to VS_VERSIONINFO.wLength.
            pAddr = newVersionData;

            wTotalLen = *((WORD*)pAddr);

            while (wTotalLen > 0)
            {
                len = 0;
                wPadding1Count = 0;
                wPadding2Count = 0;

                // wLength
                wLength = *((WORD*)pAddr);
                pAddr = UpdateAddr(pAddr, sizeof(WORD), &len);    

                // wValueLength
                wValueLength = *((WORD*)pAddr);
                pAddr = UpdateAddr(pAddr, sizeof(WORD), &len);

                // wType
                wType = *((WORD*)pAddr);
                pAddr = UpdateAddr(pAddr, sizeof(WORD), &len);

                // szKey
                szKey = (LPWSTR)pAddr;
                pAddr = UpdateAddr(pAddr, (WORD)((wcslen((WCHAR*)pAddr) + 1) * sizeof(WCHAR)), &len);

                // Padding 1
                pAddr = AddPadding(pAddr, &wPadding1Count, &len);

                // Value
                pValue = pAddr;

                if (wValueLength > 0)
                {
                    if (wType==1)
                    {
                        // In the case of String, the wValueLength is in WORD (not in BYTE).
                        pAddr = UpdateAddr(pAddr, (WORD)(wValueLength * sizeof(WCHAR)), &len);

                        // Padding 2
                        pAddr = AddPadding(pAddr, &wPadding2Count, &len);
                    } else
                    {
                        pAddr = UpdateAddr(pAddr, wValueLength, &len);                
                        if (isStringFileInfo)
                        {
                            //
                            // Generally, padding is not necessary in binary data.
                            // However, in some rare cases, people use binary data in the StringFileInfo (
                            // which is not really appropriate),
                            // So we need to add proper padding here to get around this.
                            //
                    
                            // Padding 2
                            pAddr = AddPadding(pAddr, &wPadding2Count, &len);
                        }
                    }
                }

                if (isVS_VERSIONINFO)
                {
                    //
                    // This is VS_VERSION_INFO.
                    //

                    // VS_VERSIONINFO can have padding 2.
                    isVS_VERSIONINFO = FALSE;
                    // Padding 2
                    pAddr = AddPadding(pAddr, &wPadding2Count, &len);

                    //
                    // Add the new VarResourceChecksum structure.
                    //
                    wLength += sizeof(VarResourceChecksum);
                }

                if (wcscmp(szKey, L"StringFileInfo") == 0)
                {
                    isStringFileInfo = TRUE;
                }

                if (wcscmp(szKey, L"VarFileInfo") == 0)
                {
                    isStringFileInfo = FALSE;
                    isVarFileInfo = TRUE;
                    wLength += sizeof(VarResourceChecksum);
                }

                PutWord(hFile, wLength, &dwBytesWritten, NULL);
                PutWord(hFile, wValueLength, &dwBytesWritten, NULL);
                PutWord(hFile, wType, &dwBytesWritten, NULL);
                PutStringW(hFile, szKey, &dwBytesWritten, NULL);
                PutPadding(hFile, wPadding1Count, &dwBytesWritten, NULL);
                WriteFile(hFile, pValue, wValueLength * (wType == 0 ? sizeof(BYTE) : sizeof(WCHAR)), &dwBytesWritten, NULL);
                PutPadding(hFile, wPadding2Count, &dwBytesWritten, NULL);

                if (isVarFileInfo && wcscmp(szKey, L"Translation") == 0)
                {
                    isVarFileInfo = FALSE;
                    varResourceChecksum.wLength = sizeof(VarResourceChecksum);
                    varResourceChecksum.wValueLength = 16;   // 128 bits checksum = 16 bytes
                    varResourceChecksum.wType = 0;
                    // wcscpy(varResourceChecksum.szResourceChecksum, RESOURCE_CHECK_SUM);
                    hr = StringCchCopyW(varResourceChecksum.szResourceChecksum, sizeof (varResourceChecksum.szResourceChecksum)/ sizeof (WCHAR),
                        RESOURCE_CHECK_SUM);
                    if ( ! SUCCEEDED(hr)){
                        ExitFromSafeStringError();
                    }   

                    memcpy(varResourceChecksum.dwChecksum, pbChecksum, 16);

                    if (!WriteFile(hFile, &varResourceChecksum, sizeof(VarResourceChecksum), &dwBytesWritten, NULL))
                    {
                        bRet = FALSE;
                        break;
                    }
                }

                wTotalLen -= len;        
            }

            LocalFree(newVersionData);
        }
    }

    return (bRet);
}


BOOL CALLBACK EnumLangsFunc( 
    HANDLE hModule,     // module handle 
    LPCTSTR lpType,     // address of resource type 
    LPCTSTR lpName,     // address of resource name 
    WORD wLang,         // resource language 
    LONG_PTR lParam)    // extra parameter, could be 
                        // used for error checking 
{ 
    HANDLE hResInfo; 
    char szBuffer[80]; 
    int cbString = 0; 
    pCommandLineInfo pInfo;
        
    if (lParam == 0)
    {
        printf("EnumLangsFunc: lParam is invalid!\n");
        return FALSE;
    }

    pInfo = (pCommandLineInfo) lParam;
    //
    // only write out the resource if the language id matches, otherwise just skip it and return true
    // the call back will return whatever Write(Version)Resource function(s) return
    //

    //
    // Multi lingual binary has more than two language ID, in this case
    // we don't want to extract english version resource. (this is a fix of side effect; forcing english version 
    // saved as localized one)
    //
    if ((WORD)PtrToUlong(lpType) == 16 && wLang == 0x409 && pInfo->wLanguage != 0x409)
    {
        hResInfo = FindResourceEx(hModule, lpType, lpName, pInfo->wLanguage); 
        
        if (hResInfo)
        {   // This is multi lingual DLL. we don't want to extract English Version resource.
            return TRUE;
        }
    }

    //
    // Some files does not localize VERSIOIN so we force VERSION should be added into MUI file as localized one.
    // if resource in the binary has more than two types, and type 16 is smallest resource number, then
    // it does not work in this routine.
    //
    
    if (pInfo->wLanguage == wLang || ( (WORD)PtrToUlong(lpType) == 16 && wLang == 0x409 && pInfo->bLanguageFound ) )
    {
        pInfo->bLanguageFound=TRUE;     // set this to true now that we have found at least one resource    
        hResInfo=FindResourceEx(hModule, lpType, lpName, pInfo->wLanguage);    
        if (hResInfo)
        {
            if (lpType == MAKEINTRESOURCE(RT_VERSION) && pInfo->bIsResChecksumGenerated)
            {
                //
                // If this is a version resource and resource checksum is generated, call
                // the following function to embed the resource checksum into the version
                // resource.
                //
                return (WriteVersionResource(pInfo->hFile, hModule, pInfo->wLanguage, lpName, lpType, hResInfo, pInfo->pResourceChecksum));
            }
            return (WriteResource(pInfo->hFile, hModule, pInfo->wLanguage, lpName, lpType, hResInfo));   
        }
    } 
    return TRUE; 
} 



BOOL CALLBACK EnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam)
{

    HRSRC hRsrc;
    pCommandLineInfo pInfo;

    if(lParam == 0)
    {       
        printf( "MUIBLD: EnumNamesFunc lParam value incorrect (%d)\n", lParam );
        return FALSE;
    }

    return EnumResourceLanguages(hModule, 
                                    lpType, 
                                    lpName, 
                                    (ENUMRESLANGPROC)EnumLangsFunc, 
                                    lParam); 
}



BOOL bTypeIncluded(LPCSTR lpType, char **pszIncResType){
    char *pszBuf;
    char **p;
    HRESULT hr;

    if (PtrToUlong(lpType) & 0xFFFF0000) {
        pszBuf=LocalAlloc(0, strlen(lpType) +1);
        if (pszBuf == NULL)
        {
            ExitFromOutOfMemory();
        }

        //sprintf(pszBuf, "%s", lpType);
        hr = StringCbPrintfA(pszBuf, strlen(lpType) +1, "%s", lpType);
        if ( ! SUCCEEDED(hr)){
            ExitFromSafeStringError();
        }   
    }

    else {
        WORD wType = (WORD) lpType;
        pszBuf=LocalAlloc(0, sizeof(lpType) + 1);
        if (pszBuf == NULL)
        {
            ExitFromOutOfMemory();
        }
        // sprintf(pszBuf, "%u", wType);
        
        hr = StringCbPrintfA(pszBuf, sizeof(lpType) +1,  "%u", wType);
        if ( ! SUCCEEDED(hr)){
            ExitFromSafeStringError();
        } 
    }

    p=pszIncResType;

    while(p && *p){
        if(strcmp(pszBuf, *p)==0)
            return TRUE;
        p++;
    }
    LocalFree(pszBuf);

    return FALSE;
}


BOOL bInsertHeader(HANDLE hFile){
    DWORD dwBytesWritten;

    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x20, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);

    PutWord (hFile, 0xffff, &dwBytesWritten, NULL);
    PutWord (hFile, 0x00, &dwBytesWritten, NULL);
    PutWord (hFile, 0xffff, &dwBytesWritten, NULL);
    PutWord (hFile, 0x00, &dwBytesWritten, NULL);

    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);

    return TRUE;
}

void  PutByte(HANDLE OutFile, TCHAR b, LONG *plSize1, LONG *plSize2){
    BYTE temp=b;

    if (plSize2){
        (*plSize2)++;
    }

    WriteFile(OutFile, &b, 1, plSize1, NULL);
}

void PutWord(HANDLE OutFile, WORD w, LONG *plSize1, LONG *plSize2){
    PutByte(OutFile, (BYTE) LOBYTE(w), plSize1, plSize2);
    PutByte(OutFile, (BYTE) HIBYTE(w), plSize1, plSize2);
}

void PutDWord(HANDLE OutFile, DWORD l, LONG *plSize1, LONG *plSize2){
    PutWord(OutFile, LOWORD(l), plSize1, plSize2);
    PutWord(OutFile, HIWORD(l), plSize1, plSize2);
}


void PutString(HANDLE OutFile, LPCSTR szStr , LONG *plSize1, LONG *plSize2){
    WORD i = 0;

    do {
        PutWord( OutFile , szStr[ i ], plSize1, plSize2);
    }
    while ( szStr[ i++ ] != TEXT('\0') );
}

void PutStringW(HANDLE OutFile, LPCWSTR szStr , LONG *plSize1, LONG *plSize2){
    WORD i = 0;

    do {
        PutWord( OutFile , szStr[ i ], plSize1, plSize2);
    }
    while ( szStr[ i++ ] != L'\0' );
}

void PutPadding(HANDLE OutFile, int paddingCount, LONG *plSize1, LONG *plSize2)
{
    int i;
    for (i = 0; i < paddingCount; i++)
    {
        PutByte(OutFile, 0x00, plSize1, plSize2);
    }
}

void Usage(){
    printf("MUIBLD [-h|?] [-c checksum_filename] [-v] -l langid [-i resource_type] source_filename\n");
    printf("    [target_filename]\n\n");
}

void CleanUp(pCommandLineInfo pInfo, HANDLE hModule, BOOL bDeleteFile){
    if(hModule)
        FreeLibrary(hModule);

    if(pInfo->hFile)
        CloseHandle(pInfo->hFile);

    if(bDeleteFile && pInfo->pszTarget)
        DeleteFile(pInfo->pszTarget);

}

void FreeAll(pCommandLineInfo pInfo){
    char **p;

    LocalFree(pInfo->pszSource);
    LocalFree(pInfo->pszTarget);

    if(pInfo->pszIncResType){
        p=pInfo->pszIncResType;
        while(p && *p){
            LocalFree(*p);
            p++;
        }
        LocalFree(pInfo->pszIncResType);
    }
}

void ExitFromOutOfMemory()
{
    printf("Out of memory.  Can not continue. GetLastError() = 0x%x.", GetLastError());
    exit(1);
}

void ExitFromSafeStringError()
{
    printf("Safe string return error. Can not continue.\n");
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muibld\muibld.h ===
#define ERROR_ONLY_VERSION_STAMP		1
#define ERROR_NO_RESOURCES				2
#define	ERROR_LANGUAGE_NOT_IN_SOURCE	3
#define ERROR_NO_SOURCE					4
#define	ERROR_NO_TARGET					5
#define ERROR_NO_LANGUAGE_SPECIFIED		6
#define ERROR_TOO_FEW_ARGUMENTS			7
#define DEPENDENT_RESOURCE_REMOVED		8

#define ERROR_OFFSET 100
#define ADDED_EXT ".RES"
#define ASCII_OFFSET 48

#define RESOURCE_CHECK_SUM L"ResourceChecksum"

#define GetFilePointer(hFile) SetFilePointer(hFile, 0, NULL, FILE_CURRENT)
 
#define GetVLFilePointer(hFile, lpPositionHigh) \
    (*lpPositionHigh = 0, \
    SetFilePointer(hFile, 0, lpPositionHigh, FILE_CURRENT))

#define MD5_CHECKSUM_SIZE 16

struct CommandLineInfo {
    char *pszSource;
    char *pszTarget;
    HANDLE hFile;
    WORD wLanguage;
    char **pszIncResType;
    BOOL bContainsOnlyVersion;
    BOOL bContainsResources;
    BOOL bLanguageFound;
    BOOL bIncDependent;
    BOOL bIncludeFlag;
    BOOL bVerbose;
    
    char *pszChecksumFile;
    BOOL bIsResChecksumGenerated;
    unsigned char pResourceChecksum[MD5_CHECKSUM_SIZE];

};

typedef struct CommandLineInfo *pCommandLineInfo;

void PutByte(HANDLE OutFile, TCHAR b, LONG *plSize1, LONG *plSize2);
void PutWord(HANDLE OutFile, WORD w, LONG *plSize1, LONG *plSize2);
void PutDWord (HANDLE OutFile, DWORD l, LONG *plSize1, LONG *plSize2);
void PutString(HANDLE OutFile, LPCSTR szStr , LONG *plSize1, LONG *plSize2);
void PutStringW(HANDLE OutFile, LPCWSTR szStr , LONG *plSize1, LONG *plSize2);
void PutPadding(HANDLE OutFile, int paddingCount, LONG *plSize1, LONG *plSize2);

void Usage();
void CleanUp(pCommandLineInfo pInfo, HANDLE hModule, BOOL bDeleteFile);
void FreeAll(pCommandLineInfo pInfo);

BOOL ParseCommandLine(int argc, char *argv[], pCommandLineInfo pInfo);
BOOL CALLBACK EnumTypesFunc(HMODULE hModule, LPTSTR lpType, LONG_PTR lParam);
BOOL CALLBACK EnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam);
BOOL bTypeIncluded(LPCSTR pszType, char **pszIncResType);
BOOL bInsertHeader(HANDLE hFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muimsidll\muimsidll.cpp ===
// muimsidll.cpp : Defines the entry point for the DLL application.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <Msiquery.h>
#include <wmistr.h>
#include <wmiumkm.h>
#include <Shlwapi.h>
#include <Setupapi.h>
#include <advpub.h>
#include <lmcons.h>
#include <strsafe.h>
#include <intlmsg.h>


//
// DEFINES
//
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#define MUI_LANG_GROUP_FILE         TEXT("muilang.txt")
#define BUFFER_SIZE                 1024
#define MUISETUP_PATH_SEPARATOR     TEXT("\\")
#define MUIDIR                      TEXT("MUI")
#define MUI_LANGPACK_SECTION        TEXT("LanguagePack")
#define MUI_COMPONENTS_SECTION      TEXT("Components")
#define LANGGROUPNUMBER             32
#define LANGPACKDISKCOST            300000000
#define DEFAULT_INSTALL_SECTION     TEXT("DefaultInstall")
#define DEFAULT_UNINSTALL_SECTION   TEXT("DefaultUninstall")
#define FALLBACKDIR                 TEXT("MUI\\FALLBACK")
#define EXTDIR                      TEXT("External")
#define COMP_TICK_INC               5000000      
#define LANGPACK_TICK_INC           200000000
#define OEM_COMPONENT               1

#define SELECTMUIINFBINSTREAM       TEXT("SELECT `Data` FROM `Binary` WHERE `Name` = 'MUIINF'")

// name of intl.cpl event source
#define REGOPT_EVENTSOURCE          TEXT("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\Regional and Language Options")
#define REGOPT_EVENTSOURCE_NAME     TEXT("Regional and Language Options")


#ifdef MUI_DEDUG
#define DEBUGMSGBOX(a, b, c, d) MessageBox(a, b, c, d)
#else
#define DEBUGMSGBOX(a, b, c, d) 
#endif


//
// TYPEDEFS
//
typedef 
BOOL (WINAPI *pfnMUI_InstallMFLFiles)( 
    TCHAR* pMUIInstallLanguage
    );


//
// Internal function prototypes
//
void NotifyKernel(LPTSTR LangList, ULONG Flags, MSIHANDLE hInstall);
BOOL MofCompileLanguage(LPTSTR Languages, MSIHANDLE hInstall);
BOOL EnumLanguageGroupLocalesProc(LGRPID langGroupId,     LCID lcid, LPTSTR lpszLocale, LONG_PTR lParam);
BOOL EnumLanguageGroupsProc(LGRPID LanguageGroup, LPTSTR lpLanguageGroupString, LPTSTR lpLanguageGroupNameString, DWORD dwFlags, LONG_PTR lParam);
LGRPID GetLanguageGroup(LCID lcid, MSIHANDLE hInstall);
BOOL RunRegionalOptionsApplet(LPTSTR pCommands, BOOL bSilent, MSIHANDLE hInstall);
BOOL DeleteSideBySideMUIAssemblyIfExisted(LPTSTR Language, TCHAR pszLogFile[BUFFER_SIZE]);
BOOL ReturnAllRequiredLangGroups(LPTSTR szLcid, UINT cchLcidBufsize, LPTSTR szMuiInfPath, UINT cchPathbufsize, LGRPID *lgrpids, UINT *uiNumFoundGroups, MSIHANDLE hInstall);
BOOL ExecuteComponentINF(PTSTR pComponentName, PTSTR pComponentInfFile, PTSTR pInstallSection, BOOL bInstall, MSIHANDLE hInstall);
INT InstallComponentsMUIFiles(PTSTR pszLanguage, BOOL isInstall, MSIHANDLE hInstall);
BOOL FileExists(LPTSTR szFile);
void LogCustomActionInfo(MSIHANDLE hInstall, LPCTSTR szErrorMsg);
BOOL SetUILanguage(TCHAR *szLanguage, BOOL bCurrent, BOOL bDefault, MSIHANDLE hInstall);
UINT GetMUIComponentsNumber(PTSTR pszLanguage, MSIHANDLE hInstall);
BOOL GetMUIInfPath(TCHAR *szMUIInfPath, UINT cchBufSize, MSIHANDLE hInstall);
BOOL GetLCID(TCHAR *szLanguage, UINT cchBufSize, MSIHANDLE hInstall);
BOOL MUICchPathAppend(LPTSTR szDestination, UINT cchDestBufSize, LPTSTR szAppend, UINT cchAppBufSize, MSIHANDLE hInstall);
BOOL MUIReportInfoEvent(DWORD dwEventID, TCHAR *szLanguage, UINT cchBufSize, MSIHANDLE hInstall);
BOOL MUICheckEventSource(MSIHANDLE hInstall);
LANGID GetDotDefaultUILanguage(MSIHANDLE hInstall);
BOOL IsOEMSystem();

//
// Global Variables
//
// Flags to indicate whether a language group is found for the locale or not.
BOOL    gFoundLangGroup;
LGRPID  gLangGroup;
LCID    gLCID;

// The language groups installed in the system.
LGRPID  gLanguageGroups[LANGGROUPNUMBER] ;
int     gNumLanguageGroups;

//
// Main dll entry point
//
BOOL APIENTRY DllMain(  HANDLE hModule, 
                            DWORD  ul_reason_for_call, 
                            LPVOID lpReserved)
{
	switch (ul_reason_for_call)
    {
        case ( DLL_THREAD_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_THREAD_DETACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_ATTACH ) :
        {
            return (TRUE);
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            return (TRUE);
        }
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////////////
// 
// DisableCancelButton
//
// The DisableCancelButton checks to see if a specific parameter has been passed
// to the current installation, if it has, it will issue a command to disable
// the cancel button in the UI during installation.  This is used by our
// muisetup.exe wrapper so that the user cannot cancel out of an installation or
// uninstallation once it has started.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA1(MSIHANDLE hInstall)
{
    UINT        uiRet = ERROR_SUCCESS;
    PMSIHANDLE  hRecord = MsiCreateRecord(3);	
    TCHAR       szBuffer[BUFFER_SIZE] = { 0 };
    HRESULT     hr = S_OK;
    
    if (NULL == hInstall)
    {
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // if can't create a msi record, just return
    if (NULL == hRecord)
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA1 Failure: cannot create MSI Record."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // field 0 = unused, field 1 = 2 (cancel button), field 2 = 0 (0 to disable/hide cancel button)
    if (ERROR_SUCCESS != MsiRecordSetInteger(hRecord, 1, 2))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA1 Failure: MsiRecordSetInteger function failed."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    if (ERROR_SUCCESS != MsiRecordSetInteger(hRecord, 2, 0))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA1 Failure: MsiRecordSetInteger function failed."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    MsiProcessMessage(hInstall, INSTALLMESSAGE_COMMONDATA, hRecord);
    
Exit:
    return uiRet;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// InstallComponentInfs
//
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA10(MSIHANDLE hInstall)
{
    TCHAR       szLanguage[5] = {0};
    TCHAR       szBuffer[BUFFER_SIZE] = {0};
    PMSIHANDLE  hRec = MsiCreateRecord(3);
    PMSIHANDLE  hProgressRec = MsiCreateRecord(3);
    UINT        iFunctionResult = ERROR_SUCCESS;
    INT         iInstallResult = IDOK;
    HRESULT     hr = S_OK;

    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }
    
    if ((NULL == hRec) || (NULL == hProgressRec))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA10 Failure: cannot create MSI Record."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }    
        return ERROR_INSTALL_FAILURE;
    }

    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA10 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }    
        return ERROR_INSTALL_FAILURE;
    }

    // Tell the installer to check the installation state and execute
    // the code needed during the rollback, acquisition, or
    // execution phases of the installation.
    if (MsiGetMode(hInstall,MSIRUNMODE_ROLLBACK))
    {
        // Installer is rolling back the installation, here we just remove what we had before
        // Since we are in rollback, we don't set progress bar or update message in UI
        // we also don't check for returned results here, since the installation has failed already.
        InstallComponentsMUIFiles(szLanguage, FALSE, hInstall);        
        return ERROR_SUCCESS;
    }
 
    if (!MsiGetMode(hInstall,MSIRUNMODE_SCHEDULED))
    {
        // Installer is generating the installation script of the custom
        // action.  Tell the installer to increase the value of the final total
        // length of the progress bar by the total number of ticks in the
        // custom action.

        UINT iCount = GetMUIComponentsNumber(szLanguage, hInstall);   

        if (iCount > 0)
        {
            MsiRecordSetInteger(hRec,1,3);
            MsiRecordSetInteger(hRec,2,COMP_TICK_INC * iCount);
            MsiRecordSetInteger(hRec,3,0);
            iInstallResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hRec);
        } 

        //
        // we just want to trap the cancel message here, otherwise we always return success since
        // we are just setting progressbar here.
        //
        if (iInstallResult == IDCANCEL)
        {
            return ERROR_INSTALL_USEREXIT;
        }
        else
        {
            return ERROR_SUCCESS;            
        }
    }
    else
    {
        // Installer is executing the installation script. Set up a
        // record specifying appropriate templates and text for messages
        // that will inform the user about what the custom action is
        // doing. Tell the installer to use this template and text in
        // progress messages.
        MsiRecordSetString(hRec,1,TEXT("Installing Components."));
        MsiRecordSetString(hRec,2,TEXT("Installing External Component Inf files..."));
        MsiRecordSetString(hRec,3,TEXT("Installing MUI files for Component [1]."));
        MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONSTART, hRec);

        // Tell the installer to use explicit progress messages.
        MsiRecordSetInteger(hRec,1,1);
        MsiRecordSetInteger(hRec,2,1);
        MsiRecordSetInteger(hRec,3,0);
        MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hRec);

        // do the actual work for the custom action
        iInstallResult = InstallComponentsMUIFiles(szLanguage, TRUE, hInstall);
        if (IDCANCEL == iInstallResult)
        {
            iFunctionResult = ERROR_INSTALL_USEREXIT;
        }
        else if (-1 == iInstallResult)
        {
            iFunctionResult =  ERROR_INSTALL_FAILURE;
        }
        else
        {
            iFunctionResult =  ERROR_SUCCESS;
        }
    }

    return iFunctionResult;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// UninstallComponentInfs
//
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA11(MSIHANDLE hInstall)
{
    TCHAR       szLanguage[5] = {0};
    TCHAR       szBuffer[BUFFER_SIZE] = {0};
    PMSIHANDLE  hRec = MsiCreateRecord(3);
    PMSIHANDLE  hProgressRec = MsiCreateRecord(3);
    UINT        iFunctionResult = ERROR_SUCCESS;
    INT         iInstallResult = IDOK;
    HRESULT     hr = S_OK;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }
    
    if ((NULL == hRec) || (NULL == hProgressRec))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA11 Failure: cannot create MSI Record."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }    
        return ERROR_INSTALL_FAILURE;
    }

    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("CA11 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }    
        return ERROR_INSTALL_FAILURE;
    }

    
    // Tell the installer to check the installation state and execute
    // the code needed during the rollback, acquisition, or
    // execution phases of the installation.
    if (MsiGetMode(hInstall,MSIRUNMODE_ROLLBACK))
    {
        // Installer is rolling back the installation.  We will reinstall what we uninstalled before.
        // we don't update progress message here.  And we always return SUCCESS
        InstallComponentsMUIFiles(szLanguage, TRUE, hInstall);
        return ERROR_SUCCESS;
    }
 
    if (!MsiGetMode(hInstall,MSIRUNMODE_SCHEDULED))
    {
        // Installer is generating the installation script of the custom
        // action.  Tell the installer to increase the value of the final total
        // length of the progress bar by the total number of ticks in the
        // custom action.        
        UINT iCount = GetMUIComponentsNumber(szLanguage, hInstall);            
        if (iCount > 0)
        {       
            MsiRecordSetInteger(hRec,1,3);
            MsiRecordSetInteger(hRec,2,COMP_TICK_INC * iCount);
            MsiRecordSetInteger(hRec,3,0);
            iInstallResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hRec);
        } 
        //
        // we just want to trap the cancel message here, otherwise we always return success since
        // we are just setting progressbar here.
        //
        if (iInstallResult == IDCANCEL)
        {
            return ERROR_INSTALL_USEREXIT;
        }
        else
        {
            return ERROR_SUCCESS;            
        }
    }
    else
    {
        // Installer is executing the installation script. Set up a
        // record specifying appropriate templates and text for messages
        // that will inform the user about what the custom action is
        // doing. Tell the installer to use this template and text in
        // progress messages.
        MsiRecordSetString(hRec,1,TEXT("Uninstall Components."));
        MsiRecordSetString(hRec,2,TEXT("Removing External Component Inf files..."));
        MsiRecordSetString(hRec,3,TEXT("Removing MUI files for Component [1]."));
        MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONSTART, hRec);

        // Tell the installer to use explicit progress messages.
        MsiRecordSetInteger(hRec,1,1);
        MsiRecordSetInteger(hRec,2,1);
        MsiRecordSetInteger(hRec,3,0);
        MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hRec);

        // do the actual work for the custom action, we only check for user cancel here
        // and nothing else
        iInstallResult = InstallComponentsMUIFiles(szLanguage, FALSE, hInstall);
        if (IDCANCEL == iInstallResult)
        {
            iFunctionResult = ERROR_INSTALL_USEREXIT;
        }
        else if (-1 == iInstallResult)
        {
            iFunctionResult =  ERROR_INSTALL_FAILURE;
        }
        else
        {
            iFunctionResult =  ERROR_SUCCESS;
        }

    }
    
    return iFunctionResult;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// SetLangPackRequirement
//
// This function is used to set a property in the MSI Database so that the installation knows whether
// it needs to install the language pack or not so it can reserve diskcost for it
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA3(MSIHANDLE hInstall)
{
    LGRPID  lgrpid[LANGGROUPNUMBER] = {0};
    UINT    iRet = ERROR_SUCCESS;
    UINT    uiLGrpNums = 0;
    UINT    i;
    DWORD   uiAddCost = 0;
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    TCHAR   szMUIInfPath[MAX_PATH+1] = {0};
    TCHAR   szLanguage[5] = {0};
    HRESULT hr = S_OK;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }

    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA3 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return ERROR_INSTALL_FAILURE;
    }
  
    if (!GetMUIInfPath(szMUIInfPath, MAX_PATH+1, hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA3 Failure: Cannot find installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return ERROR_INSTALL_FAILURE;
    }
    
    if (!ReturnAllRequiredLangGroups(szLanguage, ARRAYSIZE(szLanguage), szMUIInfPath, ARRAYSIZE(szMUIInfPath), lgrpid, &uiLGrpNums, hInstall))
    {
        // log an error
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA3: ReturnAllRequiredLangGroups failed."));  
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }        
        iRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

#ifdef MUI_DEBUG
    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA3: The number of lang groups required is %d."), uiLGrpNums);
    if (SUCCEEDED(hr))
    {
        DEBUGMSGBOX(NULL, tcMessage, NULL, MB_OK);
    }
#endif

    // Enumerate through all the lang groups required, check there are any language groups that requires installation
    for (i = 0; i < uiLGrpNums; i++)
    {
        if (!IsValidLanguageGroup(lgrpid[i], LGRPID_INSTALLED))
        {
            uiAddCost += LANGPACKDISKCOST;
        }
    }

    if (uiAddCost > 0)
    {
        DEBUGMSGBOX(NULL, TEXT("CA3: Need to install additional language groups."), NULL, MB_OK);                            
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("MsiRequireLangPack"), TEXT("1")))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA3 Failure: Cannot set MsiRequireLangPack property in the MSI Database."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }        
            iRet = ERROR_INSTALL_FAILURE;
        }               
    }
    else
    {
        DEBUGMSGBOX(NULL, TEXT("CA3: Language group already installed."), NULL, MB_OK);                        
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("MsiRequireLangPack"), NULL))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA3 Failure: Cannot set MsiRequireLangPack property in the MSI Database."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            iRet = ERROR_INSTALL_FAILURE;
        }
    }


Exit:
    return iRet;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// IsNTSuiteWebBlade
//
// This function is used by a custom action in our setup package to detect whether setup was invoked on a windows Blade server.
//
////////////////////////////////////////////////////////////////////////////////////
/*UINT CA5(MSIHANDLE hInstall)
{
    OSVERSIONINFOEX osvi;
    TCHAR           tcMessage[BUFFER_SIZE] = {0};
    HRESULT         hr = S_OK;

    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }
       
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx ((OSVERSIONINFO *) &osvi))
    {
        // log an error
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA5 Failure: GetVersionEx failed, cannot retrieve platform OS version.  Error returned is: %d."), GetLastError());    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;     
    }
    else
    {
        if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&			// test for NT
        	( (osvi.dwMajorVersion == 5) && (osvi.dwMinorVersion > 0) ) &&	// test for version > 5.0 (Whistler or later)
        	( (osvi.wSuiteMask & VER_SUITE_BLADE ) != 0) &&			// test for Suite Web Server
        	( (osvi.wProductType != VER_NT_WORKSTATION ) ))			// test for non-workstation type (server)
        {
            // here we need to set a MSI property so that the current installation knows that NT Suite is WebBlade
            if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("MsiNTSuiteWebBlade"), TEXT("1")))
            {
                // log an error
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA5 Failure: Failed to set required MUI MSI property."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
                return ERROR_INSTALL_FAILURE;   // can't set the property, return error
            }                
        }
        else
        {
            // here we need to set a MSI property so that the current installation knows that NT Suite is WebBlade
            if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("MsiNTSuiteWebBlade"), NULL))
            {
                // log an error
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA5: Failed to set required MUI MSI property."));   
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
                return ERROR_INSTALL_FAILURE;   // can't set the property, return error
            }                
        }
    }
    return ERROR_SUCCESS;
}
*/

////////////////////////////////////////////////////////////////////////////////////
//
// CheckDefaultSystemUILang
//
// This function is used by our setup to check whether setup is invoked on a system with US-English as the default language (0x0409)
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA4(MSIHANDLE hInstall)
{
    // get the system default UI language, and set a MSI property accordingly
    LANGID  liSysLang = GetSystemDefaultUILanguage();
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    HRESULT hr = S_OK;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }
    
    if (liSysLang == 0x0409)
    {
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("MUISystemLangIsEnglish"), TEXT("1")))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA4 Failure: Failed to set property MUISystemLangIsEnglish."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);        
            }
            return ERROR_INSTALL_FAILURE;   // can't set the property, return error
        }                    
    }
    else
    {
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("MUISystemLangIsEnglish"), NULL))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA4 Failure: Failed to set property MUISystemLangIsEnglish."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return ERROR_INSTALL_FAILURE;   // can't set the property, return error
        }                
    }

    return ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////////
//
// LogInstallComplete
//
// This function is used by setup to log a message to the system event logger
// to indicate that the MUI language is installed.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA12(MSIHANDLE hInstall)
{
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    TCHAR   szLanguage[5] = {0};    
    HRESULT hr = S_OK;

    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        // log an error
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA12 Failure: Failed to get property MUILcid."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;   
    }

    if (MUIReportInfoEvent(MSG_REGIONALOPTIONS_LANGUAGEINSTALL, szLanguage, BUFFER_SIZE, hInstall))
    {
        return ERROR_SUCCESS;
    }

    // log an error, if we get to here it's always an error
    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA12 Failure: Failed to log to system event logfile."));    
    if (SUCCEEDED(hr))
    {
        LogCustomActionInfo(hInstall, tcMessage);
    }
    return ERROR_INSTALL_FAILURE;      
}


////////////////////////////////////////////////////////////////////////////////////
//
// LogUninstallComplete
//
// This function is used by setup to log a message to the system event logger
// to indicate that the MUI language is uninstalled.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA13(MSIHANDLE hInstall)
{
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    TCHAR   szLanguage[5] = {0};    
    HRESULT hr = S_OK;

    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        // log an error
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA13 Failure: Failed to get property MUILcid."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;   
    }

    if (MUIReportInfoEvent(MSG_REGIONALOPTIONS_LANGUAGEUNINSTALL, szLanguage, BUFFER_SIZE, hInstall))
    {
        return ERROR_SUCCESS;
    }

    // log an error, if we get to here it's always an error
    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA13 Failure: Failed to log to system event logfile."));    
    if (SUCCEEDED(hr))
    {
        LogCustomActionInfo(hInstall, tcMessage);
    }
    return ERROR_INSTALL_FAILURE;      
}


////////////////////////////////////////////////////////////////////////////////////
//
// InstallWBEMMUI
//
// This function is used to set up WMI\WBEM stuff for MUI.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA6(MSIHANDLE hInstall)
{
    UINT    iRet = ERROR_SUCCESS;
    TCHAR   szLanguage[5] = {0};
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    HRESULT hr = S_OK;
    size_t  cch = 0;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }
    
    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA6 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return ERROR_INSTALL_FAILURE;
    }
  
    //
    // call WBEM API to mofcompile MUI MFL's for each language
    //
    if (!MofCompileLanguage(szLanguage, hInstall))
    {
        // log an error
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA6 Failure: MofCompileLanguage Failed."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        iRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    //
    // Inform kernel that new languages have been added
    //
    NotifyKernel(szLanguage, WMILANGUAGECHANGE_FLAG_ADDED, hInstall);
    
Exit:
    return iRet;

}


////////////////////////////////////////////////////////////////////////////////////
//
// UninstallWBEMMUI
//
// This function is called by our setup to uninstall external component associated with a MSI package.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA7(MSIHANDLE hInstall)
{
    UINT    iRet = ERROR_SUCCESS;
    TCHAR   szLanguage[5] = {0};
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    HRESULT hr = S_OK;
    size_t  cch = 0;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }
    
    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA7 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return ERROR_INSTALL_FAILURE;
    }
    
    //
    // Inform kernel that new languages have been added
    //
    NotifyKernel(szLanguage, WMILANGUAGECHANGE_FLAG_REMOVED, hInstall);

    return iRet;
}


////////////////////////////////////////////////////////////////////////////////////
//
// SetDefaultUserLanguage
//
// This function does two things - depending on the MSI execution mode:
//
// 1. Immediate:
// This function in immediate mode will schedule the deferred and the rollback
// custom action C8D/C8R.  (C8D and C8R are the expected CA identifiers used
// in the MUI MSI package)
//
// 2. Deferred/Rollback:
// This function sets the default language of new users to that of the MUI
// language that is being installed.  GetLCID in this instance will read
// the set CustomActionData property which is what we want.
//
// Also, reboot is needed after this CA in deferred mode, but this is specified 
// in the template itself, so the CA itself will not prompt for reboot (it can't 
// anyways, since it is deferred).
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA8(MSIHANDLE hInstall)
{
    UINT        iRet = ERROR_SUCCESS;
    TCHAR       szLanguage[5] = {0};
    TCHAR       szOrigLanguage[5] = {0};
    TCHAR       tcMessage[BUFFER_SIZE] = {0};
    HRESULT     hr = S_OK;
    size_t      cch = 0;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }

    // get the MUI LCID that we want to set the default UI Language to.
    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        iRet =  ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // if immediate mode (not scheduled/commit/rollback), schedule the custom actions
    if (!MsiGetMode(hInstall, MSIRUNMODE_SCHEDULED) && 
        !MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK)&& 
        !MsiGetMode(hInstall, MSIRUNMODE_COMMIT))
    {
        // get the current default UI language
        LANGID lgID = GetDotDefaultUILanguage(hInstall);
        hr = StringCchPrintf(szOrigLanguage, ARRAYSIZE(szOrigLanguage), TEXT("%04x"), lgID);
        if (FAILED(hr))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8 Failure: Cannot retrieve default UI language."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // schedule the appropriate custom actions and property setting custom actions
        // Rollback custom action goes first
        // Create a rollback custom action (in case install is stopped and rolls back)
        // Rollback custom action can't read tables, so we have to set a property
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("CA8R"), szOrigLanguage))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8 Failure: Failed to set rollback custom action property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;	    
        }
        if (ERROR_SUCCESS != MsiDoAction(hInstall, TEXT("CA8R")))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8 Failure: Failed to schedule rollback custom action."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // Create a deferred custom action (gives us the right priviledges to create the user account)
        // Deferred custom actions can't read tables, so we have to set a property
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("CA8D"), szLanguage))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8 Failure: Failed to set deferred custom action property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;	    
        }

        if (ERROR_SUCCESS != MsiDoAction(hInstall, TEXT("CA8D")))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8 Failure: Failed to schedule deferred custom action."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }    
    }
    else
    {
        if (FALSE == SetUILanguage(szLanguage, FALSE, TRUE, hInstall))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA8: Failed to set Default UI language."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            iRet = ERROR_INSTALL_FAILURE;
        }
        else
        {
            iRet = ERROR_SUCCESS;
        }
    }

Exit:
    return iRet;
}


////////////////////////////////////////////////////////////////////////////////////
//
// SetCurrentUserLanguage
//
// This function does two things - depending on the MSI execution mode:
//
// 1. Immediate:
// This function in immediate mode will schedule the deferred and the rollback
// custom action C9D/C9R.  (C9D and C9R are the expected CA identifiers used
// in the MUI MSI package)
//
// For rollback functions it will also capture the original LCID of the 
// current user and use that as the custom action for the rollback.
//
// 2. Deferred:
// This function sets the UI language of the current users to that of the MUI
// language that is being installed.
//
// Also, reboot is needed after this CA in deferred mode, but this is specified 
// in the template itself, so the CA itself will not prompt for reboot (it can't 
// anyways, since it is deferred).
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA9(MSIHANDLE hInstall)
{
    UINT        iRet = ERROR_SUCCESS;
    TCHAR       szLanguage[5] = {0};
    TCHAR       szOrigLanguage[5] = {0};    
    TCHAR       tcMessage[BUFFER_SIZE] = {0};
    HRESULT     hr = S_OK;
    size_t      cch = 0;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }

    // get the MUI LCID that we want to set the current UI Language to.     
    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        iRet =  ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // if immediate mode (not scheduled/commit/rollback), schedule the custom actions
    if (!MsiGetMode(hInstall, MSIRUNMODE_SCHEDULED) && 
        !MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK)&& 
        !MsiGetMode(hInstall, MSIRUNMODE_COMMIT))
    {
        // get the current user UI language
        LANGID lgID = GetUserDefaultUILanguage();
        hr = StringCchPrintf(szOrigLanguage, ARRAYSIZE(szOrigLanguage), TEXT("%04x"), lgID);
        if (FAILED(hr))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9 Failure: Cannot retrieve current UI language."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // schedule the appropriate custom actions and property setting custom actions
        // Rollback custom action goes first
        // Create a rollback custom action (in case install is stopped and rolls back)
        // Rollback custom action can't read tables, so we have to set a property
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("CA9R"), szOrigLanguage))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9 Failure: Failed to set rollback custom action property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }
        if (ERROR_SUCCESS != MsiDoAction(hInstall, TEXT("CA9R")))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9 Failure: Failed to schedule rollback custom action."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // Create a deferred custom action (gives us the right priviledges to create the user account)
        // Deferred custom actions can't read tables, so we have to set a property
        if (ERROR_SUCCESS != MsiSetProperty(hInstall, TEXT("CA9D"), szLanguage))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9 Failure: Failed to set deferred custom action property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;	    
        }

        if (ERROR_SUCCESS != MsiDoAction(hInstall, TEXT("CA9D")))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9 Failure: Failed to schedule deferred custom action."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            iRet =  ERROR_INSTALL_FAILURE;
            goto Exit;
        }
    }
    else
    {
        if (FALSE == SetUILanguage(szLanguage, TRUE, FALSE, hInstall))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA9: Failed to set current UI language."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            iRet = ERROR_INSTALL_FAILURE;
        }
        else
        {
            iRet = ERROR_SUCCESS;
        }
    }
    
Exit:
    return iRet;
}    


////////////////////////////////////////////////////////////////////////////////////
//
// InstallLanguageGroup
//
// This function is called by our setup to install language group files if they are needed.
// Note, a reboot is required after installation of the langpack, however, this is
// flagged using a property by the SetLangPackRequirement function instead.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA2(MSIHANDLE hInstall)
{
    LGRPID      lgrpid[LANGGROUPNUMBER] = {0};
    UINT        iRet = ERROR_SUCCESS;
    UINT        uiLGrpNums = 0;
    UINT        i;
    TCHAR       tcMessage[BUFFER_SIZE] = {0};
    TCHAR       szLanguage[5] = {0};
    TCHAR       szMuiInfPath[MAX_PATH+1] = {0};
    TCHAR *     szUILevel = NULL;
    PMSIHANDLE  hRec = MsiCreateRecord(3);
    PMSIHANDLE  hProgressRec = MsiCreateRecord(3);
    UINT        iTemp = ERROR_SUCCESS;
    BOOL        bSilent = FALSE;
    HRESULT     hr = S_OK;
    size_t      cch = 0;
    INT         iResult = IDOK;
    
    if (NULL == hInstall)
    {
        return ERROR_INSTALL_FAILURE;
    }

    if ((NULL == hRec) || (NULL == hProgressRec))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2 Failure: cannot create a MSI record."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;
    }

    if (!GetLCID(szLanguage, ARRAYSIZE(szLanguage), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2 Failure: Cannot retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        iRet =  ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // Tell the installer to check the installation state and execute
    // the code needed during the rollback, acquisition, or
    // execution phases of the installation.
    if (MsiGetMode(hInstall,MSIRUNMODE_ROLLBACK))
    {
        // Installer is rolling back the installation. Additional code
        // could be inserted here to enable the custom action to do
        // something during an installation rollback.
        iRet = ERROR_SUCCESS;
        goto Exit;
    }

    if (!MsiGetMode(hInstall,MSIRUNMODE_SCHEDULED))
    {
        if (!GetMUIInfPath(szMuiInfPath, MAX_PATH+1, hInstall))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2 Failure: Cannot find installation temp file."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            return ERROR_INSTALL_FAILURE;
        }

        if (!ReturnAllRequiredLangGroups(szLanguage, ARRAYSIZE(szLanguage), szMuiInfPath, ARRAYSIZE(szMuiInfPath), lgrpid, &uiLGrpNums, hInstall))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: ReturnAllRequiredLangGroups function failed."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            iRet = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // uiLGrpNums should be less than 32, the size of the passed-in buffer, if it is returned as larger,
        // we truncate that number down to 32.
        if (uiLGrpNums > LANGGROUPNUMBER)
        {
            uiLGrpNums = LANGGROUPNUMBER;
        }
    
        // Installer is generating the installation script of the custom
        // action.  Tell the installer to increase the value of the final total
        // length of the progress bar by the total number of ticks in the
        // custom action.
        MsiRecordSetInteger(hRec,1,3);
        MsiRecordSetInteger(hRec,2,LANGPACK_TICK_INC * uiLGrpNums);
        MsiRecordSetInteger(hRec,3,0);
        MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hRec);
        iRet = ERROR_SUCCESS;
        goto Exit;
    }
    else
    {
        // Installer is executing the installation script. Set up a
        // record specifying appropriate templates and text for messages
        // that will inform the user about what the custom action is
        // doing. Tell the installer to use this template and text in
        // progress messages.

        // Get the CustomActionData Property that tells us whether we are going to pop up dialog for windows source or not
        // the first character is the UILevel in CustomActionData (MuiLCID UILevel)
        DWORD dwCount = 7;     // e.g. "0404 1\0" adds up to 7
        TCHAR szCustomActionData[7] = {0};
        
        if (ERROR_SUCCESS != MsiGetProperty(hInstall, TEXT("CustomActionData"), szCustomActionData, &dwCount))
        {
            // log an error
            if (SUCCEEDED(hr))
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: Failed to get CustomActionData property - assuming we are calling intl.cpl in silent mode."));    
                LogCustomActionInfo(hInstall, tcMessage);
            }
        }        
        else
        {
            // we can't validate much here, if buffer overruns, MsiGetProperty will return failure.
            hr = StringCchLength(szCustomActionData, ARRAYSIZE(szCustomActionData), &cch);
            if (FAILED(hr) || (cch >= 7))
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2 Failure: CustomActionData property value is invalid."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }    
                return ERROR_INSTALL_FAILURE;
            }
        
            szCustomActionData[4] = UNICODE_NULL;       // end of MuiLCID portion
            szCustomActionData[6] = UNICODE_NULL;       // end of UILevel portion
            szUILevel = szCustomActionData + 5;
           
#ifdef MUI_DEBUG          
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: UI Level is set to %s."), szUILevel);    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
#endif            
            if (INSTALLUILEVEL_NONE == (INSTALLUILEVEL) _tcstol(szUILevel, NULL, 10))
                bSilent = TRUE;
            else
                bSilent = FALSE;
        }

        if (!GetMUIInfPath(szMuiInfPath, MAX_PATH+1, hInstall))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2 Failure: Cannot find installation temp file."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }    
            return ERROR_INSTALL_FAILURE;
        }

        if (!ReturnAllRequiredLangGroups(szLanguage, ARRAYSIZE(szLanguage), szMuiInfPath, ARRAYSIZE(szMuiInfPath), lgrpid, &uiLGrpNums, hInstall))
        {
            // log an error
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: ReturnAllRequiredLangGroups function failed."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            iRet = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // uiLGrpNums should be less than 32, the size of the passed-in buffer, if it is returned as larger,
        // we truncate that number down to 32.
        if (uiLGrpNums > LANGGROUPNUMBER)
        {
            uiLGrpNums = LANGGROUPNUMBER;
        }

        MsiRecordSetString(hRec,1,TEXT("Install LanguageGroup."));
        MsiRecordSetString(hRec,2,TEXT("Installing language groups files ..."));
        MsiRecordSetString(hRec,3,TEXT("Installing language group [1]."));
        MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONSTART, hRec);

        // Tell the installer to use explicit progress messages.
        MsiRecordSetInteger(hRec,1,1);
        MsiRecordSetInteger(hRec,2,1);
        MsiRecordSetInteger(hRec,3,0);
        iResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hRec);
        if (iResult != IDOK)
        {
            if  (iResult == IDCANCEL)
            {
                iRet = ERROR_INSTALL_USEREXIT;
                goto Exit;
            }
        }

        // do the actual work for the custom action
        // Enumerate through all the lang groups required, check if language group already installed, if so, just return success
        // otherwise install it   
        iRet = ERROR_SUCCESS;    
        for (i = 0; i < uiLGrpNums; i++)
        {
            // display on the UI that we are installing language group lgrpid[i]
            MsiRecordSetInteger(hRec,1,lgrpid[i]);
            iResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
            if (iResult != IDOK)
            {
                if  (iResult == IDCANCEL)
                {
                    iRet = ERROR_INSTALL_USEREXIT;
                    break;
                }
            }
            
            if (!IsValidLanguageGroup(lgrpid[i], LGRPID_INSTALLED))
            {
                TCHAR pCommands[MAX_PATH] = {0};

                hr = StringCchPrintf(pCommands, ARRAYSIZE(pCommands), TEXT("LanguageGroup = %d"), lgrpid[i]);
                if (FAILED(hr))
                {
                    // log an error
                    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: Failed to install language group %d."), lgrpid[i]);    
                    if (SUCCEEDED(hr))
                    {
                        LogCustomActionInfo(hInstall, tcMessage);
                    }
                    iRet = ERROR_INSTALL_FAILURE;
                    break;                    
                }
                
                DEBUGMSGBOX(NULL, pCommands, NULL, MB_OK);                                    
                if (!RunRegionalOptionsApplet(pCommands, bSilent, hInstall))
                {
                    // log an error
                    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: Failed to install language group %d."), lgrpid[i]);    
                    if (SUCCEEDED(hr))
                    {
                        LogCustomActionInfo(hInstall, tcMessage);
                    }
                    iRet = ERROR_INSTALL_FAILURE;
                    break;
                }
            }
            if (!IsValidLanguageGroup(lgrpid[i], LGRPID_INSTALLED))
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA2: Failed to install language group %d."), lgrpid[i]);    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
                iRet = ERROR_INSTALL_FAILURE;                
                break;
            }

            // we installed the current language group, update progress bar and move onto the next one
            MsiRecordSetInteger(hProgressRec,1,2);
            MsiRecordSetInteger(hProgressRec,2,LANGPACK_TICK_INC);
            MsiRecordSetInteger(hProgressRec,3,0);
            iResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hProgressRec);
            if (iResult != IDOK)
            {
                if  (iResult == IDCANCEL)
                {
                    iRet = ERROR_INSTALL_USEREXIT;
                    break;
                }
            }
        
        }
    }

Exit:
    
    return iRet;
}


////////////////////////////////////////////////////////////////////////////////////
//
// DeleteMUIInfFile
//
// This custom action will delete the extracted mui.tmp file that we are using
// during the installation from the temporary directory.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA15(MSIHANDLE hInstall)
{
    TCHAR       tcMessage[BUFFER_SIZE] = {0};
    TCHAR       tcMUIINFPath[MAX_PATH+1] = {0};
    UINT        uiRet = ERROR_SUCCESS;
    HRESULT     hr = S_OK;
    DWORD       cbPathSize = MAX_PATH+1;
    
    // form a path to the temporary directory that we want %windir%\mui.tmp
    cbPathSize = GetSystemWindowsDirectory(tcMUIINFPath, MAX_PATH+1);
    if ((0 == cbPathSize) || (MAX_PATH+1 < cbPathSize))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA15 Failure: failed to get windows directory path."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;
    }

    if (!MUICchPathAppend(tcMUIINFPath, ARRAYSIZE(tcMUIINFPath), TEXT("mui.tmp"), 8, hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA15 Failure: failed to get installation temp file path."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;        
    }
   
    if (FileExists(tcMUIINFPath))
    {
        if (!DeleteFile(tcMUIINFPath))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA15 Failure: failed to delete installation temp file."));
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return ERROR_INSTALL_FAILURE;
        }        
    }
    else
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA15 Failure: installation temp file does not exist."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return ERROR_INSTALL_FAILURE;        
    }
    return ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////////
//
// ExtractMUIInfFile
//
// This custom action will extract mui.inf file embedded in the binary table
// of the current installation database.  It will place the extracted file
// in the %winddir% directory as mui.tmp.  This file will be referenced
// during the installation.  The tmp file will be cleaned up later in the 
// installation.
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA14(MSIHANDLE hInstall)
{
    PMSIHANDLE  hDb = NULL;
    PMSIHANDLE  hView = NULL;
    PMSIHANDLE  hRec = NULL;
    TCHAR       tcMessage[BUFFER_SIZE] = {0};
    TCHAR       tcQuery[BUFFER_SIZE] = SELECTMUIINFBINSTREAM;
    TCHAR       tcMUIINFPath[MAX_PATH+1] = {0};
    char        cBuffer[BUFFER_SIZE] = {0};
    DWORD       cbBuf = BUFFER_SIZE;
    DWORD       cbPathSize = 0;
    DWORD       dwNumWritten = 0;
    UINT        uiRet = ERROR_SUCCESS;
    HRESULT     hr = S_OK;
    HANDLE      hFile = NULL;
    UINT        uiResult = ERROR_SUCCESS;
    
    // form a path to the temporary directory that we want %windir%\mui.tmp
    cbPathSize = GetSystemWindowsDirectory(tcMUIINFPath, MAX_PATH+1);
    if ((0 == cbPathSize) || (MAX_PATH+1 < cbPathSize))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to get windows directory path."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    if (!MUICchPathAppend(tcMUIINFPath, ARRAYSIZE(tcMUIINFPath), TEXT("mui.tmp"), 8, hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to get installation temp file path."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
   
    hDb = MsiGetActiveDatabase(hInstall);
    if (NULL == hDb)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to get current installation database handle."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    uiResult = MsiDatabaseOpenView(hDb, tcQuery, &hView);
    if (ERROR_SUCCESS != uiResult)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to open current installation database."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    uiResult = MsiViewExecute(hView, 0);
    if (ERROR_SUCCESS != uiResult)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: query on current installation database failed."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    uiResult = MsiViewFetch(hView, &hRec);
    if (ERROR_SUCCESS != uiResult)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: database operation failed."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    // create our temp file
    hFile = CreateFile(tcMUIINFPath,
                       GENERIC_WRITE,
                       0L,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to create installation temporary file."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        uiRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }

    do
    {
        uiResult = MsiRecordReadStream(hRec, 1, cBuffer, &cbBuf);
        if (ERROR_SUCCESS != uiResult)
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to read data from installation database."));
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            uiRet = ERROR_INSTALL_FAILURE;
            goto Exit;
        }

        // here, we need to write the read buffer out to a file
        WriteFile(hFile,
                  cBuffer,
                  cbBuf,
                  &dwNumWritten,
                  NULL);

        if (dwNumWritten != cbBuf)
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA14: failed to write to installation temporary file."));
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            uiRet = ERROR_INSTALL_FAILURE;
            goto Exit;
        }
    } while (cbBuf == BUFFER_SIZE);

Exit:    
    if (NULL != hFile)
    {
        CloseHandle(hFile);
    }

    // delete the actual file if there is an error
    if (uiRet == ERROR_INSTALL_FAILURE)
    {
        CA15(hInstall); // DeleteMUIInfFile()
    }
    
    return uiRet;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// RestoreSystemSettings
//
// This function checks the default and current user languages, and determines whether 
// system needs to reboot when uninstallation happens (immediate).  It also clears 
// the shell registry cache (commit action)
//
////////////////////////////////////////////////////////////////////////////////////
UINT CA16(MSIHANDLE hInstall)
{
    UINT    iRet = ERROR_SUCCESS;
    UINT    iRetProp = ERROR_SUCCESS;
    TCHAR   szCustomActionData[5];    
    TCHAR   tcMessage[BUFFER_SIZE];
    TCHAR   szDefLang[5];
    DWORD   dwCount = 5;
    LANGID  langID;
    BOOL    bRestoreDefault = FALSE;
    BOOL    bRestoreCurrent = FALSE;
    LANGID  sysLangID;
    UINT    iTemp = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    // get MuiLCID
    if (!GetLCID(szCustomActionData, ARRAYSIZE(szCustomActionData), hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage),TEXT("CA16: Failed to retrieve MuiLCID property."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        iRet = ERROR_INSTALL_FAILURE;
        goto Exit;
    }
    
    szCustomActionData[4] = NULL;
    langID = (LANGID)_tcstol(szCustomActionData, NULL, 16);  
#ifdef MUI_DEBUG    
    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage),TEXT("CA16: LCID is %s."), szCustomActionData);    
    if (SUCCEEDED(hr))
    {
        LogCustomActionInfo(hInstall, tcMessage);
    }
#endif

    // check what the current ui and system ui language is, if they are the same as the current mui langauge to be uninstalled
    // then we will do some additional things during uninstallation
    if (GetDotDefaultUILanguage(hInstall) == langID)
    {
#ifdef MUI_DEBUG    
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA16: Default UI Language is the same as the MUI language being uninstalled.  Changing default UI language back to 0409 (English)."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
#endif        
        bRestoreDefault = TRUE;
    }   
    if (GetUserDefaultUILanguage() == langID)
    {
#ifdef MUI_DEBUG    
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA16: Current UI Language is the same as the MUI language being uninstalled.  Changing Current UI language back to 0409 (English)."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
#endif        
        bRestoreCurrent = TRUE;    
    }    

    if (bRestoreDefault || bRestoreCurrent)
    {        
        if (MsiGetMode(hInstall, MSIRUNMODE_COMMIT))
        {
            // we will attempt to delete the shell reg key here, but if we fail, we won't fail the installtion, just 
            // log an error
            if (ERROR_SUCCESS != SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache")))
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA16: Failed to delete registry cache."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
            }
        }
        else if (!MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK) && 
                    !MsiGetMode(hInstall, MSIRUNMODE_SCHEDULED))
        {
            // indicate to the installer that a reboot is required at the end since we changed the default/current UI.
            // again, if this fails, we just log error, and not fail the installation
            iTemp = MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE);
            if (ERROR_SUCCESS != iTemp)
            {
                // log an error
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("CA16: Failed to schedule reboot operation.  MsiSetMode returned %d as the error."), iTemp);    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
            }                           
        }
    }    
    
Exit:
    return iRet;
}


////////////////////////////////////////////////////////////////////////////////////
// Internal functions, not exported are listed below
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
//
// SetUILanguage
//
// This is the internal worker function that calls intl.cpl to set the current
// and/or default user MUI UI language.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SetUILanguage(TCHAR *szLanguage, BOOL bCurrent, BOOL bDefault, MSIHANDLE hInstall)
{
    BOOL        bRet = TRUE;
    DWORD       dwCount;
    TCHAR       szCommands[BUFFER_SIZE] = {0};
    TCHAR       tcMessage[2*BUFFER_SIZE] = {0};
    TCHAR       szBuffer[BUFFER_SIZE] = {0};
    BOOL        success;
    HRESULT     hr = S_OK;
    
    if (NULL == szLanguage)
    {
        bRet = FALSE;
        goto Exit;
    }

    // return TRUE if there is nothing to set
    if (!bCurrent && !bDefault)
    {
        bRet = TRUE;            
        goto Exit;
    }

    szCommands[0] = TEXT('\0');
    if (bCurrent)
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("MUILanguage=\"%s\"\n"), szLanguage);
        if (FAILED(hr))
        {
            bRet = FALSE;
            goto Exit;
        }
        hr = StringCchCat(szCommands, ARRAYSIZE(szCommands), szBuffer);        
        if (FAILED(hr))
        {
            bRet = FALSE;
            goto Exit;
        }
    }
    if (bDefault)
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("MUILanguage_DefaultUser=\"%s\""), szLanguage);
        if (FAILED(hr))
        {
            bRet = FALSE;
            goto Exit;
        }
        hr = StringCchCat(szCommands, ARRAYSIZE(szCommands), szBuffer);        
        if (FAILED(hr))
        {
            bRet = FALSE;
            goto Exit;
        }
    }

#ifdef MUI_DEBUG
    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("SetUILanguage: Command passed to intl.cpl is: %s"), szCommands);    
    if (SUCCEEDED(hr))
    {
        LogCustomActionInfo(hInstall, tcMessage);   
    }
#endif

    success = RunRegionalOptionsApplet(szCommands, FALSE, hInstall);
    if (success)
    {
        bRet = TRUE;
#ifdef MUI_DEBUG        
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("SetUILanguage: Successfully set default and/or current user language."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
#endif        
    }
    else
    {
        bRet = FALSE;
        // log an error
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("SetUILanguage: Failed to set default and/or current user language.\nCommand passed to regional options applet is %s."), szCommands);    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
    }

Exit:
    return bRet;    
}


////////////////////////////////////////////////////////////////////////////
// 
// NotifyKernel
//
// Call the kernel to notify it that a new language is being added or
// removed
//
////////////////////////////////////////////////////////////////////////////
void NotifyKernel(LPTSTR LangList, ULONG Flags, MSIHANDLE hInstall )
{
    HANDLE              Handle;
    WMILANGUAGECHANGE   LanguageChange;
    ULONG               ReturnSize;
    BOOL                IoctlSuccess;
    ULONG               Status;
    TCHAR               tcMessage[BUFFER_SIZE] = {0};
    HRESULT             hr = S_OK;

    if ((LangList != NULL) &&
        (*LangList != 0))
    {
        Handle = CreateFile(WMIAdminDeviceName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (Handle != INVALID_HANDLE_VALUE)
        {
            memset(&LanguageChange, 0, sizeof(LanguageChange));
            hr = StringCchCopy(LanguageChange.Language, MAX_LANGUAGE_SIZE, LangList); 	// dest buffer size taken from wmiumkm.h 
            if (FAILED(hr))
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("NotifyKernel Failure: Kernel language notification failed."));
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                } 
                goto ExitClose;
            }
            LanguageChange.Flags = Flags;

            IoctlSuccess = DeviceIoControl(Handle,
                                      IOCTL_WMI_NOTIFY_LANGUAGE_CHANGE,
                                      &LanguageChange,
                                      sizeof(LanguageChange),
                                      NULL,
                                      0,
                                      &ReturnSize,
                                      NULL);

            if (!IoctlSuccess)
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("NotifyKernel: Language change notification to %ws failed, the error is %d."), LangList, GetLastError());
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
            }
ExitClose:    
            CloseHandle(Handle);
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////
//
// MofCompileLanguage
//
////////////////////////////////////////////////////////////////////////////////////
BOOL MofCompileLanguage(LPTSTR Languages, MSIHANDLE hInstall)
{
    pfnMUI_InstallMFLFiles  pfnMUIInstall = NULL;
    TCHAR                   buffer[5] = {0};
    LPTSTR                  Language = Languages;
    TCHAR                   tcMessage[2*BUFFER_SIZE] = {0};
    HMODULE                 hWbemUpgradeDll = NULL;
    TCHAR                   szDllPath[MAX_PATH+1] = {0};
    HRESULT                 hr = S_OK;
    size_t                  cch = 0;
    BOOL                    bRet = TRUE;
    
    //
    // Load the WBEM upgrade DLL from system wbem folder
    //
    if (GetSystemDirectory(szDllPath, ARRAYSIZE(szDllPath)))
    {
        hr = StringCchLength(szDllPath, ARRAYSIZE(szDllPath), &cch);
        if (SUCCEEDED(hr))
        {
            if (!MUICchPathAppend(szDllPath, ARRAYSIZE(szDllPath), TEXT("wbem\\wbemupgd.dll"), 18, hInstall))
            {
                hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MofCompileLanguage: Failed to form path to Mof Library."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, tcMessage);
                }
                 bRet = FALSE;
                 goto Exit2;
            }
            
            DEBUGMSGBOX(NULL, szDllPath, NULL, MB_OK);                        
            hWbemUpgradeDll = LoadLibrary(szDllPath);
        }
    }

    //
    // Fall back to system default path if previous loading fails
    //
    if (!hWbemUpgradeDll)
    {
        hWbemUpgradeDll = LoadLibrary(TEXT("WBEMUPGD.DLL"));
        if (!hWbemUpgradeDll)
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MofCompileLanguage: Failed to load WBEMUPGD.DLL."));
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            bRet = FALSE;
            goto Exit2;
        }
    }

    DEBUGMSGBOX(NULL, TEXT("Loaded WBEMUPGD.DLL"), NULL, MB_OK);                    
   
    //
    // Hook function pointer
    //
    pfnMUIInstall = (pfnMUI_InstallMFLFiles)GetProcAddress(hWbemUpgradeDll, "MUI_InstallMFLFiles");

    if (pfnMUIInstall == NULL)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MofCompileLanguage: Can't get address for function MUI_InstallMFLFiles."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        bRet = FALSE;
        goto Exit;
    }

    DEBUGMSGBOX(NULL, TEXT("Loaded address for function MUI_InstallMFLFiles"), NULL, MB_OK);                        

    hr = StringCchCopy(buffer, ARRAYSIZE(buffer), Language);
    if (FAILED(hr))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MofCompileLanguage: MUI_InstallMFLFiles failed."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }   
        bRet = FALSE;
        goto Exit;
    }

    if (!pfnMUIInstall(buffer))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MofCompileLanguage: MUI_InstallMFLFiles failed - argument passed in is %s."), buffer);
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
    }

Exit:
    FreeLibrary(hWbemUpgradeDll);
Exit2:    
    return bRet;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  RunRegionalOptionsApplet
//
//  Run the Regional Option silent mode installation using the specified pCommands.
//
//  This function will create the "[RegigionalSettings]" string, so there is no need
//  to supply that in pCommands.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL RunRegionalOptionsApplet(LPTSTR pCommands, BOOL bSilent, MSIHANDLE hInstall)
{
    HANDLE              hFile;
    TCHAR               szFilePath[MAX_PATH+1] = {0};
    TCHAR               szSysDir[MAX_PATH+1] = {0};
    TCHAR               szCmdLine[BUFFER_SIZE+2*MAX_PATH+1] = {0};
    DWORD               dwNumWritten = 0L;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi = {0}; 
    TCHAR               szSection[MAX_PATH] = TEXT("[RegionalSettings]\r\n");
    TCHAR               tcMessage[BUFFER_SIZE+MAX_PATH+1] = {0};
    HRESULT             hr = S_OK;
    size_t              cch = 0;
    
    //
    // prepare the file for un-attended mode setup
    //
    szFilePath[0] = UNICODE_NULL;
    if (!GetSystemWindowsDirectory(szFilePath, MAX_PATH+1))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: GetSystemWindowsDirectory Failed - error is %d."), GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }
    hr = StringCchLength(szFilePath, ARRAYSIZE(szFilePath), &cch);
    if (SUCCEEDED(hr))
    {
        if (!MUICchPathAppend(szFilePath, ARRAYSIZE(szFilePath), MUI_LANG_GROUP_FILE, 12, hInstall))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: Failed to form path to temp control file."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return FALSE;
        }
    }
                
    DEBUGMSGBOX(NULL, szFilePath, NULL, MB_OK);                            
                
    hFile = CreateFile(szFilePath,
                       GENERIC_WRITE,
                       0L,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: failed to create temporary file %s, error is %d."), szFilePath, GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    WriteFile(hFile,
              szSection,
              (lstrlen(szSection) * sizeof(TCHAR)),
              &dwNumWritten,
              NULL);

    if (dwNumWritten != (_tcslen(szSection) * sizeof(TCHAR)))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: failed to write to temporary file %s, error is %d."), szFilePath, GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        CloseHandle(hFile);
        return FALSE;
    }

    WriteFile(hFile,
               pCommands,
              (lstrlen(pCommands) * sizeof(TCHAR)),
              &dwNumWritten,
              NULL);

    if (dwNumWritten != (_tcslen(pCommands) * sizeof(TCHAR)))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: failed to write to temporary file %s, error is %d."), szFilePath, GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        CloseHandle(hFile);
        return (FALSE);
    }

    CloseHandle(hFile);

    // form a path to the system directory's rundll32.exe
    if (ARRAYSIZE(szSysDir) < GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: Failed to form path to rundll32."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return (FALSE);        
    }

    // append rundll32.exe at the end of sysdir
    if (!MUICchPathAppend(szSysDir, ARRAYSIZE(szSysDir), TEXT("rundll32.exe"), 13, hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: Failed to form path to rundll32."));
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return (FALSE);        
    }
    
    // Call the control panel regional-options applet, and wait for it to complete
    hr = StringCchPrintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("\"%s\" shell32,Control_RunDLL intl.cpl,, /f:\"%s\" "), szSysDir, szFilePath);
    if (FAILED(hr))
    {
        DWORD dwError = HRESULT_CODE(hr);
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: Failed to form launch command for intl.cpl, error is %d."), dwError);
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return (FALSE);
    }

    if (bSilent)
    {
        hr = StringCchCat(szCmdLine, ARRAYSIZE(szCmdLine), TEXT(" /D"));
        if (FAILED(hr))
        {
            DWORD dwError = HRESULT_CODE(hr);
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: Failed to form launch command for intl.cpl, error is %d."), dwError);
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return (FALSE);
        }
    }
    
    DEBUGMSGBOX(NULL, szCmdLine, NULL, MB_OK);                            
    
    memset( &si, 0x00, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    if (!CreateProcess(NULL,
                       szCmdLine,
                       NULL,
                       NULL,
                       FALSE,
                       0L,
                       NULL,
                       NULL,
                       &si,
                       &pi))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: failed to create a process for running intl.cpl, error is %d."), GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    //
    // Wait forever till intl.cpl terminates.
    //
    WaitForSingleObject(pi.hProcess, INFINITE);
    DEBUGMSGBOX(NULL, TEXT("RunRegionalOptionApplet: intl.cpl execution is complete"), NULL, MB_OK);                            

    CloseHandle(pi.hThread);      // We have to close out hThread before we can close hProcess
    CloseHandle(pi.hProcess); 

    //
    // Delete the File, don't return false if we fail to delete the command file though
    //
    if (!DeleteFile(szFilePath))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("RunRegionalOptionsApplet: failed to delete regionaloption applet command file %s, error is %d."), szFilePath, GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
    }
    
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageGroup
//
//  Retreive the Language Group of this locale.
//
////////////////////////////////////////////////////////////////////////////////////
LGRPID GetLanguageGroup(LCID lcid, MSIHANDLE hInstall)
{
    int     i;
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    HRESULT hr = S_OK;
    
    gLangGroup = LGRPID_WESTERN_EUROPE;
    gFoundLangGroup = FALSE;
    gLCID = lcid;
    
    if (!EnumSystemLanguageGroups(EnumLanguageGroupsProc, LGRPID_SUPPORTED, 0))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLanguageGroup: EnumLanguageGroups failed, error is %d."), GetLastError());
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
    }
    
    for (i=0 ; i<gNumLanguageGroups; i++)
    {
        // The globals gLangGroup and gFoundLangGroup is used in the callback function
        // EnumLanguageGroupLocalesProc.
        if (!EnumLanguageGroupLocales(EnumLanguageGroupLocalesProc, gLanguageGroups[i], 0L, 0L))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLanguageGroup: EnumLanguageGroupLocales failed, error is %d."), GetLastError());
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
        }           
        
        //
        // If we found it, then break now
        //
        if (gFoundLangGroup)
        {
            break;
        }
    }

    return gLangGroup;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// EnumLanguageGroupsProc
//
// This function is called by EnumLanguageGroups to enumerate the system installed language groups
// and store it in the global variables for other uses
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK EnumLanguageGroupsProc(
                    LGRPID      LanguageGroup,             // language group identifier
                    LPTSTR      lpLanguageGroupString,     // pointer to language group identifier string
                    LPTSTR      lpLanguageGroupNameString, // pointer to language group name string
                    DWORD       dwFlags,                   // flags
                    LONG_PTR    lParam)                    // user-supplied parameter
{
    gLanguageGroups[gNumLanguageGroups] = LanguageGroup;
    gNumLanguageGroups++;

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// EnumLanguageGroupLocalesProc
//
// This function is called to by enumerateLanguageGroupLocales to search for an installed language
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK EnumLanguageGroupLocalesProc(
                    LGRPID      langGroupId,
                    LCID        lcid,
                    LPTSTR      lpszLocale,
                    LONG_PTR    lParam)

{
    if (lcid == gLCID)
    {
        gLangGroup = langGroupId;
        gFoundLangGroup = TRUE;
        
        DEBUGMSGBOX(NULL, TEXT("EnumLanguageGroupLocalesProc: Found same LCID"), NULL, MB_OK);                                                        

        // stop iterating
        return FALSE;
    }

    // next iteration
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
// 
// ReturnAllRequiredLangGroups
//
// This function returns all the required language groups as specified by the
// system and in extracted mui.inf in the returned array.  It also returns
// the number of required language groups in the return parameter.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ReturnAllRequiredLangGroups(LPTSTR szLanguage, UINT cchLangBufsize, LPTSTR szMuiInfPath, UINT cchPathBufsize, LGRPID *lgrpids, UINT *uiNumFoundGroups, MSIHANDLE hInstall)
{
    int         iArg;
    UINT        iRet = ERROR_SUCCESS;
    DWORD       dwCount;
    TCHAR       tcMessage[BUFFER_SIZE+MAX_PATH+1] = {0};
    INFCONTEXT  InfContext;
    int         LangGroup;
    int         iMuiInfCount = 0;
    int         i;
    HINF        hInf;
    HRESULT     hr = S_OK;
    size_t      cch = 0;
    
    if (NULL == uiNumFoundGroups)
    {
        return FALSE;
    }
    
    *uiNumFoundGroups = 0;

    if ((NULL == szLanguage) || (NULL == szMuiInfPath) || (NULL == lgrpids) || (NULL == hInstall))
    {
        return FALSE;
    }

    // check length of the passed in string
    hr = StringCchLength(szLanguage, cchLangBufsize, &cch);  
    if (SUCCEEDED(hr))
    {
        if (cch > 4)
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
    
    hr = StringCchLength(szMuiInfPath, cchPathBufsize, &cch);
    if (SUCCEEDED(hr))
    {
        if (cch > MAX_PATH)
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
    
#ifdef MUI_DEBUG
    hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ReturnAllRequiredLangGroups: MuiLCID is %s, installation temp file path is %s."), szLanguage, szMuiInfPath);    
    if (SUCCEEDED(hr))
    {
        LogCustomActionInfo(hInstall, tcMessage);
    }
#endif    

    // convert lcid to appropriate language group
    iArg = _tcstol(szLanguage, NULL, 16);
    lgrpids[0] = GetLanguageGroup(MAKELCID(iArg, SORT_DEFAULT), hInstall);
    *uiNumFoundGroups = 1;      // at this point we should have 1 lang group at least
    iMuiInfCount = 1;
    
    DEBUGMSGBOX(NULL, szMuiInfPath, NULL, MB_OK);

    hInf = SetupOpenInfFile(szMuiInfPath, NULL, INF_STYLE_WIN4, NULL);       
    if (hInf != INVALID_HANDLE_VALUE)
    {
#ifdef MUI_DEBUG        
        TCHAR szMessage[BUFFER_SIZE] = {0};
        hr = StringCchPrintf(szMessage, ARRAYSIZE(szMessage), TEXT("Language is %s."), szLanguage);
        if (SUCCEEDED(hr))
        {
            DEBUGMSGBOX(NULL, szMessage, NULL, MB_OK);
        }
#endif            
        if (SetupFindFirstLine(hInf, MUI_LANGPACK_SECTION, szLanguage, &InfContext))
        {
            DEBUGMSGBOX(NULL, TEXT("Found the LanguagePack section in installation temp file!"), NULL, MB_OK);            
            while (SetupGetIntField(&InfContext, iMuiInfCount, &LangGroup))
            {
                 lgrpids[iMuiInfCount] = LangGroup;
                 iMuiInfCount++;
#ifdef MUI_DEBUG
                hr = StringCchPrintf(szMessage, ARRAYSIZE(szMessage), TEXT("Found langgroup %d in installation temp file"), LangGroup);
                if (SUCCEEDED(hr))
                {
                    DEBUGMSGBOX(NULL, szMessage, NULL, MB_OK);                     
                }
#endif                    
            }
        }
        else
        {
#ifdef MUI_DEBUG            
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ReturnAllRequiredLangGroups: installation temp file does not contain a LanguagePack section."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
#endif                
        }
        SetupCloseInfFile(hInf);
    }
    else
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ReturnAllRequiredLangGroups: installation temp file not found at location %s.  The error is %d."), szMuiInfPath, GetLastError());    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
    }

    *uiNumFoundGroups = iMuiInfCount;

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  ExecuteComponentINF
//
//  Installs component MUI files, by running the specified INF file.
//
//  Parameters:
//      pComponentName   the name of the component (e.g. "ie5")
//      pComponentInfFile: the full path of the component INF file.
//      pInstallSection the section in the component INF file to be executed. (e.g "DefaultInstall" or "Uninstall")
//      bInstall: TRUE for install, FALSE for uninstall
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ExecuteComponentINF(
            PTSTR       pComponentName, 
            PTSTR       pComponentInfFile, 
            PTSTR       pInstallSection, 
            BOOL        bInstall, 
            MSIHANDLE   hInstall)
{
    int         iLen;
    TCHAR       tchCommandParam[MAX_PATH+6+BUFFER_SIZE] = {0};
    CHAR        chCommandParam[(MAX_PATH+6+BUFFER_SIZE)*sizeof(TCHAR)] = {0};
    TCHAR       tcMessage[2*BUFFER_SIZE+MAX_PATH+1] = {0};
    HINF        hCompInf;      // the handle to the component INF file.
    HSPFILEQ    FileQueue;
    PVOID       QueueContext;
    BOOL        bRet = TRUE;
    DWORD       dwResult;
    TCHAR       szBuffer[BUFFER_SIZE] = {0};
    HRESULT     hr = S_OK;
    
    //
    // Advpack LaunchINFSection() command line format:
    //      INF file, INF section, flags, reboot string
    // 'N' or  'n' in reboot string means no reboot message popup.
    //
    hr = StringCchPrintf(tchCommandParam, ARRAYSIZE(tchCommandParam), TEXT("%s,%s,1,n"), pComponentInfFile, pInstallSection);
    if (FAILED(hr))
    {
        DWORD dwError = HRESULT_CODE(hr);
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ExecuteComponentINF: failed to form Inf Execution command.  The returned error is %d."), dwError);    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }
    
    if (!WideCharToMultiByte(CP_ACP, 0, tchCommandParam, -1, chCommandParam, ARRAYSIZE(chCommandParam), NULL, NULL))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ExecuteComponentINF: failed to form Inf Execution command.  The returned error is %d."), GetLastError());    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;    
    }
        
    if (FileExists(pComponentInfFile))
    {
        if (LaunchINFSection(NULL, NULL, chCommandParam, SW_HIDE) != S_OK)
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ExecuteComponentINF: LaunchINFSection failed for inf file %s, component name %s."), pComponentInfFile, pComponentName);    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return FALSE;
        }
    } 
    else
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("ExecuteComponentINF: Failed to locate inf file %s."), pComponentInfFile);    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);    
        }
        return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
// InstallComponentsMUIFiles
//
// Parameters:
//      pszLangSourceDir The sub-directory name for a specific lanuage in the MUI CD-ROM.  
//          E.g. "jpn.MUI"
//      pszLanguage     The LCID for the specific language.  E.g. "0404".
//      isInstall   TRUE if you are going to install the MUI files for the component.  FALSE 
//          if you are going to uninstall.
//
//  Return:
//      -1 if failed, IDOK if succeeded, IDCANCEL if user clicked cancel during the operation
//
//  Note:
//      For the language resources stored in pszLangSourceDir, this function will enumerate 
//      the compoents listed in the [Components] 
//      (the real section is put in MUI_COMPONENTS_SECTION) section, and execute the INF file 
//      listed in every entry in 
//      the [Components] section.
//
////////////////////////////////////////////////////////////////////////////////////
INT InstallComponentsMUIFiles(PTSTR pszLanguage, BOOL isInstall, MSIHANDLE hInstall)
{
    BOOL        result = TRUE;
    BOOL        bRollback = FALSE;
    BOOL        bOEMSystem = FALSE;
    TCHAR       szComponentName[BUFFER_SIZE] = {0};
    TCHAR       CompDir[MAX_PATH+1] = {0};
    TCHAR       szWinDir[MAX_PATH+1] = {0};
    TCHAR       CompINFFile[BUFFER_SIZE] = {0};
    TCHAR       CompInstallSection[BUFFER_SIZE] = {0};
    TCHAR       CompUninstallSection[BUFFER_SIZE] = {0};
    TCHAR       szMuiInfPath[MAX_PATH+1] = {0};
    TCHAR       szBuffer[3*BUFFER_SIZE+MAX_PATH+1] = {0};
    TCHAR       szCompInfFullPath[MAX_PATH+1] = {0};   
    TCHAR       szCompInfAltFullPath[MAX_PATH+1] = {0};       
    INFCONTEXT  InfContext;
    PMSIHANDLE  hRec = MsiCreateRecord(3);
    PMSIHANDLE  hProgressRec = MsiCreateRecord(3);
    HRESULT     hr = S_OK;
    INT         iResult = IDOK;
    INT         iFlag = 0;

    if ((NULL == hRec) || (NULL == hProgressRec))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: cannot create MSI Records."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        return -1;
    }

    bRollback = MsiGetMode(hInstall,MSIRUNMODE_ROLLBACK);
    
    // get path to the target installation temp file file on the target, it should be at WindowsFolder\mui.tmp
    szMuiInfPath[0] = UNICODE_NULL;
    if (!GetMUIInfPath(szMuiInfPath, MAX_PATH+1, hInstall))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Unable to find installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        return -1;
    }

    // also get the windows dir, for later use
    if (!GetSystemWindowsDirectory(szWinDir, MAX_PATH+1))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: cannot get Windows Directory."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        return -1;
    }
    
    HINF hInf = SetupOpenInfFile(szMuiInfPath, NULL, INF_STYLE_WIN4, NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Unable to open installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        return -1;
    } 

    //Check if its an OEM system
    bOEMSystem = IsOEMSystem();

    //
    // Get the first component to be installed.
    //
    if (SetupFindFirstLine(hInf, MUI_COMPONENTS_SECTION, NULL, &InfContext))
    {
        do 
        {
            if (SetupGetIntField(&InfContext, 5,&iFlag)) //Check the last field of the component to see if its an OEM component.  If OEM component iIsOEM = 1
            {
                if ((iFlag == OEM_COMPONENT) && !bOEMSystem) //Skip installation if its an OEM component and this isnt an OEM system
                    continue;
            }
            
            if (!SetupGetStringField(&InfContext, 0, szComponentName, ARRAYSIZE(szComponentName), NULL))
            {
                // continue on the next line - but remember to log an error        
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Error reading installation temp file, component name is missing."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;
            }
            
            // tell the installer UI that we are installing a new component now
            if (!bRollback)
            {
                MsiRecordSetString(hRec,1, szComponentName);
                iResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);
                if (iResult == IDCANCEL)
                {
                    SetupCloseInfFile(hInf);
                    return iResult;
                }
            }        
            
            if (!SetupGetStringField(&InfContext, 1, CompDir, ARRAYSIZE(CompDir), NULL))
            {                
                // continue on the next line - but remember to log an error        
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: MUI files for component %s was not installed because of missing component direcotry."), szComponentName);    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;        
            }
            if (!SetupGetStringField(&InfContext, 2, CompINFFile, ARRAYSIZE(CompINFFile), NULL))
            {
                // continue on the next line - but remember to log an error        
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: MUI files for component %s was not installed because of missing component INF filename."), szComponentName);    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;        
            }
            
            if (isInstall && (!SetupGetStringField(&InfContext, 3, CompInstallSection, ARRAYSIZE(CompInstallSection), NULL)))
            {
                hr = StringCchCopy(CompInstallSection, ARRAYSIZE(CompInstallSection), DEFAULT_INSTALL_SECTION);
                if (FAILED(hr))
                {
                    hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Cannot locate Default Install section for component %s."), szComponentName);    
                    if (SUCCEEDED(hr))
                    {
                        LogCustomActionInfo(hInstall, szBuffer);
                    }
                    continue;        
                }
            }
            if (!isInstall && (!SetupGetStringField(&InfContext, 4, CompUninstallSection, ARRAYSIZE(CompUninstallSection), NULL)))
            {
                hr = StringCchCopy(CompUninstallSection, ARRAYSIZE(CompUninstallSection), DEFAULT_UNINSTALL_SECTION);
                if (FAILED(hr))
                {
                    hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Cannot locate Default Uninnstall section for component %s."), szComponentName);    
                    if (SUCCEEDED(hr))
                    {
                        LogCustomActionInfo(hInstall, szBuffer);
                    }
                    continue;        
                }
            }

            //
            // Establish the correct path for component INF file.
            // We execute the INFs on the target MUI directory after msi has copied the files, it's installed to MUIroot\fallback\LCID\external\componentdir\
            // e.g. c:\windows\mui\fallback\lcid\external\ie5\ie5ui.inf
            // This is done for both install and uninstall, since we should be guaranteed that the files will be located there.
            // NOTE: for uninstall, we also try to look for inf files at c:\windows\mui\fallback\lcid - since they can be located there after installation
            //
            hr = StringCchCopy(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath), szWinDir);
            if (SUCCEEDED(hr))
            {
                if (!((MUICchPathAppend(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath), FALLBACKDIR, 13, hInstall)) &&
                        (MUICchPathAppend(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath), pszLanguage, 5, hInstall)) &&
                        (MUICchPathAppend(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath), EXTDIR, 9, hInstall)) &&
                        (MUICchPathAppend(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath), CompDir, ARRAYSIZE(CompDir), hInstall)) &&
                        (MUICchPathAppend(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath), CompINFFile, ARRAYSIZE(CompINFFile), hInstall))))
                    {
                        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Cannot form path to external component INF."));    
                        if (SUCCEEDED(hr))
                        {
                            LogCustomActionInfo(hInstall, szBuffer);
                        }
                        continue;                                            
                    }
            }            
            else
            {
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Cannot form path to external component INF."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;                    
            }
           
            if (isInstall)
            {
                if (!ExecuteComponentINF(szComponentName, szCompInfFullPath, CompInstallSection, TRUE, hInstall))
                {           
                    // log an error and continue
                    hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Failed to install external component %s.  INF path is %s, INF installsection is %s."), szComponentName, szCompInfFullPath, CompInstallSection);    
                    if (SUCCEEDED(hr))
                    {
                        LogCustomActionInfo(hInstall, szBuffer);
                    }
                    continue;
                }       
            } 
            else
            {
                if (!ExecuteComponentINF(szComponentName, szCompInfFullPath, CompUninstallSection, FALSE, hInstall) && result)	
                {
                    // try this again at an alternate location
                    hr = StringCchCopy(szCompInfAltFullPath, ARRAYSIZE(szCompInfAltFullPath), szWinDir);
                    if (SUCCEEDED(hr))
                    {
                        if (!((MUICchPathAppend(szCompInfAltFullPath, ARRAYSIZE(szCompInfAltFullPath), FALLBACKDIR, 13, hInstall)) &&
                                (MUICchPathAppend(szCompInfAltFullPath, ARRAYSIZE(szCompInfAltFullPath), pszLanguage, 5, hInstall)) &&
                                (MUICchPathAppend(szCompInfAltFullPath, ARRAYSIZE(szCompInfAltFullPath), CompINFFile, ARRAYSIZE(CompINFFile), hInstall))))
                            {
                                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Cannot form path to alternate external component INF."));    
                                if (SUCCEEDED(hr))
                                {
                                    LogCustomActionInfo(hInstall, szBuffer);
                                }
                                continue;                                            
                            }
                    }            
                    else
                    {
                        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Cannot form path to alternate external component INF."));    
                        if (SUCCEEDED(hr))
                        {
                            LogCustomActionInfo(hInstall, szBuffer);
                        }
                        continue;                    
                    }
                    if (!ExecuteComponentINF(szComponentName, szCompInfAltFullPath, CompUninstallSection, FALSE, hInstall) && result)
                    {
                        // log an error and continue
                        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("InstallComponentInfs Failure: Failed to uninstall external component %s.  INF path is %s, Alternate INF path is %s, INF uninstallsection is %s."), szComponentName, szCompInfFullPath, szCompInfAltFullPath, CompUninstallSection);    
                        if (SUCCEEDED(hr))
                        {
                            LogCustomActionInfo(hInstall, szBuffer);
                        }
                        continue;
                    }
                } 
            }
            
            // Specify that an update of the progress bar's position in this
            // case means to move it forward by one increment now that we have installed it.
            if (!bRollback)
            {
                MsiRecordSetInteger(hProgressRec,1,2);
                MsiRecordSetInteger(hProgressRec,2,COMP_TICK_INC);
                MsiRecordSetInteger(hProgressRec,3,0);
                iResult = MsiProcessMessage(hInstall, INSTALLMESSAGE_PROGRESS, hProgressRec);
                if (iResult == IDCANCEL)
                {
                    SetupCloseInfFile(hInf);
                    return iResult;
                }
            }
            //
            // Install the next component.
            //
        } while (SetupFindNextLine(&InfContext, &InfContext));

    }

    SetupCloseInfFile(hInf);

    return (IDOK);
}


////////////////////////////////////////////////////////////////////////////////////
//
// GetMUIComponentsNumber
//
// Parameters:
//      bInstall  indicate whether this function is used for installing component infs or not
//                  this affects where it will look for mui.inf to get the component count.
//      pszLangSourceDir The sub-directory name for a specific lanuage in the MUI CD-ROM.  
//          E.g. "jpn.MUI"
//      pszLanguage     The LCID for the specific language.  E.g. "0404".
//
//  Return:
//      The number of MUI external components that need to be installed/uninstalled, if
//      there is an error it will return 0, otherwise it returns the number of components
//
//  Note:
//      For the language resources stored in pszLangSourceDir, this function will enumerate 
//      the compoents listed in the [Components] 
//      (the real section is put in MUI_COMPONENTS_SECTION) section, and counts every entry in 
//      the [Components] section.
//
////////////////////////////////////////////////////////////////////////////////////
UINT GetMUIComponentsNumber(PTSTR pszLanguage, MSIHANDLE hInstall)
{
    UINT        iResult = 0;
    TCHAR       szComponentName[BUFFER_SIZE] = {0};
    TCHAR       CompDir[MAX_PATH+1] = {0};
    TCHAR       CompINFFile[BUFFER_SIZE] = {0};
    TCHAR       szMuiInfPath[MAX_PATH+1] = {0};
    TCHAR       szBuffer[BUFFER_SIZE] = {0};
    INFCONTEXT  InfContext;
    HRESULT     hr = S_OK;
    
    szMuiInfPath[0] = UNICODE_NULL;   
    
    // get path to the target mui.inf file 
    if (!GetMUIInfPath(szMuiInfPath, MAX_PATH+1, hInstall))
    {
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("GetMUIComponentsNumber Failure: Unable to find installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        return 0;		
    }
    
    HINF hInf = SetupOpenInfFile(szMuiInfPath, NULL, INF_STYLE_WIN4, NULL);

    if (hInf == INVALID_HANDLE_VALUE)
    {
        // return true here so that there won't be an error - but remember to log an error        
        hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("GetMUIComponentsNumber: Unable to open installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, szBuffer);
        }
        return (iResult);
    }    

    // Get the first comopnent to be installed.
    if (SetupFindFirstLine(hInf, MUI_COMPONENTS_SECTION, NULL, &InfContext))
    {
        do 
        {
            if (!SetupGetStringField(&InfContext, 0, szComponentName, ARRAYSIZE(szComponentName), NULL))
            {
                // return true here so that there won't be an error - but remember to log an error        
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("GetMUIComponentsNumber: Error reading installation temp file, component name is missing."));    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;
            }
            
            if (!SetupGetStringField(&InfContext, 1, CompDir, ARRAYSIZE(CompDir), NULL))
            {                
                // return true here so that there won't be an error - but remember to log an error        
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("GetMUIComponentsNumber: MUI files for component %s was not counted because of missing component direcotry."), szComponentName);    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;        
            }
            if (!SetupGetStringField(&InfContext, 2, CompINFFile, ARRAYSIZE(CompINFFile), NULL))
            {
                // return true here so that there won't be an error - but remember to log an error        
                hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("GetMUIComponentsNumber: MUI files for component %s was not counted  because of missing component INF filename."), szComponentName);    
                if (SUCCEEDED(hr))
                {
                    LogCustomActionInfo(hInstall, szBuffer);
                }
                continue;        
            }
            
            iResult++;
            
        } while (SetupFindNextLine(&InfContext, &InfContext));

    }

    SetupCloseInfFile(hInf);

#ifdef MUI_DEBUG
    hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("GetMUIComponentsNumber: Found %d components to install."), iResult);    
    if (SUCCEEDED(hr))
    {
        LogCustomActionInfo(hInstall, szBuffer);
    }
#endif

    return (iResult);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  File Exists
//
//  Returns TRUE if the file exists, FALSE if it does not.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL FileExists(LPTSTR szFile)
{
    HANDLE          hFile;
    WIN32_FIND_DATA FindFileData;
    HRESULT         hr = S_OK;
    size_t          cch = 0;

    if (NULL == szFile)
    {
        return FALSE;
    }
    
    // check for valid input, the path cannot be larger than MAX_PATH+1
    hr = StringCchLength(szFile, MAX_PATH+1, &cch);
    if (FAILED(hr) || cch > MAX_PATH)
    {
        return FALSE;
    }

    hFile = FindFirstFile(szFile, &FindFileData);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    FindClose(hFile);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
// LogCustomActionInfo
//
// This function sends an INFORMATION-type log message record to the opened
// windows installer session so that it can be logged by the installer
// if logging is enabled.
//
////////////////////////////////////////////////////////////////////////////////////
void LogCustomActionInfo(MSIHANDLE hInstall, LPCTSTR szErrorMsg)
{
    // When reporting error, we will just put the message in the format string (field 0), errors are logged to log files as INFO messages.  This is
    // to prevent it from showing up as an error and stopping the installation.
    PMSIHANDLE hRecord = MsiCreateRecord(0);	

    // if can't create a msi record, just return
    if ((NULL == hInstall) || (NULL == szErrorMsg) || (NULL == hRecord))
    {
        return;
    }

    if (ERROR_SUCCESS == MsiRecordSetString(hRecord, 0, szErrorMsg))
    {
        MsiProcessMessage(hInstall, INSTALLMESSAGE_INFO, hRecord);
    }
}

////////////////////////////////////////////////////////////////////////////////////
//
// GetLCID
//
// This function returns the 4-character LCID for the current installation package.
// We assume here that the passed in string array size is 5 TCHARs.  If it is not,
// the function will fail.
//
// The behaviour is summarized as follows:
//
// 1. Immediate:
//      a. Property "MuiLCID" is retrieved and tested from the current installation
//      b. if LCID property can't be retrieved, returns FALSE.
//
// 2. Deferred/Rollback:
//      a. Property "CustomActionData" is retrieved.
//      b. Assumption is that LCID will be the first 4 character in the retrieved CustomActionData property.
//      c. If property can't be retrieved, or if property testing fails, return FALSE.
//
//  Parameters:
//      szLanguage: This is a caller-allocated buffer of 5 TCHARS to store the LCID
//      cchBufSize: This is the size of szLanguage, it has to be 5.
//      hInstall: Current installation handle.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetLCID(TCHAR *szLanguage, UINT cchBufSize, MSIHANDLE hInstall)
{
    HRESULT     hr = S_OK;
    TCHAR       szLcid[5] = {0};
    TCHAR       szCustomActionData[BUFFER_SIZE] = {0};
    TCHAR       tcMessage[BUFFER_SIZE] = {0};
    DWORD       dwCount = 0;
        
    if ((NULL == hInstall) || (NULL == szLanguage))
    {
#ifdef MUI_DEBUG    
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLCID: Internal error 1."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
#endif        
        return FALSE;        
    }

    if (cchBufSize != 5)
    {
#ifdef MUI_DEBUG    
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLCID: Internal error 2."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
#endif        
        return FALSE;
    }

    if (!MsiGetMode(hInstall, MSIRUNMODE_SCHEDULED) && 
        !MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK)&& 
        !MsiGetMode(hInstall, MSIRUNMODE_COMMIT))
    {
        dwCount = 5;
        if (ERROR_SUCCESS != MsiGetProperty(hInstall, TEXT("MuiLCID"), szLcid, &dwCount))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLCID: Failed to retrieve MuiLCID property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return FALSE;
        }

        // copy the Lcid to the output buffer
        szLcid[4] = UNICODE_NULL;
        hr = StringCchCopy(szLanguage, cchBufSize, szLcid);
        if (FAILED(hr))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLCID: Failed to retrieve MuiLCID property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return FALSE;
        }
    }
    else
    {
        dwCount = BUFFER_SIZE;
        if (ERROR_SUCCESS != MsiGetProperty(hInstall, TEXT("CustomActionData"), szCustomActionData, &dwCount))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLCID: Failed to retrieve CustomActionData property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return FALSE;
        }
        // copy the Lcid to the output buffer
        szCustomActionData[4] = UNICODE_NULL;
        hr = StringCchCopy(szLanguage, cchBufSize, szCustomActionData);
        if (FAILED(hr))
        {
            hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetLCID: Failed to retrieve CustomActionData property."));    
            if (SUCCEEDED(hr))
            {
                LogCustomActionInfo(hInstall, tcMessage);
            }
            return FALSE;
        }
    }

    szLanguage[4] = UNICODE_NULL;        
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  GetMUIInfPath
//
//  This function returns the path to mui.inf to the calling function.  This function 
//  is intended for use only by the exported functions of the custom action functions 
//  in this dll.  
//
//  Note that mui.inf is extracted to %windir% as mui.tmp during the installation
//
//  The function expects the mui.tmp to be at %windir%\mui.tmp.  
//
//  Return Value:
//      If the function successfully finds a file named mui.inf, it returns TRUE, otherwise it returns FALSE
//      The full path to mui.inf is returned in the caller supplied buffer szMUIInfPath
//
//  Parameters:
//      szMUIInfPath - 
//          [out] This is the output buffer that will contain the path of the mui.tmp.
//      cchBufSize -
//          This indicates the size of the input/output buffer the caller allocated for us, it should be no longer
//          than MAX_PATH+1 (validated in the function.
//      hInstall -
//          This is the handle passed to us from the windows installer - it is a handle to the current installation
//  
////////////////////////////////////////////////////////////////////////////////////
BOOL GetMUIInfPath(TCHAR *szMUIInfPath, UINT cchBufSize, MSIHANDLE hInstall)
{
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    TCHAR   szTempPath[MAX_PATH+1] = {0};
    HRESULT hr = S_OK;
    size_t  cch = 0;
    DWORD   dwCount = 0;
    
    if ((NULL == hInstall) || (NULL == szMUIInfPath))
    {
        return FALSE;
    }

    if ((cchBufSize > MAX_PATH+1) || (cchBufSize <= 8))   // 8 = mui.tmp + null terminator
    {
        return FALSE;
    }
    
    if (!GetSystemWindowsDirectory(szTempPath, MAX_PATH+1))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetMUIInfPath: Unable to find the Windows directory, GetSystemWindowsDirectory returned %d."), GetLastError());    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
    }

    // check retrieved winpath, it needs to have space to append "mui.tmp" at the end
    hr = StringCchLength(szTempPath, ARRAYSIZE(szTempPath), &cch);
    if (FAILED(hr) || ((cch + 8) >= MAX_PATH+1))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetMUIInfPath: cannot locate installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    // append mui.tmp
    if (!MUICchPathAppend(szTempPath, ARRAYSIZE(szTempPath), TEXT("mui.tmp"), 8, hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetMUIInfPath: cannot locate installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }            

    // check if mui.tmp is there, if not, return failure
    if (!FileExists(szTempPath))
    {
        // zero out the output buffer
        ZeroMemory(szMUIInfPath, cchBufSize * sizeof(TCHAR));
        return FALSE;
    }

    // copy result to output buffer
    hr = StringCchCopy(szMUIInfPath, cchBufSize, szTempPath);
    if (FAILED(hr))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("GetMUIInfPath: cannot locate installation temp file."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
// MUICchPathAppend 
//
// This function is a simple pathappend-like function that does limited parameter checking and uses the 
// safe string functions internally.  It is used only internally within this custom action to append
// file names to the end of a path (such as current directory or windows system directory)
//
// If error occurs, the content of SzDestination is undefined and should not be used.
//
// Parameters:
//      szDestination: the buffer where the result of the pathappend will be held.
//      cchDestBufSize: the size of szDestination (number of characters, not byes!).
//      szAppend: the buffer where the path to be appended is held.
//      cchAppBufSize: the size of szAppend (number of characters, not byes!).
//      hInstall: windows installer session, used for logging only
//
////////////////////////////////////////////////////////////////////////////////////
BOOL MUICchPathAppend(LPTSTR szDestination, UINT cchDestBufSize, LPTSTR szAppend, UINT cchAppBufSize, MSIHANDLE hInstall)
{
    size_t  cch1 = 0;
    size_t  cch2 = 0;
    HRESULT hr = S_OK;
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    
    if ((NULL == szDestination) || (NULL == szAppend) || (NULL == hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICchPathAppend: Invalid paths specified or invalid windows installer session."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return FALSE;
    }

    // get length of both strings
    hr = StringCchLength(szDestination, cchDestBufSize, &cch1);
    if (FAILED(hr))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICchPathAppend: Invalid destination path specified."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return FALSE;
    }
    
    hr = StringCchLength(szAppend, cchAppBufSize, &cch2);
    if (FAILED(hr))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICchPathAppend: Invalid source path specified."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return FALSE;
    }

    if ((cch1 + cch2 + 2) > cchDestBufSize) // null terminator and a possible backslash
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICchPathAppend: final path would be too long."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return FALSE;
    }

    // check for slashes at the start of the string that we are appending
    if (szAppend[0] == TEXT('\\'))
    {
        // check for slashes at the end of the string to be appended, add if it is there, remove it
        if (szDestination[cch1-1] == TEXT('\\'))
        {
            szDestination[cch1-1] = UNICODE_NULL;
        }
    }
    else
    {
        // check for slashes at the end of the string to be appended, add it if it is not there
        if (szDestination[cch1-1] != TEXT('\\'))
        {
            szDestination[cch1] = TEXT('\\');
            szDestination[cch1+1] = UNICODE_NULL;
        }
    }
    
    hr = StringCchCat(szDestination, cchDestBufSize, szAppend);
    if (FAILED(hr))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICchPathAppend: Failed to form new path."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }    
        return FALSE;
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
// MUIReportInfoEvent
//
// This function logs the supplied event message to the system event log
//
////////////////////////////////////////////////////////////////////////////////////
BOOL MUIReportInfoEvent(DWORD dwEventID, TCHAR *szLanguage, UINT cchBufSize, MSIHANDLE hInstall)
{
    HRESULT         hr = S_OK;
    size_t          cch = 0;
    HANDLE          hLog = NULL;
    TCHAR           szUserName[UNLEN+1];
    TCHAR           *pszDomain = NULL;
    PSID            psidUser = NULL;
    DWORD           cbSid = 0;
    DWORD           cbDomain = 0;
    DWORD           cbUser = UNLEN + 1;
    SID_NAME_USE    snu;
    BOOL            bResult = TRUE;
    
    // check input parameters
    if ((NULL == hInstall) || (NULL == szLanguage) || (cchBufSize > BUFFER_SIZE))
    {
        bResult = FALSE;
        goto Exit;
    }

    hr = StringCchLength(szLanguage, cchBufSize, &cch);
    if (FAILED(hr))
    {
        bResult = FALSE;
        goto Exit;
    }

    // check to see if the registry key exists for the event source we are going to use
    // if it does not exist, we create it
    if (!MUICheckEventSource(hInstall))
    {
        bResult = FALSE;
        goto Exit;
    }
    
    // register the event source, first try not having written to the registry
    hLog = RegisterEventSource(NULL, REGOPT_EVENTSOURCE_NAME);
    if (NULL == hLog)
    {
        bResult = FALSE;
        goto Exit;
    }

    // get the sid from the current thread token, this should be the current user who's
    // running the installation
    if (!GetUserName(szUserName, &cbUser))
    {
        bResult = FALSE;
        goto Exit;
    }

    // convert user name to its security identifier, first time to get buffer size, second time
    // to actually get the Sid
    if (!LookupAccountName(NULL, szUserName, NULL, &cbSid, NULL, &cbDomain, &snu))
    {
        // allocate the buffers
        psidUser = (PSID) LocalAlloc(LPTR, cbSid);
        if (NULL == psidUser)
        {
            bResult = FALSE;
            goto Exit;
        }
        
        pszDomain = (TCHAR*) LocalAlloc(LPTR, cbDomain * sizeof(TCHAR));
        if (NULL == pszDomain)
        {
            bResult = FALSE;
            goto Exit;
        }
        
        if (!LookupAccountName(NULL, szUserName, psidUser, &cbSid, pszDomain, &cbDomain, &snu))
        {
            bResult = FALSE;
            goto Exit;
        }
    }

    if (!ReportEvent(hLog,           
                EVENTLOG_INFORMATION_TYPE,
                0,                  
                dwEventID,      
                psidUser,
                1,                  
                0,                  
                (LPCWSTR *) &szLanguage,              
                NULL))
        {
            bResult = FALSE;
            goto Exit;
        }
 

Exit:
    if (NULL != hLog)
    {
        if (!DeregisterEventSource(hLog))
        {
            bResult = FALSE;
        }
    }

    if (psidUser)
    {
        if (LocalFree(psidUser))
        {
            bResult = FALSE;
        }
    }

    if (pszDomain)
    {
        if (LocalFree(pszDomain))
        {
            bResult = FALSE;
        }
    }
    
    return bResult;
}


////////////////////////////////////////////////////////////////////////////////////
//
// MUICheckEventSource
//
// This function verifies that the intl.cpl is set up to report events, and
// returns TRUE if it is.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL MUICheckEventSource(MSIHANDLE hInstall)
{
    HKEY    hk; 
    DWORD   dwData; 
    TCHAR   tcMessage[BUFFER_SIZE] = {0};
    TCHAR   szPath[MAX_PATH+1] = {0};
    HRESULT hr = S_OK;
    size_t  cch = 0;
    size_t  cb = 0;
    
    if (!GetSystemWindowsDirectory(szPath, MAX_PATH+1))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: Unable to find the Windows directory, GetSystemWindowsDirectory returned %d."), GetLastError());    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    // check retrieved winpath, it needs to have space to append "system32\intl.cpl" at the end
    hr = StringCchLength(szPath,  ARRAYSIZE(szPath), &cch);
    if (FAILED(hr) || ((cch + 17) >= MAX_PATH+1))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: cannot find system windows path."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    // append system32\intl.cpl
    if (!MUICchPathAppend(szPath, ARRAYSIZE(szPath), TEXT("system32\\intl.cpl"), 18, hInstall))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: cannot form path to muisetup.exe."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }            

    // get the byte count for RegSetValueEx
    hr = StringCbLength(szPath, MAX_PATH+1 * sizeof(TCHAR), &cb);
    if (FAILED(hr))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: cannot form path to muisetup.exe."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    // Add intl.cpl source name as a subkey under the System
    // key in the EventLog registry key.  This should be there already, but add it anyways if it is not.
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGOPT_EVENTSOURCE, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hk, NULL)) 
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: cannot add Intl.cpl event source regkey."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        return FALSE;
    }

    // Add the name to the EventMessageFile subkey. 
    if (ERROR_SUCCESS != RegSetValueEx(hk, TEXT("EventMessageFile"), 0, REG_EXPAND_SZ, (LPBYTE) szPath, cb))              
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: cannot add event source Event message file information."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        RegCloseKey(hk);
        return FALSE;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE; 
 
    if (ERROR_SUCCESS != RegSetValueEx(hk, TEXT("TypesSupported"), 0, REG_DWORD, (LPBYTE) &dwData, sizeof(DWORD)))
    {
        hr = StringCchPrintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MUICheckEventSource: cannot add event source TypeSupported information."));    
        if (SUCCEEDED(hr))
        {
            LogCustomActionInfo(hInstall, tcMessage);
        }
        RegCloseKey(hk);
        return FALSE;
    }
 
    RegCloseKey(hk);
    return TRUE;
} 


////////////////////////////////////////////////////////////////////////////////////
//
// GetDotDefaultUILanguage
//
// Retrieve the UI language stored in the HKCU\.Default.
// This is the default UI language for new users.
// This function sends an INFORMATION-type log message record to the opened
// windows installer session so that it can be logged by the installer
// if logging is enabled.
//
////////////////////////////////////////////////////////////////////////////////////
LANGID GetDotDefaultUILanguage(MSIHANDLE hInstall)
{
    HKEY    hKey;
    DWORD   dwKeyType;
    DWORD   dwSize;
    BOOL    success = FALSE;
    TCHAR   szBuffer[BUFFER_SIZE] = {0};
    LANGID  langID;

    //  Get the value in .DEFAULT.
    if (RegOpenKeyEx( HKEY_USERS,
                            TEXT(".DEFAULT\\Control Panel\\Desktop"),
                            0L,
                            KEY_READ,
                            &hKey ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szBuffer);
        if (RegQueryValueEx( hKey,
                            TEXT("MultiUILanguageId"),
                            0L,
                            &dwKeyType,
                            (LPBYTE)szBuffer,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwKeyType == REG_SZ)
            {
                langID = (LANGID)_tcstol(szBuffer, NULL, 16);
                success = TRUE;
            }            
        }
        RegCloseKey(hKey);
    }

    if (!success)
    {
        langID = GetSystemDefaultUILanguage();
    }
    
    return (langID);    
}

////////////////////////////////////////////////////////////////////////////////////
//
// IsOEMSystem
//
// Retrieve the Product ID stored in HKLM\Software\Microsoft\Windows NT\CurrentVersion
// If the product ID contains the string "OEM", it is determined to be an OEM system.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL IsOEMSystem()
{
    HKEY    hKey;
    DWORD   dwKeyType;
    DWORD   dwSize;
    BOOL    bRet = FALSE;
    TCHAR   szBuffer[BUFFER_SIZE] = {0};
    TCHAR   szOEM[] = TEXT("OEM");
    
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion"),
                            0L,
                            KEY_READ,
                            &hKey ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szBuffer);
        if (RegQueryValueEx( hKey,
                            TEXT("ProductId"),
                            0L,
                            &dwKeyType,
                            (LPBYTE)szBuffer,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwKeyType == REG_SZ)
            {
                if (StrStrI((LPCTSTR)szBuffer, (LPCTSTR)szOEM) != NULL)
                {
                    bRet = TRUE;
                }
            }            
        }
        RegCloseKey(hKey);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\cmf.cpp ===
/*****************************************************************************
    
  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.

  Module Name:

   cmf.cpp

  Abstract:

    The implementation of CCompactMUIFile, CMUIFile

  Revision History:

    2001-11-01    sunggch    created.

Revision.

*******************************************************************************/



#include "muirct.h"
#include "res.h"
#include "cmf.h"


#define  DWORD_ALIGNMENT(dwValue)  ( (dwValue+3) & ~3 )

#define    TEMP_BUFFER       300
#define    MUI_COMPACT       L"CMF"


///////////////////////////////////////////////////////////////////////////////////////////
//
//  CCompactMUIFile Implementation
//
///////////////////////////////////////////////////////////////////////////////////////////

CCompactMUIFile::CCompactMUIFile()
{
    m_upCMFHeader.dwSignature = 0x1a1b;
    m_upCMFHeader.dwHeaderSize = sizeof(UP_COMPACT_MUI_RESOURCE);
    m_upCMFHeader.dwNumberofMui = 0;
    
    m_pcmui = new CMUIFile;
    if(!m_pcmui)
    	return;

    m_strFileName = new TCHAR[MAX_FILENAME_LENGTH];
    if(!m_strFileName)
    	return;
    
    m_dwFileSize = m_upCMFHeader.dwHeaderSize;

}

CCompactMUIFile::CCompactMUIFile( CCompactMUIFile & ccmf)
{
    m_hCMFFile = ccmf.m_hCMFFile;
    m_upCMFHeader = ccmf.m_upCMFHeader;
    m_pcmui = ccmf.m_pcmui;
    m_strFileName = ccmf.m_strFileName;
    
}

CCompactMUIFile::~CCompactMUIFile()
{
    if (m_strFileName)
        delete []m_strFileName;

    if (m_pcmui)
        delete m_pcmui;
}

CCompactMUIFile & CCompactMUIFile::operator= (CCompactMUIFile & ccmf)
{
    if(&ccmf == this)
        return *this;
    
    m_upCMFHeader = ccmf.m_upCMFHeader;
    m_pcmui = ccmf.m_pcmui;
    m_strFileName = ccmf.m_strFileName;
    return *this;

}


BOOL CCompactMUIFile::Create (LPCTSTR pszCMFFileName, PSTR * ppszMuiFiles, DWORD dwNumOfMUIFiles )
/*++
Abstract:
     this is main creation part of CMF Files, we simply call CMUIFile::Create with each indivisual
     mui file into specified CMF file.

Arguments:
    pszCMFFileName  -  CMF file name
    ppszMuiFiles  -  MUI files name array
    dwNumOfMUIFiles  -  the number of MUI files, it is important to avoid adding "CMF" section into 
        DLL several times when this function is called from Adding MUI file to existing CMF file.

return:
    true/false

--*/
{
    //
    // Loading MUI files and fill the headers and create CMFFile with this information.  
    // calling LoadAllMui  [public]
    //
    if ( pszCMFFileName == NULL || ppszMuiFiles == NULL || * ppszMuiFiles == NULL)
        return FALSE;
    //
    // sec; CreateFile (ascii version) only handle MAX_PATH  for file name.
    // 
    m_hCMFFile = CreateFile(pszCMFFileName, GENERIC_WRITE | GENERIC_READ, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
    
    if ( INVALID_HANDLE_VALUE == m_hCMFFile) 
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::Create"),_T("Failure of CreateFile()"));
        return FALSE;
    }
    // just in case, user want to use path for cmf file name. this value will be 
    // store in updated langNeu file.

    LPCSTR pszFileName = m_pcmui->GetFileNameFromPath(pszCMFFileName);

    if (strlen (pszFileName)+1 > MAX_FILENAME_LENGTH ) 
        return FALSE; // overflow.
        
    // strncpy(m_strFileName, pszFileName, strlen(pszFileName));
    PTSTR * ppszDestEnd = NULL;
    size_t * pbRem = NULL;
    HRESULT hr;
    hr = StringCchCopyEx(m_strFileName, MAX_FILENAME_LENGTH, pszFileName, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
   
    if ( ! SUCCEEDED(hr)){
        _tprintf("Safe string copy Error\n");
        return FALSE;
    }
    
    return LoadAllMui(ppszMuiFiles, dwNumOfMUIFiles);
   
}


BOOL CCompactMUIFile::Create( LPCTSTR pszCMFFileName ) 
/*++
Abstract:
    simpley create CMFFile and set the handle member data.

Arguments:
    pszCMFFileName  -  CMF file name

return:
    true/false
--*/
{

    if (pszCMFFileName == NULL)
        return FALSE;

    m_hCMFFile = CreateFile(pszCMFFileName, GENERIC_WRITE | GENERIC_READ, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
    // Can't use file mapping. we don't know the file size be created after all operation.
    if ( INVALID_HANDLE_VALUE == m_hCMFFile) 
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::Create"),_T("Failure of CreateFile()") );
        return FALSE;
    }
    return TRUE;
}


typedef struct _tagCOMPACT_MUI {
        WORD        wHeaderSize; // COMPACT_MUI size // [WORD]
        DWORD       dwFileVersionMS; // [DWORD * 2 ] /major version, minor version.
        DWORD       dwFileVersionLS; 
        BYTE        Checksum[16]; // [DWORD * 4 ] MD5 checksum
        WORD        wReserved; //  [DWORD ]
        ULONG_PTR   ulpOffset;  //Offset to mui resource of this from COMPACT_MUI_RESOURCE signature. [DWORD]
        DWORD       dwFileSize;
        WORD        wFileNameLenWPad;  // file name lenght + padding;
        WCHAR       wstrFieName[MAX_FILENAME_LENGTH]; // [WCHAR]
//      WORD        wPadding[1]; // [WORD]  // does not calcualte in the tools, but shall be 
                                // included specfication.
    }COMPACT_MUI, *PCOMPACT_MUI;



BOOL CCompactMUIFile::OpenCMFWithMUI(LPCTSTR pszCMFFile)
/*++
Abstract:
    Loading MUI files and fill the headers and create CMFFile with this information.  
    calling LoadAllMui  [public]

Arguments:
    pszCMFFile  -  CMF file name
return:
    true/false
--*/
{   
    BOOL bRet = FALSE;
    PSTR pszCMFBuffer = NULL;
    
    if (pszCMFFile == NULL)
        goto exit;

    m_hCMFFile = CreateFile(pszCMFFile, GENERIC_WRITE | GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    
    if ( INVALID_HANDLE_VALUE == m_hCMFFile) 
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of CreateFile()"));
        goto exit;
    }
    //
    // Loading CMF and MUI files inside, fill the header of CMF, MUI.
    //

    LPCSTR pszFileName = m_pcmui->GetFileNameFromPath(pszCMFFile);

    if (strlen (pszFileName)+1 > MAX_FILENAME_LENGTH ) 
        goto exit; // overflow.
        
    strncpy(m_strFileName, pszFileName, strlen(pszFileName)+1 ); 
    
    DWORD dwFileSize = GetFileSize(m_hCMFFile, NULL);

    if( dwFileSize == INVALID_FILE_SIZE)
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of GetFileSize()"));
        goto exit;
    }
    
    pszCMFBuffer = new CHAR[dwFileSize]; // use char for possible byte operation of locating mui data.

    if(!pszCMFBuffer)
    	goto exit;
    
    DWORD dwWritten;

    if(! ReadFile(m_hCMFFile, pszCMFBuffer, dwFileSize, &dwWritten, NULL))
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of read file"));
        goto exit;
    }

    m_dwFileSize = GetFileSize(m_hCMFFile, NULL);

    if( m_dwFileSize == INVALID_FILE_SIZE)
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of GetFileSize()"));
        goto exit;
    }
    
    m_upCMFHeader = *(UP_COMPACT_MUI_RESOURCE* ) pszCMFBuffer;

    //
    // Retrieve the each MUI header and files and fill the data to new CMUIFile.
    //


    DWORD dwUpCMFHeaderSize = sizeof UP_COMPACT_MUI_RESOURCE;

    for (UINT i = 0; i < m_upCMFHeader.dwNumberofMui; i ++ ) 
    {
        CMUIFile *pcmui = new CMUIFile();

        // pc = (COMPACT_MUI*)((PBYTE)pszCMFBuffer + wUpCMFHeaderSize);
        PCOMPACT_MUI pcm = NULL;

        pcm = (PCOMPACT_MUI)((PBYTE)pszCMFBuffer + dwUpCMFHeaderSize);
        // Copy the MUI header
        memcpy((PVOID)(&pcmui->m_MUIHeader), (PVOID)pcm, pcm->wHeaderSize );
        
        dwUpCMFHeaderSize += pcmui->m_MUIHeader.wHeaderSize;
        // Copy the MUI image, because we are going to close file handle of ReadFile.
        pcmui->m_pbImageBase = new TBYTE[pcmui->m_MUIHeader.dwFileSize];  // will be delete in destructor.
        
        memcpy(pcmui->m_pbImageBase, (PBYTE)pszCMFBuffer + pcmui->m_MUIHeader.ulpOffset, 
            pcmui->m_MUIHeader.dwFileSize);
       
        if(WideCharToMultiByte(CP_ACP, NULL, pcmui->m_MUIHeader.wstrFieName, wcslen(pcmui->m_MUIHeader.wstrFieName)+1,
             pcmui->m_strFileName, wcslen(pcmui->m_MUIHeader.wstrFieName)+1, NULL, NULL) == 0) // REVISIT; Does MUI header include its filename for updating case.
        {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of WideCharToMultiByte()"));
            delete pcmui;
            goto exit;
        }

        pcmui->m_dwIndex = i;

        m_pcvector.Push_back(pcmui);
    }
    
    bRet = TRUE;

exit:
    if (pszCMFBuffer)
        delete [] pszCMFBuffer;

    if (m_hCMFFile)
        CloseHandle(m_hCMFFile);
    
    m_hCMFFile = NULL; // It still has value although it's freed, so we need to set it NULL.
    return bRet;

}




BOOL CCompactMUIFile::LoadAllMui (PSTR *ppszMuiFiles, DWORD dwNumberofMuiFile)
/*++
Abstract:
    Load MUI files and create/initialze CMUIFile with these loaded MUI file information.

Arguments:
    ppszMuiFiles  -  MUI files array.

return:
    dwNumberofMuiFile  -  Number of MUI files in the array.
--*/
{
    //
    //  1. Use FileMapping    2. 
    // 
    if (ppszMuiFiles == NULL)
        return FALSE;

    for (UINT i = 0; i < dwNumberofMuiFile; i++) 
    {
        PSTR pszMUIFile = ppszMuiFiles[i];
        if (pszMUIFile == NULL)
            return FALSE;

        CMUIFile *pcmui = new CMUIFile;

        if(!pcmui)
        	return FALSE;

        if (! pcmui->Create(pszMUIFile))
        {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::LoadAllMui"),_T("Failure of CMUIFile::Create") );
            delete pcmui;
            return FALSE;
        }
        
        //
        // Add to the list.
        //

        m_upCMFHeader.dwHeaderSize += pcmui->m_MUIHeader.wHeaderSize;
        m_upCMFHeader.dwNumberofMui++; 
        m_dwFileSize += pcmui->m_MUIHeader.wHeaderSize + pcmui->m_MUIHeader.dwFileSize;
        // Add dwFileSize to the strucuture for sanity check inside Loader.
        m_upCMFHeader.dwFileSize = m_dwFileSize;
        pcmui->m_dwIndex = (WORD)i;
        m_pcvector.Push_back(pcmui);

    }

    return TRUE;
        // REVIST; adjust   m_upCMFHeader.wHeaderSize as DWORD aligned.
}


// #define USE_WRITEFILE
BOOL CCompactMUIFile::WriteCMFFile()
/*++
Abstract:
    Write a COMPACT_MUI_RESOURCE, COMPACT_MUI, MUI image files;
    we need to fill the offset data in COMPACT_MUI header for each files.

Arguments:
    
return:
    true/false
--*/
{
    //
    // Write the file to real file.
    //
    
    if (! m_hCMFFile)
    {
        m_hCMFFile = CreateFile(m_strFileName, GENERIC_WRITE | GENERIC_READ, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
    
        if ( INVALID_HANDLE_VALUE == m_hCMFFile) 
        {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile"),_T("Failure of CreateFile()"));
            return FALSE;
        }
        
    }

#ifndef USE_WRITEFILE
    HANDLE hFileMapping = CreateFileMapping(m_hCMFFile, NULL, PAGE_READWRITE, NULL, m_dwFileSize, NULL);
    
    if (hFileMapping == NULL)
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile"),_T("Failure of CreateFileMapping()"));
        _tprintf(_T("GetLastError : %d\n"), GetLastError());
        return FALSE;
    }
    PVOID pCMFImageBase = MapViewOfFile(hFileMapping, FILE_MAP_WRITE, NULL, NULL, NULL);
    if (pCMFImageBase == NULL)
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile"),_T("Failure of MapViewOfFile()"));
        _tprintf(_T("GetLastError : %d\n"), GetLastError());
        return FALSE;

    }
    DWORD dwTempImageBase = (DWORD)PtrToUlong(pCMFImageBase);
    CloseHandle(hFileMapping);

    //
    // write offset to each MUI header.
    //
    DWORD dwUpCMFHeaderSize = m_upCMFHeader.dwHeaderSize;
    
    DWORD_ALIGNMENT(dwUpCMFHeaderSize);  // All MUI headers are already DWORD aligned.

    memcpy(pCMFImageBase, (PVOID)&m_upCMFHeader, sizeof(UP_COMPACT_MUI_RESOURCE));

    DWORD dwLowOffset = sizeof(UP_COMPACT_MUI_RESOURCE);

    for (UINT i = 0; i < m_upCMFHeader.dwNumberofMui; i++)
    {
        CMUIFile *pcmui = (CMUIFile *)m_pcvector.GetValue(i);

        pcmui->m_MUIHeader.ulpOffset = dwUpCMFHeaderSize; // + header size. header size should be DWORD in Create()
        
        dwUpCMFHeaderSize += pcmui->m_MUIHeader.dwFileSize; // + File size is next file offset

        DWORD_ALIGNMENT(dwUpCMFHeaderSize);  // need to adjust for DWORD.
        // writing MUI header
        memcpy((PBYTE)pCMFImageBase + dwLowOffset, (PVOID)&pcmui->m_MUIHeader, pcmui->m_MUIHeader.wHeaderSize);

        dwLowOffset += pcmui->m_MUIHeader.wHeaderSize; // do not DWORD align.

        // writing MUI image
        
        memcpy((PBYTE)pCMFImageBase + pcmui->m_MUIHeader.ulpOffset, pcmui->m_pbImageBase, pcmui->m_MUIHeader.dwFileSize);
    
        UnmapViewOfFile(pcmui->m_pbImageBase); // unmap MUI file at last.
    };

    if (! FlushViewOfFile(pCMFImageBase, NULL) ) 
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile()"), _T("Failure of FlushViewOfFile()") );
        return FALSE;

    }
    
    UnmapViewOfFile(pCMFImageBase);

#else
    //
    // Using WriteFile. 
    // create two buffer. 1. header part  2. data part. we fill this buffer with data, then 
    // write these buffer; we can save time by reducing I/O
    //
    
    PBYTE pCMFImageBase  = (PBYTE)LocalAlloc(LMEM_ZEROINIT, m_dwFileSize);

    if (pCMFImageBase == NULL)
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile()"), _T("Failure of LocalAlloc()") );
        return FALSE;
    }
    
    //
    // write offset to each MUI header.
    //
    DWORD dwUpCMFHeaderSize = m_upCMFHeader.dwHeaderSize;
    
    DWORD_ALIGNMENT(dwUpCMFHeaderSize); // All MUI headers are already DWORD aligned.

    memcpy(pCMFImageBase, (PVOID)&m_upCMFHeader, sizeof(UP_COMPACT_MUI_RESOURCE));

    DWORD dwLowOffset = sizeof(UP_COMPACT_MUI_RESOURCE);

    for (UINT i = 0; i < m_upCMFHeader.dwNumberofMui; i++)
    {
        CMUIFile *pcmui = (CMUIFile *)m_pcvector.GetValue(i);

        pcmui->m_MUIHeader.ulpOffset = wUpCMFHeaderSize; // + header size. header size should be DWORD in Create()
        
        dwUpCMFHeaderSize += pcmui->m_MUIHeader.dwFileSize; // + File size is next file offset

        DWORD_ALIGNMENT(dwUpCMFHeaderSize);  // need to adjust for DWORD.
        // writing MUI header
        memcpy((PBYTE)pCMFImageBase + dwLowOffset, (PVOID)&pcmui->m_MUIHeader, pcmui->m_MUIHeader.wHeaderSize);

        dwLowOffset += pcmui->m_MUIHeader.wHeaderSize; // do not DWORD align.

        // writing MUI image
        
        memcpy((PBYTE)pCMFImageBase + pcmui->m_MUIHeader.ulpOffset, pcmui->m_pbImageBase, pcmui->m_MUIHeader.dwFileSize);
    
        UnmapViewOfFile(pcmui->m_pbImageBase); // unmap MUI file at last.
    };

    DWORD dwWritten;
    if (!WriteFile(m_hCMFFile, pCMFImageBase, m_dwFileSize, &dwWritten, NULL))
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile()"), _T("Failure of WriteFile()") );
        return FALSE;
    }

#endif
    CloseHandle(m_hCMFFile);
    return TRUE;

}

#ifdef VARIALBE_MUI_STRUCTURE

BOOL CCompactMUIFile::WriteCMFFile()
/*++
Abstract:
    Create mapped view of CMF file handle and write all information when MUI data structe is variable; MUI structure
    would be variable if we dicide replace array of MUI file name with null terminated pointer. 
    currently, our structured can accomodate both of them. if we use null termated pointer, we can set file name size 
    for robust reason from client use.

Arguments:
    

return:
--*/
{
    //
    // Write the file to real file.
    //
    
    HANDLE hFileMapping = CreateFileMapping(m_hCMFFile, NULL, PAGE_READWRITE, NULL, NULL, NULL);

    PVOID pCMFImageBase = MapViewOfFile(hFileMapping, FILE_MAP_WRITE, NULL, NULL, NULL);

    CloseHandle(hFileMapping);

    //
    // write offset to each MUI header.
    //
    DWORD dwUpCMFHeaderSize = m_upCMFHeader.dwHeaderSize;
    
    // DWORD_ALIGNMENT(wUpCMFHeaderSize); All MUI headers are already DWORD aligned.

    memcpy(pCMFImageBase, (PVOID)&m_upCMFHeader, sizeof(UP_COMPACT_MUI_RESOURCE));

    DWORD dwLowOffset = sizeof(UP_COMPACT_MUI_RESOURCE);

    for (UINT i = 0; i < m_upCMFHeader.dwNumberofMui; i++)
    {
        CMUIFile *pcmui = (CMUIFile *)m_pcvector->GetValue(i);

        pcmui->m_MUIHeader.ulpOffset = dwUpCMFHeaderSize; // + header size
        
        dwUpCMFHeaderSize += pcmui->m_MUIHeader.dwFileSize; // + File size is next file offset

        DWORD_ALIGNMENT(dwUpCMFHeaderSize);  // need to adjust for DWORD.
        // writing MUI header
        memcpy((PBYTE)pCMFImageBase + dwLowOffset, (PVOID)&pcmui->m_MUIHeader, pcmui->m_MUIHeader.wHeaderSize);

        dwLowOffset += pcmui->m_MUIHeader.wHeaderSize; // do not DWORD align.

        // writing MUI image
        memcpy((PBYTE)pCMFImageBase + pcmui->m_MUIHeader.ulpOffset, pcmui->m_pbImageBase, pcmui->m_MUIHeader.dwFileSize);
    
    };

    if (! FlushViewOfFile(pCMFImageBase, NULL) ) 
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteCMFFile()"), _T("Failure of FlushViewOfFile()") );
        return FALSE;

    }
    
    UnmapViewOfFile(pCMFImageBase);
}

#endif

BOOL CCompactMUIFile::UpdateMuiFile( PSTR pszCMFFile, PSTR pszMuiFile)
{
       // TBD
    if ( pszCMFFile == NULL || pszMuiFile == NULL)
        return FALSE;

    return TRUE;
}
//create CMUIFile and replace this data with same name inside  //CMF file and fill new CMF file structure.

BOOL CCompactMUIFile::DisplayHeaders(PSTR pszCMFFile, WORD wLevel /*= NULL*/)
/*++
Abstract:
    Dump CMF header information

Arguments:
    pszCMFFile  -  CMF file
    wLevel  -  dump level. not implemented yet.

return:
    true/false
--*/
{
    if (pszCMFFile == NULL)
        return FALSE;
    
    if (OpenCMFWithMUI(pszCMFFile))
    {
        _tprintf(_T("\nCMF Headers   %s\n"), pszCMFFile );
        _tprintf(_T("------------------  ---------------- \n\n") );

        _tprintf(_T("dwSignature        :%16x \n"),m_upCMFHeader.dwSignature );
        _tprintf(_T("dwHeaderSize       :%16x \n"),m_upCMFHeader.dwHeaderSize );
        _tprintf(_T("dwNumberofMui      :%16x \n"),m_upCMFHeader.dwNumberofMui );
        _tprintf(_T("dwFileSize         :%16x \n\n\n"),m_upCMFHeader.dwFileSize );

       for ( UINT i = 0; i < m_pcvector.Size(); i++) 
        {
            CMUIFile *pcmui = m_pcvector.GetValue(i);
            _tprintf(_T(" %d MUI Header  \n"),i+1 );
            _tprintf(_T("------------------  ----------------  \n\n") );

            _tprintf(_T("wHeaderSize        : %16x \n"),pcmui->m_MUIHeader.wHeaderSize );
            _tprintf(_T("dwFileVersionMS    : %16x \n"),pcmui->m_MUIHeader.dwFileVersionMS );
            _tprintf(_T("dwFileVersionLS    : %16x \n"),pcmui->m_MUIHeader.dwFileVersionLS );
            _tprintf(_T("Checksum           : "));
            for (UINT j=0; j < 16; j++){
                _tprintf(_T("%x "),pcmui->m_MUIHeader.Checksum[j] );
            }
            _tprintf(_T("\n"));
            _tprintf(_T("wReserved          : %16x \n"),pcmui->m_MUIHeader.wReserved );
            _tprintf(_T("ulpOffset          : %16x \n"),pcmui->m_MUIHeader.ulpOffset );
            _tprintf(_T("dwFileSize         : %16x \n"),pcmui->m_MUIHeader.dwFileSize );
            _tprintf(_T("wFileNameLenWPad   : %16x \n"),pcmui->m_MUIHeader.wFileNameLenWPad );
            _tprintf(_T("wstrFieName        : %16S \n\n\n"),pcmui->m_MUIHeader.wstrFieName );
         }
    }
    
    return TRUE;
}   


BOOL CCompactMUIFile::AddFile (PSTR pszCMFFile, PSTR *pszAddedMuiFile, DWORD dwNumOfMUIFiles)
/*++
Abstract:
    Add a new mui file into existing cmf file, it does not create new file yet,
    it just add mui into cmf's mui tree. 

Arguments:
    pszAddedMuiFile :  MUI fil be added.
    pszCMFFile : existing CMF file

return:
    true/false
--*/
{   
    if ( pszCMFFile == NULL || pszAddedMuiFile == NULL)
        return FALSE;
    //
    // Open CMF file with MUI files
    //
    
    if (! OpenCMFWithMUI(pszCMFFile))
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::AddFile"),_T("Failure of OpenCMFWithMUI(pszCMFFile)"),pszCMFFile );
        return FALSE;
    }
    
    //
    // Create a new CMUIfile on the based on new added mui file
    //
    for (UINT i =0; i < dwNumOfMUIFiles; i++)
    {
        CMUIFile *pcmui = new CMUIFile();
        
        if (!pcmui )
        	return FALSE;

        if (! pcmui->Create(pszAddedMuiFile[i]))
        {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::AddFile"),_T("Failure of CMUIFile::Create"),pszAddedMuiFile[i] );
            delete pcmui;
            return FALSE;
        }
        
        //
        // Add to the list.
        //

        m_upCMFHeader.dwHeaderSize += pcmui->m_MUIHeader.wHeaderSize;
        m_upCMFHeader.dwNumberofMui++; 
        m_dwFileSize += pcmui->m_MUIHeader.wHeaderSize + pcmui->m_MUIHeader.dwFileSize;
        // Add dwFileSize to the strucuture for sanity check inside Loader.
        m_upCMFHeader.dwFileSize = m_dwFileSize;
        pcmui->m_dwIndex = m_upCMFHeader.dwNumberofMui - 1;
        m_pcvector.Push_back(pcmui);
    }
    return TRUE;
}   
    
BOOL CCompactMUIFile::SubtractFile ( PSTR pszSubtractedMuiFile , PSTR pszCMFFile /*= NULL*/ )//elete  from the list,and create file for that.
/*++
Abstract:
    subtract mui file from the CMF file. NOT implemented yet.

Arguments:
    pszSubtractedMuiFile  -  MUI file, which would be removed from CMF file
    pszCMFFile  -  CMF file

return:
    true/false
--*/
{   
    if (pszSubtractedMuiFile == NULL)
        return FALSE;

    return TRUE;
}   

// add new CMUI file into existing CMF file
BOOL CCompactMUIFile::UnCompactCMF (PSTR pszCMFFile)
/*++
Abstract:
    Create each MUI file from CMF file. 

Arguments:
    pszCMFFile  -  CMF file

return:
    true/false
--*/
{   
    if (pszCMFFile == NULL)
        return FALSE;
    
    if (OpenCMFWithMUI(pszCMFFile))
    {
        for (UINT i = 0; i < m_pcvector.Size(); i++)
        {
            CMUIFile *pcmui = m_pcvector.GetValue(i);
    
            if (! pcmui->WriteMUIFile(pcmui))
            {
                CError ce;
                ce.ErrorPrint(_T("CCompactMUIFile::UnCompactCMF"), _T("Failure of CMUIFile::writeMUIFile()") );
                return FALSE;
            }

        }

        return TRUE;
        // REVIST ; how about uddating a binary files.
    }
 
    return FALSE;
}

    

void CCompactMUIFile::SubtractFile(CMUIFile* pcmui) 
/*++
Abstract:

Arguments:

return:
--*/
{
        // TBD

}


BOOL CCompactMUIFile::UpdateCodeFiles(PSTR pszCodeFilePath, DWORD dwNumbOfFiles)
/*++
Abstract:
    This rotine will be called when -m(create new cmf file) and -a(add mui file into
    existing cmf file). in the -a case, we don't have to (shouldn't) update code files
    because it alreay updated(include CMF name).  The updated files are added at the end 
    cmf files so we update files reversly.

Arguments:
    pszCodeFilePath  -  DLL (parent of MUI file) path
    dwNumbOfFiles  -  number of added MUI files. this is called as a function of CompactMUI in main function.

return:
    true/false
--*/
{
    
    PTSTR * ppszDestEnd = NULL;
    size_t * pbRem = NULL;
    HRESULT hr;
        
    if (pszCodeFilePath == NULL)
        return FALSE;

    // Update files from the last item until number of files end.
    UINT i =m_pcvector.Size()-1;
    
    for (UINT j = 0 ; j < dwNumbOfFiles ; i --, j++ )
    {   // create temp codefilepath.
       
        CHAR szTempCodeFilePath[MAX_PATH]; //  = {0};
        
        // szTempCodeFilePath[sizeof(szTempCodeFilePath)-1] = '\0';
        
        // strncpy(szTempCodeFilePath, pszCodeFilePath, strlen(pszCodeFilePath)+1);
        
        hr = StringCchCopyExA(szTempCodeFilePath, MAX_PATH ,pszCodeFilePath, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
        if ( ! SUCCEEDED(hr)){
            _tprintf("Safe string copy Error\n");
            return FALSE;
        }
        // Get CMUIFile
        CMUIFile *pcmui = m_pcvector.GetValue(i);

        LPCTSTR pcstrMuiFile = pcmui->m_strFileName;
        
        if ( pcstrMuiFile == NULL)
            return FALSE;

        // Get the file name without ".mui"
        DWORD dwLen = strlen(pcstrMuiFile);
        TCHAR szCodeFileName[MAX_PATH]={0}; // new is used when initializing class.

        if (dwLen > MAX_PATH) {
            return FALSE;
            }
        
        while ( dwLen )
        {
            if ( *(pcstrMuiFile + ( --dwLen )) == '.')
            {
               _tcsncpy(szCodeFileName, pcstrMuiFile, dwLen);
               // pcstrMuiFile[dwLen] = _T('\0');
               
               // StringCchCopyEx(szCodeFileName, MAX_PATH ,pcstrMuiFile, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
               // memcpy(szCodeFileName, pcstrMuiFile, dwLen);
               break;
            }
            
        }
        if (dwLen == 0)
        {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::UpdateCodeFiles"), _T("MUI File name is not a file name format (*.*)") );
            return FALSE;
            
        }
        //
        // Check if target file exist in the directory.
        //

        WIN32_FIND_DATA w32fd;

        //_tcsncat(szTempCodeFilePath, "\\", 2);
        
        hr = StringCchCatEx(szTempCodeFilePath, MAX_PATH, _T("\\"), ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
        
        if ( ! SUCCEEDED(hr)){
            _tprintf("Safe string copy Error\n");
            return FALSE;
        }

        // _tcsncat(szTempCodeFilePath, szCodeFileName, _tcslen(szCodeFileName)+1);
        hr = StringCchCatEx(szTempCodeFilePath, MAX_PATH, szCodeFileName, ppszDestEnd, pbRem,MUIRCT_STRSAFE_NULL);
        
        if ( ! SUCCEEDED(hr)){
            _tprintf("Safe string copy Error\n");
            return FALSE;
        }
        
        //if (FindFirstFile("dll\\np2.exe", &w32fd) == INVALID_HANDLE_VALUE)
        if (FindFirstFile(szTempCodeFilePath, &w32fd) == INVALID_HANDLE_VALUE)
        {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::UpdateCodeFiles"), _T("FindFirstFile fail"), szCodeFileName );
            return FALSE;
        }

        // Adding "CMF xxx.cmf" inside Version info.
        updateCodeFile(szTempCodeFilePath, pcmui->m_dwIndex);

        // update checksum data inside update Code.
        CMUIResource cmui; // :: UpdateNtHeader
        
        cmui.UpdateNtHeader(szTempCodeFilePath, cmui.CHECKSUM);

    }
    return TRUE;
}


BOOL CCompactMUIFile::updateCodeFile(PSTR pszCodeFilePath, DWORD dwIndex)
/*++
Abstract:
    update DLL (parent of MUI file)'s version resource by adding "CMF" section, which
    contain CMF file and its index inside CMF file. the index can improve searching speed inside MUI loader.

Arguments:
    pszCodeFilePath   -  DLL file path
    dwIndex  -  index of MUI inside CMF file

return:
--*/
{
    

        typedef struct VS_VERSIONINFO 
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR szKey[16];              // L"VS_VERSION_INFO" + unicode null terminator
        // Note that the previous 4 members has 16*2 + 3*2 = 38 bytes. 
        // So that compiler will silently add a 2 bytes padding to make
        // FixedFileInfo to align in DWORD boundary.
        VS_FIXEDFILEINFO FixedFileInfo;
    } VS_VERSIONINFO,* PVS_VERSIONINFO;
    
    // using the same structure in ldrrsrc.c because this is smart way to get the exact structuree location.
    typedef struct tagVERBLOCK
    {
        USHORT wTotalLen;
        USHORT wValueLen;
        USHORT wType;
        WCHAR szKey[1];
        // BYTE[] padding
        // WORD value;
    } VERBLOCK;

    // this is the structure in the muibld.exe.
    typedef struct VAR_SRC_COMPACT
    {
        WORD wLength;
        WORD wValueLength;
        WORD wType;
        WCHAR szCompactMui[4];    // For storing "CompactMui\0" null-terminated string in Unicode.
    //  DWORD dwIndex;    // 
    //  WCHAR szCompactFileName[32];
    } VAR_SRC_COMPACT; //VAR_SRC_CHECKSUM;
    
    if ( pszCodeFilePath == NULL)
        return FALSE;
    //
    // Get VersionInfo structure.
    //
    DWORD dwHandle;
    LPVOID lpVerRes = NULL;
    CMUIResource * pcmuir = NULL;
    
    DWORD dwVerSize = GetFileVersionInfoSize( (LPTSTR) pszCodeFilePath, &dwHandle);

    lpVerRes = new CHAR[dwVerSize + TEMP_BUFFER];

    if (!lpVerRes)
    	goto exit;
    
    if ( ! GetFileVersionInfo((LPTSTR)pszCodeFilePath, 0 ,dwVerSize, lpVerRes) ) {
        _tprintf(_T("Fail to get file version: GetLastError() : %d \n"),GetLastError() ) ;
        goto exit;
    }
        
    PVS_VERSIONINFO pVersionInfo = (VS_VERSIONINFO *) lpVerRes;
    
    WORD wResVerSize = pVersionInfo ->TotalSize;
    
    WORD wNewResVerSize = wResVerSize; //  + sizeof (VAR_SRC_COMPACT);
    
    VERBLOCK * pVerBlock = NULL;
    
    BOOL fSuccess = FALSE;

    //
    //  Adding checksum Resource data into inside VarFileInfo
    //
    if ( wResVerSize > 0 ) {
        
        if ( wcscmp(pVersionInfo ->szKey,L"VS_VERSION_INFO") ) {
            
            _tprintf(_T("This is not correct Version resource") );
            
            goto exit;
        }
        
        WORD wBlockSize = (WORD)DWORD_ALIGNMENT ( sizeof (VS_VERSIONINFO) );
        
        wResVerSize -= wBlockSize; 
        
        pVerBlock = (VERBLOCK *) ( pVersionInfo + 1 );
        
        while ( wResVerSize > 0 ) {
    
            if ( ! wcscmp(pVerBlock ->szKey,L"VarFileInfo") ) {
                
                VERBLOCK * pVarVerBlock = pVerBlock;
                
                WORD wVarFileSize = pVerBlock->wTotalLen;
                
                wResVerSize -= wVarFileSize;

                WORD wVarBlockSize = (WORD) DWORD_ALIGNMENT (sizeof(*pVerBlock) -1 + sizeof(L"VarFileInfo"));
                
                wVarFileSize -= wVarBlockSize;
                
                pVerBlock = (VERBLOCK *)((PBYTE) pVerBlock + wVarBlockSize );

                while ((LONG)wVarFileSize > 0 ) {
                    
                    if ( ! wcscmp(pVerBlock ->szKey,L"Translation") ) {
                        
                        VAR_SRC_COMPACT * pVarSrcCompMui = (VAR_SRC_COMPACT *)new BYTE[TEMP_BUFFER];
                        // VAR_SRC_COMPACT * pVarSrcCompMui = new VAR_SRC_COMPACT;
                        if ( !pVarSrcCompMui) {
                             _tprintf(_T("Memory Insufficient error in CCompactMUIFile::updateCodeFile"));
                             goto exit;
                           }

                        wVarBlockSize = (WORD)DWORD_ALIGNMENT ( pVerBlock ->wTotalLen );
                        
                        PBYTE pStartCompMui = (PBYTE) pVerBlock + wVarBlockSize ;
                        
                        // Fill the structure.
                        pVarSrcCompMui->wLength = sizeof (VAR_SRC_COMPACT);
                        pVarSrcCompMui->wValueLength = (strlen(m_strFileName)+1) * sizeof WCHAR + sizeof DWORD;
                        pVarSrcCompMui->wType = 0;
                        // wcsncpy(pVarSrcCompMui->szCompactMui, MUI_COMPACT, 4 );
                        HRESULT hr;
                        hr = StringCchCopyW(pVarSrcCompMui->szCompactMui, sizeof (pVarSrcCompMui->szCompactMui)/ sizeof(WCHAR),
                               L"CMF");
                        if ( ! SUCCEEDED(hr)){
                            _tprintf("Safe string copy Error\n");
                            delete [] pVarSrcCompMui;
                            goto exit;
                        }
                        pVarSrcCompMui->wLength = (WORD)DWORD_ALIGNMENT((BYTE)pVarSrcCompMui->wLength); // + sizeof (L"CompactMui"));
                        // Add DWORD wIndex
                        memcpy((PBYTE)pVarSrcCompMui + pVarSrcCompMui->wLength, &dwIndex, sizeof DWORD );
                        pVarSrcCompMui->wLength += sizeof DWORD;
                        // Add WCHAR Compact file name
                        WCHAR wstrFileName[MAX_FILENAME_LENGTH];
                        if (MultiByteToWideChar(CP_ACP, NULL, m_strFileName, 
                            strlen(m_strFileName)+1, wstrFileName, MAX_FILENAME_LENGTH ) == 0)
                            {
                                _tprintf("Error happen in updateCodeFile: MultiByteToWideChar; GetLastError() : %d\n", GetLastError() );
                                delete [] pVarSrcCompMui;
                                goto exit;
                            }
                        memcpy((PBYTE)pVarSrcCompMui + pVarSrcCompMui->wLength, wstrFileName, (wcslen(wstrFileName)+1) * sizeof WCHAR );
                        pVarSrcCompMui->wLength += (wcslen(wstrFileName) + 1) * sizeof WCHAR;
                        pVarSrcCompMui->wLength = DWORD_ALIGNMENT(pVarSrcCompMui->wLength);
                        // memcpy(pStartCompMui,pVarSrcCompMui,sizeof(VAR_SRC_COMPACT) );
                        
                        pVarVerBlock->wTotalLen += pVarSrcCompMui->wLength; // update length of VarFileInfo
                        wNewResVerSize += pVarSrcCompMui->wLength;
                        pVersionInfo ->TotalSize = wNewResVerSize;
                        
                        wVarFileSize -= wVarBlockSize; 
                        // pVerBlock = (VERBLOCK* ) ( (PBYTE) pVerBlock + pVarSrcCompMui->wLength );
                        // Push the any block in VarInfo after new inserted block "CompactMui" 
                        if ( wVarFileSize  ) {
                            
                            PBYTE pPushedBlock = new BYTE[wVarFileSize ];
                            if (pPushedBlock) {
                              memcpy(pPushedBlock, pStartCompMui, wVarFileSize );
                              memcpy(pStartCompMui + pVarSrcCompMui->wLength, pPushedBlock ,wVarFileSize );
                            }
                            else 
                            {
                              _tprintf(_T("Memory Insufficient error in CCompactMUIFile::updateCodeFile"));

                            }   
                            delete [] pPushedBlock;
                            
                        }
                        
                        memcpy(pStartCompMui, pVarSrcCompMui, pVarSrcCompMui->wLength );
                        
                        fSuccess = TRUE;
                        delete [] pVarSrcCompMui;
                        break;
                    }
                    wVarBlockSize = (WORD)DWORD_ALIGNMENT ( pVerBlock ->wTotalLen );
                    wVarFileSize -= wVarBlockSize; 
                    pVerBlock = (VERBLOCK* ) ( (PBYTE) pVerBlock + wVarBlockSize );
                }   // while (wVarFileSize > 0 ) {
                pVerBlock = (VERBLOCK* ) ( (PBYTE) pVarVerBlock->wTotalLen );
                
            }
            else {
                wBlockSize = (WORD) DWORD_ALIGNMENT ( pVerBlock ->wTotalLen );
                wResVerSize -= wBlockSize; 
                pVerBlock = (VERBLOCK * ) ( (PBYTE) pVerBlock + wBlockSize );
            }
            if (fSuccess)
                break;
        }

    }

    //
    //  Update file by using UpdateResource function
    //

    BOOL fVersionExist = FALSE;
    BOOL fUpdateSuccess = FALSE;
    BOOL fEndUpdate = FALSE;

    if ( fSuccess ) {
        
       
        pcmuir = new CMUIResource(); //(pszNewFile);

        if(!pcmuir)
        	goto exit;
        
        if (! pcmuir -> Create(pszCodeFilePath) ) 
        { // load the file .
            goto exit;
        }

        HANDLE  hUpdate = ::BeginUpdateResource(pszCodeFilePath, FALSE );
        
        if (hUpdate == NULL)
        {
            goto exit;
        }

        cvcstring  * cvName = pcmuir->EnumResNames(MAKEINTRESOURCE(RT_VERSION),reinterpret_cast <LONG_PTR> (pcmuir) );
        
        for (UINT j = 0; j < cvName->Size();j ++ ) {
            
            cvword * cvLang = pcmuir->EnumResLangID(MAKEINTRESOURCE(RT_VERSION), cvName->GetValue(j), reinterpret_cast <LONG_PTR> (pcmuir) );
                
            for (UINT k = 0; k < cvLang->Size();k ++ ) {
                    
                fUpdateSuccess = ::UpdateResource(hUpdate, MAKEINTRESOURCE(RT_VERSION),cvName->GetValue(j),cvLang->GetValue(k),lpVerRes,wNewResVerSize);
                
                fVersionExist = TRUE;
            }
        }

        pcmuir->FreeLibrary();
        
        fEndUpdate = ::EndUpdateResource(hUpdate, FALSE);

        CloseHandle(hUpdate);
    }
    else
    {
        goto exit;
    }
    
    if( ! fVersionExist ){
        _tprintf(_T("no RT_VERSION type exist in the file %s \n"), pszCodeFilePath);
    }


exit:
	if(lpVerRes)
		delete []lpVerRes;
	if(pcmuir)
		delete pcmuir;
	
	return (  fEndUpdate & fVersionExist & fUpdateSuccess );
	
}





////////////////////////////////////////////////////////////////////////////////////////////////
//
// CMUIFile implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////


CMUIFile::CMUIFile()
{
    m_MUIHeader.wHeaderSize = sizeof COMPACT_MUI;
    m_MUIHeader.dwFileVersionMS = 0;
    m_MUIHeader.dwFileVersionLS = 0;
    m_MUIHeader.Checksum[16] = 0; //new BYTE[16];
    m_MUIHeader.wReserved = 0;
    m_MUIHeader.ulpOffset = 0;
    m_MUIHeader.dwFileSize = 0;
    m_MUIHeader.wFileNameLenWPad =0;
    m_MUIHeader.wstrFieName[MAX_FILENAME_LENGTH] = '\0';
    
    m_pbImageBase = NULL;
    m_dwIndex = 0xFFFF;  // index start from 0.
    m_strFileName = new TCHAR[MAX_FILENAME_LENGTH];
}
CMUIFile::CMUIFile(CMUIFile & cmf)
{
    //REVISIT : initialize copy constructor
}
CMUIFile::~CMUIFile()
{
    if (m_pbImageBase)
    {
        delete m_pbImageBase;
    }
    if (m_strFileName)
    {
        delete []m_strFileName;
    }

}
CMUIFile & CMUIFile::operator=(CMUIFile &cmf)
{
    if (&cmf == this)
        return *this;

    m_MUIHeader.wHeaderSize = cmf.m_MUIHeader.wHeaderSize;
    m_MUIHeader.dwFileVersionMS = cmf.m_MUIHeader.dwFileVersionMS;
    m_MUIHeader.dwFileVersionLS = cmf.m_MUIHeader.dwFileVersionLS;
    m_MUIHeader.Checksum[16] = cmf.m_MUIHeader.Checksum[16];
    m_MUIHeader.wReserved = cmf.m_MUIHeader.wReserved;
    m_MUIHeader.ulpOffset = cmf.m_MUIHeader.ulpOffset;
    m_MUIHeader.dwFileSize = cmf.m_MUIHeader.dwFileSize;
    m_MUIHeader.wFileNameLenWPad = cmf.m_MUIHeader.wFileNameLenWPad;
    m_MUIHeader.wstrFieName[MAX_FILENAME_LENGTH] = cmf.m_MUIHeader.wstrFieName[MAX_FILENAME_LENGTH];
    return *this;
}



BOOL CMUIFile::Create (PSTR pszMuiFile) 
/*++
Abstract:
    load file and fill the structure block. 
Arguments:
    pszMuiFile  -  
Return:
--*/
// 
{
    HANDLE hFile = NULL;
    HANDLE hMappedFile = NULL;
    BOOL fStatus = TRUE;

    if (pszMuiFile == NULL){
        fStatus = FALSE;
        goto Exit;
    }
    LPCTSTR pszFileName = GetFileNameFromPath(pszMuiFile);

    if (strlen (pszMuiFile)+1 > MAX_FILENAME_LENGTH ){
        fStatus = FALSE;
        goto Exit;;  //overflow
    }
    // strncpy(m_strFileName, pszFileName, strlen (pszFileName)+1 );
    PTSTR * ppszDestEnd = NULL;
    size_t * pbRem = NULL;
    HRESULT hr;
    hr = StringCchCopyEx(m_strFileName, MAX_FILENAME_LENGTH, pszFileName, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
    if ( ! SUCCEEDED(hr)){
       _tprintf("Safe string copy Error\n");
       fStatus = FALSE;
       goto Exit;;
    }
    //
    // Get checksum and file version info.
    //
    // PBYTE pMD5Checksum = new BYTE[16];
    PBYTE pMD5Checksum = (PBYTE)LocalAlloc(LMEM_ZEROINIT, 20);
    // version

    DWORD dwFileVersionMS,dwFileVersionLS;
    dwFileVersionMS = dwFileVersionLS =0;

    if (pMD5Checksum)
    {
    if(! getChecksumAndVersion(pszMuiFile,&pMD5Checksum, &dwFileVersionMS, &dwFileVersionLS) )
    {
        //CError ce;
        //ce.ErrorPrint(_T("CCompactMUIFile::Create"),_T("Failure of GetChecksum()") );
    }
       else
       {
             memcpy(m_MUIHeader.Checksum, pMD5Checksum, RESOURCE_CHECKSUM_SIZE);
       }

       LocalFree(pMD5Checksum);
    }
     
    
    //
    // Load a file and map
    //

    hFile = CreateFile(pszMuiFile, GENERIC_WRITE | GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
    
    if ( INVALID_HANDLE_VALUE == hFile) 
   {
        CError ce;
        ce.ErrorPrint(_T("CMUIFile::Create (PSTR pszMuiFile)"),_T("Failure of CreateFile()"), pszMuiFile );
        printf("GetLastError %d", GetLastError());
        fStatus = FALSE;
        return FALSE;
    }
    
    hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, NULL, NULL, NULL); 

    if(hMappedFile == NULL)
    {
        CError ce;
        ce.ErrorPrint(_T("CMUIFile::Create (PSTR pszMuiFile)"),_T("Failure of CreateFileMapping()"), pszMuiFile );
        printf("GetLastError %d", GetLastError());
        fStatus = FALSE;
        goto Exit;;
    }
    PBYTE pbImageBase = (PBYTE)MapViewOfFile(hMappedFile, FILE_MAP_WRITE, NULL, NULL, NULL);

    if (pbImageBase == NULL)
    {
        CError ce;
        ce.ErrorPrint(_T("CMUIFile::Create (PSTR pszMuiFile)"),_T("Failure of MapViewOfFile()"), pszMuiFile );
        printf("GetLastError %d", GetLastError());
        fStatus = FALSE;
        goto Exit;
    }

    // Fill the CMUIFile member data
    m_pbImageBase = pbImageBase;
    
    //
    // Fill the COMPACT_MUI data field.
    //

    m_MUIHeader.dwFileVersionMS = dwFileVersionMS;
    m_MUIHeader.dwFileVersionLS = dwFileVersionLS;
        
    //offset, reserver, filesize.
    m_MUIHeader.ulpOffset = 0; // we can't set this now.
    m_MUIHeader.wReserved = 0;

    m_MUIHeader.dwFileSize = GetFileSize(hFile, NULL);
    
    
    // File name, filelenwithpadding, mui header size

    // LPWSTR pwstrBuffer = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, 256);
    WCHAR wstrBuffer[MAX_FILENAME_LENGTH];
        
       // REVISIT; only accept english file name.
       // specify wcslen instead of tcslen becasuse of possible overrun.
    if (MultiByteToWideChar(CP_ACP, NULL, m_strFileName, 
                    strlen(m_strFileName)+1, wstrBuffer, MAX_FILENAME_LENGTH ) == 0)
        {
            _tprintf("Error happen in Create: MultiByteToWideChar; GetLastError() : %d\n", GetLastError() );
            fStatus = FALSE;
            goto Exit;;
        }
    // wcsncpy(m_MUIHeader.wstrFieName, pwstrBuffer, wcslen(pwstrBuffer)+1); //strlen does not return '\0'
    
    hr = StringCchCopyW(m_MUIHeader.wstrFieName, sizeof (m_MUIHeader.wstrFieName)/ sizeof(WCHAR),
                      wstrBuffer);
    if ( ! SUCCEEDED(hr)){
        _tprintf("Safe string copy Error\n");
        fStatus = FALSE;
        goto Exit;;
    }
       // This should be done in Constructor of CMUIFile        
       // pcmui->m_MUIHeader.wHeaderSize = sizeof UP_COMPACT_MUI;
    WORD wTempHeaderSize = m_MUIHeader.wHeaderSize;


Exit:
    if (hFile)
        CloseHandle(hFile);
    if (hMappedFile)
        CloseHandle(hMappedFile);

    return fStatus;
        // add padding at end of file name as null character.
            // file length include; file string + null character + padding (null character as well)
}

#ifdef VARIALBE_MUI_STRUCTURE
BOOL CMUIFile::Create (PSTR pszMuiFile) //  
/*++
Abstract:
    load file and fill the structure block for variable MUI structure.

Arguments:
    
Return:
--*/
{
    if(pszMuiFile == NULL)
        return FALSE;
    //
    // Get checksum and file version info.
    //
        
    PBYTE pMD5Checksum = (PBYTE)LocalAlloc(LMEM_ZEROINIT, 16);
    if (pMD5Checksum) 
    {
    
          DWORD FileVersionLS,FileVersionMS;

         if(!getChecksumAndVersion(pszMUIFile,&pMD5Checksum) )
         {
            CError ce;
            ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of GetChecksum()") );
            LocalFree(pMD5Checksum);
            return FALSE;
          }
          else
         {
               memcpy(m_MUIHeader.Checksum, pMD5Checksum, RESOURCE_CHECKSUM_SIZE);
          }

         LocalFree(pMD5Checksum);
    }
    
    //
    // Load a file and map
    //

    HANDLE hFile = CreateFile(pszMUIFile, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    
    if ( INVALID_HANDLE_VALUE == hFile) 
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::OpenCMFWithMUI"),_T("Failure of CreateFile()"), _T("File : %s"), pszMUIFile );
        return FALSE;
    }
    
    HANDLE hMappedFile = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, NULL, NULL, NULL); 

    PBYTE pbImageBase = NULL ; //(PBYTE)MapViewOfFile(hMappedFile, NULL, NULL, NULL, NULL);

    // Fill the CMUIFile member data
    m_pbImageBase = pbImageBase;
//      pcmui->m_hMUIFile = hFile;   // do we need file handle ?
//      pcmui->m_wImageSize = GetFileSize(hFile);

    
    //
    // Fill the COMPACT_MUI data field.
    //

    
    
    m_MUIHeader.dwFileVersionMS = dwFileVersionMS;
    m_MUIHeader.dwFileVersionLS = dwFileVersionLS;
        
    //offset, reserver, filesize.
    m_MUIHeader.ulpOffset = 0; // we can't set this now.
    m_MUIHeader.wReserved = 0;

    m_MUIHeader.dwFileSize = GetFileSize(hFile, NULL);
    
    
    // File name, filelenwithpadding, mui header size

    //    LPWSTR pwstrBuffer = new WCHAR[MAX_FILENAME_LENGTH];
    WCHAR wstrBuffer[MAX_FILENAME_LENGTH];
    if ( MultiByteToWideChar(CP_ACP, NULL, pszMUIFile, 
                strlen(ppszMuiFiles[i]), wstrBuffer, MAX_FILENAME_LENGTH ) == 0)
        {
            _tprintf("Error happen in Create: MultiByteToWideChar; GetLastError() : %d\n", GetLastError() );
            return FALSE;
        }
    //wcsncpy(m_MUIHeader.wstrFieName, pwstrBuffer, wcslen(pwstrBuffer)+1); //strlen does not return '\0'
    HRESULT hr;
    hr = StringCchCopyW(m_MUIHeader.wstrFieName, sizeof (m_MUIHeader.wstrFieName)/ sizeof(WCHAR),
                          pwstrBuffer);
    if ( ! SUCCEEDED(hr)){
        _tprintf("Safe string copy Error\n");
        return FALSE;
    }

    // This should be done in Constructor of CMUIFile       
    // pcmui->m_MUIHeader.wHeaderSize = sizeof UP_COMPACT_MUI;
    WORD wTempHeaderSize = m_MUIHeader.wHeaderSize;

    BYTE bPadding = DWORD_ALIGNMENT(wTempHeaderSize) - wTempHeaderSize;
        // add padding at end of file name as null character.
    memcpy(m_MUIHeader.wstrFieName + wcslen(m_MUIHeader.wstrFieName) 
        + sizeof (WCHAR)/2 , "\0", bPadding);

        // file length include; file string + null character + padding (null character as well)
    m_MUIHeader.wFileNameLenWPad = wcslen(m_MUIHeader.wstrFieName) + (sizeof WCHAR)/2 + bPadding/2;

    m_MUIHeader.wHeaderSize += m_MUIHeader.wFileNameLenWPad; // we have to adjust file name buffer.

    CloseHandle(hFile);
    CloseHandle(hMappedFile);
}
#endif

BOOL CMUIFile::getChecksumAndVersion (LPCTSTR pszMUIFile, unsigned char **ppMD5Checksum, DWORD *dwFileVersionMS, DWORD *dwFileVersionLS )
/*++
Abstract:
    getChecksumAndVersion  -  Get the cehckesum data/version from the MUI file, which will be saved in the CMF header
    as MUI informatio; this can improve MUI loader burden to search checksum/version infomatio of MUI file

Arguments:
    pszMUIFile  -  MUI file
    [OUT] ppMD5Checksum  - checksum data will be stored in this
    [OUT] dwFileVersionMS   -  FileversionMS will be stored in this
    [OUT] dwFileVersionLS   -  FileversionSS will be stored in this
Return:
    true/false
--*/
{
    typedef struct tagVS_FIXEDFILEINFO
    {
        LONG   dwSignature;            /* e.g. 0xfeef04bd */
        LONG   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
        LONG   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
        LONG   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
        LONG   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
        LONG   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
        LONG   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
        LONG   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
        LONG   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
        LONG   dwFileType;             /* e.g. VFT_DRIVER */
        LONG   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
        LONG   dwFileDateMS;           /* e.g. 0 */
        LONG   dwFileDateLS;           /* e.g. 0 */
    } VS_FIXEDFILEINFO;

    typedef struct 
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];              // L"VS_VERSION_INFO" + unicode null terminator
        // Note that the previous 4 members has 16*2 + 3*2 = 38 bytes. 
        // So that compiler will silently add a 2 bytes padding to make
        // FixedFileInfo to align in DWORD boundary.
        VS_FIXEDFILEINFO FixedFileInfo;
    } RESOURCE, *PRESOURCE; //*Resource;
    
     typedef struct tagVERBLOCK
    {
        USHORT wTotalLen;
        USHORT wValueLen;
        USHORT wType;
        WCHAR szKey[1];
        // BYTE[] padding
        // WORD value;
    } VERBLOCK,*pVerBlock;
    
     if (pszMUIFile == NULL || ppMD5Checksum == NULL || dwFileVersionMS == NULL 
         || dwFileVersionLS == NULL) {
         return FALSE;
        }
#ifdef NEVER
    //
    // Get VersionInfo structure.
    //
    DWORD dwHandle;

    DWORD dwVerSize = GetFileVersionInfoSize( (LPTSTR)pszMUIFile, &dwHandle);

    HLOCAL hLocal = LocalAlloc(LMEM_ZEROINIT, dwVerSize ); 

    LPVOID lpVerRes = LocalLock(hLocal);
    
    DWORD dwError = GetLastError();

    if ( ! GetFileVersionInfo((LPTSTR)pszMUIFile, 0 ,dwVerSize, lpVerRes) ) {
        _tprintf(_T("Fail to get file version: GetLastError() : %d \n"),GetLastError() ) ;
        return TRUE;
    }
    
    if (lpVerRes)
    {
        PRESOURCE pResBase = (PRESOURCE) lpVerRes;

        DWORD ResourceSize = dwVerSize;
                    
        if((ResourceSize < sizeof(RESOURCE))
            || _wcsicmp(pResBase->Name,L"VS_VERSION_INFO") != 0) 
        {
            CError ce;
            ce.ErrorPrint(_T("CMUIFile::GetCheckSum"), _T("Invalid Version resource") );
            return FALSE; 
        }
        ResourceSize -= sizeof (RESOURCE);
        //                //
        // Get the beginning address of the children of the version information.
        //
        VERBLOCK* pVerBlock = (VERBLOCK*)(pResBase + 1);
        DWORD BlockLen = 0;
        DWORD VarFileInfoSize = 0;

        while (ResourceSize > 0)
        {        
            if (wcscmp(pVerBlock->szKey, L"VarFileInfo") == 0)
            {
                //
                // Find VarFileInfo block. Search the ResourceChecksum block.
                // 
                VarFileInfoSize = pVerBlock->wTotalLen;
                BlockLen =DWORD_ALIGNMENT(sizeof(*pVerBlock) -1 + sizeof(L"VarFileInfo"));
                VarFileInfoSize -= BlockLen;
                pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
                while (VarFileInfoSize > 0)
                {
                    if (wcscmp(pVerBlock->szKey, L"ResourceChecksum") == 0)
                    {
                        memcpy(*ppMD5Checksum,(unsigned char*)DWORD_ALIGNMENT(PtrToLong(pVerBlock->szKey) + sizeof(L"ResourceChecksum"), 16);

                        return TRUE;
                    }
                    BlockLen = DWORD_ALIGNMENT(pVerBlock->wTotalLen);
                    pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
                    VarFileInfoSize -= BlockLen;
                }
                return FALSE;
            }
            BlockLen = DWORD_ALIGNMENT(pVerBlock->wTotalLen);
            pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
            ResourceSize -= BlockLen;
                    
        }
    }

#endif
//#ifdef NEVER

    HMODULE  hModule = LoadLibraryEx(pszMUIFile, NULL, LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES );
    DWORD dwError = GetLastError();
    if ( hModule )
    {
        HRSRC hrSrc = FindResource(hModule, MAKEINTRESOURCE(1), RT_VERSION);

        if (hrSrc)
        {
            HGLOBAL hgRes = LoadResource(hModule, hrSrc);
            
            if (hgRes)
            {
                PRESOURCE pResBase = (PRESOURCE)LockResource(hgRes);

                if (pResBase) 
                {
                    DWORD ResourceSize = SizeofResource(hModule, hrSrc);
                    
                    if((ResourceSize < sizeof(RESOURCE))
                        || _wcsicmp(pResBase->Name,L"VS_VERSION_INFO") != 0) 
                    {
                        CError ce;
                        ce.ErrorPrint(_T("CMUIFile::GetCheckSum"), _T("Invalid Version resource") );
                        goto failure; 
                    }
                    *dwFileVersionMS = pResBase->FixedFileInfo.dwFileVersionMS;
                    *dwFileVersionLS = pResBase->FixedFileInfo.dwFileVersionLS;

                    ResourceSize -= sizeof (RESOURCE);
                    //                //
                    // Get the beginning address of the children of the version information.
                    //
                    VERBLOCK* pVerBlock = (VERBLOCK*)(pResBase + 1);
                    DWORD BlockLen = 0;
                    DWORD VarFileInfoSize = 0;

                    while (ResourceSize > 0)
                    {        
                        if (wcscmp(pVerBlock->szKey, L"VarFileInfo") == 0)
                        {
                            //
                            // Find VarFileInfo block. Search the ResourceChecksum block.
                            // 
                            VarFileInfoSize = pVerBlock->wTotalLen;
                            BlockLen =DWORD_ALIGNMENT(sizeof(*pVerBlock) -1 + sizeof(L"VarFileInfo"));
                            VarFileInfoSize -= BlockLen;
                            pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
                            while (VarFileInfoSize > 0)
                            {
                                if (wcscmp(pVerBlock->szKey, L"ResourceChecksum") == 0)
                                {
                                    PBYTE pbTempChecksum = (unsigned char*)DWORD_ALIGNMENT(PtrToLong(pVerBlock->szKey) + sizeof(L"ResourceChecksum"));
                                    memcpy(*ppMD5Checksum, pbTempChecksum, 16);
                                    
                                    goto success;
                            
                                }
                                BlockLen = DWORD_ALIGNMENT(pVerBlock->wTotalLen);
                                pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
                                VarFileInfoSize -= BlockLen;
                            }
                            goto failure;
                            
                        }
                        BlockLen = DWORD_ALIGNMENT(pVerBlock->wTotalLen);
                        pVerBlock = (VERBLOCK*)((unsigned char*)pVerBlock + BlockLen);
                        ResourceSize -= BlockLen;
                    }  // if (pResBase) 
                } // if (hgRes)
            }  // if (Resource) 
        }   // if (hrSrc)
    }   // if ( hModule )
    
//#endif 

failure:
    FreeLibrary(hModule);
    return FALSE;

success:
    FreeLibrary(hModule);
    return TRUE;


};

BOOL CMUIFile::WriteMUIFile(CMUIFile *pcmui)
/*++
Abstract:
    Create and write a new MUI file with a data in CMUIFile.

Arguments:
    pcmui  -  CMUIFile class,which should be filled by data

Return:
--*/
{
    if (pcmui == NULL)
        return FALSE;

    HANDLE hFile = CreateFile(pcmui->m_strFileName, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
        CError ce;
        ce.ErrorPrint(_T("CCompactMUIFile::WriteMUIFile"),_T("Failure of CreateFile()"));
        return FALSE;
    }

    DWORD dwWritten;

    if ( WriteFile(hFile, pcmui->m_pbImageBase, pcmui->m_MUIHeader.dwFileSize, &dwWritten, NULL) )
    {   
        CloseHandle(hFile);
        return TRUE;
    }

    CloseHandle(hFile);
    return FALSE;
    
};



LPCTSTR CMUIFile::GetFileNameFromPath(LPCTSTR pszFilePath)
{
    if ( pszFilePath == NULL)
        return FALSE;
    //
    // Get file name from the path
    //

    DWORD dwLen = _tcslen(pszFilePath);
    // d:\test\test.exe.mui  //
    while(dwLen--)
    {
        if (pszFilePath[dwLen] == '\\')
        {
            return pszFilePath+dwLen+1;
            
        }
        
    }

    return pszFilePath;
}

#ifdef NEVER
BOOL CMUIFile::getFileVersion(LPCTSTR pszMuiFile, DWORD *dwFileVersionMS, DWORD *dwFileVersionLS)
/*++
Abstract:
    get file version.
Arguments:

Return:
--*/
{
    if ( pszMuiFile == NULL || dwFileVersionMS == NULL || dwFileVersionLS == NULL)
        return FALSE;

    typedef struct tagVS_FIXEDFILEINFO
    {
        LONG   dwSignature;            /* e.g. 0xfeef04bd */
        LONG   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
        LONG   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
        LONG   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
        LONG   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
        LONG   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
        LONG   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
        LONG   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
        LONG   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
        LONG   dwFileType;             /* e.g. VFT_DRIVER */
        LONG   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
        LONG   dwFileDateMS;           /* e.g. 0 */
        LONG   dwFileDateLS;           /* e.g. 0 */
    } VS_FIXEDFILEINFO;

    typedef struct 
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR Name[16];              // L"VS_VERSION_INFO" + unicode null terminator
        // Note that the previous 4 members has 16*2 + 3*2 = 38 bytes. 
        // So that compiler will silently add a 2 bytes padding to make
        // FixedFileInfo to align in DWORD boundary.
        VS_FIXEDFILEINFO FixedFileInfo;
    }  RESOURCE, *PRESOURCE; //*Resource;

     HMODULE  hModule = LoadLibraryEx(pszMuiFile, NULL, LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES );
    if ( hModule )
    {
        HRSRC hrSrc = FindResource(hModule, MAKEINTRESOURCE(1), RT_VERSION);

        if (hrSrc)
        {
            HGLOBAL hgRes = LoadResource(hModule, hrSrc);
            if (hgRes)
            {
                PRESOURCE pResBase = (PRESOURCE)LockResource(hrSrc);
 
                if (pResBase) 
                {
                    DWORD ResourceSize = SizeofResource(hModule, hrSrc);
                    
                    if((ResourceSize < sizeof(RESOURCE))
                        || _wcsicmp(pResBase->Name,L"VS_VERSION_INFO") != 0) 
                    {
                        CError ce;
                        ce.ErrorPrint(_T("CMUIFile::getFileVersion"), _T("Invalid Version resource") );
                        goto failure; 
                    }
                    
                    *dwFileVersionMS = pResBase->FixedFileInfo.dwFileVersionMS;
                    *dwFileVersionLS = pResBase->FixedFileInfo.dwFileVersionLS;
                    
                    goto success;
                } // if (Resource)
            } // if (hgRes)
        } //if (hrSrc)
    }//if ( hModule )

success:
    FreeLibrary(hModule);
    return TRUE;

failure:
    FreeLibrary(hModule);
    return FALSE;
    
}



#endif

////////////////////////////////////////////////////////////////////////////////////
//
// CError Class
//
///////////////////////////////////////////////////////////////////////////////////
void CError::ErrorPrint(PSTR pszErrorModule, PSTR pszErrorLocation, PSTR pszFile /* = NULL */)
/*++
Abstract:
    print error information.

Arguments:
    pszErrorModule  -  The function name of error taking place
    pszErrorLocation  -  The location in the function of error taking place
    pszFile  - problematic file, which is used only by file related error such as CreateFile

Return:
--*/
{
    // REVISIT; create Log file.
    if (pszErrorModule == NULL || pszErrorLocation == NULL) 
        return ;

    _tprintf(_T(" %s, %s, %s \n"), pszFile ? pszFile : _T(" "), pszErrorModule, pszErrorLocation);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\muirct.h ===
#include <windows.h>   
#include <winbase.h>   // windows API

#include <tchar.h>	   // Unicode / Ansi support with TCHAR
#include <assert.h>    // ASSERT 

#include <stdlib.h>
#include <stdio.h>

// MD5 hash
#include <md5.h>

// safe string func.
#include <strsafe.h>

#define MUIRCT_STRSAFE_NULL  STRSAFE_FILL_BEHIND_NULL | STRSAFE_NULL_ON_FAILURE
#define   RESOURCE_CHECKSUM_SIZE 16

// #include <vector>	   // STL : vector
// #include <string>		// STL : basic_string< CHAR >

// using namespace std ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\muirct.cpp ===
/*****************************************************************************
    
  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.

  Module Name:

   muirct.cpp

  Abstract:

    The main funtion of muirct program

  Revision History:

    2001-10-01    sunggch    created.

Revision.

*******************************************************************************/


#include "muirct.h"
#include "res.h"
//#include "resource.h"
#include "cmf.h"

#define MAX_NUM_RESOURCE_TYPES    40
#define LANG_CHECKSUM_DEFAULT     0x409

BOOL GetFileNames(CMuiCmdInfo* pcmci, LPTSTR * pszSource, LPTSTR * pszNewFile, LPTSTR * pszMuiFile )
/*++
Abstract:
    Get the file names from the CMuiCmdInfo.
    
Arguments:
    pcmci  -  CMuiCmdInof object; has values of these files..
    pszSource  -  destination of source file
    pszNewFile  -  destination of new dll, which is same with source file without selected resource
    pszMuiRes  -  destination of new mui file.
Return:
    TRUE/FALSE
--*/
{

    DWORD dwCount = 0;
    LPTSTR *ppsz = NULL;

    if ( pcmci == NULL || pszSource == NULL || pszNewFile == NULL || pszMuiFile == NULL)
        return FALSE;

    ppsz = pcmci ->GetValueLists (_T("source"),dwCount );
    if ( ! ppsz ) {
    
        return FALSE;
    }
    *pszSource = *ppsz;

    ppsz = pcmci ->GetValueLists (_T("muidll"), dwCount );
    if ( ! ppsz ) {
    
        return FALSE;
    }
    *pszNewFile = *ppsz;

    ppsz = pcmci ->GetValueLists (_T("muires"), dwCount );
    if ( ! ppsz ) {
    
        return FALSE;
    }
    *pszMuiFile = *ppsz;

    return TRUE;

}


BOOL  FilterRemRes ( cvcstring * cvRemovedResTypes, LPTSTR * ppRemoveRes,  const UINT dwRemoveCount, BOOL fSanityCheck ) 
/*++
Abstract:
    Compare the resource types between cvRemovedResTypes and ppRemoveRes, and leave the ppRemoveRes values in the 
    cvRemovedResTypes

Arguments:
    cvRemovedResTypes - contains a resources types, which will be trimmed by ppRemoveRes
    ppRemoveRes - new resource types
    dwRemoveCount - number of count in ppRemoveRes

Return:
    true/false
--*/
{
    DWORD dwCountofSameTypes =0;
    cvcstring * cvRemovedResTypesTemp = NULL;

    if ( cvRemovedResTypes == NULL || ppRemoveRes == NULL)
        return FALSE;

    cvRemovedResTypesTemp = new cvcstring(MAX_NUM_RESOURCE_TYPES);

    if (!cvRemovedResTypesTemp)
	return FALSE;
    
    for (UINT i = 0; i < cvRemovedResTypes -> Size() ; i ++ ) {
            
        BOOL fIsResourceSame = FALSE ;
        
        LPCTSTR lpResourceTypeInFile = cvRemovedResTypes->GetValue(i);
        
        for (UINT j = 0; j < dwRemoveCount; j ++ ) {
           
            if (  0xFFFF0000 & PtrToUlong(lpResourceTypeInFile ) ) { // strings
                    if (! _tcsicmp(ppRemoveRes[j],lpResourceTypeInFile ) ) {
                    fIsResourceSame = TRUE;     // remove resours has value
                    break;
                }
            }
            else {
                
                if (! ( _tcstod (ppRemoveRes[j],NULL ) - (DWORD)PtrToUlong(lpResourceTypeInFile) ) ) {
                    
                    fIsResourceSame = TRUE;     // remove resource has value
                    
                    break;
                }
            }
            
        }
            
        if (fIsResourceSame) {
            // we need to keep the order of resource types in cvRemovedResTypes because it affects
            // checksum
            cvRemovedResTypesTemp -> Push_back(cvRemovedResTypes -> GetValue (i) );
            dwCountofSameTypes++;
        }
            
    }
       
    if (fSanityCheck && (dwCountofSameTypes < dwRemoveCount) )
    {
        _tprintf(_T(" One of resource types isn't contained target source files\n"));
        _tprintf(_T(" You can avoid type check when you use -o argument\n"));
        _tprintf(_T(" Standard Resource Types: CURSOR(1) BITMAP(2) ICON(3) MENU(4) DIALOG(5)\n") );
        _tprintf(_T(" STRING(6) FONTDIR(7) FONT(8) ACCELERATORS(9) RCDATA(10) MESSAGETABLE(11)\n") );
        _tprintf(_T(" GROUP_CURSOR(12) GROUP_ICON(14) VERSION(16)\n") );
        delete cvRemovedResTypesTemp;
        return FALSE; 
    }

    cvRemovedResTypes -> Clear();
    
    for ( i = 0; i < cvRemovedResTypesTemp ->Size(); i ++ )
    {
        cvRemovedResTypes ->Push_back ( cvRemovedResTypesTemp ->GetValue( i ) ); 
    }
    delete cvRemovedResTypesTemp;
        
    return TRUE;

}




cvcstring * FilterKeepRes ( cvcstring * cvRemovedResTypes, LPTSTR * ppKeepRes,  cvcstring * cvKeepResTypes, UINT dwKeepCount, BOOL fSanityCheck ) 
/*++
Abstract:
    Fill cvKeepResTypes(cvcstring type) and check values existence inside cvRemovedResTypes(removed resource types) then 
    return error when fSanityCheck is true.

Arguments:
    cvRemovedResTypes  -  contains a resources types, which will be trimmed by ppRemoveRes
    ppKeepRes  -  new resource types
    dwRemoveCount  -  number of count in ppRemoveRes
    cvKeepResTypes  -  filtered resource types will be saved.
    fSanityCheck  -  do sanity check if it is true.

Return:
    cvcstring, which include resource that should be removed.
--*/
{
    cvcstring * cvRemovedResTypesTemp = NULL;
    
    if ( cvRemovedResTypes == NULL || ppKeepRes == NULL || cvKeepResTypes == NULL)
        return FALSE;

    cvRemovedResTypesTemp = new cvcstring(MAX_NUM_RESOURCE_TYPES);

    BOOL fRet;
    //
    // this is just checking if value of -k is included in the -i value.
    //
    if (fSanityCheck) {
        for ( UINT i = 0; i < dwKeepCount; i ++ ) {
            fRet = TRUE ;
            
            for (UINT j = 0; j < cvRemovedResTypes -> Size(); j ++ ) {
                
                LPCTSTR lpResourceTypeInFile = cvRemovedResTypes->GetValue(j);
                
                if (  0xFFFF0000 & PtrToUlong(lpResourceTypeInFile ) ) { // strings
                    
                    if (! _tcsicmp(ppKeepRes[i],lpResourceTypeInFile ) ) {
            
                        fRet = FALSE;     // remove resource has value
                        
                        break;
                    }
                }
                else {
                    
                    if (! ( _tcstoul (ppKeepRes[i],NULL,10 ) - (DWORD)PtrToUlong(lpResourceTypeInFile ) ) ) {
                        
                        fRet = FALSE;     // remove resours has value
                        
                        break;
                    }
                }
                
            }

            if ( fRet ) {
                
                _tprintf(_T(" Resource Type %s does not exist in the -i value or file, \n "), ppKeepRes[i] );
                _tprintf(_T("You can't use this value for -k argument") );
                
                return NULL; 
            };

        }
    }
    //
    //  Delete -k argument value from -i value lists
    //
    for ( UINT i = 0; i < cvRemovedResTypes->Size(); i ++ ) {
            
        fRet = TRUE;
        
        LPCTSTR lpResourceTypeInFile = cvRemovedResTypes->GetValue(i); 

        for ( UINT j = 0; j < dwKeepCount; j ++ ) {
            
            if (  0xFFFF0000 & PtrToUlong(lpResourceTypeInFile ) ) { // REVISIT for Win64 . e.g. xxxxxxxx000000000
                
                if (! _tcsicmp(ppKeepRes[j],lpResourceTypeInFile ) ) {
        
                    fRet = FALSE;     // remove resource has value
                    
                    break;
                }
            }
            else {
                
                if (! ( _tcstoul(ppKeepRes[j],NULL,10 ) - (DWORD)PtrToUlong(cvRemovedResTypes->GetValue(i) ) ) ) {
                    
                    fRet = FALSE;     // remove resours has value
                    
                    break;
                }
                                
            }
                
        }

        if ( !fRet ) { 
            cvKeepResTypes ->Push_back(lpResourceTypeInFile);
        }
        else {
            cvRemovedResTypesTemp->Push_back(lpResourceTypeInFile);// -i value, which is not in the -k value
        }

    }
    // if all values in -i and -k (-y) are identical.
    if (! cvRemovedResTypesTemp->Size() )
        return NULL;

    return cvRemovedResTypesTemp;

}

/*************************************************************************************
void CheckTypePairs( cvstring * cvRemovedResTypes, cvstring * cvKeepResTypes )





return : no.

**************************************************************************************/

void CheckTypePairs( cvcstring * cvRemovedResTypes, cvcstring * cvKeepResTypes ) 
/*++
Abstract:
    Some resource type should be pairs, in this case  <1, 12 > < 3, 14>.

Arguments:
    cvRemovedResTypes  -  resource types of being removed 
    cvKeepResTypes  -  resource types of being mui created but not removed.

Return:
    none
--*/
{

    if (cvRemovedResTypes == NULL || cvKeepResTypes == NULL)
        return ;

    if ( cvRemovedResTypes->Find((DWORD)3) && ! cvRemovedResTypes->Find((DWORD)14) ) {
        cvRemovedResTypes->Push_back( MAKEINTRESOURCE(14) );
    }
    else if ( ! cvRemovedResTypes->Find(3) && cvRemovedResTypes->Find(14) ) {
        cvRemovedResTypes->Push_back( MAKEINTRESOURCE(3) );
    }
    if ( cvRemovedResTypes->Find(1) && ! cvRemovedResTypes->Find(12) ) {
        cvRemovedResTypes->Push_back( MAKEINTRESOURCE(12) );
    }
    else if ( ! cvRemovedResTypes->Find(1) && cvRemovedResTypes->Find(12) ) {
        cvRemovedResTypes->Push_back( MAKEINTRESOURCE(1) );
    }
    if ( cvKeepResTypes->Find((DWORD)3) && ! cvKeepResTypes->Find((DWORD)14) ) {
        cvKeepResTypes->Push_back( MAKEINTRESOURCE(14) );
    }
    else if ( ! cvKeepResTypes->Find(3) && cvKeepResTypes->Find(14) ) {
        cvKeepResTypes->Push_back( MAKEINTRESOURCE(3) );
    }
    if ( cvKeepResTypes->Find(1) && ! cvKeepResTypes->Find(12) ) {
        cvKeepResTypes->Push_back( MAKEINTRESOURCE(12) );
    }
    else if ( ! cvKeepResTypes->Find(1) && cvKeepResTypes->Find(12) ) {
        cvKeepResTypes->Push_back( MAKEINTRESOURCE(1) );
    }

}

#ifdef NEVER

BOOL CompareArgValues(cvcstring *  cvAArgValues, cvcstring *  cvBArgValues) 
/*++
Abstract:
    Comapre the values of arguments

Arguments:
    cvAArgValues : values of arugments
    cvBArgValues : values of arugments

Return:
    true/false
--*/
{
  
    if (cvAArgValues == NULL || cvBArgValues == NULL)
        return FALSE;
//
// compare its values by while routine because values is initialzed NULL in the CMUICmdInfo.
//
    LPTSTR * ppSrcValues = cvAArgValues;
    LPTSTR * ppDestValues = cvBArgValues;
    BOOL fNotIdentical = FALSE;

    for (UINT i = 0; i < cvAArgValues
    while (ppSrcValues ) {
        while ( ppDestValues ) {
            if ( _tcsicmp(*ppSrcValues,*ppDestValues) ) {
                fNotIdentical = TRUE;
            }
            ppDestValues ++;
        }
        ppSrcValues;
    }

    return fNotIdentical;

}

#endif


/******************************************************************************************************
BOOL CompactMui(CMuiCmdInfo* pcmci)


*******************************************************************************************************/
BOOL CompactMui(CMuiCmdInfo* pcmci) 
/*++
Abstract:
    Called by main to call CCompactMUIFile for compacting mui files.

Arguments:
    pcmci  -  arguments parser class.
    
Return:
    true/false
--*/
{
    if ( pcmci == NULL)
        return FALSE;
    //
    // Read the arguments list
    //
    LPTSTR *ppszMuiFiles = NULL;
    LPTSTR *ppszCMFFile = NULL;
    LPTSTR *ppszCodeFileDir = NULL;
    CCompactMUIFile *pccmf = NULL;

    DWORD dwcMuiFiles = 0;
    DWORD dwCount = 0;
    

    ppszMuiFiles = pcmci->GetValueLists(_T("m"), dwcMuiFiles);

    if (! (ppszCMFFile = pcmci->GetValueLists(_T("f"),dwCount) ))
    {
        CError ce;
        ce.ErrorPrint(_T("CompactMui"),_T("return NULL at pcmci->GetValueLists(_T(f),dwCount)") );
        return FALSE;
    }

    if(! (ppszCodeFileDir = pcmci->GetValueLists(_T("e"),dwCount)) )
    {
        CError ce;
        ce.ErrorPrint(_T("CompactMui"),_T("return NULL at pcmci->GetValueLists(_T(e),dwCount)") );
        return FALSE;
    }

    //
    // Create CCompactMUIFile and write files.
    // 

    pccmf = new CCompactMUIFile;

    if(!pccmf)
    	return FALSE;

    if (pccmf->Create(*ppszCMFFile, ppszMuiFiles, dwcMuiFiles) )
    {

        if (pccmf->WriteCMFFile())
        {
            if (pccmf->UpdateCodeFiles(*ppszCodeFileDir, dwcMuiFiles ))
            {
                delete pccmf;
                return TRUE;
            }
        }
    }

    if(pccmf)
	    delete pccmf;

    return FALSE;

}


BOOL UnCompactMui(PSTR pszCMFFile)
/*++
Abstract:
    Calling CCompactMUIFile for uncompact files

Arguments:
    pszCMFFile  -  CMF file, which will be uncompacted to indivisual MUI files.

Return:
    true/false
--*/
{
    BOOL bRet = FALSE;
    CCompactMUIFile *pccmf = NULL;
    
    if (pszCMFFile == NULL)
        return FALSE;
    //
    // Call CCompactMUIFile::UnCompactMUI
    //

    pccmf = new CCompactMUIFile();

    if(!pccmf)
    	goto exit;
    
    if ( pccmf->UnCompactCMF(pszCMFFile))
    {
        pccmf->WriteCMFFile();

        bRet = TRUE;
        // REVIST ; how about uddating a binary files.
    }

exit:
	if (pccmf)
		delete pccmf;

	return bRet;

}

BOOL DisplayHeader(PSTR pszCMFFile)
/*++
Abstract:
    Calling CCompactMUIFile for displaying the CMF headers information

Arguments:
    pszCMFFile - CMF file.

Return:
    true/false
--*/
{
   BOOL bRet = FALSE;
   CCompactMUIFile *pccmf = NULL;
   
    if (pszCMFFile == NULL)
        return FALSE;

    pccmf = new CCompactMUIFile();

    if(!pccmf)
    	goto exit;
    
    if( pccmf->DisplayHeaders(pszCMFFile) )
    {
        bRet = TRUE;

    }

exit:
	if (pccmf)
		delete pccmf;

	return bRet;

}


BOOL AddNewMUIFile(CMuiCmdInfo* pcmci)
/*++
Abstract:
    Calling CCompactMUIFile for adding MUI files into exsiting CMF file.

Arguments:
    pcmci  -  argument parser class

Return:
    true/false
--*/
{
    if (pcmci == NULL)
        return FALSE;
  
    // Read the arguments list
    //
    LPTSTR *ppszNewMuiFile = NULL;
    LPTSTR *ppszCMFFile = NULL;
    LPTSTR *ppszCodeFileDir = NULL;
    CCompactMUIFile *pccmf = NULL;
    
    DWORD dwcMuiFiles = 0;
    DWORD dwCount = 0;

    BOOL bRet = FALSE;
    
    // we don't have to check if it has value for this routine is called by the "a" arg. existence
    ppszNewMuiFile = pcmci->GetValueLists(_T("a"), dwcMuiFiles);

    if (! (ppszCMFFile = pcmci->GetValueLists(_T("f"),dwCount) ))
    {
        CError ce;
        ce.ErrorPrint(_T("CompactMui"),_T("return NULL at pcmci->GetValueLists(_T(f),dwCount)") );
        goto exit;
    }

    if(! (ppszCodeFileDir = pcmci->GetValueLists(_T("e"),dwCount)) )
    {
        CError ce;
        ce.ErrorPrint(_T("CompactMui"),_T("return NULL at pcmci->GetValueLists(_T(e),dwCount)") );
        goto exit;
    }

    //
    // Add new mui file into existing cmf file.
    //


    pccmf = new CCompactMUIFile;

    if(!pccmf)
    	goto exit;
    
    // TCHAR pszCMFName[MAX_PATH];
    if (pccmf->AddFile(*ppszCMFFile, ppszNewMuiFile, dwcMuiFiles ) )
    {   
    //  _tcscpy(pszCMFName, *ppszCMFFile);
        if( pccmf->Create(*ppszCMFFile))
        {
            if (pccmf->WriteCMFFile())
            {
                if (pccmf->UpdateCodeFiles(*ppszCodeFileDir, dwcMuiFiles ))
                {
                    bRet = TRUE;
                    goto exit;
                 }
            }
        }
    }

    _tprintf(_T("Error happened on   AddNewMUIFile, GetLastError(): %ld"), GetLastError() );      

exit:
    if (pccmf)
	    delete pccmf;

    return bRet;
    
}

BOOL AddChecksumToFile(CMuiCmdInfo* pcmci)
/*++
Abstract:
    Adding checksum to external component. this is separted feature

Arguments:
    pcmci  -  arguments parser class

Return:
    true/false
--*/
{
    cvcstring * cvKeepResTypes= NULL;
    CMUIResource * pcmui = NULL;
    
    BOOL bRet = FALSE;
    if( pcmci == NULL ) {
        return FALSE;
    }

    LPTSTR *ppChecksumFile = NULL;
    LPTSTR *ppszTargetFileName = NULL;
    DWORD dwCount, dwRemoveCount, dwRemoveCountNoSanity;

    ppszTargetFileName = pcmci->GetValueLists(_T("z"), dwCount);

    if (!(ppChecksumFile=pcmci->GetValueLists(_T("c"), dwCount)))
    {
        _tprintf(_T("Checksum file NOT exist"));
        goto exit;
    }
    
    LPTSTR * ppRemoveRes = pcmci ->GetValueLists (_T("i"), dwRemoveCount  );  // pszTmp would be copied to pszRemove

    LPTSTR * ppRemoveResNoSanity = pcmci ->GetValueLists (_T("o"), dwRemoveCountNoSanity  );

    //
    // Create CMUIResource, which is main class for mui resource handling.
    //
    pcmui = new CMUIResource();

    if(!pcmui)
    	goto exit;

    // load checksum file
    if (! pcmui -> Create(*ppChecksumFile )) // load the file for EnumRes..
        goto exit;
    //
    // Reorganise removing resource types.
    // 
    cvcstring * cvRemovedResTypes = pcmui -> EnumResTypes (reinterpret_cast <LONG_PTR> ( pcmui )); // need to change : return LPCTSTR* rather than CVector;
    
    if ( cvRemovedResTypes -> Empty() ) {
        
        _tprintf(_T("The %s does not contain any resource \n"), *ppChecksumFile );
        goto exit;

    }
    else {
        // when there is remove argument and its value e.g. -i 3 4 Anvil ..
        if ( dwRemoveCount && !!_tcscmp(*ppRemoveRes,_T("ALL") ) ) {
            
            if (! FilterRemRes(cvRemovedResTypes,ppRemoveRes,dwRemoveCount, TRUE ) ) {
               goto exit;
            }
        
        }   //if ( dwRemoveCount && _tcscmp(*ppRemoveRes,_T("ALL") ) ){
        else if (dwRemoveCountNoSanity)
        {
            // This is -o arg. build team does not know what resource type are included in the module, so 
            // they use localizable resource, but -i return false when specified resourc type is not found in the
            // module. -o does not check sanity of resource type like -i arg.
            if (! FilterRemRes(cvRemovedResTypes, ppRemoveResNoSanity, dwRemoveCountNoSanity, FALSE ) ) {
                goto exit;
            }

        }
        // Stop if source only includes type 16. very few case, so use couple of api instead moving the module to front.
        if (cvRemovedResTypes->Size() == 1 && ! ( PtrToUlong(cvRemovedResTypes->GetValue(0)) - 16 )  ) {
            _tprintf(_T("The %s contains only VERSION resource \n"), *ppChecksumFile );
            goto exit;
        }
    
    }  // cvRemovedResTypes.Empty()

    
    //
    // Some resource should be pairs <1, 12> <3, 14>
    //

    // we create bogus cvKeepResTypes for calling exisiting ChecktypePairs routine.
    cvKeepResTypes = new cvcstring (MAX_NUM_RESOURCE_TYPES);

    if(!cvKeepResTypes)
    	goto exit;
    
    CheckTypePairs(cvRemovedResTypes, cvKeepResTypes);
  
    //
    // Create a checksum data
    //
    MD5_CTX * pMD5 = NULL;
    BYTE   pbMD5Digest[RESOURCE_CHECKSUM_SIZE];
    DWORD dwLangCount =0;
        
    LPTSTR *ppChecksumLangId = pcmci ->GetValueLists (_T("b"), dwLangCount);
    WORD  wChecksumLangId = LANG_CHECKSUM_DEFAULT;
    
    if (dwLangCount)
    {
        wChecksumLangId = (WORD)strtoul(*ppChecksumLangId, NULL, 0);
    }


    pMD5 = pcmui-> CreateChecksum(cvRemovedResTypes, wChecksumLangId);
#ifdef CHECKSMU_ALL
    pMD5 = pcmui-> CreateChecksumWithAllRes(wChecksumLangId);
#endif
    memcpy(pbMD5Digest, pMD5->digest, RESOURCE_CHECKSUM_SIZE);

    pcmui -> FreeLibrary();

    //
    // Add a checksum data to target file
    //
    if ( !pcmui->Create(*ppszTargetFileName))
        goto exit;

    if (! pcmui->AddChecksumToVersion(pbMD5Digest) ) {  //add checksum into MUI file
        _tprintf(_T("Fail to add checksum to version ( %s)\n"),*ppszTargetFileName );
        goto exit;
    }
    pcmui -> FreeLibrary();

    bRet = TRUE;
    
exit:
    if (pcmui)
    	delete pcmui;
    return bRet;
    
}


/*************************************************************************************************************
void _cdecl main (INT argc, void * argv[] )

  

**************************************************************************************************************/
void _cdecl main (INT argc, void * argv[] ) 

{

    WORD     wLangID;
    CMuiCmdInfo* pcmci = NULL;
    CMUIResource * pcmui = NULL;
    cvcstring * cvKeepResTypes = NULL;
    cvcstring * cvKeepResTypesIfExist = NULL;
    cvcstring * vRemnantRes = NULL;
    CMUIResource * pcmui2 = NULL;
        
    pcmci = new CMuiCmdInfo;
    if (!pcmci)
    	goto exit;
    
    //
    // SetArgLists(Arglist, NeedValue, AllowFileValue, AllowMultipleFileValue)
    //
    pcmci->SetArgLists(_T("abcdefiklmopuvxyz"),_T("abcdefklmopuvyz"), _T("acdefmuz"), _T("am")); //set arg. lists.
                           
    if (! pcmci->CreateArgList (argc,(TCHAR **) argv  ) ) {
        
        goto exit;
    }

    DWORD   dwCount  = 0;
    if ( pcmci->GetValueLists(_T("m"),dwCount ) ){
        CompactMui(pcmci);
        goto exit;
    }

    if ( pcmci->GetValueLists(_T("a"),dwCount ) ){
        AddNewMUIFile(pcmci);
        goto exit;
    }

    LPTSTR *ppCMFFile = NULL;
    if ( ppCMFFile = pcmci->GetValueLists(_T("u"),dwCount ) ){
        UnCompactMui(*ppCMFFile);
        goto exit;
    }

    if ( ppCMFFile = pcmci->GetValueLists(_T("d"),dwCount ) ){
         DisplayHeader(*ppCMFFile);
         goto exit;
    }

    if (pcmci->GetValueLists(_T("z"),dwCount ) ){
        AddChecksumToFile(pcmci);
        goto exit;
    }
    
    //
    // Fill the CMUIResource intenal data : we don't care languge at this time, but soon add more code to
    //
    // handle the languge case.
    LPCTSTR lpLangID = NULL;
    LPTSTR * ppsz = NULL;
    BOOL fForceLocalizedLangID = FALSE;

    if ( ppsz = pcmci ->GetValueLists (_T("l"), dwCount ) ) {

        lpLangID = *ppsz;
        wLangID =  (WORD)_tcstol(lpLangID, NULL, 0 );
        
    }
    else if(ppsz = pcmci ->GetValueLists (_T("x"), dwCount ) ) {
        lpLangID = *ppsz;
        wLangID =  (WORD)_tcstol(lpLangID, NULL, 0 );
        fForceLocalizedLangID = TRUE;
    }
    else {
    
        _tprintf(_T(" Language ID is not specified, you need to specify the launge id. e.g. -l 0x0409 ") );
        
        goto exit;
    }

    //
    // get the source name and  new resource free file, mui resource file name.
    //
    LPTSTR pszSource,pszNewFile,pszMuiFile ;

    pszSource  = pszNewFile =pszMuiFile = NULL;
    
    if ( ! GetFileNames(pcmci, &pszSource, &pszNewFile, &pszMuiFile ) ) {

        _tprintf(_T("\n Can't find source name, or Name does not format of  *.* \n") );

        _tprintf(_T("MUIRCT [-h|?] -l langid [-i resource_type] [-k resource_type] [-y resource_type] \n") );
        _tprintf(_T("source_filename, [language_neutral_filename], [MUI_filename] \n\n"));

        goto exit;
    }
    //
    // we need to change the attribute of source as read/write before copy. new file inherit old one attribute.
    //
    SetFileAttributes (pszSource, FILE_ATTRIBUTE_ARCHIVE );

    if ( _tcsicmp(pszSource,pszNewFile) ) {  // new file name is same with source file.
        if (! CopyFile (pszSource, pszNewFile, FALSE ) ) {
            printf("GetLastError () : %d \n", GetLastError() );
            _tprintf (_T(" Copy File error, GetLastError() : %d \n "), GetLastError() );
            
            goto exit;
        }
    }

    //
    // Read the value of r (remove resource) , k (keep resource)
    // 

    DWORD dwKeepCount, dwRemoveCount,dwKeepIfExistCount, dwRemoveCountNoSanity; 
    
    dwKeepCount = dwRemoveCount = dwKeepIfExistCount = dwRemoveCountNoSanity = 0;
    
    LPTSTR * ppKeepRes = pcmci ->GetValueLists (_T("k"), dwKeepCount  );

    LPTSTR * ppRemoveRes = pcmci ->GetValueLists (_T("i"), dwRemoveCount  );  // pszTmp would be copied to pszRemove

    LPTSTR * ppRemoveResNoSanity = pcmci ->GetValueLists (_T("o"), dwRemoveCountNoSanity  );

    LPSTR * ppKeepIfExists = pcmci->GetValueLists(_T("y"), dwKeepIfExistCount);

#ifdef NEVER
    if (! CompareArgValues(ppRemoveRes,ppKeepRes ) ) { // if same, goto 0.
        goto exit;
    }
#endif
    //
    // Create CMUIResource, which is main class for mui resource handling.
    //
    pcmui = new CMUIResource(); //(pszNewFile);

    if (! pcmui) {
        _tprintf(_T("Insufficient resource \n") );
        goto exit;
    }

    //  
    // Create checksum data with all resource except version.Disabled at this time.
    //
#ifdef CHECKSMU_ALL
    LPTSTR  lpChecksumFile = NULL;
    BOOL fChecksum = FALSE;
    MD5_CTX * pMD5 = NULL;
    BYTE pbMD5Digest[RESOURCE_CHECKSUM_SIZE];

    if ( ppsz = pcmci ->GetValueLists (_T("c"), dwCount ) ) {
        
        lpChecksumFile  = *ppsz  ;
        // load checksum file
        if ( ! pcmui -> Create(lpChecksumFile ) ) // load the file for EnumRes..
            goto exit;

        // create a checksum MD5_CTX format ( 16 byte: all resources are caculated based on some algorithm.
        DWORD dwLangCount =0;
        
        LPTSTR *ppChecksumLangId = pcmci ->GetValueLists (_T("b"), dwLangCount);
        WORD  wChecksumLangId = LANG_CHECKSUM_DEFAULT;
        
        if (dwLangCount)
        {
            wChecksumLangId = (WORD)strtoul(*ppChecksumLangId, NULL, 0);
        }


        pMD5 = pcmui-> CreateChecksumWithAllRes(wChecksumLangId);
	 memcpy(pbMD5Digest, pMD5->digest, RESOURCE_CHECKSUM_SIZE);
        
        pcmui -> FreeLibrary();
        fChecksum = TRUE;
    } 
#endif
    //
    // load new MUI file
    //
    if (! pcmui -> Create(pszNewFile) ) { // load the file .
        
        goto exit;
    }
    //
    // Reorganise removing resource types.
    // 
    cvcstring * cvRemovedResTypes = pcmui -> EnumResTypes (reinterpret_cast <LONG_PTR> ( pcmui )); // need to change : goto LPCTSTR* rather than CVector;
    
    if ( cvRemovedResTypes -> Empty() ) {
        
        _tprintf(_T("The %s does not contain any resource \n"), pszSource );
        goto exit;

    }
    else {
        // when there is remove argument and its value e.g. -i 3 4 Anvil ..
        if ( dwRemoveCount && !!_tcscmp(*ppRemoveRes,_T("ALL") ) ) {
            
            if (! FilterRemRes(cvRemovedResTypes,ppRemoveRes,dwRemoveCount, TRUE ) ) {
               goto exit;
            }
        
        }   //if ( dwRemoveCount && _tcscmp(*ppRemoveRes,_T("ALL") ) ){
        else if (dwRemoveCountNoSanity)
        {
            // This is -o arg. build team does not know what resource type are included in the module, so 
            // they use localizable resource, but -i goto false when specified resourc type is not found in the
            // module. -o does not check sanity of resource type like -i arg.
            if (! FilterRemRes(cvRemovedResTypes, ppRemoveResNoSanity, dwRemoveCountNoSanity, FALSE ) ) {
               goto exit;
            }

        }
        // Stop if source only includes type 16. very few case, so use couple of api instead moving the module to front.
        if (cvRemovedResTypes->Size() == 1 && ! ( PtrToUlong(cvRemovedResTypes->GetValue(0)) - 16 )  ) {
            if ( _tcsicmp(pszSource, pszNewFile) ) {
                pcmui->FreeLibrary();
                DeleteFile(pszNewFile);
            }
             _tprintf(_T("The %s contains only VERSION resource \n"), pszSource );
            goto exit;
        }
    
    }  // cvRemovedResTypes.Empty()

    //
    // we need to get -k argument and check its sanity and save its valus into cvcstring format.
    // we also need to check if -i values and those of -k, -y are identical. 
    // rethink : what if remove sanity check from -k arg. then we can delete -y arg. as well as most of below.
    //
    cvKeepResTypes = new cvcstring (MAX_NUM_RESOURCE_TYPES);
    if(!cvKeepResTypes)
    	goto exit;
    
    cvKeepResTypesIfExist = new cvcstring (MAX_NUM_RESOURCE_TYPES);
    if(!cvKeepResTypesIfExist)
    	goto exit;
    
    if ( dwKeepCount && dwKeepIfExistCount ) {
        // both of -k, -y arg. exist.
        if (!( vRemnantRes = FilterKeepRes(cvRemovedResTypes,ppKeepRes,cvKeepResTypes,dwKeepCount,TRUE ) ) ){
        
            goto exit;
        }

        if (! FilterKeepRes( vRemnantRes, ppKeepIfExists, cvKeepResTypesIfExist, dwKeepIfExistCount,FALSE) ) {
              goto exit;
          }
    } 
    else if ( dwKeepCount) {
        // only -k arg. exist.
        if (!( vRemnantRes = FilterKeepRes(cvRemovedResTypes,ppKeepRes,cvKeepResTypes,dwKeepCount,TRUE ) ) ){
        
           goto exit;
        }
    }
    else if (dwKeepIfExistCount) {
        
        if ( ! FilterKeepRes( cvRemovedResTypes, ppKeepIfExists, cvKeepResTypesIfExist, dwKeepIfExistCount,FALSE))  {
            goto exit;
        }
    }
    
    //
    // Some resource should be pairs <1, 12> <3, 14>
    //
    CheckTypePairs(cvRemovedResTypes,cvKeepResTypes);

// #ifndef CHECKSUM_ALL
    //
    // Create checksum with only selected resource types. 
    //
    LPTSTR  lpChecksumFile = NULL;
    BOOL fChecksum = FALSE;
    MD5_CTX * pMD5 = NULL;
    BYTE pbMD5Digest[RESOURCE_CHECKSUM_SIZE];
    
    if ( ppsz = pcmci ->GetValueLists (_T("c"), dwCount ) ) {
        
        pcmui2 = new CMUIResource();

        lpChecksumFile  = *ppsz  ;
        // load checksum file

        if ( ! pcmui2 -> Create(lpChecksumFile ) ) // load the file for EnumRes..
            goto exit;

        DWORD dwLangCount =0;
        
        LPTSTR *ppChecksumLangId = pcmci ->GetValueLists (_T("b"), dwLangCount);
        WORD  wChecksumLangId = LANG_CHECKSUM_DEFAULT;
        
        if (dwLangCount)
        {
            wChecksumLangId = (WORD)strtoul(*ppChecksumLangId, NULL, 0);
        }

        // create a checksum MD5_CTX format ( 16 byte: all resources are caculated based on some algorithm.
        pMD5 = pcmui2-> CreateChecksum(cvRemovedResTypes, wChecksumLangId);
        memcpy(pbMD5Digest, pMD5->digest, RESOURCE_CHECKSUM_SIZE);
        
        pcmui2 -> FreeLibrary();

        fChecksum = TRUE;
         
    } 
// #endif

    // 
    // Fill CMUIData field. it goto false when there is no LangID specified. 
    // Is there any chance of no resource name when resource type exist ?
    //
    
    if ( !pcmui -> FillMuiData( cvRemovedResTypes, wLangID, fForceLocalizedLangID) ) {
        
        _tprintf (_T("Fail to get resouce name or lang id \n " ) );

        goto exit;
    };
    

    //
    // -p arugment; the valules of this argument(resourc type) should not be included in new MUI File.
    //  although delete them from source file.
    //
    dwCount =0;
    if ( ppsz = pcmci ->GetValueLists (_T("p"), dwCount ) ) 
    {
        for (UINT i =0; i < dwCount; i ++) 
        {
            LPCSTR lpDelResourceType = NULL;
            LPTSTR pszResType = *ppsz++;
            LPTSTR pszStopped = NULL;
            
            DWORD dwTypeID = _tcstoul(pszResType,&pszStopped,10 );
            
            if ( 0 == dwTypeID || *pszStopped != _T('\0')) { // string type
                lpDelResourceType = pszResType  ;
            }
            else { // id 
                lpDelResourceType = MAKEINTRESOURCE(dwTypeID);
            }
            pcmui->DeleteResItem( lpDelResourceType );
        }

    }


    DWORD dwVerbose = 0;
    if ( ppsz = pcmci ->GetValueLists (_T("v"), dwCount ) ) 
            dwVerbose = _tcstoul(*ppsz,NULL, 10 );


    // Set the link.exe path, link options.
    TCHAR lpCommandLine[] = _T(" /noentry /dll /nologo /nodefaultlib /SUBSYSTEM:WINDOWS,5.01");
    //
    // Create the mui resource files with the information from  FillMuiData
    // We can use both of these way : WriteResFile : call link.exe inside after creation of RES file
    //                                CreatePE : using UpdateResource using 
    // UpdateResource has bug to fail when udpated data is large. so we use link.
    //
    if ( ! pcmui -> WriteResFile (pszSource, pszMuiFile, lpCommandLine, wLangID ) ) {
//  if ( ! pcmui -> CreatePE ( pszMuiFile , pszSource ) ) { // this can be used after more investigation(if it is used, we can remove -s )
        _tprintf (_T(" Muirct fail to creat new mui rc file. GetLastError() : %d \n "), GetLastError() );
    }
    else
    {
        if ( dwVerbose == 1 || dwVerbose == 2) {
            _tprintf (_T(" MUI resource file(%s) is successfully created \n\n"), pszMuiFile );
        }

        if ( dwVerbose == 2) {
            pcmui ->PrtVerbose( 1 );
            _tprintf("\n");
        }
    }
    
    //
    // delete values of -k from -i values.
    // 

    if (dwKeepCount) {
        for (UINT i = 0; i < cvKeepResTypes->Size(); i ++ ) {
            pcmui->DeleteResItem( cvKeepResTypes->GetValue (i) );
        }
    }
    //
    // handling of -y argument; it is same with -k argument except skip the checking of its existence.
    //

    if ( dwKeepIfExistCount ) {

        for (UINT i = 0; i < cvKeepResTypesIfExist->Size(); i++) {
        
            pcmui->DeleteResItem(cvKeepResTypesIfExist->GetValue(i) );

        }

#ifdef NEVER
        for (UINT i = 0; i < dwKeepIfExistCount; i ++ ) {
            LPCSTR lpDelResourceType = NULL;
            LPTSTR pszValue = ppKeepIfExists[i];
            LPTSTR pszStopped = NULL;
            
            DWORD dwTypeID = _tcstoul(pszValue,&pszStopped,10 );
            
            if ( 0 == dwTypeID || *pszStopped != _T('\0')) { // string type
                lpDelResourceType = pszValue    ;

            }
            else { // id 
                lpDelResourceType = MAKEINTRESOURCE(dwTypeID);
            }

            pcmui->DeleteResItem( lpDelResourceType );
        }
#endif 

    }

    //
    // Delete resource from the pszNewFile
    //
    if ( ! pcmui -> DeleteResource () ) {
        _tprintf (_T(" Muirct fail to remove the resource from the file\n" ) );
    }
    else 
    {
        if ( dwVerbose == 1 || dwVerbose == 2) {
            _tprintf (_T(" New Resource removed file(%s) is successfully created\n\n" ), pszNewFile );
        }
        if ( dwVerbose == 2) {
            _tprintf(_T(" Removed resource types \n\n") );
            pcmui ->PrtVerbose( 1 );
            _tprintf("\n");
        }       
    }
    
    //
    // Adding a resource checksum into two files ( lang-neutral binary and mui file )
    //
    if ( fChecksum ){ 

        pcmui->Create(pszMuiFile); 
        if (! pcmui->AddChecksumToVersion(pbMD5Digest) ) {  //add checksum into MUI file
            _tprintf(_T("Fail to add checksum to version ( %s)\n"),pszMuiFile );
        }
        
        pcmui->Create(pszNewFile);
        if (! pcmui->AddChecksumToVersion(pbMD5Digest) ) {  //add checksum into lang-neutral binary. 
            _tprintf(_T("Fail to add checksum to version ( %s); \n"),pszNewFile );
        }
    }
    

    //
    // Updating file checksum in language-free binary
    // 
    
    BOOL fSuccess = pcmui->UpdateNtHeader(pszNewFile,pcmui->CHECKSUM );

exit:
    if (pcmci)
    	delete pcmci;
    
    if (pcmui)
  	  delete pcmui;

    if(pcmui2)
    	  delete pcmui2;

    if (cvKeepResTypes)
	  delete cvKeepResTypes;
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\wival.inc ===
'<script language='VBScript'>
' wival.inc - Windows Installer _Validation table definitions
'
'  6/9/2001 13:34:56 - created - val.wsf (tool by robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    AddValidation
'

Dim val_dicValidation : Set val_dicValidation = CreateObject("Scripting.Dictionary")
Dim val__Validation(9)
val__Validation(0) = "'_Validation'&&'Table'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of table'"
val__Validation(1) = "'_Validation'&&'Column'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of column'"
val__Validation(2) = "'_Validation'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Description of column'"
val__Validation(3) = "'_Validation'&&'Set'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Set of values that are permitted'"
val__Validation(4) = "'_Validation'&&'Category'&&'Y'&&''&&''&&''&&''&&''&&'Text;Formatted;Template;Condition;Guid;Path;Version;Language;Identifier;Binary;UpperCase;LowerCase;Filename;Paths;AnyPath;WildCardFilename;RegPath;KeyFormatted;CustomSource;Property;Cabinet;Shortcut;URL'&&'String category'"
val__Validation(5) = "'_Validation'&&'KeyColumn'&&'Y'&&'1'&&'32'&&''&&''&&''&&''&&'Column to which foreign key connects'"
val__Validation(6) = "'_Validation'&&'KeyTable'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'For foreign key, Name of table to which data must link'"
val__Validation(7) = "'_Validation'&&'MaxValue'&&'Y'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Maximum value allowed'"
val__Validation(8) = "'_Validation'&&'MinValue'&&'Y'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Minimum value allowed'"
val__Validation(9) = "'_Validation'&&'Nullable'&&'N'&&''&&''&&''&&''&&''&&'Y;N;@'&&'Whether the column is nullable'"
val_dicValidation.Add "_Validation", val__Validation

Dim val_ActionText(2)
val_ActionText(0) = "'ActionText'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Localized description displayed in progress dialog and log when action is executing.'"
val_ActionText(1) = "'ActionText'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to be described.'"
val_ActionText(2) = "'ActionText'&&'Template'&&'Y'&&''&&''&&''&&''&&'Template'&&''&&'Optional localized format template used to format action data records for display during action execution.'"
val_dicValidation.Add "ActionText", val_ActionText

Dim val_AdminExecuteSequence(2)
val_AdminExecuteSequence(0) = "'AdminExecuteSequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdminExecuteSequence(1) = "'AdminExecuteSequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdminExecuteSequence(2) = "'AdminExecuteSequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdminExecuteSequence", val_AdminExecuteSequence

Dim val_Condition(2)
val_Condition(0) = "'Condition'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Expression evaluated to determine if Level in the Feature table is to change.'"
val_Condition(1) = "'Condition'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Reference to a Feature entry in Feature table.'"
val_Condition(2) = "'Condition'&&'Level'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'New selection Level to set in Feature table if Condition evaluates to TRUE.'"
val_dicValidation.Add "Condition", val_Condition

Dim val_AdminUISequence(2)
val_AdminUISequence(0) = "'AdminUISequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdminUISequence(1) = "'AdminUISequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdminUISequence(2) = "'AdminUISequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdminUISequence", val_AdminUISequence

Dim val_AdvtExecuteSequence(2)
val_AdvtExecuteSequence(0) = "'AdvtExecuteSequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdvtExecuteSequence(1) = "'AdvtExecuteSequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdvtExecuteSequence(2) = "'AdvtExecuteSequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdvtExecuteSequence", val_AdvtExecuteSequence

Dim val_AdvtUISequence(2)
val_AdvtUISequence(0) = "'AdvtUISequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_AdvtUISequence(1) = "'AdvtUISequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_AdvtUISequence(2) = "'AdvtUISequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "AdvtUISequence", val_AdvtUISequence

Dim val_AppId(6)
val_AppId(0) = "'AppId'&&'AppId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&''"
val_AppId(1) = "'AppId'&&'ActivateAtStorage'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&''"
val_AppId(2) = "'AppId'&&'DllSurrogate'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_AppId(3) = "'AppId'&&'LocalService'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_AppId(4) = "'AppId'&&'RemoteServerName'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&''"
val_AppId(5) = "'AppId'&&'RunAsInteractiveUser'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&''"
val_AppId(6) = "'AppId'&&'ServiceParameters'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_dicValidation.Add "AppId", val_AppId

Dim val_AppSearch(1)
val_AppSearch(0) = "'AppSearch'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The property associated with a Signature'"
val_AppSearch(1) = "'AppSearch'&&'Signature_'&&'N'&&''&&''&&'Signature;RegLocator;IniLocator;DrLocator;CompLocator'&&'1'&&'Identifier'&&''&&'The Signature_ represents a unique file signature and is also the foreign key in the Signature,  RegLocator, IniLocator, CompLocator and the DrLocator tables.'"
val_dicValidation.Add "AppSearch", val_AppSearch

Dim val_Property(1)
val_Property(0) = "'Property'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of property, uppercase if settable by launcher or loader.'"
val_Property(1) = "'Property'&&'Value'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'String value for property.  Never null or empty.'"
val_dicValidation.Add "Property", val_Property

Dim val_BBControl(8)
val_BBControl(0) = "'BBControl'&&'Type'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The type of the control.'"
val_BBControl(1) = "'BBControl'&&'Y'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Vertical coordinate of the upper left corner of the bounding rectangle of the control.'"
val_BBControl(2) = "'BBControl'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'A string used to set the initial text contained within a control (if appropriate).'"
val_BBControl(3) = "'BBControl'&&'BBControl'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the control. This name must be unique within a billboard, but can repeat on different billboard.'"
val_BBControl(4) = "'BBControl'&&'Attributes'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'A 32-bit word that specifies the attribute flags to be applied to this control.'"
val_BBControl(5) = "'BBControl'&&'Billboard_'&&'N'&&''&&''&&'Billboard'&&'1'&&'Identifier'&&''&&'External key to the Billboard table, name of the billboard.'"
val_BBControl(6) = "'BBControl'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Height of the bounding rectangle of the control.'"
val_BBControl(7) = "'BBControl'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Width of the bounding rectangle of the control.'"
val_BBControl(8) = "'BBControl'&&'X'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Horizontal coordinate of the upper left corner of the bounding rectangle of the control.'"
val_dicValidation.Add "BBControl", val_BBControl

Dim val_Billboard(3)
val_Billboard(0) = "'Billboard'&&'Action'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'The name of an action. The billboard is displayed during the progress messages received from this action.'"
val_Billboard(1) = "'Billboard'&&'Billboard'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the billboard.'"
val_Billboard(2) = "'Billboard'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'An external key to the Feature Table. The billboard is shown only if this feature is being installed.'"
val_Billboard(3) = "'Billboard'&&'Ordering'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'A positive integer. If there is more than one billboard corresponding to an action they will be shown in the order defined by this column.'"
val_dicValidation.Add "Billboard", val_Billboard

Dim val_Feature(7)
val_Feature(0) = "'Feature'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Longer descriptive text describing a visible feature item.'"
val_Feature(1) = "'Feature'&&'Attributes'&&'N'&&''&&''&&''&&''&&''&&'0;1;2;4;5;6;8;9;10;16;17;18;20;21;22;24;25;26;32;33;34;36;37;38;48;49;50;52;53;54'&&'Feature attributes'"
val_Feature(2) = "'Feature'&&'Feature'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular feature record.'"
val_Feature(3) = "'Feature'&&'Directory_'&&'Y'&&''&&''&&'Directory'&&'1'&&'UpperCase'&&''&&'The name of the Directory that can be configured by the UI. A non-null value will enable the browse button.'"
val_Feature(4) = "'Feature'&&'Level'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The install level at which record will be initially selected. An install level of 0 will disable an item and prevent its display.'"
val_Feature(5) = "'Feature'&&'Title'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Short text identifying a visible feature item.'"
val_Feature(6) = "'Feature'&&'Display'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'Numeric sort order, used to force a specific display ordering.'"
val_Feature(7) = "'Feature'&&'Feature_Parent'&&'Y'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Optional key of a parent record in the same table. If the parent is not selected, then the record will not be installed. Null indicates a root item.'"
val_dicValidation.Add "Feature", val_Feature

Dim val_Binary(1)
val_Binary(0) = "'Binary'&&'Name'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Unique key identifying the binary data.'"
val_Binary(1) = "'Binary'&&'Data'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'The unformatted binary data.'"
val_dicValidation.Add "Binary", val_Binary

Dim val_BindImage(1)
val_BindImage(0) = "'BindImage'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'The index into the File table. This must be an executable file.'"
val_BindImage(1) = "'BindImage'&&'Path'&&'Y'&&''&&''&&''&&''&&'Paths'&&''&&'A list of ;  delimited paths that represent the paths to be searched for the import DLLS. The list is usually a list of properties each enclosed within square brackets [] .'"
val_dicValidation.Add "BindImage", val_BindImage

Dim val_File(7)
val_File(0) = "'File'&&'Sequence'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'Sequence with respect to the media images; order must track cabinet order.'"
val_File(1) = "'File'&&'Attributes'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'Integer containing bit flags representing file attributes (with the decimal value of each bit position in parentheses)'"
val_File(2) = "'File'&&'File'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token, must match identifier in cabinet.  For uncompressed files, this field is ignored.'"
val_File(3) = "'File'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the file.'"
val_File(4) = "'File'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'File name used for installation, may be localized.  This may contain a ""short name|long name"" pair.'"
val_File(5) = "'File'&&'FileSize'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_File(6) = "'File'&&'Language'&&'Y'&&''&&''&&''&&''&&'Language'&&''&&'List of decimal language Ids, comma-separated if more than one.'"
val_File(7) = "'File'&&'Version'&&'Y'&&''&&''&&'File'&&'1'&&'Version'&&''&&'Version string for versioned files;  Blank for unversioned files.'"
val_dicValidation.Add "File", val_File

Dim val_CCPSearch(0)
val_CCPSearch(0) = "'CCPSearch'&&'Signature_'&&'N'&&''&&''&&'Signature;RegLocator;IniLocator;DrLocator;CompLocator'&&'1'&&'Identifier'&&''&&'The Signature_ represents a unique file signature and is also the foreign key in the Signature,  RegLocator, IniLocator, CompLocator and the DrLocator tables.'"
val_dicValidation.Add "CCPSearch", val_CCPSearch

Dim val_CheckBox(1)
val_CheckBox(0) = "'CheckBox'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to the item.'"
val_CheckBox(1) = "'CheckBox'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with the item.'"
val_dicValidation.Add "CheckBox", val_CheckBox

Dim val_Class(12)
val_Class(0) = "'Class'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Localized description for the Class.'"
val_Class(1) = "'Class'&&'Attributes'&&'Y'&&''&&'32767'&&''&&''&&''&&''&&'Class registration attributes.'"
val_Class(2) = "'Class'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Required foreign key into the Feature Table, specifying the feature to validate or install in order for the CLSID factory to be operational.'"
val_Class(3) = "'Class'&&'AppId_'&&'Y'&&''&&''&&'AppId'&&'1'&&'Guid'&&''&&'Optional AppID containing DCOM information for associated application (string GUID).'"
val_Class(4) = "'Class'&&'Argument'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'optional argument for LocalServers.'"
val_Class(5) = "'Class'&&'CLSID'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'The CLSID of an OLE factory.'"
val_Class(6) = "'Class'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table, specifying the component for which to return a path when called through LocateComponent.'"
val_Class(7) = "'Class'&&'Context'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The numeric server context for this server. CLSCTX_xxxx'"
val_Class(8) = "'Class'&&'DefInprocHandler'&&'Y'&&''&&''&&''&&''&&'Filename'&&'1;2;3'&&'Optional default inproc handler.  Only optionally provided if Context=CLSCTX_LOCAL_SERVER.  Typically ""ole32.dll"" or ""mapi32.dll""'"
val_Class(9) = "'Class'&&'FileTypeMask'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Optional string containing information for the HKCRthis CLSID) key. If multiple patterns exist, they must be delimited by a semicolon, and numeric subkeys will be generated: 0,1,2...'"
val_Class(10) = "'Class'&&'Icon_'&&'Y'&&''&&''&&'Icon'&&'1'&&'Identifier'&&''&&'Optional foreign key into the Icon Table, specifying the icon file associated with this CLSID. Will be written under the DefaultIcon key.'"
val_Class(11) = "'Class'&&'IconIndex'&&'Y'&&'-32767'&&'32767'&&''&&''&&''&&''&&'Optional icon index.'"
val_Class(12) = "'Class'&&'ProgId_Default'&&'Y'&&''&&''&&'ProgId'&&'1'&&'Text'&&''&&'Optional ProgId associated with this CLSID.'"
val_dicValidation.Add "Class", val_Class

Dim val_Component(5)
val_Component(0) = "'Component'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'A conditional statement that will disable this component if the specified condition evaluates to the 'True' state. If a component is disabled, it will not be installed, regardless of the 'Action' state associated with the component.'"
val_Component(1) = "'Component'&&'Attributes'&&'N'&&''&&''&&''&&''&&''&&''&&'Remote execution option, one of irsEnum'"
val_Component(2) = "'Component'&&'Component'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular component record.'"
val_Component(3) = "'Component'&&'ComponentId'&&'Y'&&''&&''&&''&&''&&'Guid'&&''&&'A string GUID unique to this component, version, and language.'"
val_Component(4) = "'Component'&&'Directory_'&&'N'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Required key of a Directory table record. This is actually a property name whose value contains the actual path, set either by the AppSearch action or with the default setting obtained from the Directory table.'"
val_Component(5) = "'Component'&&'KeyPath'&&'Y'&&''&&''&&'File;Registry;ODBCDataSource'&&'1'&&'Identifier'&&''&&'Either the primary key into the File table, Registry table, or ODBCDataSource table. This extract path is stored when the component is installed, and is used to detect the presence of the component and to return the path to it.'"
val_dicValidation.Add "Component", val_Component

Dim val_Icon(1)
val_Icon(0) = "'Icon'&&'Name'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key. Name of the icon file.'"
val_Icon(1) = "'Icon'&&'Data'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'Binary stream. The binary icon data in PE (.DLL or .EXE) or icon (.ICO) format.'"
val_dicValidation.Add "Icon", val_Icon

Dim val_ProgId(5)
val_ProgId(0) = "'ProgId'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Localized description for the Program identifier.'"
val_ProgId(1) = "'ProgId'&&'Icon_'&&'Y'&&''&&''&&'Icon'&&'1'&&'Identifier'&&''&&'Optional foreign key into the Icon Table, specifying the icon file associated with this ProgId. Will be written under the DefaultIcon key.'"
val_ProgId(2) = "'ProgId'&&'IconIndex'&&'Y'&&'-32767'&&'32767'&&''&&''&&''&&''&&'Optional icon index.'"
val_ProgId(3) = "'ProgId'&&'ProgId'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The Program Identifier. Primary key.'"
val_ProgId(4) = "'ProgId'&&'Class_'&&'Y'&&''&&''&&'Class'&&'1'&&'Guid'&&''&&'The CLSID of an OLE factory corresponding to the ProgId.'"
val_ProgId(5) = "'ProgId'&&'ProgId_Parent'&&'Y'&&''&&''&&'ProgId'&&'1'&&'Text'&&''&&'The Parent Program Identifier. If specified, the ProgId column becomes a version independent prog id.'"
val_dicValidation.Add "ProgId", val_ProgId

Dim val_ComboBox(3)
val_ComboBox(0) = "'ComboBox'&&'Text'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.'"
val_ComboBox(1) = "'ComboBox'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this item. All the items tied to the same property become part of the same combobox.'"
val_ComboBox(2) = "'ComboBox'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with this item. Selecting the line will set the associated property to this value.'"
val_ComboBox(3) = "'ComboBox'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list.	The integers do not have to be consecutive.'"
val_dicValidation.Add "ComboBox", val_ComboBox

Dim val_CompLocator(2)
val_CompLocator(0) = "'CompLocator'&&'Type'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&'A boolean value that determines if the registry value is a filename or a directory location.'"
val_CompLocator(1) = "'CompLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature_ represents a unique file signature and is also the foreign key in the Signature table.'"
val_CompLocator(2) = "'CompLocator'&&'ComponentId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'A string GUID unique to this component, version, and language.'"
val_dicValidation.Add "CompLocator", val_CompLocator

Dim val_Complus(1)
val_Complus(0) = "'Complus'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the ComPlus component.'"
val_Complus(1) = "'Complus'&&'ExpType'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'ComPlus component attributes.'"
val_dicValidation.Add "Complus", val_Complus

Dim val_Directory(2)
val_Directory(0) = "'Directory'&&'Directory'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Unique identifier for directory entry, primary key. If a property by this name is defined, it contains the full path to the directory.'"
val_Directory(1) = "'Directory'&&'DefaultDir'&&'N'&&''&&''&&''&&''&&'DefaultDir'&&''&&'The default sub-path under parent's path.'"
val_Directory(2) = "'Directory'&&'Directory_Parent'&&'Y'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Reference to the entry in this table specifying the default parent directory. A record parented to itself or with a Null parent represents a root of the install tree.'"
val_dicValidation.Add "Directory", val_Directory

Dim val_Control(11)
val_Control(0) = "'Control'&&'Type'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The type of the control.'"
val_Control(1) = "'Control'&&'Y'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Vertical coordinate of the upper left corner of the bounding rectangle of the control.'"
val_Control(2) = "'Control'&&'Text'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'A string used to set the initial text contained within a control (if appropriate).'"
val_Control(3) = "'Control'&&'Property'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'The name of a defined property to be linked to this control. '"
val_Control(4) = "'Control'&&'Attributes'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'A 32-bit word that specifies the attribute flags to be applied to this control.'"
val_Control(5) = "'Control'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Height of the bounding rectangle of the control.'"
val_Control(6) = "'Control'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Width of the bounding rectangle of the control.'"
val_Control(7) = "'Control'&&'X'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Horizontal coordinate of the upper left corner of the bounding rectangle of the control.'"
val_Control(8) = "'Control'&&'Control'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the control. This name must be unique within a dialog, but can repeat on different dialogs. '"
val_Control(9) = "'Control'&&'Control_Next'&&'Y'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'The name of an other control on the same dialog. This link defines the tab order of the controls. The links have to form one or more cycles!'"
val_Control(10) = "'Control'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'External key to the Dialog table, name of the dialog.'"
val_Control(11) = "'Control'&&'Help'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The help strings used with the button. The text is optional. '"
val_dicValidation.Add "Control", val_Control

Dim val_Dialog(9)
val_Dialog(0) = "'Dialog'&&'Attributes'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'A 32-bit word that specifies the attribute flags to be applied to this dialog.'"
val_Dialog(1) = "'Dialog'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Height of the bounding rectangle of the dialog.'"
val_Dialog(2) = "'Dialog'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Width of the bounding rectangle of the dialog.'"
val_Dialog(3) = "'Dialog'&&'Dialog'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the dialog.'"
val_Dialog(4) = "'Dialog'&&'Control_Cancel'&&'Y'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'Defines the cancel control. Hitting escape or clicking on the close icon on the dialog is equivalent to pushing this button.'"
val_Dialog(5) = "'Dialog'&&'Control_Default'&&'Y'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'Defines the default control. Hitting return is equivalent to pushing this button.'"
val_Dialog(6) = "'Dialog'&&'Control_First'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'Defines the control that has the focus when the dialog is created.'"
val_Dialog(7) = "'Dialog'&&'HCentering'&&'N'&&'0'&&'100'&&''&&''&&''&&''&&'Horizontal position of the dialog on a 0-100 scale. 0 means left end, 100 means right end of the screen, 50 center.'"
val_Dialog(8) = "'Dialog'&&'Title'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'A text string specifying the title to be displayed in the title bar of the dialog's window.'"
val_Dialog(9) = "'Dialog'&&'VCentering'&&'N'&&'0'&&'100'&&''&&''&&''&&''&&'Vertical position of the dialog on a 0-100 scale. 0 means top end, 100 means bottom end of the screen, 50 center.'"
val_dicValidation.Add "Dialog", val_Dialog

Dim val_ControlCondition(3)
val_ControlCondition(0) = "'ControlCondition'&&'Action'&&'N'&&''&&''&&''&&''&&''&&'Default;Disable;Enable;Hide;Show'&&'The desired action to be taken on the specified control.'"
val_ControlCondition(1) = "'ControlCondition'&&'Condition'&&'N'&&''&&''&&''&&''&&'Condition'&&''&&'A standard conditional statement that specifies under which conditions the action should be triggered.'"
val_ControlCondition(2) = "'ControlCondition'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'A foreign key to the Dialog table, name of the dialog.'"
val_ControlCondition(3) = "'ControlCondition'&&'Control_'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'A foreign key to the Control table, name of the control.'"
val_dicValidation.Add "ControlCondition", val_ControlCondition

Dim val_ControlEvent(5)
val_ControlEvent(0) = "'ControlEvent'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'A standard conditional statement that specifies under which conditions an event should be triggered.'"
val_ControlEvent(1) = "'ControlEvent'&&'Ordering'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'An integer used to order several events tied to the same control. Can be left blank.'"
val_ControlEvent(2) = "'ControlEvent'&&'Argument'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'A value to be used as a modifier when triggering a particular event.'"
val_ControlEvent(3) = "'ControlEvent'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'A foreign key to the Dialog table, name of the dialog.'"
val_ControlEvent(4) = "'ControlEvent'&&'Control_'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'A foreign key to the Control table, name of the control'"
val_ControlEvent(5) = "'ControlEvent'&&'Event'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'An identifier that specifies the type of the event that should take place when the user interacts with control specified by the first two entries.'"
val_dicValidation.Add "ControlEvent", val_ControlEvent

Dim val_CreateFolder(1)
val_CreateFolder(0) = "'CreateFolder'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table.'"
val_CreateFolder(1) = "'CreateFolder'&&'Directory_'&&'N'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Primary key, could be foreign key into the Directory table.'"
val_dicValidation.Add "CreateFolder", val_CreateFolder

Dim val_CustomAction(3)
val_CustomAction(0) = "'CustomAction'&&'Type'&&'N'&&'1'&&'16383'&&''&&''&&''&&''&&'The numeric custom action type, consisting of source location, code type, entry, option flags.'"
val_CustomAction(1) = "'CustomAction'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, name of action, normally appears in sequence table unless private use.'"
val_CustomAction(2) = "'CustomAction'&&'Source'&&'Y'&&''&&''&&''&&''&&'CustomSource'&&''&&'The table reference of the source of the code.'"
val_CustomAction(3) = "'CustomAction'&&'Target'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Excecution parameter, depends on the type of custom action'"
val_dicValidation.Add "CustomAction", val_CustomAction

Dim val_DrLocator(3)
val_DrLocator(0) = "'DrLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The Signature_ represents a unique file signature and is also the foreign key in the Signature table.'"
val_DrLocator(1) = "'DrLocator'&&'Path'&&'Y'&&''&&''&&''&&''&&'AnyPath'&&''&&'The path on the user system. This is a either a subpath below the value of the Parent or a full path. The path may contain properties enclosed within [ ] that will be expanded.'"
val_DrLocator(2) = "'DrLocator'&&'Depth'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The depth below the path to which the Signature_ is recursively searched. If absent, the depth is assumed to be 0.'"
val_DrLocator(3) = "'DrLocator'&&'Parent'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'The parent file signature. It is also a foreign key in the Signature table. If null and the Path column does not expand to a full path, then all the fixed drives of the user system are searched using the Path.'"
val_dicValidation.Add "DrLocator", val_DrLocator

Dim val_DuplicateFile(4)
val_DuplicateFile(0) = "'DuplicateFile'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key referencing the source file to be duplicated.'"
val_DuplicateFile(1) = "'DuplicateFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the duplicate file.'"
val_DuplicateFile(2) = "'DuplicateFile'&&'DestFolder'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full pathname to a destination folder.'"
val_DuplicateFile(3) = "'DuplicateFile'&&'DestName'&&'Y'&&''&&''&&''&&''&&'Filename'&&''&&'Filename to be given to the duplicate file.'"
val_DuplicateFile(4) = "'DuplicateFile'&&'FileKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular file entry'"
val_dicValidation.Add "DuplicateFile", val_DuplicateFile

Dim val_Environment(3)
val_Environment(0) = "'Environment'&&'Name'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The name of the environmental value.'"
val_Environment(1) = "'Environment'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The value to set in the environmental settings.'"
val_Environment(2) = "'Environment'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the installing of the environmental value.'"
val_Environment(3) = "'Environment'&&'Environment'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Unique identifier for the environmental variable setting'"
val_dicValidation.Add "Environment", val_Environment

Dim val_Error(1)
val_Error(0) = "'Error'&&'Error'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Integer error number, obtained from header file IError(...) macros.'"
val_Error(1) = "'Error'&&'Message'&&'Y'&&''&&''&&''&&''&&'Template'&&''&&'Error formatting template, obtained from user ed. or localizers.'"
val_dicValidation.Add "Error", val_Error

Dim val_EventMapping(3)
val_EventMapping(0) = "'EventMapping'&&'Dialog_'&&'N'&&''&&''&&'Dialog'&&'1'&&'Identifier'&&''&&'A foreign key to the Dialog table, name of the Dialog.'"
val_EventMapping(1) = "'EventMapping'&&'Control_'&&'N'&&''&&''&&'Control'&&'2'&&'Identifier'&&''&&'A foreign key to the Control table, name of the control.'"
val_EventMapping(2) = "'EventMapping'&&'Event'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'An identifier that specifies the type of the event that the control subscribes to.'"
val_EventMapping(3) = "'EventMapping'&&'Attribute'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The name of the control attribute, that is set when this event is received.'"
val_dicValidation.Add "EventMapping", val_EventMapping

Dim val_Extension(4)
val_Extension(0) = "'Extension'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Required foreign key into the Feature Table, specifying the feature to validate or install in order for the CLSID factory to be operational.'"
val_Extension(1) = "'Extension'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table, specifying the component for which to return a path when called through LocateComponent.'"
val_Extension(2) = "'Extension'&&'Extension'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The extension associated with the table row.'"
val_Extension(3) = "'Extension'&&'MIME_'&&'Y'&&''&&''&&'MIME'&&'1'&&'Text'&&''&&'Optional Context identifier, typically ""type/format"" associated with the extension'"
val_Extension(4) = "'Extension'&&'ProgId_'&&'Y'&&''&&''&&'ProgId'&&'1'&&'Text'&&''&&'Optional ProgId associated with this extension.'"
val_dicValidation.Add "Extension", val_Extension

Dim val_MIME(2)
val_MIME(0) = "'MIME'&&'CLSID'&&'Y'&&''&&''&&''&&''&&'Guid'&&''&&'Optional associated CLSID.'"
val_MIME(1) = "'MIME'&&'ContentType'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Primary key. Context identifier, typically ""type/format"".'"
val_MIME(2) = "'MIME'&&'Extension_'&&'N'&&''&&''&&'Extension'&&'1'&&'Text'&&''&&'Optional associated extension (without dot)'"
val_dicValidation.Add "MIME", val_MIME

Dim val_FeatureComponents(1)
val_FeatureComponents(0) = "'FeatureComponents'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Foreign key into Feature table.'"
val_FeatureComponents(1) = "'FeatureComponents'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into Component table.'"
val_dicValidation.Add "FeatureComponents", val_FeatureComponents

Dim val_FileSFPCatalog(1)
val_FileSFPCatalog(0) = "'FileSFPCatalog'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'File associated with the catalog'"
val_FileSFPCatalog(1) = "'FileSFPCatalog'&&'SFPCatalog_'&&'N'&&''&&''&&'SFPCatalog'&&'1'&&'Filename'&&''&&'Catalog associated with the file'"
val_dicValidation.Add "FileSFPCatalog", val_FileSFPCatalog

Dim val_SFPCatalog(2)
val_SFPCatalog(0) = "'SFPCatalog'&&'SFPCatalog'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'File name for the catalog.'"
val_SFPCatalog(1) = "'SFPCatalog'&&'Catalog'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'SFP Catalog'"
val_SFPCatalog(2) = "'SFPCatalog'&&'Dependency'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Parent catalog - only used by SFP'"
val_dicValidation.Add "SFPCatalog", val_SFPCatalog

Dim val_Font(1)
val_Font(0) = "'Font'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Primary key, foreign key into File table referencing font file.'"
val_Font(1) = "'Font'&&'FontTitle'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Font name.'"
val_dicValidation.Add "Font", val_Font

Dim val_IniFile(7)
val_IniFile(0) = "'IniFile'&&'Action'&&'N'&&''&&''&&''&&''&&''&&'0;1;3'&&'The type of modification to be made, one of iifEnum'"
val_IniFile(1) = "'IniFile'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value to be written.'"
val_IniFile(2) = "'IniFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the installing of the .INI value.'"
val_IniFile(3) = "'IniFile'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The .INI file name in which to write the information'"
val_IniFile(4) = "'IniFile'&&'IniFile'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_IniFile(5) = "'IniFile'&&'DirProperty'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Foreign key into the Directory table denoting the directory where the .INI file is.'"
val_IniFile(6) = "'IniFile'&&'Key'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file key below Section.'"
val_IniFile(7) = "'IniFile'&&'Section'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file Section.'"
val_dicValidation.Add "IniFile", val_IniFile

Dim val_IniLocator(5)
val_IniLocator(0) = "'IniLocator'&&'Type'&&'Y'&&'0'&&'2'&&''&&''&&''&&''&&'An integer value that determines if the .INI value read is a filename or a directory location or to be used as is w/o interpretation.'"
val_IniLocator(1) = "'IniLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature_ represents a unique file signature and is also the foreign key in the Signature table.'"
val_IniLocator(2) = "'IniLocator'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The .INI file name.'"
val_IniLocator(3) = "'IniLocator'&&'Key'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Key value (followed by an equals sign in INI file).'"
val_IniLocator(4) = "'IniLocator'&&'Section'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Section name within in file (within square brackets in INI file).'"
val_IniLocator(5) = "'IniLocator'&&'Field'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The field in the .INI line. If Field is null or 0 the entire line is read.'"
val_dicValidation.Add "IniLocator", val_IniLocator

Dim val_InstallExecuteSequence(2)
val_InstallExecuteSequence(0) = "'InstallExecuteSequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_InstallExecuteSequence(1) = "'InstallExecuteSequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_InstallExecuteSequence(2) = "'InstallExecuteSequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "InstallExecuteSequence", val_InstallExecuteSequence

Dim val_InstallUISequence(2)
val_InstallUISequence(0) = "'InstallUISequence'&&'Action'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of action to invoke, either in the engine or the handler DLL.'"
val_InstallUISequence(1) = "'InstallUISequence'&&'Condition'&&'Y'&&''&&''&&''&&''&&'Condition'&&''&&'Optional expression which skips the action if evaluates to expFalse.If the expression syntax is invalid, the engine will terminate, returning iesBadActionData.'"
val_InstallUISequence(2) = "'InstallUISequence'&&'Sequence'&&'Y'&&'-4'&&'32767'&&''&&''&&''&&''&&'Number that determines the sort order in which the actions are to be executed.  Leave blank to suppress action.'"
val_dicValidation.Add "InstallUISequence", val_InstallUISequence

Dim val_IsolatedComponent(1)
val_IsolatedComponent(0) = "'IsolatedComponent'&&'Component_Application'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Key to Component table item for application'"
val_IsolatedComponent(1) = "'IsolatedComponent'&&'Component_Shared'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Key to Component table item to be isolated'"
val_dicValidation.Add "IsolatedComponent", val_IsolatedComponent

Dim val_LaunchCondition(1)
val_LaunchCondition(0) = "'LaunchCondition'&&'Description'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'Localizable text to display when condition fails and install must abort.'"
val_LaunchCondition(1) = "'LaunchCondition'&&'Condition'&&'N'&&''&&''&&''&&''&&'Condition'&&''&&'Expression which must evaluate to TRUE in order for install to commence.'"
val_dicValidation.Add "LaunchCondition", val_LaunchCondition

Dim val_ListBox(3)
val_ListBox(0) = "'ListBox'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.'"
val_ListBox(1) = "'ListBox'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this item. All the items tied to the same property become part of the same listbox.'"
val_ListBox(2) = "'ListBox'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with this item. Selecting the line will set the associated property to this value.'"
val_ListBox(3) = "'ListBox'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.'"
val_dicValidation.Add "ListBox", val_ListBox

Dim val_ListView(4)
val_ListView(0) = "'ListView'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The visible text to be assigned to the item. Optional. If this entry or the entire column is missing, the text is the same as the value.'"
val_ListView(1) = "'ListView'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this item. All the items tied to the same property become part of the same listview.'"
val_ListView(2) = "'ListView'&&'Value'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The value string associated with this item. Selecting the line will set the associated property to this value.'"
val_ListView(3) = "'ListView'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.'"
val_ListView(4) = "'ListView'&&'Binary_'&&'Y'&&''&&''&&'Binary'&&'1'&&'Identifier'&&''&&'The name of the icon to be displayed with the icon. The binary information is looked up from the Binary Table.'"
val_dicValidation.Add "ListView", val_ListView

Dim val_LockPermissions(4)
val_LockPermissions(0) = "'LockPermissions'&&'Table'&&'N'&&''&&''&&''&&''&&'Identifier'&&'Directory;File;Registry'&&'Reference to another table name'"
val_LockPermissions(1) = "'LockPermissions'&&'Domain'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Domain name for user whose permissions are being set. (usually a property)'"
val_LockPermissions(2) = "'LockPermissions'&&'LockObject'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Foreign key into Registry or File table'"
val_LockPermissions(3) = "'LockPermissions'&&'Permission'&&'Y'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Permission Access mask.  Full Control = 268435456 (GENERIC_ALL = 0x10000000)'"
val_LockPermissions(4) = "'LockPermissions'&&'User'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'User for permissions to be set.  (usually a property)'"
val_dicValidation.Add "LockPermissions", val_LockPermissions

Dim val_Media(5)
val_Media(0) = "'Media'&&'Source'&&'Y'&&''&&''&&''&&''&&'Property'&&''&&'The property defining the location of the cabinet file.'"
val_Media(1) = "'Media'&&'Cabinet'&&'Y'&&''&&''&&''&&''&&'Cabinet'&&''&&'If some or all of the files stored on the media are compressed in a cabinet, the name of that cabinet.'"
val_Media(2) = "'Media'&&'DiskId'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'Primary key, integer to determine sort order for table.'"
val_Media(3) = "'Media'&&'DiskPrompt'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Disk name: the visible text actually printed on the disk.  This will be used to prompt the user when this disk needs to be inserted.'"
val_Media(4) = "'Media'&&'LastSequence'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'File sequence number for the last file for this media.'"
val_Media(5) = "'Media'&&'VolumeLabel'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The label attributed to the volume.'"
val_dicValidation.Add "Media", val_Media

Dim val_ModuleComponents(2)
val_ModuleComponents(0) = "'ModuleComponents'&&'Component'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Component contained in the module.'"
val_ModuleComponents(1) = "'ModuleComponents'&&'Language'&&'N'&&''&&''&&'ModuleSignature'&&'2'&&''&&''&&'Default language ID for module (may be changed by transform).'"
val_ModuleComponents(2) = "'ModuleComponents'&&'ModuleID'&&'N'&&''&&''&&'ModuleSignature'&&'1'&&'Identifier'&&''&&'Module containing the component.'"
val_dicValidation.Add "ModuleComponents", val_ModuleComponents

Dim val_ModuleSignature(2)
val_ModuleSignature(0) = "'ModuleSignature'&&'Language'&&'N'&&''&&''&&''&&''&&''&&''&&'Default decimal language of module.'"
val_ModuleSignature(1) = "'ModuleSignature'&&'Version'&&'N'&&''&&''&&''&&''&&'Version'&&''&&'Version of the module.'"
val_ModuleSignature(2) = "'ModuleSignature'&&'ModuleID'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Module identifier (String.GUID).'"
val_dicValidation.Add "ModuleSignature", val_ModuleSignature

Dim val_ModuleDependency(4)
val_ModuleDependency(0) = "'ModuleDependency'&&'ModuleID'&&'N'&&''&&''&&'ModuleSignature'&&'1'&&'Identifier'&&''&&'Module requiring the dependency.'"
val_ModuleDependency(1) = "'ModuleDependency'&&'ModuleLanguage'&&'N'&&''&&''&&'ModuleSignature'&&'2'&&''&&''&&'Language of module requiring the dependency.'"
val_ModuleDependency(2) = "'ModuleDependency'&&'RequiredID'&&'N'&&''&&''&&''&&''&&''&&''&&'String.GUID of required module.'"
val_ModuleDependency(3) = "'ModuleDependency'&&'RequiredLanguage'&&'N'&&''&&''&&''&&''&&''&&''&&'LanguageID of the required module.'"
val_ModuleDependency(4) = "'ModuleDependency'&&'RequiredVersion'&&'Y'&&''&&''&&''&&''&&'Version'&&''&&'Version of the required version.'"
val_dicValidation.Add "ModuleDependency", val_ModuleDependency

Dim val_ModuleExclusion(5)
val_ModuleExclusion(0) = "'ModuleExclusion'&&'ModuleID'&&'N'&&''&&''&&'ModuleSignature'&&'1'&&'Identifier'&&''&&'String.GUID of module with exclusion requirement.'"
val_ModuleExclusion(1) = "'ModuleExclusion'&&'ModuleLanguage'&&'N'&&''&&''&&'ModuleSignature'&&'2'&&''&&''&&'LanguageID of module with exclusion requirement.'"
val_ModuleExclusion(2) = "'ModuleExclusion'&&'ExcludedID'&&'N'&&''&&''&&''&&''&&''&&''&&'String.GUID of excluded module.'"
val_ModuleExclusion(3) = "'ModuleExclusion'&&'ExcludedLanguage'&&'N'&&''&&''&&''&&''&&''&&''&&'Language of excluded module.'"
val_ModuleExclusion(4) = "'ModuleExclusion'&&'ExcludedMaxVersion'&&'Y'&&''&&''&&''&&''&&'Version'&&''&&'Maximum version of excluded module.'"
val_ModuleExclusion(5) = "'ModuleExclusion'&&'ExcludedMinVersion'&&'Y'&&''&&''&&''&&''&&'Version'&&''&&'Minimum version of excluded module.'"
val_dicValidation.Add "ModuleExclusion", val_ModuleExclusion

Dim val_MoveFile(6)
val_MoveFile(0) = "'MoveFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'If this component is not ""selected"" for installation or removal, no action will be taken on the associated MoveFile entry'"
val_MoveFile(1) = "'MoveFile'&&'DestFolder'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full path to the destination directory'"
val_MoveFile(2) = "'MoveFile'&&'DestName'&&'Y'&&''&&''&&''&&''&&'Filename'&&''&&'Name to be given to the original file after it is moved or copied.  If blank, the destination file will be given the same name as the source file'"
val_MoveFile(3) = "'MoveFile'&&'FileKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key that uniquely identifies a particular MoveFile record'"
val_MoveFile(4) = "'MoveFile'&&'Options'&&'N'&&'0'&&'1'&&''&&''&&''&&''&&'Integer value specifying the MoveFile operating mode, one of imfoEnum'"
val_MoveFile(5) = "'MoveFile'&&'SourceFolder'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full path to the source directory'"
val_MoveFile(6) = "'MoveFile'&&'SourceName'&&'Y'&&''&&''&&''&&''&&'WildCardFilename'&&''&&'Name of the source file(s) to be moved or copied.  Can contain the '*' or '?' wildcards.'"
val_dicValidation.Add "MoveFile", val_MoveFile

Dim val_MsiAssembly(4)
val_MsiAssembly(0) = "'MsiAssembly'&&'Attributes'&&'Y'&&''&&''&&''&&''&&''&&''&&'Assembly attributes'"
val_MsiAssembly(1) = "'MsiAssembly'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Foreign key into Feature table.'"
val_MsiAssembly(2) = "'MsiAssembly'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into Component table.'"
val_MsiAssembly(3) = "'MsiAssembly'&&'File_Application'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key into File table, denoting the application context for private assemblies. Null for global assemblies.'"
val_MsiAssembly(4) = "'MsiAssembly'&&'File_Manifest'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key into the File table denoting the manifest file for the assembly.'"
val_dicValidation.Add "MsiAssembly", val_MsiAssembly

Dim val_MsiAssemblyName(2)
val_MsiAssemblyName(0) = "'MsiAssemblyName'&&'Name'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The name part of the name-value pairs for the assembly name.'"
val_MsiAssemblyName(1) = "'MsiAssemblyName'&&'Value'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The value part of the name-value pairs for the assembly name.'"
val_MsiAssemblyName(2) = "'MsiAssemblyName'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into Component table.'"
val_dicValidation.Add "MsiAssemblyName", val_MsiAssemblyName

Dim val_MsiDigitalCertificate(1)
val_MsiDigitalCertificate(0) = "'MsiDigitalCertificate'&&'CertData'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'A certificate context blob for a signer certificate'"
val_MsiDigitalCertificate(1) = "'MsiDigitalCertificate'&&'DigitalCertificate'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A unique identifier for the row'"
val_dicValidation.Add "MsiDigitalCertificate", val_MsiDigitalCertificate

Dim val_MsiDigitalSignature(3)
val_MsiDigitalSignature(0) = "'MsiDigitalSignature'&&'Table'&&'N'&&''&&''&&''&&''&&''&&'Media'&&'Reference to another table name (only Media table is supported)'"
val_MsiDigitalSignature(1) = "'MsiDigitalSignature'&&'DigitalCertificate_'&&'N'&&''&&''&&'MsiDigitalCertificate'&&'1'&&'Identifier'&&''&&'Foreign key to MsiDigitalCertificate table identifying the signer certificate'"
val_MsiDigitalSignature(2) = "'MsiDigitalSignature'&&'Hash'&&'Y'&&''&&''&&''&&''&&'Binary'&&''&&'The encoded hash blob from the digital signature'"
val_MsiDigitalSignature(3) = "'MsiDigitalSignature'&&'SignObject'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Foreign key to Media table'"
val_dicValidation.Add "MsiDigitalSignature", val_MsiDigitalSignature

Dim val_MsiFileHash(5)
val_MsiFileHash(0) = "'MsiFileHash'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Primary key, foreign key into File table referencing file with this hash'"
val_MsiFileHash(1) = "'MsiFileHash'&&'Options'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Various options and attributes for this hash.'"
val_MsiFileHash(2) = "'MsiFileHash'&&'HashPart1'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_MsiFileHash(3) = "'MsiFileHash'&&'HashPart2'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_MsiFileHash(4) = "'MsiFileHash'&&'HashPart3'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_MsiFileHash(5) = "'MsiFileHash'&&'HashPart4'&&'N'&&''&&''&&''&&''&&''&&''&&'Size of file in bytes (long integer).'"
val_dicValidation.Add "MsiFileHash", val_MsiFileHash

Dim val_MsiPatchHeaders(1)
val_MsiPatchHeaders(0) = "'MsiPatchHeaders'&&'StreamRef'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key. A unique identifier for the row.'"
val_MsiPatchHeaders(1) = "'MsiPatchHeaders'&&'Header'&&'N'&&''&&''&&''&&''&&'Binary'&&''&&'Binary stream. The patch header, used for patch validation.'"
val_dicValidation.Add "MsiPatchHeaders", val_MsiPatchHeaders

Dim val_ODBCAttribute(2)
val_ODBCAttribute(0) = "'ODBCAttribute'&&'Value'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Value for ODBC driver attribute'"
val_ODBCAttribute(1) = "'ODBCAttribute'&&'Attribute'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Name of ODBC driver attribute'"
val_ODBCAttribute(2) = "'ODBCAttribute'&&'Driver_'&&'N'&&''&&''&&'ODBCDriver'&&'1'&&'Identifier'&&''&&'Reference to ODBC driver in ODBCDriver table'"
val_dicValidation.Add "ODBCAttribute", val_ODBCAttribute

Dim val_ODBCDriver(4)
val_ODBCDriver(0) = "'ODBCDriver'&&'Description'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Text used as registered name for driver, non-localized'"
val_ODBCDriver(1) = "'ODBCDriver'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Reference to key driver file'"
val_ODBCDriver(2) = "'ODBCDriver'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reference to associated component'"
val_ODBCDriver(3) = "'ODBCDriver'&&'Driver'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized.internal token for driver'"
val_ODBCDriver(4) = "'ODBCDriver'&&'File_Setup'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Optional reference to key driver setup DLL'"
val_dicValidation.Add "ODBCDriver", val_ODBCDriver

Dim val_ODBCDataSource(4)
val_ODBCDataSource(0) = "'ODBCDataSource'&&'Description'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Text used as registered name for data source'"
val_ODBCDataSource(1) = "'ODBCDataSource'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reference to associated component'"
val_ODBCDataSource(2) = "'ODBCDataSource'&&'DataSource'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized.internal token for data source'"
val_ODBCDataSource(3) = "'ODBCDataSource'&&'DriverDescription'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Reference to driver description, may be existing driver'"
val_ODBCDataSource(4) = "'ODBCDataSource'&&'Registration'&&'N'&&'0'&&'1'&&''&&''&&''&&''&&'Registration option: 0=machine, 1=user, others t.b.d.'"
val_dicValidation.Add "ODBCDataSource", val_ODBCDataSource

Dim val_ODBCSourceAttribute(2)
val_ODBCSourceAttribute(0) = "'ODBCSourceAttribute'&&'Value'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Value for ODBC data source attribute'"
val_ODBCSourceAttribute(1) = "'ODBCSourceAttribute'&&'Attribute'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Name of ODBC data source attribute'"
val_ODBCSourceAttribute(2) = "'ODBCSourceAttribute'&&'DataSource_'&&'N'&&''&&''&&'ODBCDataSource'&&'1'&&'Identifier'&&''&&'Reference to ODBC data source in ODBCDataSource table'"
val_dicValidation.Add "ODBCSourceAttribute", val_ODBCSourceAttribute

Dim val_ODBCTranslator(4)
val_ODBCTranslator(0) = "'ODBCTranslator'&&'Description'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'Text used as registered name for translator'"
val_ODBCTranslator(1) = "'ODBCTranslator'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Reference to key translator file'"
val_ODBCTranslator(2) = "'ODBCTranslator'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reference to associated component'"
val_ODBCTranslator(3) = "'ODBCTranslator'&&'File_Setup'&&'Y'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Optional reference to key translator setup DLL'"
val_ODBCTranslator(4) = "'ODBCTranslator'&&'Translator'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized.internal token for translator'"
val_dicValidation.Add "ODBCTranslator", val_ODBCTranslator

Dim val_Patch(5)
val_Patch(0) = "'Patch'&&'Sequence'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Primary key, sequence with respect to the media images; order must track cabinet order.'"
val_Patch(1) = "'Patch'&&'Attributes'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Integer containing bit flags representing patch attributes'"
val_Patch(2) = "'Patch'&&'File_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token, foreign key to File table, must match identifier in cabinet.'"
val_Patch(3) = "'Patch'&&'Header'&&'Y'&&''&&''&&''&&''&&'Binary'&&''&&'Binary stream. The patch header, used for patch validation.'"
val_Patch(4) = "'Patch'&&'PatchSize'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Size of patch in bytes (long integer).'"
val_Patch(5) = "'Patch'&&'StreamRef_'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Identifier. Foreign key to the StreamRef column of the MsiPatchHeaders table.'"
val_dicValidation.Add "Patch", val_Patch

Dim val_PatchPackage(1)
val_PatchPackage(0) = "'PatchPackage'&&'Media_'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'Foreign key to DiskId column of Media table. Indicates the disk containing the patch package.'"
val_PatchPackage(1) = "'PatchPackage'&&'PatchId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'A unique string GUID representing this patch.'"
val_dicValidation.Add "PatchPackage", val_PatchPackage

Dim val_PublishComponent(4)
val_PublishComponent(0) = "'PublishComponent'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Foreign key into the Feature table.'"
val_PublishComponent(1) = "'PublishComponent'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table.'"
val_PublishComponent(2) = "'PublishComponent'&&'ComponentId'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'A string GUID that represents the component id that will be requested by the alien product.'"
val_PublishComponent(3) = "'PublishComponent'&&'AppData'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'This is localisable Application specific data that can be associated with a Qualified Component.'"
val_PublishComponent(4) = "'PublishComponent'&&'Qualifier'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'This is defined only when the ComponentId column is an Qualified Component Id. This is the Qualifier for ProvideComponentIndirect.'"
val_dicValidation.Add "PublishComponent", val_PublishComponent

Dim val_RadioButton(8)
val_RadioButton(0) = "'RadioButton'&&'Y'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The vertical coordinate of the upper left corner of the bounding rectangle of the radio button.'"
val_RadioButton(1) = "'RadioButton'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The visible title to be assigned to the radio button.'"
val_RadioButton(2) = "'RadioButton'&&'Property'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A named property to be tied to this radio button. All the buttons tied to the same property become part of the same group.'"
val_RadioButton(3) = "'RadioButton'&&'Height'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The height of the button.'"
val_RadioButton(4) = "'RadioButton'&&'Width'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The width of the button.'"
val_RadioButton(5) = "'RadioButton'&&'X'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The horizontal coordinate of the upper left corner of the bounding rectangle of the radio button.'"
val_RadioButton(6) = "'RadioButton'&&'Value'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The value string associated with this button. Selecting the button will set the associated property to this value.'"
val_RadioButton(7) = "'RadioButton'&&'Order'&&'N'&&'1'&&'32767'&&''&&''&&''&&''&&'A positive integer used to determine the ordering of the items within one list..The integers do not have to be consecutive.'"
val_RadioButton(8) = "'RadioButton'&&'Help'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The help strings used with the button. The text is optional.'"
val_dicValidation.Add "RadioButton", val_RadioButton

Dim val_Registry(5)
val_Registry(0) = "'Registry'&&'Name'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value name.'"
val_Registry(1) = "'Registry'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value.'"
val_Registry(2) = "'Registry'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the installing of the registry value.'"
val_Registry(3) = "'Registry'&&'Key'&&'N'&&''&&''&&''&&''&&'RegPath'&&''&&'The key for the registry value.'"
val_Registry(4) = "'Registry'&&'Registry'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_Registry(5) = "'Registry'&&'Root'&&'N'&&'-1'&&'3'&&''&&''&&''&&''&&'The predefined root key for the registry value, one of rrkEnum.'"
val_dicValidation.Add "Registry", val_Registry

Dim val_RegLocator(4)
val_RegLocator(0) = "'RegLocator'&&'Name'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value name.'"
val_RegLocator(1) = "'RegLocator'&&'Type'&&'Y'&&'0'&&'18'&&''&&''&&''&&''&&'An integer value that determines if the registry value is a filename or a directory location or to be used as is w/o interpretation.'"
val_RegLocator(2) = "'RegLocator'&&'Signature_'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature_ represents a unique file signature and is also the foreign key in the Signature table. If the type is 0, the registry values refers a directory, and _Signature is not a foreign key.'"
val_RegLocator(3) = "'RegLocator'&&'Key'&&'N'&&''&&''&&''&&''&&'RegPath'&&''&&'The key for the registry value.'"
val_RegLocator(4) = "'RegLocator'&&'Root'&&'N'&&'0'&&'3'&&''&&''&&''&&''&&'The predefined root key for the registry value, one of rrkEnum.'"
val_dicValidation.Add "RegLocator", val_RegLocator

Dim val_RemoveFile(4)
val_RemoveFile(0) = "'RemoveFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key referencing Component that controls the file to be removed.'"
val_RemoveFile(1) = "'RemoveFile'&&'FileKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key used to identify a particular file entry'"
val_RemoveFile(2) = "'RemoveFile'&&'FileName'&&'Y'&&''&&''&&''&&''&&'WildCardFilename'&&''&&'Name of the file to be removed.'"
val_RemoveFile(3) = "'RemoveFile'&&'DirProperty'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full pathname to the folder of the file to be removed.'"
val_RemoveFile(4) = "'RemoveFile'&&'InstallMode'&&'N'&&''&&''&&''&&''&&''&&'1;2;3'&&'Installation option, one of iimEnum.'"
val_dicValidation.Add "RemoveFile", val_RemoveFile

Dim val_RemoveIniFile(7)
val_RemoveIniFile(0) = "'RemoveIniFile'&&'Action'&&'N'&&''&&''&&''&&''&&''&&'2;4'&&'The type of modification to be made, one of iifEnum.'"
val_RemoveIniFile(1) = "'RemoveIniFile'&&'Value'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The value to be deleted. The value is required when Action is iifIniRemoveTag'"
val_RemoveIniFile(2) = "'RemoveIniFile'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the deletion of the .INI value.'"
val_RemoveIniFile(3) = "'RemoveIniFile'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The .INI file name in which to delete the information'"
val_RemoveIniFile(4) = "'RemoveIniFile'&&'DirProperty'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Foreign key into the Directory table denoting the directory where the .INI file is.'"
val_RemoveIniFile(5) = "'RemoveIniFile'&&'Key'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file key below Section.'"
val_RemoveIniFile(6) = "'RemoveIniFile'&&'Section'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'The .INI file Section.'"
val_RemoveIniFile(7) = "'RemoveIniFile'&&'RemoveIniFile'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_dicValidation.Add "RemoveIniFile", val_RemoveIniFile

Dim val_RemoveRegistry(4)
val_RemoveRegistry(0) = "'RemoveRegistry'&&'Name'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The registry value name.'"
val_RemoveRegistry(1) = "'RemoveRegistry'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table referencing component that controls the deletion of the registry value.'"
val_RemoveRegistry(2) = "'RemoveRegistry'&&'Key'&&'N'&&''&&''&&''&&''&&'RegPath'&&''&&'The key for the registry value.'"
val_RemoveRegistry(3) = "'RemoveRegistry'&&'Root'&&'N'&&'-1'&&'3'&&''&&''&&''&&''&&'The predefined root key for the registry value, one of rrkEnum'"
val_RemoveRegistry(4) = "'RemoveRegistry'&&'RemoveRegistry'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_dicValidation.Add "RemoveRegistry", val_RemoveRegistry

Dim val_ReserveCost(4)
val_ReserveCost(0) = "'ReserveCost'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Reserve a specified amount of space if this component is to be installed.'"
val_ReserveCost(1) = "'ReserveCost'&&'ReserveFolder'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of a property whose value is assumed to resolve to the full path to the destination directory'"
val_ReserveCost(2) = "'ReserveCost'&&'ReserveKey'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key that uniquely identifies a particular ReserveCost record'"
val_ReserveCost(3) = "'ReserveCost'&&'ReserveLocal'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Disk space to reserve if linked component is installed locally.'"
val_ReserveCost(4) = "'ReserveCost'&&'ReserveSource'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'Disk space to reserve if linked component is installed to run from the source location.'"
val_dicValidation.Add "ReserveCost", val_ReserveCost

Dim val_SelfReg(1)
val_SelfReg(0) = "'SelfReg'&&'File_'&&'N'&&''&&''&&'File'&&'1'&&'Identifier'&&''&&'Foreign key into the File table denoting the module that needs to be registered.'"
val_SelfReg(1) = "'SelfReg'&&'Cost'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The cost of registering the module.'"
val_dicValidation.Add "SelfReg", val_SelfReg

Dim val_ServiceControl(5)
val_ServiceControl(0) = "'ServiceControl'&&'Name'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'Name of a service. /, \, comma and space are invalid'"
val_ServiceControl(1) = "'ServiceControl'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table that controls the startup of the service'"
val_ServiceControl(2) = "'ServiceControl'&&'Event'&&'N'&&'0'&&'187'&&''&&''&&''&&''&&'Bit field:  Install:  0x1 = Start, 0x2 = Stop, 0x8 = Delete, Uninstall: 0x10 = Start, 0x20 = Stop, 0x80 = Delete'"
val_ServiceControl(3) = "'ServiceControl'&&'ServiceControl'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_ServiceControl(4) = "'ServiceControl'&&'Arguments'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Arguments for the service.  Separate by [~].'"
val_ServiceControl(5) = "'ServiceControl'&&'Wait'&&'Y'&&'0'&&'1'&&''&&''&&''&&''&&'Boolean for whether to wait for the service to fully start'"
val_dicValidation.Add "ServiceControl", val_ServiceControl

Dim val_ServiceInstall(12)
val_ServiceInstall(0) = "'ServiceInstall'&&'Name'&&'N'&&''&&''&&''&&''&&'Formatted'&&''&&'Internal Name of the Service'"
val_ServiceInstall(1) = "'ServiceInstall'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'Description of service.'"
val_ServiceInstall(2) = "'ServiceInstall'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table that controls the startup of the service'"
val_ServiceInstall(3) = "'ServiceInstall'&&'Arguments'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Arguments to include in every start of the service, passed to WinMain'"
val_ServiceInstall(4) = "'ServiceInstall'&&'ServiceInstall'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_ServiceInstall(5) = "'ServiceInstall'&&'Dependencies'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Other services this depends on to start.  Separate by [~], and end with [~][~]'"
val_ServiceInstall(6) = "'ServiceInstall'&&'DisplayName'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'External Name of the Service'"
val_ServiceInstall(7) = "'ServiceInstall'&&'ErrorControl'&&'N'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Severity of error if service fails to start'"
val_ServiceInstall(8) = "'ServiceInstall'&&'LoadOrderGroup'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'LoadOrderGroup'"
val_ServiceInstall(9) = "'ServiceInstall'&&'Password'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'password to run service with.  (with StartName)'"
val_ServiceInstall(10) = "'ServiceInstall'&&'ServiceType'&&'N'&&'-2147483647'&&'2147483647'&&''&&''&&''&&''&&'Type of the service'"
val_ServiceInstall(11) = "'ServiceInstall'&&'StartName'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'User or object name to run service as'"
val_ServiceInstall(12) = "'ServiceInstall'&&'StartType'&&'N'&&'0'&&'4'&&''&&''&&''&&''&&'Type of the service'"
val_dicValidation.Add "ServiceInstall", val_ServiceInstall

Dim val_Shortcut(11)
val_Shortcut(0) = "'Shortcut'&&'Name'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The name of the shortcut to be created.'"
val_Shortcut(1) = "'Shortcut'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The description for the shortcut.'"
val_Shortcut(2) = "'Shortcut'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Foreign key into the Component table denoting the component whose selection gates the the shortcut creation/deletion.'"
val_Shortcut(3) = "'Shortcut'&&'Icon_'&&'Y'&&''&&''&&'Icon'&&'1'&&'Identifier'&&''&&'Foreign key into the File table denoting the external icon file for the shortcut.'"
val_Shortcut(4) = "'Shortcut'&&'IconIndex'&&'Y'&&'-32767'&&'32767'&&''&&''&&''&&''&&'The icon index for the shortcut.'"
val_Shortcut(5) = "'Shortcut'&&'Directory_'&&'N'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Foreign key into the Directory table denoting the directory where the shortcut file is created.'"
val_Shortcut(6) = "'Shortcut'&&'Target'&&'N'&&''&&''&&''&&''&&'Shortcut'&&''&&'The shortcut target. This is usually a property that is expanded to a file or a folder that the shortcut points to.'"
val_Shortcut(7) = "'Shortcut'&&'Arguments'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The command-line arguments for the shortcut.'"
val_Shortcut(8) = "'Shortcut'&&'Shortcut'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Primary key, non-localized token.'"
val_Shortcut(9) = "'Shortcut'&&'Hotkey'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'The hotkey for the shortcut. It has the virtual-key code for the key in the low-order byte, and the modifier flags in the high-order byte. '"
val_Shortcut(10) = "'Shortcut'&&'ShowCmd'&&'Y'&&''&&''&&''&&''&&''&&'1;3;7'&&'The show command for the application window.The following values may be used.'"
val_Shortcut(11) = "'Shortcut'&&'WkDir'&&'Y'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of property defining location of working directory.'"
val_dicValidation.Add "Shortcut", val_Shortcut

Dim val_Signature(8)
val_Signature(0) = "'Signature'&&'FileName'&&'N'&&''&&''&&''&&''&&'Filename'&&''&&'The name of the file. This may contain a ""short name|long name"" pair.'"
val_Signature(1) = "'Signature'&&'Signature'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'The table key. The Signature represents a unique file signature.'"
val_Signature(2) = "'Signature'&&'Languages'&&'Y'&&''&&''&&''&&''&&'Language'&&''&&'The languages supported by the file.'"
val_Signature(3) = "'Signature'&&'MaxDate'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The maximum creation date of the file.'"
val_Signature(4) = "'Signature'&&'MaxSize'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The maximum size of the file. '"
val_Signature(5) = "'Signature'&&'MaxVersion'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The maximum version of the file.'"
val_Signature(6) = "'Signature'&&'MinDate'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The minimum creation date of the file.'"
val_Signature(7) = "'Signature'&&'MinSize'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The minimum size of the file.'"
val_Signature(8) = "'Signature'&&'MinVersion'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The minimum version of the file.'"
val_dicValidation.Add "Signature", val_Signature

Dim val_TextStyle(4)
val_TextStyle(0) = "'TextStyle'&&'TextStyle'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'Name of the style. The primary key of this table. This name is embedded in the texts to indicate a style change.'"
val_TextStyle(1) = "'TextStyle'&&'Color'&&'Y'&&'0'&&'16777215'&&''&&''&&''&&''&&'A long integer indicating the color of the string in the RGB format (Red, Green, Blue each 0-255, RGB = R + 256*G + 256^2*B).'"
val_TextStyle(2) = "'TextStyle'&&'FaceName'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'A string indicating the name of the font used. Required. The string must be at most 31 characters long.'"
val_TextStyle(3) = "'TextStyle'&&'Size'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The size of the font used. This size is given in our units (1/12 of the system font height). Assuming that the system font is set to 12 point size, this is equivalent to the point size.'"
val_TextStyle(4) = "'TextStyle'&&'StyleBits'&&'Y'&&'0'&&'15'&&''&&''&&''&&''&&'A combination of style bits.'"
val_dicValidation.Add "TextStyle", val_TextStyle

Dim val_TypeLib(7)
val_TypeLib(0) = "'TypeLib'&&'Description'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&''"
val_TypeLib(1) = "'TypeLib'&&'Feature_'&&'N'&&''&&''&&'Feature'&&'1'&&'Identifier'&&''&&'Required foreign key into the Feature Table, specifying the feature to validate or install in order for the type library to be operational.'"
val_TypeLib(2) = "'TypeLib'&&'Component_'&&'N'&&''&&''&&'Component'&&'1'&&'Identifier'&&''&&'Required foreign key into the Component Table, specifying the component for which to return a path when called through LocateComponent.'"
val_TypeLib(3) = "'TypeLib'&&'Directory_'&&'Y'&&''&&''&&'Directory'&&'1'&&'Identifier'&&''&&'Optional. The foreign key into the Directory table denoting the path to the help file for the type library.'"
val_TypeLib(4) = "'TypeLib'&&'Language'&&'N'&&'0'&&'32767'&&''&&''&&''&&''&&'The language of the library.'"
val_TypeLib(5) = "'TypeLib'&&'Version'&&'Y'&&'0'&&'16777215'&&''&&''&&''&&''&&'The version of the library. The minor version is in the lower 8 bits of the integer. The major version is in the next 16 bits. '"
val_TypeLib(6) = "'TypeLib'&&'Cost'&&'Y'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The cost associated with the registration of the typelib. This column is currently optional.'"
val_TypeLib(7) = "'TypeLib'&&'LibID'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'The GUID that represents the library.'"
val_dicValidation.Add "TypeLib", val_TypeLib

Dim val_UIText(1)
val_UIText(0) = "'UIText'&&'Text'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The localized version of the string.'"
val_UIText(1) = "'UIText'&&'Key'&&'N'&&''&&''&&''&&''&&'Identifier'&&''&&'A unique key that identifies the particular string.'"
val_dicValidation.Add "UIText", val_UIText

Dim val_Upgrade(6)
val_Upgrade(0) = "'Upgrade'&&'Attributes'&&'N'&&'0'&&'2147483647'&&''&&''&&''&&''&&'The attributes of this product set.'"
val_Upgrade(1) = "'Upgrade'&&'Language'&&'Y'&&''&&''&&''&&''&&'Language'&&''&&'A comma-separated list of languages for either products in this set or products not in this set.'"
val_Upgrade(2) = "'Upgrade'&&'ActionProperty'&&'N'&&''&&''&&''&&''&&'UpperCase'&&''&&'The property to set when a product in this set is found.'"
val_Upgrade(3) = "'Upgrade'&&'Remove'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The list of features to remove when uninstalling a product from this set.  The default is ""ALL"".'"
val_Upgrade(4) = "'Upgrade'&&'UpgradeCode'&&'N'&&''&&''&&''&&''&&'Guid'&&''&&'The UpgradeCode GUID belonging to the products in this set.'"
val_Upgrade(5) = "'Upgrade'&&'VersionMax'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The maximum ProductVersion of the products in this set.  The set may or may not include products with this particular version.'"
val_Upgrade(6) = "'Upgrade'&&'VersionMin'&&'Y'&&''&&''&&''&&''&&'Text'&&''&&'The minimum ProductVersion of the products in this set.  The set may or may not include products with this particular version.'"
val_dicValidation.Add "Upgrade", val_Upgrade

Dim val_Verb(4)
val_Verb(0) = "'Verb'&&'Sequence'&&'Y'&&'0'&&'32767'&&''&&''&&''&&''&&'Order within the verbs for a particular extension. Also used simply to specify the default verb.'"
val_Verb(1) = "'Verb'&&'Argument'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'Optional value for the command arguments.'"
val_Verb(2) = "'Verb'&&'Extension_'&&'N'&&''&&''&&'Extension'&&'1'&&'Text'&&''&&'The extension associated with the table row.'"
val_Verb(3) = "'Verb'&&'Verb'&&'N'&&''&&''&&''&&''&&'Text'&&''&&'The verb for the command.'"
val_Verb(4) = "'Verb'&&'Command'&&'Y'&&''&&''&&''&&''&&'Formatted'&&''&&'The command text.'"

val_dicValidation.Add "Verb", val_Verb

Sub AddValidation(installer, db, sTable, fVerbose)
	Dim vw, rec, arrSplit
	' create the validation table if necessary
	If db.TablePersistent("_Validation") = 2 Then
		Set vw = db.OpenView("CREATE TABLE _Validation(`Table` CHAR(32) NOT NULL, `Column` CHAR(32) NOT NULL, `Nullable` CHAR(4) NOT NULL, `MinValue` LONG, `MaxValue` LONG, `KeyTable` CHAR(255), `KeyColumn` SHORT, `Category` CHAR(32), `Set` CHAR(255), `Description` CHAR(255) PRIMARY KEY `Table`, `Column`)")
		vw.Execute
		AddValidation installer, db, "_Validation", fVerbose
	End If
	If val_dicValidation.Exists(sTable) Then
		Dim i, arTable : arTable = val_dicValidation.Item(sTable)
		Set vw = db.OpenView("SELECT `Table`, `Column`, `Nullable`, `MinValue`, `MaxValue`, `KeyTable`, `KeyColumn`, `Category`, `Set`, `Description` FROM `_Validation`")
		vw.Execute
		Set rec = installer.CreateRecord(10)
		For i = 0 To UBound(arTable)
			If fVerbose Then WScript.Echo arTable(i)
			arrSplit = Split(arTable(i), "&&")
			For j = 0 To UBound(arrSplit)
				rec.StringData(j + 1) = Mid(arrSplit(j), 2, Len(arrSplit(j)) - 2)
			Next
			vw.Modify 1, rec
		Next
	End If
End Sub
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\msi\xmlconst.inc ===
'<script language='VBScript'>
' xmlconsts.inc - MSXML DOM constants
'
'  1999/12/31 - created - Rob Mensching (robmen@microsoft.com)
'
' requires:
'    none
'
' entrypoints:
'    none
'

' MSXML DOM definitions
Const NODE_ELEMENT                = 1
Const NODE_ATTRIBUTE              = 2
Const NODE_TEXT                   = 3
Const NODE_CDATA_SECTION          = 4
Const NODE_ENTITY_REFERENCE       = 5
Const NODE_ENTITY                 = 6
Const NODE_PROCESSING_INSTRUCTION = 7
Const NODE_COMMENT                = 8
Const NODE_DOCUMENT               = 9
Const NODE_DOCUMENT_TYPE          = 10
Const NODE_DOCUMENT_FRAGMENT      = 11
Const NODE_NOTATION               = 12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\res.cpp ===
/*****************************************************************************
  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.

  Module Name:

   res.cpp

  Abstract:

    The implementation of CMuiResource, CMuiCmdInfo ..

  Revision History:

    2001-10-01    sunggch    created.

Revision.
01/24/02 : create mui file with specified resource type regardless its language id. 
ex. muirct -l 0x418 -i 2 3 4 5 6 7 notepad.exe -> notepad.exe.mui include 2 3, 4, 5,
    6, 7 (0x418) resource type although 3 4 5 are 0x409 in original file.
*******************************************************************************/


#include "muirct.h"
#include "resource.h"
#include <Winver.h>
#include <Imagehlp.h>
#include "res.h"

#define LINK_COMMAND_LENGTH        512
#define MAX_ENV_LENGTH             256
#define VERSION_SECTION_BUFFER     300
#define LANG_CHECKSUM_DEFAULT      0x409

BOOL CALLBACK EnumResTypeProc(
  HMODULE hModule,  // module handle
  LPCTSTR pszType,  // resource type
  LONG_PTR lParam   // application-defined parameter
)
/*++
Abstract:
     Callback function for Resource Type from EnumResourceType

Arguments:

return:
--*/
{
    if (PtrToUlong(pszType) & 0xFFFF0000 ) {
        DWORD dwBufSize = _tcslen(pszType) + 1;
        LPTSTR pszStrType = new TCHAR[dwBufSize ]; // REVISIT : memory leak, where I have to delete.

        if (pszStrType) {
//          _tcsncpy(pszStrType, pszType, _tcslen(pszType) + 1);
            PTSTR * ppszDestEnd = NULL;
            size_t * pbRem = NULL;
            HRESULT hr;
            hr = StringCchCopyEx(pszStrType, dwBufSize ,pszType, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
            if ( ! SUCCEEDED(hr)){
                _tprintf("Safe string copy Error\n");
                return FALSE;
            }                   

            ((CResource* )lParam) ->SetResType ( pszStrType );
            }
        else
            {
             _tprintf("Insufficient resource in EnumResTypeProc");
            return FALSE;
            }
    }
    else {
        ((CResource* )lParam) ->SetResType (pszType);
    }
    return TRUE;
};


BOOL CALLBACK EnumResNameProc(
  HMODULE hModule,   // module handle
  LPCTSTR pszType,  // resource type
  LPCTSTR pszName,   // resource name
  LONG_PTR lParam    // application-defined parameter
)
/*++
Abstract:
    Callback function for Resource Type from EnumResourceName

Arguments:

return:
--*/
{
    if (PtrToUlong(pszName) & 0xFFFF0000 ) {
        DWORD dwBufSize = _tcslen(pszName) + 1;    
        LPTSTR pszStrName = new TCHAR [ dwBufSize ];// _tcslen(pszName) + 1 ];

        if ( pszStrName ) {
            // _tcsncpy(pszStrName, pszName, _tcslen(pszName) + 1);
            PTSTR * ppszDestEnd = NULL;
            size_t * pbRem = NULL;
            HRESULT hr;
            
            hr = StringCchCopyEx(pszStrName, dwBufSize ,pszName, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
            if ( ! SUCCEEDED(hr)){
                _tprintf("Safe string copy Error\n");
                return FALSE;
            }

            ((CResource* )lParam) ->SetResName ( pszStrName );
            }
        else {
            _tprintf("Insufficient resource in EnumResNameProc");
            return FALSE;
            }
    }
    else {
        ((CResource* )lParam) ->SetResName ( pszName );
    }
    return TRUE;

}


BOOL CALLBACK EnumResLangProc(
  HANDLE hModule,    // module handle
  LPCTSTR pszType,  // resource type
  LPCTSTR pszName,  // resource name
  WORD wIDLanguage,  // language identifier
  LONG_PTR lParam    // application-defined parameter
)
/*++

  Callback function for Resource Type from EnumResourceLanguages
--*/
{
    ((CResource* )lParam) ->SetResLangID (wIDLanguage);

    return TRUE;

}



BOOL CALLBACK EnumChecksumResNameProc(
  HMODULE hModule,   // module handle
  LPCTSTR pszType,  // resource type
  LPCTSTR pszName,   // resource name
  LONG_PTR lParam    // application-defined parameter
)
/*++
Abstract:
    Callback function for Resource name from EnumResourceName, this is only for checksum purpose.
    Checksum need to enumerate English file, which is calcuated separately from localiszed file.

Arguments:

return:
--*/
{
    CMUIResource * pcmui = (CMUIResource * ) lParam;
    
    HRSRC  hRsrc = FindResourceEx (hModule, pszType, pszName, pcmui->m_wChecksumLangId );
    
    if (!hRsrc) {
        return TRUE; // Not English resource, skip.
    };

    HGLOBAL hgMap = LoadResource(hModule, hRsrc);
    if  (!hgMap) {
        return FALSE;  //  This should never happen!
    }
    DWORD dwResSize = SizeofResource(hModule, hRsrc );
    unsigned char* lpv = (unsigned char*)LockResource(hgMap);

    //  we leave the data as public for preventing frequent funtion call.
    MD5Update(pcmui->m_pMD5, lpv, dwResSize);

    return TRUE;

}

BOOL CALLBACK EnumChecksumResTypeProc(
  HMODULE hModule,  // module handle
  LPCTSTR pszType,  // resource type
  LONG_PTR lParam   // application-defined parameter
)
/*++
Abstract:
     Callback function for Resource Type from EnumResourceType

Arguments:

return:
--*/

{
    
   if ( pszType == RT_VERSION )
   {
       return TRUE;
   }
   else
   {
       ::EnumResourceNames(hModule, pszType, ( ENUMRESNAMEPROC )EnumChecksumResNameProc, lParam );
    }

   return TRUE;

}



// Constructor 
CResource :: CResource ( ) : m_hRes(0), m_pszFile(NULL),m_hResUpdate(0)
{ 
    m_vwResType  = new cvcstring;
    if(!m_vwResType)
    	return;
    
    m_vwResName  = new cvcstring;
    if(!m_vwResName)
    	return;
    
    m_vwResLangID  = new cvword;
    if(!m_vwResLangID)
    	return;
}


CResource :: ~ CResource ( ) {

    if(m_vwResType)
    	    delete m_vwResType;

    if(m_vwResName)
	    delete m_vwResName;
    
    if(m_vwResLangID)
	    delete m_vwResLangID;
}


CResource :: CResource (const CResource & cr ) : m_hRes(cr.m_hRes),m_hResUpdate(cr.m_hResUpdate),
                                m_pszFile(cr.m_pszFile)

/*++
Abstract:
    copy constructor, we use STL, so just copy without creating new member
Arguments:

return:
--*/

{
    
    assert (&cr);

    m_vwResType  = new cvcstring;

    if (!m_vwResType)
    	return;

    m_vwResType = cr.m_vwResType;

    m_vwResName  = new cvcstring;

    if (!m_vwResName)
    	return;
    	
    m_vwResName = cr.m_vwResName;
    
    m_vwResLangID  = new cvword;

     if (!m_vwResLangID)
    	return;
    	
    m_vwResLangID = cr.m_vwResLangID;       


}


CResource & CResource :: operator = (const CResource & cr ) 
/*++
Abstract:
    operator = function.
Arguments:

return:
--*/
{

    assert (&cr); 
    if ( this == &cr ) {
        return *this;
    }
    
    m_hRes = cr.m_hRes; 
    m_pszFile = cr.m_pszFile; 

    m_vwResType = cr.m_vwResType; 
    m_vwResName = cr.m_vwResName; 
    m_vwResLangID = cr.m_vwResLangID;

    return *this;

}


cvcstring * CResource :: EnumResTypes (LONG_PTR lParam /*= NULL */)
/*++
Abstract:
    Wrapper function of Calling the EnumResourceTypes
Arguments:
    
return:
    resource type saved CVector.
--*/
{

    m_vwResType -> Clear();

    ::EnumResourceTypes( m_hRes, ( ENUMRESTYPEPROC ) EnumResTypeProc, lParam );
  
    return m_vwResType;
}


cvcstring * CResource :: EnumResNames (LPCTSTR pszType, LONG_PTR lParam /*= NULL */)
/*++
Abstract:
    Wrapper function of Calling the EnumResNames

Arguments:

return:
    resource type saved CVector.
--*/
{

    if (m_vwResType -> Empty() ) {
        SetResType(pszType);
    }
    m_vwResName -> Clear();

    EnumResourceNames( m_hRes, pszType, (ENUMRESNAMEPROC) EnumResNameProc, lParam  );

    return m_vwResName;
}

cvword * CResource :: EnumResLangID ( LPCTSTR lpType, LPCTSTR lpName, LONG_PTR lParam /*= NULL */ )
/*++
Abstract:
    Wrapper function of Calling the EnumResourceLanguages

Arguments:

return:
    resource name saved CVector.
--*/
{


    if (m_vwResType -> Empty() ) {
    
        SetResType( lpType );
    }
    if (m_vwResName -> Empty() ) {
        
        SetResName( lpName );
    }
    m_vwResLangID -> Clear();
    
    EnumResourceLanguages( m_hRes, lpType, lpName, (ENUMRESLANGPROC) EnumResLangProc, lParam );
    
    return m_vwResLangID;

}


CMUIResource :: CMUIResource() : CResource() 
/*++
Abstract:
     this is  constructor, but it is disabled after creating of Create() function.

Arguments:

return:
--*/
{
    m_wChecksumLangId = 0;

    m_pcmTreeRoot = new CMUITree;

    if(!m_pcmTreeRoot)
    	return;
    	
    m_pMD5 = new MD5_CTX;   

    if(!m_pMD5)
    	return;
}


CMUIResource :: CMUIResource(LPCTSTR pszName) : CResource() 
/*++
Abstract:
    this is another constructor, but it is disabled after creating of Create() function.

Arguments:

return:
--*/
{
    m_wChecksumLangId = 0;

    m_pcmTreeRoot = new CMUITree;

    if(!m_pcmTreeRoot)
	return;
	
    m_pMD5 = new MD5_CTX;

    if(!m_pMD5)
    	return;
}


CMUIResource :: CMUIResource(const CMUIResource & cmui ) : CResource ( cmui )
/*++
Abstract:
    just copy constructor. we need this function for proper class

Arguments:

return:
--*/
{
        m_wChecksumLangId = 0;

        m_pcmTreeRoot = new CMUITree;

        if(!m_pcmTreeRoot)
        	return;
        	
        m_pMD5 = new MD5_CTX;

        if(!m_pMD5)
        	return;
}


CMUIResource :: ~CMUIResource() 
{
	PVOID pcmtLangIDDel, pcmtNameDel, pcmtTypeDel;
	
	CMUITree * pcmtType = m_pcmTreeRoot->m_ChildFirst;

       while ( pcmtType ){

            CMUITree * pcmtName = pcmtType ->m_ChildFirst;

            while ( pcmtName ) {

	            CMUITree * pcmtLangID = pcmtName ->m_ChildFirst;
	            
	            while ( pcmtLangID ) {
			  pcmtLangIDDel = pcmtLangID;
	                pcmtLangID = pcmtLangID->m_Next;
	                delete pcmtLangIDDel;
	                
	            	}
	            pcmtNameDel = pcmtName;
		     pcmtName = pcmtName->m_Next;
		     delete pcmtNameDel;
		     
            	}

            pcmtTypeDel = pcmtType;
            pcmtType = pcmtType->m_Next;
            delete pcmtTypeDel;
            
       }


	if (m_pcmTreeRoot)
		delete m_pcmTreeRoot;
       
	if (m_pMD5)
		delete m_pMD5;

};


CMUIResource & CMUIResource ::  operator = (const CMUIResource & cmui) 
/*++
Abstract:
    operator = 
Arguments:

return:
--*/
{

    if ( this == & cmui ) {
        return *this;
    }
    CResource::operator = ( cmui );

    // m_pszRCFile = cmui.m_pszRCFile;
    
    return *this;
}


BOOL CMUIResource::Create(LPCTSTR pszFile)
/*++
Abstract:
     loading the file and saving its path and handle

Arguments:
    pszFile  -  file name for used resource. all this call use  this file as resource operation

return:
    true/false
--*/
{
    if( pszFile == NULL )
        return FALSE;

    m_pszFile = pszFile; 
    
    m_hRes = LoadLibraryEx(m_pszFile,NULL, LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES );
        
    if ( ! m_hRes ) {
            
            _tprintf (_T("Error happened while loading file(%s),GetLastError()  : %d \n"),m_pszFile, GetLastError()  );
            _tprintf (_T("Please make sure that file name is *.* format \n") );
        
        return FALSE;
    }
    
    return TRUE;
}


BOOL CMUIResource::CreatePE( LPCTSTR pszNewResFile, LPCTSTR pszSrcResFile )
/*++
Abstract:
    we have two way of creating new resource dll (MUI) one is using UpdateResource and second is 
    using muibld source and CreateProcess ("link.exe".... ). this is about first one.

    We loading the DLL, which is null PE, and we put the new resource into this file by using UpdateResource
    function.

    This work properly randomly. need to test more before using this.
    I think UpdateResource, EndUpdateResource API has some problem ( surely ).
    BUG_BUG>

Arguments:
    pszNewResFile : new MUI resource name, which will be created at end of this routine.
    pszSrcResFile : original source file. we need this because DeleteResource close the resource file handle.


return:
--*/
{
   BOOL bRet = FALSE;
   
    if (pszNewResFile == NULL || pszSrcResFile == NULL)
        return FALSE;

    //
    // create a file from the resource template files, which is PE file inlcuding only version resource.
    //
   
    HANDLE hFile = CreateFile(pszNewResFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

    if (hFile == INVALID_HANDLE_VALUE ) {
        
        _tprintf (_T(" CreateFile error in CreatePE ,GetLastError() : %d \n"), GetLastError() );

        return FALSE;
     }
    
    HMODULE hCurrent = LoadLibrary (_T("muirct.exe") ); // m_hRes 

    HRSRC  hrsrc = ::FindResource(hCurrent, MAKEINTRESOURCE(100),MAKEINTRESOURCE(IDR_PE_TEMPLATE) );
    
    if (!hrsrc) {
        _tprintf (_T("Fail to find resource template \n") ); // this should never happen
        goto exit;
    };

    HGLOBAL hgTemplateMap = ::LoadResource(hCurrent, hrsrc);

    if  (!hgTemplateMap) {
        goto exit; //  This should never happen!
    }
    
    int nsize = ::SizeofResource(hCurrent, hrsrc );
    LPVOID lpTempate = ::LockResource(hgTemplateMap);

    if (!lpTempate)
    	goto exit;
    
    DWORD dwWritten; 
    
    if ( ! WriteFile(hFile, lpTempate, nsize, &dwWritten, NULL )  ) {

        _tprintf (_T("Fail to write new file, GetLastError() : %d \n"), GetLastError() );

        goto exit;

    }
    
    
 
    //
    // Update selected resource into Template file
    // 
    HANDLE  hUpdate  = ::BeginUpdateResource ( pszNewResFile, FALSE );

    if (hUpdate) {

        HMODULE hModule = LoadLibrary ( pszSrcResFile ); // load the source exe file. 

        LPCTSTR lpType = NULL;
        LPCTSTR lpName = NULL;
        WORD   wWord = 0; 

        // Add temperary private method for deleting type that UpdateResource return FALSE.
        CheckTypeStability();

        BOOL fUpdate; 
        
        fUpdate = TRUE;

        UINT uiSize = m_cMuiData.SizeofData();
        
        BeginUpdateResource(FALSE);

        WORD wLangID = 0;

        CMUITree * pcmtType = NULL;
        
        pcmtType = m_pcmTreeRoot->m_ChildFirst;
        
        while ( pcmtType ){
            lpType = pcmtType ->m_lpTypeorName;
            
            CMUITree * pcmtName = pcmtType ->m_ChildFirst;

            while ( pcmtName ){
                lpName = pcmtName->m_lpTypeorName;

                CMUITree * pcmtLangID = pcmtName ->m_ChildFirst;
                
                while ( pcmtLangID ) {
                    
                    wLangID = pcmtLangID->m_wLangID;
                    
                    HRSRC  hRsrc = ::FindResourceEx(hModule, lpType, lpName, wLangID  );
                
                    if (!hRsrc) {
                        _tprintf (_T("Fail to find resource from the source,Type (%d), Name (%d),LangID(%d) \n"),PtrToUlong(lpType),PtrToUlong(lpName),wLangID );
                        goto exit;
                    };

                    HGLOBAL hgMap = ::LoadResource(hModule, hRsrc);
                    if  (!hgMap) {
                        goto exit;  //  This should never happen!
                    }
                    nsize = ::SizeofResource(hModule, hRsrc );
                    
                    LPVOID lpv = ::LockResource(hgMap);
                                    
                    if (! ::UpdateResource(hUpdate , lpType, lpName, wLangID,lpv, nsize ) ) {
                        _tprintf(_T("Error in the UpdateResource, GetLastError : %d \n"), GetLastError() );
                        _tprintf(_T("Resource Type (%d),Name (%d),LangID (%d) \n"),PtrToUlong(lpType),PtrToUlong(lpName),wWord);
                    }
                                    
                    pcmtLangID = pcmtLangID->m_Next;                
                }
                pcmtName = pcmtName->m_Next;
            } 
            pcmtType = pcmtType->m_Next;
        }
        
        bRet =  ::EndUpdateResource (hUpdate, FALSE );
    }

exit:
    if (hFile)
		CloseHandle (hFile );
	
    return bRet;
}


BOOL CMUIResource :: DeleteResource (WORD wLang /* = O */)
/*++
Abstract:
     Delete all resource saved in the CMUIData, which is filled by FillMuiData.
     Currenttly, we don't specify the language ID.
Arguments:

return:
--*/
{

    // Add temperary private method for deleting type that UpdateResource return FALSE.
    CheckTypeStability();

    BOOL fUpdate; 
    
    fUpdate = TRUE;

    UINT uiSize = m_cMuiData.SizeofData();
    
    BeginUpdateResource(FALSE);

    LPCTSTR lpType, lpName = NULL;
    
    WORD wLangID = 0;

    CMUITree * pcmtType = NULL;
    
    pcmtType = m_pcmTreeRoot->m_ChildFirst;
    
    while ( pcmtType ){
        lpType = pcmtType ->m_lpTypeorName;
        
        CMUITree * pcmtName = pcmtType ->m_ChildFirst;

        while ( pcmtName ){
            lpName = pcmtName->m_lpTypeorName;

            CMUITree * pcmtLangID = pcmtName ->m_ChildFirst;
            
            while ( pcmtLangID ) {
                
                wLangID = pcmtLangID->m_wLangID;
                //
                // we just delete anything on the MUI Tree without checking language ID.
                //
                if (wLangID) {
                    if (! UpdateResource(lpType,lpName, wLangID,NULL,NULL ) ) {
                    }                   
                }
                pcmtLangID = pcmtLangID->m_Next;                
            }
            pcmtName = pcmtName->m_Next;
        } 
        pcmtType = pcmtType->m_Next;
    }
    FreeLibrary ( );    // this should be done before EndUpdateResource.
    
    return EndUpdateResource (FALSE);

}




void CMUIResource :: PrtVerbose ( DWORD dwRate )
/*++
Abstract:
    print out removed resource information.

Arguments:

return:
--*/
{
    LPCTSTR lpType = NULL;
    LPCTSTR lpName = NULL;
    WORD wLangID = 0;
    UINT uiSize = m_cMuiData.SizeofData();
    
    _tprintf(_T(" Resource Type   :  Name          : LangID \n\n")  );
    
    CMUITree * pcmtType = NULL;
    pcmtType = m_pcmTreeRoot->m_ChildFirst;
    while ( pcmtType ){
        lpType = pcmtType ->m_lpTypeorName;
        
        CMUITree * pcmtName = pcmtType ->m_ChildFirst;

        while ( pcmtName ) {
            lpName = pcmtName->m_lpTypeorName;

            CMUITree * pcmtLangID = pcmtName ->m_ChildFirst;
            
            while ( pcmtLangID ) {
                
                wLangID = pcmtLangID->m_wLangID;
                
                if ( PtrToUlong(lpType) & 0xFFFF0000 && PtrToUlong(lpName) & 0xFFFF0000 ) {
                    _tprintf(_T(" %-15s :%-15s :%7d   \n"),lpType,lpName,wLangID );
                }
                else if (PtrToUlong(lpType) & 0xFFFF0000 ) {
                    _tprintf(_T(" %-15s :%-15d :%7d   \n"),lpType,PtrToUlong(lpName),wLangID );
                }
                else if (PtrToUlong(lpName) & 0xFFFF0000 ) {
                    _tprintf(_T(" %-15d :%-15s :%7d   \n"),PtrToUlong(lpType),lpName,wLangID );
                }
                else {
                    _tprintf(_T(" %-15d :%-15d :%7d   \n"),PtrToUlong(lpType),PtrToUlong(lpName),wLangID );
                }
                pcmtLangID = pcmtLangID->m_Next;                
            }
            pcmtName = pcmtName->m_Next;
        } 
        pcmtType = pcmtType->m_Next;
    }

}


BOOL CMUIResource :: DeleteResItem(LPCTSTR lpType, LPCTSTR lpName /*=NULL */,WORD wLanguageID /* = 0 */)
/*++
Abstract:
    we only support deletinog of resource Type items from the resource tree

Arguments:
    lpType - resource type
    lpName - resource name
return:
--*/
{
    if ( lpType == NULL) // no 0 resource type.
        return FALSE;

    return m_pcmTreeRoot->DeleteType(lpType);
}


BOOL CMUIResource :: FillMuiData(cvcstring * vType, WORD wLanguageID, BOOL fForceLocalizedLangID )    
/*++
Abstract:
    Fill the CMUIData field (Resource Type, Name, Languge ID ). If lpLangID specified, only reosurce 
    of this LangID is saved. lpLangID is defualt = NULL 

Arguments:
    vType  -  Resource Type CVector (pointer array)
    wLanguageID  -  Specified language ID

return:

Note.  Although the resource  does not have specified language ID, m_pcmTreeRoot will contain its resource type as
        its tree, but not used in writing resource, deletiing resource. we need to create only affected resource tree.
        if we add and delete type,name when there is no langID, it works but so much damage to perfomance. 
        i'm not sure of its deserve because the possilble scenario ( -i 16, 23 && wrong langID ) is so rare.

--*/
{

    if (vType == NULL)
        return FALSE;

    // fill Type 
    CMUITree * pcmtType = NULL;
    CMUITree * pcmtTemp = m_pcmTreeRoot->m_ChildFirst;

    // get the last item of previous round. last itme will be used as first item to be added in this round.
    //
    while ( pcmtTemp ) {

        pcmtType = pcmtTemp;

        pcmtTemp = pcmtTemp->m_Next;
    }

    // Add more / new items
    for ( UINT i = 0; i < vType ->Size(); i ++ ) {
         m_pcmTreeRoot->AddTypeorName(vType ->GetValue(i));
    }

    // get the first items of added or new.
    if (pcmtType) {
        pcmtType = pcmtType->m_Next;
    }
    else {
        pcmtType = m_pcmTreeRoot->m_ChildFirst;
    }
    //
    // Fill the resource tree.
    //

    BOOL    fNameLangExist, fTypeLangExit;  // flag to tell its name or type has language ID.
    CMUITree * pcmtTempDelete = NULL;   // delete type or name when no language is specified.
    
    while ( pcmtType ) {

        fTypeLangExit = FALSE;
        
        LPCTSTR lpType = pcmtType ->m_lpTypeorName;
        
        cvcstring *  vName = EnumResNames( lpType,reinterpret_cast <LONG_PTR> ( this ) );
        // fill name of specified type
        for (UINT j = 0; j < vName->Size(); j ++ ) 
            pcmtType ->AddTypeorName (vName->GetValue(j) );

        CMUITree * pcmtName = pcmtType ->m_ChildFirst;

        //
        // Fill the tree of m_pcmTreeRoot.
        //
        while ( pcmtName ) {

            fNameLangExist = FALSE;
            LPCTSTR lpName = pcmtName->m_lpTypeorName;

            cvword *  vLangID = EnumResLangID(lpType,lpName,reinterpret_cast <LONG_PTR> ( this ) );
            // fill langID of specified name
            for (UINT k = 0; k < vLangID->Size(); k ++ ) {
                
                WORD wlangID = vLangID->GetValue(k);
               //
               // sometimes, VERSION is not localized. VERSION should exist on MUI file.
               // But, we don't want to force VERSION to be localized when the file does not contain any localized resource.
               // note. we will delete unlocalized version and add it to mui file unless -k argu.

               // we add !wLanguageID because we want to force all unlocalized resource(only English) to
               // be added to mui file as well.
               //

                // VERSION will be checeked regardless of fForceLocalizedLangID
                if ((WORD)PtrToUlong(lpType) == 16 && wlangID == 0x409 && wLanguageID != 0x409)
                {
                    HRSRC hResInfo = FindResourceEx(lpType, lpName, wLanguageID); 
                    
                    if (hResInfo)
                    {   // This is multi lingual DLL. we don't want to extract English Version resource.
                        continue;
                    }
                }

                //
                // Multi-lingual component case, we force english language id into specified only when
                // there is not speicifed langauge resource.
                //

                if (fForceLocalizedLangID && wlangID == 0x409 && wLanguageID != 0x409)
                {
                    HRSRC hResInfo = FindResourceEx(lpType, lpName, wLanguageID); 
                    
                    if (hResInfo)
                    {   // This is multi lingual DLL. we don't want to convert English resource to localized when localized resource exist.
                        continue;
                    }
                }

                //
                // Finally, we save language ID or force Only English into specified language ID 
                //
                if ( (wlangID == wLanguageID) ||
                    (fForceLocalizedLangID && (wlangID != wLanguageID) && wlangID == 0x409) ) // ||  ||  (WORD)PtrToUlong(lpType) == 16  ){
                {
                    fNameLangExist = TRUE;
                    fTypeLangExit = TRUE;
                    pcmtName ->AddLangID(wlangID);  // we only save real lang ID so we can retrieve its data when creating mui file.
                }
            }       

          
            pcmtName = pcmtName->m_Next;
      
            if (!fNameLangExist )
            {
                 pcmtType->DeleteType(lpName); // delete pcmtTmepName containg lpName.
            }
                         
        }

      pcmtType = pcmtType->m_Next;
      
      if (! fTypeLangExit) 
      {
           m_pcmTreeRoot->DeleteType(lpType);
      }
        
    }

    return TRUE;

}


BOOL CMUIResource::WriteResFile( LPCTSTR pszSource, LPCTSTR pszMuiFile, LPCTSTR lpCommandLine, WORD wLanguageID /* = 0 */ ) 
/*++
Abstract:
    we have two way of creating new resource dll (MUI) one is using UpdateResource and second is 
    using muibld source and CreateProcess ("link.exe".... ). this is about second one.

    we  have language ID aruguement here, but does not implement for this because we just retrieve the value after
    FillMuiData, which already accept only specified language ID.

Arguments:
    pszMuiFile  -  new MUI Resource name 
    lpCommandLine  -  command string used for second arg. of CreateProcess

return:
    true/false;
--*/
{

    if ( pszSource == NULL || pszMuiFile == NULL || lpCommandLine == NULL)
        return FALSE;

    HANDLE hFile = CreateFile("temp.res", GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE ) {
        
        _tprintf (_T(" File creating error,GetLastError() : %d \n"), GetLastError() );

        return FALSE;
    }
    
    bInsertHeader(hFile);  // this is came from muibld.

    LPCTSTR lpType,lpName = NULL;
    CMUITree * pcmtType = NULL;
    CMUITree * pcmtName = NULL;
    CMUITree * pcmtLangID = NULL;
    WORD   wLangID;
        
    pcmtType = m_pcmTreeRoot->m_ChildFirst;

    while ( pcmtType ){

        lpType = pcmtType ->m_lpTypeorName;
        
        pcmtName = pcmtType ->m_ChildFirst;

        while ( pcmtName ) {

            lpName = pcmtName->m_lpTypeorName;

            pcmtLangID = pcmtName ->m_ChildFirst;
            
            while ( pcmtLangID ) {

                wLangID = pcmtLangID->m_wLangID;
                
                if ( wLangID ) {  // some name does not have languge ID yet all or different from user specified.
                    HRSRC hrsrc = FindResourceEx(lpType,lpName, wLangID );
                    
                    if (! hrsrc ) {
                        
                        if ( PtrToUlong(lpType) & 0xFFFF0000  ) {
                            _tprintf (_T("Fail to find resource type:%s, name:%d \n"), lpType,PtrToUlong(lpName) );
                        }
                        else {
                            _tprintf (_T("Fail to find resource type:%d, name:%d \n"), PtrToUlong(lpType),PtrToUlong(lpName) );
                        }
                        return FALSE;
                    }
                    //
                    // sometimes, VERSION resource is not localized, so we need to force 
                    // specified language ID be used for MUI file instead un-localized langID.
                    // All data in this tree is specified language ID except VERSION; refer to FillMuiData
                    // 

                    // This operation force not only VERSION, but also any unlocalized(but localizable)
                    // resource added to mui with localized language ID.
                    //
                    WriteResource(hFile, m_hRes, wLanguageID, lpName, lpType, hrsrc );
                    
                }
                pcmtLangID = pcmtLangID->m_Next;
            } 
            pcmtName = pcmtName->m_Next;
        }
        pcmtType = pcmtType->m_Next;
    }


    CloseHandle (hFile );

    // call CreateProcess for the link.
    PROCESS_INFORMATION piProcInfo;
    STARTUPINFO si = { 0 };
    si.cb = sizeof (si);

   
    // using the lpEnv from GetEnvironmentStrings for CreateProcess simply does not work correctly, 
    // so we need to get NTMAKEENV, pBuildArch variable.

    TCHAR pApp[MAX_ENV_LENGTH];
    TCHAR pBuildArch[MAX_ENV_LENGTH];
    TCHAR pCmdLine[LINK_COMMAND_LENGTH];

    pApp[sizeof(pApp) / sizeof (TCHAR) -1] = '\0';
    pBuildArch[sizeof(pBuildArch) / sizeof (TCHAR) -1] = '\0';
    pCmdLine[sizeof(pCmdLine) / sizeof (TCHAR) -1] = '\0';

    DWORD dwNtEnv  = GetEnvironmentVariable("NTMAKEENV", pApp, sizeof (pApp) / sizeof (TCHAR) );
    DWORD dwBuildArch = GetEnvironmentVariable("_BuildArch", pBuildArch, sizeof (pBuildArch) /sizeof(TCHAR) );

    if ( _T('\0') == *pApp  || _T('\0') == *pBuildArch ) {
    
        _tprintf (_T("This is not SD enviroment, link path should be set by default or same directory ") );

    }
    if ( dwNtEnv > MAX_ENV_LENGTH || dwBuildArch > MAX_ENV_LENGTH) {
        _tprintf (_T("Insufficient buffer in GetEnvironmentVariable") );         
        return FALSE;
        }
        
    // _tcsncat(pApp,_T("\\x86\\link.exe"), _tcslen("\\x86\\link.exe")+1 );
    HRESULT hr;
    PTSTR * ppszDestEnd = NULL;
    size_t * pbRem = NULL;

    hr = StringCchCatEx(pApp, sizeof (pApp), _T("\\x86\\link.exe"), ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);

    if ( ! SUCCEEDED(hr)){
        _tprintf("Safe string copy Error\n");
        return FALSE;
    }

    
    if (pApp[sizeof(pApp)/sizeof(TCHAR)-1] != '\0' || pBuildArch[sizeof(pBuildArch)/sizeof(TCHAR)-1] != '\0' )
        return FALSE; // overflow

    
    if (!_tcsicmp (pBuildArch,_T("ia64") ) ) {
    
//     _sntprintf(pCmdLine ,LINK_COMMAND_LENGTH, _T("%s /machine:IA64  /out:%s  temp.res") ,lpCommandLine, pszMuiFile );

        hr = StringCchPrintfEx(pCmdLine, LINK_COMMAND_LENGTH, ppszDestEnd, pbRem, 
            MUIRCT_STRSAFE_NULL, _T("%s /machine:IA64  /out:%s  temp.res"), lpCommandLine, pszMuiFile );

        if ( ! SUCCEEDED(hr)){
            _tprintf("Safe string copy Error\n");
            return FALSE;
        }
    }
    else {

  //    _sntprintf(pCmdLine ,LINK_COMMAND_LENGTH, _T("%s /machine:IX86  /out:%s  temp.res") ,lpCommandLine, pszMuiFile );
        hr = StringCchPrintfEx(pCmdLine, LINK_COMMAND_LENGTH, ppszDestEnd, pbRem, 
            MUIRCT_STRSAFE_NULL, _T("%s /machine:IX86  /out:%s  temp.res"), lpCommandLine, pszMuiFile );

        if ( ! SUCCEEDED(hr)){
            _tprintf("Safe string copy Error\n");
            return FALSE;
        }
    }

    if (pCmdLine[sizeof(pCmdLine)/sizeof(TCHAR)-1] != '\0')
        return FALSE; // overflow
    
    BOOL bRet = CreateProcess(pApp, pCmdLine,NULL, NULL, 0, 0 , NULL, NULL, &si, &piProcInfo);
     
   if (bRet)
    {   // child process(link.exe) process the IO, so it wait until it complete I/O.
        if( (WaitForSingleObjectEx(piProcInfo.hProcess, 1000, FALSE)) != WAIT_OBJECT_0) {
            bRet = FALSE;
        }
    }

    return bRet;
}



BOOL CMUIResource:: WriteResource(HANDLE hFile, HMODULE hModule, WORD wLanguage, LPCSTR lpName, LPCSTR lpType, HRSRC hRsrc)
/*++
Abstract:
    this came from muibld. Write resource to file directly. we can make buffer before writing to file
    in the future edition
Arguments:

return:
--*/
{
    HGLOBAL hRes;
    PVOID pv;
    LONG ResSize=0L;

    DWORD iPadding;
    unsigned i;

    DWORD dwBytesWritten;
    DWORD dwHeaderSize=0L;

    // Handle other types other than VS_VERSION_INFO
    
    //...write the resource header
    if(!(ResSize= ::SizeofResource(hModule, hRsrc)))
    {
        return FALSE;
    }

    // 
    // Generate an item in the RES format (*.res) file.
    //

    //
    // First, we generated header for this resource.
    //

    if (!WriteResHeader(hFile, ResSize, lpType, lpName, wLanguage, &dwBytesWritten, &dwHeaderSize))
    {
        return (FALSE);
    }

    //Second, we copy resource data to the .res file
    if (!(hRes=::LoadResource(hModule, hRsrc)))
    {
        return FALSE;
    }
    if(!(pv=::LockResource(hRes)))
    {
        return FALSE;
    }

    if (!WriteFile(hFile, pv, ResSize, &dwBytesWritten, NULL))
    {
        return FALSE;
    }

    //...Make sure resource is DWORD aligned
    iPadding=dwBytesWritten%(sizeof(DWORD));

    if(iPadding){
        for(i=0; i<(sizeof(DWORD)-iPadding); i++){
            PutByte (hFile, 0, &dwBytesWritten, NULL);
        }
    }
    return TRUE;
}



BOOL CMUIResource:: WriteResHeader(
    HANDLE hFile, LONG ResSize, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, DWORD* pdwBytesWritten, DWORD* pdwHeaderSize)
/*++
Abstract:

Arguments:

return:
--*/
{
    DWORD iPadding;
    WORD IdFlag=0xFFFF;
    unsigned i;
    LONG dwOffset;
    
    //...write the resource's size.
    PutDWord(hFile, ResSize, pdwBytesWritten, pdwHeaderSize);

    //...Put in bogus header size
    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);

    //...Write Resource Type
    if(PtrToUlong(lpType) & 0xFFFF0000)
    {
        PutString(hFile, lpType, pdwBytesWritten, pdwHeaderSize);
    }
    else
    {
        PutWord(hFile, IdFlag, pdwBytesWritten, pdwHeaderSize);
        PutWord(hFile, (USHORT)lpType, pdwBytesWritten, pdwHeaderSize);
    }

    //...Write Resource Name

    if(PtrToUlong(lpName) & 0xFFFF0000){
        PutString(hFile, lpName, pdwBytesWritten, pdwHeaderSize);
    }

    else{
        PutWord(hFile, IdFlag, pdwBytesWritten, pdwHeaderSize);
        PutWord(hFile, (USHORT)lpName, pdwBytesWritten, pdwHeaderSize);
    }


    //...Make sure Type and Name are DWORD-aligned
    iPadding=(*pdwHeaderSize)%(sizeof(DWORD));

    if(iPadding){
        for(i=0; i<(sizeof(DWORD)-iPadding); i++){
            PutByte (hFile, 0, pdwBytesWritten, pdwHeaderSize);
        }
    }

    //...More Win32 header stuff
    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);
    PutWord(hFile, 0x1030, pdwBytesWritten, pdwHeaderSize);


    //...Write Language

    PutWord(hFile, wLanguage, pdwBytesWritten, pdwHeaderSize);

    //...More Win32 header stuff

    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);  //... Version

    PutDWord(hFile, 0, pdwBytesWritten, pdwHeaderSize);  //... Characteristics

    dwOffset=(*pdwHeaderSize)-4;

    //...Set file pointer to where the header size is
    if(SetFilePointer(hFile, -dwOffset, NULL, FILE_CURRENT));
    else{
        return FALSE;
    }

    PutDWord(hFile, (*pdwHeaderSize), pdwBytesWritten, NULL);


    //...Set file pointer back to the end of the header
    if(SetFilePointer(hFile, dwOffset-4, NULL, FILE_CURRENT));
    else {
        return FALSE;
    }

    return (TRUE);
}






BOOL CMUIResource:: bInsertHeader(HANDLE hFile){
    DWORD dwBytesWritten;

    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x20, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);
    PutByte (hFile, 0x00, &dwBytesWritten, NULL);

    PutWord (hFile, 0xffff, &dwBytesWritten, NULL);
    PutWord (hFile, 0x00, &dwBytesWritten, NULL);
    PutWord (hFile, 0xffff, &dwBytesWritten, NULL);
    PutWord (hFile, 0x00, &dwBytesWritten, NULL);

    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);
    PutDWord (hFile, 0L, &dwBytesWritten, NULL);

    return TRUE;
}

void  CMUIResource:: PutByte(HANDLE OutFile, TCHAR b, ULONG *plSize1, ULONG *plSize2){
    BYTE temp=b;

    if (plSize2){
        (*plSize2)++;
    }

    WriteFile(OutFile, &b, 1, plSize1, NULL);
}

void CMUIResource:: PutWord(HANDLE OutFile, WORD w, ULONG *plSize1, ULONG *plSize2){
    PutByte(OutFile, (BYTE) LOBYTE(w), plSize1, plSize2);
    PutByte(OutFile, (BYTE) HIBYTE(w), plSize1, plSize2);
}

void CMUIResource:: PutDWord(HANDLE OutFile, DWORD l, ULONG *plSize1, ULONG *plSize2){
    PutWord(OutFile, LOWORD(l), plSize1, plSize2);
    PutWord(OutFile, HIWORD(l), plSize1, plSize2);
}


void CMUIResource:: PutString(HANDLE OutFile, LPCSTR szStr , ULONG *plSize1, ULONG *plSize2){
    WORD i = 0;

    do {
        PutWord( OutFile , szStr[ i ], plSize1, plSize2);
    }
    while ( szStr[ i++ ] != TEXT('\0') );
}

void CMUIResource:: PutStringW(HANDLE OutFile, LPCWSTR szStr , ULONG *plSize1, ULONG *plSize2){
    WORD i = 0;

    do {
        PutWord( OutFile , szStr[ i ], plSize1, plSize2);
    }
    while ( szStr[ i++ ] != L'\0' );
}

void CMUIResource:: PutPadding(HANDLE OutFile, int paddingCount, ULONG *plSize1, ULONG *plSize2)
{
    int i;
    for (i = 0; i < paddingCount; i++)
    {
        PutByte(OutFile, 0x00, plSize1, plSize2);
    }
}



void CMUIResource:: CheckTypeStability()
/* ++
Abstract:
    Check the type stability. UpdateResource fail when same resource type contain string and ID resource
    name, in this case, it return TRUE but EndUpdateResource hang or fail. this bug fixed in .NET server (after 3501)

    
--*/
{
    
    BOOL fUpdate; 
    
    fUpdate = TRUE;

    UINT uiSize = m_cMuiData.SizeofData();
    
    BeginUpdateResource(FALSE);

    LPCTSTR lpType, lpName = NULL;
    
    WORD wLangID = 0;

    CMUITree * pcmtType = NULL;
    
    pcmtType = m_pcmTreeRoot->m_ChildFirst;

    LPCTSTR lpFalseType = NULL;  

    while ( pcmtType ){
        lpType = pcmtType ->m_lpTypeorName;
        
        CMUITree * pcmtName = pcmtType ->m_ChildFirst;
        
        // it works as long as type has more than 1.
        if (lpFalseType)    {
            DeleteResItem(lpFalseType);
            lpFalseType = NULL;
        }

        while ( pcmtName ){
            lpName = pcmtName->m_lpTypeorName;
            
            CMUITree * pcmtLangID = pcmtName ->m_ChildFirst;
        
            while ( pcmtLangID ) {
                
                wLangID = pcmtLangID->m_wLangID;
                
                if (! UpdateResource(lpType,lpName, wLangID,NULL,NULL ) ) {
                    
                //  _tprintf(_T("Resource type (%d),name(%d),langid(%d) deletion fail \n"),PtrToUlong(lpType),PtrToUlong(lpName),wLangID ) ; 
                //  _tprintf(_T("GetLastError() : %d \n") ,GetLastError() );
                    
                    lpFalseType = lpType;
                    
                }
                pcmtLangID = pcmtLangID->m_Next;                
            }
            pcmtName = pcmtName->m_Next;
        } 
        pcmtType = pcmtType->m_Next;
    }
    
    //If Type has only 1 items, this routin can check.
    if (lpFalseType) {
        DeleteResItem(lpFalseType);
        lpFalseType = NULL;
    }

    EndUpdateResource (TRUE);
}

/*******************************************************************************************
    MD5_CTX * CreateChecksum ( LPCTSTR lpChecsumSrcFile ) 

*******************************************************************************************/
MD5_CTX * CMUIResource:: CreateChecksum (cvcstring * cvChecksumResourceTypes, WORD  wChecksumLangId ) 
{
    if ( cvChecksumResourceTypes == NULL)
        return FALSE;
    
    if (wChecksumLangId != LANG_CHECKSUM_DEFAULT)
    {
        if(!FindResourceEx(MAKEINTRESOURCE(16), MAKEINTRESOURCE(1), wChecksumLangId))
        {   //
            // It does not has specifed language id in version resource, we supposed that this binary does not
            // have any language id specified at all, so we set it as 0 in order to use English instead.
            //
            wChecksumLangId = LANG_CHECKSUM_DEFAULT;
        }
    }

    m_wChecksumLangId = wChecksumLangId;
    // cvcstring * cvType = EnumResTypes(reinterpret_cast <LONG_PTR> (this) );
    MD5Init(m_pMD5);

    for (UINT i = 0; i < cvChecksumResourceTypes->Size(); i ++ ) {
        
        if ( cvChecksumResourceTypes->GetValue(i) == RT_VERSION )
            continue;
        else
            ::EnumResourceNames(m_hRes, cvChecksumResourceTypes->GetValue(i), ( ENUMRESNAMEPROC )EnumChecksumResNameProc,reinterpret_cast <LONG_PTR> (this) );
    }

    MD5Final(m_pMD5);

    return m_pMD5;
}



MD5_CTX * CMUIResource::CreateChecksumWithAllRes(WORD  wChecksumLangId)
/*++

--*/
{   
    // 
    // We calculate the checksum based of the specified language id.
    //
    if (wChecksumLangId != LANG_CHECKSUM_DEFAULT)
    {
        if(!FindResourceEx(MAKEINTRESOURCE(16), MAKEINTRESOURCE(1), wChecksumLangId))
        {   //
            // It does not has specifed language id in version resource, we supposed that this binary does not
            // have any language id specified at all, so we set it as 0 in order to use English instead.
            //
            wChecksumLangId = LANG_CHECKSUM_DEFAULT;
        }
    }

    m_wChecksumLangId = wChecksumLangId;

    MD5Init(m_pMD5);
        
    ::EnumResourceTypes(m_hRes, (ENUMRESTYPEPROC)EnumChecksumResTypeProc,reinterpret_cast <LONG_PTR> (this));

    MD5Final(m_pMD5);

    return m_pMD5;

}

BOOL CMUIResource:: AddChecksumToVersion(BYTE * pbMD5Digest)
/*++
Abstract:
    Adding a checksum data to MUI file.

Arguments:
    pbMD5Digest  -  MD5 hash data (128 bits)
return:
--*/
{

    typedef struct VS_VERSIONINFO 
    {
        USHORT TotalSize;
        USHORT DataSize;
        USHORT Type;
        WCHAR szKey[16];              // L"VS_VERSION_INFO" + unicode null terminator
        // Note that the previous 4 members has 16*2 + 3*2 = 38 bytes. 
        // So that compiler will silently add a 2 bytes padding to make
        // FixedFileInfo to align in DWORD boundary.
        VS_FIXEDFILEINFO FixedFileInfo;
    } VS_VERSIONINFO,* PVS_VERSIONINFO;
    
    // using the same structure in ldrrsrc.c because this is smart way to get the exact structuree location.
    typedef struct tagVERBLOCK
    {
        USHORT wTotalLen;
        USHORT wValueLen;
        USHORT wType;
        WCHAR szKey[1];
        // BYTE[] padding
        // WORD value;
    } VERBLOCK;

    // this is the structure in the muibld.exe.
    typedef struct VAR_SRC_CHECKSUM
    {
        WORD wLength;
        WORD wValueLength;
        WORD wType;
        WCHAR szResourceChecksum[17];    // For storing "ResourceChecksum\0" null-terminated string in Unicode.
//      BYTE[] padding
//      DWORD dwChecksum[4];    // 128 bit checksum = 16 bytes = 4 DWORD.
    } VAR_SRC_CHECKSUM;
    
    if (pbMD5Digest == NULL)
        return FALSE;

    //
    // Get VersionInfo structure.
    //
    DWORD dwHandle;
    LPVOID lpVerRes = NULL;
    
    DWORD dwVerSize = GetFileVersionInfoSize( (LPTSTR) m_pszFile,&dwHandle);

    lpVerRes = new CHAR[dwVerSize + VERSION_SECTION_BUFFER];

    if(!lpVerRes)
    	goto exit;
    
    if ( ! GetFileVersionInfo((LPTSTR)m_pszFile, 0 ,dwVerSize,lpVerRes) ) {
        _tprintf(_T("Fail to get file version: GetLastError() : %d \n"),GetLastError() ) ;
        printf("%s", m_pszFile);
        goto exit;
    }
    
    PVS_VERSIONINFO pVersionInfo = (VS_VERSIONINFO *) lpVerRes;
    
    // Sanity check for the verion info
    
    LONG lResVerSize = (LONG)pVersionInfo ->TotalSize; 
    LONG lNewResVerSize = lResVerSize; // new Vesrion file when UpdateResource
    VERBLOCK * pVerBlock = NULL;
    BOOL fSuccess = FALSE;

    //
    //  Adding checksum Resource data into inside VarFileInfo
    //
    if ( lResVerSize > 0 ) {
        
        if ( wcscmp(pVersionInfo ->szKey,L"VS_VERSION_INFO") ) {
            
            _tprintf(_T("This is not correct Version resource") );
            
            goto exit;
        }
        
        WORD wBlockSize = (WORD)AlignDWORD ( sizeof (VS_VERSIONINFO) );
        
        lResVerSize -= wBlockSize; 
        
        pVerBlock = (VERBLOCK *) ( pVersionInfo + 1 );

        while ( lResVerSize > 0 ) {
    
            if ( ! wcscmp(pVerBlock ->szKey,L"VarFileInfo") ) {
                
                VERBLOCK * pVarVerBlock = pVerBlock;
                
                LONG lVarFileSize = (LONG)pVerBlock->wTotalLen;
                
                lResVerSize -= lVarFileSize;
                
                WORD wVarBlockSize = (WORD) AlignDWORD (sizeof(*pVerBlock) -1 + sizeof(L"VarFileInfo"));
                
                lVarFileSize -= wVarBlockSize;
                
                pVerBlock = (VERBLOCK *)((PBYTE) pVerBlock + wVarBlockSize );

                while (lVarFileSize > 0 ) {
                    
                    if ( ! wcscmp(pVerBlock ->szKey,L"Translation") ) {
                        
                        VAR_SRC_CHECKSUM * pVarSrcChecsum = (VAR_SRC_CHECKSUM *)new BYTE[VERSION_SECTION_BUFFER];
//                      VAR_SRC_CHECKSUM * pVarSrcChecsum = new VAR_SRC_CHECKSUM;
                        
                        if ( !pVarSrcChecsum) {
                             _tprintf(_T("Memory Insufficient error in CCompactMUIFile::updateCodeFile"));
                             goto exit;
                           }

                        wVarBlockSize = (WORD)AlignDWORD ( pVerBlock ->wTotalLen );
                        PBYTE pStartChecksum = (PBYTE) pVerBlock + wVarBlockSize ;
                        // Fill the structure.
                        pVarSrcChecsum->wLength = sizeof (VAR_SRC_CHECKSUM);
                        
                        pVarSrcChecsum->wValueLength = 16;
                        pVarSrcChecsum->wType = 0;
                        //wcscpy(pVarSrcChecsum->szResourceChecksum,L"ResourceChecksum");
                        PWSTR * ppszDestEnd = NULL;
                        size_t * pbRem = NULL;
                        HRESULT hr;
                        hr = StringCchCopyExW(pVarSrcChecsum->szResourceChecksum, sizeof (pVarSrcChecsum->szResourceChecksum)/ sizeof(WCHAR),
                                L"ResourceChecksum", ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
                        if ( ! SUCCEEDED(hr)){
                            _tprintf("Safe string copy Error\n");
                            goto exit;
                        }

                        pVarSrcChecsum->wLength = (WORD)AlignDWORD((BYTE)pVarSrcChecsum->wLength); // + sizeof (L"ResourceChecksum") );
                                                
                        memcpy((PBYTE)pVarSrcChecsum + pVarSrcChecsum->wLength, pbMD5Digest, RESOURCE_CHECKSUM_SIZE);
                    
                        pVarSrcChecsum->wLength += RESOURCE_CHECKSUM_SIZE;
                        // memcpy(pStartChecksum,pVarSrcChecsum,sizeof(VAR_SRC_CHECKSUM) );
                        // When checksum length is not DWORD, we need to align this.( in this case, redundant)
                        pVarSrcChecsum->wLength = (WORD)AlignDWORD((BYTE)pVarSrcChecsum->wLength); 
                        
                        pVarVerBlock->wTotalLen += pVarSrcChecsum->wLength; // update length of VarFileInfo
                        lNewResVerSize += pVarSrcChecsum->wLength;
                        pVersionInfo ->TotalSize = (WORD)lNewResVerSize;
                        
                        lVarFileSize -= wVarBlockSize; 
                        // Push the any block in VarInfo after new inserted block "ResourceChecksum" 
                        if ( lVarFileSize  ) {
                            
                            PBYTE pPushedBlock = new BYTE[lVarFileSize ];
                            
                            if ( pPushedBlock) {
                                memcpy(pPushedBlock, pStartChecksum, lVarFileSize );
                                memcpy(pStartChecksum + pVarSrcChecsum->wLength, pPushedBlock, lVarFileSize );
                            }
                            else
                            {
                                _tprintf(_T("Insufficient memory error in CCompactMUIFile::updateCodeFile"));
                            }
                            
                            delete []pPushedBlock;
                            
                        }
                        
                        memcpy(pStartChecksum, pVarSrcChecsum, pVarSrcChecsum->wLength );
                        
                        fSuccess = TRUE;
                        
                        delete [] pVarSrcChecsum;
                        break;
                    }
                    wVarBlockSize = (WORD)AlignDWORD ( pVerBlock ->wTotalLen );
                    lVarFileSize -= wVarBlockSize; 
                    pVerBlock = (VERBLOCK* ) ( (PBYTE) pVerBlock + wVarBlockSize );
                    
                }   // while (lVarFileSize > 0 ) {
                pVerBlock = (VERBLOCK* ) ( (PBYTE) pVarVerBlock->wTotalLen );
                
            }
            else {
                wBlockSize = (WORD) AlignDWORD ( pVerBlock ->wTotalLen );
                lResVerSize -= wBlockSize; 
                pVerBlock = (VERBLOCK * ) ( (PBYTE) pVerBlock + wBlockSize );
               
            }
            if (fSuccess)
                break;
        }
        
    }
    
    
    //
    //  Update file by using UpdateResource function
    //

    BOOL fVersionExist = FALSE;
    BOOL fUpdateSuccess = FALSE;
    BOOL fEndUpdate = FALSE;

    if ( fSuccess ) {
    

        BeginUpdateResource( FALSE );
                
        cvcstring  * cvName = EnumResNames(MAKEINTRESOURCE(RT_VERSION),reinterpret_cast <LONG_PTR> (this) );
        for (UINT j = 0; j < cvName->Size();j ++ ) {
            
            cvword * cvLang = EnumResLangID(MAKEINTRESOURCE(RT_VERSION),cvName->GetValue(j),reinterpret_cast <LONG_PTR> (this) );
                
            for (UINT k = 0; k < cvLang->Size();k ++ ) {
                    
                fUpdateSuccess = UpdateResource(MAKEINTRESOURCE(RT_VERSION),cvName->GetValue(j),cvLang->GetValue(k),lpVerRes,lNewResVerSize);
                
                fVersionExist = TRUE;
            }
        }

        FreeLibrary();
        
        fEndUpdate = EndUpdateResource(FALSE);
    }
    else{
        goto exit;
    }
    
    if( ! fVersionExist ){
        _tprintf(_T("no RT_VERSION type exist in the file %s \n"),m_pszFile);
    }


exit:
	if(lpVerRes)
		delete []lpVerRes;
	
	return (  fEndUpdate & fVersionExist & fUpdateSuccess );
    
}



BOOL CMUIResource:: UpdateNtHeader(LPCTSTR pszFileName, DWORD dwUpdatedField )
/*++
Abstract:
    Update PE header for checksum, which should be updated for windows setup; Windows setup check the PE file checksum 
    on the fly.   

Arguments:
    pszFileName  -  target file
    dwUpdatedField  -  updated field in PE structure.
return:
--*/

{
    
    PIMAGE_NT_HEADERS pNtheader = NULL;
    BOOL bRet = FALSE;

    if (pszFileName == NULL)
        goto exit;

    //
    // Open file with read/write and map file.
    //
    HANDLE hFile = CreateFile(pszFileName,GENERIC_READ | GENERIC_WRITE,FILE_SHARE_READ,
                        NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
    
    if (hFile == INVALID_HANDLE_VALUE) {
        _tprintf(_T("Couldn't open a file< %s> with CreateFile \n"), pszFileName );
        goto exit;
    }


    HANDLE hMappedFile = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL );

    if (hMappedFile == 0 ) {
        _tprintf(_T("Couldn't ope a file mapping with CreateFileMapping \n") );
        goto exit;
    }

    PVOID pImageBase = MapViewOfFile(hMappedFile,FILE_MAP_WRITE, 0, 0, 0);

    if (pImageBase == NULL ) {
        _tprintf(_T("Couldn't mape view of file with MapViewOfFile \n") );
        goto exit;
    }
    //
    // Locate ntheader; same routine of RtlImageNtHeader
    //
    if (pImageBase != NULL && pImageBase != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)pImageBase)->e_magic == IMAGE_DOS_SIGNATURE) {
            pNtheader = (PIMAGE_NT_HEADERS)((PCHAR)pImageBase + ((PIMAGE_DOS_HEADER)pImageBase)->e_lfanew);
        }
        else
        {
            _tprintf(_T("This file is not PE foramt \n") );
            goto exit;
        }
    }

    
    //
    // GetChecksum data through ImageHlp function.
    //
    
    if ( dwUpdatedField & CHECKSUM ) {
        
        DWORD dwHeaderSum = 0;
        DWORD dwCheckSum = 0;
        
        MapFileAndCheckSum((PTSTR)pszFileName,&dwHeaderSum,&dwCheckSum);

        if (pNtheader != NULL && dwHeaderSum != dwCheckSum ) {

            pNtheader->OptionalHeader.CheckSum = dwCheckSum;

        }
    }

    // 
    // Write checksum data to mapped file directly.
    //
    
    bRet = TRUE;

exit:
	if (hFile)
		CloseHandle(hFile);
	if (hMappedFile)
		CloseHandle(hMappedFile);
	if (pImageBase)
		UnmapViewOfFile(pImageBase);
	
	return bRet;
}



/**************************************************************************************************
CMUIData::CMap::CMap()

***************************************************************************************************/
CMUIData::CMap::CMap() {

     m_lpType  = NULL;
     m_lpName  = NULL;
     m_wLangID = 0; 

}


void CMUIData :: SetAllData(LPCTSTR lpType,LPCTSTR lpName, WORD wLang, UINT i  ) 
/*++
Abstract:
    Set all resource type,name,langid

Arguments:
    lpType : resource type,
    lpName : resource name,
    wLang : resource language id
    i : number of resource so far. (index)

return:
--*/
{

    //HLOCAL hMem = LocalAlloc(LMEM_ZEROINIT,sizeof(CMap) );
    // REVISIT : seems like new operator bug. we beat the error by using LocalAlloc at this time.
    // guess : LocalAlloc can be same with HeapCreate in terms of deleting memory when process end.so gabarge collection for these.
    // m_cmap[i] = (CMap*) LocalLock(hMem); // new CMap ;

    // disable below line due to Prefast error,anyway, this routine is dead.
#ifdef NEVER
    CMap * pCmap = new CMap; 

    pCmap->m_lpType = lpType;
    pCmap->m_lpName = lpName; 
    pCmap->m_wLangID = wLang;

    m_iSize = i + 1; 
#endif 
}

void CMUIData::SetType(UINT index, LPCTSTR lpType)
{
    m_cmap[index].m_lpType = lpType;
}



CMUIData::~ CMUIData() { 

//  for ( UINT i = 0; i < m_iSize; i ++ ) 
//      delete m_cmap[i]; 
    if (m_cmap)
        delete [] m_cmap;

};

CMUIData::CMap* CMUIData::m_cmap = NULL;
CMUIData::CMap* CMUIData::m_poffset = NULL;
const UINT CMUIData::MAX_SIZE_RESOURCE = 1000;
UINT CMUIData::m_index = 0;

PVOID CMUIData::CMap::operator new (size_t size) 
/*++
Abstract:
    
Arguments:

return:
--*/
{

    static DWORD dwExpand = 0;
    
    if ( ! m_cmap ) {
                
        m_cmap = m_poffset = ::new CMap[ MAX_SIZE_RESOURCE ];
        if (! m_cmap)
            _tprintf(_T("resource insufficient") );

        dwExpand ++;
        m_index ++;
        return m_poffset;
    }

    if ( m_index < MAX_SIZE_RESOURCE * dwExpand ) {
        m_index ++;
        return ++ m_poffset ;
    }
    else {
        dwExpand ++;
        CMap * ptbase = NULL;
        CMap * ptoffset = NULL;
        
        size_t tsize = dwExpand *MAX_SIZE_RESOURCE;
        ptbase = ptoffset = ::new CMap [ tsize ];
        
        for ( UINT i = 0; i < ( dwExpand - 1 ) * MAX_SIZE_RESOURCE; i ++ ) {

            memcpy( ptoffset++, &m_cmap [i],sizeof(CMap) );

        }
        
        ::delete [] m_cmap;
        
        m_cmap = ptbase;

        m_poffset = ptoffset;
        
        m_index ++;

        return m_poffset;
    }

}


void CMUIData::CMap::operator delete ( void *p ) {

    m_poffset = m_poffset - 1;

}



// this can be removed ? I mean, just use API instead of Wrapper. but m_hResUpdate also is member of this file.
// I just live this one .

inline HANDLE CResource::BeginUpdateResource(BOOL bDeleteExistingResources )
{
        
    return (m_hResUpdate = ::BeginUpdateResource( m_pszFile, bDeleteExistingResources) );

};


inline BOOL CResource:: UpdateResource (LPCTSTR lpType,LPCTSTR lpName,WORD wLanguage, LPVOID lpData, DWORD cbData) {    
    
    return ::UpdateResource( m_hResUpdate, lpType, lpName, wLanguage, lpData, cbData ); 

};
    

inline BOOL CResource::EndUpdateResource(BOOL bDiscard)
{
    
    return ::EndUpdateResource (m_hResUpdate, bDiscard ); 

}


///////////////////////////////////////////////////////////////////////////////////////////////////
//
//  CMuiCmdInfo
//
//////////////////////////////////////////////////////////////////////////////////////////////////



CMuiCmdInfo :: CMuiCmdInfo() : CCommandInfo() ,m_uiCount(0){
    
    m_buf = NULL; 
    m_buf2 = NULL;

};

CMuiCmdInfo :: ~CMuiCmdInfo() {
    if ( m_buf )
        delete [] m_buf;
    if (m_buf2)
        delete [] m_buf2; 

};


CMuiCmdInfo :: CMuiCmdInfo ( CMuiCmdInfo& cav ):CCommandInfo(cav) // : m_mArgList = cav.m_mArgList
{
    m_pszArgLists = NULL;
}

// no implementatin and can't be used by client
CMuiCmdInfo& CMuiCmdInfo :: operator = ( CMuiCmdInfo& cav )
{
    return *this;
}


void CMuiCmdInfo :: SetArgLists(LPTSTR pszArgLists, LPTSTR pszArgNeedValueList, LPTSTR pszArgAllowFileValue,
                                LPTSTR pszArgAllowMultiValue ) 
/*++
Abstract:
    Set internal arguments list with new arugments lists    

Arguments:
    pszArgLists - string of arguments list, each character of this string is argument.
        it does not allow string arg. like -kb, -ad.
    pszArgNeedValueList  - Argument requiring values.

    pszArgAllowFileValue  - Argument allowing file name value

    pszArgAllowMultiValue  - Argument allowing multiple file value

return:
--*/
{
    if ( pszArgLists == NULL || pszArgNeedValueList == NULL || 
        pszArgAllowFileValue == NULL || pszArgAllowMultiValue == NULL)
        return ;

    m_pszArgLists = pszArgLists;

    m_pszArgNeedValueList = pszArgNeedValueList;

    m_pszArgAllowMultiValue = pszArgAllowMultiValue; 

    m_pszArgAllowFileValue = pszArgAllowFileValue;
}


BOOL CMuiCmdInfo :: CreateArgList(INT argc, TCHAR * argv [] ) 
/*++
Abstract:
    Create mapping table with its argument and its values. The argument type are classified by 
    1. No need values 
    2. No File Arguments. regardless of one or muliple values "a""i", "k", "y" "o","p",
    3. File, no Multiple. "c", "f", "d","e", 
    4. File, Multiple. "m", "a"
        
Arguments:
    argc : arguments count
    argv : argument values pointer to string array

return:
--*/
{
    
    DWORD dwBufSize = 0;
    HRESULT hr;
    PTSTR * ppszDestEnd = NULL;
    size_t * pbRem = NULL;

    if ( argc < 2 ) {

        _tprintf(_T("MUIRCT [-h|?] -l langid [-i resource_type] [-k resource_type] [-y resource_type] \n") );
        _tprintf(_T("source_filename, [language_neutral_filename], [MUI_filename] \n\n"));

        return FALSE;
    }

    LPCTSTR lpVal = NULL;
    
    for ( int i = 1; i < argc; ) {
        
        if ( lpVal = getArgValue (argv[i]) ) {
            
            if ( ++ i >=  argc )  {  // we need a source file name

                _tprintf ("MUIRCT needs a source file name and new dll name or file name does not have format *.* \n" );
                    
                _tprintf(_T("MUIRCT [-h|?] -l langid [-i resource_type] [-k resource_type] [-y resource_type] \n") );
                _tprintf(_T("source_filename, [language_neutral_filename], [MUI_filename] \n\n"));

                return FALSE;
            }
// #ifdef NEVER
                if ( getArgValue(argv[i]) )
                {
                    if (!isNeedValue(lpVal) )  // -i -X ... case. -i don't need values.
                    {   
                        m_cmap[m_uiCount].m_first = lpVal;
                        m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = _T("ALL");
                        m_uiCount ++;
                        //i--;  // this is not a value for argument.
                        continue;
                    }
                    else
                    {
                    _tprintf ("%s argument need values. e.g. muirct -l 0x0409 \n " , argv[ i- 1 ] );
                    return FALSE;
                    }
                }
        
                
                if (!isAllowFileValue(lpVal) )
                {
                    m_cmap[m_uiCount].m_first = lpVal;
                    
                    while (i < argc && !getArgValue (argv[i]) && !isFile(argv[i]) )
                    {
                        m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = argv [i];
                        i++ ;
                    }
                    m_uiCount ++;
                    i--;
                    
                    
                }
                else if (isAllowFileValue(lpVal) && isAllowMultiFileValues(lpVal) )
                {
                    m_cmap[m_uiCount].m_first = lpVal;

                    while (i < argc && !getArgValue ( argv[ i ] ))
                    {
                        m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = argv [i];
                        i++ ;
                    }
                    m_uiCount ++;
                    i--;
                    
                }
                else if (isAllowFileValue(lpVal) && !isAllowMultiFileValues(lpVal) )
                {
                    m_cmap[m_uiCount].m_first = lpVal;
                    m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = argv [i];
                    m_uiCount ++;
                    
                }
                else 
                {
                    _tprintf(_T(" <%s> is not a supported argument\n"), lpVal );
                    return FALSE;
                }

                i++;
        }


// #endif   
#ifdef NEVER
            if ( ! getArgValue( argv [ i] ) && (! isFile ( argv[ i ] ) || isAllowFileValue(lpVal) ) ) {
                     m_cmap[m_uiCount].m_first = lpVal;
                m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = argv [i];
                // // the argu. is in the if() are arg. allowing multiple values.   
//              while ( ++ i < argc && ! getArgValue ( argv[ i ] ) && (! isFile ( argv[ i ] )   
//                    || _T('m') == *lpVal || _T('a') == *lpVal) )// prevent "" be called

                while ( ++ i < argc && ! getArgValue ( argv[ i ] ) && (! isFile ( argv[ i ] )   
                    || isAllowMultiFileValues(lpVal) ) )// prevent "" be called
                {
                        m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = argv [i];
                }
               m_uiCount ++;


        } 
        else {  // "-i" argument or file.
            if ( isNeedValue (argv [i-1] ) ) {
                
                _tprintf ("%s argument need values. e.g. muirct -l 0x0409 \n " , argv[ i- 1 ] );
                
                return FALSE;

            }
            else {
                
                   m_cmap[m_uiCount].m_first = lpVal;
                   m_cmap[m_uiCount].m_second[m_cmap[m_uiCount].m_count++] = _T("ALL"); // need to revisit.
             
                m_uiCount ++;
            }
        }

    } // if ( lpVal = getArgValue ( argv[i] )  ) {
#endif 
        else if (! isFile( argv [i]) ) {
            
            if ( _T('h') == argv[i][1] || _T('H') == argv[i][1]  || _T('?') == argv[i][1] ) {

                _tprintf(_T("\n\n") );
                _tprintf(_T("MUIRCT [-h|?] -l langid [-c checksum_file ] [-i removing_resource_types]  \n" ) );
                _tprintf(_T("    [ -k keeping_resource_types] [ -y keeping_resource_types] [-v level] source_file \n" ) );
                _tprintf(_T("    [langue_neutral_filename] [MUI_filename]\n\n") );
                
                _tprintf(_T("-h(elp) or -?    :  Show help screen.\n\n") );
                
                _tprintf(_T("-l(anguage)langid:  Extract only resource in this language.\n") );
                _tprintf(_T("                    The language resource must be specified. The value is in decimal.\n\n") ); 
                
                _tprintf(_T("-c(hecksum file) :  Calculate the checksum on the based of this file,and put this data \n") );
                _tprintf(_T("                    into language_neutral_file and mui_file.\n\n") );

                _tprintf(_T("-i(clude removed):  Include certain resource types,\n") );
                _tprintf(_T("resource_type          e.g. -i 2 3 4 or -i reginst avi 3 4 .\n") );
                _tprintf(_T("                    -i (to inlcude all resources). \n" ) );
                _tprintf(_T("                    Multiple inclusion is possible. If this\n") );
                _tprintf(_T("                    flag is not used, all types are included like -i \n") );
                _tprintf(_T("                    Standard resource types must be specified\n") );
                _tprintf(_T("                    by number. See below for list.\n") );
                _tprintf(_T("                    Types 1 and 12 are always included in pairs,\n") );
                _tprintf(_T("                    even if only one is specified. Types 3 and 14\n") );
                _tprintf(_T("                    are always included in pairs, too.\n\n\n") );

                _tprintf(_T("-k(eep resource) :  Keep specified resources in langue_neutral_file and \n") );
                _tprintf(_T("                    also included in mui file.\n") );
                _tprintf(_T("                    Its usage is same with -i argument. \n\n") );

                _tprintf(_T("-y               :  This is same with -k argument except it does not check \n") );
                _tprintf(_T("                    if the values are in the -i values.\n\n") );

                _tprintf(_T("-o               :  This is same with -i argument except it does not check \n") );
                _tprintf(_T("                    if the types are exist in the source file.\n\n") );

                _tprintf(_T("-z               :  Calculate and insert only checksum data to specific file \n") );
                _tprintf(_T("                    eg. muirct -c notepad.exe -i[-o] 3 4 5 6 8 -z notepad2.exe .\n\n") );

                _tprintf(_T("-p               :  Delete types from source file, but does not want to add into mui file \n\n") );

                _tprintf(_T("-x               :  Add all resource types into MUI file as specified language id \n"));      
                _tprintf(_T("                     regardless of language ID  \n\n"));                            

                _tprintf(_T("-v(erbose) level :  Print all affected resource type, name, langID when level is 2.\n\n") );
                

                _tprintf(_T("source_filename  :  The localized source file (no wildcard support)\n\n") );

                _tprintf(_T("language_neutral_:  Optional. If no filename is specified,\n") );
                _tprintf(_T("_filename           a second extension .new is added to the\n") );
                _tprintf(_T("                    source_filename.\n\n") );
                
                _tprintf(_T("mui_filename     :  Optional. If no target_filename is specified,\n") );
                _tprintf(_T("                    a second extension .mui is added to the \n") );
                _tprintf(_T("                    source_filename.\n\n") );

                _tprintf(_T("-m               :  CMF, enumerate compacted mui files \n") );
                _tprintf(_T("                eg. muirct -m notepad.exe.mui foo.dll.mui bar.dll.mui .\n\n") );
                
                _tprintf(_T("-e               :  CMF, the directory of matching execute file of compacted mui files \n\n") );

                _tprintf(_T("-f               :  CMF, newly created CMF file name \n") );
                _tprintf(_T("                 eg, muirct -m foo.dll.mui bar.dll.mui -f far.cmf -d c:\\file\\exe  \n\n") );

                _tprintf(_T("-d               :  CMF, dump CMF headers information \n\n\n") );                                                

                _tprintf(_T("Standard Resource Types: CURSOR(1) BITMAP(2) ICON(3) MENU(4) DIALOG(5)\n") );
                _tprintf(_T("STRING(6) FONTDIR(7) FONT(8) ACCELERATORS(9) RCDATA(10) MESSAGETABLE(11)\n") );
                _tprintf(_T("GROUP_CURSOR(12) GROUP_ICON(14) VERSION(16)\n\n\n") );

            }
            else {
                _tprintf(_T("%s argument is not supported  \n" ),argv[i] );
                _tprintf(_T("MUIRCT needs a source file name and new dll name or file name does not have format *.* \n" ) );
                _tprintf(_T("MUIRCT [-h|?] -l langid [-i resource_type] [-k resource_type] [-y resource_type] \n") );
                _tprintf(_T("source_filename, [language_neutral_filename], [MUI_filename] \n\n"));

            }

                return FALSE;
        }  // ! isFile( argv [i] ) ) {
        else {
            m_cmap[m_uiCount].m_first = _T("source");
            m_cmap[m_uiCount].m_second[m_cmap[m_uiCount++].m_count++] = argv[i++];

            //m_mArgList.insert(make_pair(,argv[i++] ) );

            if ( i < argc ) {
                
                m_cmap[m_uiCount].m_first = _T("muidll");
                m_cmap[m_uiCount].m_second[m_cmap[m_uiCount++].m_count++] = argv[i++];

                // m_mArgList.insert(make_pair("muidll",argv[i++] ) );

                if ( i < argc ) {
                    
                    m_cmap[m_uiCount].m_first = _T("muires");
                    m_cmap[m_uiCount].m_second[m_cmap[m_uiCount++].m_count++] = argv[i++];

                    // m_mArgList.insert(make_pair("muires",argv[i] ) );
                }
                else {
                    dwBufSize = _tcslen(argv[i-2]) + 10;
                    m_buf = new TCHAR[dwBufSize]; // 10 is enough number, actually we need just 4 .
                    if (m_buf == NULL) {
                        _tprintf(_T("Insufficient memory resource\n"));
                        return FALSE;
                        }
                    memcpy ( m_buf, argv[i-2], _tcslen(argv[i-2])+1 ) ; // source.mui instead of newfile.mui

                    // _tcscat(m_buf,_T(".mui" ) );
                    
                    hr = StringCchCatEx(m_buf, dwBufSize , _T("mui"), ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
                    if ( ! SUCCEEDED(hr)){
                        _tprintf("Safe string copy Error\n");
                        return FALSE;
                    }
                    m_cmap[m_uiCount].m_first = "muires";
                    m_cmap[m_uiCount].m_second[m_cmap[m_uiCount++].m_count++] = m_buf; // argv[i++];
                    
                    //i++;
                }
                    
            }
            else {
                 dwBufSize = _tcslen(argv[i-1]) + 10;
                 m_buf = new TCHAR[dwBufSize];

                 if (m_buf == NULL) {
                    _tprintf(_T("Insufficient memory resource\n"));
                    return FALSE;
                    }
                    
                memcpy (m_buf, argv[i-1], _tcslen(argv[i-1])+1 );

                // _tcscat(m_buf,_T(".new") );
                               
                hr = StringCchCatEx(m_buf, dwBufSize , _T(".new"), ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);

                if ( ! SUCCEEDED(hr)){
                    _tprintf("Safe string copy Error\n");
                    return FALSE;
                }
                m_cmap[m_uiCount].m_first = _T("muidll");
                m_cmap[m_uiCount].m_second[m_cmap[m_uiCount++].m_count++] = m_buf; // argv[i];


                //m_mArgList.insert(make_pair("muidll",argv[i]));
                dwBufSize = _tcslen(argv[i-1])+ 10;
                m_buf2 = new TCHAR[dwBufSize];

                 if (m_buf2 == NULL) {
                    _tprintf(_T("Insufficient memory resource\n"));
                    return FALSE;
                    }
                 
                memcpy (m_buf2, argv[i-1], _tcslen(argv[i-1])+1 );
                
                // _tcscat(m_buf2,_T(".mui") );
                hr = StringCchCatEx(m_buf2, dwBufSize , _T(".mui"), ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
                if ( ! SUCCEEDED(hr)){
                    _tprintf("Safe string copy Error\n");
                    return FALSE;
                }
                m_cmap[m_uiCount].m_first = _T("muires");
                m_cmap[m_uiCount].m_second[m_cmap[m_uiCount++].m_count++] = m_buf2; // argv[i++];
                
                //i ++;

                // m_mArgList.insert(make_pair("muires",argv[i]));
            
            }; // if ( i < argc )
    
        }; // else if (! isFile( argv [i] ) ) {
                    
     }; // for (

    return TRUE; 
}

            
LPTSTR* CMuiCmdInfo :: GetValueLists ( LPCTSTR pszKey, DWORD& dwCount )
/*++
Abstract:
    Return the second (value) and its count by its key
Arguments:
    pszKey  -  key (arguments)
    [OUT] dwCount  -  number of values of this key(argument)

return:
    pointer to array of values
--*/
{
    if (pszKey == NULL)
        return FALSE;

    for (UINT i = 0; i < m_uiCount; i ++ ) {

        if (! _tcsicmp (m_cmap[i].m_first, pszKey) ) {

            dwCount = m_cmap[i].m_count;

            return m_cmap[i].m_second;
        }
    }

    dwCount = 0;
    return NULL;

}
            


LPCTSTR CMuiCmdInfo :: getArgValue ( LPTSTR pszArg )
/*++
Abstract:
    return the second pointer(value ) of first pointer(key)
Arguments:

return:
    pointer to value
--*/
{

    if ( pszArg == NULL)
        return FALSE;

    LPCTSTR lpArg = CharLower(pszArg);
    LPCTSTR pszArgTemp = m_pszArgLists;
        
    if ( _T('-') == *lpArg  || _T('/') == *lpArg  ) {
        lpArg++;
        while ( *pszArgTemp != _T('\0') ) {

            if ( *lpArg == *pszArgTemp++ ) {

                return lpArg;
                
                
            }
        }
    }
#ifdef NEVER
        if ( _T('i') == *++lpArg  || _T('k') == *lpArg || _T('l') == *lpArg  || 
            _T('v') == *lpArg || _T('c') == *lpArg || _T('y') == *lpArg ) {
        
            return lpArg;
        }
#endif  
//  printf("%s\n", lpArg);  
    return NULL;

}

LPCTSTR CMuiCmdInfo::getArgString(LPTSTR pszArg)
/*++
Abstract:
    check the string and return its value if it is argument that has string value

Arguments:
    pszArg  - speicific argument 

return:
    pointer to character field of argument ( -s, /s. only return s )
--*/
{
    if (pszArg == NULL)
        return FALSE;

    LPCTSTR lpArg = CharLower(pszArg);

//  if ( *lpArg == '-' || *lpArg  == '/' )

//      if ( *++lpArg == 's' || *lpArg == 'p' ) 
        
//           return lpArg;
    
    return NULL;
}



BOOL CMuiCmdInfo :: isFile ( LPCTSTR pszArg ) 
/*++
Abstract:
    check if the string has file format(*.*) or not
Arguments:
    pszArg : specific argument 
return:
--*/
{
    if(pszArg == NULL)
        return FALSE;
    
    for (int i = 0; _T('\0') != pszArg[i]  ; i ++ ) {

        if ( _T('.') == pszArg [i] )
            
            return TRUE;
    }

    return FALSE;

}


BOOL CMuiCmdInfo :: isNumber ( LPCTSTR pszArg ) 
/*++
Abstract:
    heck if the string has file number ( 10, 16 base )

Arguments:
    pszArg : specific argument 
return:
--*/
{
    if (pszArg == NULL)
        return FALSE;
    
    for ( int i = 0; _T('\0') != pszArg[i]; i ++ ) {

        if ( _T('0') == pszArg[0]  && _T('x') == pszArg[1]  )
        
            return TRUE;

        if ( pszArg[i] < '0' || pszArg[i] > '9' ) 

            return FALSE;

    }

    return TRUE;

};


BOOL CMuiCmdInfo::isNeedValue( LPCTSTR pszArg )
/*++
Abstract:
    check if argument should have value or can stand alone.
Arguments:
    pszArg  - specific argument
return:
--*/
{
    if (pszArg == NULL)
        return FALSE;

    LPCTSTR lpArg = CharLower((LPTSTR)pszArg);

    LPCTSTR pszArgTemp = m_pszArgNeedValueList;

    if ( _T('-') == *lpArg  || _T('/') == *lpArg  ) 
    {
        lpArg++;
    }

    while ( *pszArgTemp != _T('\0') ) {
        if ( *lpArg == *pszArgTemp++ ) {
            return TRUE;
        }
    }
#ifdef NEVER
        if ( _T('k') == *++lpArg  || _T('l') == *lpArg || _T('c') == *lpArg ) 
        
            return TRUE;
#endif
                    
    return FALSE;
}


BOOL CMuiCmdInfo::isAllowFileValue(LPCTSTR pszArg)
/*++
Abstract:
    Check if argument allow file as its value
Arguments:
    pszArg  -  specific argument
return:
--*/
{
    if(pszArg == NULL)
        return FALSE;

    LPCTSTR lpArg = CharLower((LPTSTR)pszArg);
    LPCTSTR pszArgTemp = m_pszArgAllowFileValue;

    if ( _T('-') == *lpArg  || _T('/') == *lpArg  ) 
    {
        lpArg++;
    }

    while ( *pszArgTemp != _T('\0') ) {
        if ( *lpArg == *pszArgTemp++ ) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CMuiCmdInfo::isAllowMultiFileValues(LPCTSTR pszArg)
/*++
Abstract:
    Check if the argument all multiple file names as its values

Arguments:
    pszArg  -  specific argument

return:
--*/
{
    if (pszArg == NULL)
        return FALSE;

    LPCTSTR lpArg = CharLower((LPTSTR)pszArg);
    LPCTSTR pszArgTemp = m_pszArgAllowMultiValue;

    if ( _T('-') == *lpArg  || _T('/') == *lpArg  ) 
    {
        lpArg++;
    }

    while ( *pszArgTemp != _T('\0') ) {
        if ( *lpArg == *pszArgTemp++ ) {
            return TRUE;
        }
    }
    
     return FALSE;
}



template <class T>
CVector<T> :: CVector ( const CVector<T> &cv ) {
    
        base = offset = new T [MAX_SIZE];

        for (int i = 0; i < cv.offset - cv.base; i ++ )
             base[i]  =  cv.base[i];
        
        offset = &base[i];
        
}


template <class T>
CVector<T> & CVector<T> :: operator = (const CVector<T> & cv ) { 
        if ( this == &cv) 
            return *this;

        for (int i = 0; i < cv.offset - cv.base; i ++ )
             base[i]  =  cv.base[i];
        
        offset = &base[i];
        return *this;
}


template <class T>
BOOL CVector<T> :: Empty() { 
        
    if ( offset - base ) 
        
        return FALSE;

    else 
    
        return TRUE;

}

/*  // The definition of member template is outside the class. 
Visual C++ has a limitation in which member templates must be fully defined within the enclosing class. 
See KB article Q239436 for more information about LNK2001 and member templates. 

template <class T>
BOOL CVector<T> :: Find(DWORD dwValue) { 
        
    for ( UINT i = 0; i < offset - base; i ++ ) {
        if ( PtrToUlong( base+i ) & 0xFFFF0000) {
            if ( !( _tcstoul( base+i, NULL, 10 )  - dwValue ) )
                return TRUE;
        }
        else {
            if (! ( PtrToUlong(base+i ) - dwValue ) ) 
                return TRUE;
        }
    }

    return FALSE;
};

*/

void CMUITree::AddTypeorName( LPCTSTR lpTypeorName )
/*++
Abstract:
    This is Resource Tree creation : Resource tree has multiple tree
    argument

Arguments:
    lpTypeorName  -  LPCTSTR type or name 
return:
--*/
{
    if (lpTypeorName == NULL)
        return ;

    LPTSTR lpTempTypeorName = NULL;
    
    CMUITree * pcmType = new CMUITree;
	
    if (!pcmType)
        return;
	
    if ( 0xFFFF0000 & PtrToUlong(lpTypeorName) ) 
    { // how about 64 bit ?
        
        DWORD dwBufSize = _tcslen(lpTypeorName) + 1;
        lpTempTypeorName = new TCHAR [dwBufSize ];

        if (!lpTempTypeorName)
            return;
        
        // _tcscpy(lpTempTypeorName,lpTypeorName);
        PTSTR * ppszDestEnd = NULL;
        size_t * pbRem = NULL;
        HRESULT hr;

        hr = StringCchCopyEx(lpTempTypeorName, dwBufSize ,lpTypeorName, ppszDestEnd, pbRem, MUIRCT_STRSAFE_NULL);
        if ( ! SUCCEEDED(hr)){
            _tprintf("Safe string copy Error\n");
            delete pcmType;
		delete [] lpTempTypeorName;
            return ;
        }                 


    }
                    
    pcmType->m_lpTypeorName = lpTempTypeorName ? lpTempTypeorName : lpTypeorName; 

    if ( m_ChildFirst ) {
        
        CMUITree * pTemp = m_ChildFirst;  // tricky : we put the value of next of child, not this->m_Next;
        
        CMUITree * pTempPre = pTemp;
        
        while ( pTemp = pTemp->m_Next ) 
            pTempPre = pTemp;
        
        pTempPre ->m_Next = pTemp  = pcmType;
    }
    else 
        m_ChildFirst = pcmType;
}   


void CMUITree::AddLangID ( WORD wLangID )
/*++
Abstract:
    This is language ID tree of resource tree, we need another one besides AddTypeorName because 
    we want to handle LPCTSTR and WORD separately

Arguments:
    wLangID  -  language ID
return:
--*/
{
    
    CMUITree * pcmType = new CMUITree;
    if(!pcmType)
    	return;
                
    pcmType->m_wLangID = wLangID; 

    if ( m_ChildFirst ) {
    
        CMUITree * pmuTree = m_ChildFirst;  // tricky : we put the value of next of child, not this->m_Next;

        while ( pmuTree = pmuTree->m_Next );
        
        pmuTree = pcmType;
    }
    else 
        m_ChildFirst = pcmType;
    
}


BOOL CMUITree::DeleteType ( LPCTSTR lpTypeorName )
/*++
Abstract:
    This is just for deleting method of resource tree. you can delete resource type or name, but 
    not support language id. can be expanded by adding more arguments (lpType,lpName,lpLaguageID)

Arguments:
    lpTypeorName : LPCTSTR type or name 

return:
--*/
{
    if (lpTypeorName == NULL)
        return FALSE;

    CMUITree * pcmTree = m_ChildFirst;
        
    // delete first 
    // the other case : impossible of being same two value.
    if (! pcmTree ) {
        _tprintf("No resource type in the resource tree \n");
        return FALSE;
    }
        
    if ( (0xFFFF0000 & PtrToUlong(lpTypeorName) ) && (0xFFFF0000 & PtrToUlong(pcmTree->m_lpTypeorName) ) ) {

        if (! _tcsicmp(pcmTree->m_lpTypeorName, lpTypeorName ) ){

            m_ChildFirst = pcmTree->m_Next;
            
            CMUITree * pChild = pcmTree->m_ChildFirst;
            CMUITree * pChildNext = NULL;
            
            while ( pChild ) { 
                pChildNext = pChild->m_Next;
                delete pChild;
                pChild = pChildNext;
            }
            
            delete pcmTree;
            return TRUE;
        }
    }
    else if ( !(0xFFFF0000 & PtrToUlong(lpTypeorName) ) && !(0xFFFF0000 & PtrToUlong(pcmTree->m_lpTypeorName) ) ) {
        
        if (!( PtrToUlong(pcmTree->m_lpTypeorName)- PtrToUlong(lpTypeorName ) ) ){
        
            m_ChildFirst = pcmTree->m_Next;

            CMUITree * pChild = pcmTree->m_ChildFirst;
            CMUITree * pChildNext = NULL;

            while ( pChild ) { 
                pChildNext = pChild->m_Next;
                delete pChild;
                pChild = pChildNext;
            }

            delete pcmTree;
            return TRUE;
        }
    }
    // delete middle or last
    CMUITree * pcmTreePre = pcmTree;
    while( pcmTree = pcmTree->m_Next ) {
        
        if ( (0xFFFF0000 & PtrToUlong(lpTypeorName) ) && (0xFFFF0000 & PtrToUlong(pcmTree->m_lpTypeorName) ) ) {

            if (! _tcsicmp(pcmTree->m_lpTypeorName,lpTypeorName ) ){

                pcmTreePre->m_Next = pcmTree->m_Next;

                CMUITree * pChild = pcmTree->m_ChildFirst;
                CMUITree * pChildNext = NULL;

                while ( pChild ) { 
                    pChildNext = pChild->m_Next;
                    delete pChild;
                    pChild = pChildNext;
                }

                delete pcmTree;
                return TRUE;
            }
        }
        else if ( !(0xFFFF0000 & PtrToUlong(lpTypeorName) ) && !(0xFFFF0000 & PtrToUlong(pcmTree->m_lpTypeorName) ) ) {
            
            if (!( PtrToUlong(pcmTree->m_lpTypeorName)- PtrToUlong(lpTypeorName ) ) ){
            
                pcmTreePre->m_Next = pcmTree->m_Next;

                CMUITree * pChild = pcmTree->m_ChildFirst;
                CMUITree * pChildNext = NULL;

                while ( pChild ) { 
                    pChildNext = pChild->m_Next;
                    delete pChild;
                    pChild = pChildNext;
                }

                delete pcmTree;
                return TRUE;
            }
        }
        pcmTreePre = pcmTree;
    }  // while

    return FALSE;
}


DWORD  CMUITree::NumOfChild()
/*++
Abstract:
    Calculate a number of child.
Arguments:

return:
--*/
{

    DWORD dwCont = 0;

        if (m_ChildFirst)
        {
            dwCont++;
            CMUITree * pcMuitree = m_ChildFirst;
            while (pcMuitree = pcMuitree->m_Next) {
                dwCont++;
                }
         }

return dwCont;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\res.h ===
/*****************************************************************************
    
  Copyright (c) 2001,  Microsoft Corporation  All rights reserved.

  Module Name:

   res.h

  Abstract:

    The declaration of class CMuiResource, CMuiCmdInfo ..

  Revision History:

    2001-10-01    sunggch    created.

Revision.

*******************************************************************************/


template < class T >
class CVector {

public:

    CVector() : MAX_SIZE(1000),m_index(0),m_dwExpand(1) { base = offset = new T [MAX_SIZE]; };

    CVector( UINT size ) : MAX_SIZE(size), m_index(0),m_dwExpand(1) { base = offset = new T [MAX_SIZE]; };

    virtual ~ CVector () { delete [] base; };

    void Push_back(T value )  { // *offset ++ = value; }; 
        
        if (m_index < MAX_SIZE * m_dwExpand )
            *offset ++ = value; 
        else {
            m_dwExpand ++;
            T * pbase = NULL;
            T * poffset = NULL;
            pbase = poffset = new T [MAX_SIZE * m_dwExpand ]; 
            for (UINT i = 0; i < MAX_SIZE * ( m_dwExpand -1 ); i++ )
                memcpy(poffset++,&base[i],sizeof(T));

            delete [] base;
            DWORD dwCount = (DWORD) (poffset - pbase);
            base = pbase;
            offset = poffset;
            *offset++ = value;
        }
        m_index ++;
    }

    BOOL Empty( );

    BOOL Find(DWORD dwValue) { // this shouldn't be here, but there is vc++ bug regarding template.
        
        for ( UINT i = 0; i < (UINT) (offset - base); i ++ ) {
            if ( PtrToUlong( GetValue(i) ) & 0xFFFF0000) {
                if ( !( _tcstoul( GetValue(i), NULL, 10 )  - dwValue ) )
                    return TRUE;
            }
            else {
                if (! ( PtrToUlong(GetValue(i) ) - dwValue ) ) 
                    return TRUE;
            }
    }

    return FALSE;
    };

    void Clear() { offset = base; m_index = 0; };

    T operator [] (UINT index ) { return base[index]; };

    T GetValue ( UINT index ) { return base[index]; };

    CVector ( const CVector<T> &cv );

    CVector<T> & operator = (const CVector<T> & cv );

    UINT Size() { assert (base); return (UINT)(offset - base ); };

    
    
private:

    T * base;

    UINT m_index;

    UINT m_dwExpand;

    T * offset;

    const UINT MAX_SIZE;

};



typedef CVector <LPTSTR> cvstring;
typedef CVector <LPCTSTR> cvcstring;
typedef CVector <WORD> cvword;



class CResource {


public:
    BOOL EndUpdateResource ( BOOL bDiscard );

    HANDLE BeginUpdateResource (BOOL bDeleteExistingResources );

    CResource ();

    virtual ~ CResource (); 

    CResource (const CResource & cr );

    CResource & operator = (const CResource & cr );


    // enumerate resource
    cvcstring * EnumResTypes (LONG_PTR lParam = NULL ); 
    
    cvcstring * EnumResNames (LPCTSTR pszType,LONG_PTR lParam = NULL );
    
    cvword * EnumResLangID ( LPCTSTR lpType,LPCTSTR lpName,LONG_PTR lParam = NULL );


    BOOL UpdateResource (LPCTSTR lpType,LPCTSTR lpName,WORD wLanguage, LPVOID lpData, DWORD cbData);
    
    // delete all resource, we can replace the value as well.
    BOOL SetAllResource(LPVOID lpData, DWORD cbData );

    
    HRSRC FindResourceEx (LPCTSTR lpType, LPCTSTR lpName,WORD wLanguage ) 
                { return ::FindResourceEx(m_hRes, lpType, lpName, wLanguage ); };
    
    virtual void SetResType(LPCTSTR pszType) { m_vwResType -> Push_back((LPCTSTR)pszType); };

    virtual void SetResName(LPCTSTR pszName) { m_vwResName -> Push_back((LPCTSTR)pszName); };

    virtual void SetResLangID(WORD wLangID) {m_vwResLangID -> Push_back(wLangID); };


    cvcstring * GetResType () {return m_vwResType; }; 

    cvcstring * GetResName () {return m_vwResName; };

    cvword * GetResLangID () {return m_vwResLangID; };


    DWORD SizeofResource( HRSRC hResInfo ) { return ::SizeofResource(m_hRes,hResInfo); };

    HGLOBAL LoadResource (HRSRC hResInfo ) { return ::LoadResource(m_hRes, hResInfo); };

    LPVOID LockResource( HGLOBAL hResData ) { return :: LockResource(hResData); };

    BOOL FreeLibrary(void) { return ::FreeLibrary(m_hRes); } 

    //LoadResource ( );

protected :

    HMODULE  m_hRes;
    
    LPCTSTR  m_pszFile;  // why not using "string m_sFile "

private :

    HANDLE m_hResUpdate;

    cvcstring * m_vwResType;
    cvcstring * m_vwResName;
    cvword * m_vwResLangID; 
    
    //LPCTSTR ** m_pTmp;

public:
    
};


class CMUIData {

    class CMap {
        
        friend CMUIData;

        LPCTSTR     m_lpType;
        LPCTSTR     m_lpName;
        WORD        m_wLangID;

        CMap ();// : m_lpType(NULL),m_lpName(NULL),m_wLangID(0) { };
        
        virtual ~ CMap() {};

        static PVOID operator new ( size_t size ); 
        
        static void operator delete ( void *p );


    };


public:

    CMUIData() : m_iSize(0) { m_cmap = m_poffset = NULL ; };

    virtual ~ CMUIData();

    void SetAllData ( LPCTSTR lpType, LPCTSTR lpName, WORD wLang, UINT i ); 

    LPCTSTR GetType ( UINT i ) const { assert ( i < m_iSize); return m_cmap[i].m_lpType; };

    LPCTSTR GetName ( UINT i ) const { assert ( i < m_iSize); return m_cmap[i].m_lpName; };

    WORD  GetLangID ( UINT i) const { assert ( i < m_iSize); return m_cmap[i].m_wLangID; };

    INT SizeofData ( ) const { return m_iSize ; };

    void SetType( UINT index, LPCTSTR lpType );
    
private:
    
private : 

    UINT m_iSize;
    
    static CMap * m_cmap; 
    
    static CMap * m_poffset;

    static UINT m_index;

    static const UINT MAX_SIZE_RESOURCE;

    
};



// Place all data in public area for performance. we don't want to call Get... although calling Add..

class CMUITree
{
public:
    CMUITree    * m_Next;
    CMUITree    * m_ChildFirst;
    LPCTSTR     m_lpTypeorName;
    WORD        m_wLangID;

public:
    CMUITree() : m_Next(NULL), m_ChildFirst(NULL), m_lpTypeorName(NULL), m_wLangID(0) {}; 
    virtual ~ CMUITree() { };

    void AddTypeorName( LPCTSTR lpType );
    void AddLangID ( WORD wLangID );
        // we keep path with AddTypeofName by controling Child pointer.
    BOOL DeleteType ( LPCTSTR lpTypeorName );
    //  DeleteLangID ( CMUITree *pcmName, WORD wLangID );  // does not support in this time.
    DWORD NumOfChild();

private :  
    CMUITree(CMUITree & cmuit) {}; // NOT_IMPLETMENT_YET
    CMUITree & operator = (CMUITree & cmuit) {} ;  // NOT_IMPLETMENT_YET

};


class CMUIResource : public CResource 
{
public :

    CMUIResource();

    CMUIResource(LPCTSTR pszName);

    virtual ~CMUIResource() ;

    CMUIResource(const CMUIResource & cmui );
    
    CMUIResource & operator = (const CMUIResource & cmui);

    BOOL Create( LPCTSTR pszFile );

    BOOL CreatePE( LPCTSTR pszNewResFile , LPCTSTR pszSrcResFile);
    
    virtual BOOL WriteResFile(LPCTSTR pszSource, LPCTSTR pszMuiFile , LPCTSTR lpCommandLine, WORD wLanguageID = 0  );

    virtual BOOL DeleteResource (WORD wLang = 0 );

    virtual BOOL FillMuiData(cvcstring * vType, WORD wLanguageID, BOOL fForceLocalizedLangID  );

    virtual void PrtVerbose ( DWORD dwRate);

    BOOL DeleteResItem(LPCTSTR lpType, LPCTSTR lpName=NULL,WORD wLanguageID = 0);
    
    MD5_CTX * CreateChecksum (cvcstring * cvChecksumResourceTypes,WORD  wChecksumLangId);

    MD5_CTX * CreateChecksumWithAllRes(WORD  wChecksumLangId);

    BOOL AddChecksumToVersion(BYTE * pbMD5Digest);

    BOOL UpdateNtHeader(LPCTSTR pszFileName, DWORD dwUpdatedField );

    
protected :

    

private :


    BOOL WriteResource(HANDLE hFile, HMODULE hModule, WORD wLanguage, LPCSTR lpName, LPCSTR lpType, HRSRC hRsrc);

    BOOL WriteResHeader(HANDLE hFile, LONG ResSize, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, DWORD* pdwBytesWritten, DWORD* pdwHeaderSize);

    BOOL bInsertHeader(HANDLE hFile); 
    
    void PutByte(HANDLE OutFile, TCHAR b, ULONG *plSize1, ULONG *plSize2);

    void PutWord(HANDLE OutFile, WORD w, ULONG *plSize1, ULONG *plSize2);

    void PutDWord(HANDLE OutFile, DWORD l, ULONG *plSize1, ULONG *plSize2);

    void PutString(HANDLE OutFile, LPCSTR szStr , ULONG *plSize1, ULONG *plSize2);

    void PutStringW(HANDLE OutFile, LPCWSTR szStr , ULONG *plSize1, ULONG *plSize2);

    void PutPadding(HANDLE OutFile, int paddingCount, ULONG *plSize1, ULONG *plSize2); 

private:

    void CheckTypeStability();
    
    DWORD AlignDWORD ( DWORD dwValue) { return ( (dwValue+3) & ~3 ); };
    

private:
    HANDLE    m_hFile; 

    CMUIData  m_cMuiData;
    
    CMUITree *m_pcmTreeRoot;

    
    
public:
    MD5_CTX * m_pMD5;
    WORD m_wChecksumLangId; // we put this in public for perfomance.
    enum {
        IMAGE_SIZE  = 0x00000001L,
        HEADER_SIZE = 0x00000010L,
        CHECKSUM    = 0x00000100L,
    };
    

};



/**********************************************
class CArgVerify 



***********************************************/
class CCommandInfo {

public :
    CCommandInfo() { };

    virtual ~CCommandInfo() { };
    
    virtual BOOL CreateArgList(INT argc, TCHAR * argv [] ) = 0;

    
private :

    
};

    

class CMuiCmdInfo : public  CCommandInfo {

    class CMap {
        friend CMuiCmdInfo;
        
        LPCTSTR     m_first; 
        LPTSTR *    m_second;
        UINT        m_count;

        CMap () : m_first( NULL ),m_count(0){m_second = new LPTSTR[100]; };  // we have more than 16 resource type.need to generalize

        ~ CMap () { delete [] m_second; }

    };

public :
    CMuiCmdInfo();

    virtual ~CMuiCmdInfo();
    
    CMuiCmdInfo(CMuiCmdInfo& cav);  // copy constructor

    BOOL CreateArgList(INT argc, TCHAR * argv [] );

    LPTSTR * GetValueLists ( LPCTSTR pszKey, DWORD& dwCount );
    
    void SetArgLists(LPTSTR pszArgLists, LPTSTR m_pszArgNeedValueList, LPTSTR pszArgAllowFileValue,
                                LPTSTR pszArgAllowMultiValue );

private :

    CMuiCmdInfo& operator=(CMuiCmdInfo& cav) ;  // do not allow = operation

    LPCTSTR getArgValue ( LPTSTR pszArg );
    LPCTSTR getArgString ( LPTSTR pszArg);
    BOOL isFile ( LPCTSTR pszArg );
    BOOL isNumber ( LPCTSTR pszArg );
    BOOL isNeedValue( LPCTSTR pszArg );
    BOOL isAllowFileValue(LPCTSTR pszArg);
    BOOL isAllowMultiFileValues( LPCTSTR pszArg );


private : // member data
    CMap  m_cmap[256];
    UINT  m_uiCount;
    TCHAR *m_buf, *m_buf2;   // just in case no new,resource name exist. we can delete this on the destructor.
    LPTSTR m_pszArgLists;
    LPTSTR m_pszArgNeedValueList;   // arg., which is need values
    LPTSTR m_pszArgAllowFileValue;  
    LPTSTR m_pszArgAllowMultiValue;
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\diamond.cpp ===
/*++

Copyright (c) 1991-1999,  Microsoft Corporation  All rights reserved.

Module Name:

    diamond.c

Abstract:

    Implement File Decompression Interface -FDI- for Cabinet files.


Revision History:

    04-20-1999    SamerA    Created.

--*/

#include "muisetup.h"
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <sys/stat.h>
#define STRSAFE_LIB
#include <strsafe.h>


// 
// Module Global Variables
//

//
// Cabinet DLL handle
HINSTANCE hCabinetDll;
HFDI ghfdi;                  // diamond FDI context


//
// DLL Function pointers
//
typedef HFDI (DIAMONDAPI *PFNFDICREATE)(
    PFNALLOC pfnalloc,
    PFNFREE pfnfree,
    PFNOPEN pfnopen,
    PFNREAD pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK pfnseek,
    int cpuType,
    PERF perf);

typedef BOOL (DIAMONDAPI *PFNFDIISCABINET)(
    HFDI hfdi,
    INT_PTR hf,
    PFDICABINETINFO pfdici);

typedef BOOL (DIAMONDAPI *PFNFDICOPY)(
    HFDI hfdi,
    char *pszCabinet,
    char *pszCabPath,
    int  flags,
    PFNFDINOTIFY pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void *pvUser);

typedef BOOL (DIAMONDAPI *PFNFDIDESTROY)(
    HFDI hfdi);
        

PFNFDICREATE pfnFDICreate;
PFNFDICOPY pfnFDICopy;
PFNFDIISCABINET pfnFDIIsCabinet;
PFNFDIDESTROY pfnFDIDestroy;


//-------------------------------------------------------------------------//
//                          FDI EXTERNAL ROUTINES                          //
//-------------------------------------------------------------------------//


////////////////////////////////////////////////////////////////////////////
//
//  FDICreate
//
//  Tries to create an FDI context. Will load cabinet.dll and hook necessary
//  function pointers.
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

HFDI DIAMONDAPI FDICreate(
    PFNALLOC pfnalloc,
    PFNFREE  pfnfree,
    PFNOPEN  pfnopen,
    PFNREAD  pfnread,
    PFNWRITE pfnwrite,
    PFNCLOSE pfnclose,
    PFNSEEK  pfnseek,
    int      cpuType,
    PERF     perf)
{
    HFDI hfdi;


    //
    // Load cabinet DLL
    //
    hCabinetDll = LoadLibrary(TEXT("CABINET.DLL"));
    if (hCabinetDll == NULL)
    {
        return NULL;
    }

    //
    // Hook function pointers
    //
    pfnFDICreate = (PFNFDICREATE) GetProcAddress(hCabinetDll, "FDICreate");
    pfnFDICopy = (PFNFDICOPY) GetProcAddress(hCabinetDll, "FDICopy");
    pfnFDIIsCabinet = (PFNFDIISCABINET) GetProcAddress(hCabinetDll, "FDIIsCabinet");
    pfnFDIDestroy = (PFNFDIDESTROY) GetProcAddress(hCabinetDll, "FDIDestroy");

    if ((pfnFDICreate == NULL)    ||
        (pfnFDICopy == NULL)      ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary( hCabinetDll );
        return NULL;
    }

    //
    // Try to create an FDI context
    //
    hfdi = pfnFDICreate( pfnalloc,
                         pfnfree,
                         pfnopen,
                         pfnread,
                         pfnwrite,
                         pfnclose,
                         pfnseek,
                         cpuType,
                         perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return hfdi;
}



////////////////////////////////////////////////////////////////////////////
//
//  FDIIsCabinet
//
//  Determines if file is a cabinet, returns info if it is
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI FDIIsCabinet(
    HFDI            hfdi,
    INT_PTR         hf,
    PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return FALSE;
    }

    return (pfnFDIIsCabinet(hfdi,hf,pfdici));
}



////////////////////////////////////////////////////////////////////////////
//
//  FDICopy
//
//  Extracts files from a cabinet
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI FDICopy(
    HFDI          hfdi,
    char         *pszCabinet,
    char         *pszCabPath,
    int           flags,
    PFNFDINOTIFY  pfnfdin,
    PFNFDIDECRYPT pfnfdid,
    void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return FALSE;
    }

    return (pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}



////////////////////////////////////////////////////////////////////////////
//
//  FDIDestroy
//
//  Destroy an FDI context. Should be called when you're done with the HFDI.
//
//  04-20-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL DIAMONDAPI FDIDestroy(
    HFDI hfdi)
{
    BOOL bRet;

    if (pfnFDIDestroy == NULL)
    {
        return FALSE;
    }

    bRet = pfnFDIDestroy( hfdi );
    if (bRet == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return bRet;
}



//-------------------------------------------------------------------------//
//                        FDI SUPPORT ROUTINES                             //
//-------------------------------------------------------------------------//


PVOID
DIAMONDAPI
DiamondMemAlloc(
    IN ULONG NumberOfBytes
    )
{
    return ((PVOID)LocalAlloc(LMEM_FIXED, NumberOfBytes));
}


VOID
DIAMONDAPI
DiamondMemFree(
    IN PVOID Block
    )
{
   if (Block)
   {
        LocalFree( (HLOCAL)Block );
   }
}


INT_PTR
DIAMONDAPI
DiamondFileOpen(
    IN PSTR FileName,
    IN int  oflag,
    IN int  pmode
    )
{
    HFILE h;
    int OpenMode;

    if (oflag & _O_WRONLY) 
    {
        OpenMode = OF_WRITE;
    } else 
    {
        if (oflag & _O_RDWR)
        {
            OpenMode = OF_READWRITE;
        } else 
        {
            OpenMode = OF_READ;
        }
    }

    h = _lopen(FileName, OpenMode | OF_SHARE_DENY_WRITE);

    if (h == HFILE_ERROR) 
    {
        return -1;
    }

    return ((INT_PTR) h);
}


UINT
DIAMONDAPI
DiamondFileRead(
    IN  INT_PTR Handle,
    OUT PVOID pv,
    IN  UINT  ByteCount
    )
{
    UINT rc;

    rc = _lread((HFILE)Handle, pv, ByteCount);

    if (rc == HFILE_ERROR) 
    {
        rc = (UINT)(-1);
    }

    return rc;
}


UINT
DIAMONDAPI
DiamondFileWrite(
    IN INT_PTR Handle,
    IN PVOID pv,
    IN UINT  ByteCount
    )
{
    UINT rc;

    rc = _lwrite((HFILE)Handle, (LPCSTR)pv, ByteCount);

    return rc;
}


int
DIAMONDAPI
DiamondFileClose(
    IN INT_PTR Handle
    )
{
    _lclose( (HFILE)Handle );
    return 0;
}


LONG
DIAMONDAPI
DiamondFileSeek(
    IN INT_PTR Handle,
    IN long Distance,
    IN int  SeekType
    )
{
    LONG rc;

    rc = _llseek((HFILE)Handle, Distance, SeekType);

    if (rc == HFILE_ERROR) 
    {
        rc = -1L;
    }

    return rc;
}


INT_PTR
DIAMONDAPI
DiamondNotifyFunction(
    IN FDINOTIFICATIONTYPE Operation,
    IN PFDINOTIFICATION    Parameters
    )
{
    HRESULT hresult;
    switch (Operation)
    {        
        case fdintCABINET_INFO: // general information about the cabinet
            return 0;
        break;


        case fdintPARTIAL_FILE: // first file in cabinet is continuation
            return 0;
        break;

        case fdintCOPY_FILE:    // file to be copied
        {
            HFILE handle;
            char destination[256];
            PDIAMOND_PACKET pDiamond = (PDIAMOND_PACKET) Parameters->pv;
            

            
            //
            // Check to see if we just want the original file name
            //
            if (pDiamond->flags & DIAMOND_GET_DEST_FILE_NAME)
            {
                //*STRSAFE*                 strcpy( pDiamond->szDestFilePath, Parameters->psz1 );
                hresult = StringCchCopyA(pDiamond->szDestFilePath , ARRAYSIZE(pDiamond->szDestFilePath),  Parameters->psz1 );
                if (!SUCCEEDED(hresult))
                {
                   return -1;
                }
                return 0;
            }

            //*STRSAFE*             sprintf( destination, "%s%s", pDiamond->szDestFilePath, Parameters->psz1 );
            hresult = StringCchPrintfA(destination , ARRAYSIZE(destination),  "%s%s", pDiamond->szDestFilePath, Parameters->psz1 );
            if (!SUCCEEDED(hresult))
            {
               return -1;
            }

            handle = _lcreat(destination, 0);

            if (handle == HFILE_ERROR)
            {
                return -1;
            }

            return handle;
        }
        break;

        case fdintCLOSE_FILE_INFO:    // close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            PDIAMOND_PACKET pDiamond = (PDIAMOND_PACKET) Parameters->pv;


            if (pDiamond->flags & DIAMOND_GET_DEST_FILE_NAME)
            {
                return 0;
            }

            //*STRSAFE*             sprintf( destination, "%s%s", pDiamond->szDestFilePath, Parameters->psz1);
            hresult = StringCchPrintfA(destination , ARRAYSIZE(destination),  "%s%s", pDiamond->szDestFilePath, Parameters->psz1);
            if (!SUCCEEDED(hresult))
            {
               return -1;
            }

            _lclose( (HFILE)Parameters->hf );


            //
            // Set date/time
            //
            // Need Win32 type handle for to set date/time
            //
            handle = CreateFileA( destination,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime( Parameters->date,
                                                   Parameters->time,
                                                   &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime( &datetime,
                                                         &local_filetime))
                    {
                        SetFileTime( handle,
                                     &local_filetime,
                                     NULL,
                                     &local_filetime
                                   );
                    }
                }

                CloseHandle(handle);
            }

            //
            // Mask out attribute bits other than readonly,
            // hidden, system, and archive, since the other
            // attribute bits are reserved for use by
            // the cabinet format.
            //
            attrs = Parameters->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            SetFileAttributesA( destination,
                                attrs
                              );

            return TRUE;
        }
        break;

        case fdintNEXT_CABINET:  // file continued to next cabinet
            return 0;
        break;
    }

    return 0;
}




//-------------------------------------------------------------------------//
//                        MUISETUP-SUPPORT ROUTINES                        //
//-------------------------------------------------------------------------//

////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_InitDiamond
//
//  Initialize diamond DLL.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

HFDI Muisetup_InitDiamond()
{
    ERF erf;

    if (!ghfdi)
    {
        ghfdi = FDICreate( DiamondMemAlloc,
                           DiamondMemFree,
                           DiamondFileOpen,
                           DiamondFileRead,
                           DiamondFileWrite,
                           DiamondFileClose,
                           DiamondFileSeek,
                           cpuUNKNOWN,
                           &erf );
    }

    return ghfdi;
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_FreeDiamond
//
//  Free diamond dll. Should be called at application shutdown.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_FreeDiamond()
{
    BOOL bRet = TRUE;

    if (ghfdi)
    {
        bRet = FDIDestroy(ghfdi);
    }

    return bRet;
}

////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_DiamondReset
//
//  Should be called at the start of processing a file to copy.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

void Muisetup_DiamondReset(
    PDIAMOND_PACKET pDiamond)
{
    pDiamond->flags = DIAMOND_NONE;

    return;
}



////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_IsDiamondFile
//
//  Determines if a file is a diamond file, and if so, returns its original
//  name.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_IsDiamondFile(
    PWSTR pwszFileName,
    PWSTR pwszOriginalName,
    INT nSize,
    PDIAMOND_PACKET pDiamond)
{
    INT_PTR hf;
    BOOL bRet;
    int nCount;
    char *p;
    FDICABINETINFO fdici;
    HFDI hfdi = ghfdi;
    HRESULT hresult;

    if (!hfdi)
    {
#if SAMER_DBG
        OutputDebugStringA("Muisetup_IsDiamondFile : No HFDI context\n");
#endif
        return FALSE;
    }

    //
    // Init the diamond packet
    //
    pDiamond->flags = DIAMOND_NONE;

    if ((nCount = WideCharToMultiByte( CP_ACP,
                                       0,
                                       pwszFileName,
                                       -1,
                                       pDiamond->szSrcFilePath,
                                       sizeof( pDiamond->szSrcFilePath ),
                                       NULL,
                                       NULL )) == 0)
    {
#if SAMER_DBG
        OutputDebugStringA("Muisetup_IsDiamondFile : WideCharToMultiByte failed\n");
#endif
        return FALSE;
    }
    pDiamond->szSrcFilePath[ nCount ] = '\0';

    hf = DiamondFileOpen( pDiamond->szSrcFilePath,
                          _O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
                          0
                        );

    if (hf == -1)
    {
#if SAMER_DBG
        OutputDebugStringA("Muisetup_IsDiamondFile : file_open failed\n");
#endif
        return FALSE;
    }

    bRet = FDIIsCabinet( hfdi,
                         hf,
                         &fdici
                       );

    DiamondFileClose( hf );

    //
    // If succeeded, then let's setup everything else
    // to get the correct original file name
    //
    if (bRet)
    {
        pDiamond->flags |= DIAMOND_GET_DEST_FILE_NAME;

        p = strrchr(pDiamond->szSrcFilePath, '\\');

        if (p == NULL)
        {
            //*STRSAFE*             strcpy(pDiamond->szSrcFileName, pDiamond->szSrcFilePath);
            hresult = StringCchCopyA(pDiamond->szSrcFileName , ARRAYSIZE(pDiamond->szSrcFileName),  pDiamond->szSrcFilePath);
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
            //*STRSAFE*             strcpy(pDiamond->szSrcFilePath, "");
            hresult = StringCchCopyA(pDiamond->szSrcFilePath , ARRAYSIZE(pDiamond->szSrcFilePath),  "");
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
        }
        else
        {
            //*STRSAFE*             strcpy(pDiamond->szSrcFileName, p+1);
            hresult = StringCchCopyA(pDiamond->szSrcFileName , ARRAYSIZE(pDiamond->szSrcFileName),  p+1);
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
            p[ 1 ] = '\0';
        }

        
        //*STRSAFE*         strcpy( pDiamond->szDestFilePath, "c:\\samer\\" );
        hresult = StringCchCopyA(pDiamond->szDestFilePath , ARRAYSIZE(pDiamond->szDestFilePath),  "c:\\samer\\" );
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        if (Muisetup_CopyDiamondFile( pDiamond,
                                      NULL))
        {
            //
            // Convert the original file name back to Unicode
            //
            nCount = MultiByteToWideChar( CP_ACP,
                                          0,
                                          pDiamond->szDestFilePath,
                                          -1,
                                          pwszOriginalName,
                                          nSize
                                        );

            if (!nCount)
            {
                return FALSE;
            }

            pwszOriginalName[ nCount ] = UNICODE_NULL;
            pDiamond->flags = DIAMOND_FILE;
        
#if SAMER_DBG
            {
                BYTE byBuf[200];

                //*STRSAFE*                 wsprintfA(byBuf, "SrcFile = %s%s, OriginalFileName=%s\n", pDiamond->szSrcFilePath, pDiamond->szSrcFileName,pDiamond->szDestFilePath);
                hresult = StringCchPrintfA(byBuf , ARRAYSIZE(byBuf),  "SrcFile = %s%s, OriginalFileName=%s\n", pDiamond->szSrcFilePath, pDiamond->szSrcFileName,pDiamond->szDestFilePath);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                OutputDebugStringA(byBuf);
            }
#endif
        }

        pDiamond->flags &= ~DIAMOND_GET_DEST_FILE_NAME;
    }

    return bRet;
}




////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CopyDiamondFile
//
//  Copies and expands a diamond file.
//
//  04-23-99     SamerA     Created.
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CopyDiamondFile(
    PDIAMOND_PACKET pDiamond,
    PWSTR pwszCopyTo)
{
    char szDestPath[ MAX_PATH + 1];
    char *p;
    int nCount;
    BOOL bRet;
    HFDI hfdi = ghfdi;
    HRESULT hresult;

    
    //
    // Validate that this is a diamond file
    //
    if ((!hfdi) ||
        (pDiamond->flags == DIAMOND_NONE))
    {
        return FALSE;
    }

    //
    // Validate flags
    //
    if (!(pDiamond->flags & (DIAMOND_FILE | DIAMOND_GET_DEST_FILE_NAME)))
    {
        return FALSE;
    }

#if SAMER_DBG
    {
      BYTE byBuf[100];
      //*STRSAFE*       wsprintfA(byBuf, "DiamondCopy called for %s, flags = %lx\n", pDiamond->szSrcFileName, pDiamond->flags);
      hresult = StringCchPrintfA(byBuf , ARRAYSIZE(byBuf),  "DiamondCopy called for %s, flags = %lx\n", pDiamond->szSrcFileName, pDiamond->flags);
      if (!SUCCEEDED(hresult))
      {
         return FALSE;
      }
      OutputDebugStringA(byBuf);
    }
#endif

    if (!(pDiamond->flags & DIAMOND_GET_DEST_FILE_NAME))
    {
        if ((nCount = WideCharToMultiByte( CP_ACP,
                                           0,
                                           pwszCopyTo,
                                           -1,
                                           szDestPath,
                                           sizeof( szDestPath ),
                                           NULL,
                                           NULL )) == 0)
        {
            return FALSE;
        }        


        p = strrchr(szDestPath, '\\');
        if (p)
        {
            p[1] = '\0';
        }
        else
        {
            szDestPath[ nCount ] = '\\';
            szDestPath[ nCount + 1 ] = '\0';
        }

        //*STRSAFE*         strcpy( pDiamond->szDestFilePath, szDestPath );
        hresult = StringCchCopyA(pDiamond->szDestFilePath , ARRAYSIZE(pDiamond->szDestFilePath),  szDestPath );
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    }


    bRet = FDICopy( hfdi,
                    pDiamond->szSrcFileName,
                    pDiamond->szSrcFilePath,
                    0,
                    DiamondNotifyFunction,
                    NULL,
                    pDiamond);

#if SAMER_DBG
    {
        BYTE byBuf[200];

        //*STRSAFE*         wsprintfA(byBuf, "SrcFile = %s%s, DestPath=%s, Status=%lx\n", pDiamond->szSrcFilePath,pDiamond->szSrcFileName,pDiamond->szDestFilePath, bRet);
        hresult = StringCchPrintfA(byBuf , ARRAYSIZE(byBuf),  "SrcFile = %s%s, DestPath=%s, Status=%lx\n", pDiamond->szSrcFilePath,pDiamond->szSrcFileName,pDiamond->szDestFilePath, bRet);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        OutputDebugStringA(byBuf);
    }
#endif

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muirct\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by muirct.rc
//
#define IDR_PE_TEMPLATE                 20

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\installer.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <shlwapi.h>
#include <shlwapip.h> // For SHRegisterValidateTemplate()
#include "muisetup.h"
#include "stdlib.h"
#include "tchar.h"
#include <setupapi.h>
#include <syssetup.h>
#include "lzexpand.h"
#include <sxsapi.h>
#include <Msi.h>    // for Msi invocation API
#ifdef _IA64_
#include "msiguids64.h"
#else
#include "msiguids.h"
#endif

#define STRSAFE_LIB
#include <strsafe.h>

#define SHRVT_REGISTER                  0x00000001
#define DEFAULT_INSTALL_SECTION TEXT("DefaultInstall")
#define DEFAULT_UNINSTALL_SECTION TEXT("DefaultUninstall")

// GLOBAL variables
MUIMSIREGINFO g_MuiMsiRegs[REG_MUI_MSI_COUNT] = {
                    {HKEY_LOCAL_MACHINE, REGSTR_HKLM_MUI_MSI1, NORMAL_GUID}, 
                    {HKEY_LOCAL_MACHINE, REGSTR_HKLM_MUI_MSI2, REVERSED_GUID}, 
                    {HKEY_LOCAL_MACHINE, REGSTR_HKLM_MUI_MSI3, REVERSED_GUID}, 
                    {HKEY_CLASSES_ROOT, REGSTR_HKR_MUI_MSI4, REVERSED_GUID},
                    {HKEY_CLASSES_ROOT, REGSTR_HKR_MUI_MSI5, REVERSED_GUID}
               };

extern TCHAR  DirNames[MFL][MAX_PATH],DirNames_ie[MFL][MAX_PATH];
LPTSTR g_szSpecialFiles[] = {
    TEXT("hhctrlui.dll"),
};
extern BOOL     g_bReboot;
extern BOOL     g_bSilent;
extern BOOL     g_bNoUI;
extern BOOL     g_bLipLanguages;
extern BOOL     g_bLipAllowSwitch;
extern BOOL     g_bRunFromOSSetup;
extern TCHAR    g_szCDLabel[MAX_PATH];
extern int      g_cdnumber;;

void debug(char *printout);


////////////////////////////////////////////////////////////////////////////
//
//  ConstructMSIGUID
//
//  This function will reverse the character orders in each section of a 
//  string guild (separated by the - char) and write the result to the
//  output.  The output string will also have all the - characters
//  removed as well.
//
////////////////////////////////////////////////////////////////////////////
BOOL ConstructMSIGUID(LPTSTR szGuid, LPTSTR szOutput)
{
    BOOL    bResult = TRUE;
    INT     i, j;
    INT     iSegments1[3] = {8, 4, 4};    // number of char in each segments of a guid string
    INT     iSegments2[5] = {4, 12};    // number of char in each segments of a guid string    
    TCHAR   *tcDest = szOutput;
    TCHAR   *tcSource = szGuid+1;               // we increment by one to skip the opening '{' char
    
    if ((NULL == szGuid) || (NULL == szOutput))
    {
        return FALSE;
    }
    else
    {       
        for (i = 0; i < 3; i++)
        {
            // copy the size of the segment into the output buffer 
            _tcsncpy(tcDest, tcSource, iSegments1[i]);

            // add a null to the end of the dest
            *(tcDest+iSegments1[i]) = NULL;

            // reverse the section we just copied into the output buffer
            _tcsrev(tcDest);

            // skip ahead, for source, we add one more so we don't copy the '-' char
            tcDest += iSegments1[i];
            tcSource += (iSegments1[i] + 1);
        }
        for (i = 0; i < 2; i++)

        {
            j = iSegments2[i];
            // here in each segment, we swap every second char in the segment, eg. 1a3f becomes a1f3
            while (j > 0)
            {
                // copy the size of the segment into the output buffer, swapping the source chars
                tcDest[0] = tcSource[1];
                tcDest[1] = tcSource[0];
                tcDest[2] = NULL;
                j-=2;
                tcDest += 2;
                tcSource += 2;
            }
            // for source, we add one more so we don't copy the '-' char
            tcSource++;            
        }
    }
    
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  DeleteMSIRegSettings
//
//  This function will atempt to manually remove enough MSI registry
//  keys from the system so that a specific MUI language is shown as
//  not installed on the system.
//
//  Note that this is a hack right now as, during OS setup, the windows
//  installer service is not available and so we cannot find a way
//  to uninstall MUI during that time using the windows installer service.
//
////////////////////////////////////////////////////////////////////////////
void DeleteMSIRegSettings(LPTSTR Language)
{
    TCHAR   tcMessage[BUFFER_SIZE];
    BOOL    bFound = FALSE;
    TCHAR   szProductCode[GUIDLENGTH];      // stores a GUID in string format
    TCHAR   szReversed[GUIDLENGTH-4];        // this is essentially the guild string reversed and without the dashes
    HKEY    hkReg = NULL;
    DWORD   dwDisp = 0;
    int     i;
    
    if (NULL == Language)
    {
        return;
    }

    // look up the MSI product code for the 
    bFound = GetMSIProductCode(Language, szProductCode, ARRAYSIZE(szProductCode));

    // construct the reversed guid string key
    ConstructMSIGUID(szProductCode, szReversed);

    if (TRUE == bFound)
    {
        for (i=0; i<REG_MUI_MSI_COUNT; i++)
        {
            if (RegOpenKeyEx(g_MuiMsiRegs[i].hkRegRoot,
                             g_MuiMsiRegs[i].szRegString,
                             0,
                             KEY_ALL_ACCESS,
                             &hkReg) == ERROR_SUCCESS)
            {
                if (g_MuiMsiRegs[i].RegType == NORMAL_GUID)
                {
                    DeleteRegTree(hkReg, szProductCode);
                }
                else
                {
                    DeleteRegTree(hkReg, szReversed);
                }
                RegCloseKey(hkReg);
            }
        }
    }
    else
    {
        wnsprintf(tcMessage, ARRAYSIZE(tcMessage), TEXT("MuiSetup: DeleteMSIRegSettings: product code for language %s is not found."), Language);
        LogMessage(tcMessage); 
    }

}


////////////////////////////////////////////////////////////////////////////////////
//
//  GetMSIProductCode
//
//  This function returns the product code for a specific mui language
//  after copying it into the supplied destination buffer.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetMSIProductCode(LPTSTR szLanguage, LPTSTR szProductCode, UINT uiBufSize)
{
    HRESULT hresult = S_OK;
    int     i;
    BOOL    bResult = FALSE;
    TCHAR   tcMessage[BUFFER_SIZE];
    
    if ((NULL == szLanguage) || (NULL == szProductCode) || (uiBufSize <= 0))
    {
        wnsprintf(tcMessage, ARRAYSIZE(tcMessage) ,TEXT("MuiSetup: GetMSIProductCode: WARNING - input parameter invalid."));
        LogMessage(tcMessage);     
        bResult = FALSE;
    }
    else
    {
        for (i = 0; i < NUM_PRODUCTS; i++)
        {
            if (lstrcmpi(szLanguage, g_mpProducts[i].szLanguage) == 0)
            {
                //*STRSAFE*                 lstrcpy(szProductCode, g_mpProducts[i].szProductGUID);
                hresult = StringCchCopy(szProductCode , uiBufSize,  g_mpProducts[i].szProductGUID);
                if (!SUCCEEDED(hresult))
                {
                    wnsprintf(tcMessage, ARRAYSIZE(tcMessage) ,TEXT("MuiSetup: GetMSIProductCode: WARNING - failed to copy product code to output buffer."));
                    LogMessage(tcMessage);                     
                    bResult = FALSE;
                }
                else
                {
                    bResult = TRUE;
                }
                break;
            }
        }
    }

    if (FALSE == bResult)
    {
        wnsprintf(tcMessage, ARRAYSIZE(tcMessage) ,TEXT("MuiSetup: GetMSIProductCode: WARNING - failed to find the MSI product code for langauge %s."), szLanguage);
        LogMessage(tcMessage);                     
    }
    
    return bResult;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  EnumLanguages
//
//  Enumerate the languages in the [Languages] section of MUI.INF. And check for the language 
//  folders in the CD-ROM.
//  Languages is an OUT parameter, which will store the languages which has language folder
//  in the CD-ROM.
//
////////////////////////////////////////////////////////////////////////////////////

int EnumLanguages(LPTSTR Languages, BOOL bCheckDir)
{
    DWORD  dwErr;
    LPTSTR Language;
    LONG_PTR lppArgs[2];    
    TCHAR  szInffile[MAX_PATH];
    int    iLanguages = 0;
    TCHAR  LipLanguages[128] = {0};
    HRESULT hresult;

    if (!Languages)
    {
        return (-1);
    }                  
    //
    // MUI.INF should be in the same directory in which the installer was
    // started
    //

    //*STRSAFE*     _tcscpy(szInffile, g_szMUIInfoFilePath);             
    hresult = StringCchCopy(szInffile , ARRAYSIZE(szInffile),  g_szMUIInfoFilePath);
    if (!SUCCEEDED(hresult))
    {
       return (-1);
    }

    //
    // find out how many languages we can install
    //

    *Languages = TEXT('\0');
    if (!GetPrivateProfileString( MUI_LANGUAGES_SECTION,
                                  NULL,
                                  TEXT("NOLANG"),
                                  Languages,
                                  BUFFER_SIZE,
                                  szInffile))
    {               
        //
        //      "LOG: Unable to read MUI.INF - rc == %1"
        //
        lppArgs[0] = (LONG_PTR)GetLastError();
        lppArgs[1] = (LONG_PTR)g_szMUIInfoFilePath;        
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);

        return(-1);
    }  
    

    if (bCheckDir)
    {
        CheckLanguageDirectoryExist(Languages);
    }

    Language = Languages;

    //
    // Count the number of languages which exist in the CD-ROM,
    // and return that value.
    //
    while (*Language)
    {
        iLanguages++;
        while (*Language++)
        {
        }
    }

    if (iLanguages == 1 &&
      GetPrivateProfileSection( MUI_LIP_LANGUAGES_SECTION,
                                  LipLanguages,
                                  ARRAYSIZE(LipLanguages),
                                  szInffile)) 
    {
        g_bLipLanguages = TRUE;
    }

    if (g_bLipLanguages &&
    GetPrivateProfileSection( MUI_LIP_ALLOW_SWITCH_SECTION,
                                  LipLanguages,
                                  ARRAYSIZE(LipLanguages),
                                  szInffile)) 
    {
        g_bLipAllowSwitch = TRUE;
    }

    return(iLanguages);
}


BOOL CheckLanguageDirectoryExist(LPTSTR Languages)
{
    TCHAR szBuffer[BUFFER_SIZE];
    TCHAR szSource[ MAX_PATH ];
    TCHAR szTemp  [ MAX_PATH ]; 
    LPTSTR lpCur,lpBuffer;
    HANDLE          hFile;
    WIN32_FIND_DATA FindFileData;
    int nSize;
    HRESULT hresult;

    if (!Languages)
    {
        return FALSE;
    }             
    memcpy(szBuffer,Languages,BUFFER_SIZE);        
    lpCur=Languages;         
    lpBuffer=szBuffer;
    nSize=BUFFER_SIZE;
    while (*lpBuffer)
    {          
        GetPrivateProfileString( MUI_LANGUAGES_SECTION, 
                            lpBuffer, 
                            TEXT("DEFAULT"),
                            szSource, 
                            (sizeof(szSource)/sizeof(TCHAR)),
                            g_szMUIInfoFilePath );
        
#ifndef MUI_MAGIC  
        //*STRSAFE*         _tcscpy(szTemp,g_szMUISetupFolder);
        hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp), g_szMUISetupFolder);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,szSource);
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), szSource);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,TEXT("\\"));
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), TEXT("\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,g_szPlatformPath); // i386 or alpha
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), g_szPlatformPath);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,TEXT("*.*"));
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), TEXT("*.*"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        hFile = FindFirstFile( szTemp, &FindFileData );
        
        if (INVALID_HANDLE_VALUE != hFile )
        {
           if (FindNextFile( hFile, &FindFileData ) && 
               FindNextFile( hFile, &FindFileData )  )
           {
              //*STRSAFE*               _tcscpy(lpCur,lpBuffer);
              hresult = StringCchCopy(lpCur , nSize, lpBuffer);
              if (!SUCCEEDED(hresult))
              {
                 FindClose(hFile);
                 return FALSE;
              }
              lpCur+=(_tcslen(lpBuffer)+1);
              nSize -= (_tcslen(lpBuffer)+1);
           }
           FindClose(hFile);
        }   
#else
        // kenhsu - here, we check for the specific msi file that is required for installation of the language, e.g. for jpn, it's 0411.msi
        // the file is located at CDRoot\jpn.mui\platform\msi
        //*STRSAFE*         _tcscpy(szTemp,g_szMUISetupFolder);
        hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp), g_szMUISetupFolder);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,lpBuffer);                            
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), lpBuffer);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,TEXT(".msi"));
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), TEXT(".msi"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        hFile = FindFirstFile( szTemp, &FindFileData );

        if (INVALID_HANDLE_VALUE != hFile )
        {
           //*STRSAFE*            _tcscpy(lpCur,lpBuffer);
           hresult = StringCchCopy(lpCur , nSize, lpBuffer);
           if (!SUCCEEDED(hresult))
           {
              FindClose(hFile);
              return FALSE;
           }
           lpCur+=(_tcslen(lpBuffer)+1);
           nSize -= (_tcslen(lpBuffer)+1);           
           FindClose(hFile);
        }


        
#endif        
        while (*lpBuffer++)  
        {               
        }
    }
    *lpCur=TEXT('\0');

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  checkversion
//
//  Checks the NT version and build, and system ui language
//
////////////////////////////////////////////////////////////////////////////////////

BOOL checkversion(BOOL bMatchBuildNumber)
{
    TCHAR               buffer[20];
    TCHAR               build[20];
    OSVERSIONINFO       verinfo;
    LANGID              rcLang;
    TCHAR               lpMessage[BUFFER_SIZE];
    HRESULT             hresult;
    DWORD               dwDummy = 0;
    DWORD               dwBufSize = 0;
    UINT                uiLen = 0;
    BYTE                *pbBuffer = NULL;
    VS_FIXEDFILEINFO    *pvsFileInfo;
    BOOL                bResult = TRUE;

    //
    // get the os version structure
    //
    verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);    
    if (!GetVersionEx( &verinfo))
    {
        bResult = FALSE;
        goto Exit;
    }

    // 
    // get the file version structure
    //
    if (!FileExists(g_szMuisetupPath))
    {
        bResult = FALSE;
        goto Exit;
    }
    
    dwBufSize = GetFileVersionInfoSize(g_szMuisetupPath, &dwDummy);
    if (dwBufSize > 0)
    {
        //
        // allocate enough buffer to store the file version info
        //
        pbBuffer = (BYTE*) LocalAlloc(LMEM_FIXED, dwBufSize+1);
        if (NULL == pbBuffer)
        {
            bResult = FALSE;
            goto Exit;
        }
        else
        {
            //
            // Get the file version info
            //
            if (!GetFileVersionInfo(g_szMuisetupPath, dwDummy, dwBufSize, pbBuffer))
            {
                bResult = FALSE;
                goto Exit;
            }
            else
            {
                //
                // get the version from the file version info using VerQueryValue
                //
                if (!VerQueryValue(pbBuffer, TEXT("\\"), (LPVOID *) &pvsFileInfo, &uiLen))
                {
                    bResult = FALSE;
                    goto Exit;
                }            
            }
        }        
    }
    else
    {
        bResult = FALSE;
        goto Exit;
    }
    
    //
    // make sure muisetup.exe file version matches os version
    //
    if ((verinfo.dwMajorVersion != HIWORD(pvsFileInfo->dwFileVersionMS)) || (verinfo.dwMinorVersion != LOWORD(pvsFileInfo->dwFileVersionMS)))
    {
        debug("DBG: muisetup.exe file version does not match the OS version.\r\n");
        bResult = FALSE;
        goto Exit;
    }

    rcLang = (LANGID) gpfnGetSystemDefaultUILanguage();

    //
    // need to convert decimal to hex, LANGID to chr.
    //
    hresult = StringCchPrintf(buffer, ARRAYSIZE(buffer),TEXT("00000%X") , rcLang);
    if (!SUCCEEDED(hresult))
    {
        bResult = FALSE;
        goto Exit;
    }
    if (_tcscmp(buffer, TEXT("00000409")))
    {
        bResult = FALSE;
        goto Exit;
    }

    // 
    // also make sure version build number matches between os and muisetup
    //
    if (bMatchBuildNumber)
    {
        if (LOWORD(verinfo.dwBuildNumber) == HIWORD(pvsFileInfo->dwFileVersionLS))
        {
            bResult = TRUE;
        }
        else
        {
            bResult = FALSE;
        }
    }

Exit:
    if (pbBuffer)
    {
        LocalFree(pbBuffer);
    }
    return bResult;            
}


////////////////////////////////////////////////////////////////////////////////////
//
//  File Exists
//
//  Returns TRUE if the file exists, FALSE if it does not.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL FileExists(LPTSTR szFile)
{
    HANDLE  hFile;
    WIN32_FIND_DATA FindFileData;

    if (!szFile)
    {
        return FALSE;
    }
    hFile = FindFirstFile( szFile, &FindFileData );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    FindClose( hFile );

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  EnumDirectories
//
//  Enumerates the directories listed in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL EnumDirectories()
{
    DWORD  dwErr;
    LPTSTR Directories, Directory, TempDir;
    TCHAR  lpError[BUFFER_SIZE];
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[3];
    int    Dirnumber = 0;
    HRESULT  hresult;

    Directories = (LPTSTR) LocalAlloc( 0, (DIRNUMBER * MAX_PATH * sizeof(TCHAR)) );
    if (Directories == NULL)
    {
         ExitFromOutOfMemory();
    }
    TempDir = (LPTSTR) LocalAlloc( 0, (MAX_PATH * sizeof(TCHAR)) );
    if (TempDir == NULL)
    {
        LocalFree(Directories);
        ExitFromOutOfMemory();
    }
    else
    {
          *Directories = TEXT('\0');
    }
    //
    // Copy all key names into Directories.
    //
    if (!GetPrivateProfileString( TEXT("Directories"), 
                                  NULL, 
                                  TEXT("DEFAULT"),
                                  Directories, 
                                  (DIRNUMBER * MAX_PATH),
                                  g_szMUIInfoFilePath  ))
    {
        //
        //      "LOG: Unable to read - rc == %1"
        //
        lppArgs[0] = (LONG_PTR)GetLastError();
        lppArgs[1] = (LONG_PTR)g_szMUIInfoFilePath;        
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
        LocalFree( TempDir );
        LocalFree( Directories );
        return FALSE;
    }

    Directory = Directories;
    
    //
    // In case we don't find anything, we go to the fallback directory
    //
    //*STRSAFE*     _tcscpy(DirNames[0], TEXT("FALLBACK"));
    hresult = StringCchCopy(DirNames[0] , MAX_PATH,  TEXT("FALLBACK"));
    if (!SUCCEEDED(hresult))
    {
       LocalFree( TempDir );
       LocalFree( Directories );
       return FALSE;
    }
        
    while (*Directory)
    {
        if (!GetPrivateProfileString( TEXT("Directories"), 
                                      Directory, 
                                      TEXT("\\DEFAULT"),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {
            //
            //      "LOG: Unable to read - rc == %1"
            //
            lppArgs[0] = (LONG_PTR)GetLastError();
            lppArgs[1] = (LONG_PTR)g_szMUIInfoFilePath;            
            LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                        
        //*STRSAFE*         _tcscpy(DirNames[++Dirnumber], TempDir);
        hresult = StringCchCopy(DirNames[++Dirnumber] , MAX_PATH,  TempDir);
        if (!SUCCEEDED(hresult))
        {
           LocalFree( TempDir );
           LocalFree( Directories );
           return FALSE;
        }

        // Move to the beginning of next key name.
        while (*Directory++)
        {
        }
    }

    LocalFree( TempDir );
    LocalFree( Directories );
        
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  EnumFileRename
//
//  Enumerates the [File_Layout] section  listed in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL EnumFileRename()
{
    DWORD  dwErr;
    LPTSTR Directories, Directory, TempDir,lpszNext;    
    TCHAR  szPlatform[MAX_PATH+1],szTargetPlatform[MAX_PATH+1];
    LONG_PTR lppArgs[1];
    int    Dirnumber = 0,nIdx=0;
    HRESULT hresult;


    Directories = (LPTSTR) LocalAlloc( 0, (FILERENAMENUMBER * (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!Directories)
    {
       return FALSE;
    }  
    TempDir = (LPTSTR) LocalAlloc( 0, ( (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!TempDir)
    {
       LocalFree(Directories);
       return FALSE;
    }

    if (gbIsAdvanceServer)
    {
       //*STRSAFE*        _tcscpy(szTargetPlatform,PLATFORMNAME_AS);
       hresult = StringCchCopy(szTargetPlatform , ARRAYSIZE(szTargetPlatform), PLATFORMNAME_AS);
       if (!SUCCEEDED(hresult))
       {
          LocalFree( TempDir );
          LocalFree( Directories );
          return FALSE;
       }
    }
    else if (gbIsServer)
    {
      //*STRSAFE*       _tcscpy(szTargetPlatform,PLATFORMNAME_SRV);
      hresult = StringCchCopy(szTargetPlatform , ARRAYSIZE(szTargetPlatform), PLATFORMNAME_SRV);
      if (!SUCCEEDED(hresult))
      {
         LocalFree( TempDir );
         LocalFree( Directories );
         return FALSE;
      }
    }
    else if (gbIsWorkStation)
    {
       //*STRSAFE*        _tcscpy(szTargetPlatform,PLATFORMNAME_PRO);
       hresult = StringCchCopy(szTargetPlatform , ARRAYSIZE(szTargetPlatform), PLATFORMNAME_PRO);
       if (!SUCCEEDED(hresult))
       {
          LocalFree( TempDir );
          LocalFree( Directories );
          return FALSE;
       }
    }
    else if ( gbIsDataCenter)
    {
       //*STRSAFE*        _tcscpy(szTargetPlatform,PLATFORMNAME_DTC);
       hresult = StringCchCopy(szTargetPlatform , ARRAYSIZE(szTargetPlatform), PLATFORMNAME_DTC);
       if (!SUCCEEDED(hresult))
       {
          LocalFree( TempDir );
          LocalFree( Directories );
          return FALSE;
       }
    }
    else
    {
      //*STRSAFE*       _tcscpy(szTargetPlatform,PLATFORMNAME_PRO);
      hresult = StringCchCopy(szTargetPlatform , ARRAYSIZE(szTargetPlatform), PLATFORMNAME_PRO);
      if (!SUCCEEDED(hresult))
      {
         LocalFree( TempDir );
         LocalFree( Directories );
         return FALSE;
      }
    }



        
    *Directories = TEXT('\0');
    if (!GetPrivateProfileString( MUI_FILELAYOUT_SECTION, 
                                  NULL, 
                                  TEXT(""),
                                  Directories, 
                                  (FILERENAMENUMBER * MAX_PATH),
                                  g_szMUIInfoFilePath  ))
    {
        LocalFree( TempDir );
        LocalFree( Directories );
        return FALSE;
    }

    Directory = Directories;

    //
    // Calculate # of entries in this section
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_FILELAYOUT_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                      
      //
      // Check if platform ID field in this entry
      // 
      // Source_file_name=Destination_file_name,P,S,A
      //
        lpszNext=TempDir;
        while ( (lpszNext=_tcschr(lpszNext,TEXT(','))) )
        {
            lpszNext++;
            nIdx=0;
            szPlatform[0]=TEXT('\0');

            while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')))
            {
                if (*lpszNext != TEXT(' '))
                {
                   szPlatform[nIdx++]=*lpszNext;
                }
                lpszNext++;
            }
            szPlatform[nIdx]=TEXT('\0');

            if (!_tcsicmp(szPlatform,szTargetPlatform))
            {
              Dirnumber++;
              break;
            }
         
         }
         while (*Directory++)
         {
         }
    }
    //
    // Allocte Space for Rename Table
    //
    g_pFileRenameTable=(PFILERENAME_TABLE)LocalAlloc( 0, Dirnumber * sizeof(FILERENAME_TABLE) );
    if (!g_pFileRenameTable)
    {
       LocalFree( TempDir );
       LocalFree( Directories );
       return FALSE;

    }
    g_nFileRename=0;
    Directory = Directories;
    //
    // Create Reanme Table
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_FILELAYOUT_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree(g_pFileRenameTable);
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                      
        //
        // Check if platform ID field in this entry
        // 
        // Source_file_name=Destination_file_name,P,S,A
        //
        lpszNext=TempDir;
        while ( lpszNext =_tcschr(lpszNext,TEXT(',')))
        {
            lpszNext++;
            nIdx=0;
            szPlatform[0]=TEXT('\0');

            while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')))
            {
                if (*lpszNext != TEXT(' '))
                {
                   szPlatform[nIdx++]=*lpszNext;
                }
                lpszNext++;
            }
            szPlatform[nIdx]=TEXT('\0');
            if (!_tcsicmp(szPlatform,szTargetPlatform) )
            {
              //
              // Insert this entry into rename table pointed by g_pFileRenameTable
              //
              //*STRSAFE*               _tcscpy(g_pFileRenameTable[g_nFileRename].szSource,Directory);
              hresult = StringCchCopy(g_pFileRenameTable[g_nFileRename].szSource , MAX_PATH+1, Directory);
              if (!SUCCEEDED(hresult))
              {
                 LocalFree( TempDir );
                 LocalFree( Directories );
                 return FALSE;
              }
              lpszNext=TempDir;
              nIdx=0;
              g_pFileRenameTable[g_nFileRename].szDest[0]=TEXT('\0');
              while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')) && (*lpszNext != TEXT(' ')) )
              {
                  g_pFileRenameTable[g_nFileRename].szDest[nIdx++]=*lpszNext;
                  lpszNext++;
              }
              g_pFileRenameTable[g_nFileRename].szDest[nIdx]=TEXT('\0');
              g_nFileRename++;
              break;
            }
         
         }
         while (*Directory++)
         {
         }
    }
    LocalFree( TempDir );
    LocalFree( Directories );
        
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  EnumTypeNotFallback
//
//  Enumerates the [FileType_NoFallback] section  listed in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////

BOOL EnumTypeNotFallback()
{
    
    LPTSTR Directories, Directory, TempDir,lpszNext;
    int    Dirnumber = 0,nIdx=0;


    Directories = (LPTSTR) LocalAlloc( 0, (NOTFALLBACKNUMBER  * (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!Directories)
    {
       return FALSE;
    }  
    TempDir = (LPTSTR) LocalAlloc( 0, ( (MAX_PATH+1) * sizeof(TCHAR)) );
    if (!TempDir)
    {
       LocalFree(Directories);
       return FALSE;
    }
        
    *Directories = TEXT('\0');
    if (!GetPrivateProfileString( MUI_NOFALLBACK_SECTION, 
                                  NULL, 
                                  TEXT(""),
                                  Directories, 
                                  (NOTFALLBACKNUMBER * MAX_PATH),
                                  g_szMUIInfoFilePath  ))
    {
        LocalFree( TempDir );
        LocalFree( Directories );
        return FALSE;
    }

    Directory = Directories;

    //
    // Calculate # of entries in this section
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_NOFALLBACK_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
                      
        Dirnumber++;
        while (*Directory++)
        {
        }
    }
    //
    // Allocte Space for 
    //

    g_pNotFallBackTable=(PTYPENOTFALLBACK_TABLE)LocalAlloc( 0, Dirnumber * sizeof(TYPENOTFALLBACK_TABLE) );

    if (!g_pNotFallBackTable)
    {
       LocalFree( TempDir );
       LocalFree( Directories );
       return FALSE;

    }
    g_nNotFallBack=0;
    Directory = Directories;
    //
    // Create NoFallBack Table
    //
    while (*Directory)
    {
        if (!GetPrivateProfileString( MUI_NOFALLBACK_SECTION, 
                                      Directory, 
                                      TEXT(""),
                                      TempDir, 
                                      MAX_PATH,
                                      g_szMUIInfoFilePath))
        {   
            LocalFree(g_pNotFallBackTable);
            LocalFree( TempDir );
            LocalFree( Directories );
            return FALSE;
        }
        //
        // 
        //
        lpszNext=TempDir;
        nIdx=0;
        g_pNotFallBackTable[g_nNotFallBack].szSource[0]=TEXT('\0');
        while ( (*lpszNext != TEXT('\0')) && (*lpszNext != TEXT(',')) && (*lpszNext != TEXT(' ')) )
        {
            g_pNotFallBackTable[g_nNotFallBack].szSource[nIdx++]=*lpszNext;
            lpszNext++;
        }
        g_pNotFallBackTable[g_nNotFallBack].szSource[nIdx]=TEXT('\0');
        g_nNotFallBack++;
        while (*Directory++)
        {
        }
    }
    LocalFree( TempDir );
    LocalFree( Directories );
        
    return TRUE;
}

//
// Check if a given file should be renamed by searching Rename Table
//
BOOL IsFileBeRenamed(LPTSTR lpszSrc,LPTSTR lpszDest)
{
    int   nIdx;
    BOOL  bResult=FALSE;   
    HRESULT hresult;

    if (!lpszSrc)
        return bResult;

    for (nIdx=0; nIdx < g_nFileRename; nIdx++)
    {
        LPTSTR pMUI = StrStrI(lpszSrc,g_pFileRenameTable[nIdx].szSource);

        if (pMUI == lpszSrc)
        {
            pMUI += lstrlen(g_pFileRenameTable[nIdx].szSource);

           //*PREFAST * if (!*pMUI || !lstrcmpi(pMUI, TEXT(".MUI")))
           if (! *pMUI || (CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,pMUI,-1,TEXT(".MUI"),-1) == 2) ) 
            {    
                //*STRSAFE*                 lstrcpy(lpszDest,g_pFileRenameTable[nIdx].szDest);
                hresult = StringCchCopy(lpszDest , MAX_PATH, g_pFileRenameTable[nIdx].szDest);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                //*STRSAFE*                 lstrcat(lpszDest, pMUI);
                hresult = StringCchCat(lpszDest , MAX_PATH,  pMUI);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                bResult=TRUE;
                break;
            }
        }
    }
    return bResult;
}
//
// Check if a given file matches szDest field of rename table.
// If it the case then we won't install this file
//
BOOL IsFileInRenameTable(LPTSTR lpszSrc)
{
    int   nIdx;
    BOOL  bResult=FALSE;   

    if (!lpszSrc)
        return bResult;

    for (nIdx=0; nIdx < g_nFileRename; nIdx++)
    {
        LPTSTR pMUI = StrStrI(lpszSrc,g_pFileRenameTable[nIdx].szDest);

        if (pMUI == lpszSrc)
        {
            pMUI += lstrlen(g_pFileRenameTable[nIdx].szDest);

            //*PREFAST* if (!*pMUI || !lstrcmpi(pMUI, TEXT(".MUI")))
           if (! *pMUI || (CompareString(LOCALE_INVARIANT,NORM_IGNORECASE,pMUI,-1,TEXT(".MUI"),-1) == 2) )            
            {                   
                bResult=TRUE;
                break;
            }
        }
    }
    return bResult;
}
//
// Check if the file type of a given file belongs to the category "Do not Fallback"
//
BOOL IsDoNotFallBack(LPTSTR lpszFileName)
{
   BOOL bResult = FALSE;
   int  iLen,nIdx;

   if (!lpszFileName)
   {
      return bResult;
   }  
   iLen = _tcslen(lpszFileName);

   if (iLen > 4)
   {
      for (nIdx=0; nIdx < g_nNotFallBack ; nIdx++)
      {
         if (!_tcsicmp(&lpszFileName[iLen - 4],g_pNotFallBackTable[nIdx].szSource))
         {
            bResult = TRUE;
            break;
         }

      }
   }

   return bResult;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CheckForExpandedFile
//
//  Retreives the original filename, in case the file is compressed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CheckForExpandedFile( 
    PTSTR pszPathName,
    PTSTR pszFileName,
    PTSTR pszOriginalFileName,
    PDIAMOND_PACKET pDiamond)
{
    TCHAR szCompressedFileName[ MAX_PATH ];
    TCHAR szOut[ MAX_PATH ];
    PTSTR pszTemp, pszDelimiter;
    BOOL  bIsCompressed;
    int   iLen=0;
    HRESULT hresult;

    if ( (!pszPathName) || (!pszFileName) || (!pszOriginalFileName) || (!pDiamond))
    {
       return FALSE;
    }
    
    // Initializations
    bIsCompressed = FALSE;
    
    szOut[ 0 ] = szCompressedFileName[ 0 ] = TEXT('\0');


    //
    // Get the real name
    //
    //*STRSAFE*     _tcscpy(szCompressedFileName, pszPathName);
    hresult = StringCchCopy(szCompressedFileName , ARRAYSIZE(szCompressedFileName),  pszPathName);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     _tcscat(szCompressedFileName, pszFileName);
    hresult = StringCchCat(szCompressedFileName , ARRAYSIZE(szCompressedFileName),  pszFileName);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    if (Muisetup_IsDiamondFile( szCompressedFileName,
                                pszOriginalFileName,
                                MAX_PATH,
                                pDiamond ))
    {
        return TRUE;
    }

    if (GetExpandedName(szCompressedFileName, szOut) == TRUE)
    {
        pszDelimiter = pszTemp = szOut;

        while (*pszTemp)
        {
            if ((*pszTemp == TEXT('\\')) ||
                (*pszTemp == TEXT('/')))
            {
                pszDelimiter = pszTemp;
            }
            pszTemp++;
        }

        if (*pszDelimiter == TEXT('\\') ||
            *pszDelimiter == TEXT('/'))
        {
            pszDelimiter++;
        }

        if (_tcsicmp(pszDelimiter, pszFileName) != 0)
        {
            bIsCompressed = TRUE;
            //*STRSAFE*             _tcscpy(pszOriginalFileName, pszDelimiter);
            hresult = StringCchCopy(pszOriginalFileName , MAX_PATH,  pszDelimiter);
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
        }
    }

    if (!bIsCompressed)
    {
       //*STRSAFE*        _tcscpy(pszOriginalFileName, pszFileName);
       hresult = StringCchCopy(pszOriginalFileName , MAX_PATH,  pszFileName);
       if (!SUCCEEDED(hresult))
       {
          return FALSE;
       }
       //
       // If muisetup is launched through [GUIRunOnce] command line mode,
       // W2K uncompresses all mui files and leave the name as xxxxxx.xxx.mu_
       // We should cover this situation by changing the name to xxxxxx.xxx.mui
       iLen = _tcslen(pszOriginalFileName);
       if (iLen > 4)
       {
          if (_tcsicmp(&pszOriginalFileName[iLen - 4], TEXT(".mu_")) == 0)
          {
             pszOriginalFileName[iLen-1]=TEXT('i');
          }
       }
    }
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CopyFile
//
//  Copy file, and expand it if necessary.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CopyFile(
    PCTSTR pszCopyFrom,
    PTSTR  pszCopyTo,
    PDIAMOND_PACKET pDiamond,
    PTSTR pOriginalName)
{
    OFSTRUCT ofs;
    INT      hfFrom, hfTo;
    BOOL     bRet = FALSE;
    HRESULT hresult;
    
    if ( (!pszCopyFrom) || (!pszCopyTo) || (!pDiamond) )
    {
        return FALSE;
    }
  
    //
    // Check if diamond can handle it    
    //
    bRet = Muisetup_CopyDiamondFile( pDiamond,
                                 pszCopyTo );    

    if (bRet)
    {
        //
        // Diamond copy won't rename file for us
        //
        if (pOriginalName)
        {
            WCHAR wszPath[MAX_PATH];

            //
            // Diamond is ANSI
            //
            if (MultiByteToWideChar(1252, 0, pDiamond->szDestFilePath, -1, wszPath, ARRAYSIZE(wszPath)))
            {
                //*STRSAFE* StrCat(wszPath, pOriginalName);
                 hresult = StringCchCat(wszPath , ARRAYSIZE(wszPath),  pOriginalName);
                 if (!SUCCEEDED(hresult))
                 {
                     return FALSE;
                 }                
                MoveFileEx(wszPath,pszCopyTo,MOVEFILE_REPLACE_EXISTING);
            }
        }
        return bRet;
    }

    hfFrom = LZOpenFile( (PTSTR) pszCopyFrom,
                         &ofs,
                         OF_READ );
    if (hfFrom < 0)
    {
        return FALSE;
    }

    hfTo = LZOpenFile( (PTSTR) pszCopyTo,
                       &ofs,
                       OF_CREATE | OF_WRITE);
    if (hfTo < 0)
    {
        LZClose(hfFrom);
        return FALSE;
    }

    bRet = TRUE;
    if (LZCopy(hfFrom, hfTo) < 0)
    {
        bRet = FALSE;
    }

    LZClose(hfFrom);
    LZClose(hfTo);

    return bRet;
}


////////////////////////////////////////////////////////////////////////////////////
//
// InstallComponentsMUIFiles
//
// Parameters:
//      pszLangSourceDir The sub-directory name for a specific lanuage in the MUI CD-ROM.  
//          E.g. "jpn.MUI"
//      pszLanguage     The LCID for the specific language.  E.g. "0404".
//      isInstall   TRUE if you are going to install the MUI files for the component.  FALSE 
//          if you are going to uninstall.
//      [OUT] pbCanceled    TRUE if the operation is canceled.
//      [OUT] pbError       TURE if error happens.
//
//  Return:
//      TRUE if success.  Otherwise FALSE.
//
//  Note:
//      For the language resources stored in pszLangSourceDir, this function will enumerate 
//      the compoents listed in the [Components] 
//      (the real section is put in MUI_COMPONENTS_SECTION) section, and execute the INF file 
//      listed in every entry in 
//      the [Components] section.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InstallComponentsMUIFiles(PTSTR pszLangSourceDir, PTSTR pszLanguage, BOOL isInstall)
{
    BOOL result = TRUE;
    TCHAR szComponentName[BUFFER_SIZE];
    TCHAR CompDir[BUFFER_SIZE];
    TCHAR CompINFFile[BUFFER_SIZE];
    TCHAR CompInstallSection[BUFFER_SIZE];
    TCHAR CompUninstallSection[BUFFER_SIZE];

    TCHAR szCompInfFullPath[MAX_PATH];
    
    LONG_PTR lppArgs[2];
    INFCONTEXT InfContext;
    HRESULT hresult;

    TCHAR szBuffer[BUFFER_SIZE];
    if ((TRUE == isInstall) && (!pszLangSourceDir))
    {
        return FALSE;
    }

    HINF hInf = SetupOpenInfFile(g_szMUIInfoFilePath, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
    {
        //*STRSAFE*         _stprintf(szBuffer, TEXT("%d"), GetLastError());    
        hresult = StringCchPrintf(szBuffer , ARRAYSIZE(szBuffer),  TEXT("%d"), GetLastError());
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        lppArgs[0] = (LONG_PTR)szBuffer;
        lppArgs[1] = (LONG_PTR)g_szMUIInfoFilePath;        
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
        return (FALSE);
    }    

    //
    // Get the first comopnent to be installed.
    //
    if (SetupFindFirstLine(hInf, MUI_COMPONENTS_SECTION, NULL, &InfContext))
    {
        do 
        {
            if (!SetupGetStringField(&InfContext, 0, szComponentName, ARRAYSIZE(szComponentName), NULL))
            {
                lppArgs[0]=(LONG_PTR)szComponentName;                
                LogFormattedMessage(ghInstance, IDS_COMP_MISSING_NAME_L, lppArgs);
                continue;
            }
            if (!SetupGetStringField(&InfContext, 1, CompDir, ARRAYSIZE(CompDir), NULL))
            {                
                //
                //  "LOG: MUI files for component %1 was not installed because of missing component direcotry.\n"
                //
                lppArgs[0]=(LONG_PTR)szComponentName;                
                LogFormattedMessage(ghInstance, IDS_COMP_MISSING_DIR_L, lppArgs);
                continue;        
            }
            if (!SetupGetStringField(&InfContext, 2, CompINFFile, ARRAYSIZE(CompINFFile), NULL))
            {
                //
                //  "LOG: MUI files for component %1 were not installed because of missing component INF filename.\n"
                //
                lppArgs[0]=(LONG_PTR)szComponentName;                
                LogFormattedMessage(ghInstance, IDS_COMP_MISSING_INF_L, lppArgs);
                continue;        
            }
            if (!SetupGetStringField(&InfContext, 3, CompInstallSection, ARRAYSIZE(CompInstallSection), NULL))
            {
                //*STRSAFE*                 _tcscpy(CompInstallSection, DEFAULT_INSTALL_SECTION);
                hresult = StringCchCopy(CompInstallSection , ARRAYSIZE(CompInstallSection),  DEFAULT_INSTALL_SECTION);
                if (!SUCCEEDED(hresult))
                {
                   SetupCloseInfFile(hInf);
                   return FALSE;
                }
            }
            if (!SetupGetStringField(&InfContext, 4, CompUninstallSection, ARRAYSIZE(CompUninstallSection), NULL))
            {
                //*STRSAFE*                 _tcscpy(CompUninstallSection, DEFAULT_UNINSTALL_SECTION);
                hresult = StringCchCopy(CompUninstallSection , ARRAYSIZE(CompUninstallSection),  DEFAULT_UNINSTALL_SECTION);
                if (!SUCCEEDED(hresult))
                {
                   SetupCloseInfFile(hInf);
                   return FALSE;
                }
            }

            //
            // Establish the correct path for component INF file.
            //    
            if (isInstall)
            {
                //
                // For installation, we execute the INFs in the language directory of the CD-ROM (e.g.
                // g:\jpn.mui\i386\ie5\ie5ui.inf
                //
                //*STRSAFE*     _stprintf(szCompInfFullPath, TEXT("%s%s\\%s%s\\%s"),  g_szMUISetupFolder,  pszLangSourceDir,  g_szPlatformPath, CompDir, CompINFFile);
                hresult = StringCchPrintf(szCompInfFullPath, ARRAYSIZE(szCompInfFullPath),  TEXT("%s%s\\%s%s\\%s"),  g_szMUISetupFolder,  pszLangSourceDir,  g_szPlatformPath, CompDir, CompINFFile);
                if (!SUCCEEDED(hresult))
                {
                   SetupCloseInfFile(hInf);
                   return FALSE;
                }
                if (!ExecuteComponentINF(NULL, szComponentName, szCompInfFullPath, CompInstallSection, TRUE))
                {    
                    if (!g_bNoUI)
                    {
                        if (DoMessageBox(NULL, IDS_CANCEL_INSTALLATION, IDS_MAIN_TITLE, MB_YESNO) == IDNO)
                        {
                            result = FALSE;
                            break;
                        }
                    }
                }
            } else
            {
                //
                // For uninstallation, we execute the INFs in the \winnt\mui\fallback directory to remove component files.
                //
                //*STRSAFE*                 _stprintf(szCompInfFullPath, TEXT("%s%s\\%s\\%s"), g_szWinDir, FALLBACKDIR, pszLanguage, CompINFFile) ;
                hresult = StringCchPrintf(szCompInfFullPath , ARRAYSIZE(szCompInfFullPath),  TEXT("%s%s\\%s\\%s"), g_szWinDir, FALLBACKDIR, pszLanguage, CompINFFile);
                if (!SUCCEEDED(hresult))
                {
                    SetupCloseInfFile(hInf);
                   return FALSE;
                }
                if (!ExecuteComponentINF(NULL, szComponentName, szCompInfFullPath, CompUninstallSection, FALSE) && result)	
                {
                    result = FALSE;
                }
            }
            
            //
            // Install the next component.
            //
        } while (SetupFindNextLine(&InfContext, &InfContext));
    }

    SetupCloseInfFile(hInf);

    return (result);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  CopyFiles
//
//  Copies the specified files to the appropriate directories
//
//  Parameters:
//      [in] languages: contain the hex string for the languages to be installed. There could be more than one language.
//      [out] lpbCopyCancelled: if the copy operation has been cancelled.
//
//  Notes:
//      This function first look at the [Languages] section in the INF file to find out the
//      source directory (in the CD-ROM) for the language to be installed.
//      From that directory, do:
//          1. install the MUI files for the components listed in the [Components] section, 
//          2. Enumarate every file in that direcotry to:
//              Check if the same file exists in directories in DirNames.  If yes, this means we have to copy
//              the mui file to that particular direcotry.  Otherwise, copy the file to the FALLBACK directory.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CopyFiles(HWND hWnd, LPTSTR Languages)
{

    LPTSTR          Language;
    HANDLE          hFile;
    HWND            hStatic;
    TCHAR           lpStatus[ BUFFER_SIZE ];
    TCHAR           lpLangText[ BUFFER_SIZE ];
    TCHAR           szSource[ MAX_PATH ] = {0};   // The source directory for a particular language
    TCHAR           szTarget[ MAX_PATH ];
    TCHAR           szTemp[ MAX_PATH ];
    TCHAR           szOriginalFileName[ MAX_PATH ];
    TCHAR           szFileNameBeforeRenamed[ MAX_PATH], szFileNameCopied[MAX_PATH];
    TCHAR           szFileRenamed[MAX_PATH];
    DIAMOND_PACKET  diamond;
    BOOL            CreateFailure = FALSE;
    BOOL            CopyOK=TRUE;
    BOOL            bFileWithNoMuiExt=FALSE;
    BOOL            FileCopied = FALSE;
    BOOL            bSpecialDirectory=FALSE;
    BOOL            bRename=FALSE;
    WIN32_FIND_DATA FindFileData;   
    int             FoundMore = 1;
    int             Dirnum = 0;
    int             iLen;
    int             NotDeleted = 0;
    int             i;
    
    TCHAR           dir[_MAX_DIR];
    TCHAR           fname[_MAX_FNAME];
    TCHAR           ext[_MAX_EXT];
    LONG_PTR        lppArgs[3];

    HRESULT hresult;

    MSG             msg;

    if (!Languages)
    {
        return FALSE;
    }
    //
    // we need to try to copy for each language to be installed the file
    //      
    Language = Languages;

#ifndef MUI_MAGIC
    if (!g_bNoUI)
    {    
        hStatic = GetDlgItem(ghProgDialog, IDC_STATUS);
    }
    while (*Language)
    {
        //
        //  Find the directory in which the sourcefile for given language should be
        //
        GetPrivateProfileString( MUI_LANGUAGES_SECTION, 
                                 Language, 
                                 TEXT("DEFAULT"),
                                 szSource, 
                                 (sizeof(szSource)/sizeof(TCHAR)),
                                 g_szMUIInfoFilePath );

        //
        // Install Fusion MUI assemblies
        //
        if (gpfnSxsInstallW)
        {
            TCHAR pszLogFile[BUFFER_SIZE]; 
            if ( !DeleteSideBySideMUIAssemblyIfExisted(Language, pszLogFile))
            {
                TCHAR errInfo[BUFFER_SIZE];
                //*STRSAFE*                 swprintf(errInfo, TEXT("Uninstall existing assemblies based on %s before new installation failed\n"), pszLogFile);
                hresult = StringCchPrintf(errInfo , ARRAYSIZE(errInfo),  TEXT("Uninstall existing assemblies based on %s before new installation failed\n"), pszLogFile);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                OutputDebugString(errInfo);
            }
            if (GetFileAttributes(pszLogFile) != 0xFFFFFFFF) 
            {
                DeleteFile(pszLogFile); // no use anyway
            }
            TCHAR szFusionAssemblyPath[BUFFER_SIZE];
            
            PathCombine(szFusionAssemblyPath, g_szMUISetupFolder, szSource);
            PathAppend(szFusionAssemblyPath, g_szPlatformPath);
            PathAppend(szFusionAssemblyPath, TEXT("ASMS"));

            SXS_INSTALLW SxsInstallInfo = {sizeof(SxsInstallInfo)};
            SXS_INSTALL_REFERENCEW Reference = {sizeof(Reference)};
            
            Reference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OPAQUESTRING;
            Reference.lpIdentifier = MUISETUP_ASSEMBLY_INSTALLATION_REFERENCE_IDENTIFIER;    
    
            SxsInstallInfo.dwFlags = SXS_INSTALL_FLAG_REPLACE_EXISTING |        
                SXS_INSTALL_FLAG_REFERENCE_VALID |
                SXS_INSTALL_FLAG_CODEBASE_URL_VALID |
                SXS_INSTALL_FLAG_LOG_FILE_NAME_VALID | 
                SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE;
            SxsInstallInfo.lpReference = &Reference;
            SxsInstallInfo.lpLogFileName = pszLogFile;            
            SxsInstallInfo.lpManifestPath = szFusionAssemblyPath;
            SxsInstallInfo.lpCodebaseURL = SxsInstallInfo.lpManifestPath;

            if ( !gpfnSxsInstallW(&SxsInstallInfo))
            {
                TCHAR errInfo[BUFFER_SIZE];
                //*STRSAFE*                 swprintf(errInfo, TEXT("Assembly Installation of %s failed. Please refer Eventlog for more information"), szFusionAssemblyPath);
                hresult = StringCchPrintf(errInfo , ARRAYSIZE(errInfo),  TEXT("Assembly Installation of %s failed. Please refer Eventlog for more information"), szFusionAssemblyPath);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                OutputDebugString(errInfo);
            }
        }

        GetLanguageGroupDisplayName((LANGID)_tcstol(Language, NULL, 16), lpLangText, ARRAYSIZE(lpLangText)-1);

        lppArgs[0] = (LONG_PTR)lpLangText;
        
        //
        // Try installing component satellite DLLs
        // 
        if (!g_bNoUI)
        {        
            FormatStringFromResource(lpStatus, sizeof(lpStatus)/sizeof(TCHAR), ghInstance, IDS_INSTALLING_COMP_MUI, lppArgs);
            SetWindowText(hStatic, lpStatus);
        }
        if (!InstallComponentsMUIFiles(szSource, NULL, TRUE))
        {
#ifndef IGNORE_COPY_ERRORS
           DeleteFiles(Languages,&NotDeleted);
           return FALSE;
#endif
        }
        
        //
        //  Output what is being installed on the progress dialog box
        //
        if (!g_bNoUI)
        {
            LoadString(ghInstance, IDS_INSTALLING, lpStatus, ARRAYSIZE(lpStatus)-1);
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          lpStatus,
                          0,
                          0,
                          lpStatus,
                          ARRAYSIZE(lpStatus)-1,
                          (va_list *)lppArgs);

            SetWindowText(hStatic, lpStatus);
        }

        //
        //  find first file in language subdirectory
        //
        
        //*STRSAFE*         _tcscpy(szTemp,szSource);
        hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp), szSource);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        // szSource = g_szMUISetupFolder\szSource\tchPlatfromPath
        // e.g. szSource = "g_szMUISetupFolder\JPN.MUI\i386\"
        
        //*STRSAFE*         _tcscpy(szSource,g_szMUISetupFolder);
        hresult = StringCchCopy(szSource , ARRAYSIZE(szSource), g_szMUISetupFolder);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szSource,szTemp);
        hresult = StringCchCat(szSource , ARRAYSIZE(szSource), szTemp);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szSource, TEXT("\\"));
        hresult = StringCchCat(szSource , ARRAYSIZE(szSource),  TEXT("\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szSource, g_szPlatformPath); // i386 or alpha
        hresult = StringCchCat(szSource , ARRAYSIZE(szSource),  g_szPlatformPath);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        // szTemp = szSource + "*.*"
        // e.g. szTemp = "g_szMUISetupFolder\JPN.MUI\i386\*.*"
        //*STRSAFE*         _tcscpy(szTemp,szSource);
        hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp), szSource);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTemp,TEXT("*.*"));
        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp), TEXT("*.*"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        FoundMore = 1;  // reset foundmore for next language.


        hFile = FindFirstFile( szTemp, &FindFileData );

        if (INVALID_HANDLE_VALUE == hFile)
            return FALSE;

        //*STRSAFE*         _tcscpy(szTemp, TEXT(""));
        hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp),  TEXT(""));
        if (!SUCCEEDED(hresult))
        {
           FindClose(hFile);
           return FALSE;
        }
        
        while (FoundMore)
        {
            CreateFailure=FALSE;
            FileCopied=FALSE;

            if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // Reset diamond stuff for the new file
                //
                Muisetup_DiamondReset(&diamond);

                //
                // Check if it's a compressed file or not
                //
                Muisetup_CheckForExpandedFile( szSource,
                                               FindFileData.cFileName,
                                               szOriginalFileName,
                                               &diamond );

                if (IsFileBeRenamed(szOriginalFileName,szFileRenamed))
                {
                   //*STRSAFE*                    _tcscpy(szFileNameBeforeRenamed,szOriginalFileName);
                   hresult = StringCchCopy(szFileNameBeforeRenamed , ARRAYSIZE(szFileNameBeforeRenamed), szOriginalFileName);
                   if (!SUCCEEDED(hresult))
                   {
                      FindClose(hFile);
                      return FALSE;
                   }
                   //*STRSAFE*                    _tcscpy(szOriginalFileName,szFileRenamed);
                   hresult = StringCchCopy(szOriginalFileName , ARRAYSIZE(szOriginalFileName), szFileRenamed);
                   if (!SUCCEEDED(hresult))
                   {
                       FindClose(hFile);
                      return FALSE;
                   }
                   bRename=TRUE;
                }
                else if (IsFileInRenameTable(szOriginalFileName))
                {
                 // Skip this file because a file be renamed/to be renamed with the same name.
                 // Fix bug#:443196
                 FoundMore = FindNextFile( hFile, &FindFileData );
                 continue;
                }               
                else
                {
                   bRename=FALSE;
                }

                // e.g. szTemp = "shell32.dll"
                //*STRSAFE*                 _tcscpy(szTemp, szOriginalFileName);        //////////////
                hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp),  szOriginalFileName);
                if (!SUCCEEDED(hresult))
                {
                    FindClose(hFile);
                   return FALSE;
                }
                

                FileCopied=FALSE;

                for (Dirnum=1; (_tcslen(DirNames[Dirnum])>0); Dirnum++ )
                {
                    //
                    //  see where this file has to go
                    //
                    pfnGetWindowsDir( szTarget, MAX_PATH);

                    // e.g. szTarget = "c:\winnt\system32\wbem"
                    //*STRSAFE*                     _tcscat(szTarget, DirNames[Dirnum]);
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  DirNames[Dirnum]);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                    if (_tcscmp(DirNames[Dirnum], TEXT("\\")))
                    {
                        //*STRSAFE*                         _tcscat(szTarget, TEXT("\\"));
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                    }
                    
                    bFileWithNoMuiExt = FALSE;

                    //*STRSAFE*                     _tcscpy(szTemp, szOriginalFileName); //remove .mui  if it's .mui ////////
                    hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp),  szOriginalFileName);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                    iLen = _tcslen(szTemp);
                    if (iLen > 4)
                    {
                        if (_tcsicmp(&szTemp[iLen - 4], TEXT(".mui")) == 0)
                        {
                            *(szTemp +  iLen - 4) = 0;
                        }
                        else
                        {
                            bFileWithNoMuiExt = TRUE;
                        }
                    }

                    //*STRSAFE*                     _tcscat(szTarget, szTemp);
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  szTemp);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }

                    //
                    // Check the file with the same name (with the .mui extension) exist in the
                    // system directory.  If yes, this means that we need to copy the mui file.
                    // 
                    if (FileExists(szTarget))
                    {
                        //
                        //  need to copy this file to the directory
                        //
                        FileCopied = TRUE;
                                                
                        //
                        // copy filename in szTemp and directory in szTarget
                        //
                        _tsplitpath( szTarget, szTemp, dir, fname, ext );
                        //*STRSAFE*                         _tcscpy(szTarget, szTemp);               // drive name
                        hresult = StringCchCopy(szTarget , ARRAYSIZE(szTarget),  szTemp);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        //*STRSAFE*                         _tcscat(szTarget, dir);                  // directory name
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  dir);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                                                                                
                        //
                        //now szTarget = Directory, szTemp = filename
                        //
                        //*STRSAFE*                         _tcscat(szTarget, MUIDIR);  // append MUI to directory
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  MUIDIR);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        if (!MakeDir(szTarget))                    // if the MUI dir doesn't exist yet, create it.
                        {
                            MakeDirFailed(szTarget);
                            CreateFailure = TRUE;
                        }
                                                
                        //*STRSAFE*                         _tcscat(szTarget, TEXT("\\"));                          
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        //*STRSAFE*                         _tcscat(szTarget, Language); // add Language Identifier (from MUI.INF, e.g., 0407)                                      
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  Language);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        if (!FileExists(szTarget))    // if the directory doesn't exist yet
                        {
                            if (!MakeDir(szTarget))       // if the LANGID dir doesn't exist yet, create it.
                            {
                                MakeDirFailed(szTarget);
                                CreateFailure=TRUE;
                            }
                        }
                                                
                        //*STRSAFE*                         _tcscat(szTarget, TEXT("\\"));      // append \  /
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        if (bRename)
                        {
                           //*STRSAFE*                            _tcscpy(szFileNameCopied,szTarget);
                           hresult = StringCchCopy(szFileNameCopied , ARRAYSIZE(szFileNameCopied), szTarget);
                           if (!SUCCEEDED(hresult))
                           {
                              FindClose(hFile);                          
                              return FALSE;
                           }
                           //*STRSAFE*                            _tcscat(szFileNameCopied,szFileNameBeforeRenamed);
                           hresult = StringCchCat(szFileNameCopied , ARRAYSIZE(szFileNameCopied), szFileNameBeforeRenamed);
                           if (!SUCCEEDED(hresult))
                           {
                              FindClose(hFile);
                              return FALSE;
                           }
                        }
                        //*STRSAFE*                         _tcscat(szTarget, szOriginalFileName);  // append filename
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  szOriginalFileName);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        //*STRSAFE*                         _tcscpy(szTemp, szSource);
                        hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp),  szSource);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                        //*STRSAFE*                         _tcscat(szTemp, FindFileData.cFileName);
                        hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp),  FindFileData.cFileName);
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }

                        if (!CreateFailure)
                        {
                            if (!Muisetup_CopyFile(szTemp, szTarget, &diamond, bRename? szFileNameBeforeRenamed:NULL))
                            {               
                                CopyFileFailed(szTarget,0);
                                CreateFailure = TRUE;
                                CopyOK = FALSE;
                            }
                            else
                            {
                                if (!g_bNoUI)
                                {
                                    SendMessage(ghProgress, PBM_DELTAPOS, (WPARAM)(1), 0);
                                }
                                //
                                // Diamond decompression doesn't rename correctly
                                //
                                /*
                                if (bRename)
                                {
                                    MoveFileEx(szFileNameCopied,szTarget,MOVEFILE_REPLACE_EXISTING);
                                } 
                                */

                            }
                        }
                    } // if fileexists
                } // of for

                //
                // the file was not found in any of the known MUI targets -> fallback.
                // Simple hack for FAXUI.DLL to be copied to the fallback directory as well.
                //
                bSpecialDirectory=FALSE;
                for (i = 0; i < ARRAYSIZE(g_szSpecialFiles); i++)
                {
                    if (_tcsicmp(szOriginalFileName, g_szSpecialFiles[i]) == 0)
                    {
                       bSpecialDirectory=TRUE;
                    }
                }

                if ( ( (FileCopied != TRUE) && (!IsDoNotFallBack(szOriginalFileName))) || 
                    (_tcsicmp(szOriginalFileName, TEXT("faxui.dll.mui")) == 0) )
                {
                    pfnGetWindowsDir(szTarget, MAX_PATH); //%windir%  //
                    //*STRSAFE*                     _tcscat(szTarget, TEXT("\\"));
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                    
                    
                    //
                    // If the file couldn't be found in any of the above, and it's extension
                    // doesn't contain .mui, then copy it to %windir%\system32
                    // szTemp holds the filename.
                    //
                    if (bSpecialDirectory)
                    {
                        // e.g. szTarget = "c:\winnt\system32\";
                        //*STRSAFE*                         _tcscat(szTarget, TEXT("system32\\"));
                        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("system32\\"));
                        if (!SUCCEEDED(hresult))
                        {
                           FindClose(hFile);
                           return FALSE;
                        }
                    }

                    // e.g. szTarget = "c:\winnt\system32\MUI" (when bSpecialDirectory = TRUE) or "c:\winnt\MUI"                                                            
                    //*STRSAFE*                     _tcscat(szTarget, MUIDIR);                                // \MUI //
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  MUIDIR);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }

                    if (!MakeDir(szTarget))       // if the MUI dir doesn't exist yet, create it.
                    {
                        MakeDirFailed(szTarget);
                        CreateFailure = TRUE;
                    }
                                       
                    if (!bSpecialDirectory)
                    {
                        // e.g. szTarget = "C:\winnt\MUI\FALLBACK"
                       //*STRSAFE*                        _tcscat(szTarget, TEXT("\\"));
                       hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                       if (!SUCCEEDED(hresult))
                       {
                          FindClose(hFile);
                          return FALSE;
                       }
                       //*STRSAFE*                        _tcscat(szTarget, TEXT("FALLBACK"));      // FALLBACK
                       hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("FALLBACK"));
                       if (!SUCCEEDED(hresult))
                       {
                          FindClose(hFile);
                          return FALSE;
                       }

                       if (!MakeDir(szTarget))       // if the MUI dir doesn't exist yet, create it.
                       {
                           MakeDirFailed(szTarget);
                           CreateFailure = TRUE;
                       }
                    }   
                    //*STRSAFE*                     _tcscat(szTarget, TEXT("\\"));  // \ //
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                    // e.g. szTarget = "c:\winnt\system32\MUI\0411" (when bSpecialDirectory = TRUE) or "c:\winnt\MUI\FALLBACK\0411"
                    //*STRSAFE*                     _tcscat(szTarget, Language);    // add Language Identifier (from MUI.INF, e.g., 0407)
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  Language);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                                        
                    if (!MakeDir(szTarget))       // if the MUI dir doesn't exist yet, create it.
                    {
                        MakeDirFailed(szTarget);
                        CreateFailure = TRUE;
                    }
                                        
                    //*STRSAFE*                     _tcscat(szTarget, TEXT("\\"));                                    // \ //
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                    //*STRSAFE*                     _tcscat(szTarget, szOriginalFileName);                            // filename
                    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  szOriginalFileName);
                    if (!SUCCEEDED(hresult))
                    {
                        FindClose(hFile);
                       return FALSE;
                    }
                                
                    //*STRSAFE*                     _tcscpy(szTemp, szSource);
                    hresult = StringCchCopy(szTemp , ARRAYSIZE(szTemp),  szSource);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }
                    //*STRSAFE*                     _tcscat(szTemp, FindFileData.cFileName);
                    hresult = StringCchCat(szTemp , ARRAYSIZE(szTemp),  FindFileData.cFileName);
                    if (!SUCCEEDED(hresult))
                    {
                       FindClose(hFile);
                       return FALSE;
                    }


                    if (!CreateFailure)
                    {
                        if (!Muisetup_CopyFile(szTemp, szTarget, &diamond, bRename? szFileNameBeforeRenamed:NULL))
                        {
                            CopyFileFailed(szTarget,0);
                            CopyOK = FALSE;
                        }
                        else
                        {
                            if (!g_bNoUI)
                            {                            
                                SendMessage(ghProgress, PBM_DELTAPOS, (WPARAM)(1), 0);
                            }
                        }
                    }

                    if (CreateFailure == TRUE)
                    {
                        CopyOK=FALSE;
                    }
                }  // fallback case
            } // of file not dir

            FoundMore = FindNextFile( hFile, &FindFileData );

            if (!g_bNoUI)
            {
                //
                // Since this is a lengthy operation, we should
                // peek and dispatch window messages here so
                // that MUISetup dialog could repaint itself.
                //
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (msg.message == WM_QUIT)
                    {
                        return (FALSE);
                    }
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }            
            }
        } // of while
        
        FindClose(hFile);

        lppArgs[0] = (LONG_PTR)Language;
        LogFormattedMessage(NULL, IDS_LANG_INSTALLED, lppArgs);
        while (*Language++)  // go to the next language and repeat
        {                       
        }        
    } // of while (*Language)
#ifndef IGNORE_COPY_ERRORS
    if (!CopyOK)
    {
        // in silent mode, always just fail without prompting for user input
        if (!g_bNoUI)
        {
            if (DoMessageBox(NULL, IDS_CANCEL_INSTALLATION, IDS_MAIN_TITLE, MB_YESNO) == IDNO)
            {
                DeleteFiles(Languages,&NotDeleted);
            } 
            else
            {
                CopyOK = TRUE;
            }
        }
    }          
#endif
                
    return CopyOK;

#else
    TCHAR    szMSIPath[MAX_PATH];
    TCHAR    szCmdLine[BUFFER_SIZE];
    UINT     uiMSIError = ERROR_SUCCESS;
    TCHAR    lpPath[BUFFER_SIZE] = {0};
    TCHAR    szCaption[MAX_PATH+1],szMsg[MAX_PATH+1];  
    BOOL     bFileExist = FALSE;
    UINT     uiPrevMode = 0;

    // kenhsu - in this codebranch here we include the code for MSI invocation instead of copying the files ourselves
    // we will invoke the msi packages for installation one by one for each of the languages contained in the 
    // languages variable.
    
    // Initialize MSI UI level (use Basic UI level if in GUI mode, otherwise, use no UI). 
    if (g_bNoUI)
    {
        MsiSetInternalUI((INSTALLUILEVEL)(INSTALLUILEVEL_NONE), NULL);        
    }
    else
    {
        MsiSetInternalUI((INSTALLUILEVEL)(INSTALLUILEVEL_BASIC | INSTALLUILEVEL_PROGRESSONLY), NULL);        
    }
    

    if (GetSystemWindowsDirectory(lpPath, MAX_PATH))
    {
        //*STRSAFE*         _tcscat(lpPath, MSILOG_FILE);
        hresult = StringCchCat(lpPath , ARRAYSIZE(lpPath),  MSILOG_FILE);
        if (!SUCCEEDED(hresult))
        {
            return FALSE;
        }
        MsiEnableLog(INSTALLLOGMODE_FATALEXIT | 
                    INSTALLLOGMODE_ERROR | 
                    INSTALLLOGMODE_WARNING | 
                    INSTALLLOGMODE_INFO | 
                    INSTALLLOGMODE_OUTOFDISKSPACE | 
                    INSTALLLOGMODE_ACTIONSTART | 
                    INSTALLLOGMODE_ACTIONDATA | 
                    INSTALLLOGMODE_PROPERTYDUMP,      
                    lpPath,
                    INSTALLLOGATTRIBUTES_APPEND | INSTALLLOGATTRIBUTES_FLUSHEACHLINE);        
    }
    else
    {
        DEBUGMSGBOX(NULL, TEXT("Error getting windows directory, MSI logging has been disabled."), NULL, MB_OK); 
        MsiEnableLog(0, NULL, INSTALLLOGATTRIBUTES_APPEND);        
    }

    while (*Language)
    {
        //*STRSAFE*         _tcscpy(szMSIPath,g_szMUISetupFolder);
        hresult = StringCchCopy(szMSIPath , ARRAYSIZE(szMSIPath), g_szMUISetupFolder);
        if (!SUCCEEDED(hresult))
        {
            return FALSE;
        }
        //*STRSAFE*         _tcscat(szMSIPath,Language);                            
        hresult = StringCchCat(szMSIPath , ARRAYSIZE(szMSIPath), Language);
        if (!SUCCEEDED(hresult))
        {
            return FALSE;
        }
        //*STRSAFE*         _tcscat(szMSIPath,TEXT(".msi"));
        hresult = StringCchCat(szMSIPath , ARRAYSIZE(szMSIPath), TEXT(".msi"));
        if (!SUCCEEDED(hresult))
        {
            return FALSE;
        }

        //
        // if we can't find files or media is missing, treat as error
        //        
        uiPrevMode = SetErrorMode(SEM_FAILCRITICALERRORS);

        //
        // First check to see if the MSI package is still located at the same place, since the user
        // could have removed the CD, either intentionally or to install langpack for a MUI language
        //
        bFileExist = FileExists(szMSIPath);
        while (!bFileExist)
        {
            if (g_bNoUI)
            {
                // 
                // log an error and fail the installation
                //
                lppArgs[0] = (LONG_PTR)szMSIPath;
                LogFormattedMessage(ghInstance, IDS_CHANGE_CDROM3, lppArgs);
                SetErrorMode(uiPrevMode);            
                return FALSE;
            }
            else
            {
                //
                // prompt the user to reinsert the MUI CD so installation can continue, if user
                // click cancel, cancel and fail the installation.
                //
                szCaption[0]=szMsg[0]=TEXT('\0');
                LoadString(NULL, IDS_MAIN_TITLE, szCaption, MAX_PATH);
                lppArgs[0] = (LONG_PTR)g_szCDLabel;
                lppArgs[1] = (LONG_PTR)g_cdnumber;
                FormatStringFromResource(szMsg, ARRAYSIZE(szMsg), ghInstance, IDS_CHANGE_CDROM2, lppArgs);
                if (MESSAGEBOX(NULL, szMsg,szCaption, MB_YESNO | MB_ICONQUESTION) == IDNO)
                {
                    lppArgs[0] = (LONG_PTR)szMSIPath;
                    LogFormattedMessage(ghInstance, IDS_CHANGE_CDROM3, lppArgs);
                    SetErrorMode(uiPrevMode);            
                    return FALSE;
                }
            }
            bFileExist = FileExists(szMSIPath);
        }
        SetErrorMode(uiPrevMode);

        //
        // Get the language display name in case we need to log it
        //
        GetPrivateProfileString( MUI_LANGUAGES_SECTION, 
                             Language, 
                             TEXT("DEFAULT"),
                             szSource, 
                             (sizeof(szSource)/sizeof(TCHAR)),
                             g_szMUIInfoFilePath );

        GetLanguageGroupDisplayName((LANGID)_tcstol(Language, NULL, 16), lpLangText, ARRAYSIZE(lpLangText)-1);

        // invoke the MSI to do the installation - we do not set current user UI language and default user UI language here
        //*STRSAFE*         lstrcpy(szCmdLine, TEXT("CANCELBUTTON=\"Disable\" REBOOT=\"ReallySuppress\" CURRENTUSER=\"\" DEFAULTUSER=\"\""));
        hresult = StringCchCopy(szCmdLine , ARRAYSIZE(szCmdLine),  TEXT("CANCELBUTTON=\"Disable\" REBOOT=\"ReallySuppress\" CURRENTUSER=\"\" DEFAULTUSER=\"\""));
        if (!SUCCEEDED(hresult))
        {
            return FALSE;
        }
        uiMSIError = MsiInstallProduct(szMSIPath, szCmdLine);
        if ((ERROR_SUCCESS != uiMSIError) && (ERROR_SUCCESS_REBOOT_INITIATED != uiMSIError) && ((ERROR_SUCCESS_REBOOT_REQUIRED != uiMSIError)))
        {
            // log a message here indicating something went wrong
            lppArgs[0] = (LONG_PTR) lpLangText;
            lppArgs[1] = (LONG_PTR) szMSIPath;
            lppArgs[2] = (LONG_PTR) uiMSIError;
            LogFormattedMessage(NULL, IDS_ERROR_INSTALL_LANGMSI, lppArgs);     

#ifdef MUI_DEBUG
            TCHAR errorMsg[1024];
            //*STRSAFE*             wsprintf(errorMsg, TEXT("MSI Install failed, MSI path is %s, error is %d, language is %s"), szMSIPath, uiMSIError, lpLangText);
            hresult = StringCchPrintf(errorMsg , ARRAYSIZE(errorMsg),  TEXT("MSI Install failed, MSI path is %s, error is %d, language is %s"), szMSIPath, uiMSIError, lpLangText);
            if (!SUCCEEDED(hresult))
            {
                return FALSE;
            }
            DEBUGMSGBOX(NULL, errorMsg, NULL, MB_OK);            
#endif
            CopyOK = FALSE;
        }
        else
        {
            lppArgs[0] = (LONG_PTR)Language;
            LogFormattedMessage(NULL, IDS_LANG_INSTALLED, lppArgs);
        }           

        if ((ERROR_SUCCESS_REBOOT_INITIATED == uiMSIError) || ((ERROR_SUCCESS_REBOOT_REQUIRED == uiMSIError)))
        {
            g_bReboot = TRUE;
        }       
        
        while (*Language++)  // go to the next language and repeat
        {                       
        }        
    } // of while (*Language)

    return CopyOK;
    
#endif
}


////////////////////////////////////////////////////////////////////////////////////
//
// Copy or remove muisetup related files
//      Help file   : %windir%\help
//      Other files : %windir%\mui
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CopyRemoveMuiItself(BOOL bInstall)
{
    //
    // MUISETUP files need to be copied from MUI CD
    //
    TCHAR *TargetFiles[] = {
        TEXT("muisetup.exe"), 
        TEXT("mui.inf"), 
        TEXT("eula.txt"),
        TEXT("readme.txt"),
        TEXT("relnotes.htm")
    };
    
    TCHAR szTargetPath[MAX_PATH+1], szTargetFile[MAX_PATH+1];
    TCHAR szSrcFile[MAX_PATH+1];
    TCHAR szHelpFile[MAX_PATH+1];
    BOOL bRet = FALSE;
    int i;

    PathCombine(szTargetPath, g_szWinDir, MUIDIR);

    if (MakeDir(szTargetPath))    
    {
        //
        // Copy over MUISETUP related files
        //
        for (i=0; i<ARRAYSIZE(TargetFiles); i++)
        {
            PathCombine(szTargetFile, szTargetPath, TargetFiles[i]);
            PathCombine(szSrcFile, g_szMUISetupFolder, TargetFiles[i]);

            if (bInstall)
            {
                RemoveFileReadOnlyAttribute(szTargetFile);
                CopyFile(szSrcFile,szTargetFile,FALSE);
                RemoveFileReadOnlyAttribute(szTargetFile);
            }
            else
            {
                if (FileExists(szTargetFile) && 
                    !MUI_DeleteFile(szTargetFile))
                {
                    MoveFileEx(szTargetFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                }
            }
        }


        //
        // Copy over muisetup help file
        //
        LoadString(NULL, IDS_HELPFILE,szHelpFile,MAX_PATH);
        
        PathCombine(szTargetFile, g_szWinDir, HELPDIR);
        PathAppend(szTargetFile, szHelpFile);
        PathCombine(szSrcFile, g_szMUISetupFolder, szHelpFile);

        if (bInstall)
        {
            RemoveFileReadOnlyAttribute(szTargetFile);
            CopyFile(szSrcFile,szTargetFile,FALSE);
            RemoveFileReadOnlyAttribute(szTargetFile);
        }
        else
        {
            if (FileExists(szTargetFile) && 
                !MUI_DeleteFile(szTargetFile))
            {
                MoveFileEx(szTargetFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }

        bRet = TRUE;
    }

    return bRet;
}

BOOL CompareMuisetupVersion(LPTSTR pszSrc,LPTSTR pszTarget)
{

    BOOL bResult=TRUE;
    ULONG  ulHandle,ulHandle1,ulBytes,ulBytes1;
    PVOID  pvoidBuffer=NULL,pvoidBuffer1=NULL;
    VS_FIXEDFILEINFO *lpvsInfo,*lpvsInfo1;
    UINT                  unLen;

    if ( (!pszSrc) || (!pszTarget))
    { 
       bResult = FALSE;
       goto endcompare;
    }
    
    ulBytes = GetFileVersionInfoSize( pszSrc, &ulHandle );

    if ( ulBytes == 0 )

       goto endcompare;
    

    ulBytes1 = GetFileVersionInfoSize( pszTarget,&ulHandle1 );

    if ( ulBytes1 == 0 ) 
    
       goto endcompare;
       

    pvoidBuffer=LocalAlloc(LMEM_FIXED,ulBytes+1);

    if (!pvoidBuffer)
       goto endcompare;
       
    
    pvoidBuffer1=LocalAlloc(LMEM_FIXED,ulBytes1+1);

    if (!pvoidBuffer1)
       goto endcompare;

    if ( !GetFileVersionInfo( pszSrc, ulHandle, ulBytes, pvoidBuffer ) ) 
       goto endcompare;

    if ( !GetFileVersionInfo( pszTarget, ulHandle1, ulBytes1, pvoidBuffer1 ) ) 
       goto endcompare;
    
    // Get fixed info block
    if ( !VerQueryValue( pvoidBuffer,_T("\\"),(LPVOID *)&lpvsInfo ,&unLen ) )
       goto endcompare;
    

    if ( !VerQueryValue( pvoidBuffer1,_T("\\"),(LPVOID *)&lpvsInfo1,&unLen ) )
       goto endcompare;
               
    bResult = FALSE;

    //
    // We do nothing if major release version is different
    //
    // I.E We won't copy a new muisetup.exe over a old one if major release version of them are different
    //
    if ( (lpvsInfo->dwFileVersionMS == lpvsInfo1->dwFileVersionMS) &&
         (lpvsInfo->dwFileVersionLS < lpvsInfo1->dwFileVersionLS))
    
    {
    
       bResult = TRUE;  
    }                

    
endcompare:

   if(pvoidBuffer)
      LocalFree(pvoidBuffer);

   if(pvoidBuffer1)
      LocalFree(pvoidBuffer1);

   return bResult;

}



BOOL IsAllLanguageRemoved(LPTSTR Language)
{
   int mask[MAX_UI_LANG_GROUPS],nIdx;

   LCID SystemUILangId,lgCheck;
  
   BOOL bResult=FALSE;

   if (! Language)
   {
      return FALSE;
   }  
   if (gNumLanguages_Install > 0)
      return bResult;              

   SystemUILangId=(LCID) gSystemUILangId; 

   for ( nIdx=0; nIdx<g_UILanguageGroup.iCount;nIdx++)
   {
      if ( gSystemUILangId == g_UILanguageGroup.lcid[nIdx])
      {
         mask[nIdx]=1;
      }
      else
      {
         mask[nIdx]=0;
      }
   }
   while (*Language)
   {   
       
       lgCheck = (LCID)_tcstol(Language,NULL,16);    

       for ( nIdx=0; nIdx<g_UILanguageGroup.iCount;nIdx++)
       {
          if ( lgCheck == g_UILanguageGroup.lcid[nIdx])
          {
             mask[nIdx]=1;
             break;
          }
       } 
       while (*Language++)  
       {            
       }
   }
   bResult=TRUE;
   for ( nIdx=0; nIdx<g_UILanguageGroup.iCount;nIdx++)
   {
       if ( mask[nIdx] == 0)
       {
          bResult = FALSE;
          break;
       }
   } 
   return bResult;
}

void DoRemoveFiles(LPTSTR szDirToDelete, int* pnNotDeleted)
{
    // File wildcard pattern.
    TCHAR szTarget[MAX_PATH];    
    // File to be deleted.
    TCHAR szFileName[MAX_PATH];
    // Sub-directory name
    TCHAR szSubDirName[MAX_PATH];
    
    int FoundMore = 1;
    
    HANDLE hFile;
    WIN32_FIND_DATA FindFileData;

    MSG msg;
    HRESULT hresult;

    if ((!szDirToDelete) || (!pnNotDeleted))
    {
        return;
    }
    // e.g. szTarget = "c:\winnt\system32\Wbem\MUI\0404\*.*"
    //*STRSAFE*     _stprintf(szTarget, TEXT("%s\\*.*"), szDirToDelete);
    hresult = StringCchPrintf(szTarget , ARRAYSIZE(szTarget),  TEXT("%s\\*.*"), szDirToDelete);
    if (!SUCCEEDED(hresult))
    {
       return;
    }
    
    hFile = FindFirstFile(szTarget, &FindFileData);

    while (FoundMore)
    {
        if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            //*STRSAFE*             _tcscpy(szFileName, szDirToDelete);
            hresult = StringCchCopy(szFileName , ARRAYSIZE(szFileName),  szDirToDelete);
            if (!SUCCEEDED(hresult))
            {
               FindClose(hFile);
               return;
            }
            //*STRSAFE*             _tcscat(szFileName, TEXT("\\"));
            hresult = StringCchCat(szFileName , ARRAYSIZE(szFileName),  TEXT("\\"));
            if (!SUCCEEDED(hresult))
            {
               FindClose(hFile);
               return;
            }
            //*STRSAFE*             _tcscat(szFileName, FindFileData.cFileName);
            hresult = StringCchCat(szFileName , ARRAYSIZE(szFileName),  FindFileData.cFileName);
            if (!SUCCEEDED(hresult))
            {
               FindClose(hFile);
               return;
            }
    
            if (FileExists(szFileName))
            {
                // We should check if the said file is actually deleted
                // If it's not the case, then we should post a defered deletion
                //
                if (!MUI_DeleteFile(szFileName))
                {
                   (*pnNotDeleted)++;
                   MoveFileEx(szFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                }                
            }

            SendMessage(ghProgress, PBM_DELTAPOS, (WPARAM)(1), 0);
        } else
        {
            if (_tcscmp(FindFileData.cFileName, TEXT(".")) != 0 && _tcscmp(FindFileData.cFileName, TEXT("..")) != 0)
            {
                //*STRSAFE*                 _stprintf(szSubDirName, TEXT("%s\\%s"), szDirToDelete, FindFileData.cFileName);
                hresult = StringCchPrintf(szSubDirName , ARRAYSIZE(szSubDirName),  TEXT("%s\\%s"), szDirToDelete, FindFileData.cFileName);
                if (!SUCCEEDED(hresult))
                {
                   FindClose(hFile);
                   return ;
                }
                DoRemoveFiles(szSubDirName, pnNotDeleted);
            }
        }

        //
        // Since this is a lengthy operation, we should
        // peek and dispatch window messages here so
        // that MUISetup dialog could repaint itself.
        //
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                FindClose(hFile);
                return;
            }
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }            

        FoundMore = FindNextFile( hFile, &FindFileData );
    }

    FindClose(hFile);
    //
    // If the directory is not empty, then we should post a defered deletion
    // for the directory
    //
    if (!RemoveDirectory(szDirToDelete))
    {
       MoveFileEx(szDirToDelete, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
    }
}


BOOL DeleteFilesClassic(LPTSTR Language, int *lpNotDeleted)
{
    TCHAR  lpLangText[BUFFER_SIZE];
    LONG_PTR lppArgs[3];
    TCHAR  lpStatus[BUFFER_SIZE];
    HWND   hStatic;
    int Dirnum = 0;
    TCHAR  szTarget[MAX_PATH];   
    LPTSTR Langchk;   
    TCHAR  szMuiDir[MAX_PATH];
    TCHAR  szFallbackDir[MAX_PATH];   
    HRESULT hresult;

    if ((!Language) || (!lpNotDeleted))
    {
        return FALSE;
    }
#ifndef MUI_MAGIC
    if (!g_bNoUI)
    {
        hStatic = GetDlgItem(ghProgDialog, IDC_STATUS);
    }
#endif

    Langchk = Language;
    *lpNotDeleted = 0;

    GetLanguageGroupDisplayName((LANGID)_tcstol(Language, NULL, 16), lpLangText, ARRAYSIZE(lpLangText)-1);

    lppArgs[0]= (LONG_PTR)lpLangText;

#ifndef MUI_MAGIC
    //
    //  Output what is being uninstalled on the progress dialog box
    //
    if (!g_bNoUI)
    {    
        FormatStringFromResource(lpStatus, sizeof(lpStatus)/sizeof(TCHAR), ghInstance, IDS_UNINSTALLING, lppArgs);
        SetWindowText(hStatic, lpStatus);
    }
#endif

    //
    // Remove all files under special directories (those directories listed under [Directories] in mui.inf.
    //
    for (Dirnum=1; (_tcslen(DirNames[Dirnum])>0); Dirnum++ )
    {
        // szTarget = "c:\winnt"
        //*STRSAFE*         _tcscpy(szTarget, g_szWinDir);
        hresult = StringCchCopy(szTarget , ARRAYSIZE(szTarget),  g_szWinDir);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        
        // e.g. szTarget = "c:\winnt\system32\Wbem"
        //*STRSAFE*         _tcscat(szTarget, DirNames[Dirnum]);
        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  DirNames[Dirnum]);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
                
        if (_tcscmp(DirNames[Dirnum], TEXT("\\")))
        {
            // e.g. szTarget = "c:\winnt\system32\Wbem\"
            //*STRSAFE*             _tcscat(szTarget, TEXT("\\"));
            hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
        }

        // e.g. szTarget = "c:\winnt\system32\Wbem\MUI"
        //*STRSAFE*         _tcscat(szTarget, MUIDIR);
        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  MUIDIR);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }

        // e.g. szTarget = "c:\winnt\system32\Wbem\MUI\0404"
        //*STRSAFE*         _tcscat(szTarget, TEXT("\\"));
        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szTarget, Language);
        hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  Language);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        
        DoRemoveFiles(szTarget, lpNotDeleted);    
    }

    // Uninstall Component MUI Files.
    // Note that we should do this before removing all files under FALLBACK directory,
    // since we store compoent INF files under the FALLBACK directory.
    InstallComponentsMUIFiles(NULL, Language, FALSE);
    
    //
    //  Remove all files under FALLBACK directory.
    //

    // E.g. szTarget = "c:\winnt\mui"
    //*STRSAFE*     _tcscpy(szTarget, g_szWinDir);
    hresult = StringCchCopy(szTarget , ARRAYSIZE(szTarget),  g_szWinDir);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     _tcscat(szTarget, TEXT("\\"));
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     _tcscat(szTarget, MUIDIR);
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  MUIDIR);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    //*STRSAFE*     _tcscpy(szMuiDir, szTarget);
    hresult = StringCchCopy(szMuiDir , ARRAYSIZE(szMuiDir),  szTarget);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    // E.g. szTarget = "c:\winnt\mui\FALLBACK"
    //*STRSAFE*     _tcscat(szTarget, TEXT("\\"));
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     _tcscat(szTarget, TEXT("FALLBACK"));
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("FALLBACK"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    //*STRSAFE*     _tcscpy(szFallbackDir, szTarget);
    hresult = StringCchCopy(szFallbackDir , ARRAYSIZE(szFallbackDir),  szTarget);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     _tcscat(szTarget, TEXT("\\"));
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  TEXT("\\"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    // E.g. szTarget = "c:\winnt\mui\FALLBACK\0404"
    //*STRSAFE*     _tcscat(szTarget, Language);
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget),  Language);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    DoRemoveFiles(szTarget, lpNotDeleted);

    //
    // Remove files listed in g_SpecialFiles
    //    
    // e.g. szTarget = "c:\winnt\system32\mui\0411"
    //*STRSAFE*             wsprintf(szTarget, L"%s\\system32\\%s\\%s", g_szWinDir, MUIDIR, Language);
    hresult = StringCchPrintf(szTarget , ARRAYSIZE(szTarget),  TEXT("%s\\system32\\%s\\%s"), g_szWinDir, MUIDIR, Language);
    if (!SUCCEEDED(hresult))
    {
        return FALSE;
    }
   
    DoRemoveFiles(szTarget, lpNotDeleted); 

    lppArgs[0] = (LONG_PTR)Language;
    LogFormattedMessage(NULL, IDS_LANG_UNINSTALLED, lppArgs);

    return TRUE;
}
 
////////////////////////////////////////////////////////////////////////////////////
//
//  DeleteFiles
//
//  Deletes MUI files for the languages specified
//
//  Parameters:
//      [IN]    Languages: a double-null terminated string which contains languages
//             to be processed.
//      [OUT]    lpNotDeleted: The number of files to be deleted after reboot.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL DeleteFiles(LPTSTR Languages, int *lpNotDeleted)
{
    LPTSTR Language,Langchk;
    
    HWND   hStatic;
    TCHAR  lpLangText[BUFFER_SIZE];
    

    //TCHAR  szTarget[MAX_PATH];
    TCHAR  szMuiDir[MAX_PATH];
    TCHAR  szFallbackDir[MAX_PATH];
    
    BOOL   bSuccess = TRUE;
    
    LONG_PTR lppArgs[3];
    int i;

    HRESULT hresult;

    if ((!Languages) || (!lpNotDeleted))
    {
        return FALSE;
    }
    Language = Langchk = Languages;
    *lpNotDeleted = 0;

#ifndef MUI_MAGIC
    if (!g_bNoUI)
    {
        hStatic = GetDlgItem(ghProgDialog, IDC_STATUS);
    }
    while (*Language)
    {
        if (!DeleteFilesClassic(Language, lpNotDeleted))
        {
            bSuccess = FALSE;
        }
        
        while (*Language++)  // go to the next language and repeat
        {
        }
    } // of while (*Language)


    //
    //  Removes Fallback directory if all languages have been uninstalled.
    //
    if (!RemoveDirectory(szFallbackDir))
    {
       MoveFileEx(szFallbackDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT); 
    }
    //
    //  Removes MUI directory if all languages have been uninstalled and Fallback
    //  directory has been removed.
    //
    if (IsAllLanguageRemoved(Langchk))
    {
      CopyRemoveMuiItself(FALSE);   
    }

    if (!RemoveDirectory(szMuiDir))
    {
       MoveFileEx(szMuiDir, NULL, MOVEFILE_DELAY_UNTIL_REBOOT); 
    }
    return bSuccess;

 #else

    UINT    uiMSIError = ERROR_SUCCESS;
    BOOL    bFound = FALSE;
    TCHAR   lpPath[BUFFER_SIZE] = {0};
    TCHAR   szString[256];
    
    // kenhsu - in this codebranch here we include the code for MSI invocation instead of copying the files ourselves
    // we will invoke the msi packages for installation one by one for each of the languages contained in the 
    // languages variable.
    
    // Initialize MSI UI level (use Basic UI level if in GUI mode, otherwise, use no UI).  
    if (g_bNoUI)
    {
        MsiSetInternalUI((INSTALLUILEVEL)(INSTALLUILEVEL_NONE), NULL);        
    }
    else
    {
        MsiSetInternalUI((INSTALLUILEVEL)(INSTALLUILEVEL_BASIC | INSTALLUILEVEL_PROGRESSONLY), NULL);        
    }    

    if (GetSystemWindowsDirectory(lpPath, MAX_PATH))
    {
        //*STRSAFE*         _tcscat(lpPath, MSILOG_FILE);
        hresult = StringCchCat(lpPath , ARRAYSIZE(lpPath),  MSILOG_FILE);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        MsiEnableLog(INSTALLLOGMODE_FATALEXIT | 
                    INSTALLLOGMODE_ERROR | 
                    INSTALLLOGMODE_WARNING | 
                    INSTALLLOGMODE_INFO | 
                    INSTALLLOGMODE_OUTOFDISKSPACE | 
                    INSTALLLOGMODE_ACTIONSTART | 
                    INSTALLLOGMODE_ACTIONDATA | 
                    INSTALLLOGMODE_PROPERTYDUMP,      
                    lpPath,
                    INSTALLLOGATTRIBUTES_APPEND | INSTALLLOGATTRIBUTES_FLUSHEACHLINE);        
    }
    else
    {
        DEBUGMSGBOX(NULL, TEXT("Error getting windows directory, MSI logging has been disabled."), NULL, MB_OK); 
        MsiEnableLog(0, NULL, INSTALLLOGATTRIBUTES_APPEND);        
    }
   
    while (*Language)
    {
        TCHAR   szProductCode[GUIDLENGTH] = { 0 };    
        
        GetLanguageGroupDisplayName((LANGID)_tcstol(Language, NULL, 16), lpLangText, ARRAYSIZE(lpLangText)-1);

        // Get the product code here
        bFound = GetMSIProductCode(Language, szProductCode, ARRAYSIZE(szProductCode));

#ifdef MUI_DEBUG
        //*STRSAFE*         wsprintf(szString, TEXT("lpLangText is: %s, szProductGUID is %s,  Language is %s"), lpLangText, szProductCode, Language);
        hresult = StringCchPrintf(szString , ARRAYSIZE(szString),  TEXT("lpLangText is: %s, szProductGUID is %s,  Language is %s"), lpLangText, szProductCode, Language);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        DEBUGMSGBOX(NULL, szString, TEXT("DEBUG MESSAGE"), MB_OK);            
#endif
        if (TRUE == bFound)
        {
            INSTALLSTATE isProductState = MsiQueryProductState(szProductCode);

            // debug code remove later
            switch (isProductState)
            {
                case INSTALLSTATE_ABSENT:
                        //*STRSAFE*                         wsprintf(szString, TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_ABSENT"), lpLangText, Language, szProductCode);
                        hresult = StringCchPrintf(szString , ARRAYSIZE(szString),  TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_ABSENT"), lpLangText, Language, szProductCode);
                        if (!SUCCEEDED(hresult))
                        {
                           return FALSE;
                        }
                    break;
                case INSTALLSTATE_ADVERTISED:
                        //*STRSAFE*                         wsprintf(szString, TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_ADVERTISED"), lpLangText, Language, szProductCode);                    
                        hresult = StringCchPrintf(szString , ARRAYSIZE(szString),  TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_ADVERTISED"), lpLangText, Language, szProductCode);
                        if (!SUCCEEDED(hresult))
                        {
                           return FALSE;
                        }
                    break;
                case INSTALLSTATE_DEFAULT:
                        //*STRSAFE*                         wsprintf(szString, TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_DEFAULT"), lpLangText, Language, szProductCode);                                        
                        hresult = StringCchPrintf(szString , ARRAYSIZE(szString),  TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_DEFAULT"), lpLangText, Language, szProductCode);
                        if (!SUCCEEDED(hresult))
                        {
                           return FALSE;
                        }
                    break;
                case INSTALLSTATE_INVALIDARG:
                        //*STRSAFE*                         wsprintf(szString, TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_INVALIDARG"), lpLangText, Language, szProductCode);                                                            
                        hresult = StringCchPrintf(szString , ARRAYSIZE(szString),  TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_INVALIDARG"), lpLangText, Language, szProductCode);
                        if (!SUCCEEDED(hresult))
                        {
                           return FALSE;
                        }
                    break;
                case INSTALLSTATE_UNKNOWN:
                default:
                        //*STRSAFE*                         wsprintf(szString, TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_UNKNOWN or an unknown value."), lpLangText, Language, szProductCode);                                                                                
                        hresult = StringCchPrintf(szString , ARRAYSIZE(szString),  TEXT("Installed state for language %s (lcid: %s, product code: %s) is INSTALLSTATE_UNKNOWN or an unknown value."), lpLangText, Language, szProductCode);
                        if (!SUCCEEDED(hresult))
                        {
                           return FALSE;
                        }
                    break;
            }
            LogMessage(szString);            
            
            // check here to see if the product is actually installed using MSI
            if (INSTALLSTATE_DEFAULT == isProductState)
            {        
                LogMessage(TEXT("MUI Installed using Windows Installer"));

                // invoke the MSI to do the installation by configuring the product to an install state of 'absent'
                uiMSIError = MsiConfigureProductEx(szProductCode, INSTALLLEVEL_DEFAULT, INSTALLSTATE_ABSENT, TEXT("CANCELBUTTON=\"Disable\" REBOOT=\"ReallySuppress\""));
                switch (uiMSIError)
                {
                    case ERROR_SUCCESS:
                    case ERROR_SUCCESS_REBOOT_INITIATED:
                    case ERROR_SUCCESS_REBOOT_REQUIRED:
                        lppArgs[0] = (LONG_PTR)Language;
                        LogFormattedMessage(NULL, IDS_LANG_UNINSTALLED, lppArgs);
                        if ((ERROR_SUCCESS_REBOOT_INITIATED == uiMSIError) || ((ERROR_SUCCESS_REBOOT_REQUIRED == uiMSIError)))
                        {
                            g_bReboot = TRUE;
                        }                        
                        break;
                    default:
                        if (TRUE == g_bRunFromOSSetup)
                        {
                            LogFormattedMessage(NULL, IDS_NTOS_SETUP_MSI_ERROR, NULL);
                            // we are in OS setup, and MSI service is not available, we will manually remove the files
                            // we will also need to clear the registry keys for the installer logs
                            if (!DeleteFilesClassic(Language, lpNotDeleted))
                            {
                                // log a message here indicating something went wrong
                                lppArgs[0] = (LONG_PTR) Language;
                                lppArgs[1] = (LONG_PTR) szProductCode;
                                lppArgs[2] = (LONG_PTR) uiMSIError;
                                LogFormattedMessage(NULL, IDS_ERROR_UNINSTALL_LANGMSI, lppArgs);           
                                bSuccess = FALSE;
                            }
                        }
                        else
                        {
                            // log a message here indicating something went wrong
                            lppArgs[0] = (LONG_PTR) Language;
                            lppArgs[1] = (LONG_PTR) szProductCode;
                            lppArgs[2] = (LONG_PTR) uiMSIError;
                            LogFormattedMessage(NULL, IDS_ERROR_UNINSTALL_LANGMSI, lppArgs);           
                            bSuccess = FALSE;
                        }
                        break;                        
                }                
            }            
            else
            {
                // this is a classic installation - we will try to remove it manually
                LogFormattedMessage(NULL, IDS_MUI_OLD_SETUP, NULL);                
                if (!DeleteFilesClassic(Language, lpNotDeleted))
                {
                    // log a message here indicating something went wrong
                    lppArgs[0] = (LONG_PTR) Language;
                    lppArgs[1] = (LONG_PTR) szProductCode;
                    lppArgs[2] = (LONG_PTR) uiMSIError;
                    LogFormattedMessage(NULL, IDS_ERROR_UNINSTALL_LANGMSI, lppArgs);           
                    bSuccess = FALSE;
                }
            }
        }
        else
        {
            // log a message here indicating language is not installed (which should not happen really)
            lppArgs[0] = (LONG_PTR) Language;
            LogFormattedMessage(NULL, IDS_IS_NOT_INSTALLED_L, lppArgs);       
            bSuccess = FALSE;
        }

        while (*Language++)  // go to the next language and repeat
        {                       
        }        
    } // of while (*Language)

    return bSuccess;
 #endif
}


////////////////////////////////////////////////////////////////////////////////////
//
//  MZStrLen
//
//  Calculate the length of MULTI_SZ string
//
//  the length is in bytes and includes extra terminal NULL, so the length >= 1 (TCHAR)
//
////////////////////////////////////////////////////////////////////////////////////

UINT MZStrLen(LPTSTR lpszStr)
{
    UINT i=0;
    if (!lpszStr)
    {
        return i;
    }

    while (lpszStr && *lpszStr) 
    {
        i += ((lstrlen(lpszStr)+1) * sizeof(TCHAR));
        lpszStr += (lstrlen(lpszStr)+1);
    }

    //
    // extra NULL
    //
    i += sizeof(TCHAR);
    return i;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  SetFontLinkValue
//
//  Set necessary font link value into registry
//
//  lpszLinkInfo = "Target","Link1","Link2",....
//
////////////////////////////////////////////////////////////////////////////////////

BOOL SetFontLinkValue (LPTSTR lpszLinkInfo,BOOL *lpbFontLinkRegistryTouched)
{
    const TCHAR szDeli[] = TEXT("\\\\");
    TCHAR szStrBuf[FONTLINK_BUF_SIZE];
    TCHAR szRegDataStr[FONTLINK_BUF_SIZE];
    LPTSTR lpszDstStr,lpszSrcStr;
    LPTSTR lpszFontName;
    LPTSTR lpszTok;
    DWORD  dwType;
    DWORD  cbData;
    HKEY hKey;
    LONG rc;
    BOOL bRet = FALSE;
    HRESULT hresult;
    int      nSize;

    if ((!lpszLinkInfo) || (!lpbFontLinkRegistryTouched))
    {
        bRet = FALSE;
        goto Exit1;
    }
    lpszSrcStr = szStrBuf;

    lpszTok = _tcstok(lpszLinkInfo,szDeli);

    while (lpszTok) 
    {
        //*STRSAFE*         lstrcpy(lpszSrcStr,lpszTok);
        hresult = StringCchCopy(lpszSrcStr , ARRAYSIZE(szStrBuf), lpszTok);
        if (!SUCCEEDED(hresult))
        {
            bRet = FALSE;
            goto Exit1;
        }
        lpszSrcStr += (lstrlen(lpszTok) + 1);
        lpszTok = _tcstok(NULL,szDeli);
    }

    *lpszSrcStr = TEXT('\0');

    //
    // first token is base font name
    //

    lpszSrcStr = lpszFontName = szStrBuf;
    
    if (! *lpszFontName) 
    {
        //
        // there is no link info needs to be processed
        //

        bRet = FALSE;
        goto Exit1;
    }

    //
    // point to first linked font
    //
    lpszSrcStr += (lstrlen(lpszSrcStr) + 1);

    if (! *lpszSrcStr) 
    {
        //
        // no linked font
        //
        bRet = FALSE;
        goto Exit1;
    }

    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink"),
                        0L,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        NULL);

    if (rc != ERROR_SUCCESS) 
    {
        bRet = FALSE;
        goto Exit1;
    }   

    cbData = sizeof(szRegDataStr);

    rc = RegQueryValueEx(hKey,
                         lpszFontName,
                         NULL,
                         &dwType,
                         (LPBYTE) szRegDataStr,
                         &cbData);

    if (rc != ERROR_SUCCESS) 
    {
        //
        // case 1, this font's font link hasn't been set yet, or something wrong in old value
        //
        lpszDstStr = lpszSrcStr;
    } 
    else 
    {
        //
        // case 2, this font's font link list has been there
        //
        // we need check if new font is defined in font list or not.
        //
        while (*lpszSrcStr) 
        {

            lpszDstStr = szRegDataStr;
            nSize = ARRAYSIZE(szRegDataStr);

            while (*lpszDstStr) 
            {
                if (lstrcmpi(lpszSrcStr,lpszDstStr) == 0) 
                {
                    break;
                }
                lpszDstStr += (lstrlen(lpszDstStr) + 1);
                nSize -= (lstrlen(lpszDstStr) + 1);
            }

            if (! *lpszDstStr) 
            {
                //
                // the font is not in original linke font list then
                //
                // append to end of list
                //

                //
                // make sure this is a safe copy
                //
                if (lpszDstStr+(lstrlen(lpszSrcStr)+2) < szRegDataStr+FONTLINK_BUF_SIZE) 
                {
                    //*STRSAFE*                     lstrcpy(lpszDstStr,lpszSrcStr);
                    hresult = StringCchCopy(lpszDstStr , nSize, lpszSrcStr);
                    if (!SUCCEEDED(hresult))
                    {
                        bRet = FALSE;
                        goto Exit2;
                    }
                    lpszDstStr += (lstrlen(lpszDstStr) + 1);
                    *lpszDstStr = TEXT('\0');
                }
            }
            lpszSrcStr += (lstrlen(lpszSrcStr) + 1);
        }
        lpszDstStr = szRegDataStr;
    }

    //
    // in this step,lpszDstStr is new font link list
    //
    rc = RegSetValueEx( hKey,
                        lpszFontName,
                        0L,
                        REG_MULTI_SZ,
                        (LPBYTE)lpszDstStr,
                        MZStrLen(lpszDstStr));

    if (rc != ERROR_SUCCESS) 
    {
        goto Exit2;
    }

    bRet = TRUE;

    *lpbFontLinkRegistryTouched = TRUE;

Exit2:
    RegCloseKey(hKey);

Exit1:
    return bRet;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  MofCompileLanguages
//
//  Call the WBEM API to mofcompile the MFL's for each language
//
////////////////////////////////////////////////////////////////////////////////////

BOOL MofCompileLanguages(LPTSTR Languages)
{
    pfnMUI_InstallMFLFiles pfnMUIInstall = NULL;
    TCHAR  buffer[5];
    LPTSTR Language = Languages;
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];
    HMODULE hWbemUpgradeDll = NULL;
    TCHAR szDllPath[MAX_PATH];
    HRESULT hresult;

    if (!Languages)
    {
       return FALSE;
    }
    //
    // Load the WBEM upgrade DLL from system wbem folder
    //
    if (GetSystemDirectory(szDllPath, ARRAYSIZE(szDllPath)) && 
        PathAppend(szDllPath, TEXT("wbem\\wbemupgd.dll")))
    {        
        hWbemUpgradeDll = LoadLibrary(szDllPath);
    }

    //
    // Fall back to system default path if previous loading fails
    //
    if (!hWbemUpgradeDll)
    {
        hWbemUpgradeDll = LoadLibrary(TEXT("WBEMUPGD.DLL"));
        if (!hWbemUpgradeDll)
        {
            return FALSE;
        }
    }


    //
    // Hook function pointer
    //
    pfnMUIInstall = (pfnMUI_InstallMFLFiles)GetProcAddress(hWbemUpgradeDll, "MUI_InstallMFLFiles");

    if (pfnMUIInstall == NULL)
    {
        FreeLibrary(hWbemUpgradeDll);
        return FALSE;
    }

	// process each language
    while (*Language)
    {
        //*STRSAFE*         _tcscpy(buffer, Language);
        hresult = StringCchCopy(buffer , ARRAYSIZE(buffer),  Language);
        if (!SUCCEEDED(hresult))
        {
           FreeLibrary(hWbemUpgradeDll);
           return FALSE;
        }

		if (!pfnMUIInstall(buffer))
		{
			// log error for this language
            LoadString(ghInstance, IDS_MOFCOMPILE_LANG_L, lpMessage, ARRAYSIZE(lpMessage)-1);
			lppArgs[0] = (LONG_PTR)buffer;
            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          lpMessage,
                          0,
                          0,
                          lpMessage,
                          ARRAYSIZE(lpMessage)-1,
                          (va_list *)lppArgs);

			LogMessage(lpMessage);
		}

        while (*Language++)  // go to the next language and repeat
        {               
        }
    } // of while (*Language)

    FreeLibrary(hWbemUpgradeDll);
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateRegistry
//
//  Update the Registry to account for languages that have been installed
//
////////////////////////////////////////////////////////////////////////////////////

BOOL UpdateRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched)
{
    TCHAR  szRegPath[MAX_PATH];
    TCHAR  szValue[] = TEXT("1");
    LPTSTR Language;
    DWORD  dwErr;
    HKEY   hkey;
    DWORD  dwDisp;
    HRESULT hresult;
    
    if ((!Languages) || (!lpbFontLinkRegistryTouched))
    {
       return FALSE;
    }
    //*STRSAFE*     _tcscpy(szRegPath, TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\MUILanguages"));
    hresult = StringCchCopy(szRegPath , ARRAYSIZE(szRegPath),  TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\MUILanguages"));
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }

    dwErr = RegCreateKeyEx( HKEY_LOCAL_MACHINE,  // handle of an open key
                            szRegPath, // address of subkey name
                            0, // reserved
                            TEXT("REG_SZ"),   // address of class string
                            REG_OPTION_NON_VOLATILE ,  // special options flag
                            KEY_ALL_ACCESS,  // desired security access
                            NULL,
                            &hkey,  // address of szRegPath for opened handle
                            &dwDisp  // address of disposition value szRegPath
                          );

    if (dwErr != ERROR_SUCCESS)
    {
        return FALSE;
    }

    Language = Languages;
    
    if (!g_bLipLanguages || g_bLipAllowSwitch) {
        //*STRSAFE*         lstrcpy(szRegPath, TEXT("0409"));
        hresult = StringCchCopy(szRegPath , ARRAYSIZE(szRegPath),  TEXT("0409"));
        if (!SUCCEEDED(hresult))
        {
           RegCloseKey(hkey);
           return FALSE;
        }
        dwErr = RegSetValueEx( hkey,
                               szRegPath,
                               0,
                               REG_SZ,
                               (const BYTE *)szValue,
                               (lstrlen(szValue) + 1) * sizeof(TCHAR));
    }
    
    while (*Language)
    {
        TCHAR szFontLinkVal[FONTLINK_BUF_SIZE];
        DWORD dwNum;

        //*STRSAFE*         lstrcpy(szRegPath, Language);
        hresult = StringCchCopy(szRegPath , ARRAYSIZE(szRegPath),  Language);
        if (!SUCCEEDED(hresult))
        {
           RegCloseKey(hkey);
           return FALSE;
        }
        dwErr = RegSetValueEx( hkey,
                               szRegPath,
                               0,
                               REG_SZ,
                               (const BYTE *)szValue,
                               (lstrlen(szValue) + 1)*sizeof(TCHAR));

        if (dwErr != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return FALSE;
        }

        dwNum = GetPrivateProfileString(TEXT("FontLink"),
                                        szRegPath,
                                        TEXT(""),
                                        szFontLinkVal,
                                        (sizeof(szFontLinkVal)/sizeof(TCHAR)),
                                        g_szMUIInfoFilePath);
        if (dwNum) 
        {
            SetFontLinkValue(szFontLinkVal,lpbFontLinkRegistryTouched);
        }    

        while (*Language++);  // go to the next language and repeat
    } // of while (*Language)

    RegCloseKey(hkey);
    return TRUE;
}

void debug(char *printout)
{
#ifdef _DEBUG
    fprintf(stderr, "%s", printout);
#endif
}


////////////////////////////////////////////////////////////////////////////////////
//
//  MakeDir
//
//  Create the directory if it does not already exist
//
////////////////////////////////////////////////////////////////////////////////////


BOOL MakeDir(LPTSTR szTarget)
{
    TCHAR  lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];

    if (!szTarget)
    {
        return FALSE;
    }
    if (!FileExists(szTarget))    // if the directory doesn't exist yet
    {
        if (!CreateDirectory( szTarget, NULL))  // create it
        {
            //
            // "LOG: Error creating directory %1"
            //
            LoadString(ghInstance, IDS_CREATEDIR_L, lpMessage, ARRAYSIZE(lpMessage)-1);
            lppArgs[0]=(LONG_PTR)szTarget;

            FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          lpMessage,
                          0,
                          0,
                          lpMessage,
                          ARRAYSIZE(lpMessage)-1,
                          (va_list *)lppArgs);

            LogMessage(lpMessage);

            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          GetLastError(),
                          0,
                          lpMessage,
                          ARRAYSIZE(lpMessage)-1,
                          NULL);
                
            LogMessage(lpMessage);
            return FALSE;
        }
    }

    return TRUE;
}
                                

////////////////////////////////////////////////////////////////////////////////////
//
//  MakeDirFailed
//
//  Write message to log file that MakeDir failed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL MakeDirFailed(LPTSTR lpDirectory)
{   
    LONG_PTR lppArgs[1];

    if (!lpDirectory)
    {
       return FALSE;
    }
    //
    //      "LOG: MakeDir has failed: %1"
    //
    lppArgs[0]=(LONG_PTR)lpDirectory;
    LogFormattedMessage(NULL, IDS_MAKEDIR_L, lppArgs);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  CopyFileFailed
//  Write message to log file that CopyFile failed.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CopyFileFailed(LPTSTR lpFile,DWORD dwErrorCode)
{
    TCHAR lpMessage[BUFFER_SIZE];
    LONG_PTR lppArgs[1];
    DWORD  MessageID;

    if (!lpFile)
    {
       return FALSE;
    }
    if ( dwErrorCode)
    {
       MessageID = dwErrorCode;
    }
    else
    {
       MessageID = GetLastError();
    }
                                        
    //
    //      "LOG: CopyFile has failed: %1"
    //
    LoadString(ghInstance, IDS_COPYFILE_L, lpMessage, ARRAYSIZE(lpMessage)-1);
                                                
    lppArgs[0]=(LONG_PTR)lpFile;
        
    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   lpMessage,
                   0,
                   0,
                   lpMessage,
                   ARRAYSIZE(lpMessage)-1,
                   (va_list *)lppArgs);
                
    LogMessage(lpMessage);

    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                   NULL,
                   MessageID,
                   0,
                   lpMessage,
                   ARRAYSIZE(lpMessage)-1,
                   NULL);
        
    LogMessage(lpMessage);
        
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_InitInf
//
//  Parameters:
//  
//      [OUT] phInf     the handle to the INF file opened.
//      [OUT] pFileQueue    the file queue created in this function.
//      [OUT] pQueueContext the context used by the default queue callback routine included with the Setup API.
//
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_InitInf(
    HWND hDlg,
    LPTSTR pszInf,
    HINF *phInf,
    HSPFILEQ *pFileQueue,
    PVOID *pQueueContext)
{
    if ((! pszInf) || (!pFileQueue) || (!pQueueContext))
    {
        return FALSE;
    }
    //
    //  Open the Inf file.
    //
    *phInf = SetupOpenInfFile(pszInf, NULL, INF_STYLE_WIN4, NULL);
    if (*phInf == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    //  Create a setup file queue and initialize default setup
    //  copy queue callback context.
    //
    *pFileQueue = SetupOpenFileQueue();
    if ((!*pFileQueue) || (*pFileQueue == INVALID_HANDLE_VALUE))
    {
        SetupCloseInfFile(*phInf);
        return FALSE;
    }

    *pQueueContext = SetupInitDefaultQueueCallback(hDlg);
    if (!*pQueueContext)
    {
        SetupCloseFileQueue(*pFileQueue);
        SetupCloseInfFile(*phInf);
        return FALSE;
    }

    //
    //  Return success.
    //
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_CloseInf
//
////////////////////////////////////////////////////////////////////////////

BOOL Muisetup_CloseInf(
    HINF hInf,
    HSPFILEQ FileQueue,
    PVOID QueueContext)
{
    if (!QueueContext)
    {
       return FALSE;
    }
    //
    //  Terminate the Queue.
    //
    SetupTermDefaultQueueCallback(QueueContext);

    //
    //  Close the file queue.
    //
    SetupCloseFileQueue(FileQueue);

    //
    //  Close the Inf file.
    //
    SetupCloseInfFile(hInf);

    return TRUE;
}




////////////////////////////////////////////////////////////////////////////////////
//
//  ExecuteComponentINF
//
//  Installs component MUI files, by running the specified INF file.
//
//  Parameters:
//      pComponentName   the name of the component (e.g. "ie5")
//      pComponentInfFile: the full path of the component INF file.
//      pInstallSection the section in the component INF file to be executed. (e.g "DefaultInstall" or "Uninstall")
//
////////////////////////////////////////////////////////////////////////////////////

BOOL ExecuteComponentINF(
    HWND hDlg, PTSTR pComponentName, PTSTR pComponentInfFile, PTSTR pInstallSection, BOOL bInstall)
{
    int      iLen;
    TCHAR   tchCommandParam[BUFFER_SIZE];
    CHAR    chCommandParam[BUFFER_SIZE*sizeof(TCHAR)];
    
    HINF     hCompInf;      // the handle to the component INF file.
    HSPFILEQ FileQueue;
    PVOID    QueueContext;
    BOOL     bRet = TRUE;
    DWORD    dwResult;
    LONG_PTR lppArgs[3];

    TCHAR   szBuffer[BUFFER_SIZE];
    HRESULT hresult;
    if ((!pComponentName) || (!pComponentInfFile) || (!pInstallSection))
    {
       return FALSE;
    }
    //
    // Advpack LaunchINFSection() command line format:
    //      INF file, INF section, flags, reboot string
    // 'N' or  'n' in reboot string means no reboot message popup.
    //
    //*STRSAFE*     wsprintf(tchCommandParam, TEXT("%s,%s,0,n"), pComponentInfFile, pInstallSection);
    if (g_bNoUI)
    {
        hresult = StringCchPrintf(tchCommandParam , ARRAYSIZE(tchCommandParam),  TEXT("%s,%s,1,n"), pComponentInfFile, pInstallSection);
    }
    else
    {
        hresult = StringCchPrintf(tchCommandParam , ARRAYSIZE(tchCommandParam),  TEXT("%s,%s,0,n"), pComponentInfFile, pInstallSection);
    }
    
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    WideCharToMultiByte(CP_ACP, 0, tchCommandParam, -1, chCommandParam, sizeof(chCommandParam), NULL, NULL);
    
    
    if (FileExists(pComponentInfFile))
    {
        // gpfnLaunchINFSection won't be NULL since InitializePFNs() already verifies that.
        if ((gpfnLaunchINFSection)(hDlg, ghInstance, chCommandParam, g_bNoUI? SW_HIDE : SW_SHOW) != S_OK)
        {
            if (!g_bNoUI)
            {
                lppArgs[0] = (LONG_PTR)pComponentName;
                DoMessageBoxFromResource(hDlg, ghInstance, bInstall? IDS_ERROR_INSTALL_COMP_UI : IDS_ERROR_UNINSTALL_COMP_UI, lppArgs, IDS_ERROR_T, MB_OK);
            }
            else
            {
                lppArgs[0] = (LONG_PTR)pComponentName;
                LogFormattedMessage(ghInstance, bInstall? IDS_ERROR_INSTALL_COMP_UI : IDS_ERROR_UNINSTALL_COMP_UI, lppArgs);
            }
            return (FALSE);
        }
    } 
    
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  CheckProductType
//
//  Check product type of W2K
//
////////////////////////////////////////////////////////////////////////////////////
 BOOL CheckProductType(INT_PTR nType)
  {
      OSVERSIONINFOEX verinfo;
      INT64 dwConditionMask=0;
      BOOL  bResult=FALSE;
      DWORD dwTypeMask = VER_PRODUCT_TYPE;

      memset(&verinfo,0,sizeof(verinfo));
      verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

      VER_SET_CONDITION(dwConditionMask,VER_PRODUCT_TYPE,VER_EQUAL);

      switch (nType)
      {
           // W2K Professional
           case MUI_IS_WIN2K_PRO:
                verinfo.wProductType=VER_NT_WORKSTATION;
                break;
           // W2K Server
           case MUI_IS_WIN2K_SERVER:
                verinfo.wProductType=VER_NT_SERVER;
                break;
           // W2K Advanced Server or Data Center
           case MUI_IS_WIN2K_ADV_SERVER_OR_DATACENTER:
                verinfo.wProductType=VER_NT_SERVER;
                verinfo.wSuiteMask  =VER_SUITE_ENTERPRISE;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;
           // W2k Data Center
           case MUI_IS_WIN2K_DATACENTER:
                verinfo.wProductType=VER_NT_SERVER;
                verinfo.wSuiteMask  =VER_SUITE_DATACENTER;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;   
           // W2K Domain Controller
           case MUI_IS_WIN2K_DC:
                verinfo.wProductType=VER_NT_DOMAIN_CONTROLLER;
                break;
           case MUI_IS_WIN2K_ENTERPRISE:
                verinfo.wProductType=VER_NT_DOMAIN_CONTROLLER;
                verinfo.wSuiteMask  =VER_SUITE_ENTERPRISE;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;
           case MUI_IS_WIN2K_DC_DATACENTER:
                verinfo.wProductType=VER_NT_DOMAIN_CONTROLLER;
                verinfo.wSuiteMask  =VER_SUITE_DATACENTER;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_OR);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break; 
           // Whistler Personal                
           case MUI_IS_WIN2K_PERSONAL:
                verinfo.wProductType=VER_NT_WORKSTATION;
                verinfo.wSuiteMask  =VER_SUITE_PERSONAL;
                VER_SET_CONDITION(dwConditionMask,VER_SUITENAME,VER_AND);
                dwTypeMask = VER_PRODUCT_TYPE | VER_SUITENAME;
                break;
           default:
                verinfo.wProductType=VER_NT_WORKSTATION;
                break;
      }
      return (VerifyVersionInfo(&verinfo,dwTypeMask,dwConditionMask));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\installer.h ===
#ifndef __INSTALLER_H_
#define __INSTALLER_H_

#include "stdio.h"                               
#include "string.h"
#include <windows.h>
#include <fdi.h>

#ifdef _DEBUG
        #define INIFILE TEXT(".\\layout.inf")
#endif

#define MUIINFFILENAME          TEXT("mui.inf")
#define MUIINF                  TEXT(".\\mui.inf")
#define HELPDIR                 TEXT("HELP\\MUI")
#define MUI_LANGUAGES_SECTION   TEXT("Languages")
#define MUI_COMPONENTS_SECTION   TEXT("Components")
#define MUI_LANGPACK_SECTION    TEXT("LanguagePack")
#define MUI_DISPLAYNAME_SECTION TEXT("LanguageDisplayName")
#define MUI_COUNTRYNAME_SECTION TEXT("UseCountryName")
#define MUI_UIFILESIZE_SECTION  TEXT("FileSize_UI")
#define MUI_UIFILESIZE_SECTION_IA64   TEXT("FileSize_UI_IA64")
#define MUI_LPKFILESIZE_SECTION  TEXT("FileSize_LPK")
#define MUI_LPKFILESIZE_SECTION_IA64   TEXT("FileSize_LPK_IA64")
#define MUI_CDLAYOUT_SECTION    TEXT("CD_LAYOUT")
#define MUI_CDLAYOUT_SECTION_IA64    TEXT("CD_LAYOUT_IA64")
#define MUI_FILELAYOUT_SECTION  TEXT("File_Layout")
#define MUI_NOFALLBACK_SECTION  TEXT("FileType_NoFallback")
#define MUI_CDLABEL             TEXT("cdlabel")
#define MUI_LIP_LANGUAGES_SECTION       TEXT("LIP_Languages")
#define MUI_LIP_ALLOW_SWITCH_SECTION    TEXT("LIP_Allow_Switch")

#define PLATFORMNAME_PRO        TEXT("P")
#define PLATFORMNAME_SRV        TEXT("S")
#define PLATFORMNAME_AS         TEXT("A")
#define PLATFORMNAME_DTC        TEXT("D")
                                  

#define IE5_MUIINF_FILE        TEXT("ie5ui.inf")
#define IE5_MUI_DIR            TEXT("ie5")
#define IE5_INSTALL_SECTION    TEXT("DefaultInstall")
#define IE5_UNINSTALL_SECTION  TEXT("Uninstall")
#define IE5_Satellite_HOME     TEXT("Program Files\\Internet Explorer\\MUI\\")
#define IE5_Satellite_WEB      TEXT("web\\mui\\")
#define IE5_Satellite_JAVA     TEXT("Java\\Help\\")
#define IE5_Satellite_HH       TEXT("system32\\mui\\")

#define DEFAULT_CD_NUMBER      2
#define MFL                    20
#define DIRNUMBER              100
#define FILERENAMENUMBER       200
#define NOTFALLBACKNUMBER      20

#define MUIDIR          TEXT("MUI")
#define FALLBACKDIR     TEXT("\\MUI\\FALLBACK")

//
// max size of fontlink string, same as GRE
//
#define FONTLINK_BUF_SIZE MAX_PATH+LF_FACESIZE

//
// Diamond definitions/structures (diamond.c)
//
#define DIAMOND_NONE                0x00000000
#define DIAMOND_GET_DEST_FILE_NAME  0x00000001
#define DIAMOND_FILE                0x00000002

#define MUI_IS_WIN2K_PRO        0
#define MUI_IS_WIN2K_SERVER     1
#define MUI_IS_WIN2K_ADV_SERVER_OR_DATACENTER 2
#define MUI_IS_WIN2K_DATACENTER 3
#define MUI_IS_WIN2K_DC         4
#define MUI_IS_WIN2K_ENTERPRISE     5
#define MUI_IS_WIN2K_DC_DATACENTER  6
#define MUI_IS_WIN2K_PERSONAL   7

typedef struct 
{
    UINT flags;

    char szSrcFileName[ MAX_PATH ];

    char szSrcFilePath[ MAX_PATH ];

    char szDestFilePath[ MAX_PATH ];

} DIAMOND_PACKET, *PDIAMOND_PACKET;



//
// Diamond APIs (diamond.c)
//
HFDI Muisetup_InitDiamond();

BOOL Muisetup_FreeDiamond();

void Muisetup_DiamondReset(
    PDIAMOND_PACKET pDiamond);


BOOL Muisetup_IsDiamondFile(
    PWSTR pwszFileName,
    PWSTR pwszOriginalName,
    INT nSize,
    PDIAMOND_PACKET pDiamond);

BOOL Muisetup_CopyDiamondFile(
    PDIAMOND_PACKET pDiamond,
    PWSTR pwszCopyTo);


int EnumLanguages(LPTSTR Languages, BOOL bCheckDir = TRUE);
BOOL checkversion(BOOL bMatchBuildNumber);
BOOL FileExists(LPTSTR szFile);
BOOL EnumDirectories(void);
BOOL EnumFileRename();
BOOL EnumTypeNotFallback();
BOOL CopyFileFailed(LPTSTR lpFile, DWORD dwErrorCode);
BOOL CopyFiles(HWND hWnd, LPTSTR Languages);
BOOL MofCompileLanguages(LPTSTR Languages);
BOOL UpdateRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
BOOL UpdateRegistry_FontLink(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
BOOL MakeDir(LPTSTR szTarget);
BOOL MakeDirFailed(LPTSTR lpDirectory);
BOOL ExecuteComponentINF(
    HWND hDlg, PTSTR pComponentName, PTSTR pComponentInfFile, PTSTR pInstallSection, BOOL bInstall);

BOOL CheckLanguageDirectoryExist(LPTSTR Languages);
BOOL CheckProductType(INT_PTR nType);
BOOL CompareMuisetupVersion(LPTSTR pszSrc,LPTSTR pszTarget);
BOOL IsFileBeRenamed(LPTSTR lpszSrc,LPTSTR lpszDest);
BOOL IsFileInRenameTable(LPTSTR lpszSrc);
BOOL InstallComponentsMUIFiles(PTSTR pszLangSourceDir, PTSTR pszLanguage, BOOL isInstall);

#endif //__INSTALLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\msiguids.h ===
//
// Msiguilds.h
//
// This file contains the Product codes for each of the MSI packages that we have built for all the MUI Languages that
// are supported on the I386 platform.  The GUIDs are taken from mui\msi\guidlang.txt and reproduced here.
// In the future we should use some automated tool in pre-build to generate this file from guidlang.txt but for now they
// are copied here in its entirety.
//  
// The product codes are used by muisetup.exe when it tries to unstall the MSI package from the target system. 
//
// Created: Ken Hsu

#define NUM_PRODUCTS    35
#define GUIDLENGTH      48

struct MUIProduct
{
    TCHAR szLanguage[5];
    TCHAR szProductGUID[GUIDLENGTH];
};

MUIProduct g_mpProducts[NUM_PRODUCTS] =                                              
    {   TEXT("0411"), TEXT("{FD2C1642-21F5-4520-A216-919DCFEB4115}"),  
        TEXT("0404"), TEXT("{460F7060-7E27-41CA-ABA3-59946C28DADE}"),  
        TEXT("040C"), TEXT("{45E81489-6E7A-467D-A77A-AEC8F63EBE1A}"),   
        TEXT("040A"), TEXT("{02926251-EDD8-44CF-A63B-D783FFDEA5ED}"),   
        TEXT("0410"), TEXT("{6668D8AC-A745-4374-A47F-B00476BABDD8}"),   
        TEXT("041D"), TEXT("{F61C1248-2BC0-4F99-8234-430339EBD885}"),   
        TEXT("0413"), TEXT("{EF1EB825-0F19-4F02-9E31-CCE4BDD4C374}"),   
        TEXT("0416"), TEXT("{7B56D54F-EEE7-4935-810C-739346DB6E92}"),   
        TEXT("040B"), TEXT("{F2AA2E5C-D22A-43A8-937D-23560AC053EA}"),   
        TEXT("0414"), TEXT("{E06D561E-4C3D-456D-895E-A55D3E29E0A1}"),   
        TEXT("0406"), TEXT("{F9539F6F-2B8D-4A1A-B6DA-2D3B9484CD4B}"),   
        TEXT("040E"), TEXT("{A1273A21-6B65-47F0-922D-39D50603800F}"),   
        TEXT("0415"), TEXT("{65AA9C82-3DC9-42DD-8D80-8B0FF37AD348}"),   
        TEXT("0419"), TEXT("{3515EAE6-2D7C-41FC-A32A-13E247A9582B}"),      
        TEXT("0405"), TEXT("{E5D7626A-6EDE-49EC-82CD-417E122FF677}"),   
        TEXT("0408"), TEXT("{4FD03CB0-FE9C-4C81-BD81-EA0B8DDEE903}"),   
        TEXT("0816"), TEXT("{0997F1B3-142E-41CF-8F32-371B0414FAD9}"),   
        TEXT("041F"), TEXT("{538C7A8A-3B0B-4D91-86D4-5119591B9F9D}"),   
        TEXT("0412"), TEXT("{910B708D-8995-4517-A413-B6FC0A434027}"),  
        TEXT("0407"), TEXT("{E23F7A6E-7010-4Af4-8EDF-9B85B2310F48}"),  
        TEXT("0804"), TEXT("{86087E1E-22B0-4078-B185-35E1444B333E}"),  
        TEXT("0401"), TEXT("{C196DE0C-7165-49B2-9B3D-64B017504002}"),  
        TEXT("040D"), TEXT("{0C81880B-AE56-4027-BF0A-73AD35DC672E}"),  
        TEXT("0403"), TEXT("{4B88AB75-CA1B-4093-ADCE-245FE2479F2F}"),      
        TEXT("041F"), TEXT("{2E055E42-6B5A-4DB1-ABB6-F75FD2F8CE74}"),  
        TEXT("041B"), TEXT("{C777A991-2523-4AFD-BC63-77DCEBB740A4}"),   
        TEXT("0424"), TEXT("{21AB9081-5B7A-4292-8145-03C7C6095B50}"),   
        TEXT("0418"), TEXT("{99252E8F-2743-439E-BA7A-3EC5B6202529}"), 
        TEXT("041A"), TEXT("{972F0F24-3537-48B3-84A6-DED7EAFA8245}"),     
        TEXT("0402"), TEXT("{C7254F49-D081-47AA-9EBD-20160321D175}"),   
        TEXT("0425"), TEXT("{380921D2-E1B3-4D6C-B559-6C4C45A8B67D}"),   
        TEXT("0427"), TEXT("{BA52E84A-593D-4865-A3DD-B6BF54319C9F}"),   
        TEXT("0426"), TEXT("{F3B12A06-F6FC-4F2B-8655-1644691DBE88}"),   
        TEXT("041E"), TEXT("{8E3265B2-F2D7-41B4-8D5E-BE57B4372E93}"),
        TEXT("0C0A"), TEXT("{02926251-EDD8-44CF-A63B-D783FFDEA5ED}")
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by muisetup.rc
//
#define MUI_ICON                        1
#define IDS_WRONG_VERSION               3
#define IDS_SUCCESS                     4
#define IDS_COMPLETE_T                  5
#define IDS_ERROR                       6
#define IDS_NO_LANG_L                   7
#define IDS_INVALID_DEFAULT             9
#define IDS_DEFAULT_T                   10
#define IDS_NO_SUPPORT_T                11
#define IDS_NO_SUPPORT                  12
#define IDS_DIRECTORY_L                 13
#define IDS_COPY_L                      14
#define IDS_REGISTRY_L                  15
#define IDS_DELETE_L                    16
#define IDS_WAS_NOT_INSTALLED_L         17
#define IDS_IS_INSTALLED_L              18
#define IDS_NOT_LISTED_L                19
#define IDS_WAS_NOT_UNINSTALLED_L       20
#define IDS_IS_NOT_INSTALLED_L          21
#define IDS_ADMIN_L                     22
#define IDS_NO_SUPPORT_L                23
#define IDS_DEFAULT_L                   24
#define IDS_SUCCESS_L                   25
#define IDS_LOG_HEAD                    26
#define IDS_NO_READ_L                   27
#define IDS_HANDLE_L                    28
#define IDS_PROCADD_L                   29
#define IDS_COPYFILE_L                  30
#define IDS_MAKEDIR_L                   31
#define IDS_NO_CHECK_L                  32
#define IDS_CREATEDIR_L                 33
#define IDS_INSTALLING                  34
#define IDS_UNINSTALLING                35
#define IDS_SETTING                     36
#define IDS_HELP_T                      37
#define IDS_HELP                        38
#define IDS_INSTALLLANGGROUP            39
#define IDS_CHECK_LANG_GROUP            40
#define IDS_ERROR_FILE_CREATE           41
#define IDS_ERROR_LAUNCH_INTLCPL        42
#define IDS_MAIN_TITLE                  43
#define IDS_ALREADY_RUNNING             44
#define IDS_APP                         45
#define IDS_ERROR_NT5_ONLY              46
#define IDS_REBOOT_STRING               47
#define IDS_CHANGE_UI_LANG              48
#define IDS_DEFAULT_USER_ERROR          49
#define IDS_ERROR_INSTALL_COMP_UI       50
#define IDS_ERROR_SETUP_COMP_UI         51
#define IDS_INSTALLING_COMP_MUI         52
#define IDS_REMOVING_COMP_MUI           53
#define IDS_MUI_CHS                     54
#define IDS_MUI_CHT                     55
#define IDS_LG_NOT_INSTALL              56
#define IDS_CHANGE_CDROM                57     
#define IDS_INSTALL_TITLE               58
#define IDS_PROG_TITLE_2                59
#define IDS_IS_TSCLIENT                 60
#define IDS_SUCCESS_UNINSTALL           61
#define IDS_COMPLETE_T_UNINSTALL        62
#define IDS_WRONG_NTAS                  63
#define IDS_NOT_QUALIFIED_L             64
#define IDS_CHANGE_CDROM2               66
#define IDS_DISKSPACE_NOTENOUGH         68
#define IDS_ERROR_DISKSPACE             69
#define IDS_MUST_REBOOT_STRING1         70
#define IDS_NO_MUI_FILE                 71
#define IDS_HELPFILE                    72
#define IDS_ERROR_T                     73
#define IDS_COMP_MISSING_NAME_L         75
#define IDS_COMP_MISSING_DIR_L          76
#define IDS_COMP_MISSING_INF_L          77
#define IDS_COMP_MISSING_INF_FILE_L     78
#define IDS_COMP_COPY_FILES_ERROR_L     79
#define IDS_COMP_INSTALL_ERROR_L        80
#define IDS_OUT_OF_MEMORY               81
#define IDS_OUT_OF_MEMORY_L             82
#define IDS_LOAD_ADVPACK_L              83
#define IDS_LOAD_ADVPACK_API_L          84
#define IDS_PROG_TITLE_3                85
#define IDS_WRONG_IMAGE                 86  
#define IDS_ADMIN                       87
#define IDS_UNINSTALL_TITLE             88
#define IDS_ERROR_NO_LANG_ARG           89
#define IDS_MUISETUP_SUCCESS            90
#define IDS_COMMAND_LOG                 91
#define IDS_LANG_INSTALLED              92
#define IDS_LANG_UNINSTALLED            93
#define IDS_SET_UILANG_CURRENT          94
#define IDS_ERROR_SET_UILANG_CURRENT    95
#define IDS_SET_UILANG_ALLUSERS         96
#define IDS_ERROR_SET_UILANG_ALLUSERS   97
#define IDS_CHANGE_UI_NEED_RBOOT        98
#define IDS_NO_MUI_LANG                 99
#define IDS_CHANGE_UI_NEED_RBOOT_SYSTEM_LCID    100
#define IDS_LANG_IN_ANOTHER_CD_L        101
#define IDS_MUST_REBOOT_STRING2         102
#define IDS_MOFCOMPILE_L                103
#define IDS_MOFCOMPILE_LANG_L           104
#define IDS_LG_NOT_INSTALL_L            105
#define IDS_MUISETUP_UNINSTALL_SUCCESS  106
#define IDS_ERROR_UNINSTALL_COMP_UI     107
#define IDS_CANCEL_INSTALLATION         108
#define IDS_ERROR_INSTALL_LANGMSI       109
#define IDS_ERROR_UNINSTALL_LANGMSI     110
#define IDS_ERROR_INSTALL_LANG          111
#define IDS_ERROR_UNINSTALL_LANG        112
#define IDS_SUCCESS_INSTALL_LANG        113
#define IDS_SUCCESS_UNINSTALL_LANG      114
#define IDS_LOAD_USERENV_L              115
#define IDS_LOAD_SXS_L                  116
#define IDS_NTOS_SETUP_MSI_ERROR        117
#define IDS_MUI_OLD_SETUP               118
#define IDS_CHANGE_CDROM3               119     
//
// Dialogs
//

#define IDD_DIALOG_MAIN                 102
#define IDD_DIALOG_INSTALL_PROGRESS     105
#define IDD_DIALOG_PROGRESS_LG          106
#define IDD_WELCOME                     107

#define IDC_DEF_UI_LANG_COMBO                      1001
#define IDC_LIST1                       1002
#define IDC_LIST6                       1010
#define IDC_LIST2                       1013
#define IDC_PROGRESS1                   1016
#define IDC_STATUS                      1022
#define IDC_WELCOME_LINE                1023
#define IDC_EDIT_LICENSE                1024
#define IDC_CHECK_LICENSE               1025
#define IDC_README                      1027
#define IDC_CHECK_LOCALE                1028
#define IDC_CHECK_UIFONT                1029
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\msiguids64.h ===
//
// Msiguilds.h
//
// This file contains the Product codes for each of the MSI packages that we have built for all the MUI Languages that
// are supported on the IA64 platform.  The GUIDs are taken from mui\msi\guidlang.txt and reproduced here.
// In the future we should use some automated tool in pre-build to generate this file from guidlang.txt but for now they
// are copied here in its entirety.
//  
// The product codes are used by muisetup.exe when it tries to unstall the MSI package from the target system. 
//
// Created: Ken Hsu

#define NUM_PRODUCTS    35
#define GUIDLENGTH      48

struct MUIProduct
{
    TCHAR szLanguage[5];
    TCHAR szProductGUID[GUIDLENGTH];
};

MUIProduct g_mpProducts[NUM_PRODUCTS] =                                              
    {   TEXT("0411"), TEXT("{FF62CFC4-DF40-41E8-8721-5D6525390D0F}"),
        TEXT("0404"), TEXT("{E65E1CE7-F524-424B-9961-D71FA977302A}"),	
        TEXT("040C"), TEXT("{DFCF2641-4591-49BC-B98F-02132910B49D}"),	
        TEXT("040A"), TEXT("{D1F44D16-06BF-4B73-BF63-173FCB452951}"),	
        TEXT("0410"), TEXT("{78E9076B-0826-44EF-A77A-31F47FD478B3}"),	
        TEXT("041D"), TEXT("{11522C10-AA18-4aBD-8A3B-5EA1CBC8334D}"),
        TEXT("0413"), TEXT("{384028CF-4143-41B5-BA2F-D7DE559BAF70}"),	
        TEXT("0416"), TEXT("{98E331F5-FBCE-4A75-98C0-D76ED985EC57}"),	
        TEXT("040B"), TEXT("{54DFB1F0-C2C8-4725-8500-946144D3F59D}"),	
        TEXT("0414"), TEXT("{7AC38B03-D9C4-44A1-9C61-C35C49A29E76}"),
        TEXT("0406"), TEXT("{A57BC471-483D-4FA3-87B8-610997EE4711}"),	
        TEXT("040E"), TEXT("{0C007D5E-05D5-4D0A-8C9C-517F946C8DCA}"),
        TEXT("0415"), TEXT("{68AC930B-C325-468E-972B-CEE51F3B0D8A}"),	
        TEXT("0419"), TEXT("{C6342201-950F-4027-A04D-E7C5C70B0356}"),	
        TEXT("0405"), TEXT("{0457A5EF-A6DD-4D09-8299-84253381B96D}"),	
        TEXT("0408"), TEXT("{A4919442-CCEF-4D0E-9218-E76F5779D4E1}"),	
        TEXT("0816"), TEXT("{3173F58B-B7F1-4990-B0ED-091004759F19}"),	
        TEXT("041F"), TEXT("{57497BD8-AB66-4F3B-8FFA-02A6B36D9457}"),
        TEXT("0412"), TEXT("{907FE868-2167-4F33-9A35-2235D2AFD3D7}"),
        TEXT("0407"), TEXT("{02194273-C296-4CB6-83EE-E4DB8C2EEA36}"),	
        TEXT("0804"), TEXT("{FAD6C901-F6CD-4D73-8029-1CE86B4091FF}"),	
        TEXT("0401"), TEXT("{3FA64949-6CEC-4D00-83B5-CBCA17230BB6}"),	
        TEXT("040D"), TEXT("{E9DFD761-ECA8-496D-B32C-AA5E6B28B5E4}"),	
        TEXT("0403"), TEXT("{275CCA0F-B27B-403F-8868-87FE7768616F}"),
        TEXT("041F"), TEXT("{304D8589-DC1B-49B2-BD8C-A4C9A07BC228}"),
        TEXT("041B"), TEXT("{8FC101AA-F493-4B01-B4E0-7ACDCCDAAC98}"),	
        TEXT("0424"), TEXT("{600AF96B-380D-47EB-9E44-1AE540260930}"),	
        TEXT("0418"), TEXT("{67E0ED33-320C-4439-B6C9-2F823CDB022A}"),
        TEXT("041A"), TEXT("{8B1AF525-D649-4F1E-BC76-84772029E96C}"),	
        TEXT("0402"), TEXT("{9840B9A5-34FD-4486-A79E-47D11F9DD873}"),	
        TEXT("0425"), TEXT("{7A379537-7803-4B11-9740-3CDE637B9FCC}"),	
        TEXT("0427"), TEXT("{1CA76743-1DF0-4311-935E-87C9B973DA6A}"),	
        TEXT("0426"), TEXT("{B906AE81-CBB2-4E61-A551-F521D0843882}"),	
        TEXT("041E"), TEXT("{57922BCA-399C-4B6E-988B-0A0CB27AC051}"),
        TEXT("0C0A"), TEXT("D1F44D16-06BF-4B73-BF63-173FCB452951}")
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\welcome.cpp ===
#include "muisetup.h"
#include <shlwapi.h>
#include <shellapi.h>
#define STRSAFE_LIB
#include <strsafe.h>

#define README_FILENAME TEXT("README.TXT")
#define EULA_FILENAME   TEXT("EULA.TXT")

BOOL g_bLicenseAccepted;


INT_PTR 
CALLBACK
WelcomeDialogProc(HWND   hWndDlg, UINT   uMsg, WPARAM wParam, LPARAM lParam)
{ 
    HANDLE hFile=INVALID_HANDLE_VALUE;
    DWORD  dwFileSize;
    DWORD  dwActual;
    LPVOID pFileBuffer; 
    TCHAR   szEulaPath[MAX_PATH];
    BOOL bResult = FALSE;
    HRESULT hresult;

    switch ( uMsg ) {

        case WM_INITDIALOG:
            
            //
            // Load EULA file from the path where MUISETUP was lunched
            //
            GetModuleFileName( NULL, szEulaPath, ARRAYSIZE( szEulaPath ));

            //*STRSAFE*             lstrcpy(StrRChrI(szEulaPath, NULL, TEXT('\\'))+1, EULA_FILENAME);
            hresult = StringCchCopy(StrRChrI(szEulaPath, NULL, TEXT('\\'))+1, ARRAYSIZE(szEulaPath) - lstrlen(szEulaPath), EULA_FILENAME);            
            if (!SUCCEEDED(hresult))
            {
               return 1;
            }

            hFile = CreateFile(
                        szEulaPath,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                dwFileSize = GetFileSize( hFile, NULL );

                if ( dwFileSize != -1 ) {

                    pFileBuffer = LocalAlloc(LPTR, dwFileSize + 1 );

                    if ( pFileBuffer ) {

                        if ( ReadFile( hFile, pFileBuffer, dwFileSize, &dwActual, NULL )) {

                            //
                            // Make sure to NULL terminate the string
                            //
                            *((PCHAR)((PCHAR)pFileBuffer + dwFileSize)) = 0x00;

                            //
                            // Use ANSI text
                            //
                            SetDlgItemTextA( hWndDlg, IDC_EDIT_LICENSE, (LPCSTR)pFileBuffer );
                            bResult = TRUE;
                            }                        
                        LocalFree( pFileBuffer );
                        }
                    }
                }
            SetFocus( GetDlgItem( hWndDlg, IDC_CHECK_LICENSE ));
            if ( hFile != INVALID_HANDLE_VALUE )
            {
                CloseHandle(hFile);
            }
            if (! bResult)
            {
               EndDialog( hWndDlg, ERROR_CANCELLED );
               return 1;
            }
            else
            {            
               return 0;
            }

        case WM_COMMAND:

            switch ( LOWORD( wParam )) 
            {
                case IDOK:
                    g_bLicenseAccepted = ( IsDlgButtonChecked( hWndDlg, IDC_CHECK_LICENSE ) == BST_CHECKED );
                    EndDialog( hWndDlg, 0 );
                    return 1;

                case IDCANCEL:
                    EndDialog( hWndDlg, ERROR_CANCELLED );
                    return 1;

                case IDC_README:
                    {
                        // invoke notepad.exe open readme.txt
                        TCHAR szReadMePath[MAX_PATH];
                        SHELLEXECUTEINFO ExecInfo = {0};                        

                        GetModuleFileName(NULL, szReadMePath, sizeof(szReadMePath)/sizeof(TCHAR));
                        //*STRSAFE*                         lstrcpy(StrRChrI(szReadMePath, NULL, TEXT('\\'))+1, README_FILENAME);                       
                        hresult = StringCchCopy(StrRChrI(szReadMePath, NULL, TEXT('\\'))+1, ARRAYSIZE(szReadMePath) - lstrlen(szReadMePath), README_FILENAME);            
                        if (!SUCCEEDED(hresult))
                        {
                           return 1;
                        }
                        
                        ExecInfo.lpParameters    = szReadMePath;
                        ExecInfo.lpFile          = TEXT("NOTEPAD.EXE");
                        ExecInfo.nShow           = SW_SHOWNORMAL;
                        ExecInfo.cbSize          = sizeof(SHELLEXECUTEINFO);                 
                        ShellExecuteEx(&ExecInfo);
                    }
                    return 1;

                case IDC_CHECK_LICENSE:
                    EnableWindow( GetDlgItem( hWndDlg, IDOK ), IsDlgButtonChecked( hWndDlg, IDC_CHECK_LICENSE ) == BST_CHECKED );
                    return 1;

            }
            break;

        case WM_CLOSE:
            EndDialog( hWndDlg, ERROR_CANCELLED );
            return 1;

        }

    return 0;
}


BOOL
WelcomeDialog(HWND hWndParent)
{
    INT_PTR Status;

    Status = DialogBox(
                 NULL,
                 MAKEINTRESOURCE( IDD_WELCOME ),
                 hWndParent,
                 WelcomeDialogProc
                 );

    return (( Status == ERROR_SUCCESS ) && ( g_bLicenseAccepted ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\sources.inc ===
TARGETNAME=muisetup
TARGETPATH=obj
TARGETTYPE=PROGRAM

USE_MSVCRT=1

SOURCES=\
        ..\muisetup.rc   \
        ..\muisetup.cpp  \
        ..\installer.cpp \
        ..\diamond.cpp   \
        ..\welcome.cpp

INCLUDES=$(INCLUDES);$(BASE_INC_PATH);$(SHELL_INC_PATH)

C_DEFINES= -DUNICODE -D_UNICODE
LINKER_FLAGS = /SWAPRUN:CD

UMTYPE=windows
UMENTRY=winmain
TARGETLIBS=\
    $(SDK_LIB_PATH)\comctl32.lib   \
    $(SDK_LIB_PATH)\setupapi.lib   \
    $(SDK_LIB_PATH)\shlwapi.lib    \
    $(SDK_LIB_PATH)\shell32.lib    \
    $(SDK_LIB_PATH)\version.lib    \
    $(SDK_LIB_PATH)\lz32.lib       \
    $(SDK_LIB_PATH)\msi.lib        \
    $(SHELL_LIB_PATH)\shell32p.lib \
    $(SDK_LIB_PATH)\strsafe.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\muisetup.h ===
#ifndef __MUISETUP_H_
#define __MUISETUP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <winnls.h>
#include "installer.h"
#include "resource.h"
#include "sxsapi.h"



#define SUPPORT_PSEUDO_BUILD
//#define IGNORE_COPY_ERRORS

#define MUISETUP_HELP_FILENAME         TEXT("muisetup.hlp")
#define MUISETUP_EXECUTION_FILENAME    TEXT("muisetup.exe")
#define MUISETUP_ASSEMBLY_INSTALLATION_LOG_FILENAME TEXT("muisetup.log.") // langid would be ext

#define MUISETUP_ASSEMBLY_INSTALLATION_REFERENCE_IDENTIFIER TEXT("MUISETUP installation");

#define MUISETUP_PATH_SEPARATOR        TEXT("\\")

#define MUISETUP_FORWARDCALL_TAG       TEXT("/$_transfer_$")
#define MUI_FILLER_CHAR                TEXT('?')

#ifdef MUI_DEDUG
#define DEBUGMSGBOX(a, b, c, d) MessageBox(a, b, c, d)
#else
#define DEBUGMSGBOX(a, b, c, d) 
#endif


//
// Context Help IDs for Muisetup
//
#define IDH_COMM_GROUPBOX              28548
#define IDH_MUISETUP_UILANGUAGE_LIST   3000
#define IDH_MUISETUP_UILANGUAGECOMBO   3001
#define IDH_MUISETUP_COMMANDLINE       3002
#define IDH_MUISETUP_CHECKLOCALE       3003
#define IDH_MUISETUP_MATCHUIFONT       3004
#define MAX_UI_LANG_GROUPS             64
#define INSTALLED_FILES                1500


#define MAX_MUI_LANGUAGES   32

#define MESSAGEBOX(hWnd, lpText, lpCaption, uiType)  (g_bSilent || g_bNoUI ? IDNO : MessageBox(hWnd, lpText, lpCaption, uiType))

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

#define BUFFER_SIZE 1024

#define MUI_MATCH_LOCALE    0x0001
#define MUI_MATCH_UIFONT    0x0002

#define REGSTR_MUI_SETTING  TEXT("System\\CurrentControlSet\\Control\\NLS\\MUILanguages")
#define REGSTR_VALUE_MATCH_LOCALE TEXT("MatchSystemLocale")
#define REGSTR_VALUE_MATCH_UIFONT TEXT("UIFontSubstitute")

#define REG_MUI_MSI_COUNT       5
#define REGSTR_HKLM_MUI_MSI1  	TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall") //HKLM - need to append PID after that
#define REGSTR_HKLM_MUI_MSI2  	TEXT("Software\\Classes\\Installer\\Products")                  //HKLM - need to append reversed PID after that
#define REGSTR_HKLM_MUI_MSI3  	TEXT("Software\\Classes\\Installer\\Features")                  //HKLM - need to append reversed PID after that
#define REGSTR_HKR_MUI_MSI4  	TEXT("Installer\\Features")                                     //HCR - need to append reversedP ID after that
#define REGSTR_HKR_MUI_MSI5  	TEXT("Installer\\Products")                                     //HCR - need to append reversed PID after that

#define IS_FE_LANGPACK(lcid) (((lcid) == 0x0804) || ((lcid) == 0x0404) || ((lcid)==0x0411) || ((lcid)==0x0412))

enum GUIDStringType
{
    REVERSED_GUID       = 0,
    NORMAL_GUID         = 1
};

typedef struct _MUIMSIREGINFO_structtag
{
    HKEY	hkRegRoot;                  // the root of the reg hive where subkey lives in (e.g. hklm)
    TCHAR	szRegString[BUFFER_SIZE];   // The regkey path to the parent note of the subkey
    GUIDStringType RegType;             // used to indicate whether the product guid needs to be reversed when deleting key
} MUIMSIREGINFO, *PMUIMSIREGINFO;

//
// MUI Language Info attached to listview item
//
typedef struct _MUILANGIINFO_structtag
{
    LGRPID lgrpid;               // MUI's Lang Group

    LCID   lcid;                 // MUI's Lang LCID

    LPTSTR lpszLcid;             // MUI's LCID name

    TCHAR  szDisplayName[BUFFER_SIZE];    // The display for this language.

    int    cd_number;
    INT64  ulLPKSize;            // Size of LPK for this LCID 
    INT64  ulUISize;             // Size of MUI Resource files for this LCID

} MUILANGINFO, *PMUILANGINFO;


typedef struct _INSTALL_LANG_GROUP_Structtag
{
    LGRPID lgrpid[MAX_MUI_LANGUAGES];   // MUI Lang Group to install

    int    iCount;                      // count of MUI lang group to install
    BOOL   bFontLinkRegistryTouched;    // We have touched font link registry
    int    NotDeleted;

} INSTALL_LANG_GROUP, *PINSTALL_LANG_GROUP;

typedef struct UI_LangGroup_Structtag
{
    int    iCount;
    
    LCID lcid[MAX_UI_LANG_GROUPS];

} UILANGUAGEGROUP, *PUILANGUAGEGROUP;

typedef struct _FILERENAME_TABLE_Structtag
{
   TCHAR   szSource[MAX_PATH+1];
   TCHAR   szDest  [MAX_PATH+1];
}  FILERENAME_TABLE,*PFILERENAME_TABLE;

typedef struct _TYPENOTFALLBACK_TABLE_Structtag
{
   TCHAR   szSource[MAX_PATH+1];
} TYPENOTFALLBACK_TABLE,*PTYPENOTFALLBACK_TABLE;


//
//...Macro for ListView checkboxes
//
#ifndef ListView_SetCheckState
   #define ListView_SetCheckState(hwndLV, i, fCheck) \
      ListView_SetItemState(hwndLV, i, \
      INDEXTOSTATEIMAGEMASK((fCheck)+1), LVIS_STATEIMAGEMASK)
#endif

#define MSILOG_FILE TEXT("\\muimsi.log")
#define LOG_FILE TEXT("\\muisetup.log")
#define REG_MUI_PATH TEXT("System\\CurrentControlSet\\Control\\Nls\\MUILanguages")
#define REG_FILEVERSION_PATH TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\MUILanguages\\FileVersions")
#define MUI_LANG_GROUP_FILE TEXT("muilang.txt")
#define RUNDLLNAME          TEXT("system32\\rundll32.exe")
#define WINHELP32PATH       TEXT("winhlp32.exe")
extern UINT (WINAPI *pfnGetWindowsDir)(LPWSTR pBuf, UINT uSize);

BOOL DeleteSideBySideMUIAssemblyIfExisted(LPTSTR Languages, TCHAR buf[BUFFER_SIZE]);

BOOL CheckMultipleInstances(void);
void InitGlobals(void);
void Muisetup_Cleanup();
void SetSourcePath(LPTSTR lpszPath);
LPTSTR NextCommandTag(LPTSTR lpcmd);
BOOL InitializePFNs();

void Muisetup_RebootTheSystem(void);
BOOL CheckForReboot(HWND hwnd, PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL CheckDefault(HWND hwndDlg);
BOOL CheckLangGroupCommandLine(PINSTALL_LANG_GROUP pInstallLangGroup, LPTSTR lpArg);
BOOL DeleteFiles(LPTSTR Languages,int *lpNotDeleted);
int  EnumSelectedLanguages(HWND hList, LPTSTR lpAddLanguages);
int  EnumUnselectedLanguages(HWND hList, LPTSTR lpRemoveLanguages);
BOOL HaveFiles(LPTSTR lpBuffer, BOOL bCheckDir = TRUE);
BOOL InitializeInstallDialog(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL InitializeListView(HWND hList);
BOOL UpdateFontLinkRegistry(LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
BOOL IsInstalled(LPTSTR lpUILang);
DWORD GetInstalledMUILanguages(LPTSTR lpUninstall, int cch);
BOOL ListViewChanged(HWND hDlg, int iID, NM_LISTVIEW *pLV);
BOOL ListViewChanging(HWND hDlg, int iID, NM_LISTVIEW *pLv);

BOOL RunRegionalOptionsApplet(LPTSTR pCommands);

BOOL ParseCommandLine(LPTSTR lpCommandLine);
BOOL StartGUISetup(HWND hwndDlg);
BOOL SelectInstalledLanguages(HWND hList);
BOOL SetDefault(HWND hCombo);
BOOL SetUserDefaultLanguage(LANGID langID, BOOL bApplyCurrentUser, BOOL bApplyAllUsers);
BOOL UninstallUpdateRegistry(LPTSTR Languages);
BOOL UpdateCombo(HWND hwndDlg);
INT_PTR CALLBACK DialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ProgressDialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL GetMuiLangInfoFromListView(HWND hList, int i, PMUILANGINFO *ppMuiLangInfo);
int Muisetup_GetLocaleLanguageInfo(LCID lcid, PTSTR pBuf, int iLen, BOOL fCountryName);


HKEY OpenMuiKey(REGSAM samDesired);
BOOL GetLcidItemIndexFromListView(HWND hList, LCID lcid, int *piIndex);


int CopyArgument(LPTSTR dest, LPTSTR src);
int InsertLanguageInListView(HWND hList, LPTSTR lpLanguage, BOOL bCheckState);
int InstallSelected (LPTSTR Languages,BOOL *lpbFontLinkRegistryTouched);
int UninstallSelected(LPTSTR Languages,int *lpNotDeleted);

PTCHAR SkipBlanks(PTCHAR pszText);

void DisplayHelpWindow(void);
void ListViewCustomDraw(HWND hDlg, LPNMLVCUSTOMDRAW pDraw);

// Language Group Installation
BOOL CALLBACK EnumLanguageGroupsProc(
  LGRPID LanguageGroup,
  LPTSTR lpLanguageGroupString,
  LPTSTR lpLanguageGroupNameString,
  DWORD dwFlags,
  LONG_PTR lParam);
LGRPID GetLanguageGroup( LCID lcid );
BOOL EnumLanguageGroupLocalesProc(
    LGRPID langGroupId, 
    LCID lcid, 
    LPTSTR lpszLocale,
    LONG_PTR lParam);
BOOL DetectLanguageGroups(HWND hwndDlg);
BOOL ConvertMUILangToLangGroup(HWND hwndDlg, PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL AddMUILangGroup(PINSTALL_LANG_GROUP pInstallLangGroup, LGRPID lgrpid);
BOOL InstallLanguageGroups(PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL CheckVolumeChange();
BOOL StartFromTSClient();
BOOL CheckLanguageIsQualified(LPTSTR lpLanguage);

BOOL CALLBACK Region_EnumUILanguagesProc(PWSTR pwszUILanguage,LONG_PTR lParam);
BOOL MUIGetAllInstalledUILanguages();
BOOL GetUIFileSize_commandline(LPTSTR lpszLcid, INT64 *ulUISize,INT64 *ulLPKSize);
BOOL GetUIFileSize(PMUILANGINFO pMuiLangInfo);
BOOL IsSpaceEnough(HWND hList,INT64 *ulSizeNeed,INT64 *ulSizeAvailable);
BOOL CopyRemoveMuiItself(BOOL bInstall);
BOOL RemoveFileReadOnlyAttribute(LPTSTR lpszFileName);
BOOL MUI_DeleteFile(LPTSTR lpszFileName);
void Set_SourcePath_FromForward(LPCTSTR lpszPath);
BOOL MUIShouldSwitchToNewVersion(LPTSTR lpszCommandLine);
BOOL MUI_TransferControlToNewVersion(LPTSTR lpszExecutable,LPTSTR lpszCommandLine);
void ExitFromOutOfMemory();
void NotifyKernel(
    LPTSTR LangList,
    ULONG Flags
    );
BOOL WelcomeDialog(HWND hWndParent);
BOOL DoSetup(
    HWND hwnd,
    int UninstallLangCount, LPTSTR lpUninstall, 
    INSTALL_LANG_GROUP installLangGroup, 
    int InstallLangCount, LPTSTR lpInstall, 
    LPTSTR lpDefaultUILang,
    BOOL fAllowReboot, BOOL bInteractive, BOOL bDisplayUI);

//
// Utility functions
//
BOOL IsAdmin(void);
DWORD_PTR TransNum(LPTSTR lpsz);
LANGID GetDotDefaultUILanguage();

//
// Log functions
//
HANDLE OpenLogFile(void);
void BeginLog(void);
BOOL LogMessage(LPCTSTR lpMessage);
BOOL LogFormattedMessage(HINSTANCE hInstance, int messageID, LONG_PTR* lppArgs);

//
// Resource utility functions
//
int DoMessageBox(HWND hwndParent, UINT uIdString, UINT uIdCaption, UINT uType);
int DoMessageBoxFromResource(HWND hwndParent, HMODULE hInstance, UINT uIdString, LONG_PTR* lppArgs, UINT uIdCaption, UINT uType);

LPTSTR FormatStringFromResource(LPTSTR pszBuffer, UINT bufferSize, HMODULE hInstance, int messageID, LONG_PTR* lppArgs);
void SetWindowTitleFromResource(HWND hwnd, int resourceID);

//
//  Registry utility functions
//
DWORD DeleteRegTree(HKEY hStartKey, LPTSTR pKeyName);
void DeleteMSIRegSettings(LPTSTR Language);


//
// External data refereces
//
extern HINSTANCE ghInstance;
extern HWND ghProgress;
extern HWND ghProgDialog;

typedef
NTSTATUS
(NTAPI *pfnNtSetDefaultUILanguage)(
    LANGID DefaultUILanguageId
    );

typedef
LANGID
(WINAPI *pfnGetUserDefaultUILanguage)(
    void
    );

typedef
LANGID
(WINAPI *pfnGetSystemDefaultUILanguage)(
    void
    );

typedef
BOOL
(WINAPI *pfnIsValidLanguageGroup)(
    LGRPID LanguageGroup,
    DWORD dwFlags
    );

typedef
BOOL
(WINAPI *pfnEnumLanguageGroupLocalesW)(
    LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
    LGRPID LanguageGroup,
    DWORD dwFlags,
    LONG_PTR lParam
    );

typedef
BOOL
(WINAPI *pfnEnumSystemLanguageGroupsW)(
    LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
    DWORD dwFlags,
    LONG_PTR lParam
    );

typedef
NTSTATUS
(NTAPI *pfnRtlAdjustPrivilege)(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,PBOOLEAN WasEnabled
    );

typedef
BOOL
(WINAPI *pfnGetDefaultUserProfileDirectoryW)(
    LPWSTR lpProfileDir,
    LPDWORD lpcchSize
    );

typedef 
BOOL (WINAPI *pfnMUI_InstallMFLFiles)( 
    TCHAR* pMUIInstallLanguage
    );

typedef
BOOL
(WINAPI *pfnProcessIdToSessionId)(
    DWORD_PTR dwProcessId,
    DWORD_PTR *pSessionId
    );

typedef
INT
(WINAPI *pfnLaunchINFSection)(
    HWND hWnd,
    HINSTANCE hInstance,
    PSTR pParams,
    INT flags
);

typedef BOOL (*UILANGUAGE_ENUMPROC)(LPTSTR, LONG_PTR);
typedef BOOL (*pfnEnumUILanguages)(UILANGUAGE_ENUMPROC, DWORD, LONG_PTR);

extern pfnNtSetDefaultUILanguage gpfnNtSetDefaultUILanguage;
extern pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;
extern pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage;
extern pfnIsValidLanguageGroup gpfnIsValidLanguageGroup;
extern pfnEnumLanguageGroupLocalesW gpfnEnumLanguageGroupLocalesW;
extern pfnEnumSystemLanguageGroupsW gpfnEnumSystemLanguageGroupsW;
extern pfnRtlAdjustPrivilege gpfnRtlAdjustPrivilege;
extern pfnProcessIdToSessionId gpfnProcessIdToSessionId;
extern pfnGetDefaultUserProfileDirectoryW gpfnGetDefaultUserProfileDirectoryW;
extern pfnLaunchINFSection gpfnLaunchINFSection;
extern PSXS_INSTALL_W gpfnSxsInstallW;
extern PSXS_UNINSTALL_ASSEMBLYW gpfnSxsUninstallW;

extern TCHAR g_szPlatformPath[];
extern TCHAR g_AddLanguages[];
extern TCHAR g_szMUIInfoFilePath[];
extern TCHAR g_szMUISetupFolder[];
extern TCHAR g_szMuisetupPath[];
extern TCHAR g_szMUIHelpFilePath[];
extern TCHAR g_szWinDir[];
extern BOOL  g_InstallCancelled;
extern BOOL  g_IECopyError;
extern BOOL  gbIsWorkStation,gbIsServer,gbIsAdvanceServer,gbIsDataCenter,gbIsDomainController;
extern PFILERENAME_TABLE g_pFileRenameTable;
extern int   g_nFileRename;
extern PTYPENOTFALLBACK_TABLE g_pNotFallBackTable;
extern int   g_nNotFallBack;
extern LPTSTR g_SpecialFiles[];
extern int gNumLanguages_Install;
extern UILANGUAGEGROUP g_UILanguageGroup;
extern LANGID gUserUILangId, gSystemUILangId;
BOOL GetLanguageGroupDisplayName(LANGID LangId, LPTSTR lpBuffer, int nSize);

BOOL CheckMUIRegSetting(DWORD dwFlag);
BOOL SetMUIRegSetting(DWORD dwFlag, BOOL bEnable);
BOOL DeleteMUIRegSetting();
BOOL AddExtraLangGroupsFromINF(LPTSTR lpszLcid, PINSTALL_LANG_GROUP pInstallLangGroup);
BOOL InstallExternalComponents(LPTSTR Languages);
VOID UninstallExternalComponents(LPTSTR Languages);
BOOL GetMSIProductCode(LPTSTR szLanguage, LPTSTR szProductCode, UINT uiBufSize);
	
#endif //__MUISETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\muisetup\muisetup.cpp ===
////////////////////////////////////////////////////////////////////////////
//
//  MUISetup.cpp
//
//  This file contains the WinMain() and the UI handling of MUISetup.
//
//  MUISetup is compiled as an Unicode application.
//
////////////////////////////////////////////////////////////////////////////
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <userenv.h>
#include <shellapi.h>
#include <regstr.h>
#include <wmistr.h>
#include <wmiumkm.h>
#include <setupapi.h>
#include <shlwapi.h>
#include "sxsapi.h"
#include "muisetup.h"
#define STRSAFE_LIB
#include <strsafe.h>

//
// Context Help IDs
//
//
//  Context Help Ids.
//

STDAPI_(BOOL) IsUserAnAdmin();
static int aMuisetupHelpIds[] =
{
    207,        IDH_COMM_GROUPBOX,              // Group Box
    IDC_LIST1,  IDH_MUISETUP_UILANGUAGE_LIST,   // UI Language ListView
    IDC_DEF_UI_LANG_COMBO, IDH_MUISETUP_UILANGUAGECOMBO,   // UI ComboBox selection
    IDC_CHECK_LOCALE, IDH_MUISETUP_CHECKLOCALE, // Match system locale with UI language
    IDC_CHECK_UIFONT, IDH_MUISETUP_MATCHUIFONT, // Match system locale with UI language
    0, 0
};
//
//  Global variables
//
BOOL g_bMatchUIFont;
// Store the special directories listed under [Directories] in mui.inf
TCHAR DirNames[MFL][MAX_PATH],DirNames_ie[MFL][MAX_PATH];
TCHAR szWindowsDir[MAX_PATH];
// The FOLDER where MUISetup.exe is executed.
TCHAR g_szMUISetupFolder[MAX_PATH];
// The FULL PATH for MUISetup.exe.
TCHAR g_szMuisetupPath[MAX_PATH];
// The full path where MUI.inf is located.
TCHAR g_szMUIInfoFilePath[MAX_PATH];
TCHAR g_szVolumeName[MAX_PATH],g_szVolumeRoot[MAX_PATH];
TCHAR g_szMUIHelpFilePath[MAX_PATH],g_szPlatformPath[16],g_szCDLabel[MAX_PATH];
// Windows directory
TCHAR g_szWinDir[MAX_PATH];
TCHAR g_AddLanguages[BUFFER_SIZE];
HANDLE ghMutex = NULL;
HINSTANCE ghInstance;
HWND ghProgDialog;      // The progress dialog showed during installation/uninstallation.
HWND ghProgress;        // The progress bar in the progress dialog
LANGID gUserUILangId, gSystemUILangId;
BOOL gbIsWorkStation,gbIsServer,gbIsAdvanceServer,gbIsDataCenter,gbIsDomainController;
HINSTANCE g_hUserEnvDll = NULL;
HMODULE g_hAdvPackDll = NULL;
HMODULE g_hSxSDll = NULL;
DWORD g_dwVolumeSerialNo;
BOOL g_InstallCancelled,g_IECopyError,g_bRemoveDefaultUI,g_bRemoveUserUI,g_bCmdMatchLocale,g_bCmdMatchUIFont, g_bReboot;
UILANGUAGEGROUP g_UILanguageGroup;
int g_cdnumber;
// Number of MUI languges to insatll
int gNumLanguages,gNumLanguages_Install,gNumLanguages_Uninstall;
// Flag to indicate whether a language group is found for the locale or not.
BOOL gFoundLangGroup;
LGRPID gLangGroup;
LCID gLCID;
// The language groups installed in the system.
LGRPID gLanguageGroups[32] ;
int gNumLanguageGroups;
PFILERENAME_TABLE g_pFileRenameTable;
int   g_nFileRename;
PTYPENOTFALLBACK_TABLE g_pNotFallBackTable; 
int  g_nNotFallBack;                       
BOOL g_bSilent=FALSE;               // indicate that muisetup should need no user interaction
BOOL g_bNoUI=FALSE;                 // indicate that muisetup should install with no UI displayed and no user interaction
BOOL g_bRunFromOSSetup=FALSE;       // indicated that muisetup is called as part of NT setup/upgrade
BOOL g_bLipLanguages;
BOOL g_bLipAllowSwitch;
//
// Required pfns
//
pfnNtSetDefaultUILanguage gpfnNtSetDefaultUILanguage;
pfnGetUserDefaultUILanguage gpfnGetUserDefaultUILanguage;
pfnGetSystemDefaultUILanguage gpfnGetSystemDefaultUILanguage;
pfnIsValidLanguageGroup gpfnIsValidLanguageGroup;
pfnEnumLanguageGroupLocalesW gpfnEnumLanguageGroupLocalesW;
pfnEnumSystemLanguageGroupsW gpfnEnumSystemLanguageGroupsW;
pfnRtlAdjustPrivilege gpfnRtlAdjustPrivilege;
pfnProcessIdToSessionId gpfnProcessIdToSessionId;
pfnGetDefaultUserProfileDirectoryW gpfnGetDefaultUserProfileDirectoryW = NULL;
pfnLaunchINFSection gpfnLaunchINFSection = NULL;
PSXS_INSTALL_W              gpfnSxsInstallW = NULL;
PSXS_UNINSTALL_ASSEMBLYW    gpfnSxsUninstallW = NULL;

//
// GetWindowsDirectory stuff
//
UINT WINAPI NT4_GetWindowsDir(LPWSTR pBuf, UINT uSize)
{
    return GetWindowsDirectoryW(pBuf, uSize);
}
//
// shlwapi StrToIntEx doesn't work for us
//
DWORD HexStrToInt(LPTSTR lpsz)
{
    DWORD   dw = 0L;
    TCHAR   c;
    if (! lpsz)
    {
        return dw;
    }
    while(*lpsz)
    {
        c = *lpsz++;
        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return(dw);
}
UINT (WINAPI *pfnGetWindowsDir)(LPWSTR pBuf, UINT uSize) = NT4_GetWindowsDir;


void InitGetWindowsDirectoryPFN(HMODULE hMod)
{
    pfnGetWindowsDir = (UINT (WINAPI *) (LPWSTR pBuf, UINT uSize)) GetProcAddress(hMod, "GetSystemWindowsDirectoryW");
    if (!pfnGetWindowsDir)
    {
        pfnGetWindowsDir = NT4_GetWindowsDir;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageDisplayName
//
//  Get the display name (in the form of "Language (Region)") for the specified
//  language ID.
//
//  Parameters:
//      [IN]  langID        Language ID
//      [OUT] lpBuffer      the buffer to receive the display name.
//      [IN]  nBufferSize   the size of buffer, in TCHAR.
//
//  Return Values:
//      TRUE if succeed.  FALSE if the buffer is not big enough.
//
//
//  01-11-2001  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////
BOOL GetLanguageDisplayName(LANGID langID, LPTSTR lpBuffer, int nBufferSize)
{
    TCHAR lpLangName[BUFFER_SIZE];
    TCHAR lpRegionName[BUFFER_SIZE];
    int nCharCount = 0;
    HRESULT hresult = S_OK;
    
    nCharCount  = GetLocaleInfo(langID, LOCALE_SENGLANGUAGE, lpLangName, ARRAYSIZE(lpLangName)-1);
    nCharCount += GetLocaleInfo(langID, LOCALE_SENGCOUNTRY , lpRegionName, ARRAYSIZE(lpRegionName)-1);
    nCharCount += 3;
    if (nCharCount > nBufferSize)
    {
        if (nBufferSize)
            //*STRSAFE*             lstrcpy(lpBuffer, TEXT(""));
            hresult = StringCchCopy(lpBuffer , nBufferSize, TEXT(""));
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
        return (FALSE);
    }
    //*STRSAFE*     wsprintf(lpBuffer, TEXT("%s (%s)"), lpLangName, lpRegionName);
    hresult = StringCchPrintf(lpBuffer ,  nBufferSize,  TEXT("%s (%s)"), lpLangName, lpRegionName);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    return (TRUE);                
}
//
// Our Message Box
//
int DoMessageBox(HWND hwndParent, UINT uIdString, UINT uIdCaption, UINT uType)
{
   TCHAR szString[MAX_PATH+MAX_PATH];
   TCHAR szCaption[MAX_PATH];
   szString[0] = szCaption[0] = TEXT('\0');
   if (uIdString)
       LoadString(NULL, uIdString, szString, MAX_PATH+MAX_PATH-1);
   if (uIdCaption)
       LoadString(NULL, uIdCaption, szCaption, MAX_PATH-1);
   return MESSAGEBOX(hwndParent, szString, szCaption, uType);
}
////////////////////////////////////////////////////////////////////////////
//
//  DoMessageBoxFromResource
//
//  Load a format string from resource, and format the string using the 
//  specified arguments.  Display a message box using the formatted string.
//
//  Parameters:
//
//  Return Values:
//      The return value from MessageBox.
//
//  Remarks:
//      The length of the formatted string is limited by BUFFER_SIZE.
//
//  08-07-2000  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////
int DoMessageBoxFromResource(HWND hwndParent, HMODULE hInstance, UINT uIdString, LONG_PTR* lppArgs, UINT uIdCaption, UINT uType)
{
    TCHAR szString[BUFFER_SIZE];
    TCHAR szCaption[BUFFER_SIZE];
    szString[0] = szCaption[0] = TEXT('\0');
    if (uIdCaption)
       LoadString(hInstance, uIdCaption, szCaption, MAX_PATH-1);
    
    FormatStringFromResource(szString, sizeof(szString)/sizeof(TCHAR), hInstance, uIdString, lppArgs);
    return (MESSAGEBOX(hwndParent, szString, szCaption, uType));            
}
BOOL IsMatchingPlatform(void)
{
    BOOL bx86Image = FALSE;
    BOOL bRet = TRUE;
    TCHAR szWOW64Path[MAX_PATH];
#ifdef _X86_
    bx86Image = TRUE;
#endif
    if (GetSystemWow64Directory(szWOW64Path, ARRAYSIZE(szWOW64Path)) &&
        bx86Image)
        bRet = FALSE;
    return bRet;
}
//
// Program Entry Point
//
INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, INT nCmdShow)
{
    int result = 0;
    BOOL bForwardCall=FALSE;
    
    TCHAR lpCommandLine[BUFFER_SIZE+1];
    HMODULE hMod;
    int error,nNumArgs=0,i;
    LONG_PTR lppArgs[3];
    LPWSTR *pszArgv=NULL;
    HRESULT hresult;
    
    if (!IsUserAnAdmin())
    {
        // 
        // "You must have administrator right to run muisetup.\n\n"
        // "If you want to switch your UI language, please use the regional option from control panel."
        //
        LogFormattedMessage(ghInstance, IDS_ADMIN_L, NULL);
        DoMessageBox(NULL, IDS_ADMIN, IDS_MAIN_TITLE, MB_OK);        
        return result;
    }
    //
    // Bail out if image doesn't match the running platform
    // 
    if (!IsMatchingPlatform())
    {
        DoMessageBox(NULL, IDS_WRONG_IMAGE, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
        return result;
    }
    
    ghInstance = hInstance;
    //
    // Let make sure this NT5, and let's initialize all our pfns
    //
    if (!InitializePFNs())
    {
        //
        // Not an NT5 system. The following should be ANSI to work on Win9x.
        //
        CHAR szString[MAX_PATH];
        CHAR szCaption[MAX_PATH];
        LoadStringA(NULL, IDS_ERROR_NT5_ONLY, szString, MAX_PATH-1);
        LoadStringA(NULL, IDS_MAIN_TITLE, szCaption, MAX_PATH-1);
        MessageBoxA(NULL, szString, szCaption, MB_OK | MB_ICONINFORMATION);
        result = 1;
        goto Exit;
    }
    //
    // Check if the program has already been running ?
    //
    if (CheckMultipleInstances())
    {
        result = 1;        
        goto Exit;
    }
    //
    // Initialize any global vars
    //
    InitGlobals();
    //
    // Check if I'm launching from previous version of muisetup
    //
    // I.E. muisetup /$_transfer_$ path_of_MUI_installation_files
    //
    pszArgv = CommandLineToArgvW((LPCWSTR) GetCommandLineW(), &nNumArgs);
    lpCommandLine[0]=TEXT('\0');
    if (pszArgv)
    {
        for (i=1; i<nNumArgs;i++)
        {
            if (!_tcsicmp(pszArgv[i],MUISETUP_FORWARDCALL_TAG) && ((i+1) < nNumArgs) )
            {
                Set_SourcePath_FromForward(pszArgv[i+1]);
                bForwardCall=TRUE;
                i++;
            }
            else
            {
                //*STRSAFE*                 _tcscat(lpCommandLine,pszArgv[i]);
                hresult = StringCchCat(lpCommandLine , ARRAYSIZE(lpCommandLine), pszArgv[i]);
                if (!SUCCEEDED(hresult))
                {
                   result = 1;
                  goto Exit;
                }
                //*STRSAFE*                 _tcscat(lpCommandLine,TEXT(" "));
                hresult = StringCchCat(lpCommandLine , ARRAYSIZE(lpCommandLine), TEXT(" "));
                if (!SUCCEEDED(hresult))
                {
                    result = 1;
                    goto Exit;
                }

                
            }
        }
    }

    //
    // Check if there is a new version of muisetup.exe at %windir%\mui
    //
    // If it's the case, transfer all the control to it  
    //
    if (!bForwardCall)
    {
       if ( MUIShouldSwitchToNewVersion(lpCommandLine) )
       {
           result = 0;        
           goto Exit;;
       } 
    } 

    InitCommonControls();

    BeginLog();
    //
    // Block the installation of Personal and Professional
    // NOTE: this is here for only the .NET server release, re-enable pro sku after this.
    //
#ifdef MUI_MAGIC
    if (CheckProductType(MUI_IS_WIN2K_PERSONAL) || CheckProductType(MUI_IS_WIN2K_PRO))
#else
    if (CheckProductType(MUI_IS_WIN2K_PERSONAL))
#endif
    {
         //
         //  "Windows XP MultiLanguage Version cannot be installed on this platform."
         //
         DoMessageBox(NULL, IDS_ERROR_NT5_ONLY, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);    
         result = 1;
         goto Exit;
    }
   
    //
    //  Check to see if a command line has been used
    //
    if(lpCommandLine && NextCommandTag(lpCommandLine))
    {
        lppArgs[0] = (LONG_PTR)lpCommandLine;
        LogFormattedMessage(NULL, IDS_COMMAND_LOG, lppArgs);
        LogMessage(TEXT(""));   //Add a carriage return and newline
        ParseCommandLine(lpCommandLine);
    }
    else
    {
        //
        // MUI version needs to match OS version
        //
        if (!checkversion(TRUE))
        {
            DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
            result = 1;        
            goto Exit;
        }
        if (WelcomeDialog(0))
        {
            DialogBox(hInstance, MAKEINTRESOURCE(IDD_DIALOG_MAIN), 0, DialogFunc);
        }
        result = 1;
    }
Exit:
    //
    // Cleanup
    //
    if ( pszArgv)
    {
       GlobalFree((HGLOBAL) pszArgv);
    }
    Muisetup_Cleanup();
    return result;
}
////////////////////////////////////////////////////////////////////////////////////
//
//   CheckMultipleInstances
//
//   Checks if another instance is running, and if so, it switches to it.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckMultipleInstances(void)
{
    ghMutex = CreateMutex(NULL, TRUE, TEXT("Muisetup_Mutex"));
    if (ghMutex && (GetLastError() == ERROR_ALREADY_EXISTS))
    {
        const int idsTitles[] = {IDS_MAIN_TITLE, IDS_INSTALL_TITLE, IDS_PROG_TITLE_2, IDS_PROG_TITLE_3, IDS_UNINSTALL_TITLE};
        HWND hWnd;
        TCHAR szTitle[MAX_PATH];
        int i;
        //
        // Find the running instance by searching possible Window titles
        //
        for (i=0; i<ARRAYSIZE(idsTitles); i++)
        {
            LoadString(NULL, idsTitles[i], szTitle, MAX_PATH-1);
            hWnd = FindWindow(NULL,szTitle);
            if (hWnd && IsWindow(hWnd))
            {
                if (IsIconic(hWnd))
                    ShowWindow(hWnd, SW_RESTORE);
                SetForegroundWindow(hWnd);
                break;
            }
        }
        
        //
        // Always bail out if there is another running instance
        //
        return TRUE;
    }
    return FALSE;
}
  
////////////////////////////////////////////////////////////////////////////////////
//
//   InitializePFNs
//
//   Initialize NT5 specific pfns
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InitializePFNs()
{
    HMODULE     hModule;
    SYSTEM_INFO SystemInfo;
    LONG_PTR lppArgs[2];    
    HRESULT hresult;
    //
    //  Determine platform
    //
    GetSystemInfo( &SystemInfo );
    if (SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL ||
        SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 ||
        SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
    {
#if defined(_AMD64_)
        //*STRSAFE*         _tcscpy(g_szPlatformPath, TEXT("amd64\\"));
        hresult = StringCchCopy(g_szPlatformPath , ARRAYSIZE(g_szPlatformPath), TEXT("amd64\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
#elif defined(_IA64_)
        //*STRSAFE*         _tcscpy(g_szPlatformPath, TEXT("ia64\\"));
        hresult = StringCchCopy(g_szPlatformPath , ARRAYSIZE(g_szPlatformPath), TEXT("ia64\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
#else
        //*STRSAFE*         _tcscpy(g_szPlatformPath, TEXT("i386\\"));
        hresult = StringCchCopy(g_szPlatformPath , ARRAYSIZE(g_szPlatformPath), TEXT("i386\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
#endif
    }
    else
    {
        // This is NOT supported yet
        return FALSE;
    }
    //
    // Let's bring ntdll!NtSetDefaultUILanguage
    //
    hModule = GetModuleHandle(TEXT("ntdll.dll"));
    if (!hModule)
        return FALSE;
    
    gpfnNtSetDefaultUILanguage =
        (pfnNtSetDefaultUILanguage)GetProcAddress(hModule,
                                                  "NtSetDefaultUILanguage");
    if (!gpfnNtSetDefaultUILanguage)
        return FALSE;
    
    gpfnRtlAdjustPrivilege =
        (pfnRtlAdjustPrivilege)GetProcAddress(hModule,
                                              "RtlAdjustPrivilege");
    if (!gpfnRtlAdjustPrivilege)
        return FALSE;
    //
    // Let's get out from kernel32.dll :
    // - GetUserDefaultUILanguage
    // - GetSystemDefaultUILanguage
    // - EnumLanguageGroupLocalesW
    //
    hModule = GetModuleHandle(TEXT("kernel32.dll"));
    if (!hModule)
        return FALSE;
    gpfnGetUserDefaultUILanguage =
        (pfnGetUserDefaultUILanguage)GetProcAddress(hModule,
                                                    "GetUserDefaultUILanguage");
    if (!gpfnGetUserDefaultUILanguage)
        return FALSE;
    gpfnGetSystemDefaultUILanguage =
        (pfnGetSystemDefaultUILanguage)GetProcAddress(hModule,
                                                      "GetSystemDefaultUILanguage");
    if (!gpfnGetSystemDefaultUILanguage)
        return FALSE;
    gpfnIsValidLanguageGroup =
        (pfnIsValidLanguageGroup)GetProcAddress(hModule,
                                                "IsValidLanguageGroup");
    if (!gpfnIsValidLanguageGroup)
        return FALSE;
    gpfnEnumLanguageGroupLocalesW =
        (pfnEnumLanguageGroupLocalesW)GetProcAddress(hModule,
                                                     "EnumLanguageGroupLocalesW");
    if (!gpfnEnumLanguageGroupLocalesW)
        return FALSE;
    gpfnEnumSystemLanguageGroupsW =
        (pfnEnumSystemLanguageGroupsW)GetProcAddress(hModule,
                                                     "EnumSystemLanguageGroupsW");
    if (!gpfnEnumSystemLanguageGroupsW)
        return FALSE;
    gpfnProcessIdToSessionId =  
       (pfnProcessIdToSessionId)  GetProcAddress(hModule,
                                                     "ProcessIdToSessionId");    
    //
    // Initialize the pfnGetWindowsDirectory
    //
    InitGetWindowsDirectoryPFN(hModule);
    //
    // Try to load userenv.dll
    //
    g_hUserEnvDll = LoadLibrary(TEXT("userenv.dll"));
    if (g_hUserEnvDll)
    {
        gpfnGetDefaultUserProfileDirectoryW =
            (pfnGetDefaultUserProfileDirectoryW)GetProcAddress(g_hUserEnvDll,
                                                               "GetDefaultUserProfileDirectoryW");
    }
    else
    {
        LogFormattedMessage(ghInstance, IDS_LOAD_USERENV_L, NULL);
        return (FALSE);
    }
    g_hAdvPackDll = LoadLibrary(TEXT("AdvPack.dll"));
    if (g_hAdvPackDll == NULL)
    {
        LogFormattedMessage(ghInstance, IDS_LOAD_ADVPACK_L, NULL);
        return (FALSE);
    }
    gpfnLaunchINFSection = (pfnLaunchINFSection)GetProcAddress(g_hAdvPackDll, "LaunchINFSection");
    if (gpfnLaunchINFSection == NULL)
    {
        lppArgs[0] = (LONG_PTR)TEXT("LaunchINFSection");
        LogFormattedMessage(ghInstance, IDS_LOAD_ADVPACK_API_L, lppArgs);        
        return (FALSE);
    }
    g_hSxSDll = LoadLibrary(TEXT("SxS.dll"));
    if (g_hSxSDll) 
    {
        gpfnSxsInstallW = (PSXS_INSTALL_W)GetProcAddress(g_hSxSDll, SXS_INSTALL_W);
        gpfnSxsUninstallW = (PSXS_UNINSTALL_ASSEMBLYW)GetProcAddress(g_hSxSDll, SXS_UNINSTALL_ASSEMBLYW);
    }
    else
    {
        LogFormattedMessage(ghInstance, IDS_LOAD_SXS_L, NULL);
        return (FALSE);
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  Find the path of execution file and set path for MUI.INF
//
//
////////////////////////////////////////////////////////////////////////////////////
void SetSourcePath(LPTSTR lpszPreviousMUIPath)
{
    UINT_PTR cb;
    LPTSTR   lpszPath,lpszNext=NULL;
    TCHAR    szHelpPath[MAX_PATH+1],szHelpFile[MAX_PATH+1];
    HRESULT hresult;

   
    if (!lpszPreviousMUIPath)
    {
    
        g_szMUISetupFolder[0]=TEXT('\0');
        cb = GetModuleFileName (ghInstance, g_szMuisetupPath, MAX_PATH);
        //*STRSAFE*         _tcscpy(g_szMUISetupFolder,g_szMuisetupPath);
        hresult = StringCchCopy(g_szMUISetupFolder , ARRAYSIZE(g_szMUISetupFolder), g_szMuisetupPath);
        if (!SUCCEEDED(hresult))
        {
           return;
        }
        
        //
        // Get folder for MUISetup.
        //
        lpszPath = g_szMUISetupFolder;
        while ( (lpszNext=_tcschr(lpszPath,TEXT('\\')))  )
        {    
            lpszPath = lpszNext+1;
        }
        *lpszPath=TEXT('\0');
    }
    else
    { 
      //*STRSAFE*       _tcscpy(g_szMUISetupFolder,lpszPreviousMUIPath);
      hresult = StringCchCopy(g_szMUISetupFolder , ARRAYSIZE(g_szMUISetupFolder), lpszPreviousMUIPath);
      if (!SUCCEEDED(hresult))
      {
         return ;
      }
    }
    //*STRSAFE*     _tcscpy(g_szMUIInfoFilePath,g_szMUISetupFolder);
    hresult = StringCchCopy(g_szMUIInfoFilePath , ARRAYSIZE(g_szMUIInfoFilePath), g_szMUISetupFolder);
    if (!SUCCEEDED(hresult))
    {
       return;
    }
    //*STRSAFE*     _tcscat(g_szMUIInfoFilePath,MUIINFFILENAME);
    hresult = StringCchCat(g_szMUIInfoFilePath , ARRAYSIZE(g_szMUIInfoFilePath), MUIINFFILENAME);
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
    //
    // Check the location of help file
    //
    //*STRSAFE*     _tcscpy(szHelpPath,g_szMUISetupFolder);
    hresult = StringCchCopy(szHelpPath , ARRAYSIZE(szHelpPath), g_szMUISetupFolder);
    if (!SUCCEEDED(hresult))
    {
       return ;
    }
    LoadString(NULL, IDS_HELPFILE,szHelpFile,MAX_PATH);
    //*STRSAFE*     _tcscat(szHelpPath,szHelpFile);
    hresult = StringCchCat(szHelpPath , ARRAYSIZE(szHelpPath), szHelpFile);
    if (!SUCCEEDED(hresult))
    {
       return;
    }
    if (!FileExists(szHelpPath))
    {
       pfnGetWindowsDir(szHelpPath, MAX_PATH); 
       //*STRSAFE*        _tcscat(szHelpPath, TEXT("\\"));
       hresult = StringCchCat(szHelpPath , ARRAYSIZE(szHelpPath), TEXT("\\"));
       if (!SUCCEEDED(hresult))
       {
          return ;
       }
       //*STRSAFE*        _tcscat(szHelpPath,HELPDIR);           // HELP\MUI
       hresult = StringCchCat(szHelpPath , ARRAYSIZE(szHelpPath), HELPDIR);
       if (!SUCCEEDED(hresult))
       {
          return ;
       }
       //*STRSAFE*        _tcscat(szHelpPath, TEXT("\\"));
       hresult = StringCchCat(szHelpPath , ARRAYSIZE(szHelpPath), TEXT("\\"));
       if (!SUCCEEDED(hresult))
       {
          return ;
       }
       //*STRSAFE*        _tcscat(szHelpPath,szHelpFile);
       hresult = StringCchCat(szHelpPath , ARRAYSIZE(szHelpPath), szHelpFile);
       if (!SUCCEEDED(hresult))
       {
          return ;
       }
       if (FileExists(szHelpPath))
       {
          //*STRSAFE*           _tcscpy(g_szMUIHelpFilePath,szHelpPath);
          hresult = StringCchCopy(g_szMUIHelpFilePath , ARRAYSIZE(g_szMUIHelpFilePath), szHelpPath);
          if (!SUCCEEDED(hresult))
          {
             return ;
          }
       }
    }
    else
    {
       //*STRSAFE*        _tcscpy(g_szMUIHelpFilePath,szHelpPath);
       hresult = StringCchCopy(g_szMUIHelpFilePath , ARRAYSIZE(g_szMUIHelpFilePath), szHelpPath);
       if (!SUCCEEDED(hresult))
       {
          return ;
       }
    }
       
    if(g_szMUIInfoFilePath[1] == TEXT(':'))
    {
        _tcsncpy(g_szVolumeRoot,g_szMUIInfoFilePath,3);
        g_szVolumeRoot[3]=TEXT('\0');
        GetVolumeInformation(g_szVolumeRoot, g_szVolumeName, sizeof(g_szVolumeName)/sizeof(TCHAR),
                           &g_dwVolumeSerialNo, 0, 0, 0, 0);
    }
    if (!GetPrivateProfileString( MUI_CDLAYOUT_SECTION,
                            MUI_CDLABEL,
                            TEXT(""),
                            g_szCDLabel,
                            MAX_PATH-1,
                            g_szMUIInfoFilePath))
    {
       LoadString(NULL, IDS_CHANGE_CDROM, g_szCDLabel, MAX_PATH-1);
    }
}

//
// Set MUI installation source path from the instance that transfer control to this instance
//
void Set_SourcePath_FromForward(LPCTSTR lpszPath)
{
    TCHAR szMUIPath[MAX_PATH+1];
    int nidx=0;

    if (!lpszPath)
    {
         return;
    }
    while (*lpszPath)
    {
       if (*lpszPath == MUI_FILLER_CHAR)
       {
          szMUIPath[nidx++]=TEXT(' ');
       }
       else
       {
          szMUIPath[nidx++]=*lpszPath;
       }
       lpszPath++;
    }
    szMUIPath[nidx]=TEXT('\0');

    SetSourcePath(szMUIPath);

}

//
// Check if the version of current instance is older than that in %windir%\mui.
// If it's the case, then we transfer control to %windir%\mui\muisetup.
//
BOOL MUIShouldSwitchToNewVersion(LPTSTR lpszCommandLine)
{
    BOOL   bResult=FALSE;

    TCHAR  szTarget[ MAX_PATH+1 ];
  
    HRESULT hresult;


    ULONG  ulHandle,ulBytes;

    pfnGetWindowsDir(szTarget, MAX_PATH); //%windir%  //
    //*STRSAFE*      _tcscat(szTarget, TEXT("\\"));
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget), TEXT("\\"));
    if (!SUCCEEDED(hresult))
    {        
         return bResult;
    }
    //*STRSAFE*      _tcscat(szTarget, MUIDIR);            // \MUI //
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget), MUIDIR);
    if (!SUCCEEDED(hresult))
    {        
         return bResult;
    }
    //*STRSAFE* _tcscat(szTarget, TEXT("\\"));
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget), TEXT("\\"));
    if (!SUCCEEDED(hresult))
    {        
         return bResult;
    }
    //*STRSAFE* _tcscat(szTarget,MUISETUP_EXECUTION_FILENAME);
    hresult = StringCchCat(szTarget , ARRAYSIZE(szTarget), MUISETUP_EXECUTION_FILENAME);
    if (!SUCCEEDED(hresult))
    {        
         return bResult;
    }    
    //
    // If %windir%\mui\muisetup.exe doesn't exist or current muisetup.exe is launched from %windir%\mui then
    //    do nothing
    //
    if (!FileExists(szTarget) || !_tcsicmp(szTarget,g_szMuisetupPath))
    {
       return bResult;
    }
    //
    // If %windir%mui\muisetup.exe is not a execuatble then do nothing
    //
    ulBytes = GetFileVersionInfoSize( szTarget, &ulHandle );

    if ( ulBytes == 0 )
       return bResult;

    //
    // Compare the version stamp
    //
    // if version of g_szMuisetupPath (cuurent process) < %windir%\mui\muisetup
    // then switch control to it
    //
    if (CompareMuisetupVersion(g_szMuisetupPath,szTarget))
    {
       bResult = TRUE;
       MUI_TransferControlToNewVersion(szTarget,lpszCommandLine);
    }                   
    return bResult;     
}
////////////////////////////////////////////////////////////////////////////////////
//
// MUI_TransferControlToNewVersion
//
// Call %windir%\mui\muisetup.exe /$_transfer_$ mui_installation_file_path command_line
//
////////////////////////////////////////////////////////////////////////////////////
BOOL MUI_TransferControlToNewVersion(LPTSTR lpszExecutable,LPTSTR lpszCommandLine)
{

   STARTUPINFO si;
   PROCESS_INFORMATION pi;
   TCHAR  szAppName[BUFFER_SIZE],szDropPath[MAX_PATH];
   int    nIdx,nLen;
   BOOL   bResult=FALSE;

   HRESULT hresult;

   if (!lpszExecutable)
   {
       return bResult;
   }
   nLen=_tcslen(g_szMUISetupFolder);

   for (nIdx=0; nIdx <nLen ; nIdx++)
   {
       if (g_szMUISetupFolder[nIdx]==TEXT(' '))
       {
          szDropPath[nIdx]=MUI_FILLER_CHAR;
       }
       else
       {
          szDropPath[nIdx]=g_szMUISetupFolder[nIdx];
       }
   }
   szDropPath[nIdx]=TEXT('\0');

   //*STRSAFE*     wsprintf(szAppName,TEXT("%s %s %s %s"),lpszExecutable,MUISETUP_FORWARDCALL_TAG,szDropPath,lpszCommandLine);

   hresult = StringCchPrintf(szAppName , ARRAYSIZE(szAppName), TEXT("%s %s %s %s"),lpszExecutable,MUISETUP_FORWARDCALL_TAG,szDropPath,lpszCommandLine);
   if (!SUCCEEDED(hresult))
  {
        return bResult;
  }   
   //
   // Run the process
   //
   memset( &si, 0x00, sizeof(si));
   si.cb = sizeof(STARTUPINFO);
 
   if (!CreateProcess(NULL,
              szAppName, 
              NULL,
              NULL,
              FALSE, 
              0L, 
              NULL, NULL,
              &si,
              &pi) )

      return bResult;
 

   bResult =TRUE; 

   return bResult;

}

////////////////////////////////////////////////////////////////////////////////////
//
//    CheckVolumeChange
//
//    Make sure that MUI CD-ROM is put in the CD drive.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckVolumeChange()
{
   BOOL bResult = FALSE;
   TCHAR szVolumeName[MAX_PATH],szCaption[MAX_PATH+1],szMsg[MAX_PATH+1],szMsg00[MAX_PATH+1],szMsg01[MAX_PATH+1];
   DWORD dwVolumeSerialNo;
   BOOL  bInit=TRUE;
   LONG_PTR lppArgs[3];
   if( *g_szVolumeName &&
       GetVolumeInformation(g_szVolumeRoot, szVolumeName, ARRAYSIZE(szVolumeName),
                            &dwVolumeSerialNo, 0, 0, 0, 0) )
   {             
       while( lstrcmp(szVolumeName,g_szVolumeName) || (dwVolumeSerialNo != g_dwVolumeSerialNo) )
       {
           if (bInit)
           {
              szCaption[0]=szMsg00[0]=szMsg01[0]=TEXT('\0');
              LoadString(NULL, IDS_MAIN_TITLE, szCaption, MAX_PATH);
              lppArgs[0] = (LONG_PTR)g_szCDLabel;
              lppArgs[1] = (LONG_PTR)g_cdnumber;
              FormatStringFromResource(szMsg, ARRAYSIZE(szMsg), ghInstance, IDS_CHANGE_CDROM2, lppArgs);
              
              bInit=FALSE;
           }
           if (MESSAGEBOX(NULL, szMsg,szCaption, MB_YESNO | MB_ICONQUESTION) == IDNO)
           {
              return TRUE;
           }
           GetVolumeInformation(g_szVolumeRoot, szVolumeName, ARRAYSIZE(szVolumeName),
                            &dwVolumeSerialNo, 0, 0, 0, 0);
       }
   }
   return bResult;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    InitGlobals
//
//    Initialize global variables
//
////////////////////////////////////////////////////////////////////////////////////
void InitGlobals(void)
{
    // User UI Language Id
    gUserUILangId = gpfnGetUserDefaultUILanguage();
    gSystemUILangId = gpfnGetSystemDefaultUILanguage();
    // System Windows directory
    szWindowsDir[0] = TEXT('\0');
    pfnGetWindowsDir(szWindowsDir, MAX_PATH);
    // Does this have admin privliges ?
    gbIsWorkStation=CheckProductType(MUI_IS_WIN2K_PRO);
    gbIsServer= CheckProductType(MUI_IS_WIN2K_SERVER);
    gbIsAdvanceServer= (CheckProductType(MUI_IS_WIN2K_ADV_SERVER_OR_DATACENTER) || CheckProductType(MUI_IS_WIN2K_ENTERPRISE));
    gbIsDataCenter=(CheckProductType(MUI_IS_WIN2K_DATACENTER) || CheckProductType(MUI_IS_WIN2K_DC_DATACENTER));
    gbIsDomainController=CheckProductType(MUI_IS_WIN2K_DC);
    if (gbIsDomainController)
    {
       if ( (!gbIsWorkStation) && (!gbIsServer) && (!gbIsAdvanceServer))
       {
          gbIsServer=TRUE;
       }  
    }
    // Fill in system supported language groups
    gpfnEnumSystemLanguageGroupsW(EnumLanguageGroupsProc, LGRPID_SUPPORTED, 0);
    pfnGetWindowsDir(g_szWinDir, sizeof(g_szWinDir));
    g_AddLanguages[0]=TEXT('\0');
    g_szVolumeName[0]=TEXT('\0');
    g_szVolumeRoot[0]=TEXT('\0');
    g_szMUIHelpFilePath[0]=TEXT('\0');
    g_szCDLabel[0]=TEXT('\0');
    g_dwVolumeSerialNo = 0;
    gNumLanguages=0;
    gNumLanguages_Install=0;
    gNumLanguages_Uninstall=0;
    g_InstallCancelled = FALSE;
    g_bRemoveDefaultUI=FALSE;
    g_cdnumber=0;
    g_pFileRenameTable=NULL;
    g_nFileRename=0;
    g_pNotFallBackTable=NULL;
    g_nNotFallBack=0;
    // Detect source path for installation
    SetSourcePath(NULL);
    // Initialize the context for diamond FDI
    Muisetup_InitDiamond();
    // Get all installed UI languages
    MUIGetAllInstalledUILanguages();
}


BOOL CALLBACK EnumLanguageGroupsProc(
  LGRPID LanguageGroup,             // language group identifier
  LPTSTR lpLanguageGroupString,     // pointer to language group identifier string
  LPTSTR lpLanguageGroupNameString, // pointer to language group name string
  DWORD dwFlags,                    // flags
  LONG_PTR lParam)                  // user-supplied parameter
{
    gLanguageGroups[gNumLanguageGroups] = LanguageGroup;
    gNumLanguageGroups++;
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    Muisetup_Cleanup
//
//    Muisetup cleanup code.
//
////////////////////////////////////////////////////////////////////////////////////
void Muisetup_Cleanup()
{
    //
    // Free userenv.dll, if needed
    //
    if (g_hUserEnvDll)
    {
        FreeLibrary(g_hUserEnvDll);
    }
    if (g_hAdvPackDll)
    {
        FreeLibrary(g_hAdvPackDll);
    }
    if (g_hSxSDll)
    {
        FreeLibrary(g_hSxSDll);
    }
    if (ghMutex)
    {
        CloseHandle(ghMutex);
    }
    
    // Free/release diamond DLL
    Muisetup_FreeDiamond();
    return;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  OpenMuiKey
//
//  Opens the Registry Key where installed languages are stored
//
////////////////////////////////////////////////////////////////////////////////////
HKEY OpenMuiKey(REGSAM samDesired)
{
    DWORD dwDisposition;    
    HKEY hKey;
    TCHAR lpSubKey[BUFFER_SIZE];    
    HRESULT hresult;
    
    //*STRSAFE*     _tcscpy(lpSubKey, REG_MUI_PATH);
    hresult = StringCchCopy(lpSubKey , ARRAYSIZE(lpSubKey), REG_MUI_PATH);
    if (!SUCCEEDED(hresult))
    {
       return NULL;
    }
    if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                      lpSubKey,
                      0,
                      NULL,
                      REG_OPTION_NON_VOLATILE,
                      samDesired,
                      NULL,
                      &hKey,
                      &dwDisposition) != ERROR_SUCCESS)
    {
        hKey = NULL;
    }
    return hKey;
}
void DialogCleanUp(HWND hwndDlg)
{
    HWND hList = GetDlgItem(hwndDlg, IDC_LIST1);
    int iCount = ListView_GetItemCount(hList);
    LVITEM lvItem;
    PMUILANGINFO pMuiLangInfo;
    while (iCount--)
    {
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iCount;
        lvItem.iSubItem = 0;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = 0;
        lvItem.cchTextMax = 0;
        lvItem.iImage = 0;
        lvItem.lParam = 0;
        ListView_GetItem(hList, &lvItem);
        pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;
        if (pMuiLangInfo)
        {
            if (pMuiLangInfo->lpszLcid)
                LocalFree(pMuiLangInfo->lpszLcid);
            LocalFree(pMuiLangInfo);
        }
    }
}
////////////////////////////////////////////////////////////////////////////////////
//
//  DialogFunc
//
//  Callback function for main dialog (102)
//
////////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK DialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
    switch(uMsg)
    {
    case WM_INITDIALOG:
        SendMessage(hwndDlg, WM_SETICON , (WPARAM)ICON_BIG, (LPARAM)LoadIcon(ghInstance,MAKEINTRESOURCE(MUI_ICON)));
        SendMessage(hwndDlg, WM_SETICON , (WPARAM)ICON_SMALL, (LPARAM)LoadIcon(ghInstance,MAKEINTRESOURCE(MUI_ICON)));
        
        InitializeInstallDialog(hwndDlg, uMsg, wParam, lParam);
        return TRUE;
    case WM_HELP:
    {
        WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                 g_szMUIHelpFilePath,
                 HELP_WM_HELP,
                 (DWORD_PTR)(LPTSTR)aMuisetupHelpIds );
        break;
    }
    case WM_CONTEXTMENU:      // right mouse click
    {
        WinHelp( (HWND)wParam,
                 g_szMUIHelpFilePath,
                 HELP_CONTEXTMENU,
                 (DWORD_PTR)(LPTSTR)aMuisetupHelpIds );
        break;
    }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            EnableWindow(hwndDlg, FALSE);            
            if (StartGUISetup(hwndDlg))
            {
                EndDialog(hwndDlg, 0);
            }
            else
            {
                EnableWindow(hwndDlg, TRUE);  
                SetFocus(hwndDlg);
            }
            return TRUE;
        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;
                            
        case IDC_DEF_UI_LANG_COMBO:
            switch(HIWORD(wParam))
            {                       
            case CBN_SELCHANGE:
                UpdateCombo(hwndDlg);
                return TRUE;
            default:
                break;
            }
            break;
        case IDC_CHECK_LOCALE:
            if (BST_CHECKED == IsDlgButtonChecked( hwndDlg, IDC_CHECK_LOCALE))
            {
                EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_UIFONT), TRUE);
            }
            else
            {
                CheckDlgButton(hwndDlg, IDC_CHECK_UIFONT, BST_UNCHECKED);
                EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_UIFONT), FALSE);                
            }
            break;
        }
            
        //
        //    End of WM_COMMAND case
        //
        break;
    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
            case(NM_CUSTOMDRAW):
                ListViewCustomDraw(hwndDlg, (LPNMLVCUSTOMDRAW)lParam);
                return TRUE;
                break;
            case (LVN_ITEMCHANGING):
                return ListViewChanging( hwndDlg,
                                         IDC_LIST1,
                                         (NM_LISTVIEW *)lParam);
                break;
            case (LVN_ITEMCHANGED) :
                ListViewChanged( hwndDlg,
                                 IDC_LIST1,
                                 (NM_LISTVIEW *)lParam );
                break;
            default:
                return FALSE;
            }
            break;
        case WM_CLOSE:
            EndDialog(hwndDlg, 0);
            return TRUE;
            
        case WM_DESTROY:
            DialogCleanUp(hwndDlg);
            return TRUE;
        default:
            return FALSE;
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  ListViewChanging
//
//  Processing for a LVN_ITEMCHANGING message
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ListViewChanging(HWND hDlg, int iID, NM_LISTVIEW *pLV)
{
    HWND         hwndLV = GetDlgItem(hDlg, iID);
    PMUILANGINFO pMuiLangInfo;
    
    //
    //  Make sure it's a state change message
    //
    if ((!(pLV->uChanged & LVIF_STATE)) || ((pLV->uNewState & 0x3000) == 0))
        return FALSE;
    //
    //  Don't let the System Default be unchecked
    //
    GetMuiLangInfoFromListView(hwndLV, pLV->iItem, &pMuiLangInfo);
    if (MAKELCID(gSystemUILangId, SORT_DEFAULT) == pMuiLangInfo->lcid)
        return TRUE;
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  ListViewChanged
//
//  Processing for a LVN_ITEMCHANGED message
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ListViewChanged(HWND hDlg, int iID, NM_LISTVIEW *pLV)
{
    HWND         hwndLV = GetDlgItem(hDlg, iID);
    PMUILANGINFO pMuiLangInfo;
    int          iCount;
    BOOL         bChecked;
    //
    //  Make sure it's a state change message.
    //
    
    if ((!(pLV->uChanged & LVIF_STATE)) ||
        ((pLV->uNewState & 0x3000) == 0))
    {
        return (FALSE);
    }
    //
    //  Get the state of the check box for the currently selected item.
    //
    bChecked = ListView_GetCheckState(hwndLV, pLV->iItem) ? TRUE : FALSE;
    //
    //  Don't let the System Default or the current user UI language be unchecked
    //
    GetMuiLangInfoFromListView(hwndLV, pLV->iItem, &pMuiLangInfo);
    if (MAKELCID(gSystemUILangId, SORT_DEFAULT) == pMuiLangInfo->lcid)
        
    {
        //
        //  Set Default check state
        //
        
        if (bChecked == FALSE)
        {
            ListView_SetCheckState( hwndLV,
                                    pLV->iItem,
                                    TRUE );
        }
        return FALSE;
    }
    //
    //  Deselect all items.
    //
    
    iCount = ListView_GetItemCount(hwndLV);
    while (iCount > 0)
    {
        iCount--;
        ListView_SetItemState( hwndLV,
                               iCount,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
    }
    //
    //  Make sure this item is selected.
    //
    ListView_SetItemState( hwndLV,
                           pLV->iItem,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );
   //
   // Update the combo box
   //
   PostMessage( hDlg,
                WM_COMMAND,
                MAKEWPARAM(IDC_DEF_UI_LANG_COMBO, CBN_SELCHANGE),
                0L);
   //
   //  Return success.
   //
    
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  ListViewCustomDraw
//
//  Processing for list view WM_CUSTOMDRAW notification.
//
////////////////////////////////////////////////////////////////////////////////////
void ListViewCustomDraw(HWND hDlg, LPNMLVCUSTOMDRAW pDraw)
{
    HWND hwndLV = GetDlgItem(hDlg, IDC_LIST1);
    PMUILANGINFO pMuiLangInfo;
    //
    //  Tell the list view to notify me of item draws.
    //
    if (pDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
    {
        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_NOTIFYITEMDRAW);
        return;
    }
    //  
    //  Handle the Item Prepaint.
    //
    if (pDraw->nmcd.dwDrawStage & CDDS_ITEMPREPAINT)
    {
        //
    // Check to see if the item being drawn is the system default or
        // the current active ui language
        //
        GetMuiLangInfoFromListView(hwndLV, (int)pDraw->nmcd.dwItemSpec, &pMuiLangInfo);
        if (MAKELCID(gSystemUILangId, SORT_DEFAULT) == pMuiLangInfo->lcid)
            
        {
            pDraw->clrText = (GetSysColor(COLOR_GRAYTEXT));
        }
    }   
    //
    //  Do the default action.
    //
    
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, CDRF_DODEFAULT);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  StartGUISetup
//
//  Creates dialog with progress bar for installation
//
////////////////////////////////////////////////////////////////////////////////////
BOOL StartGUISetup(HWND hwndDlg)
{
    
    LONG_PTR lppArgs[3];
    ULONG ulParam[2];
    TCHAR lpMessage[BUFFER_SIZE];
    TCHAR szBuf[BUFFER_SIZE];
    INT64 ulSizeNeed,ulSizeAvailable;
    BOOL success;
    HWND hList;
    HWND hCombo;
    int iIndex;
    TCHAR lpAddLanguages[BUFFER_SIZE];
    TCHAR lpRemoveLanguages[BUFFER_SIZE];
    TCHAR lpDefaultUILang[BUFFER_SIZE];
    TCHAR szPostParameter[BUFFER_SIZE];
    
    int installLangCount;   // The number of MUI languages to be installed
    int uninstallLangCount; // The number of MUI langauges to be uninstalled.
    LANGID langID;
    HRESULT hresult;
    
    INSTALL_LANG_GROUP installLangGroup;
    
    //
    // (0) Check available disk space
    //
    if(!IsSpaceEnough(hwndDlg,&ulSizeNeed,&ulSizeAvailable))
    {
     
       ulParam[0] = (ULONG) (ulSizeNeed/1024);
       ulParam[1] = (ULONG) (ulSizeAvailable/1024);
       LoadString(ghInstance, IDS_DISKSPACE_NOTENOUGH, lpMessage, ARRAYSIZE(lpMessage)-1);
       LoadString(ghInstance, IDS_ERROR_DISKSPACE, szBuf, ARRAYSIZE(szBuf)-1);
       FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                lpMessage,
                                0,
                                0,
                                lpMessage,
                                ARRAYSIZE(lpMessage)-1,
                                (va_list *)ulParam);
       LogMessage(lpMessage);
       MESSAGEBOX(NULL, lpMessage, szBuf, MB_OK | MB_DEFBUTTON1 | MB_ICONWARNING);
       //
       // Let User has another chance to reselect
       //
       return FALSE;
       
    }
    
    installLangGroup.bFontLinkRegistryTouched = FALSE;
    installLangGroup.NotDeleted               = 0;
    //
    // (1) Install Language Group First
    //
    ConvertMUILangToLangGroup(hwndDlg, &installLangGroup);
        
    hList=GetDlgItem(hwndDlg, IDC_LIST1);  
    hCombo=GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);
    
    installLangCount = EnumSelectedLanguages(hList, lpAddLanguages);
    memmove(g_AddLanguages,lpAddLanguages,ARRAYSIZE(lpAddLanguages));
    uninstallLangCount = EnumUnselectedLanguages(hList, lpRemoveLanguages);
    //
    // Let's read the user's UI language selection,
    // and then call the kernel to update the registry.
    //
    hList = GetDlgItem(hwndDlg, IDC_LIST1);
    hCombo = GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);
    iIndex = (int)SendMessage(hCombo, CB_GETCURSEL, 0, 0);
    if (iIndex == CB_ERR)
    {
        return FALSE;
    }
    langID = LANGIDFROMLCID((LCID) SendMessage(hCombo, CB_GETITEMDATA, iIndex, 0L));
    //*STRSAFE*     wsprintf(lpDefaultUILang, TEXT("%X"), langID);
    hresult = StringCchPrintf(lpDefaultUILang , ARRAYSIZE(lpDefaultUILang),  TEXT("%X"), langID);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    DEBUGMSGBOX(NULL, TEXT("About to do setup"), NULL, MB_OK);
    success = DoSetup(
        hwndDlg,
        uninstallLangCount, lpRemoveLanguages, 
        installLangGroup, 
        installLangCount, lpAddLanguages, 
        g_bLipLanguages? lpAddLanguages:lpDefaultUILang, 
        TRUE, TRUE, TRUE);
    return (success);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  ProgressDialogFunc
//
//  Callback function for progresss dialog
//
////////////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ProgressDialogFunc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case WM_INITDIALOG:
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hwndDlg, 0);
            return TRUE;
                
        }
        break;
     case WM_CLOSE:
         EndDialog(hwndDlg, 0);
         return TRUE;
            
     case WM_DESTROY:
         EndDialog(hwndDlg, 0);
         return TRUE;
     default:
         return FALSE;
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  InitializeInstallDialog
//
//  Sets contents of list view and combo box in installation dialog
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InitializeInstallDialog(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{    
    HWND hList, hCombo;
    PTSTR lpLanguages;
    TCHAR tchBuffer[BUFFER_SIZE];
    TCHAR lpDefaultSystemLanguage[BUFFER_SIZE],lpUILanguage[BUFFER_SIZE];
    TCHAR lpMessage[BUFFER_SIZE];
    int iIndex;
    int iChkIndex,iCnt,iMUIDirectories=0;    
    HRESULT hresult;
    lpLanguages = tchBuffer;
    SetWindowTitleFromResource(hwndDlg, IDS_MAIN_TITLE);
    hList = GetDlgItem(hwndDlg, IDC_LIST1);
    hCombo=GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);
    InitializeListView(hList);
    //
    //  Insert the default system language in the list view
    //  
    //*STRSAFE*     _stprintf(lpDefaultSystemLanguage, TEXT("%04x"), gSystemUILangId);
    hresult = StringCchPrintf(lpDefaultSystemLanguage , ARRAYSIZE(lpDefaultSystemLanguage),  TEXT("%04x"), gSystemUILangId);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    iIndex=InsertLanguageInListView(hList, lpDefaultSystemLanguage, TRUE);
    //
    //  Insert the languages in MUI.INF in the list view
    //
    if ( ( (iMUIDirectories =EnumLanguages(lpLanguages)) == 0)  && (g_UILanguageGroup.iCount == 0 ) )
    {
        //
        //  No languages found in MUI.INF
        //
        LoadString(ghInstance, IDS_NO_LANG_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return FALSE;
    }
    while (*lpLanguages != TEXT('\0'))
    {
       if (CheckLanguageIsQualified(lpLanguages))
       {
            InsertLanguageInListView(hList, lpLanguages, FALSE);
       }
       lpLanguages = _tcschr(lpLanguages, '\0');
       lpLanguages++;       
    }   
    //
    // We should also check all installed UI languages
    //
    for (iCnt=0; iCnt<g_UILanguageGroup.iCount; iCnt++)
    {
        if (!GetLcidItemIndexFromListView(hList, g_UILanguageGroup.lcid[iCnt], &iChkIndex))
        {  
            //*STRSAFE*             _stprintf(lpUILanguage, TEXT("%04x"), g_UILanguageGroup.lcid[iCnt]);
            hresult = StringCchPrintf(lpUILanguage , ARRAYSIZE(lpUILanguage),  TEXT("%04x"), g_UILanguageGroup.lcid[iCnt]);
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
            if (CheckLanguageIsQualified(lpUILanguage))
            {
                InsertLanguageInListView(hList, lpUILanguage, FALSE);
            }
        }
    }
    //
    // Let's detect which language groups are installed
    //
    DetectLanguageGroups(hwndDlg);
    SelectInstalledLanguages(hList);
    SetDefault(hCombo);
    //
    //  Deselect all items.
    //
    iIndex = ListView_GetItemCount(hList);
    while (iIndex > 0)
    {
        iIndex--;
        ListView_SetItemState( hList,
                               iIndex,
                               0,
                               LVIS_FOCUSED | LVIS_SELECTED );
    }
    //
    //  Select the first one in the list.
    //
    ListView_SetItemState( hList,
                           0,
                           LVIS_FOCUSED | LVIS_SELECTED,
                           LVIS_FOCUSED | LVIS_SELECTED );
    //
    // Match system locale with the default UI language
    //
    if (CheckMUIRegSetting(MUI_MATCH_LOCALE))
    {
        CheckDlgButton(hwndDlg, IDC_CHECK_LOCALE, BST_CHECKED);
        //
        // Match UI font with the default UI language
        // 
        if (g_bMatchUIFont = CheckMUIRegSetting(MUI_MATCH_UIFONT))
        {
            CheckDlgButton(hwndDlg, IDC_CHECK_UIFONT, BST_CHECKED);
        }
    }
    else
    {
        SetMUIRegSetting(MUI_MATCH_UIFONT, FALSE);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHECK_UIFONT), FALSE);
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    CheckForUsingCountryName
//
//    Fetch MUIINF file if the selected UI lang needs to be displayed as a language
//    name or a country name.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckForUsingCountryName(PMUILANGINFO pMuiLangInfo)
{
    TCHAR szSource[MAX_PATH];
    szSource[0] = TEXT('\0');
    //
    // Try check if there is a value for it under [UseCountryName]
    //
    GetPrivateProfileString( MUI_COUNTRYNAME_SECTION,
                             pMuiLangInfo->lpszLcid,
                             TEXT(""),
                             szSource,
                             MAX_PATH,
                             g_szMUIInfoFilePath);
    if (szSource[0] == TEXT('1'))
    {
        return (TRUE);
    }
    return (FALSE);
}
////////////////////////////////////////////////////////////////////////////////////
//
//    GetDisplayName
//
//    Fetch MUIINF file if the selected UI lang needs to be displayed using the
//    name specified in [LanguageDisplayName] section of mui.inf.
//    Otherwise, get the display name according to the values in [UseCountryName].
//    If the value for the specified LCID is 1, use the country name. Otherwise,
//    use the locale name.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetDisplayName(PMUILANGINFO pMuiLangInfo)
{
    //
    // Try check if there is a customized display name for the specified LCID under [LanguageDisplayName].
    //
    pMuiLangInfo->szDisplayName[0] = L'\0';
    if (pMuiLangInfo->lpszLcid)
    {
        GetPrivateProfileString( MUI_DISPLAYNAME_SECTION,
                                 pMuiLangInfo->lpszLcid,
                                 TEXT(""),
                                 pMuiLangInfo->szDisplayName,
                                 MAX_PATH,
                                 g_szMUIInfoFilePath);
    }
    if (pMuiLangInfo->szDisplayName[0] == L'\0')
    {
        //
        // There is no entry in [LanguageDisplayName].  Use the country name or locale name.
        //
        Muisetup_GetLocaleLanguageInfo( pMuiLangInfo->lcid,
                                        pMuiLangInfo->szDisplayName,
                                        ARRAYSIZE(pMuiLangInfo->szDisplayName)-1,
                                        CheckForUsingCountryName(pMuiLangInfo));
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
// GetLanguageGroupDisplayName
// Get language group display name for MUI install/uninstall dialog
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetLanguageGroupDisplayName(LANGID LangId, LPTSTR lpBuffer, int nSize)
{
    BOOL bRet = FALSE;
    MUILANGINFO MuiLangInfo = {0};
    HRESULT hresult;
    if ( (!lpBuffer) || (nSize == 0))
    {
        return bRet;
    }
    MuiLangInfo.lcid = MAKELCID(LangId, SORT_DEFAULT);
    MuiLangInfo.lgrpid = GetLanguageGroup(MuiLangInfo.lcid);
    if (GetDisplayName(&MuiLangInfo) &&
        nSize >= lstrlen(MuiLangInfo.szDisplayName))
    {
        //*STRSAFE*         lstrcpy(lpBuffer, MuiLangInfo.szDisplayName);
        hresult = StringCchCopy(lpBuffer , nSize, MuiLangInfo.szDisplayName);
        if (!SUCCEEDED(hresult))
        {
           return bRet;
        }
        bRet = TRUE;
    }
    return bRet;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    Get UI, IE and LPK files size for the lcid
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetUIFileSize(PMUILANGINFO pMuiLangInfo)
{
    TCHAR szSize[MAX_PATH];
    int   nCD;
    pMuiLangInfo->ulUISize = 0;
    pMuiLangInfo->ulLPKSize = 0;
    
#if defined(_IA64_)
    BOOL bIA64 = TRUE;
#else
    BOOL bIA64 = FALSE;
#endif

    if (!pMuiLangInfo)
    {
        return FALSE;
    }
    szSize[0] = TEXT('\0');
    //
    // Try to get UI files size under [FileSize_UI]
    //
    if (GetPrivateProfileString( bIA64? MUI_UIFILESIZE_SECTION_IA64 : MUI_UIFILESIZE_SECTION,
                             pMuiLangInfo->lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))
    {  
       pMuiLangInfo->ulUISize =_wtoi64(szSize);
    }
    szSize[0] = TEXT('\0');
    //
    // Try to get LPK files size under [FileSize_LPK]
    //
    if (GetPrivateProfileString( bIA64? MUI_LPKFILESIZE_SECTION_IA64 : MUI_LPKFILESIZE_SECTION,
                             pMuiLangInfo->lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))
    {  
       pMuiLangInfo->ulLPKSize =_wtoi64(szSize);
    }
    //
    // Try to get CD # under [CD_LAYOUT]
    //
    nCD=GetPrivateProfileInt(bIA64? MUI_CDLAYOUT_SECTION_IA64 : MUI_CDLAYOUT_SECTION,
                             pMuiLangInfo->lpszLcid,
                             0,
                             g_szMUIInfoFilePath);
    if (nCD)
    {    
       pMuiLangInfo->cd_number = nCD;
       if (g_cdnumber == 0)
       {
          g_cdnumber = pMuiLangInfo->cd_number;
       }
    }
    else
    {
       pMuiLangInfo->cd_number = DEFAULT_CD_NUMBER;
    }
    return TRUE;
}
BOOL GetUIFileSize_commandline(LPTSTR lpszLcid, INT64 *ulUISize,INT64 *ulLPKSize)
{
    TCHAR szSize[MAX_PATH];
    *ulUISize = 0;
    *ulLPKSize = 0;
    
#if defined(_IA64_)
    BOOL bIA64 = TRUE;
#else
    BOOL bIA64 = FALSE;
#endif
   if (  (!lpszLcid) || (!ulUISize) || (!ulLPKSize))   	
   {
       return FALSE;
   }
    szSize[0] = TEXT('\0');
    //
    // Try to get UI files size under [FileSize_UI]
    //
    if (GetPrivateProfileString( bIA64? MUI_UIFILESIZE_SECTION_IA64 : MUI_UIFILESIZE_SECTION,
                             lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))
    {  
       *ulUISize =_wtoi64(szSize); 
    }
    
    szSize[0] = TEXT('\0');
    //
    // Try to get LPK files size under [FileSize_LPK]
    //
    if (GetPrivateProfileString( bIA64? MUI_LPKFILESIZE_SECTION_IA64 : MUI_LPKFILESIZE_SECTION,
                             lpszLcid,
                             TEXT(""),
                             szSize,
                             MAX_PATH,
                             g_szMUIInfoFilePath))
    {  
       *ulLPKSize =_wtoi64(szSize);
    }
    // Try to get CD # under [CD_LAYOUT]
    //
    if (g_cdnumber == 0)
    {
       g_cdnumber=GetPrivateProfileInt( bIA64? MUI_CDLAYOUT_SECTION_IA64 : MUI_CDLAYOUT_SECTION,
                                lpszLcid,
                                0,
                                g_szMUIInfoFilePath);
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    InitializeListView
//
//    Gets the list view ready for inserting items
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InitializeListView(HWND hList)
{
    DWORD dwExStyle;
    LV_COLUMN Column;
    RECT Rect;
    
    GetClientRect(hList, &Rect);
    Column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    Column.fmt = LVCFMT_LEFT;
    Column.cx = Rect.right - GetSystemMetrics(SM_CYHSCROLL);
    Column.pszText = NULL;
    Column.cchTextMax = 0;
    Column.iSubItem = 0;
    ListView_InsertColumn(hList, 0, &Column);
    dwExStyle = ListView_GetExtendedListViewStyle(hList);
    ListView_SetExtendedListViewStyle(hList, dwExStyle | LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//
//    Check if specified language can install on the target machine.
//    I.E. Arabic, Turkish, Greek and Hebrew MUI can only install on NT Workstation;
//         They are not allowed on NT Server
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckLanguageIsQualified(LPTSTR lpLanguage)
{
#ifdef XCHECK_LANGUAGE_FOR_PLATFORM
    BOOL   bResult = FALSE;    
    
    LANGID LgLang;

    if (!lpLanguage)
    {
         return bResult;
    }
    LgLang = (LANGID)_tcstol(lpLanguage, NULL, 16);
    LgLang = PRIMARYLANGID(LgLang);
    if(gbIsAdvanceServer)
    {
      if (LgLang == LANG_GERMAN     || LgLang == LANG_FRENCH  || LgLang == LANG_SPANISH   ||
          LgLang == LANG_JAPANESE   || LgLang == LANG_KOREAN  || LgLang == LANG_CHINESE)
      {
          bResult = TRUE;
      }   
    }
    else if(gbIsServer)
    {
      if (LgLang == LANG_GERMAN     || LgLang == LANG_FRENCH  || LgLang == LANG_SPANISH   ||
          LgLang == LANG_JAPANESE   || LgLang == LANG_KOREAN  || LgLang == LANG_CHINESE   ||
          LgLang == LANG_SWEDISH    || LgLang == LANG_ITALIAN || LgLang == LANG_DUTCH     ||
          LgLang == LANG_PORTUGUESE || LgLang == LANG_CZECH   || LgLang == LANG_HUNGARIAN ||
          LgLang == LANG_POLISH     || LgLang == LANG_RUSSIAN || LgLang == LANG_TURKISH)
      {
          bResult = TRUE;
      }
    }    
    else if(gbIsWorkStation)
    {
          bResult = TRUE;
    }                    
    return bResult;                           
#else
    return TRUE;
#endif
}
////////////////////////////////////////////////////////////////////////////////////
//
//    InsertLanguageInListView
//
//    Returns the index of the item in the list view after inserting it.
//
////////////////////////////////////////////////////////////////////////////////////
int InsertLanguageInListView(HWND hList, LPTSTR lpLanguage, BOOL bCheckState)
{
    LANGID LgLang;
    LV_ITEM lvItem;
    PMUILANGINFO pMuiLangInfo;
    int iIndex;
    HRESULT hresult;

    if (!lpLanguage)
   {
       return -1;
   }
    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE | LVIF_IMAGE;
    lvItem.iItem = 0;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = LVIS_STATEIMAGEMASK;
    lvItem.cchTextMax = 0;
    lvItem.iImage = 0;
    //
    // Allocate enough space to hold pszLcid and MUILANGINFO
    //
    pMuiLangInfo = (PMUILANGINFO) LocalAlloc(LPTR, sizeof(MUILANGINFO));
    if (pMuiLangInfo == NULL)
    {        
        ExitFromOutOfMemory();
    }
    else
    {        
        pMuiLangInfo->lpszLcid = (LPTSTR) LocalAlloc(LMEM_FIXED, (_tcslen(lpLanguage) + 1) * sizeof(TCHAR));
    }
    if (pMuiLangInfo->lpszLcid == NULL)
    {
        ExitFromOutOfMemory();
    }
    else
    {
        //
        // Init pszLcid
        //
        lvItem.lParam = (LPARAM)pMuiLangInfo;
        //*STRSAFE*     _tcscpy((LPTSTR)pMuiLangInfo->lpszLcid, lpLanguage);
        hresult = StringCchCopy((LPTSTR)pMuiLangInfo->lpszLcid ,_tcslen(lpLanguage) + 1 , lpLanguage);
        if (!SUCCEEDED(hresult))
        {
           return -1;
        }
    }
    //
    //  Init lcid
    //
    LgLang = (LANGID)_tcstol(lpLanguage, NULL, 16);
    
    pMuiLangInfo->lcid = MAKELCID(LgLang, SORT_DEFAULT);
    if (pMuiLangInfo->szDisplayName[0] == L'\0')
    {
        GetDisplayName(pMuiLangInfo);
    }        
    
    lvItem.pszText = pMuiLangInfo->szDisplayName;
    
    GetUIFileSize(pMuiLangInfo);
    iIndex = ListView_InsertItem(hList, &lvItem);
    if (iIndex >= 0)
    {
        ListView_SetCheckState(hList, iIndex, bCheckState);
    }
    return iIndex;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    GetMuiLangInfoFromListView
//
//    Get the MuiLangInfo of the corresponding ListView Item
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetMuiLangInfoFromListView(HWND hList, int i, PMUILANGINFO *ppMuiLangInfo)
{
    LVITEM lvItem;

    if (!ppMuiLangInfo)
    {
        return FALSE;
    }
    //
    // Check if Language Group is installed
    //
    lvItem.mask = LVIF_PARAM;
    lvItem.iItem = i;
    lvItem.iSubItem = 0;
    lvItem.state = 0;
    lvItem.stateMask = 0;
    lvItem.pszText = 0;
    lvItem.cchTextMax = 0;
    lvItem.iImage = 0;
    lvItem.lParam = 0;
    ListView_GetItem(hList, &lvItem);
    *ppMuiLangInfo = (PMUILANGINFO)lvItem.lParam;
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    Muisetup_GetLocaleLanguageInfo
//
//    Read the locale info of the language or country name.
//
////////////////////////////////////////////////////////////////////////////////////
int Muisetup_GetLocaleLanguageInfo(LCID lcid, PTSTR pBuf, int iLen, BOOL fUseCountryName)
{
    TCHAR tchBuf[ MAX_PATH ] ;
    int iRet;
    HRESULT hresult;

    if ( (!pBuf) || (iLen == 0))
    {
       return 0;
    }
    //
    // If this is either 0x0404 or 0x0804, then mark them specially
    //
    if (0x0404 == lcid)
    {
        iRet = LoadString(ghInstance, IDS_MUI_CHT, pBuf, iLen);
    }
    else if (0x0804 == lcid)
    {
        iRet = LoadString(ghInstance, IDS_MUI_CHS, pBuf, iLen);
    }
    else
    {
        iRet = GetLocaleInfo( lcid,
                              LOCALE_SENGLANGUAGE,
                              pBuf,
                              iLen);
        if (fUseCountryName)
        {
            iRet = GetLocaleInfo( lcid,
                                  LOCALE_SENGCOUNTRY,
                                  tchBuf,
                                  (sizeof(tchBuf)/sizeof(TCHAR)));
            if (iRet)
            {
                //*STRSAFE*                 _tcscat(pBuf, TEXT(" ("));
                hresult = StringCchCat(pBuf , iLen, TEXT(" ("));
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }                
                //*STRSAFE*                 _tcscat(pBuf, tchBuf);
                hresult = StringCchCat(pBuf , iLen, tchBuf);
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }
                //*STRSAFE*                 _tcscat(pBuf, TEXT(")"));
                hresult = StringCchCat(pBuf , iLen, TEXT(")"));
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }
            }
        }
    }
    return iRet;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    GetLcidFromComboBox
//
//    Retreives the index of the combo box item that corresponds to this UI Language
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetLcidFromComboBox(HWND hCombo, LCID lcid, int *piIndex)
{
    LCID ItemLcid;
    int i;
    int iCount = (int)SendMessage(hCombo, CB_GETCOUNT, 0L, 0L);
    if (!piIndex)
    {
        return FALSE;        
    }
    if (CB_ERR != iCount)
    {
        i = 0;
        while (i < iCount)
        {
            ItemLcid = (LCID)SendMessage(hCombo, CB_GETITEMDATA, (WPARAM)i, (LPARAM)0);
            if ((CB_ERR != ItemLcid) && (ItemLcid == lcid))
            {
                *piIndex = i;
                return TRUE;
            }
            i++;
        }
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//    GetMuiLangInfoFromListView
//
//    Retreives the index of the listview item that corresponds to this UI Language
//
////////////////////////////////////////////////////////////////////////////////////
BOOL GetLcidItemIndexFromListView(HWND hList, LCID lcid, int *piIndex)
{
    int iCount = ListView_GetItemCount(hList);
    int i;
    PMUILANGINFO pMuiLangInfo;
    LVITEM lvItem;
    if (!piIndex)
    {
        return FALSE;        
    }
    i = 0;
    while (i < iCount)
    {
        //
        // Check if Language Group is installed
        //
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = 0;
        lvItem.cchTextMax = 0;
        lvItem.iImage = 0;
        lvItem.lParam = 0;
        ListView_GetItem(hList, &lvItem);
        pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;
        if (pMuiLangInfo->lcid == lcid)
        {
            *piIndex = i;
            return TRUE;
        }
        i++;
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  SelectInstalledLanguages
//
//  Sets the list view check state for insalled languages
//
// TODO: We should perhaps use the MSI to check for installed packages instead...
////////////////////////////////////////////////////////////////////////////////////
BOOL SelectInstalledLanguages(HWND hList)
{
    DWORD dwData;
    DWORD dwIndex;
    DWORD dwValue;
    HKEY hKey;
    LANGID LgLang;
    LONG rc;
    TCHAR lpItemString[BUFFER_SIZE];
    TCHAR szData[BUFFER_SIZE];
    TCHAR szValue[BUFFER_SIZE];
    int iIndex;
    int nLvIndex;
    if (hKey = OpenMuiKey(KEY_READ))
    {
        dwIndex = 0;
        rc = ERROR_SUCCESS;
        iIndex = ListView_GetItemCount(hList);
        while(rc==ERROR_SUCCESS)
        {
            dwValue=sizeof(szValue)/sizeof(TCHAR);
            szValue[0]=TEXT('\0');
            dwData = sizeof(szData);
            szData[0] = TEXT('\0');
            DWORD dwType;
            rc = RegEnumValue(hKey, dwIndex, szValue, &dwValue, 0, &dwType, (LPBYTE)szData, &dwData);
            
            if (rc == ERROR_SUCCESS)
            {
                if (dwType != REG_SZ)
                {
                    dwIndex++;
                    continue;
                }
                LgLang=(WORD)_tcstol(szValue, NULL, 16); 
                if (GetLcidItemIndexFromListView(hList, MAKELCID(LgLang, SORT_DEFAULT), &nLvIndex))
                {
                    ListView_SetCheckState(hList, nLvIndex, TRUE);
                }
            }
            dwIndex++;
        }
        RegCloseKey(hKey);
        return TRUE;
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  UpdateCombo
//
//  Updates the combo box to correspond to the languages selected in the list view
//
////////////////////////////////////////////////////////////////////////////////////
BOOL UpdateCombo(HWND hwndDlg)
{
    BOOL bDefaultSet=FALSE;
    HWND hCombo;
    HWND hList;
    TCHAR lpBuffer[BUFFER_SIZE];
    TCHAR lpSystemDefault[BUFFER_SIZE];
    int i;
    int iIndex;
    int iLbIndex;
    int iListIndex;
    WPARAM iPrevDefault;
    LCID lcidPrev;
    PMUILANGINFO pMuiLangInfo;
    hList = GetDlgItem(hwndDlg, IDC_LIST1);
    hCombo = GetDlgItem(hwndDlg, IDC_DEF_UI_LANG_COMBO);
    //
    //  If the Previous Default is still selected, keep it as the default
    //
    iPrevDefault = SendMessage(hCombo, CB_GETCURSEL, 0, 0);
    if (iPrevDefault == CB_ERR)
        return FALSE;
    lcidPrev = (LCID) SendMessage(hCombo, CB_GETITEMDATA, (WPARAM)iPrevDefault, 0);
    //
    //  Get the text of the currently selected default
    //
    GetLcidItemIndexFromListView(hList, lcidPrev, &iLbIndex);
    
    SendMessage(hCombo, CB_RESETCONTENT, 0, 0);
    iIndex = ListView_GetItemCount(hList);
    iListIndex = 0;
        
    //
    // See if we can preserve the default.
    //
    i = 0;
    while (i < iIndex)
    {
        if (ListView_GetCheckState(hList, i))
        {
            ListView_GetItemText(hList, i, 0, lpBuffer, ARRAYSIZE(lpBuffer)-1);
            iListIndex = (int) SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)lpBuffer);
            if (CB_ERR != iListIndex)
            {
                GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);
                SendMessage(hCombo, CB_SETITEMDATA, iListIndex, (LPARAM)(LCID)pMuiLangInfo->lcid);
                if (pMuiLangInfo->lcid == lcidPrev)
                {
                    SendMessage(hCombo, CB_SETCURSEL, (WPARAM)iListIndex, 0);
                    bDefaultSet = TRUE;
                }
            }
        }
        i++;
    }
    //
    // If no default, force the system default.
    //
    if (!bDefaultSet)
    {
        lcidPrev = MAKELCID(gSystemUILangId, SORT_DEFAULT);
        if (!GetLcidFromComboBox(hCombo, lcidPrev, &iIndex))
        {
            GetLocaleInfo(lcidPrev,
                          LOCALE_SENGLANGUAGE,
                          lpSystemDefault,
                          ARRAYSIZE(lpSystemDefault)-1);
            iIndex = (int) SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)lpSystemDefault);
            SendMessage(hCombo, CB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)(LCID)lcidPrev);
        }
        SendMessage(hCombo, CB_SETCURSEL, (WPARAM)iIndex, 0);
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  SetDefault
//
//  Sets the default user setting in the combo box
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SetDefault(HWND hCombo)
{
    int iIndex;
    TCHAR lpBuffer[BUFFER_SIZE];
    LCID lcid = MAKELCID(GetDotDefaultUILanguage(), SORT_DEFAULT);
    GetLocaleInfo(lcid,
                  LOCALE_SENGLANGUAGE,
                  lpBuffer,
                  ARRAYSIZE(lpBuffer)-1);
    
    iIndex = (int)SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)lpBuffer);
    if (CB_ERR != iIndex)
    {
        SendMessage(hCombo, CB_SETITEMDATA, (WPARAM)iIndex, (LPARAM)(DWORD) lcid);
        SendMessage(hCombo, CB_SETCURSEL, (WPARAM)iIndex, 0);
    }
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  SetUserDefaultLanguage
//
//  Sets the default language in the registry
//
////////////////////////////////////////////////////////////////////////////////////
BOOL SetUserDefaultLanguage(LANGID langID, BOOL bApplyCurrentUser, BOOL bApplyAllUsers)
{
    TCHAR szCommands[BUFFER_SIZE];
    TCHAR szBuf[BUFFER_SIZE];
    BOOL  success;
    LONG_PTR lppArgs[2];
    HRESULT hresult;
    
    //
    // Set the UI language now
    //
    // status = gpfnNtSetDefaultUILanguage(LANGIDFROMLCID(langID));
    szCommands[0] = TEXT('\0');
    if (bApplyCurrentUser)
    {
        // E.g. MUILanguage = "0411".
        //*STRSAFE*         wsprintf(szCommands, TEXT("MUILanguage=\"%x\"\n"), langID);
        hresult = StringCchPrintf(szCommands , ARRAYSIZE(szCommands),  TEXT("MUILanguage=\"%x\"\n"), langID);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    }        
    if (bApplyAllUsers)
    {    
        //*STRSAFE*         wsprintf(szBuf, TEXT("MUILanguage_DefaultUser = \"%x\""), langID);
        hresult = StringCchPrintf(szBuf , ARRAYSIZE(szBuf),  TEXT("MUILanguage_DefaultUser = \"%x\""), langID);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        //*STRSAFE*         _tcscat(szCommands, szBuf);
        hresult = StringCchCat(szCommands , ARRAYSIZE(szCommands), szBuf);
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    }
    success = RunRegionalOptionsApplet(szCommands);
    lppArgs[0] = langID;
    if (success)
    {
        if (bApplyCurrentUser)
        {
            LogFormattedMessage(NULL, IDS_SET_UILANG_CURRENT, lppArgs);    
        }
        if (bApplyAllUsers)
        {
            LogFormattedMessage(NULL, IDS_SET_UILANG_ALLUSERS, lppArgs);        
        }
    } else
    {
        if (bApplyCurrentUser)
        {
            LogFormattedMessage(NULL, IDS_ERROR_SET_UILANG_CURRENT, lppArgs);        
        }
        if (bApplyAllUsers)
        {
            LogFormattedMessage(NULL, IDS_ERROR_SET_UILANG_ALLUSERS, lppArgs);        
        }
    }
    return (success);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  GetDotDefaultUILanguage
//
//  Retrieve the UI language stored in the HKCU\.Default.
//  This is the default UI language for new users.
//
////////////////////////////////////////////////////////////////////////////////////
LANGID GetDotDefaultUILanguage()
{
    HKEY hKey;
    DWORD dwKeyType;
    DWORD dwSize;
    BOOL success = FALSE;
    TCHAR szBuffer[BUFFER_SIZE];
    LANGID langID;
    //
    //  Get the value in .DEFAULT.
    //
    if (RegOpenKeyEx( HKEY_USERS,
                            TEXT(".DEFAULT\\Control Panel\\Desktop"),
                            0L,
                            KEY_READ,
                            &hKey ) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szBuffer);
        if (RegQueryValueEx( hKey,
                            TEXT("MultiUILanguageId"),
                            0L,
                            &dwKeyType,
                            (LPBYTE)szBuffer,
                            &dwSize) == ERROR_SUCCESS)
        {
            if (dwKeyType == REG_SZ)
            {
                langID = (LANGID)_tcstol(szBuffer, NULL, 16);
                success = TRUE;
            }            
        }
        RegCloseKey(hKey);
    }

    // here, check to see if the key is actually meaningful, if not, return SystemDefaultUILanguage
    if (success && (!IsInstalled(szBuffer)))
    {
        success = FALSE;
    }
    
    if (!success)
    {
        langID = GetSystemDefaultUILanguage();
    }
    
    return (langID);    
}
////////////////////////////////////////////////////////////////////////////////////
//
//  CheckLangGroupCommandLine
//
//  Command line version of CheckSupport
//
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckLangGroupCommandLine(PINSTALL_LANG_GROUP pInstallLangGroup, LPTSTR lpArg)
{
    int i = 0;
    int iArg;
    LGRPID lgrpid;

    if ( (!pInstallLangGroup) || (!lpArg))
    {
       return FALSE;
    }
    iArg = _tcstol(lpArg, NULL, 16);
    //
    // See if the lang group for this MUI lang is installed or not
    //
    lgrpid = GetLanguageGroup(MAKELCID(iArg, SORT_DEFAULT));
    if (AddMUILangGroup(pInstallLangGroup, lgrpid))
    {
        return TRUE;        
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  SetWindowTitleFromResource
//
//  Set the window title using the specified resource string ID.
//
////////////////////////////////////////////////////////////////////////////////////
void SetWindowTitleFromResource(HWND hwnd, int resourceID)
{
    TCHAR szBuffer[BUFFER_SIZE];
    LoadString(NULL, resourceID, szBuffer, sizeof(szBuffer)/sizeof(TCHAR));
    SetWindowText(hwnd, szBuffer);
}

BOOL RemoveFileReadOnlyAttribute(LPTSTR lpszFileName)
{
   BOOL   bResult = FALSE;
   DWORD  dwAttrib;
   if (! lpszFileName)
   {
       return bResult;
   }
   dwAttrib = GetFileAttributes (lpszFileName);
   if ( dwAttrib & FILE_ATTRIBUTE_READONLY )
   {
      dwAttrib &= ~FILE_ATTRIBUTE_READONLY;
      SetFileAttributes (lpszFileName, dwAttrib);
      bResult=TRUE;
   }  
   return bResult;
}
BOOL MUI_DeleteFile(LPTSTR lpszFileName)
{
   if (!lpszFileName)
   {
      return FALSE;
   }
   RemoveFileReadOnlyAttribute(lpszFileName);
   return DeleteFile(lpszFileName);
}

BOOL DeleteSideBySideMUIAssemblyIfExisted(LPTSTR Languages, TCHAR pszLogFile[BUFFER_SIZE])
{
    HRESULT hresult;
    if (!Languages)
    {
        return FALSE;
    }
    //*STRSAFE*     lstrcpy(pszLogFile, g_szWinDir);                // c:\windows
    hresult = StringCchCopy(pszLogFile , BUFFER_SIZE, g_szWinDir);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     lstrcat(pszLogFile, MUISETUP_PATH_SEPARATOR);   // c:\windows
    hresult = StringCchCat(pszLogFile , BUFFER_SIZE, MUISETUP_PATH_SEPARATOR);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    
    //*STRSAFE*     lstrcat(pszLogFile, MUIDIR);                    // c:\windows\mui
    hresult = StringCchCat(pszLogFile , BUFFER_SIZE, MUIDIR);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     lstrcat(pszLogFile, MUISETUP_PATH_SEPARATOR);   // c:\windows\mui
    hresult = StringCchCat(pszLogFile , BUFFER_SIZE, MUISETUP_PATH_SEPARATOR);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    
    //*STRSAFE*     lstrcat(pszLogFile, MUISETUP_ASSEMBLY_INSTALLATION_LOG_FILENAME);     // c:\windows\mui\muisetup.log.
    hresult = StringCchCat(pszLogFile , BUFFER_SIZE, MUISETUP_ASSEMBLY_INSTALLATION_LOG_FILENAME);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     lstrcat(pszLogFile, Languages);                 // c:\windows\mui\muisetup.log.1234
    hresult = StringCchCat(pszLogFile , BUFFER_SIZE, Languages);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    if (GetFileAttributes(pszLogFile) != 0xFFFFFFFF) // existed
    {
        // open it and delete assemblies in the list
        SXS_UNINSTALLW UninstallData = {sizeof(UninstallData)};
        UninstallData.dwFlags = SXS_UNINSTALL_FLAG_USE_INSTALL_LOG;
        UninstallData.lpInstallLogFile = pszLogFile;
        return gpfnSxsUninstallW(&UninstallData,NULL);
    }else
        return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  InstallSelected
//
//   Install the languages specified
//
//  Return:
//      TURE if the operation succeeds. Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InstallSelected(LPTSTR Languages, BOOL *lpbFontLinkRegistryTouched)
{
    TCHAR       lpMessage[BUFFER_SIZE];
    
    if (!Languages)
    {
        return FALSE;
    }    
    //
    // Next step is to create a list of install directories from layout
    // the directories are listed in the [Directories] section of MUI.INF
    //
    if (!EnumDirectories())
    {
        //
        //  "LOG: Error reading directory list."
        //
        LoadString(ghInstance, IDS_DIRECTORY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }
    EnumFileRename();
    EnumTypeNotFallback();
    //
    // Copy the common files
    //
    if (Languages)
    {
        //
        // Copy MUI files for the selected languages.
        //
#ifdef MUI_MAGIC      
        if (!g_bNoUI)
        {
            SetWindowTitleFromResource(ghProgDialog, IDS_INSTALL_TITLE);
        }
#endif 
        if (!CopyFiles(ghProgDialog, Languages))
        {
            //
            //  "LOG: Error copying files."
            //
            //  stop install if copy fails
            //
            LoadString(ghInstance, IDS_COPY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
            LogMessage(lpMessage);
#ifndef IGNORE_COPY_ERRORS
            gNumLanguages_Install = 0;
            return (FALSE);
#endif
        }
        
#ifndef MUI_MAGIC        
        CopyRemoveMuiItself(TRUE);
#endif
    }
#ifndef MUI_MAGIC
    //
    // register MUI as installed in registry
    //
    if (!UpdateRegistry(Languages,lpbFontLinkRegistryTouched))
    {
        //
        // LOG: Error updating registry
        //
        LoadString(ghInstance, IDS_REGISTRY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }
    if (!InstallExternalComponents(Languages))
    {
        return (FALSE);
    }
#endif
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////////////
//
//   UninstallSelected
//
//   Uninstall the languages specified
//
//  Return:
//      TRUE if the operation succeeds. Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL UninstallSelected(LPTSTR Languages,int *lpNotDeleted)
{
    TCHAR       lpMessage[BUFFER_SIZE];
    BOOL    bResult = TRUE;
    HRESULT hresult;

    if (!Languages)
    {
        return FALSE;
    }    

    //
    // Next step is to create a list of install directories
    // the directories are listed in the [Directories] section
    //
    //
    // this enumerates the directories and fills the array DirNames
    //
    if (!EnumDirectories())
    {
        //
        //   "LOG: Error reading directory list."
        //
        LoadString(ghInstance, IDS_DIRECTORY_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return (FALSE);
    }
#ifndef MUI_MAGIC
    UninstallExternalComponents(Languages);
    if (!g_bNoUI)
    {
        SetWindowTitleFromResource(ghProgDialog, IDS_UNINSTALL_TITLE);
    }
#endif
    //
    // Copy the common files
    //
    if (!DeleteFiles(Languages,lpNotDeleted))
    {
        //
        //  "LOG: Error deleting files"
        //
        LoadString(ghInstance, IDS_DELETE_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        bResult = FALSE;       // even though something failed, we will continue to try to uninstall the product here so upgrade uninstallation will continue clean up
    }
    //
    // register MUI as installed in registry, the function logs messages already, so we don't need to log another one here.
    //
    UninstallUpdateRegistry(Languages);
   
    //
    // Delete sxs Assembly
    //
    if (gpfnSxsUninstallW) 
    {
        TCHAR pszLogFile[BUFFER_SIZE];
        if ( ! DeleteSideBySideMUIAssemblyIfExisted(Languages, pszLogFile)) 
        {
            TCHAR errInfo[BUFFER_SIZE];
            //*STRSAFE*             swprintf(errInfo, TEXT("Assembly UnInstallation of %s failed"), pszLogFile);
            hresult = StringCchPrintf(errInfo , ARRAYSIZE(errInfo),  TEXT("Assembly UnInstallation of %s failed"), pszLogFile);
            if (!SUCCEEDED(hresult))
            {
               return FALSE;
            }
            OutputDebugString(errInfo);
        }
    }
    return (bResult);
}
////////////////////////////////////////////////////////////////////////////////////
//
//   UninstallUpdateRegistry
//
//   Update the Registry to account for languages that have been uninstalled
//
////////////////////////////////////////////////////////////////////////////////////
BOOL UninstallUpdateRegistry(LPTSTR Languages)
{
    LPTSTR Language;
    HKEY   hKeyMUI = 0;
    HKEY   hKeyFileVersions = 0;
    DWORD  dwDisp;
    BOOL   bRet = TRUE;
    TCHAR tcMessage[BUFFER_SIZE];
    
    if (!Languages)
    {
        return FALSE;
    }

    if (RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         REG_MUI_PATH,
                         0,
                         TEXT("REG_SZ"),
                         REG_OPTION_NON_VOLATILE ,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hKeyMUI,
                         &dwDisp) != ERROR_SUCCESS)
    {
        bRet = FALSE;
        goto Exit;
    }
    if (RegCreateKeyEx( HKEY_CURRENT_USER,
                         REG_FILEVERSION_PATH,
                         0,
                         TEXT("REG_SZ"),
                         REG_OPTION_NON_VOLATILE ,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hKeyFileVersions,
                         &dwDisp) != ERROR_SUCCESS)
    {
        bRet = FALSE;
        goto Exit;
    }
    Language = Languages;
    while (*Language)
    {
        //
        // Don't remove system UI language for registry
        //
        if (HexStrToInt(Language) != gSystemUILangId)
        {
            //
            //  Delete UI Language key, subkeys and values.
            //
            if (RegDeleteValue(hKeyMUI, Language) != ERROR_SUCCESS)
            {
                bRet = FALSE;                    
            }
            if (DeleteRegTree(hKeyFileVersions, Language) != ERROR_SUCCESS)
            {
                bRet = FALSE;                    
            }
        }

        //
        // Attempt to delete the Windows installer regkey entry if we are in OS upgrade setup
        //
        if (TRUE == g_bRunFromOSSetup)
        {
            DeleteMSIRegSettings(Language);
        }
        
        while (*Language++)  // go to the next language and repeat
        {
        }
    } // of while (*Language)
    //
    // Delete Match UI Font and Match locale Key
    //
    DeleteMUIRegSetting();

Exit:
    //
    //  Clean up
    //
    if (hKeyMUI)
        RegCloseKey(hKeyMUI);
    if (hKeyFileVersions)
        RegCloseKey(hKeyFileVersions);
    
    return bRet;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  EnumSelectedLanguages
//
//  Enumerate the languages marked for installation
//
//  Return:
//      The total number of MUI languages to be added.
//
////////////////////////////////////////////////////////////////////////////////////
int EnumSelectedLanguages(HWND hList, LPTSTR lpAddLanguages)
{
    TCHAR  szBuffer[BUFFER_SIZE];
    TCHAR *p;
    LPTSTR lpszLcid;
    int    iIndex;
    int    i = 0;
    PMUILANGINFO pMuiLangInfo;
    int installLangCount = 0;    
    iIndex = ListView_GetItemCount(hList);  
    HRESULT hresult;

    if (!lpAddLanguages)
    {
        return 0;
    }
    *lpAddLanguages=TEXT('\0');
    
    while(i<iIndex)
    {
        if(ListView_GetCheckState(hList, i))
        {
            GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);
            lpszLcid = pMuiLangInfo->lpszLcid;
            if (!IsInstalled(lpszLcid) && HaveFiles(lpszLcid))
            {
                //*STRSAFE*                 _tcscat(lpAddLanguages, lpszLcid);
                hresult = StringCchCat(lpAddLanguages , BUFFER_SIZE, lpszLcid);
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }
                //*STRSAFE*                 _tcscat(lpAddLanguages, TEXT("*"));
                hresult = StringCchCat(lpAddLanguages , BUFFER_SIZE, TEXT("*"));
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }
                //
                // Count how many languages are being installed/uninstalled for the progress bar
                //
                gNumLanguages++;
                gNumLanguages_Install++;
                installLangCount++;
            }
          
        }
        i++;
    }
    p = lpAddLanguages;
    while (p=_tcschr(p, TEXT('*')))
    {
        *p=TEXT('\0');
        p++;
    }
    return (installLangCount);
}
////////////////////////////////////////////////////////////////////////////////////
//
//   EnumUnselectedLanguages
//
//   Enumerate the languages marked for removal
//
//  Return:
//      The total number of MUI languages to be added.
//
////////////////////////////////////////////////////////////////////////////////////
int EnumUnselectedLanguages(HWND hList, LPTSTR lpRemoveLanguages)
{
    LPTSTR p;
    TCHAR  szBuffer[BUFFER_SIZE];
    LPTSTR lpszLcid;
    int    iIndex;
    int    i = 0;
    PMUILANGINFO pMuiLangInfo;
    int uninstallLangCount = 0;
    HRESULT hresult;
    iIndex = ListView_GetItemCount(hList);
    if (!lpRemoveLanguages)
    {
        return 0;
    }
    *lpRemoveLanguages=TEXT('\0');
    g_bRemoveDefaultUI=FALSE;
    while (i < iIndex)
    {
        if (!ListView_GetCheckState(hList, i))
        {
            GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);
            lpszLcid = pMuiLangInfo->lpszLcid;
            if (IsInstalled(lpszLcid))
            {
                //*STRSAFE*                 _tcscat(lpRemoveLanguages, lpszLcid);
                hresult = StringCchCat(lpRemoveLanguages , BUFFER_SIZE, lpszLcid);
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }
                //*STRSAFE*                 _tcscat(lpRemoveLanguages, TEXT("*"));
                hresult = StringCchCat(lpRemoveLanguages , BUFFER_SIZE, TEXT("*"));
                if (!SUCCEEDED(hresult))
                {
                   return 0;
                }
                if (GetDotDefaultUILanguage() == pMuiLangInfo->lcid)
                {
                   g_bRemoveDefaultUI=TRUE;
                }
                if (GetUserDefaultUILanguage() == pMuiLangInfo->lcid)
                {
                    g_bRemoveUserUI = TRUE;                
                }
                //
                // Count how many languages are being installed/uninstalled for the progress bar
                //
                gNumLanguages++;
                gNumLanguages_Uninstall++;
                uninstallLangCount++;
            }
        }
        i++;
    }
    p = lpRemoveLanguages;
    while (p=_tcschr(p, TEXT('*')))
    {
        *p = TEXT('\0');
        p++;
    }
    return (uninstallLangCount);
}
////////////////////////////////////////////////////////////////////////////////////
//
//   SkipBlanks
//
//   Skips spaces and tabs in string. Returns pointer to next character
//
////////////////////////////////////////////////////////////////////////////////////
PTCHAR SkipBlanks(PTCHAR pszText)
{
    if (!pszText)
    {
        return NULL;
    }
    while (*pszText==TEXT(' ') || *pszText==TEXT('\t'))
    {
        pszText++;
    }
    return pszText;
}
////////////////////////////////////////////////////////////////////////////////////
//
//   NextCommandTag
//
//   pointing to next command tag (TEXT('-') or TEXT('/')
//
////////////////////////////////////////////////////////////////////////////////////
LPTSTR NextCommandTag(LPTSTR lpcmd)
{
    LPTSTR p=NULL;
    if(!lpcmd)
    {
        return (p);
    }     
    while(*lpcmd)
    {
        if ((*lpcmd == TEXT('-')) || (*lpcmd == TEXT('/')))
        {
            // Skip to the character after the '-','/'.
            p = lpcmd + 1;
            break;
        }
        lpcmd++;
    }
    return (p);
}
////////////////////////////////////////////////////////////////////////////////////
//
//   IsInInstallList
//
//   Check if a target is in the string list
//   
//   Structure of string list:
//
//   <string 1><NULL><string 2><NULL>......<string n><NULL><NULL>
//
//////////////////////////////////////////////////////////////////////////////////// 
BOOL IsInInstallList(LPTSTR lpList,LPTSTR lpTarget) 
{
     BOOL bResult=FALSE;
     if (!lpList || !lpTarget)
        return bResult;
     
     while (*lpList)
     {  
        if (!_tcsicmp(lpList,lpTarget))
        {
           bResult=TRUE;
           break;
        }  
        while (*lpList++) // move to next 
        {       
        }
     } 
     return bResult;
}  
////////////////////////////////////////////////////////////////////////////////////
//
//   CreateProgressDialog
//
//   Globals affected:
//      ghProgDialog
//      ghProgress
//
////////////////////////////////////////////////////////////////////////////////////
void CreateProgressDialog(HWND hwnd)
{
    ghProgDialog = CreateDialog(ghInstance,
             MAKEINTRESOURCE(IDD_DIALOG_INSTALL_PROGRESS),
             hwnd,
             ProgressDialogFunc);
    ghProgress = GetDlgItem(ghProgDialog, IDC_PROGRESS1);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  CheckLanguageGroupInstalled
//      Check if the Language groups for specified languages is installed correctly.
//  
//  Parameters:
//      [IN]    lpLanguages     The double-null-terminated string which contains the hex LCID
//                              strings to be checked.
//  Return:
//      TURE if all the required language packs are installed in the system.  Otherwise, FALSE is
//      returned.
//
//  CheckLanguageGroupInstalled
//      Check if the Language groups for specified languages is installed correctly.
//  
//  Parameters:
//      [IN]    lpLanguages     The double-null-terminated string which contains the hex LCID
//                              strings to be checked.
//  Return:
//      TURE if all the required language packs are installed in the system.  Otherwise, FALSE is
//      returned.
//
//  Remarks:
//  01-18-2001  YSLin       Created.
////////////////////////////////////////////////////////////////////////////////////
BOOL CheckLanguageGroupInstalled(LPTSTR lpLanguages)
{    
    LANGID langID;
    LGRPID lgrpID;
    
    if (!lpLanguages)
    {
       return FALSE;
    }
    while (*lpLanguages != TEXT('\0'))
    {
        langID = (LANGID)TransNum(lpLanguages);    
        lgrpID = GetLanguageGroup(langID);
        if (!gpfnIsValidLanguageGroup(lgrpID, LGRPID_INSTALLED))
        {
            return (FALSE);
        }
        // Go to the null character.
        lpLanguages = _tcschr(lpLanguages, TEXT('\0'));
        // Skip to next char after the null character.
        lpLanguages++;
    }
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  DoSetup
//
//  Parameters:
//      hwnd    The hwnd of the MUISetup main dialog. Pass null if the muisetup is run from command line.
//      UnistallLangCount   The number of languages to be uninstalled.
//      lpUninstall         The double-null-terminated string which contains the hex LCID strings for the
//                          languages to be uninstalled.
//      installLangGroup
//      InstallLangCount    The number of languages to be installed.
//      lpInstall           The double-null-terminated string which contains the hex LCID strings for the
//                          languages to be installed.
//      lpDefaultUILang     The language to be set as system default UI language.  Pass NULL if the system default
//                          UI language is not changed.
//      fAllowReboot        The flag to indicate if this function should check if reboot is necessary.
//      bInteractive        TRUE if run in interactive mode, or FALSE if run in silent mode.
//      bDisplayUI          TRUE if UI is desired, FALSE if UI is to be suppressed
//      
//
//  Return:
//      TRUE if installation is successful.  Otherwise FALSE.
//
//  Notes:
//      This functions serves as the entry point of the real installation process, shared by both the GUI setup
//      and the command line mode setup.
//
//      There are several steps in doing MUI setup.
//      1. Uninstall the selected MUI languages.
//      2. Install the necessary language packs according to the selected MUI languges(if any).
//      3. Install the selected MUI languages.
//      4. Change the default UI language.
//      5. Check for rebooting.
//
// Please note that to save space, we do the uninstallation first, then do the installation.
////////////////////////////////////////////////////////////////////////////////////
BOOL DoSetup(
    HWND hwnd,
    int UninstallLangCount, LPTSTR lpUninstall, 
    INSTALL_LANG_GROUP installLangGroup, 
    int InstallLangCount, LPTSTR lpInstall, 
    LPTSTR lpDefaultUILang,
    BOOL fAllowReboot, BOOL bInteractive, BOOL bDisplayUI)
{
    LONG_PTR lppArgs[3];
    TCHAR lpMessage[BUFFER_SIZE];   
    TCHAR lpForceUILang[BUFFER_SIZE];    
    TCHAR lpTemp[BUFFER_SIZE];
    TCHAR lpTemp2[BUFFER_SIZE];
    LANGID defaultLangID;
    
    HCURSOR hCurSave;
    int NotDeleted;
    BOOL bDefaultUIChanged = FALSE;
    BOOL bErrorOccurred = FALSE;
    LANGID lidSys = GetSystemDefaultLangID();
    BOOL isReboot;
    ghProgDialog = NULL;
    ghProgress = NULL;
    HRESULT hresult;
    if ( (! lpUninstall) || (!lpInstall) )
    {
       return FALSE;
    }
    hCurSave=SetCursor(LoadCursor(NULL, IDC_WAIT));
    if(UninstallLangCount > 0)
    {
#ifndef MUI_MAGIC 
        if (bDisplayUI)
        {
            CreateProgressDialog(hwnd);      
            SendMessage(ghProgress, PBM_SETRANGE, (WPARAM)(int)0, (LPARAM)MAKELPARAM(0, UninstallLangCount * INSTALLED_FILES));
            SendMessage(ghProgress, PBM_SETPOS, (WPARAM)0, 0); 
            SetWindowTitleFromResource(ghProgDialog, IDS_UNINSTALL_TITLE);
        }
#endif
        //
        // Uninstall MUI languages
        //
        if (!UninstallSelected(lpUninstall, &NotDeleted))
        {
#ifndef MUI_MAGIC      
            if (bDisplayUI)
            {
                DestroyWindow(ghProgDialog);
                ghProgDialog = NULL;
            }
#endif         
            // prompt a messagebox about uninstallation error
            if (bDisplayUI)
            {            
                DoMessageBoxFromResource(hwnd, ghInstance, IDS_ERROR_UNINSTALL_LANG, lppArgs, IDS_MAIN_TITLE, MB_OK);            
                SetCursor(hCurSave);
            }
            bErrorOccurred = TRUE;
            goto PostSetup;
        }
        
#ifndef MUI_MAGIC
        if (bDisplayUI)
        {
            SendMessage(ghProgress, PBM_SETPOS, (WPARAM)(UninstallLangCount * INSTALLED_FILES), 0);
        }
#endif
    }
    if(InstallLangCount > 0)
    {
    
#ifndef MUI_MAGIC    
        //
        // Install Language Group First
        //
        if (!InstallLanguageGroups(&installLangGroup))
        {
            if (bDisplayUI)
            {
                DestroyWindow(ghProgDialog);
                ghProgDialog = NULL;
            }
            if (bDisplayUI)
            {
                SetCursor(hCurSave);
            }
            bErrorOccurred = TRUE;
            goto PostSetup;            
        }
        //
        // Check if language group in installLangGroup is installed correctly
        //
        if (!CheckLanguageGroupInstalled(lpInstall))
        {
            LogFormattedMessage(NULL, IDS_LG_NOT_INSTALL_L, NULL);
            if (bDisplayUI || bInteractive)
            {
                DoMessageBox(NULL, IDS_LG_NOT_INSTALL, IDS_MAIN_TITLE, MB_OK);
            }
            return (FALSE);
        }
#endif        
        //
        // Make sure MUI CD-ROM is put in the CD-ROM drive.
        //
        if(CheckVolumeChange())
        {
            if (bDisplayUI)
            {
#ifndef MUI_MAGIC  
                DestroyWindow(ghProgDialog);
                ghProgDialog = NULL;
#endif            
                SetCursor(hCurSave);
            }
            return (FALSE);
        }
        
#ifndef MUI_MAGIC
        if (bDisplayUI)
        {        
            if (ghProgDialog == NULL) 
            {
                CreateProgressDialog(hwnd);
            }            
            SendMessage(ghProgress, PBM_SETRANGE, (WPARAM)(int)0, (LPARAM)MAKELPARAM(0, InstallLangCount * INSTALLED_FILES));
            SendMessage(ghProgress, PBM_SETPOS, (WPARAM)0, 0);
            SetWindowTitleFromResource(ghProgDialog, IDS_INSTALL_TITLE);
        }
#endif
      
        if (!InstallSelected(lpInstall,&installLangGroup.bFontLinkRegistryTouched))
        {
            if (bDisplayUI)
            {
                DoMessageBoxFromResource(hwnd, ghInstance, IDS_ERROR_INSTALL_LANG, lppArgs, IDS_MAIN_TITLE, MB_OK);
#ifndef MUI_MAGIC            
                DestroyWindow(ghProgDialog);
                ghProgDialog = NULL;
#endif            
                SetCursor(hCurSave);
            }
            bErrorOccurred = TRUE;
            goto PostSetup;            
        }
#ifndef MUI_MAGIC        
        if (bDisplayUI)
        {
            SendMessage(ghProgress, PBM_SETPOS, (WPARAM)((UninstallLangCount+InstallLangCount) * INSTALLED_FILES), 0);
        }
#endif        
    }
    if (bDisplayUI)
    {
#ifndef MUI_MAGIC    
        DestroyWindow(ghProgDialog);
        ghProgDialog = NULL;   
#endif
        SetCursor(hCurSave); 
    }
    if (UninstallLangCount + InstallLangCount > 0)
    {
        //
        //  "Installation Complete"
        //  "Installation was completed successfully."
        //
        if (bInteractive || bDisplayUI)
        {
            DoMessageBox(hwnd, InstallLangCount > 0 ? IDS_MUISETUP_SUCCESS : IDS_MUISETUP_UNINSTALL_SUCCESS, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);        
        }
    }
    //
    // In command line mode, if "/D" is specified, we should ask user to confirm making default UI language change.
    // In command line mode, if "/D" is NOT specified, we should NOT try to change the default UI language.
    // In command line mode, if "/D" & "/S" are specified, we will NOT ask user's confirmation.
    // In GUI mode, we always ask user to confirm making default UI language change.
    // 
    //
    // Special case:
    // If the current default UI language is going to be removed and user doesn't choose a new UI language,
    // we will force to set the default UI language to be the system UI language.
    //    
    if(g_bRemoveDefaultUI)
    {
        //
        // Delete shell cache for the current user
        //
        SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));
    }    
    if (lpDefaultUILang)
    {
        defaultLangID = (LANGID)_tcstol(lpDefaultUILang, NULL, 16);
        if (IsInstalled(lpDefaultUILang))
        {
            //
            // If the assigned UI language ID (defaultLangID) is already the default user UI language,
            // we don't do anything.  Otherwise, change the default user UI langauge.
            //
            if (defaultLangID != GetDotDefaultUILanguage())
            {
                if (SetUserDefaultLanguage(defaultLangID, FALSE, TRUE))
                {
                    bDefaultUIChanged = TRUE;
                } else
                {
                    if (bInteractive)
                    {
                        DoMessageBox(hwnd, IDS_DEFAULT_USER_ERROR, IDS_MAIN_TITLE, (MB_OK | MB_ICONEXCLAMATION));
                    }
                }
            } else
            {
                // Do nothing here. I leave this here intentionally to highlight that
                // we don't do antying if the specified defaultLangID is already the default UI language.
            }
            //
            // Make sure registry is set correctly
            //
            if(BST_CHECKED == IsDlgButtonChecked( hwnd, IDC_CHECK_LOCALE ))
            {
                SetMUIRegSetting(MUI_MATCH_LOCALE, TRUE);
                SetMUIRegSetting(MUI_MATCH_UIFONT, BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CHECK_UIFONT));
            }
            else
            {
                SetMUIRegSetting(MUI_MATCH_LOCALE, FALSE);
                SetMUIRegSetting(MUI_MATCH_UIFONT, FALSE);
            }
            //
            // Notify intl.cpl if we have system locale or UI font setting change
            //
            if ((BST_CHECKED == IsDlgButtonChecked( hwnd, IDC_CHECK_LOCALE)  || g_bCmdMatchLocale || g_bLipLanguages) && 
                defaultLangID != lidSys)
            {
                TCHAR szCommands[BUFFER_SIZE];
                
                //
                // Invoke intl.cpl to change system locale to match the default UI language
                //
                //*STRSAFE*                 wsprintf(szCommands, TEXT("SystemLocale = \"%x\""), defaultLangID);
                hresult = StringCchPrintf(szCommands , ARRAYSIZE(szCommands),  TEXT("SystemLocale = \"%x\""), defaultLangID);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                //
                // Always reboot if system locale is changed
                //
                if (RunRegionalOptionsApplet(szCommands))
                {
                    g_bReboot = TRUE;
                }
            }
            else if (g_bMatchUIFont != (BST_CHECKED == IsDlgButtonChecked(hwnd, IDC_CHECK_UIFONT)) ||
                     g_bCmdMatchUIFont)
            {
                TCHAR szCommands[BUFFER_SIZE];
                
                //
                // We're not really changing system locale here, it is used to invoke intl.cpl for font setting changes
                //
                //*STRSAFE*                 wsprintf(szCommands, TEXT("SystemLocale = \"%x\""), lidSys);
                hresult = StringCchPrintf(szCommands , ARRAYSIZE(szCommands),  TEXT("SystemLocale = \"%x\""), lidSys);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                
                if (RunRegionalOptionsApplet(szCommands) && defaultLangID == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
                {
                    // Don't prompt for reboot, intl.cpl will cause muisetup to lose focus if we do so.                     
                    // Need to fix this in XP server release
                    
                    g_bReboot = TRUE;
                }
            }
            // 
            // Change user locale for LIP languages
            //
            if (g_bLipLanguages)
            {
                TCHAR szCommands[BUFFER_SIZE];
                
                //
                // Invoke intl.cpl to change system locale to match the default UI language
                //
                //*STRSAFE*                 wsprintf(szCommands, TEXT("UserLocale = \"%x\"\x0d\x0aUserLocale_DefaultUser = \"%x\"\x0d\x0aMUILanguage=\"%x\""), defaultLangID, defaultLangID, defaultLangID);
                hresult = StringCchPrintf(szCommands , ARRAYSIZE(szCommands),  TEXT("UserLocale = \"%x\"\x0d\x0aUserLocale_DefaultUser = \"%x\"\x0d\x0aMUILanguage=\"%x\""), defaultLangID, defaultLangID, defaultLangID);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
                
                if (RunRegionalOptionsApplet(szCommands) && defaultLangID == MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT))
                {
                    // Don't prompt for reboot, intl.cpl will cause muisetup to loose focus if we do so.                     
                    // Need to fix this in XP server release
                    
                    g_bReboot = TRUE;
                }
           }
        } else 
        {
            //
            //  "ERROR: %1 was not set as the default. It is not installed.\r\nNo default UI language change."
            //
            lppArgs[0] = (LONG_PTR)lpDefaultUILang;
            LogFormattedMessage(NULL, IDS_DEFAULT_L, lppArgs);
            return (FALSE);            
        }
    }
PostSetup:
    
    //
    // Check for reboot, and if we are allowed to do so.
    //
    if (fAllowReboot)
    {
        //
        // Check if we need to reboot?
        //
        if (!CheckForReboot(hwnd, &installLangGroup))
        {
            //
            // Check if we recommend a reboot?
            //
            if ((bInteractive || bDisplayUI) && bDefaultUIChanged)
            {
                GetLanguageDisplayName(defaultLangID, lpTemp, ARRAYSIZE(lpTemp)-1);
                lppArgs[0] = (LONG_PTR)lpTemp;
                if (lidSys == defaultLangID)
                {
                    if (bDisplayUI)
                    {
                        isReboot = (DoMessageBoxFromResource(hwnd, ghInstance, IDS_CHANGE_UI_NEED_RBOOT, lppArgs, IDS_MAIN_TITLE, MB_YESNO) == IDYES);
                    }
                    else
                    {
                        isReboot = TRUE;
                    }
                } else
                {
                    GetLanguageDisplayName(lidSys, lpTemp2, ARRAYSIZE(lpTemp2)-1);
                    lppArgs[1] = (LONG_PTR)lpTemp2;

                    if (bDisplayUI)
                    {
                        isReboot = (DoMessageBoxFromResource(hwnd, ghInstance, IDS_CHANGE_UI_NEED_RBOOT_SYSTEM_LCID, lppArgs, IDS_MAIN_TITLE, MB_YESNO) == IDYES);
                    }
                    else
                    {
                        isReboot = TRUE;
                    }
                }
                if (isReboot) 
                {
                    Muisetup_RebootTheSystem();
                }
                
            }
        }            
    }
    if (bErrorOccurred)
        return (FALSE);
    
    return (TRUE);
}
int ParseUninstallLangs(LPTSTR p, LPTSTR lpUninstall, int cchUninstall, INT64* pulUISize, INT64* pulLPKSize, INT64* pulSpaceNeed, BOOL* pbLogError)
{
    int iCopied;
    TCHAR lpBuffer[BUFFER_SIZE];
    LONG_PTR lppArgs[2];
    int cLanguagesToUnInstall = 0;
    LANGID LgId;
    LPTSTR pU = lpUninstall;
    if ((!p) || (! lpUninstall) || (!pulUISize) || (!pulLPKSize) || (!pulSpaceNeed) || (!pbLogError))
    {
       return FALSE;
    }
    p = SkipBlanks(p);

    if (!p)
    	return FALSE;
    
    iCopied = 0;
    while((*p != TEXT('-')) && (*p != TEXT('/')) && (*p != TEXT('\0')))
    { 
        iCopied = CopyArgument(lpBuffer, p);
        if(!HaveFiles(lpBuffer, FALSE))
        {
            //
            //  "LOG: %1 was not installed. It is not listed in MUI.INF."
            //
            lppArgs[0] = (LONG_PTR)lpBuffer;
            LogFormattedMessage(NULL, IDS_NOT_LISTED_L, lppArgs);
            *pbLogError = TRUE;
        } else if (!IsInstalled(lpBuffer))
        {
            //
            //  "LOG: %1 was not uninstalled, because it is not installed. "
            //
            lppArgs[0] = (LONG_PTR)lpBuffer;
            LogFormattedMessage(NULL, IDS_IS_NOT_INSTALLED_L, lppArgs);
            *pbLogError = TRUE;
        } else if (!IsInInstallList(lpUninstall,lpBuffer))
        {
            iCopied = CopyArgument(pU, p);
            //
            // Check if we are going to remove the current UI language
            //
            LgId = (LANGID)_tcstol(pU, NULL, 16);                    
            if (LgId == GetDotDefaultUILanguage())
            {
                g_bRemoveDefaultUI = TRUE;
            }
            if (LgId == GetUserDefaultUILanguage())
            {
                g_bRemoveUserUI = TRUE;
            }
            //
            // Calculate the space required
            //
            GetUIFileSize_commandline(lpBuffer, pulUISize,pulLPKSize);
            *pulSpaceNeed-=*pulUISize;
            pU += iCopied;
            pU++; //skip over NULL
            cLanguagesToUnInstall++;                    
        }
        p += iCopied;
        p  = SkipBlanks(p);
    }
    //
    // Uninstall all MUI languages if there is no language argument after /U
    //
    if (iCopied == 0)
    {
        cLanguagesToUnInstall = GetInstalledMUILanguages(lpUninstall, cchUninstall);
        if (cLanguagesToUnInstall == 0)
        {
            LogFormattedMessage(ghInstance, IDS_NO_MUI_LANG, NULL);
            *pbLogError = TRUE;
        }
        else
        {
            if (0x0409 != GetDotDefaultUILanguage())
            {
                g_bRemoveDefaultUI = TRUE;
            }
            if (0x0409 != GetUserDefaultUILanguage())
            {
                g_bRemoveUserUI = TRUE;
            }
        }
    }
    else
    {
        *pU=TEXT('\0');
    }                
    return (cLanguagesToUnInstall);
}
////////////////////////////////////////////////////////////////////////////
//
//  GetCDNameFromLang
//
//  Given a langange ID (in hex string), return the CD name where the language 
//  installation folder exist.
//  This can also be used to check if the language is supported MUI language.
//
//  Parameters:
//      [IN]  lpLangName  the language to be installed in hex string.
//      [OUT] lpCDName    the number of the CD (e.g. "2" or "3").
//      [IN]  nCDNameSize the size of lpCDName, in TCHAR.
//
//  Return Values:
//      TRUE if lpLangName is a supported MUI language.  lpCDName will contain
//      the name of the CD. 
//      FALSE if the language ID is not a supported langauge. lpCDNAme will be 
//      empty string.
//
//  Remarks:
//
//  01-01-2001  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////
BOOL GetCDNameFromLang(LPTSTR lpLangName, LPTSTR lpCDName, int nCDNameSize)
{
    if (!GetPrivateProfileString(
            MUI_CDLAYOUT_SECTION,
            lpLangName,
            TEXT(""),
            lpCDName,
            nCDNameSize,
            g_szMUIInfoFilePath))
    {
        return (FALSE);
    }
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  ParseCommandLine
//
//  Runs installation functions with command line specifications
//
////////////////////////////////////////////////////////////////////////////////////
BOOL ParseCommandLine(LPTSTR lpCommandLine)
{
    BOOL bSetDefaultUI=FALSE;    // Specify if the /D switch is used to change the user default UI language.
    BOOL bInstall=FALSE;
    BOOL bLogError=FALSE;
    BOOL bFELangpackAdded=FALSE;
    BOOL bResult = FALSE;
    DWORD dwDisp;
    LANGID LgId;
    TCHAR lpBuffer[BUFFER_SIZE];
    TCHAR lpDefault[BUFFER_SIZE];
    TCHAR lpDefaultText[MAX_PATH];
    TCHAR lpInstall[BUFFER_SIZE];
    TCHAR lpMessage[BUFFER_SIZE];
    TCHAR lpUninstall[BUFFER_SIZE];
    TCHAR lpSystemDefault[BUFFER_SIZE];
    TCHAR lpTemp[BUFFER_SIZE];
    TCHAR  szWinDir[MAX_PATH];
    INSTALL_LANG_GROUP installLangGroup;
    LONG_PTR lppArgs[4];
    PTCHAR pI;
    PTCHAR pD;
    PTCHAR p;
    BOOL fAllowReboot = TRUE;
    int cLanguagesToInstall = 0L;
    int cLanguagesToUnInstall = 0L;
    int iCopied;
    TCHAR chOpt;                     
    INT64 ulSpaceNeed=0,ulSpaceAvailable=0,ulUISize=0,ulLPKSize=0;
    ULONG ulParam[2];
    ULARGE_INTEGER ulgiFreeBytesAvailableToCaller;
    ULARGE_INTEGER ulgiTotalNumberOfBytes;
    BOOL bHasLangArgs = FALSE;
    BOOL bHelpDisplayed=FALSE;    
    //PREFAST TCHAR lpCDName[BUFFER_SIZE];
    LPTSTR lpCDName=NULL;

    if (!lpCommandLine)
    {
       return FALSE;
    }
    //
    // Allocate space for  Heap variable
    //
    lpCDName = new TCHAR[BUFFER_SIZE];
    if (! lpCDName)
    {
        goto  exit_ParseCommandLine;
    }
    //
    // Initialize Lang-Groups to install
    //
    installLangGroup.iCount = 0L;
    installLangGroup.NotDeleted = 0L;
    installLangGroup.bFontLinkRegistryTouched = FALSE;
    lpInstall[0]   = TEXT('\0');
    lpUninstall[0] = TEXT('\0');
    lpDefault[0] = TEXT('\0');
    pI = lpInstall;
    pD = lpDefault;
    p  = lpCommandLine;
    CharLower(p);
    while(p=NextCommandTag(p))
    {
        chOpt = *p++;
        switch (chOpt)
        {
        case '?':
        case 'h':
            if (!bHelpDisplayed)
            {  
                DisplayHelpWindow();
                bHelpDisplayed=TRUE;
            }
            // if we encountered a help switch, after displaying the window, we just exit
            bResult = TRUE;
            goto exit_ParseCommandLine;
            //            p = SkipBlanks(p);
            break;
       
        case 'i':
            if (!FileExists(g_szMUIInfoFilePath))
            {
                //
                //    "The file MUI.INF cannot be found."
                //
                DoMessageBox(NULL, IDS_NO_MUI_FILE, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }
            //
            // MUI version needs to match OS version
            //
            if (!checkversion(TRUE))
            {
                DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }
            
            p = SkipBlanks(p);
            while ((*p != TEXT('-'))  && (*p != TEXT('/')) && (*p != TEXT('\0')))
            {
                bHasLangArgs = TRUE;
                iCopied=CopyArgument(lpBuffer, p);
                if (!IsInstalled(lpBuffer) &&
                    CheckLanguageIsQualified(lpBuffer) &&
                    HaveFiles(lpBuffer) && (!IsInInstallList(lpInstall,lpBuffer)) )
                {   
                    //
                    // Calculate the space required
                    //
                    GetUIFileSize_commandline(lpBuffer, &ulUISize,&ulLPKSize);
                    ulSpaceNeed+=ulUISize;
                    if(CheckLangGroupCommandLine(&installLangGroup, lpBuffer))
                    {
                      if (IS_FE_LANGPACK(_tcstol(lpBuffer, NULL, 16)))
                      {
                        if (!bFELangpackAdded)
                        {
                            ulSpaceNeed+=ulLPKSize;                        
                            bFELangpackAdded = TRUE;
                        }
                      }else
                      {
                         ulSpaceNeed+=ulLPKSize;                        
                      }
                    }
                    AddExtraLangGroupsFromINF(lpBuffer, &installLangGroup);
                    iCopied=CopyArgument(pI, p);
                    pI += iCopied;
                    pI++; //skip over NULL
                    bInstall = TRUE;
                    cLanguagesToInstall++;
                }
                else
                {
                    lppArgs[0]=(LONG_PTR)lpBuffer;
                    if(IsInstalled(lpBuffer)|| IsInInstallList(lpInstall,lpBuffer))
                    {
                        // "LOG: %1 was not installed, because it is already installed. "
                        LogFormattedMessage(ghInstance, IDS_IS_INSTALLED_L, lppArgs);
                    }
                    if(!HaveFiles(lpBuffer))
                    {
                        if (!GetCDNameFromLang(lpBuffer, lpCDName, ARRAYSIZE(lpCDName)))
                        {
                            // lpBuffer is not a supported MUI language.
                            //  "LOG: %1 was not installed, because it is not listed in MUI.INF. Please check if it is a valid UI language ID."
                            LogFormattedMessage(ghInstance, IDS_NOT_LISTED_L, lppArgs);
                        } else
                        {
                            // lpBuffer is a supported MUI language, ask user to change CD and
                            // rerun setup.
                            LoadString(ghInstance, IDS_CHANGE_CDROM, lpTemp, ARRAYSIZE(lpTemp)-1);
                            lppArgs[1] = (LONG_PTR)lpTemp;
                            lppArgs[2] = (LONG_PTR)lpCDName;
                            // "ERROR: %1 was not installed, because it is located in %2 %3.  Please insert that CD and rerun MUISetup."
                            LogFormattedMessage(ghInstance, IDS_LANG_IN_ANOTHER_CD_L, lppArgs);
                        }
                    }
                    if(!CheckLanguageIsQualified(lpBuffer))
                    {   
                        // "LOG: %1 was not installed, because it cannot be installed on this platform\n"
                        LogFormattedMessage(ghInstance, IDS_NOT_QUALIFIED_L, lppArgs);
                    }                   
                    bLogError = TRUE;
                }
                p += iCopied;
                p  = SkipBlanks(p);
            }
            if (!bHasLangArgs)
            {
                lppArgs[0] = (LONG_PTR)TEXT("/I");
                FormatStringFromResource(lpMessage, sizeof(lpMessage)/sizeof(TCHAR), ghInstance, IDS_ERROR_NO_LANG_ARG, lppArgs);
                LogMessage(lpMessage);
                bLogError = TRUE;
            }
            *pI = TEXT('\0');
            break;
      
        case 'u':
            if (!checkversion(FALSE))
            {
                DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }
            cLanguagesToUnInstall = ParseUninstallLangs(p, lpUninstall, ARRAYSIZE(lpUninstall), &ulUISize, &ulLPKSize, &ulSpaceNeed, &bLogError);
            break;
        case 'd':
            if (!checkversion(FALSE))
            {
                DoMessageBox(NULL, IDS_WRONG_VERSION, IDS_MAIN_TITLE, MB_OK | MB_DEFBUTTON1);
                break;
            }
            bSetDefaultUI = TRUE;
            p = SkipBlanks(p);
            if (CopyArgument(lpDefault, p) == 0)
            {
                lppArgs[0] = (LONG_PTR)TEXT("/D");
                FormatStringFromResource(lpMessage, sizeof(lpMessage)/sizeof(TCHAR), 
                    ghInstance, IDS_ERROR_NO_LANG_ARG, lppArgs);
                LogMessage(lpMessage);
                bLogError = FALSE;
            }
            break;
        case 'r':
            fAllowReboot = FALSE;
            break;
        case 's' :
            g_bSilent = TRUE;
            // check if desktop is interactive or not, if not, hide all UI
            if (FALSE == IsWindowVisible(GetDesktopWindow()))
            {
                g_bNoUI = TRUE;
            }
            break;
        case 't' :
            // use this switch to totally suppress all the possible UI that can be popped up by muisetup and the processes it 
            // launches.
            g_bSilent = TRUE;
            g_bNoUI = TRUE;
            break;
        case 'l':
            g_bCmdMatchLocale = TRUE;
            break;
        case 'f':
            g_bCmdMatchUIFont = TRUE;
            break;
        case 'o':
            g_bRunFromOSSetup = TRUE;    
            break;
        default:
            // if we encounter an invalid switch at any stage, treat it the same as help and quit afterwards
            if (!bHelpDisplayed)
            {  
                DisplayHelpWindow();
                bHelpDisplayed=TRUE;
            }
            // if we encountered a help switch, after displaying the window, we just exit
            bResult = TRUE;           
            goto exit_ParseCommandLine;
            break;
        }
    }
    //
    // UI Font depends on system locale
    //
    if (!g_bCmdMatchLocale && g_bCmdMatchUIFont)
    {
        g_bCmdMatchUIFont = FALSE;
    }
    //
    // Check the disk space
    //  
    //
    pfnGetWindowsDir( szWinDir, MAX_PATH);
    szWinDir[3]=TEXT('\0');
    if (GetDiskFreeSpaceEx(szWinDir,
                      &ulgiFreeBytesAvailableToCaller,
                      &ulgiTotalNumberOfBytes,
                      NULL))
    {
      ulSpaceAvailable= ulgiFreeBytesAvailableToCaller.QuadPart;
      if ( ulSpaceAvailable <  ulSpaceNeed )
      { 
         ulParam[0] = (ULONG) (ulSpaceNeed/1024);
         ulParam[1] = (ULONG) (ulSpaceAvailable/1024);
         LoadString(ghInstance, IDS_DISKSPACE_NOTENOUGH, lpMessage, ARRAYSIZE(lpMessage)-1);
         LoadString(ghInstance, IDS_ERROR_DISKSPACE, lpTemp, ARRAYSIZE(lpTemp)-1);
         FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                  lpMessage,
                                  0,
                                  0,
                                  lpMessage,
                                  ARRAYSIZE(lpMessage)-1,
                                  (va_list *) ulParam);
         LogMessage(lpMessage);
         bLogError = TRUE;
         MESSAGEBOX(NULL, lpMessage, lpTemp, MB_OK | MB_DEFBUTTON1 | MB_ICONWARNING);
         bInstall = FALSE;
         cLanguagesToUnInstall = 0;
      }
      
    } 
    if (!bLogError)
    {
        //
        // Let's set the default UI language
        //
        if (!DoSetup(
            NULL,
            cLanguagesToUnInstall, lpUninstall, 
            installLangGroup, 
            cLanguagesToInstall, lpInstall,
            (bSetDefaultUI ? lpDefault : NULL), 
            fAllowReboot, !g_bSilent, !g_bNoUI))
        {
            bLogError = TRUE;
        }
    } 
    if (bLogError && !g_bSilent && !g_bNoUI)
    {
        //
        //  "Installation Error"
        //  "One or more errors occurred during installation.
        //   Please see %1\muisetup.log for more information."
        //
        lppArgs[0] = (LONG_PTR)szWindowsDir;
        DoMessageBoxFromResource(NULL, ghInstance, IDS_ERROR, lppArgs, IDS_ERROR_T, MB_OK | MB_DEFBUTTON1 | MB_ICONWARNING);
    }
    bResult = TRUE;
exit_ParseCommandLine:
    if (lpCDName)
    {
       delete [] lpCDName;
    }
    return bResult;
} 
////////////////////////////////////////////////////////////////////////////////////
//
//  DisplayHelpWindow
//
//  Displays help window for command line version
//
////////////////////////////////////////////////////////////////////////////////////
void DisplayHelpWindow()
{
  STARTUPINFO si;
  PROCESS_INFORMATION pi = {0};
  TCHAR Appname[MAX_PATH+MAX_PATH+1],szFilePath[MAX_PATH+1];
  HRESULT hresult;
  int           nLen;
  
  szFilePath[0] = UNICODE_NULL;
  
  if (!pfnGetWindowsDir(szFilePath, MAX_PATH))
  {
        return;
  }
  nLen = lstrlen(szFilePath);
  if (szFilePath[nLen-1] != TEXT('\\'))
  {
      hresult = StringCchCat(szFilePath , ARRAYSIZE(szFilePath), TEXT("\\"));
      if (!SUCCEEDED(hresult))
      {
         return;
     }
  }
  hresult = StringCchCat(szFilePath , ARRAYSIZE(szFilePath), WINHELP32PATH);
  if (!SUCCEEDED(hresult))
  {
     return ;
  }
  if (FileExists(g_szMUIHelpFilePath))
  {
     //*STRSAFE*      wsprintf(Appname,TEXT("\"%s\"  -n%d %s"),szFilePath,IDH_MUISETUP_COMMANDLINE,g_szMUIHelpFilePath);
     hresult = StringCchPrintf(Appname , ARRAYSIZE(Appname), TEXT("\"%s\" -n%d %s"),szFilePath, IDH_MUISETUP_COMMANDLINE,g_szMUIHelpFilePath);
     if (!SUCCEEDED(hresult))
     {
        return;
     }
     memset( &si, 0x00, sizeof(si));
     si.cb = sizeof(STARTUPINFO);
  
     if (!CreateProcess(NULL,
               Appname, 
               NULL,
               NULL,
               FALSE, 
               0L, 
               NULL, NULL,
               &si,
               &pi) )
        return;
     WaitForSingleObject(pi.hProcess, INFINITE);
     //
     // Close Handle
     //
     CloseHandle( pi.hProcess );
     CloseHandle( pi.hThread );
  }
  else
  { 
     //////////////////////////////////////////////
     //  MessageBox should be changed to Dialog
     //////////////////////////////////////////////
     DoMessageBox(NULL, IDS_HELP, IDS_HELP_T, MB_OK | MB_DEFBUTTON1);
  }
} 
////////////////////////////////////////////////////////////////////////////////////
//
//  CopyArgument
//
//  Copies command line argument pointed to by src to dest
//
////////////////////////////////////////////////////////////////////////////////////
int CopyArgument(LPTSTR dest, LPTSTR src)
{
    int i=0;
    if ((!dest) || (!src))
    {
       return i;
    }
    while(*src!=TEXT(' ') && *src!=TEXT('\0'))
    {
        *dest=*src;
        dest++;
        src++;
        i++;
    }
    *dest = TEXT('\0');
    return i;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  IsInstalled
//
//  Checks to see if lpArg is a language installed in the registry
//
////////////////////////////////////////////////////////////////////////////////////
BOOL IsInstalled(LPTSTR lpArg)
{ 
    HKEY hKey;
    DWORD dwData;
    DWORD dwIndex;
    DWORD dwValue;
    TCHAR lpData[BUFFER_SIZE];
    TCHAR lpValue[BUFFER_SIZE];
    int rc;
    int iArg;
    
    if (!lpArg)
    {
        return FALSE;
    }
    hKey=OpenMuiKey(KEY_READ);
    if (hKey == NULL)
    {
        return (FALSE);
    }
    dwIndex=0;
    rc=ERROR_SUCCESS;
    
    iArg=_tcstol(lpArg, NULL, 16);
    if (iArg == gSystemUILangId)
    {
        RegCloseKey(hKey);
        return (TRUE);
    }
    while(rc==ERROR_SUCCESS)
    {
        dwValue=sizeof(lpValue)/sizeof(TCHAR);
        lpValue[0]=TEXT('\0');
        dwData=sizeof(lpData);
        lpData[0]=TEXT('\0');
        DWORD dwType;
    
        rc=RegEnumValue(hKey, dwIndex, lpValue, &dwValue, 0, &dwType, (LPBYTE)lpData, &dwData);
        if(rc==ERROR_SUCCESS)
        {
            if (dwType != REG_SZ)
            {
                dwIndex++;
                continue;
            }
            if(_tcstol(lpValue, NULL, 16)==iArg)
            {           
                RegCloseKey(hKey);  
                return TRUE;
            }
        }
        dwIndex++;
    }
    RegCloseKey(hKey);
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  GetInstalledMUILanguages
//
//  Get installed MUI languages, dump it to lpUninstall buffer in a MULTI_SZ format
//
////////////////////////////////////////////////////////////////////////////////////
DWORD GetInstalledMUILanguages(LPTSTR lpUninstall, int cch)
{ 
    HKEY hKey;
    DWORD dwIndex = 0;
    DWORD dwCount = 0;
    DWORD dwValue = cch;
    DWORD dwType = 0;

    if (!lpUninstall)
    {
        return dwCount;
    }
    if (hKey = OpenMuiKey(KEY_READ))
    {
        while(ERROR_NO_MORE_ITEMS != RegEnumValue(hKey, dwIndex++, lpUninstall, &dwValue, 0, &dwType, NULL, NULL) && 
            cch > 0)
        {
            if (dwType != REG_SZ)
                continue;
            if (_tcstol(lpUninstall, NULL, 16) != gSystemUILangId) 
            {
                //
                // Count in NULL
                //
                dwValue++;
                lpUninstall += dwValue;
                cch -= dwValue;
                dwCount++;                
            }
            dwValue = cch;                
        }
        RegCloseKey(hKey);
        *lpUninstall = TEXT('\0');
    }
    return dwCount;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  HaveFiles
//
//  Checks that the language in lpBuffer is in MUI.INF
//
////////////////////////////////////////////////////////////////////////////////////
BOOL HaveFiles(LPTSTR lpBuffer, BOOL bCheckDir)
{
    LPTSTR lpLanguages = NULL;
    TCHAR  lpMessage[BUFFER_SIZE];
    TCHAR  tchBuffer[BUFFER_SIZE];
    if (!lpBuffer)
    {
        return FALSE;
    }
    lpLanguages = tchBuffer;
    if (EnumLanguages(lpLanguages, bCheckDir) == 0)
    {
        //
        //  "LOG: No languages found in MUI.INF"
        //
        LoadString(ghInstance, IDS_NO_LANG_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        return FALSE;
    }
    if(!lpLanguages)
    	return FALSE;
    while (*lpLanguages != TEXT('\0'))
    {
        if (_tcscmp(lpBuffer, lpLanguages) == 0)
        {
            return TRUE;
        }
        lpLanguages = _tcschr(lpLanguages, '\0');
        lpLanguages++;
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  OpenLogFile
//
//  Opens the setup log for writing
//
////////////////////////////////////////////////////////////////////////////////////
HANDLE OpenLogFile()
{
    DWORD dwSize;
    DWORD dwUnicodeHeader;
    HANDLE hFile;
    SECURITY_ATTRIBUTES SecurityAttributes;
    TCHAR lpPath[BUFFER_SIZE];
    int error;
    HRESULT hresult;
    
    pfnGetWindowsDir(lpPath, MAX_PATH);
    error=GetLastError();
    //*STRSAFE*     _tcscat(lpPath, LOG_FILE);
    hresult = StringCchCat(lpPath , ARRAYSIZE(lpPath), LOG_FILE);
    if (!SUCCEEDED(hresult))
    {
       return NULL;
    }
    SecurityAttributes.nLength=sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor=NULL;
    SecurityAttributes.bInheritHandle=FALSE;
        
    hFile=CreateFile(
        lpPath,
        GENERIC_WRITE,
        0,
        &SecurityAttributes,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);  
#ifdef UNICODE
    //
    //  If the file did not already exist, add the unicode header
    //
    if(GetLastError()==0)
    {
        dwUnicodeHeader=0xFEFF;
        WriteFile(hFile, &dwUnicodeHeader, 2, &dwSize, NULL);
    }
#endif
    error=GetLastError();
    return hFile;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  LogMessage
//
//  Writes lpMessage to the setup log
//
////////////////////////////////////////////////////////////////////////////////////
BOOL LogMessage(LPCTSTR lpMessage)
{
    DWORD dwBytesWritten;
    HANDLE hFile;

    if (!lpMessage)
    {
        return FALSE;
    }    
    hFile=OpenLogFile();
    
    if(hFile==INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    SetFilePointer(hFile, 0, NULL, FILE_END);
    WriteFile(
        hFile,
        lpMessage,
        _tcslen(lpMessage) * sizeof(TCHAR),
        &dwBytesWritten,
        NULL);
    SetFilePointer(hFile, 0, NULL, FILE_END);
    WriteFile(
        hFile,
        TEXT("\r\n"),
        _tcslen(TEXT("\r\n")) * sizeof(TCHAR),
        &dwBytesWritten,
        NULL);
    CloseHandle(hFile);
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
// LogFormattedMessage
//
// Writes a formatted lpMessage to the setup log
//
////////////////////////////////////////////////////////////////////////////////////
BOOL LogFormattedMessage(HINSTANCE hInstance, int messageID, LONG_PTR* lppArgs)
{
    TCHAR szBuffer[BUFFER_SIZE];
    
    LoadString(hInstance, messageID, szBuffer, ARRAYSIZE(szBuffer));
    if (lppArgs == NULL)
    {
        return (LogMessage(szBuffer));
    }
    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
        szBuffer,
        0,
        0,
        szBuffer,
        sizeof(szBuffer) / sizeof(TCHAR),
        (va_list *)lppArgs);
    
    return (LogMessage(szBuffer));
}
////////////////////////////////////////////////////////////////////////////
//
//  FormatStringFromResource
//
//  Format a string using the format specified in the resource and the 
//  specified arguments.
//
//  Parameters:
//
//  Return Values:
//      the formatted string.
//
//  Remarks:
//
//  08-07-2000  YSLin       Created.
//
////////////////////////////////////////////////////////////////////////////
LPTSTR FormatStringFromResource(LPTSTR pszBuffer, UINT bufferSize, HMODULE hInstance, int messageID, LONG_PTR* lppArgs)
{
    TCHAR szFormatStr[BUFFER_SIZE];
        
        
    LoadString(hInstance, messageID, szFormatStr, ARRAYSIZE(szFormatStr)-1);
    if (!lppArgs)
    {
        LogMessage(szFormatStr);
        return NULL;
    }
    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  szFormatStr,
                  0,
                  0,
                  pszBuffer,
                  bufferSize ,
                  (va_list *)lppArgs);
    return (pszBuffer);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  BeginLog
//
//  Writes a header to the setup log
//
////////////////////////////////////////////////////////////////////////////////////
void BeginLog(void)
{
    TCHAR lpMessage[BUFFER_SIZE];
    SYSTEMTIME stSysTime;
    HRESULT hresult;
    //
    //  "**********************************************************
    //  Language Module Installation Log
    //  **********************************************************" (LOG)
    //
    LoadString(ghInstance, IDS_LOG_HEAD, lpMessage, ARRAYSIZE(lpMessage)-1);
    LogMessage(lpMessage);
    // Also log the time the mui installation is started.
    GetLocalTime(&stSysTime);
    //*STRSAFE*     wsprintf(lpMessage, TEXT("Muisetup.exe started on day %2d/%2d/%4d at time %2d:%2d:%2d"), 
    //*STRSAFE*                     stSysTime.wMonth,
    //*STRSAFE*                     stSysTime.wDay,
    //*STRSAFE*                     stSysTime.wYear,
    //*STRSAFE*                     stSysTime.wHour,
    //*STRSAFE*                     stSysTime.wMinute,
    //*STRSAFE*                     stSysTime.wSecond
    //);
    hresult = StringCchPrintf(lpMessage ,  ARRAYSIZE(lpMessage) ,  TEXT("Muisetup.exe started on day %2d/%2d/%4d at time %2d:%2d:%2d"), 
    	                                    stSysTime.wMonth,
                                           stSysTime.wDay,
                                           stSysTime.wYear,
                                           stSysTime.wHour,
                                           stSysTime.wMinute,
                                           stSysTime.wSecond
                   );                                           
    if (!SUCCEEDED(hresult))
    {
       return;
    }
    LogMessage(lpMessage);
    
}
////////////////////////////////////////////////////////////////////////////////////
//
//  GetLanguageGroup
//
//  Retreive the Language Group of this locale.
//
////////////////////////////////////////////////////////////////////////////////////
LGRPID GetLanguageGroup(LCID lcid)
{
    int i;
    gLangGroup = LGRPID_WESTERN_EUROPE;
    gFoundLangGroup = FALSE;
    gLCID = lcid;
    for (i=0 ; i<gNumLanguageGroups; i++)
    {
        // The globals gLangGroup and gFoundLangGroup is used in the callback function
        // EnumLanguageGroupLocalesProc.
        gpfnEnumLanguageGroupLocalesW(EnumLanguageGroupLocalesProc, gLanguageGroups[i], 0L, 0L);
        //
        // If we found it, then break now
        //
        if (gFoundLangGroup)
            break;
    }
    return gLangGroup;
}
BOOL EnumLanguageGroupLocalesProc(
    LGRPID langGroupId,
    LCID lcid,
    LPTSTR lpszLocale,
    LONG_PTR lParam)
{
    if (lcid == gLCID)
    {
        gLangGroup = langGroupId;
        gFoundLangGroup = TRUE;
        // stop iterating
        return FALSE;
    }
    // next iteration
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  DetectLanguageGroups
//
//  Detect language groups installed.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL DetectLanguageGroups(HWND hwndDlg)
{
    int i;
    HWND hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
    HWND hwndProgress, hwndStatus,hProgDlg;
    int iCount = ListView_GetItemCount(hwndList);
    LVITEM lvItem;
    PMUILANGINFO pMuiLangInfo;
    TCHAR szBuf[MAX_PATH], szStatus[MAX_PATH];
    PVOID ppArgs[1];
    hProgDlg = CreateDialog(ghInstance,
                            MAKEINTRESOURCE(IDD_DIALOG_INSTALL_PROGRESS),
                            hwndDlg,
                            ProgressDialogFunc);
    hwndProgress = GetDlgItem(hProgDlg, IDC_PROGRESS1);
    hwndStatus = GetDlgItem(hProgDlg, IDC_STATUS);
    //
    // Reflect that we doing something on the UI
    //
    LoadString(ghInstance, IDS_INSTALLLANGGROUP, szBuf, MAX_PATH-1);
    SetWindowText(hProgDlg, szBuf);
    SendMessage(hwndProgress, PBM_SETRANGE, (WPARAM)(int)0, (LPARAM)MAKELPARAM(0, iCount));
    SendMessage(hwndProgress, PBM_SETPOS, (WPARAM)(int)(0), 0);
    SetWindowText(hwndStatus, TEXT(""));
    i = 0;
    while (i < iCount)
    {
        //
        // Check if Language Group is installed
        //
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.state = 0;
        lvItem.stateMask = 0;
        lvItem.pszText = 0;
        lvItem.cchTextMax = 0;
        lvItem.iImage = 0;
        lvItem.lParam = 0;
        ListView_GetItem(hwndList, &lvItem);
        pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;
        SendMessage(hwndProgress, PBM_SETPOS, (WPARAM)(int)i+1, 0L);
        LoadString(ghInstance, IDS_CHECK_LANG_GROUP, szStatus, MAX_PATH-1);
        if (pMuiLangInfo->szDisplayName[0] == L'\0')
        {
            GetDisplayName(pMuiLangInfo);
        }
        ppArgs[0] = pMuiLangInfo->szDisplayName;
        FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      szStatus,
                      0,
                      0,
                      szStatus,
                      MAX_PATH-1,
                      (va_list *)ppArgs);
        SetWindowText(hwndStatus, szStatus);
        pMuiLangInfo->lgrpid = GetLanguageGroup(pMuiLangInfo->lcid);
        i++;
    };
    SendMessage(hwndProgress, PBM_SETPOS, (WPARAM)(int)i+1, 0L);
    DestroyWindow(hProgDlg);
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
// AddExtraLangGroupsFromINF
//
//      Look at the [LanguagePack] section to see if we need to install extra
//      language packs for the language specified in lpszLcid.
//
//      This is basically used to support pseudo localized build.
//
//  Parameter:
//      lpszLcid the LCID of UI language to be installed in string form.
//      pInstallLangGroup   points to a strcutre which stores language groups to be installed.
//
//  Remarks:
//
//      10-11-2000  YSLin       Created.
////////////////////////////////////////////////////////////////////////////////////
BOOL AddExtraLangGroupsFromINF(LPTSTR lpszLcid, PINSTALL_LANG_GROUP pInstallLangGroup)
{
    WCHAR szBuffer[BUFFER_SIZE];
    HINF hInf;
    INFCONTEXT InfContext;
    LONG_PTR lppArgs[2];    
    int LangGroup;
    int i;
    HRESULT hresult;
    if (!pInstallLangGroup)
    {
        return FALSE;
    }
    hInf = SetupOpenInfFile(g_szMUIInfoFilePath, NULL, INF_STYLE_WIN4, NULL);    
    
    if (hInf == INVALID_HANDLE_VALUE)
    {
        //*STRSAFE*         _stprintf(szBuffer, TEXT("%d"), GetLastError());    
        hresult = StringCchPrintf(szBuffer , ARRAYSIZE(szBuffer),  TEXT("%d"), GetLastError());
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
        lppArgs[0] = (LONG_PTR)szBuffer;
        lppArgs[1] = (LONG_PTR)g_szMUIInfoFilePath;
        LogFormattedMessage(ghInstance, IDS_NO_READ_L, lppArgs);
        return (FALSE);
    }
    if (SetupFindFirstLine(hInf, MUI_LANGPACK_SECTION, lpszLcid, &InfContext))
    {
        i = 1;
        while (SetupGetIntField(&InfContext, i++, &LangGroup))
        {
            AddMUILangGroup(pInstallLangGroup, LangGroup);
        }
    }
    SetupCloseInfFile(hInf);
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////////////
//
// ConvertMUILangToLangGroup
//
//      Generate Lang-Group IDs for the selected items in the listview,
//      in preparation to pass them to InstallLanguageGroups(...)
////////////////////////////////////////////////////////////////////////////////////
BOOL ConvertMUILangToLangGroup(HWND hwndDlg, PINSTALL_LANG_GROUP pInstallLangGroup)
{
    int i;
    LVITEM lvItem;
    HWND hwndList = GetDlgItem(hwndDlg, IDC_LIST1);
    int iCount = ListView_GetItemCount(hwndList);
    PMUILANGINFO pMuiLangInfo;

    if (!pInstallLangGroup)
    {
        return FALSE;
    }
    //
    // Initialize to "No lang-groups to install"
    //
    pInstallLangGroup->iCount = 0L;
    i = 0;
    while (i < iCount)
    {
        if (ListView_GetCheckState(hwndList, i))
        {
           //
           // Check if Language Group is installed
           //
           lvItem.mask = LVIF_PARAM;
           lvItem.iItem = i;
           lvItem.iSubItem = 0;
           lvItem.state = 0;
           lvItem.stateMask = 0;
           lvItem.pszText = 0;
           lvItem.cchTextMax = 0;
           lvItem.iImage = 0;
           lvItem.lParam = 0;
           ListView_GetItem(hwndList, &lvItem);
           pMuiLangInfo = (PMUILANGINFO)lvItem.lParam;
           //
           // Make sure there are no redundant elements
           //
           AddMUILangGroup(pInstallLangGroup, pMuiLangInfo->lgrpid);
           //
           // Add extra language groups specified in [LangPack] section of mui.inf
           // This is used to support Pesudo Localized Build.           
           //
           AddExtraLangGroupsFromINF(pMuiLangInfo->lpszLcid, pInstallLangGroup);
        }
        i++;
    };
    return TRUE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  AddMUILangGroup
//
//      Add a language a group to INSTALL_LANG_GROUP. Takes care of duplicates.
////////////////////////////////////////////////////////////////////////////////////
BOOL AddMUILangGroup(PINSTALL_LANG_GROUP pInstallLangGroup, LGRPID lgrpid)
{
    int j = 0L;
    BOOL bFound = FALSE;
    if (!pInstallLangGroup)
    {
        return FALSE;
    }
    //
    // Check if it is installed by default
    //
    if (gpfnIsValidLanguageGroup(lgrpid, LGRPID_INSTALLED))
    {   
        return FALSE;
    }
    while (j < pInstallLangGroup->iCount)
    {
        if (pInstallLangGroup->lgrpid[j] == lgrpid)
        {
            bFound = TRUE;
        }
        j++;
    }
    if (!bFound)
    {
        pInstallLangGroup->lgrpid[j] = lgrpid;
        pInstallLangGroup->iCount++;
        return TRUE;
    }
    return FALSE;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  RunRegionalOptionsApplet
//
//  Run the Regional Option silent mode installation using the specified pCommands.
//
//  This function will create the "[RegigionalSettings]" string, so there is no need
//  to supply that in pCommands.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL RunRegionalOptionsApplet(LPTSTR pCommands)
{
    HANDLE hFile;
    TCHAR szFilePath[MAX_PATH], szCmdLine[MAX_PATH];
    DWORD dwNumWritten = 0L;
    STARTUPINFO si;
    PROCESS_INFORMATION pi = {0};
    int i;
    LONG_PTR lppArgs[3];
    HRESULT hresult;
    TCHAR szRunDllPath[MAX_PATH];
    
    TCHAR szSection[MAX_PATH] = TEXT("[RegionalSettings]\r\n");
    if (!pCommands)
    {
        return FALSE;
    }
    //
    // prepare the file for un-attended mode setup
    //
    szFilePath[0] = UNICODE_NULL;
    if (!pfnGetWindowsDir(szFilePath, MAX_PATH-1))
    {
        return FALSE;
    }
    i = lstrlen(szFilePath);
    if (szFilePath[i-1] != TEXT('\\'))
    {
        //*STRSAFE*         lstrcat(szFilePath, TEXT("\\"));
        hresult = StringCchCat(szFilePath , ARRAYSIZE(szFilePath), TEXT("\\"));
        if (!SUCCEEDED(hresult))
        {
           return FALSE;
        }
    }
    hresult = StringCchCopy(szRunDllPath , ARRAYSIZE(szRunDllPath), szFilePath);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    //*STRSAFE*     lstrcat(szFilePath, MUI_LANG_GROUP_FILE);
    hresult = StringCchCat(szFilePath , ARRAYSIZE(szFilePath), MUI_LANG_GROUP_FILE);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }    
    hresult = StringCchCat(szRunDllPath , ARRAYSIZE(szRunDllPath), RUNDLLNAME);
    if (!SUCCEEDED(hresult))
    {
       return FALSE;
    }
    hFile = CreateFile(szFilePath,
                       GENERIC_WRITE,
                       0L,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        lppArgs[0] = (LONG_PTR)szFilePath;
        LogFormattedMessage(ghInstance, IDS_ERROR_FILE_CREATE, lppArgs);
        return FALSE;
    }
    WriteFile(hFile,
              szSection,
              (lstrlen(szSection) * sizeof(TCHAR)),
              &dwNumWritten,
              NULL);
    if (dwNumWritten != (lstrlen(szSection) * sizeof(TCHAR)))
    {
        lppArgs[0] = (LONG_PTR)szFilePath;
        LogFormattedMessage(ghInstance, IDS_ERROR_FILE_CREATE, lppArgs);
        CloseHandle(hFile);
        return FALSE;
    }
    WriteFile(hFile,
               pCommands,
              (lstrlen(pCommands) * sizeof(TCHAR)),
              &dwNumWritten,
              NULL);
    if (dwNumWritten != (lstrlen(pCommands) * sizeof(TCHAR)))
    {
#if SAMER_DBG
        OutputDebugString(TEXT("Unable to write to Language Groups to muilang.txt\n"));
#endif
        CloseHandle(hFile);
        return (FALSE);
    }
    CloseHandle(hFile);
    //
    // Call the control panel regional-options applet, and wait for it to complete
    //
    //*STRSAFE* lstrcpy(szCmdLine, TEXT("rundll32 shell32,Control_RunDLL intl.cpl,, /f:\""));
    hresult=StringCchPrintf(szCmdLine,ARRAYSIZE(szCmdLine),TEXT("\"%s\" shell32,Control_RunDLL intl.cpl,, /f:\""),szRunDllPath);
    if (!SUCCEEDED(hresult))
    {
       DeleteFile(szFilePath);
       return FALSE;
    }           
    
    //*STRSAFE*     lstrcat(szCmdLine, szFilePath);
    hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), szFilePath);
    if (!SUCCEEDED(hresult))
    {
       DeleteFile(szFilePath);
       return FALSE;
    }
    // only pop up progress bar UI if we are showing UI "/g" param for intl.cpl dictates this
    // also add a /D so that intl.cpl will not prompt for a source dialog if no UI is to be shown
    if (!g_bNoUI)
    {
        //*STRSAFE*         lstrcat(szCmdLine, TEXT("\"/g "f));
        hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), TEXT("\" /g"));
        if (!SUCCEEDED(hresult))
        {
           DeleteFile(szFilePath);
           return FALSE;
        }
    }
    else
    {
#ifdef MUI_MAGIC    
        //*STRSAFE*         lstrcat(szCmdLine, TEXT("\" /D"));
        hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), TEXT("\" /D "));
//        hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), TEXT("\" "));
        if (!SUCCEEDED(hresult))
        {
           DeleteFile(szFilePath);
           return FALSE;
        }
#else
        //*STRSAFE*         lstrcat(szCmdLine, TEXT("\" /D"));
        hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), TEXT("\" "));
//        hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), TEXT("\" "));
        if (!SUCCEEDED(hresult))
        {
           DeleteFile(szFilePath);
           return FALSE;
        }
#endif
    }

    // intl.cpl matches the UI font if /t is specified on the command line
    if (g_bCmdMatchUIFont)
    {
        //*STRSAFE*         lstrcat(szCmdLine, TEXT("/t "));
        hresult = StringCchCat(szCmdLine , ARRAYSIZE(szCmdLine), TEXT("/t "));
        if (!SUCCEEDED(hresult))
        {
           DeleteFile(szFilePath);
           return FALSE;
        }
    }

    memset( &si, 0x00, sizeof(si));
    si.cb = sizeof(STARTUPINFO);
    if (!CreateProcess(NULL,
                       szCmdLine,
                       NULL,
                       NULL,
                       FALSE,
                       0L,
                       NULL,
                       NULL,
                       &si,
                       &pi))
    {
        lppArgs[0] = (LONG_PTR)szCmdLine;
        LogFormattedMessage(ghInstance, IDS_ERROR_LAUNCH_INTLCPL, lppArgs);
        DeleteFile(szFilePath);
        return FALSE;
    }
    //
    // Wait forever till intl.cpl terminates.
    //
    WaitForSingleObject(pi.hProcess, INFINITE);
    //
    // Close Handle
    //
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
    //
    // Delete the File
    //
    DeleteFile(szFilePath);
    return (TRUE);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  InstallLanguageGroups
//
//  Checks whether a language group is needed to be installed or not. If
//      any lang-group needs to be installed, then the routine will invoke
//      the Regional-Options applet in unattended mode setup.
//
//  Return:
//      TURE if the operation succeeds.  Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InstallLanguageGroups(PINSTALL_LANG_GROUP pInstallLangGroup)
{
    TCHAR pCommands[MAX_PATH];
    int i, iCount = pInstallLangGroup->iCount;
    BOOL bFirstTime=FALSE;
    HRESULT hresult;

    if (!pInstallLangGroup)
    {
        return FALSE;
    }
    //
    // If nothing to do, then just return
    //
    if (0L == iCount)
    {
        return TRUE;
    }
    i = 0;
    while (i < iCount)
    {
        if (!gpfnIsValidLanguageGroup(pInstallLangGroup->lgrpid[i], LGRPID_INSTALLED))
        {
            if (!bFirstTime)
            {
                bFirstTime = TRUE;
                //*STRSAFE*                 wsprintf(pCommands, TEXT("LanguageGroup = %d\0"), pInstallLangGroup->lgrpid[i]);
                hresult = StringCchPrintf(pCommands , ARRAYSIZE(pCommands),  TEXT("LanguageGroup = %d\0"), pInstallLangGroup->lgrpid[i]);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
            }
            else
            {
                //*STRSAFE*                 wsprintf(&pCommands[lstrlen(pCommands)], TEXT(",%d\0"), pInstallLangGroup->lgrpid[i]);
                hresult = StringCchPrintf(&pCommands[lstrlen(pCommands)] , ARRAYSIZE(pCommands) -lstrlen(pCommands) ,  TEXT(",%d\0"), pInstallLangGroup->lgrpid[i]);
                if (!SUCCEEDED(hresult))
                {
                   return FALSE;
                }
            }
        }
        i++;
    };
    if (!bFirstTime)
    {
        //
        // There is no language group to be added.
        return (FALSE);        
    }
    return (RunRegionalOptionsApplet(pCommands));
}
////////////////////////////////////////////////////////////////////////////
//
//  Muisetup_RebootTheSystem
//
//  This routine enables all privileges in the token, calls ExitWindowsEx
//  to reboot the system, and then resets all of the privileges to their
//  old state.
//
////////////////////////////////////////////////////////////////////////////
void Muisetup_RebootTheSystem(void)
{
    HANDLE Token = NULL;
    ULONG ReturnLength, Index;
    PTOKEN_PRIVILEGES NewState = NULL;
    PTOKEN_PRIVILEGES OldState = NULL;
    BOOL Result;
    Result = OpenProcessToken( GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               &Token );
    if (Result)
    {
        ReturnLength = 4096;
        NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        OldState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, ReturnLength);
        Result = (BOOL)((NewState != NULL) && (OldState != NULL));
        if (Result)
        {
            Result = GetTokenInformation( Token,            // TokenHandle
                                          TokenPrivileges,  // TokenInformationClass
                                          NewState,         // TokenInformation
                                          ReturnLength,     // TokenInformationLength
                                          &ReturnLength );  // ReturnLength
            if (Result)
            {
                //
                // Set the state settings so that all privileges are enabled...
                //
                if (NewState->PrivilegeCount > 0)
                {
                    for (Index = 0; Index < NewState->PrivilegeCount; Index++)
                    {
                        NewState->Privileges[Index].Attributes = SE_PRIVILEGE_ENABLED;
                    }
                }
                Result = AdjustTokenPrivileges( Token,           // TokenHandle
                                                FALSE,           // DisableAllPrivileges
                                                NewState,        // NewState
                                                ReturnLength,    // BufferLength
                                                OldState,        // PreviousState
                                                &ReturnLength ); // ReturnLength
                if (Result)
                {
                    ExitWindowsEx(EWX_REBOOT, SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);
                    AdjustTokenPrivileges( Token,
                                           FALSE,
                                           OldState,
                                           0,
                                           NULL,
                                           NULL );
                }
            }
        }
    }
    if (NewState != NULL)
    {
        LocalFree(NewState);
    }
    if (OldState != NULL)
    {
        LocalFree(OldState);
    }
    if (Token != NULL)
    {
        CloseHandle(Token);
    }
}
////////////////////////////////////////////////////////////////////////////
//
//  CheckForReboot
//
//  Check if we need to reboot the system, if a lang group is installed
//
//  Return:
//  TRUE if we need user to reboot, otherwise FALSE.   
//
////////////////////////////////////////////////////////////////////////////
BOOL CheckForReboot(HWND hwnd, PINSTALL_LANG_GROUP pInstallLangGroup)
{
    int nIDS,nMask=MB_YESNO | MB_ICONQUESTION;
    if (!pInstallLangGroup)
    {
       return FALSE;
    }
    if (pInstallLangGroup->iCount || pInstallLangGroup->bFontLinkRegistryTouched || pInstallLangGroup->NotDeleted 
        || g_bRemoveDefaultUI || g_bRemoveUserUI || g_bReboot)
    {
        if (g_bRemoveUserUI)
        {
           nIDS=IDS_MUST_REBOOT_STRING1;
           nMask=MB_YESNO | MB_ICONWARNING;
        }
        else if (g_bRemoveDefaultUI)
        {
            nMask=MB_YESNO | MB_ICONWARNING;
            nIDS=IDS_MUST_REBOOT_STRING2;
        }
        else
        {
           nIDS=IDS_REBOOT_STRING;
        }

        SetForegroundWindow(hwnd);   // muisetup lost focus when it show reboot dialog so we force it as foreground window.        
         
        if (DoMessageBox(hwnd, nIDS, IDS_MAIN_TITLE, nMask) == IDYES)
        {
           Muisetup_RebootTheSystem();
        }
        return (TRUE);
    }
    return (FALSE);
}
////////////////////////////////////////////////////////////////////////////
//
// Following code are stolen from intl.cpl
//
// We want to enumulate all installed UI languages
//
////////////////////////////////////////////////////////////////////////////
DWORD_PTR TransNum(
    LPTSTR lpsz)
{
    DWORD dw = 0L;
    TCHAR c;
    if (!lpsz)
    {
       return dw;
    }

    while (*lpsz)
    {
        c = *lpsz++;
        if (c >= TEXT('A') && c <= TEXT('F'))
        {
            c -= TEXT('A') - 0xa;
        }
        else if (c >= TEXT('0') && c <= TEXT('9'))
        {
            c -= TEXT('0');
        }
        else if (c >= TEXT('a') && c <= TEXT('f'))
        {
            c -= TEXT('a') - 0xa;
        }
        else
        {
            break;
        }
        dw *= 0x10;
        dw += c;
    }
    return (dw);
}
BOOL MUIGetAllInstalledUILanguages()
{
    pfnEnumUILanguages fnEnumUILanguages;
    BOOL result = TRUE;
    HINSTANCE hKernel32;
    //
    //  Enumerate the installed UI languages.
    //
    g_UILanguageGroup.iCount = 0L;
    hKernel32 = LoadLibrary(TEXT("kernel32.dll"));
    fnEnumUILanguages = (pfnEnumUILanguages)GetProcAddress(hKernel32, "EnumUILanguagesW");
    if (fnEnumUILanguages == NULL) 
    {
        result = FALSE;
    } else
    {
        fnEnumUILanguages(Region_EnumUILanguagesProc, 0, (LONG_PTR)&g_UILanguageGroup);
    }
    FreeLibrary(hKernel32);
    return (result);
}
BOOL CALLBACK Region_EnumUILanguagesProc(
    LPWSTR pwszUILanguage,
    LONG_PTR lParam)
{
    int Ctr = 0;
    LGRPID lgrp;    
    PUILANGUAGEGROUP pUILangGroup = (PUILANGUAGEGROUP)lParam;
    if ( (!pwszUILanguage) || (!pUILangGroup))
    {
        return FALSE;
    }
    LCID UILanguage = (LCID)TransNum( pwszUILanguage );
    if (UILanguage)
    {
        while (Ctr < pUILangGroup->iCount)
        {
            if (pUILangGroup->lcid[Ctr] == UILanguage)
            {
                break;
            }
            Ctr++;
        }
        //
        //  Theoritically, we won't go over 64 language groups!
        //
        if ((Ctr == pUILangGroup->iCount) && (Ctr < MAX_UI_LANG_GROUPS))
        {
            pUILangGroup->lcid[Ctr] = UILanguage;
            pUILangGroup->iCount++;
        }
    }
    return (TRUE);
}
BOOL IsSpaceEnough(HWND hwndDlg,INT64 *ulSizeNeed,INT64 *ulSizeAvailable)
{
    
    HWND    hList; 
    LGRPID lgrpid[MAX_MUI_LANGUAGES];
    LPTSTR lpszLcid;
    int    iIndex;
    int    i = 0;
    int    iCount=0,iArrayIndex=0;
    PMUILANGINFO pMuiLangInfo;
    BOOL   bChked,bResult=TRUE;
    INT64  ulTotalBytesRequired=0,ulSpaceAvailable;
    TCHAR  szWinDir[MAX_PATH];
    BOOL   bFELangpackAdded = FALSE;
    
    ULARGE_INTEGER ulgiFreeBytesAvailableToCaller;
    ULARGE_INTEGER ulgiTotalNumberOfBytes;
    if ((!ulSizeNeed) || (!ulSizeAvailable))
    {
        return FALSE;
    }
     *ulSizeNeed=0; 
    *ulSizeAvailable=0;
    hList=GetDlgItem(hwndDlg, IDC_LIST1);
    iIndex = ListView_GetItemCount(hList);   
       
    while(i<iIndex)
    {
        bChked=ListView_GetCheckState(hList, i);
        GetMuiLangInfoFromListView(hList, i, &pMuiLangInfo);        
        lpszLcid = pMuiLangInfo->lpszLcid;
        //
        // Install required
        //
        if (bChked && !IsInstalled(lpszLcid) && HaveFiles(lpszLcid))
        {
           if (!gpfnIsValidLanguageGroup(pMuiLangInfo->lgrpid, LGRPID_INSTALLED))
           {
              for(iArrayIndex=0;iArrayIndex < iCount;iArrayIndex++)
              {
                 if (lgrpid[iArrayIndex]==pMuiLangInfo->lgrpid)
                    break;
              }
              if(iArrayIndex == iCount)
              {  
                 if (IS_FE_LANGPACK(pMuiLangInfo->lcid))
                 {
                    if (!bFELangpackAdded)
                    {
                        ulTotalBytesRequired+=pMuiLangInfo->ulLPKSize;
                        bFELangpackAdded = TRUE;
                    }
                 }
                 else
                 {
                    ulTotalBytesRequired+=pMuiLangInfo->ulLPKSize;
                 }
                 lgrpid[iCount]= pMuiLangInfo->lgrpid;
                 iCount++;
              }
           }
           ulTotalBytesRequired+=pMuiLangInfo->ulUISize;
        }
        // Uninstall required
        if (!bChked && IsInstalled(lpszLcid))
        {
           ulTotalBytesRequired-=pMuiLangInfo->ulUISize;
        } 
        i++;
    }
    //
    // Let's check available disk space of system drive
    //
    pfnGetWindowsDir( szWinDir, MAX_PATH);
    szWinDir[3]=TEXT('\0');
    if (GetDiskFreeSpaceEx(szWinDir,
                       &ulgiFreeBytesAvailableToCaller,
                       &ulgiTotalNumberOfBytes,
                       NULL))
    {
       ulSpaceAvailable= ulgiFreeBytesAvailableToCaller.QuadPart;
       if ( ulSpaceAvailable <  ulTotalBytesRequired )
       {
          *ulSizeNeed =ulTotalBytesRequired;
          *ulSizeAvailable=ulSpaceAvailable;  
          bResult=FALSE;
       }
       
    } 
    return bResult;
}
void ExitFromOutOfMemory()
{
    LONG_PTR lppArgs[1];
    lppArgs[0] = (LONG_PTR)GetLastError();
    DoMessageBox(NULL, IDS_OUT_OF_MEMORY, IDS_MAIN_TITLE, MB_ICONEXCLAMATION | MB_OK);
    LogFormattedMessage(ghInstance, IDS_OUT_OF_MEMORY_L, lppArgs);
    
    ExitProcess(1);
}
////////////////////////////////////////////////////////////////////////////
//
// Call the kernel to notify it that a new language is being added or
// removed
//
////////////////////////////////////////////////////////////////////////////
void NotifyKernel(
    LPTSTR LangList,
    ULONG Flags
    )
{
    HANDLE Handle;
    WMILANGUAGECHANGE LanguageChange;
    ULONG ReturnSize;
    BOOL IoctlSuccess;
    HRESULT hresult;
    if ((LangList != NULL) &&
        (*LangList != 0))
    {
        Handle = CreateFile(WMIAdminDeviceName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
        if (Handle != INVALID_HANDLE_VALUE)
        {
            while (*LangList != 0)
            {
                memset(&LanguageChange, 0, sizeof(LanguageChange));
                //*STRSAFE*                 _tcscpy(LanguageChange.Language, LangList);
                hresult = StringCchCopy(LanguageChange.Language , MAX_LANGUAGE_SIZE, LangList);
                if (!SUCCEEDED(hresult))
                {
                   CloseHandle(Handle);
                   return ;
                }
                LanguageChange.Flags = Flags;
                IoctlSuccess = DeviceIoControl(Handle,
                                          IOCTL_WMI_NOTIFY_LANGUAGE_CHANGE,
                                          &LanguageChange,
                                          sizeof(LanguageChange),
                                          NULL,
                                          0,
                                          &ReturnSize,
                                          NULL);
#if ALANWAR_DBG
                {
                    WCHAR Buf[256];
                    //*STRSAFE*                     wsprintf(Buf, L"MUISetup: Notify Lang change -> %d for %ws\n", GetLastError(), LangList);
                    hresult = StringCchPrintfW(Buf , ARRAYSIZE(Buf),  L"MUISetup: Notify Lang change -> %d for %ws\n", GetLastError(), LangList);
                    if (!SUCCEEDED(hresult))
                    {
                       CloseHandle(Handle);
                       return ;
                    }
                    OutputDebugStringW(Buf);
                }
#endif              
                while (*LangList++ != 0) ;
            }
            CloseHandle(Handle);
        }
    }
}
//
// Query MUI registry setting
//
BOOL CheckMUIRegSetting(DWORD dwFlag)
{
    BOOL bRet = FALSE;
    HKEY hKey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_MUI_SETTING, 0, KEY_READ, &hKey))
    {
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        DWORD dwType;
        if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, 
                (dwFlag & MUI_MATCH_UIFONT)? REGSTR_VALUE_MATCH_UIFONT : REGSTR_VALUE_MATCH_LOCALE, 
                0, &dwType, (LPBYTE)&dwValue, &dwSize))
        {
            bRet = (BOOL) dwValue;
        }
        RegCloseKey(hKey);
    }         
    
    return bRet;
}
//
// Set MUI registry setting
//
BOOL SetMUIRegSetting(DWORD dwFlag, BOOL bEnable)
{
    BOOL bRet = FALSE;
    HKEY hKey;    
    if (ERROR_SUCCESS  ==
        RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_MUI_SETTING, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, &hKey, NULL))
    {
        DWORD dwValue = (DWORD) bEnable;
        if (ERROR_SUCCESS ==
            RegSetValueEx(hKey, 
                (dwFlag & MUI_MATCH_UIFONT)? REGSTR_VALUE_MATCH_UIFONT : REGSTR_VALUE_MATCH_LOCALE, 
                0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD)))
        {
            bRet = TRUE;
        }
        RegCloseKey(hKey);
    }
    return bRet;
}
//
// Delete  MUI registry setting
//
BOOL DeleteMUIRegSetting()
{
    BOOL bRet = TRUE;
    HKEY hKey;
    TCHAR tcMessage[BUFFER_SIZE];
    if (ERROR_SUCCESS ==RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_MUI_SETTING, 0, KEY_ALL_ACCESS, &hKey))
    {    
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        DWORD dwType;
        
        if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, 
                REGSTR_VALUE_MATCH_UIFONT, 
                0, &dwType, (LPBYTE)&dwValue, &dwSize))
        {
        
           if (RegDeleteValue(hKey, REGSTR_VALUE_MATCH_UIFONT) != ERROR_SUCCESS)
           {
              wnsprintf(tcMessage, ARRAYSIZE(tcMessage) ,TEXT("MuiSetup: DeleteMUIRegSetting: WARNING - Failed to delete regkey HKLM\\%s regvalue %s"), REGSTR_MUI_SETTING,REGSTR_VALUE_MATCH_UIFONT);
              LogMessage(tcMessage);                
              bRet = FALSE;              
           }
        }
        dwSize = sizeof(dwValue);
        if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, 
                REGSTR_VALUE_MATCH_LOCALE, 
                0, &dwType, (LPBYTE)&dwValue, &dwSize))
        {
        
            if (RegDeleteValue(hKey, REGSTR_VALUE_MATCH_LOCALE) != ERROR_SUCCESS)
           {
              wnsprintf(tcMessage, ARRAYSIZE(tcMessage) ,TEXT("MuiSetup: DeleteMUIRegSetting: WARNING - Failed to delete regkey HKLM\\%s regvalue %s"), REGSTR_MUI_SETTING,REGSTR_VALUE_MATCH_LOCALE);
              LogMessage(tcMessage);                
              bRet = FALSE;
           }
        }  
 
        RegCloseKey(hKey);
    }         
    
    return bRet;
}
////////////////////////////////////////////////////////////////////////////
//
//  DeleteRegTree
//
//  This deletes all subkeys under a specific key.
//
//  Note: The code makes no attempt to check or recover from partial
//  deletions.
//
//  A registry key that is opened by an application can be deleted
//  without error by another application.  This is by design.
//
////////////////////////////////////////////////////////////////////////////
DWORD DeleteRegTree(
    HKEY hStartKey,
    LPTSTR pKeyName)
{
    DWORD dwRtn, dwSubKeyLength;
    LPTSTR pSubKey = NULL;
    TCHAR szSubKey[REGSTR_MAX_VALUE_LENGTH];   // (256) this should be dynamic.
    HKEY hKey;
    //
    //  Do not allow NULL or empty key name.
    //
    if (pKeyName && lstrlen(pKeyName))
    {
        if ((dwRtn = RegOpenKeyEx( hStartKey,
                                   pKeyName,
                                   0,
                                   KEY_ENUMERATE_SUB_KEYS | DELETE,
                                   &hKey )) == ERROR_SUCCESS)
        {
            while (dwRtn == ERROR_SUCCESS)
            {
                dwSubKeyLength = REGSTR_MAX_VALUE_LENGTH;
                dwRtn = RegEnumKeyEx( hKey,
                                      0,       // always index zero
                                      szSubKey,
                                      &dwSubKeyLength,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL );
                if (dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
                else if (dwRtn == ERROR_SUCCESS)
                {
                    dwRtn = DeleteRegTree(hKey, szSubKey);
                }
            }
            RegCloseKey(hKey);
        }
        else if (dwRtn == ERROR_FILE_NOT_FOUND)
        {
            dwRtn = ERROR_SUCCESS;
        }
    }
    else
    {
        dwRtn = ERROR_BADKEY;
    }
    return (dwRtn);
}
////////////////////////////////////////////////////////////////////////////////////
//
//  InstallExternalComponents
//
//
//  Return:
//      TURE if the operation succeeds. Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////
BOOL InstallExternalComponents(LPTSTR Languages)
{
    BOOL    bRet = TRUE;
    TCHAR   lpMessage[BUFFER_SIZE];

    if (! Languages)
    {
        return FALSE;
    }
    //
    // call WBEM API to mofcompile MUI MFL's for each language
    //
    if (!MofCompileLanguages(Languages))
    {
        //
        // LOG: Error mofcompiling
        //
        LoadString(ghInstance, IDS_MOFCOMPILE_L, lpMessage, ARRAYSIZE(lpMessage)-1);
        LogMessage(lpMessage);
        bRet = FALSE;
    }
    if (bRet)
    {    
        //
        // Inform kernel that new languages have been added
        //
        NotifyKernel(Languages,
                     WMILANGUAGECHANGE_FLAG_ADDED);
    }
    return bRet;
}
////////////////////////////////////////////////////////////////////////////////////
//
//  UninstallExternalComponents
//
////////////////////////////////////////////////////////////////////////////////////
VOID UninstallExternalComponents(LPTSTR Languages)
{
    if (!Languages)
    {
        return ;
    }
    //
    // Inform kernel that new languages have been added
    //
    NotifyKernel(Languages,
                 WMILANGUAGECHANGE_FLAG_REMOVED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\mui\tools\muiver\muiver.cpp ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <assert.h>
#include <io.h>
#include <md5.h>
#define STRSAFE_LIB
#include <strsafe.h>

#define MD5_CHECKSUM_SIZE 16
#define RESOURCE_CHECKSUM_LANGID 0x0409

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

BOOL g_bVerbose = FALSE;

typedef struct 
{
    BOOL bContainResource;
    MD5_CTX ChecksumContext;
} CHECKSUM_ENUM_DATA;

void PrintError()
{
    LPTSTR lpMsgBuf;
    
    if (FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    ))
    {
        printf("GetLastError():\n   %s", lpMsgBuf);
        LocalFree( lpMsgBuf );            
    }
    return;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumNamesFunc
//
//  The callback funciton for enumerating the resource names in the specified module and
//  type.
//  The side effect is that MD5 checksum context (contained in CHECKSUM_ENUM_DATA
//  pointed by lParam) will be updated.
//
//  Return:
//      Always return TRUE so that we can finish all resource enumeration.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumNamesFunc(HMODULE hModule, LPCTSTR lpType, LPTSTR lpName, LONG_PTR lParam){

    HRSRC hRsrc;
    HGLOBAL hRes;
    const unsigned char* pv;
    LONG ResSize=0L;
    WORD IdFlag=0xFFFF;

    DWORD dwHeaderSize=0L;
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;   

    if(!(hRsrc=FindResourceEx(hModule, lpType, lpName,  RESOURCE_CHECKSUM_LANGID)))
    {
        //
        // If US English resource is not found for the specified type and name, we 
        // will continue the resource enumeration.
        //
        return (TRUE);
    }
    pChecksumEnumData->bContainResource = TRUE;

    if (!(ResSize=SizeofResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not get resource size when generating resource checksum.\n");
        return (TRUE);
    }

    if (!(hRes=LoadResource(hModule, hRsrc)))
    {
        printf("WARNING: Can not load resource when generating resource checksum.\n");
        return (TRUE);
    }
    pv=(unsigned char*)LockResource(hRes);

    //
    // Update MD5 context using the binary data of this particular resource.
    //
    MD5Update(&(pChecksumEnumData->ChecksumContext), pv, ResSize);
    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  ChecksumEnumTypesFunc
//
//  The callback function for enumerating the resource types in the specified module.
//  This function will call EnumResourceNames() to enumerate all resource names of
//  the specified resource type.
//
//  Return:
//      TRUE if EnumResourceName() succeeds.  Otherwise FALSE.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK ChecksumEnumTypesFunc(HMODULE hModule, LPSTR lpType, LONG_PTR lParam)
{
    CHECKSUM_ENUM_DATA* pChecksumEnumData = (CHECKSUM_ENUM_DATA*)lParam;
    //
    // Skip the version resource type, so that version is not included in the resource checksum.
    //
    if (lpType == RT_VERSION)
    {
        return (TRUE);
    }    
    
    if(!EnumResourceNames(hModule, (LPCSTR)lpType, ChecksumEnumNamesFunc, (LONG_PTR)lParam))
    {
        return (FALSE);
    }
    return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////////
//
//  GenerateResourceChecksum
//
//  Generate the resource checksum for the US English resource in the specified file.
//
//  Parameters:
//      pszSourceFileName   The file used to generate resource checksum.
//      pResourceChecksum   Pointer to a 16 bytes (128 bits) buffer for storing
//                          the calcuated MD5 checksum.
//  Return:
//      TURE if resource checksum is generated from the given file.  Otherwise FALSE.
//  
//  The following situation may return FALSE:
//      * The specified file does not contain resource.
//      * If the specified file contains resource, but the resource is not US English.
//      * The specified file only contains US English version resource.
//
////////////////////////////////////////////////////////////////////////////////////

BOOL GenerateResourceChecksum(LPCSTR pszSourceFileName, unsigned char* pResourceChecksum)
{
    HMODULE hModule = NULL;
    ULONG i;

    DWORD dwResultLen;
    BOOL  bRet = FALSE;

    if (!pszSourceFileName)
    {
          goto GR_EXIT;
    }
    //
    // The stucture to be passed into the resource enumeration functions.
    //
    CHECKSUM_ENUM_DATA checksumEnumData;

    checksumEnumData.bContainResource = FALSE;

    //
    // Start MD5 checksum calculation by initializing MD5 context.
    //
    MD5Init(&(checksumEnumData.ChecksumContext));
    
    if (g_bVerbose)
    {
        printf("Generate resource checksum for [%s]\n", pszSourceFileName);
    }
    
    if(!(hModule = LoadLibraryEx(pszSourceFileName, NULL, DONT_RESOLVE_DLL_REFERENCES|LOAD_LIBRARY_AS_DATAFILE)))
    {
        if (g_bVerbose)
        {
            printf("\nERROR: Error in opening resource checksum module [%s]\n", pszSourceFileName);
        }
        PrintError();
        goto GR_EXIT;
    }

    if (g_bVerbose)
    {
        printf("\nLoad checksum file: %s\n", pszSourceFileName);
    }

    //
    //  Enumerate all resources in the specified module.
    //  During the enumeration, the MD5 context will be updated.
    //
    if (!EnumResourceTypes(hModule, ChecksumEnumTypesFunc, (LONG_PTR)&checksumEnumData))
    {
        if (g_bVerbose)
        {
            printf("\nWARNING: Unable to generate resource checksum from resource checksum module [%s]\n", pszSourceFileName);
        }
        goto GR_EXIT;
    }    

    if (checksumEnumData.bContainResource)
    {
        if (!pResourceChecksum)
        {
            goto GR_EXIT;
        }
        //
        // If the enumeration succeeds, and the specified file contains US English
        // resource, get the MD5 checksum from the accumulated MD5 context.
        //
        MD5Final(&checksumEnumData.ChecksumContext);

        memcpy(pResourceChecksum, checksumEnumData.ChecksumContext.digest, 16);

        if (g_bVerbose)
        {
            printf("Generated checksum: [");
            for (i = 0; i < MD5_CHECKSUM_SIZE; i++)
            {
                printf("%02x ", pResourceChecksum[i]);
            }
            printf("]\n");    
        }
        bRet = TRUE;
    }

GR_EXIT:
    if (hModule)
    {
        FreeLibrary(hModule);
    }

    return (bRet);
}

void PrintUsage() 
{
    printf("muiver - Print out MUI resource checksum\n");
    printf("Usage:\n\n");
    printf("    muiver <US English file name>\n");
    
}

void PrintChecksum(BYTE* lpChecksum, int nSize) 
{
    int i;

    if (!lpChecksum)
    {
        return;
    }
    for (i = 0; i < nSize; i++) 
    {
        printf("%02x ", lpChecksum[i]);
    }
}

struct LANGANDCODEPAGE {
  WORD wLanguage;
  WORD wCodePage;
};

LPWSTR EmptyString = L"N/A";

LPWSTR GetFileVersionStringData(LPVOID pVerData, LANGANDCODEPAGE* pLang, LPWSTR pVersionDataType) 
{
    WCHAR subBlcok[256];
    LPVOID lpBuffer;    
    UINT dwBytes;
    HRESULT hresult;
   
    if ( (! pVerData) || (!pLang) || (!pVersionDataType))
    {
         goto ERET;
    }
    //*STRSAFE*     wsprintfW( subBlcok,L"\\StringFileInfo\\%04x%04x\\%s",pLang->wLanguage,pLang->wCodePage,pVersionDataType);
    hresult = StringCchPrintfW(subBlcok,ARRAYSIZE(subBlcok),L"\\StringFileInfo\\%04x%04x\\%s",pLang->wLanguage,pLang->wCodePage,pVersionDataType);
    if (!SUCCEEDED(hresult))
    {
       goto ERET;
    }

    // Retrieve file description for language and code page "i". 
    if (VerQueryValueW(pVerData, 
                subBlcok, 
                &lpBuffer, 
                &dwBytes)) {
        return ((LPWSTR)lpBuffer);                
    }
ERET:    
    return (EmptyString);
}

void PrintFileVersion(LPVOID pVerData) 
{
    UINT cbTranslate;

    LANGANDCODEPAGE  *lpTranslate;
    
    
    if (!pVerData)
    {
        return;
    }
    // Read the list of languages and code pages.

    VerQueryValueW(pVerData, 
                  L"\\VarFileInfo\\Translation",
                  (LPVOID*)&lpTranslate,
                  &cbTranslate);

    // Read the file description for each language and code page.

    for(UINT i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++)
    {
        wprintf(L"  Locale = 0x%04x, CodePage = %d\n", lpTranslate->wLanguage, lpTranslate->wCodePage);
        wprintf(L"    FileDescriptions: [%s", GetFileVersionStringData(pVerData, lpTranslate+i, L"FileDescription")); 
        wprintf(L"]\n");
        wprintf(L"    FileVersion     : [%s]\n", GetFileVersionStringData(pVerData, lpTranslate+i, L"FileVersion")); 
        wprintf(L"    ProductVersion  : [%s]\n", GetFileVersionStringData(pVerData, lpTranslate+i, L"ProductVersion")); 
        //wprintf(L"    Comments        : [%s]\n", GetFileVersionStringData(pVerData, lpTranslate+i, L"Comments")); 
    }

    BYTE* lpResourceChecksum;
    UINT cbResourceChecksum;

    wprintf(L"    ResourceChecksum: [");

    if (VerQueryValueW(pVerData,
                     L"\\VarFileInfo\\ResourceChecksum",
                     (LPVOID*)&lpResourceChecksum,
                     &cbResourceChecksum))
    {
        for (i = 0; i < cbResourceChecksum; i++) 
        {
            wprintf(L"%02x ", lpResourceChecksum[i]);
        }
    } else 
    {
        wprintf(L"n/a");
    }
    wprintf(L"]\n");

}

void PrintResult(LPSTR fileName, LPVOID pVerData, BYTE* pChecksum)
{
    if (!fileName)
    {
       return;
    }
    printf("File: [%s]\n", fileName);
    printf("\nVersion information:\n");
    if (pVerData == NULL) 
    {
        printf("    !!! Not availabe.  Failed in GetFileVersionInfo()\n");
    } else 
    {
        PrintFileVersion(pVerData);
    }
    
    printf("\n\n  Resource Checksum:%s\n    ", fileName);
    if (pChecksum == NULL) 
    {
        printf("    n/a.  Probably resources for 0x%04x is not available.\n", RESOURCE_CHECKSUM_LANGID);
    } else 
    {    
        PrintChecksum(pChecksum, MD5_CHECKSUM_SIZE);
    }
    printf("\n");
}

int __cdecl main(int argc, char *argv[]){
    LPSTR pFileName;

    LPBYTE lpVerData = NULL;
    DWORD dwVerDataSize;
    DWORD dwHandle;

    BYTE MD5Checksum[MD5_CHECKSUM_SIZE];

    if (argc == 1) 
    {
        PrintUsage();
        return (1);
    }

    pFileName = argv[1];

    if (dwVerDataSize = GetFileVersionInfoSizeA(pFileName, &dwHandle)) 
    {
        lpVerData = new BYTE[dwVerDataSize];
        if (!GetFileVersionInfoA(pFileName, 0, dwVerDataSize, (LPVOID)lpVerData)) {
            lpVerData = NULL;
        }
    }

    if (GenerateResourceChecksum(pFileName, MD5Checksum))
    {
        PrintResult(pFileName, (LPVOID)lpVerData, MD5Checksum);
    } else 
    {
        PrintResult(pFileName, (LPVOID)lpVerData, NULL);    
    }
    

    if (!lpVerData)
    {
        delete [] lpVerData;
    }
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\resonexe\resonexe.c ===
/****************************************************************************/
/*                                                                          */
/*  resonexe.C -                                                            */
/*                                                                          */
/*    Windows DOS Version 3.2 add resource onto executable                  */
/*   (C) Copyright Microsoft Corporation 1988-1992                          */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include <windows.h>

#include <fcntl.h>
#include <io.h>
#include <stdlib.h>

#include "ntverp.h"
#include "rc.h"
#include "resonexe.h"

#define BUFSIZE 4096

//
// Globals
//

PUCHAR  szInFile=NULL;
BOOL    fDebug = FALSE;
BOOL    fVerbose = FALSE;
BOOL    fReplace = FALSE;
BOOL    fDelete = FALSE;
int     fhBin = -1;
UCHAR	szType[256];
UCHAR	szName[256];
int	idLang;
int	idType=0;
int	idName=0;

void
usage ( int rc );

void
usage ( int rc )
{
#if DBG
    printf("Microsoft (R) Windows RESONEXE Version %s\n", VER_PRODUCTVERSION_STR);
#else
    printf("Microsoft (R) Windows RESONEXE Version %s.%d\n", VER_PRODUCTVERSION_STR, VER_PRODUCTBUILD);
#endif /* dbg */
    printf("Copyright (C) Microsoft Corp. 1991-1992.  All rights reserved.\n\n");
    printf( "usage: resonexe [-v] [-r|-x resspec] [-fo outfile] <input file> [<exe file>]\n");
    printf( "       where  input file is an WIN32 .RES file\n");
    printf( "              -v verbose - print info\n");
    printf( "              -d debug - print debug info\n");
    printf( "              -r replace - delete all resource from input file before adding new resources.\n");
    printf( "              -x delete - delete specified resource from input file.\n");
    printf( "              resspec is of the form: typeid,nameid,langid\n");
    printf( "              typeid is a string or decimal number\n");
    printf( "              nameid is a string or decimal number\n");
    printf( "              langid is a hexadecimal number\n");
    printf( "              outfile is the desired output file name.\n");
    printf( "                      outfile defaults to filespec.exe.\n");
    printf( "              exe file is the exe file to attach resources to.\n");
    exit(rc);
}

void
__cdecl main(
    IN int argc,
    IN char *argv[]
    )

/*++

Routine Description:

    Determines options
    locates and opens input files
    reads input files
    writes output files
    exits

Exit Value:

        0 on success
        1 if error

--*/

{
    int         i;
    UCHAR       *s1;
    UCHAR       *szOutFile=NULL;
    UCHAR       *szExeFile=NULL;
    long        lbytes;
    BOOL        result;
    HANDLE      hupd;

    if (argc == 1) {
        usage(0);
        }

    for (i=1; i<argc; i++) {
        s1 = argv[i];
        if (*s1 == '/' || *s1 == '-') {
            s1++;
            if (!_stricmp(s1, "fo")) {
                szOutFile = argv[++i];
	    }
            else if (!_stricmp(s1, "d")) {
                fDebug = TRUE;
	    }
            else if (!_stricmp(s1, "v")) {
                fVerbose = TRUE;
	    }
            else if (!_stricmp(s1, "r")) {
                fReplace = TRUE;
	    }
            else if (!_stricmp(s1, "x")) {
                fDelete = TRUE;
		if (i+1 == argc)
		    usage(1);
		s1 = argv[++i];
		if (sscanf(s1, "%d,%d,%x", &idType, &idName, &idLang) == 3)
		    continue;
		idType = 0;
		idName = 0;
		if (sscanf(s1, "%d,%[^,],%x", &idType, szName, &idLang) == 3)
		    continue;
		idType = 0;
		idName = 0;
		if (sscanf(s1, "%[^,],%d,%x", szType, &idName, &idLang) == 3)
		    continue;
		idType = 0;
		idName = 0;
		if (sscanf(s1, "%[^,],%[^,],%x", szType, szName, &idLang) == 3)
		    continue;
		printf("Unrecognized type,name,lang triplet <%s>\n", s1);
		usage(1);
	    }
            else if (!_stricmp(s1, "h")) {
                usage(1);
	    }
            else if (!_stricmp(s1, "?")) {
                usage(1);
	    }
            else {
                usage(1);
	    }
	}
        else if (szInFile == NULL) {
            szInFile = s1;
	}
        else {
            szExeFile = s1;
        }
    }
    //
    // Make sure that we actually got a file
    //

    if (fDelete) {
	if (fReplace) {
	    printf("usage error:  Can't do both Replace and Delete\n");
	    usage(1);
	}
	if (!szInFile) {
	    printf("usage error:  Missing exe file spec\n");
	    usage(1);
	}
	if (szInFile && !szExeFile) {
	    szExeFile = szInFile;
	    if (!szOutFile)
		szOutFile = _strdup(szInFile);
	    szInFile = NULL;
	if (idType == 0)
	    _strupr(szType);
	if (idName == 0)
	    _strupr(szName);
	}
    }
    else if (!szInFile) {
	printf("usage error:  Must have file spec\n");
        usage(1);
    }

    if (fVerbose || fDebug) {
#if DBG
    printf("Microsoft (R) Windows RESONEXE Version %s\n", VER_PRODUCTVERSION_STR);
#else
    printf("Microsoft (R) Windows RESONEXE Version %s.%d\n", VER_PRODUCTVERSION_STR, VER_PRODUCTBUILD);
#endif /* dbg */
        printf("Copyright (C) Microsoft Corp. 1991-1992.  All rights reserved.\n\n");
    }


    if (szInFile && (fhBin = _open( szInFile, O_RDONLY|O_BINARY )) == -1) {
        /*
         *  try adding a .RES extension.
         */
        s1 = MyAlloc(strlen(szInFile) + 4 + 1);
        strcpy(s1, szInFile);
        szInFile = s1;
        strcat(szInFile, ".RES");
        if ((fhBin = _open( szInFile, O_RDONLY|O_BINARY )) == -1) {
            pehdr();
            printf("Cannot open %s for reading.\n", szInFile);
            exit(1);
        }
#if DBG
	printf("Reading %s\n", szInFile);
#endif /* DBG */
    }

    if (fhBin != -1) {
	lbytes = MySeek(fhBin, 0L, SEEK_END);
	MySeek(fhBin, 0L, SEEK_SET);
    }

    if (szExeFile == NULL) {
        /*
         * Make exefile = infile.exe
         */
        szExeFile = MyAlloc(strlen(szInFile) + 4 + 1);
        strcpy(szExeFile, szInFile);
        s1 = &szExeFile[strlen(szExeFile) - 4];
        if (s1 < szExeFile)
            s1 = szExeFile;
        while (*s1) {
            if (*s1 == '.')
                break;
            s1++;
        }
        strcpy(s1, ".exe");
    }

    if (szOutFile == NULL) {
        /*
         * Make outfile = infile.exe
         */
        szOutFile = MyAlloc(strlen(szInFile) + 4 + 1);
        strcpy(szOutFile, szInFile);
        s1 = &szOutFile[strlen(szOutFile) - 4];
        if (s1 < szOutFile)
            s1 = szOutFile;
        while (*s1) {
            if (*s1 == '.')
                break;
            s1++;
        }
        strcpy(s1, ".exe");
    }
    else {
        /*
         * Make outfile = copyof(exefile)
         */
        if (CopyFile(szExeFile, szOutFile, FALSE) == FALSE) {
            pehdr();
            printf("RW1001: copy of %s to %s failed", szExeFile, szOutFile);
            _close(fhBin);
            exit(1);
        }
	SetFileAttributes(szOutFile, FILE_ATTRIBUTE_NORMAL);
    }

#if DBG
    printf("Writing %s\n", szOutFile);
#endif /* DBG */

    hupd = BeginUpdateResourceA(szOutFile, fReplace);
    if (hupd == NULL) {
        pehdr();
        printf("RW1001: unable to load %s\n", szOutFile);
        _close(fhBin);
        exit(1);
    }
    if (fDelete) {
	result = UpdateResourceA(hupd,
			idType!=0?(PCHAR)idType:szType,
			idName!=0?(PCHAR)idName:szName,
			idLang, NULL, 0);
	if (result == 0) {
	    pehdr();
	    if (idType) {
		if (idName)
		    printf("RW1004: unable to delete resource %d,%d,%x from %s, status:%d\n", idType, idName, idLang, szExeFile, GetLastError());
		else
		    printf("RW1004: unable to delete resource %d,%s,%x from %s, status:%d\n", idType, szName, idLang, szExeFile, GetLastError());
	    }
	    else {
		if (idName)
		    printf("RW1004: unable to delete resource %s,%d,%x from %s, status:%d\n", szType, idName, idLang, szExeFile, GetLastError());
		else
		    printf("RW1004: unable to delete resource %s,%s,%x from %s, status:%d\n", szType, szName, idLang, szExeFile, GetLastError());
	    }
            _close(fhBin);
	    exit(1);
	}
    }
    else {
	result = ReadRes(fhBin, lbytes, hupd);
	if (result == 0) {
	    pehdr();
	    printf("RW1002: unable to read resources from %s, status:%d\n", szInFile, GetLastError());
            _close(fhBin);
	    exit(1);
	}
    }
    result = EndUpdateResourceW(hupd, FALSE);
    if (result == 0) {
        pehdr();
        printf("RW1003: unable to write resources to %s, status:%d\n", szOutFile, GetLastError());
    }

    _close( fhBin );
    exit(result ? 0 : 1);
}


UCHAR*
MyAlloc(ULONG nbytes )
{
    UCHAR       *s;

    if ((s = (UCHAR*)calloc( 1, nbytes )) != NULL)
        return s;
    else {
        pehdr();
        printf( "Memory allocation, needed %u bytes\n", nbytes );
        exit(1);
    }
}


ULONG
MyRead(int fh, UCHAR*p, ULONG n )
{
    USHORT      n1;

    if ((n1 = _read( fh, p, n )) != n) {
        eprintf( "a file read error occured" );
        exit(1);
    }
    else
        return 0;
}


LONG
MySeek( int fh, long pos, int cmd )
{
    if ((pos = _lseek( fh, pos, cmd )) == -1) {
        eprintf( "seek error" );
        exit(1);
    }

    return pos;
}


ULONG
MoveFilePos( int fh, ULONG pos )
{
    return MySeek( fh, pos, SEEK_SET );
}


void
eprintf(
    UCHAR *s
    )
{
    pehdr();
    printf("%s.\n", s);
}

void
pehdr(
    )
{
    printf("RESONEXE: error - ");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\resonexe\read.c ===
/****************************************************************************/
/*                                                                          */
/*  READ.C -                                                                */
/*                                                                          */
/*    Windows DOS Version 3.2 add resource onto executable		    */
/*   (C) Copyright Microsoft Corporation 1988-1992                          */
/*                                                                          */
/*                                                                          */
/****************************************************************************/

#include <windows.h>

#include <stdlib.h>

#include "rc.h"
#include "resonexe.h"

//
// Reads a String structure from fhIn
// If the first word is 0xffff then this is an ID
// return the ID instead
//

BOOL
ReadStringOrID(
    IN int	fhIn,
    IN WCHAR	*s,
    OUT WORD	*pOrdinal
    )
{
    USHORT	cb;
    WCHAR	*pwch;

    pwch = s;
    *pwch = 0;
    *pOrdinal = 0;
    MyRead(fhIn, (PUCHAR)s, sizeof(WORD));

    if ( *s == ID_WORD) {

        //
        // an ID
        //

        MyRead(fhIn, (PUCHAR)pOrdinal, sizeof(WORD));
        return IS_ID;

    }
    else {

        //
        // a string
        //

        while (*s) {
              s++;
              MyRead(fhIn, (PUCHAR)s, sizeof(WCHAR));
        }

        *(s+1) = 0;
        cb = s - pwch;
        return IS_STRING;
    }

}

CHAR	*pTypeName[] = {
		    NULL,		/* 0 */
		    "CURSOR",		/* 1 */
		    "BITMAP",		/* 2 */
		    "ICON",		/* 3 */
		    "MENU",		/* 4 */
		    "DIALOG",		/* 5 */
		    "STRING",		/* 6 */
		    "FONTDIR",		/* 7 */
		    "FONT",		/* 8 */
		    "ACCELERATOR",	/* 9 */
		    "RCDATA",		/* 10 */
		    "MESSAGETABLE",	/* 11 */
		    "GROUP_CURSOR",	/* 12 */
		    NULL,		/* 13 */
		    "GROUP_ICON",	/* 14 */
		    NULL,		/* 15 */
		    "VERSION",		/* 16 */
		    "DLGINCLUDE"	/* 17 */
		    };


BOOL
ReadRes(
    IN int fhIn,
    IN ULONG cbInFile,
    IN HANDLE hupd
    )

/*++

Routine Description:


Arguments:

    fhIn - Supplies input file handle.
    fhOut - Supplies output file handle.
    cbInFile - Supplies size of input file.

Return Value:

    fSuccess

--*/

{
    WCHAR	type[256];
    WCHAR	name[256];
    WORD	typeord;
    WORD	nameord;
    ULONG	offHere;     // input file offset
    RESADDITIONAL	Additional;
    UCHAR	Buffer[1024];
    PVOID	pdata;

    //
    // Build up Type and Name directories
    //

    offHere = 0;
    while (offHere < cbInFile) {
	//
	// Get the sizes from the file
	//

	MyRead(fhIn, (PUCHAR)&Additional.DataSize, sizeof(ULONG));
	MyRead(fhIn, (PUCHAR)&Additional.HeaderSize, sizeof(ULONG));
	if (Additional.DataSize == 0) {
	    offHere = MySeek(fhIn, Additional.HeaderSize-2*sizeof(ULONG), SEEK_CUR);
	    continue;
	}

	//
	// Read the TYPE and NAME
	//
        ReadStringOrID(fhIn, type, &typeord);
        ReadStringOrID(fhIn, name, &nameord);
        offHere = MySeek(fhIn, 0, SEEK_CUR);
        while (offHere & 3)
            offHere = MySeek(fhIn, 1, SEEK_CUR);

	//
	// Read the rest of the header
	//
	MyRead(fhIn, (PUCHAR)&Additional.DataVersion,
		sizeof(RESADDITIONAL)-2*sizeof(ULONG));

        //
        // if were converting a win30 resource and this is
        // a name table then discard it
        //

        if (fVerbose)  {
            if ( typeord == 0) {
                printf("Adding resource - Type:%S, ", type);
            }
	    else {
		if (typeord <= 17)
		    printf("Adding resource - Type:%s, ", pTypeName[typeord]);
		else
		    printf("Adding resource - Type:%d, ", typeord);
            }

            if ( nameord == 0 ) {
                printf("Name:%S, ", name);
            }
	    else {
                printf("Name:%d, ", nameord);
            }

            printf("Size:%ld\n", Additional.DataSize);
        }
        pdata = (PVOID)MyAlloc(Additional.DataSize);
        MyRead(fhIn, pdata, Additional.DataSize);

        if (typeord == 0) {
            if (nameord == 0) {
                UpdateResourceW(hupd, type, name,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
            }
            else {
                UpdateResourceW(hupd, type, (LPWSTR)nameord,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
	    }
        }
        else {
            if (nameord == 0) {
                UpdateResourceW(hupd, (LPWSTR)typeord, name,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
            }
            else {
                UpdateResourceW(hupd, (LPWSTR)typeord, (LPWSTR)nameord,
				Additional.LanguageId,
			        pdata, Additional.DataSize);
	    }
        }

        offHere = MySeek(fhIn, 0, SEEK_CUR);
        while (offHere & 3)
            offHere = MySeek(fhIn, 1, SEEK_CUR);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\resonexe\test\test.c ===
int main (char**argv, int argc) { return 1;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\resonexe\resonexe.h ===
/*++

(C) Copyright Microsoft Corporation 1988-1992

Module Name:

    resonexe.h

Author:

    Floyd A Rogers 2/7/92

Revision History:

    2/7/92 floydr
        Created
--*/

#include <common.h>

/*  Global externs */

extern PUCHAR   szInFile;
extern BOOL     fDebug;
extern BOOL     fVerbose;
extern BOOL     fUnicode;

/* functions in main.c */

void    __cdecl main(int argc, char *argv[]);
PUCHAR  MyAlloc( ULONG nbytes );
PUCHAR  MyReAlloc(char *p, ULONG nbytes );
PUCHAR  MyFree( PUCHAR  );
ULONG   MyRead( int fh, PUCHAR p, ULONG n );
LONG    MyTell( int fh );
LONG    MySeek( int fh, long pos, int cmd );
ULONG   MoveFilePos( int fh, ULONG pos);
ULONG   MyWrite( int fh, PUCHAR p, ULONG n );
void    eprintf( PUCHAR s);
void    pehdr(void);
int     fcopy (char *, char *);

/* functions in read.c */

BOOL
ReadRes(
    IN int fhIn,
    IN ULONG cbInFile,
    IN HANDLE hupd
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\main.h ===
#ifndef __MAIN_H__
#define __MAIN_H__

#include <afx.h>
#include <iodll.h>

///////////////////////////////////////////////////////////////////////////////
// From RLMan
// Token flag Masks

#define ISPOPUP         0x0001
#define ISCOR	        0x0010
#define ISDUP	        0x0020
#define ISCAP	        0x0040
#define ISDLGFONTCHARSET 0x0002
#define ISDLGFONTNAME   0x0004
#define ISDLGFONTSIZE   0x0008
#define ISALIGN         0x0080
#define ISEXTSTYLE      0x0200

#define OLD_POPUP_ID	0x0100

#define ISKEY	        0x0010
#define ISVAL	        0x0020

// status bits
#define ST_TRANSLATED   4
#define ST_READONLY     2
#define ST_NEW	        1
#define ST_DIRTY        1
#define ST_CHANGED      4

#define MAX_STR_SIZE    8192    // Max Len of a string passed to WriteCon
#define MAX_BUF_SIZE    8192    // Max ResItem Buffer size

// Console flags
#define CONOUT          0        // Used with WriteCon to send the message to stdout
#define CONERR          1        // Used with WriteCon to send the message to stderr
#define CONBOTH         2        // Used with WriteCon to send the message to stderr and stdout if not the same handle
#define CONWRN          3        // Used with WriteCon to send the message to stderr only if WARNING enabled

class CMainApp
{
public:
    // Error codes
    enum Error_Codes
    {
        ERR_NOERROR           =  0x00000000,  //
        ERR_COMMAND_LINE      =  0x00000001,  // Wrong command line
        ERR_TOKEN_MISMATCH    =  0x00000002,  // Token file don't match
        ERR_TOKEN_WRONGFORMAT =  0x00000004,  // Token file are not in the right format
        ERR_FILE_OPEN         =  0x00000100,  // Cannot open the file
        ERR_FILE_COPY         =  0x00000200,  // Cannot copy the file
        ERR_FILE_CREATE       =  0x00000400,  // Cannot create the file
        ERR_FILE_NOTSUPP      =  0x00000800,  // This file type is not supported
        ERR_FILE_NOTFOUND     =  0x00001000,  // The file doesn't exist
        ERR_FILE_VERSTAMPONLY =  0x00002000,  // The file has only version stamping
        ERR_HELP_CHOOSE       =  0x00004000   // The user want to see the help file
    };

    // Options Flags
    enum Option_Codes
    {
        NO_OPTION   = 0x00000000,  //  Initializer
        WARNING     = 0x00000001,  //  -w                  (Show warning messages)
        HELP        = 0x00000002,  //  -? or -h            (Show more complete help using winhelp)
        APPEND      = 0x00000004,  //  -a                  (Append resources in localized tokens)
        REPLACE     = 0x00000008,  //  -r                  (Replace resources in localized tokens, no checking)
        EXTRACT     = 0x00000010,  //  -t                  (Extract token file)
        BITMAPS     = 0x00000020,  //  -b                  (Extract bitmaps and icons)
        SPLIT       = 0x00000040,  //  -s                  (Split the message table)
        NOLOGO      = 0x00000080,  //  -n                  (Nologo)
        UPDATE      = 0x00000100,  //  -u                  (Update the resources in localized file)
        FONTS       = 0x00000200,  //  -f                  (Font information for dialog)
        PIPED       = 0x00001000,  //  We have being piped to a file
        INPUT_LANG  = 0x00002000,  //  -i                  (Input language resources set)
        OUTPUT_LANG = 0x00004000,  //  -o                  (Output language resources set)
        LEANAPPEND   = 0x00010000,   //  -l                (Do not append redudant resources)
        ALIGNMENT   = 0x00020000,  //  -y                  (Extract static control alignment style info)
        GIFHTMLINF  = 0x00040000,  //  -c                  (Extract embedded gifs, htmls and infs)
        NOVERSION   = 0x00080000   //  -v                  (Do not generate selected version stamp information)
    };

#if 0
    enum Return_Codes
    {
        RET_NOERROR           =  0x00000000,  //
        RET_ID_NOTFOUND       =  0x00000001,  // An Id was not found
        RET_CNTX_CHANGED      =  0x00000002,  // Contex changed
        RET_RESIZED           =  0x00000004,  // item resized
        RET_INVALID_TOKEN     =  0x00000008,  // The token file is not valid
        RET_TOKEN_REMOVED     =  0x00000010,  // some token were removed
        RET_TOKEN_MISMATCH    =  0x00000020,  // The token mismatch
        RET_IODLL_ERROR       =  0x00000040,  // There is an error in IO
        RET_IODLL_WARNING     =  0x00000080,  // There is an warning in IO
        RET_FILE_VERSTAMPONLY =  0x00000100,  // File has only version stamping
        RET_FILE_NORESOURCE   =  0x00000200,  // File has no resource
        RET_FILE_MULTILANG    =  0x00000400,  // File has multiple language
        RET_IODLL_CHKMISMATCH =  0x00000800,  // Symbool checksum mismatch
        RET_FILE_CUSTOMRES    =  0x00001000,  // Contains custom resource.
        RET_IODLL_NOSYMBOL    =  0x00002000,  // Symbol file not found
        RET_FILE_NOSYMPATH    =  0x00004000   // Output symbol path not found.
    };
#endif

public:
    // Constructor
    CMainApp();
    ~CMainApp();

    // Operations
    Error_Codes ParseCommandLine(int argc, char ** argv);
    Error_Codes GenerateFile();

    void Banner();
    void Help();

    BOOL IsFlag(Option_Codes dwFlag)
        { return ((m_dwFlags & dwFlag)==dwFlag); }

    int  __cdecl WriteCon(int iFlags, const char * lpstr, ...);

    void AddNotFound()
        { m_wIDNotFound++; SetReturn(ERROR_RET_ID_NOTFOUND); }
    void AddChanged()
        { m_wCntxChanged++; SetReturn(ERROR_RET_CNTX_CHANGED); }
    void AddResized()
        { m_wResized++; SetReturn(ERROR_RET_RESIZED); }

    int ReturnCode()
        { return m_dwReturn; }

    // Language support
    WORD GetOutLang()
        { return ( MAKELANGID(m_usOPriLangId, m_usOSubLangId) ); }

    int SetReturn(int rc);
    int IoDllError(int iError);
    UINT GetUICodePage()
        { return m_uiCodePage; }

private:
    // Attributes
    Option_Codes m_dwFlags;        // Command line parameters
    int m_dwReturn;       // Return codes

    // Console Handles
    HANDLE m_StdOutput;
    HANDLE m_StdError;

    // String Buffers
    CString m_strBuffer1;
    CString m_strBuffer2;
    BYTE *  m_pBuf;

    // File Names
    CString m_strInExe;
    CString m_strOutExe;
    CString m_strSrcTok;
    CString m_strTgtTok;

    // Symbol Path Name
    CString m_strSymPath;
    CString m_strOutputSymPath;

    SHORT  m_usIPriLangId;     // Primary language ID for the input file
    SHORT  m_usISubLangId;     // Secondary language ID for the input file

    SHORT  m_usOPriLangId;     // Primary language ID for the output file
    SHORT  m_usOSubLangId;     // Secondary language ID for the output file

    UINT   m_uiCodePage;       // Code page to use during conversion
    char   m_unmappedChar;     // Default for unmappable characters

    // report counters
    WORD    m_wIDNotFound;
    WORD    m_wCntxChanged;
    WORD    m_wResized;

    // Helper operators
    CString CalcTab(CString str, int tablen, char ch);
    USHORT  GetLangID(CString strNum);
    UINT    GetCodePage(CString strNum);
    LPCSTR  Format(CString strTmp);
    LPCSTR  UnFormat(CString strTmp);

    // Member functions
    Error_Codes BinGen();
    Error_Codes TokGen();
    Error_Codes DelRes();
};

/////////////////////////////////////////////////////////////////////////
// This is needed to make sure that the operator |= will work fine on the
// enumerated type Option_Codes
inline CMainApp::Option_Codes operator|=( CMainApp::Option_Codes &oc, int i )
    { return oc = (CMainApp::Option_Codes)(oc | i); }

#if 0
inline CMainApp::Error_Codes operator|=( CMainApp::Error_Codes &rc, int i )
    { return rc = (CMainApp::Return_Codes)(rc | i); }
#endif

#pragma pack(1)
typedef struct iconHeader
{
    WORD idReserved;
    WORD idType;
    WORD idCount;
    BYTE bWidth;
    BYTE bHeight;
    BYTE bColorCount;
    BYTE bReserved;
    WORD wPlanes;
    WORD wBitCount;
    DWORD dwBytesInRes;
    DWORD dwImageOffset;
} ICONHEADER;
#pragma pack(8)

#endif // __MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\token.h ===
#ifndef __TOKEN_H__
#define __TOKEN_H__

#include <afx.h>

class CToken: public CObject
{
friend class CTokenFile;
public:
    // Constructor
    CToken();

    int Parse(CString strSrc, CString strTgt);

    CString GetTgtText()
        { return m_strTgtText; }
    CString GetSrcText()
        { return m_strSrcText; }

    unsigned int GetFlags()
        { return m_uiFlags;    }

    BOOL GetTgtSize(WORD *, WORD *, WORD *, WORD *);
    BOOL GetSrcSize(WORD *, WORD *, WORD *, WORD *);

    int GetLastError()
        { return m_uiLastError; }

    CString GetTokenID()
        { return m_strTokenID; }

protected:
    unsigned int    m_uiTypeID;
    unsigned int    m_uiResID;
    unsigned int    m_uiItemID;
    unsigned int    m_uiFlags;
    unsigned int    m_uiStatusFlags;
    unsigned int    m_uiLastError;
    CString         m_strItemName;
    CString         m_strSrcText;
    CString         m_strTgtText;
    CString         m_strTokenID;

};

class CTokenFile
{
public:
    CTokenFile();
    ~CTokenFile();

    // Operators
    int Open(CString strSrcFile, CString strTgtFile);

    const CToken * GetToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strText,
                      CString strItemName = "");

    const CToken * GetNoCaptionToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName = "");

    // Overload GetTokenSize since some item have no text but change in size
    const CToken * GetTokenSize(CToken * pToken, WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy);
    const CToken * CTokenFile::GetTokenSize(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName,
                      WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy);

    int GetTokenNumber()
        { return (int)m_Tokens.GetSize(); }


private:
    CObArray  m_Tokens;
    INT_PTR   m_iLastPos;
    INT_PTR   m_iUpperBound;

    CString m_strSrcFile;
    CString m_strTgtFile;
};

#endif // __TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\main.cpp ===
//////////////////////////////////////////////////////////////////////////
//
// This application will generate a localized binary given in input
// a source binary and two token files.
//
// The format of the token file is:
// [[TYPE ID|RES ID|Item ID|Flags|Status Flags|Item Name]]=
// this is the standar format used by several token file tools in MS.
//
///////////////////////////////////////////////////////////////////////////////
//
// Other DLL used: IODLL.DLL
//
///////////////////////////////////////////////////////////////////////////////
//
// Author: 	Alessandro Muti
// Date:	01-16-95
//
///////////////////////////////////////////////////////////////////////////////

#include <afx.h>

#include "main.h"
#include <iodll.h>
#include <winuser.h>
#include <ntverp.h>

//////////////////////////////////////////////////////////////////////////
#define BANNER   "Microsoft (R) 32-bit RLTools Version 3.5 (Build %d)\r\n"                     \
                 "Copyright (C) Microsoft Corp. 1991-1998. All Rights reserved.\r\n"\
                 "\r\n"                                                             \
                 "Binary file generator utility.\r\n\r\n"

#ifdef _DEBUG
#define BUILDSTAMP "Build:  " __DATE__ " " __TIME__ " ("  __TIMESTAMP__  ")\r\n\r\n"
#endif

// Need to split the help screen in two since it is too long.
// The good thing to do would be to put this string in a message table
// To be done...
char strHelp0[] =                                                                   \
"BINGEN [-w|n] [-h|?] [-b|s|f] [-p cp] [-{i|o} Pri Sub] [-d char]              \r\n"\
"       [-{t|u|r|a|x} files]                                                   \r\n"\
"                                                                              \r\n"\
"  -w                  (Show warning messages)                                 \r\n"\
"  -? or -h            (Show more complete help using winhelp)                 \r\n"\
"  -b                  (Extract bitmaps and icons)                             \r\n"\
"  -c                  (Extract embedded gifs, htmls, infs and other binaries) \r\n"\
"  -y                  (Extract Static Control alignment style)                \r\n"\
"  -l                  (Lean mode and do not append redundant resources)       \r\n"\
"  -s                  (Split Message table messages at \\n\\r)                \r\n"\
"  -f                  (Add/Use font information field for dialogs)            \r\n"\
"  -n                  (Nologo)                                                \r\n"\
"  -v                  (Ignore selected version stamp information)             \r\n"\
"  -p  CodePage        (Default code page of text in project token file)       \r\n"\
"  -d  Character       (Default for unmappable characters)                     \r\n"\
"                                                                              \r\n"\
"<<The commands -{t|r|a} are mutually exlusive>>                               \r\n"\
"  -t  InputExeFile  OutputTokenFile                                           \r\n"\
"                      (Extract token file)                                    \r\n"\
"  -u  InputExeFile  InputUSTokFile  InputLOCTokFile  OutputExeFile            \r\n"\
"                      (Replace old lang resources with localized tokens)      \r\n"\
"  -r  InputExeFile  InputLOCTokFile  OutputExeFile                            \r\n"\
"                      (Replace old lang resources with localized tokens)      \r\n"\
"                      (Doesn't perform any consistency check)                 \r\n"\
"  -a  InputExeFile  InputLOCTokFile  OutputExeFile                            \r\n"\
"                      (Append resources in localized tokens)                  \r\n"\
"                                                                              \r\n";
char strHelp1[] =                                                                   \
"<<Default language is always NEUTRAL>>                                        \r\n"\
"  -i  PriLangId SecLangId (Primary- and Sub-Lang IDs, dec/hex, Input file)    \r\n"\
"  -o  PriLangId SecLangId (Primary- and Sub-Lang IDs, dec/hex, Output file)   \r\n"\
"                                                                              \r\n"\
"  -x  InputRuleFile   (Pseudo translation options)                            \r\n"\
"  -m  InputSymbolPath OutputSymbolPath                                        \
                       (Update symbol checksum if neccesory)                   \r\n";

//////////////////////////////////////////////////////////////////////////

CMainApp::CMainApp()
{
    m_dwFlags = NO_OPTION;
    m_dwReturn = ERROR_NO_ERROR;

    m_StdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
    m_StdError = GetStdHandle(STD_ERROR_HANDLE);

    // Check if we have being piped to a file
    BY_HANDLE_FILE_INFORMATION HndlFileInfo;
    if(GetFileInformationByHandle(m_StdOutput, &HndlFileInfo) ||
       GetFileInformationByHandle(m_StdError, &HndlFileInfo))
        m_dwFlags |= PIPED;

    m_strBuffer1 = "";
    m_strBuffer2 = "";

    m_pBuf = new BYTE[MAX_BUF_SIZE];

    m_wIDNotFound = 0;
    m_wCntxChanged = 0;
    m_wResized = 0;

    //
    // Set default values for Language
    //

    m_usIPriLangId = -1;
    m_usISubLangId = -1;

    m_usOPriLangId = -1;
    m_usOSubLangId = -1;

    m_uiCodePage = GetACP();

    m_unmappedChar = '?';
    m_strSymPath = "";
    m_strOutputSymPath = "";
}

CMainApp::~CMainApp()
{
    if(m_pBuf)
        delete m_pBuf;
}

//////////////////////////////////////////////////////////////////////////

CMainApp::Error_Codes CMainApp::ParseCommandLine(int argc, char ** argv)
{
    char * pArgument;
    int count = 0;

    if(argc==1)
        m_dwFlags |= HELP;

    while(++count<argc)
    {
        pArgument = argv[count];
        if(*pArgument=='/' || *pArgument=='-')
        {
            while(*(++pArgument))
            {
                switch(*pArgument)
                {
                    case 'a':   // Append resources
                    case 'A':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(REPLACE) | IsFlag(UPDATE) | IsFlag(EXTRACT))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -a without the -r, -u or -t option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option

                        for(int c=1; c<=3; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -a option\r\n"\
                                                 "  -a  InputExeFile  InputLOCTokFile  OutputExeFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= APPEND;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];

                        // Get the output EXE file name
                        m_strOutExe = argv[++count];
                    }
                    break;
                    case 'b':
                    case 'B':
                        m_dwFlags |= BITMAPS;
                    break;
                    case 'd':
                    case 'D':   // Default  for unmappable characters
                        m_unmappedChar = argv[++count][0];
                    break;
                    case 'f':
                    case 'F':
                        m_dwFlags |= FONTS;
                    break;
                    case 'c':
                    case 'C':
                        m_dwFlags |= GIFHTMLINF;
                    break;
                    case '?':   // Help
                    case 'h':
                    case 'H':
                        m_dwFlags |= HELP;
                    break;
                    case 'i':   // Input language/sublanguage
                    case 'I':
                        m_dwFlags |= INPUT_LANG;
                        m_usIPriLangId = GetLangID(argv[++count]);
                        m_usISubLangId = GetLangID(argv[++count]);
                    break;
                    case 'l':
                    case 'L':
                    {
                        m_dwFlags |= LEANAPPEND;
                    break;
                    }
                    case 'm':
                    case 'M':
                    {
                        for(int c=1; c<=2; c++)
                        {
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Please specify Input and Output Symbol Paths.\r\n");
                                return ERR_COMMAND_LINE;
                            }
                        }
                        m_strSymPath = argv[++count];
                        m_strOutputSymPath = argv[++count];
                    }
                    break;
                    case 'n':
                    case 'N':
                        m_dwFlags |= NOLOGO;
                    break;
                    case 'o':   // Output language/sublanguage
                    case 'O':
                        m_dwFlags |= OUTPUT_LANG;
                        m_usOPriLangId = GetLangID(argv[++count]);
                        m_usOSubLangId = GetLangID(argv[++count]);
                    break;
                    case 'p':   // Code page
                    case 'P':
                        m_uiCodePage = GetCodePage(argv[++count]);
                    break;
                    case 'r':   // Replace resources
                    case 'R':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(APPEND) | IsFlag(EXTRACT) | IsFlag(UPDATE))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -r without the -a, -u or -t option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option
                        for(int c=1; c<=3; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -r option\r\n"\
                                                 "  -r  InputExeFile  InputLOCTokFile  OutputExeFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= REPLACE;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];

                        // Get the output EXE file name
                        m_strOutExe = argv[++count];
                    }
                    break;
                    case 'u':   // Update resources
                    break;
                    case 's':
                    case 'S':
                        m_dwFlags |= SPLIT;
                    break;
                    case 't':   // Create token file
                    case 'T':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(APPEND) | IsFlag(REPLACE) | IsFlag(UPDATE))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -t without the -a, -u, or -r option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option
                        for(int c=1; c<=2; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -t option\r\n"\
                                                 "  -t  InputExeFile  OutputTokenFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= EXTRACT;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];
                    }
                    break;
                    case 'U':
                    {
                        //Make sure no other conflicting flags are specified
                        if(IsFlag(APPEND) | IsFlag(EXTRACT) | IsFlag(REPLACE))
                        {
                            Banner();
                            WriteCon(CONERR, "Please use -u without the -a, -r or -t option!");
                            return ERR_COMMAND_LINE;
                        }

                        // Make sure none of the next item is another option
                        for(int c=1; c<=4; c++)
                            if(argv[count+c]==NULL || *argv[count+c]=='/' || *argv[count+c]=='-')
                            {
                                Banner();
                                WriteCon(CONERR, "Not enough parameters specified for the -u option\r\n"\
                                                 "  -u  InputExeFile  InputUSTokFile  InputLOCTokFile  OutputExeFile\r\n");
                                return ERR_COMMAND_LINE;
                            };

                        m_dwFlags |= UPDATE;

                        // Get the input EXE file name
                        m_strInExe = argv[++count];

                        // Get the source token file name
                        m_strSrcTok = argv[++count];

                        // Get the target token file name
                        m_strTgtTok = argv[++count];

                        // Get the output EXE file name
                        m_strOutExe = argv[++count];
                    }
                    break;
                    case 'v':   // Display warnings
                    case 'V':
                        m_dwFlags |= NOVERSION;
                    break;
                    case 'w':   // Display warnings
                    case 'W':
                        m_dwFlags |= WARNING;
                    break;
                    case 'y':
                    case 'Y':
                        m_dwFlags |= ALIGNMENT;
                    break;
                    default:
                    break;
                }
            }
        }
    }
    // Do we want the banner
    if(!IsFlag(NOLOGO))
        Banner();
	
    // Before exiting make sure we display the help screen if requested
    if(IsFlag(HELP))
    {
        Help();
        return ERR_HELP_CHOOSE;
    }

    // Check if the code page we have is installed in this system
    if(!IsValidCodePage(m_uiCodePage))
    {
        // Warn the user and get back the default CP
        m_uiCodePage = GetACP();
        WriteCon(CONERR, "The code page specified is not installed in the system or is invalid! Using system default!\r\n");
    }

    // Make sure the input file is there
    CFileStatus fs;
    if(!m_strInExe.IsEmpty())
    {
        if(!CFile::GetStatus(m_strInExe, fs))
        {
            WriteCon(CONERR, "File not found: %s\r\n", m_strInExe);
            return ERR_FILE_NOTFOUND;
        }
    }

    // Check if the tgt token file or exe are read only
    if(!m_strOutExe.IsEmpty())
    {
        if(CFile::GetStatus(m_strOutExe, fs))
        {
            if((fs.m_attribute & 0x1)==0x1)
            {
                WriteCon(CONERR, "File is read only: %s\r\n", m_strOutExe);
                return ERR_FILE_CREATE;
            }
        }
    }

    if(!m_strTgtTok.IsEmpty() && IsFlag(EXTRACT))
    {
        if(CFile::GetStatus(m_strTgtTok, fs))
        {
            if((fs.m_attribute & 0x1)==0x1)
            {
                WriteCon(CONERR, "File is read only: %s\r\n", m_strTgtTok);
                return ERR_FILE_CREATE;
            }
        }
    }

    //
    // Check the value specified for the output language.
    // If none has been specified, warn the user and default to neutral.
    //
    if(IsFlag(APPEND) | IsFlag(REPLACE))
    {
        if(m_usOPriLangId==-1)
        {
            m_usOPriLangId = LANG_NEUTRAL; // set the PRI language ID to neutral
            WriteCon(CONERR, "Output language ID not specified, default to neutral(%d)\r\n", m_usOPriLangId);
        }

        if(m_usOSubLangId==-1)
        {
            m_usOSubLangId = SUBLANG_NEUTRAL; // set the SEC language ID to neutral
            WriteCon(CONERR, "Output sub-language ID not specified, default to neutral(%d)\r\n", m_usOSubLangId);
        }
    }

    WriteCon(CONWRN, "Code Page              : %d\r\n", m_uiCodePage);
    WriteCon(CONWRN, "In  Primary Language   : %d (%d)\r\n", m_usIPriLangId, MAKELANGID(m_usIPriLangId,m_usISubLangId));
    WriteCon(CONWRN, "In  Secondary Language : %d (0x%x)\r\n", m_usISubLangId, MAKELANGID(m_usIPriLangId,m_usISubLangId));
    WriteCon(CONWRN, "Out Primary Language   : %d (%d)\r\n", m_usOPriLangId, MAKELANGID(m_usOPriLangId,m_usOSubLangId));
    WriteCon(CONWRN, "Out Secondary Language : %d (0x%x)\r\n", m_usOSubLangId, MAKELANGID(m_usOPriLangId,m_usOSubLangId));
    WriteCon(CONWRN, "Default unmapped char  : %c \r\n", m_unmappedChar);

    return ERR_NOERROR;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper start

void CMainApp::Banner()
{
    WriteCon(CONOUT, BANNER, VER_PRODUCTBUILD);
    #ifdef _DEBUG
        WriteCon(CONOUT, BUILDSTAMP);
    #endif
}

void CMainApp::Help()
{
    WriteCon(CONOUT, strHelp0);
    WriteCon(CONOUT, strHelp1);
}

CString CMainApp::CalcTab(CString str, int tablen, char ch)
{
    for(int i = tablen-str.GetLength();i>0;i--)
        str += (char)ch;

    return str.GetBuffer(0);
}

int __cdecl CMainApp::WriteCon(int iFlags, const char * lpstr, ...)
{
    DWORD dwWritten;

    va_list ptr;

    va_start(ptr, lpstr);
    _vsnprintf(m_strBuffer1.GetBuffer(MAX_STR_SIZE), MAX_STR_SIZE, lpstr, ptr);

    m_strBuffer1.ReleaseBuffer();

    // Check if we want to have the handle sent to both out and err
    if((iFlags==CONBOTH) && (IsFlag(PIPED)))
    {
        WriteFile(m_StdError, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
        WriteFile(m_StdOutput, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
        return dwWritten;
    }

    if((iFlags==CONWRN))
    {
        if(IsFlag(WARNING))
            WriteFile(m_StdError, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
        return dwWritten;
    }

    if(iFlags==CONERR)
        WriteFile(m_StdError, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);
    else
        WriteFile(m_StdOutput, m_strBuffer1, m_strBuffer1.GetLength(), &dwWritten, NULL);

    return dwWritten;
}

int CMainApp::SetReturn(int rc)
        { return (m_dwReturn = rc); }

////////////////////////////////////////////////
// Will convert the string strNum in to a short
USHORT CMainApp::GetLangID(CString strNum)
{
    strNum.MakeUpper();
    // If is there is any of this char "ABCDEFX" assume is an hex number
    return LOWORD(strtol(strNum, NULL, ((strNum.FindOneOf("ABCDEFX")!=-1) ? 16:10)));
}

UINT CMainApp::GetCodePage(CString strNum)
{
    strNum.MakeUpper();
    // If is there is any of this char "ABCDEFX" assume is an hex number
    return strtol(strNum, NULL, ((strNum.FindOneOf("ABCDEFX")!=-1) ? 16:10));
}

#ifdef NOSLASH
LPCSTR CMainApp::Format(CString strTmp)
{
    int iPos;
    char * pStr = strTmp.GetBuffer(0);
    char * pStrStart = pStr;
    int i = 0;

    m_strBuffer2 = strTmp;

    while((pStr = strchr(pStr, '\\')))
    {
        iPos = pStr++ - pStrStart + i++;
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\\\" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);
    }

    while((iPos = m_strBuffer2.Find('\t'))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\t" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);

    while((iPos = m_strBuffer2.Find('\n'))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\n" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);

    while((iPos = m_strBuffer2.Find('\r'))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\r" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-1);

    return m_strBuffer2;
}

LPCSTR CMainApp::UnFormat(CString strTmp)
{
    int iPos;
    char * pStr = strTmp.GetBuffer(0);
    char * pStrStart = pStr;
    int i = 0;

    m_strBuffer2 = strTmp;

    while((pStr = strstr(pStr, "\\\\")))
    {
        iPos = pStr - pStrStart - i++; pStr += 2;
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\\" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);
    }

    while((iPos = m_strBuffer2.Find("\\t"))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\t" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);

    while((iPos = m_strBuffer2.Find("\\n"))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\n" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);

    while((iPos = m_strBuffer2.Find("\\r"))!=-1)
        m_strBuffer2 = m_strBuffer2.Left(iPos) + "\r" + m_strBuffer2.Right(m_strBuffer2.GetLength()-iPos-2);

    return m_strBuffer2;
}
#endif

LPCSTR CMainApp::Format(CString strTmp)
{
    char * pStr = strTmp.GetBuffer(0);
    char * pDest = m_strBuffer2.GetBuffer(MAX_STR_SIZE);
    char * pNext;


    while(*pStr)
    {
        if(!IsDBCSLeadByteEx(m_uiCodePage, *pStr))
        {
            switch(*pStr)
            {
                case '\\':
                    *pDest++ = '\\';
                    *pDest++ = '\\';
                    break;
                case '\t':
                    *pDest++ = '\\';
                    *pDest++ = 't';
                    break;
                case '\r':
                    *pDest++ = '\\';
                    *pDest++ = 'r';
                    break;
                case '\n':
                    *pDest++ = '\\';
                    *pDest++ = 'n';
                    break;
                default:
                    *pDest++ = *pStr;
                    break;
            }
        }
        else {
            memcpy( pDest, pStr, 2 );
            pDest += 2;
        }

        pStr = CharNextExA((WORD)m_uiCodePage, pStr, 0);
    }

    *pDest = '\0';

    m_strBuffer2.ReleaseBuffer(-1);

    return m_strBuffer2;
}

LPCSTR CMainApp::UnFormat(CString strTmp)
{
    m_strBuffer2 = strTmp;

    int i = m_strBuffer2.GetLength();
    char * pStr = m_strBuffer2.GetBuffer(0);
    char * pNext;


    while(*pStr)
    {
        if(*pStr=='\\' && !IsDBCSLeadByteEx(m_uiCodePage, *pStr))
        {
            pNext = CharNextExA((WORD)m_uiCodePage, pStr, 0);
            switch(*pNext)
            {
                case '\\':
                    *pStr = '\\';
                    break;
                case 't':
                    *pStr = '\t';
                    break;
                case 'n':
                    *pStr = '\n';
                    break;
                case 'r':
                    *pStr = '\r';
                    break;
                default:
                    break;
            }

            pStr = pNext;
            pNext = CharNextExA((WORD)m_uiCodePage, pNext, 0);
            memmove(pStr, pNext, --i);

        }
        else
        {
            //DBCS shorten length by 2
            if (IsDBCSLeadByteEx(m_uiCodePage, *pStr))
                i-=2;
            else
                i--;
            pStr = CharNextExA((WORD)m_uiCodePage, pStr, 0);
        }
    }

    m_strBuffer2.ReleaseBuffer(-1);

    return m_strBuffer2;
}


int CMainApp::IoDllError(int iError)
{
    CString str = "";

    switch (iError) {
    case 0:                                                                     break;
    case ERROR_HANDLE_INVALID:          str = "Invalid handle.";                break;
    case ERROR_READING_INI:             str = "Error reading WIN.INI file.";    break;
    case ERROR_NEW_FAILED:              str = "Running low on memory.";         break;
    case ERROR_FILE_OPEN:               str = "Error opening file.";            break;
    case ERROR_FILE_CREATE:             str = "Error creating file.";           break;
    case ERROR_FILE_INVALID_OFFSET:     str = "File corruption detected.";      break;
    case ERROR_FILE_READ:               str = "Error reading file.";            break;
    case ERROR_DLL_LOAD:                str = "Error loading R/W DLL.";         break;
    case ERROR_DLL_PROC_ADDRESS:        str = "Error loading R/W procedure.";   break;
    case ERROR_RW_LOADIMAGE:            str = "Error loading R/W image.";       break;
    case ERROR_RW_PARSEIMAGE:           str = "Error parsing R/W image.";       break;
    case ERROR_RW_NOTREADY:             str = "Error:  R/W not ready?";         break;
    case ERROR_RW_BUFFER_TOO_SMALL:     str = "Running low on memory?";         break;
    case ERROR_RW_INVALID_FILE:         str = "Invalid R/W file.";              break;
    case ERROR_RW_IMAGE_TOO_BIG:        str = "Can't load HUGE image.";         break;
    case ERROR_RW_TOO_MANY_LEVELS:      str = "Resource directory too deep.";   break;
    case ERROR_RW_NO_RESOURCES:         str = "This file contains no resources.";
break;
    case ERROR_IO_INVALIDITEM:          str = "Invalid resource item.";         break;
    case ERROR_IO_INVALIDID:            str = "Invalid resource ID.";           break;
    case ERROR_IO_INVALID_DLL:          str = "Unrecognized file format.";      break;
    case ERROR_IO_TYPE_NOT_SUPPORTED:   str = "Type not supported.";            break;
    case ERROR_IO_INVALIDMODULE:        str = "Invalid module.";                break;
    case ERROR_IO_RESINFO_NULL:         str = "ResInfo is NULL?";               break;
    case ERROR_IO_UPDATEIMAGE:          str = "Error updating image.";          break;
    case ERROR_IO_FILE_NOT_SUPPORTED:   str = "File not supported.";            break;
    case ERROR_IO_CHECKSUM_MISMATCH:    str = "Symbol file checksum mismatch.";
break;
    case ERROR_IO_SYMBOLFILE_NOT_FOUND: str = "Symbol file not found.";
break;
    case ERROR_FILE_SYMPATH_NOT_FOUND:  str = "Output symbol path not found.";
break;
    case ERROR_RW_VXD_MSGPAGE:
        str  = "The specified VxD file contains a message page as its";
        str += " last page.  This may cause the VxD not to work.  Please";
        str += " inform the development team of the problem with this file.";
        break;
    case ERROR_OUT_OF_DISKSPACE:        str = "Out of disk space.";             break;
    case ERROR_RES_NOT_FOUND:           str = "Resource not found.";            break;

    default:
        if(iError-LAST_ERROR>0)
        {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
        			NULL,
        			iError-LAST_ERROR,
        			MAKELANGID(LANG_NEUTRAL,LANG_NEUTRAL),
        			str.GetBuffer(1024),
        			1024,
           			NULL);
            str.ReleaseBuffer();
        }
    break;
    }

    if (!str.IsEmpty())
    {
        WriteCon(CONERR, "%s: %s\r\n", (iError < LAST_WRN) ? "IODLL Warning" : "IODLL Error", str);
        SetReturn(iError);
    }

    return iError;
}

// Helper end
/////////////////////////////////////////////////////////////////////////////////////////////////////

CMainApp::Error_Codes CMainApp::GenerateFile()
{
    Error_Codes bRet;

    // Before we procede let's give the global info to the IODLL
    SETTINGS settings;

    settings.cp = m_uiCodePage;
    settings.bAppend = IsFlag(APPEND);
    settings.bUpdOtherResLang = TRUE;  //we save this option for future
    settings.szDefChar[0] = m_unmappedChar; settings.szDefChar[1] = '\0';
    RSSetGlobals(settings);

    // Here we decide what is the action we have to take
    if(IsFlag(EXTRACT))
    {
        // we want to generate a token file
        bRet = TokGen();
    }
    else if(IsFlag(APPEND) | IsFlag(REPLACE) | IsFlag(UPDATE) )
    {
        // we want to generate a binary
        bRet = BinGen();
    }

    return bRet;
}

// Main application
CMainApp theApp;

//////////////////////////////////////////////////////////////////////////
int _cdecl main(int argc, char** argv)
{
    if(theApp.ParseCommandLine(argc, argv)){
        return theApp.ReturnCode();
    }

    theApp.GenerateFile();
    return theApp.ReturnCode();
}
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\bingen.cpp ===
//////////////////////////////////////////////////////////////////////////
//
// The format of the token file is:
// [[TYPE ID|RES ID|Item ID|Flags|Status Flags|Item Name]]=
// this is the standar format used by several token file tools in MS.
//
///////////////////////////////////////////////////////////////////////////////
//
// Author: 	Alessandro Muti
// Date:	12/02/94
//
///////////////////////////////////////////////////////////////////////////////


#include <afx.h>
#include "iodll.h"
#include "main.h"
#include "token.h"
#include "vktbl.h"
#include "imagehlp.h"

extern CMainApp theApp;

/*******************************************************\
 This is the part were the real code starts.
 The function Bingen generate a binary from a token file.
 If the user select the -u options then we perform a
 token checking otherwise we'll be compatible with RLMAN
 and just trust the ID.
\*******************************************************/

CMainApp::Error_Codes CMainApp::BinGen()
{
    Error_Codes iErr = ERR_NOERROR;
    CTokenFile m_tokenfile;
    CToken * pToken;

    iErr = (CMainApp::Error_Codes)m_tokenfile.Open(m_strSrcTok, m_strTgtTok);

    if(iErr) {
        return iErr;
    }

    WriteCon(CONERR, "%s\r\n", CalcTab("", 79, '-'));

    // Copy the Src binary over the target
    // Now we can go and open an handle to the SrcExe file
    HANDLE hModule = RSOpenModule(m_strInExe, NULL);
    if ((int)(UINT_PTR)hModule < LAST_ERROR) {
            // error or warning
            WriteCon(CONERR, "%s", CalcTab(m_strInExe, m_strInExe.GetLength()+5, ' '));
            IoDllError((int)(UINT_PTR)hModule);
            return ERR_FILE_NOTSUPP;
    } else {
        LPCSTR lpszType = 0L;
        LPCSTR lpszRes = 0L;
        DWORD  dwLang = 0L;
        DWORD  dwItem = 0L;
        DWORD  dwItemId;
        LPRESITEM lpResItem = NULL;
        CString strResName = "";

        BOOL bSkip;
		BOOL bSkipLang = FALSE;
        WORD wCount = 0;

        CString strFaceName;
        WORD    wPointSize;
        BYTE    bCharSet;

        // before we do anything else we have to check how many languages we have in the file
        CString strLang;
        char szLang[8];
        BOOL b_multi_lang = FALSE;
        USHORT usInputLang = MAKELANGID(m_usIPriLangId, m_usISubLangId);

        if((b_multi_lang = RSLanguages(hModule, strLang.GetBuffer(1024))) && !IsFlag(INPUT_LANG))
        {
            // this is a multiple language file but we don't have an input language specified
            // Fail, but warn the user that he has to set the input language to continue.
            strLang.ReleaseBuffer();
            theApp.SetReturn(ERROR_FILE_MULTILANG);
            WriteCon(CONERR, "Multiple language file. Please specify an input language %s.\r\n", strLang);
            goto exit;
        }

        strLang.ReleaseBuffer();

        // Convert the language in to the hex value
        if (usInputLang)
            sprintf(szLang,"0x%3X", usInputLang);
        else
            sprintf(szLang,"0x000");

        // Check if the input language that we got is a valid one
        if(IsFlag(INPUT_LANG) && strLang.Find(szLang)==-1)
        {
            WriteCon(CONERR, "The language %s in not a valid language for this file.\r\n", szLang);
            WriteCon(CONERR, "Valid languages are: %s.\r\n", strLang);
            theApp.SetReturn(ERROR_RES_NOT_FOUND);
            goto exit;
        }

        CString strFileName = m_strInExe;
        CString strFileType;
        CString strTokenDir = "";
        int pos = m_strInExe.ReverseFind('\\');
        if(pos!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }
        else
        if((pos = m_strInExe.ReverseFind(':'))!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }

        pos = m_strTgtTok.ReverseFind('\\');
        if(pos==-1)
            pos = m_strTgtTok.ReverseFind(':');

        if(pos!=-1)
            strTokenDir = m_strTgtTok.Left(pos+1);

        if (m_strSymPath[0] && m_strSymPath != m_strOutputSymPath)
        {
            CString strInDebugFile;
            CString strOutDebugFile;

            HANDLE hDebugFile = FindDebugInfoFile(
                                    strFileName.GetBuffer(MAX_PATH),
                                    m_strSymPath.GetBuffer(MAX_PATH),
                                    strInDebugFile.GetBuffer(MAX_PATH)
                                    );
            strInDebugFile.ReleaseBuffer();
            if ( hDebugFile == NULL ) {
                return (Error_Codes)IoDllError(ERROR_IO_SYMBOLFILE_NOT_FOUND);
            }
            CloseHandle(hDebugFile);

            strOutDebugFile = m_strOutputSymPath + strInDebugFile.Right(strInDebugFile.GetLength()-m_strSymPath.GetLength());

            if (!CopyFile(strInDebugFile.GetBuffer(MAX_PATH), strOutDebugFile.GetBuffer(MAX_PATH),FALSE))
            {
                CString strTmp;
                strTmp = strOutDebugFile.Left(strOutDebugFile.GetLength()-strFileName.GetLength()-1);

                CreateDirectory(strTmp.GetBuffer(MAX_PATH),NULL);

                if (!CopyFile(strInDebugFile.GetBuffer(MAX_PATH), strOutDebugFile.GetBuffer(MAX_PATH),FALSE))
                {
                    return (Error_Codes)IoDllError(ERROR_FILE_SYMPATH_NOT_FOUND);
                }
            }
        }

        WriteCon(CONOUT, "Processing\t");
        WriteCon(CONBOTH, "%s", CalcTab(strFileName, strFileName.GetLength()+5, ' '));
        RSFileType(m_strInExe, strFileType.GetBuffer(10));
        strFileType.ReleaseBuffer();
        WriteCon(CONBOTH, "%s", CalcTab(strFileType, strFileType.GetLength()+5, ' '));
        if(IsFlag(WARNING))
            WriteCon(CONBOTH, "\r\n");

        while ((lpszType = RSEnumResType(hModule, lpszType)))
        {
            // Check if is one of the type we care about
            if(HIWORD(lpszType)==0)
                switch(LOWORD(lpszType))
                {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 14:
                    case 16:
                    case 23:
                    case 240:
                    case 1024:
                    case 2110:
                        bSkip = FALSE;
                        break;
                    default:
                        bSkip = TRUE;
                }
            else
                bSkip = FALSE;

            lpszRes = 0L;
            dwLang = 0L;
            dwItem = 0L;
            CString strText;
            int iTokenErr = 0;

            while ((!bSkip) && (lpszRes = RSEnumResId(hModule, lpszType, lpszRes))) {
                while ((dwLang = RSEnumResLang(hModule, lpszType, lpszRes, dwLang))) {

					// Check if we have to skip this language
                    if(b_multi_lang && (LOWORD(dwLang)!=usInputLang))
                        bSkipLang = TRUE;
                    else
                        bSkipLang = FALSE;


					while ((!bSkipLang) && (dwItem = RSEnumResItemId(hModule, lpszType, lpszRes, dwLang, dwItem))) {

                        // Now Get the Data
                        DWORD dwImageSize = RSGetResItemData( hModule,
                                              lpszType,
                                              lpszRes,
                                              dwLang,
                                              dwItem,
                                              m_pBuf,
                                              MAX_BUF_SIZE );

                        lpResItem = (LPRESITEM)m_pBuf;

                        if(((wCount++ % 50)==0) && !(IsFlag(WARNING)))
                            WriteCon(CONOUT, ".");

                        if (HIWORD(lpszType))
                        {
                            if (lstrcmp (lpszType,"REGINST") == 0)
                            {
                                //
                                // Currently there is no id for REGINST defined
                                // in nt.  We just use this 2200 for now.
                                //
                                lpResItem->dwTypeID = 2200;
                            }
                        }

                        lpResItem->dwLanguage = theApp.GetOutLang();

                        // Version stamp use class name as res id
                        if(lpResItem->lpszResID)
                            strResName = lpResItem->lpszResID;
                        else strResName = "";

                        if(lpResItem->dwTypeID==16)
                        {
                            strResName = lpResItem->lpszClassName;
                        }

                        switch(LOWORD(lpResItem->dwTypeID))
                        {
                            case 4:
                                {

                                    if(!(lpResItem->dwFlags & MF_POPUP))
                                        dwItemId = (LOWORD(lpResItem->dwItemID)==0xffff ? HIWORD(lpResItem->dwItemID) : lpResItem->dwItemID);
                                    else dwItemId = lpResItem->dwItemID;
                                }
                            break;
                            case 5:
                                dwItemId = (LOWORD(lpResItem->dwItemID)==0xffff ? HIWORD(lpResItem->dwItemID) : lpResItem->dwItemID);
                            break;
                            case 11:
                                dwItemId = LOWORD(lpResItem->dwItemID);
                            break;
                            default:
                                dwItemId = lpResItem->dwItemID;
                        }

                        if (lpResItem->dwTypeID==1 || lpResItem->dwTypeID==12
                           || lpResItem->dwTypeID==14)
                        {
                            // if user don't want to append redundant cursors,
                            // bitmaps, and icons, we make it NULL
                            if (IsFlag(LEANAPPEND) && IsFlag(APPEND)){
                             dwImageSize=0;
                             RSUpdateResImage(hModule,lpszType,lpszRes,dwLang,0,lpResItem,dwImageSize);
                            }
                            continue;
                        }

                        // Is this a bitmap?
                        if(lpResItem->dwTypeID==2
                           || lpResItem->dwTypeID==3
                           || lpResItem->dwTypeID==23
                           || lpResItem->dwTypeID== 240
                           || lpResItem->dwTypeID== 1024
                           || lpResItem->dwTypeID== 2110
                           || lpResItem->dwTypeID== 2200)
                        {

                            if (IsFlag(LEANAPPEND)
                                && IsFlag(APPEND)
                                && (lpResItem->dwTypeID == 2
                                || lpResItem->dwTypeID == 3))
                            {
                                dwImageSize=0;
                                RSUpdateResImage(hModule,lpszType,lpszRes,dwLang,0,lpResItem,dwImageSize);
                                continue;
                            }
                            // Search for a token with this ID
                            pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemId,
                                strResName);

                            if(pToken!=NULL)
                            {
                                // Get the name of the input image
                                strText = pToken->GetTgtText();

                                // Open the file
                                CFile inputFile;
                                if(!inputFile.Open(strText,
                                                   CFile::modeRead |
                                                   CFile::shareDenyNone |
                                                   CFile::typeBinary ) &&
                                   !inputFile.Open(strTokenDir + strText,
                                                   CFile::modeRead |
                                                   CFile::shareDenyNone |
                                                   CFile::typeBinary))
                                {
                                    WriteCon(CONERR, "Input file %s not found! Using Src file data!\r\n", strTokenDir+strText);
                                    goto skip;
                                }

                                DWORD dwSize = inputFile.GetLength();
                                BYTE * pInputBuf = (BYTE*)new BYTE[dwSize];

                                if(pInputBuf==NULL)
                                {
                                    WriteCon(CONERR, "Error allocating memory for the image! (%d)\r\n", dwSize);
                                    goto skip;
                                }

                                BYTE * pInputBufOrigin = pInputBuf;

                                inputFile.ReadHuge(pInputBuf, inputFile.GetLength());

                                CString strTmp = pToken->GetTokenID();
                                WriteCon(CONWRN, "Using image in file %s for ID %s\"]]!\r\n", strText.GetBuffer(0), strTmp.GetBuffer(0));

                                BYTE * pInputImage=(BYTE *) new BYTE[dwSize];
                                DWORD dwImageSize;
                                // remove the header from the file
                                switch(lpResItem->dwTypeID)
                                {
                                    case 2:
                                    {
                                        dwImageSize = dwSize - sizeof(BITMAPFILEHEADER);
                                        pInputBuf += sizeof(BITMAPFILEHEADER);
                                    }
                                    break;
                                    case 3:
                                    {
                                        dwImageSize = dwSize - sizeof(ICONHEADER);
                                        pInputBuf += sizeof(ICONHEADER);
                                    }
                                    case 23:
                                    case 240:
                                    case 1024:
                                    case 2110:
                                    case 2200:
                                    {
                                        dwImageSize = dwSize;
                                    }
                                    break;

                                    default:
                                    break;
                                }

                                memcpy(pInputImage, pInputBuf, dwImageSize);
                                //
                                //  We need to keep output lang info seperately,
                                //  because we dont't have lpResItem to send
                                //  the info to io for icons and bitmaps.
                                //
                                DWORD dwUpdLang = theApp.GetOutLang();

                                // Update the resource
                                RSUpdateResImage(hModule,lpszType,lpszRes,dwLang,dwUpdLang, pInputImage,dwImageSize);

                                delete pInputBufOrigin;
                                delete pInputImage;
                            }
                            else
                            {
                                goto skip;
                            }
                        }
                        // is this an accelerator
                        else if(lpResItem->dwTypeID==9)
                        {
                            // Search for a token with this ID
                            pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemId,
                                strResName);

                            if(pToken!=NULL)
                            {
                                CAccel acc(pToken->GetTgtText());

                                if( (lpResItem->dwFlags & 0x80)==0x80 )
                                    lpResItem->dwFlags = acc.GetFlags() | 0x80;
                                else
                                    lpResItem->dwFlags = acc.GetFlags();

                                lpResItem->dwStyle = acc.GetEvent();

                                if(IoDllError(RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE)))
                                {
                                    // we have an error, warn the user
                                    WriteCon(CONWRN, "Error updating token\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                    lpResItem->dwTypeID,
                                                    lpResItem->dwResID,
                                                    dwItemId,
                                                    0,
                                                    4,
                                                    strResName);
                                    AddNotFound();
                                }
                            }
                        }
                        else
                        {
                            // Search for a token with this ID
                            pToken = (CToken *)m_tokenfile.GetToken(lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemId,
                                Format(lpResItem->lpszCaption),
                                strResName);
                        }

                        if(pToken!=NULL) {
                            iTokenErr = pToken->GetLastError();
                            if(pToken->GetFlags() & ISEXTSTYLE){
                                CString strStyle= pToken->GetTgtText();
                                lpResItem->dwExtStyle = strtol(strStyle, (char**)0,16);
                                // Get the real Token
                                pToken = (CToken *)m_tokenfile.GetToken(lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemId,
                                    Format(lpResItem->lpszCaption),
                                    strResName);

                                if(pToken!=NULL)
                                    wCount++;
                            }

                            // Check if is a dialog font name
                            if(pToken != NULL &&
                               ((pToken->GetFlags() & ISDLGFONTNAME) ||
                               (pToken->GetFlags() & ISDLGFONTSIZE)))
                            {
                                if(theApp.IsFlag(CMainApp::FONTS))
                                {
                                    int iColon;
                                    CString strTgtFaceName = pToken->GetTgtText();

                                    // This should be the font description token
                                    if( strTgtFaceName.IsEmpty() || ((iColon = strTgtFaceName.Find(':'))==-1) )
                                        WriteCon(CONWRN, "Using Src file FaceName for ID %s\"]]!\r\n", pToken->GetTokenID());

                                    // Check if the dialog has the DS_SETFONT flag set, otherwise let the user
                                    // know that we can't do much with his font description
                                    if( (lpResItem->dwStyle & DS_SETFONT)!=DS_SETFONT )
                                       WriteCon(CONWRN, "Dialog ID %s\"]] is missing the DS_SETFONT bit. Cannot change font!\r\n", pToken->GetTokenID());
                                    else
                                    {
                                        strFaceName = strTgtFaceName.Left(iColon);
                                        strFaceName.TrimRight();
                                        strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                        strTgtFaceName.TrimLeft();
                                        //sscanf( strTgtFaceName, "%d", &wPointSize );
                                            if ((iColon=strTgtFaceName.Find(':'))!=-1) {
                                                wPointSize=(WORD)atoi(strTgtFaceName.Left(iColon));
                                                strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                                bCharSet = (BYTE)atoi(strTgtFaceName);
                                                lpResItem->bCharSet = bCharSet;
                                            }else{
                                                wPointSize=(WORD)atoi(strTgtFaceName);
                                            }

                                            lpResItem->lpszFaceName = strFaceName.GetBuffer(0);
                                            lpResItem->wPointSize = wPointSize;

                                        strFaceName.ReleaseBuffer();
                                    }
                                }

                                // Get the real Token
                                pToken = (CToken *)m_tokenfile.GetToken(lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemId,
                                    Format(lpResItem->lpszCaption),
                                    strResName);

                                if(pToken!=NULL)
                                    wCount++;
                            }
                        }

                        if(pToken!=NULL && !pToken->GetLastError())
                        {
                            strText = UnFormat(pToken->GetTgtText());
                            if(m_tokenfile.GetTokenSize(pToken, &lpResItem->wX, &lpResItem->wY,
                                &lpResItem->wcX, &lpResItem->wcY))
                                wCount++;

                            lpResItem->lpszCaption = strText.GetBuffer(0);

                            // Static control and style flag is set.  We need
                            // to take style alignment change as well
                            if (LOBYTE(lpResItem->wClassName) == 0x82 &&
                                theApp.IsFlag(CMainApp::ALIGNMENT))
                            {
                                //Get style alignment token
                                pToken = (CToken *)m_tokenfile.GetToken(
                                    lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemId,
                                    Format(lpResItem->lpszCaption),
                                    strResName);

                                if (pToken!=NULL)
                                {
                                    wCount++;

                                    CString strStyle=pToken->GetTgtText();

                                    if (strStyle=="SS_CENTER")
                                        lpResItem->dwStyle |= SS_CENTER;

                                    else if (strStyle=="SS_RIGHT")
                                    {
                                        //reset the alignment bit
                                        lpResItem->dwStyle &= 0xfffffffc;
                                        lpResItem->dwStyle |= SS_RIGHT;
                                    }
                                    else if (strStyle=="SS_LEFT")
                                        lpResItem->dwStyle &= 0xfffffffc;

                                    else
                                        //use provided style is wrong. warn!
                                        WriteCon(CONWRN, "Using Src file alignment style for ID %s\"]]!\r\n", pToken->GetTokenID());
                                }
                            }


                            if(IoDllError(RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE)))
                            {
                                // we have an error, warn the user
                                WriteCon(CONWRN, "Error updating token\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                AddNotFound();
                            }
                            strText.ReleaseBuffer();
                        }
                        else
                        {
                             pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                 lpResItem->dwResID,
                                 dwItemId,
                                 strResName);

                             if(pToken!=NULL)
                             {
                                if(pToken->GetFlags() & ISEXTSTYLE){

                                    CString strStyle= pToken->GetTgtText();
                                    lpResItem->dwExtStyle = strtol(strStyle, (char**)0,16);
                                    // Get the real Token
                                    pToken = (CToken *)m_tokenfile.GetNoCaptionToken(lpResItem->dwTypeID,
                                        lpResItem->dwResID,
                                        dwItemId,
                                        strResName);

                                    if(pToken!=NULL)
                                        wCount++;
                                }

                                // Check if is a dialog font name
                                if(pToken != NULL &&
                                   ((pToken->GetFlags() & ISDLGFONTNAME) ||
                                    (pToken->GetFlags() & ISDLGFONTSIZE)))
                                {
                                    if(theApp.IsFlag(CMainApp::FONTS))
                                    {
                                        int iColon;
                                        CString strTgtFaceName = pToken->GetTgtText();

                                        // This should be the font description token
                                        if( strTgtFaceName.IsEmpty() || ((iColon = strTgtFaceName.Find(':'))==-1) )
                                            WriteCon(CONWRN, "Using Src file FaceName for ID %s\"]]!\r\n", pToken->GetTokenID());

                                        // Check if the dialog has the DS_SETFONT flag set, otherwise let the user
                                        // know that we can't do much with his font description
                                        if( (lpResItem->dwStyle & DS_SETFONT)!=DS_SETFONT )
                                            WriteCon(CONWRN, "Dialog ID %s\"]] is missing the DS_SETFONT bit. Cannot change font!\r\n", pToken->GetTokenID());
                                        else
                                        {
                                            strFaceName = strTgtFaceName.Left(iColon);
                                            strFaceName.TrimRight();
                                            strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                            strTgtFaceName.TrimLeft();
                                           // sscanf( strTgtFaceName, "%d", &wPointSize );
                                            if ((iColon=strTgtFaceName.Find(':'))!=-1){
                                                wPointSize=(WORD)atoi(strTgtFaceName.Left(iColon));
                                                strTgtFaceName = strTgtFaceName.Right(strTgtFaceName.GetLength() - iColon-1);
                                                bCharSet = (BYTE)atoi(strTgtFaceName);
                                                lpResItem->bCharSet = bCharSet;
                                            }else{
                                                wPointSize=(WORD)atoi(strTgtFaceName);
                                            }

                                            lpResItem->lpszFaceName = strFaceName.GetBuffer(0);
                                            lpResItem->wPointSize = wPointSize;
                                            strFaceName.ReleaseBuffer();
                                        }
                                    }
                                    if(m_tokenfile.GetTokenSize(pToken, &lpResItem->wX, &lpResItem->wY,
                                            &lpResItem->wcX, &lpResItem->wcY))
                                        wCount++;
                                }
                                // Check if is a dialog size
                                else if(pToken->GetFlags() & ISCOR)
                                {
                                    pToken->GetTgtSize(&lpResItem->wX, &lpResItem->wY,
                                            &lpResItem->wcX, &lpResItem->wcY);
                                }

                                // Just size and/or font updated
                                if(IoDllError(RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE)))
                                {
                                    // we have an error, warn the user
                                    WriteCon(CONWRN, "Error updating token\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                    lpResItem->dwTypeID,
                                                    lpResItem->dwResID,
                                                    dwItemId,
                                                    0,
                                                    4,
                                                    strResName);
                                    AddNotFound();
                                }
                            }
                            else
                            {
                                switch(LOWORD(lpszType))
                                {
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 10:
                                    case 11:
                                        // No Token was found for this ID
                                        // Leave it for now but here will come the
                                        // PSEUDO Translation code.
                                        if(strlen(lpResItem->lpszCaption) && !iTokenErr)
                                        {
                                            WriteCon(CONWRN, "ID not found\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                            AddNotFound();
                                        }
                                        break;
                                    case 9:
                                        WriteCon(CONWRN, "ID not found\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                        AddNotFound();
                                        break;
                                        break;
                                    case 16:
                                        if (theApp.IsFlag(CMainApp::NOVERSION) &&
                                            (strResName==TEXT("FileVersion") ||
                                            strResName==TEXT("ProductVersion") ||
                                            strResName==TEXT("Platform"))){
                                            //
                                            // do nothing
                                            //
                                        }else if(strlen(lpResItem->lpszCaption)                                                  && !iTokenErr){
                                            WriteCon(CONWRN, "ID not found\t[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]\r\n",
                                                lpResItem->dwTypeID,
                                                lpResItem->dwResID,
                                                dwItemId,
                                                0,
                                                4,
                                                strResName);
                                            AddNotFound();
                                        }
                                        break;

                                    default:
                                    break;
                                }

                                // Let's update the item anyway, since the language might have changed
                                // RSUpdateResItemData(hModule,lpszType,lpszRes,dwLang,dwItem,lpResItem,MAX_BUF_SIZE);
                            }
                        }
skip:;
                    }
                }
            }
        }
        iErr=(Error_Codes)IoDllError(RSWriteResFile(hModule, m_strOutExe, NULL,m_strOutputSymPath));

        if ((int)iErr > 0){
            //WriteCon(CONERR, "%s", CalcTab(m_strOutExe, m_strOutExe.GetLength()+5, ' '));
            goto exit;
        }

        WriteCon(CONBOTH, " %hu(%hu) Items\r\n", wCount, m_wIDNotFound);

        // Check if some items were removed from the file
        if(wCount<m_tokenfile.GetTokenNumber() ||
           m_wIDNotFound ||
           m_wCntxChanged ||
           m_wResized)
            WriteCon(CONWRN, "%s\tToken: ", CalcTab(strFileName, strFileName.GetLength()+5, ' '));

        if(wCount<m_tokenfile.GetTokenNumber())
        {
            SetReturn(ERROR_RET_RESIZED);
            WriteCon(CONWRN, "Removed %d ", m_tokenfile.GetTokenNumber()-wCount);
        }

        if(m_wIDNotFound)
            WriteCon(CONWRN, "Not Found %d ", m_wIDNotFound);

        if(m_wCntxChanged)
            WriteCon(CONWRN, "Contex Changed %d ", m_wCntxChanged);

        if(m_wResized)
            WriteCon(CONWRN, "Resize Changed %d ", m_wResized);

        if(wCount<m_tokenfile.GetTokenNumber() ||
           m_wIDNotFound ||
           m_wCntxChanged ||
           m_wResized)
            WriteCon(CONWRN, "\r\n");
    }

exit:
    RSCloseModule(hModule);

    return iErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\tokgen.cpp ===
//////////////////////////////////////////////////////////////////////////
//
// The format of the token file is:
// [[TYPE ID|RES ID|Item ID|Flags|Status Flags|Item Name]]=
// this is the standar format used by several token file tools in MS.
//
///////////////////////////////////////////////////////////////////////////////
//
// Author: 	Alessandro Muti
// Date:	12/02/94
//
///////////////////////////////////////////////////////////////////////////////


#include <afx.h>
#include "iodll.h"
#include "main.h"
#include "vktbl.h"

extern CMainApp theApp;

#define RECURSIVE   0x10
#define WARNINGS    0x20

///////////////////////////////////////////////////////////////////////////////
CString CreateName(CString & strTokenName, CString strExt, int iID)
{
    CString strOutputName = strTokenName;
    int iNamePos = strTokenName.ReverseFind('\\');
    if(iNamePos!=-1) {
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    } else if(iNamePos = strTokenName.ReverseFind(':')!=-1){
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    }

    CString strID = "";
    // subst with ID name
    _itoa(iID++, strID.GetBuffer(10), 10);
    strID.ReleaseBuffer(-1);

    // Check the length of the name
    iNamePos = strOutputName.Find('.');
    if(iNamePos!=-1)
        strOutputName.SetAt(iNamePos, '_');

    strOutputName = strOutputName + "_" + strID + strExt;
    return strOutputName;
}

CString CreateName(CString & strTokenName, CString strExt, CString strIdName)
{
    CString strOutputName = strTokenName;
    int iNamePos = strTokenName.ReverseFind('\\');
    if(iNamePos!=-1) {
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    } else if(iNamePos = strTokenName.ReverseFind(':')!=-1){
        strOutputName = strTokenName.Right(strTokenName.GetLength()-iNamePos-1);
    }

    iNamePos = strOutputName.Find('.');
    if(iNamePos!=-1)
        strOutputName.SetAt(iNamePos, '_');

    iNamePos = strIdName.Find(':');
    if (iNamePos!=-1)
        strIdName.SetAt(iNamePos, '_');

    iNamePos = strIdName.Find('\\');
    if (iNamePos!=-1)
        strIdName.SetAt(iNamePos, '_');

    strOutputName = strOutputName + "_" + strIdName + strExt;
    return strOutputName;
}

///////////////////////////////////////////////////////////////////////////////
// This function will parse the source file and create the token file
CMainApp::Error_Codes CMainApp::TokGen()
{
    Error_Codes ReturnErr = ERR_NOERROR;

    WriteCon(CONERR, "%s\r\n", CalcTab("", 79, '-'));

    // Open the iodll.dll using the first file name
    HANDLE hModule = RSOpenModule(m_strInExe, NULL);
    if ((int)(INT_PTR)hModule < LAST_ERROR) {
            // error or warning
            WriteCon(CONERR, "%s", CalcTab(m_strInExe, m_strInExe.GetLength()+5, ' '));
            IoDllError((int)(INT_PTR)hModule);
            return ERR_FILE_NOTSUPP;
    } else {
        // before we do anything else we have to check how many languages we have in the file
        CString strLang;
        char szLang[8];
        BOOL b_multi_lang = FALSE;
        USHORT usInputLang = MAKELANGID(m_usIPriLangId, m_usISubLangId);

        if((b_multi_lang = RSLanguages(hModule, strLang.GetBuffer(1024))) && !IsFlag(INPUT_LANG))
        {
            // this is a multiple language file but we don't have an input language specified
            // Fail, but warn the user that he has to set the input language to continue.
            strLang.ReleaseBuffer();
            WriteCon(CONERR, "Multiple language file. Please specify an input language %s.\r\n", strLang);
            theApp.SetReturn(ERROR_FILE_MULTILANG);
            goto exit;
        }

        // Convert the language in to the hex value
        sprintf(szLang,"0x%3.3X", usInputLang);

        // Check if the input language that we got is a valid one
        if(IsFlag(INPUT_LANG) && strLang.Find(szLang)==-1)
        {
            WriteCon(CONERR, "The language %s in not a valid language for this file.\r\n", szLang);
            WriteCon(CONERR, "Valid languages are: %s.\r\n", strLang);
            theApp.SetReturn(ERROR_RES_NOT_FOUND);
            goto exit;
        }

        // Check if the user is extracting the neutral language
        if(!usInputLang)
            usInputLang = 0xFFFF;

        // Open the output file
        CStdioFile fileOut;
        if(!fileOut.Open(m_strTgtTok, CFile::modeCreate | CFile::modeReadWrite)) {
            WriteCon(CONERR, "Cannot create file: %s\r\n", CalcTab(m_strTgtTok, m_strTgtTok.GetLength()+5, ' '));
            return ERR_FILE_CREATE;
        }

        CString strOutputDir = "";
        CString strFileName = m_strInExe;
        int pos = m_strInExe.ReverseFind('\\');
        if(pos!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }
        else
        if((pos = m_strInExe.ReverseFind(':'))!=-1)
        {
            strFileName = m_strInExe.Right(m_strInExe.GetLength()-pos-1);
        }

        pos = m_strTgtTok.ReverseFind('\\');
        if(pos!=-1)
        {
            strOutputDir = m_strTgtTok.Left(pos+1);
        }
        else
        if((pos = m_strTgtTok.ReverseFind(':'))!=-1)
        {
            strOutputDir = m_strTgtTok.Left(pos+1);
        }

        // inform the user ...
        WriteCon(CONOUT, "Processing\t");
        WriteCon(CONBOTH, "%s", CalcTab(strFileName, strFileName.GetLength()+5, ' '));

        if (IsFlag(WARNING))
            WriteCon(CONOUT, "\r\n");

		LPCSTR lpszType = 0L;
        LPCSTR lpszRes = 0L;
        DWORD  dwLang = 0L;
        DWORD  dwItem = 0L;
        DWORD  dwItemID = 0L;
        LPRESITEM lpResItem = NULL;

        CString strToken;
        CString strResName;
        CString strCaption;
        WORD wFlag;
        BOOL bSkip = FALSE;
        BOOL bSkipEmpty = FALSE;
        BOOL bSkipLang = FALSE;
        WORD wCount = 0;

        WORD wMsgCount = 0;
        int iPos = 1;
        int iBmpIdCount = 0;

        BOOL bVersionStampOnly = TRUE;
        BOOL bCustomResource = FALSE;

        while ((lpszType = RSEnumResType(hModule, lpszType))) {

            // Check if is one of the type we care about
            if(HIWORD(lpszType)==0)
            {
                switch(LOWORD(lpszType))
                {
                    case 2:
                    case 3:
                        if(theApp.IsFlag(CMainApp::BITMAPS))
                            bSkip = FALSE;
                        else bSkip = TRUE;
                    break;
                    case 4:
                    case 5:
                    case 6:
                    case 11:
                        bVersionStampOnly = FALSE;
                    case 9:
                    case 10:
                    case 16:
                        bSkip = FALSE;
                        break;
                    case 23:
                    case 240:
                    case 1024:
                    case 2110:
                        if(theApp.IsFlag(CMainApp::GIFHTMLINF))
                             bSkip = FALSE;
                        else
                             bSkip = TRUE;
                        bVersionStampOnly = FALSE;
                        bCustomResource = TRUE;
                        break;
                    default:
                        bSkip = TRUE;
                }
            }
            else
            {
                if (lstrcmp (lpszType, "REGINST") == 0)
                {
                   if(theApp.IsFlag(CMainApp::GIFHTMLINF))
                        bSkip = FALSE;
                   else
                        bSkip = TRUE;
                   bCustomResource = TRUE;
                }
                else
                {
                    bSkip = FALSE;
                }
                bVersionStampOnly = FALSE;
            }

            lpszRes = 0L;
            dwLang = 0L;
            dwItem = 0L;

            while ((!bSkip) && (lpszRes = RSEnumResId(hModule, lpszType, lpszRes))) {
                while ((dwLang = RSEnumResLang(hModule, lpszType, lpszRes, dwLang))) {

                    // Check if we have to skip this language
                    if(b_multi_lang && (LOWORD(dwLang)!=usInputLang))
                        bSkipLang = TRUE;
                    else
                        bSkipLang = FALSE;

                    while ((!bSkipLang) && (dwItem = RSEnumResItemId(hModule, lpszType, lpszRes, dwLang, dwItem))) {

                    // Now Get the Data
                    DWORD dwImageSize = RSGetResItemData( hModule,
											  lpszType,
											  lpszRes,
											  dwLang,
											  dwItem,
											  m_pBuf,
											  MAX_BUF_SIZE );
											
				    lpResItem = (LPRESITEM)m_pBuf;

                    if((wCount++ % 50)==0 && !(IsFlag(WARNING)))
                        WriteCon(CONOUT, ".");


                    if (HIWORD(lpszType))
                    {
                        if (lstrcmp (lpszType,"REGINST") == 0)
                        {
                            //
                            // Currently there is no id for REGINST defined
                            // in nt.  We just use this 2200 for now.
                            //
                            lpResItem->dwTypeID = 2200;
                        }
                    }

                    // Check if we want or not empty strings
                    // Allow empty strings for Dialog resources
                    switch(lpResItem->dwTypeID)
                    {
                        case 4:
                        case 16:
                            bSkipEmpty = TRUE;
                        break;
                        default:
                            bSkipEmpty = FALSE;
                        break;
                    }

                    // Version stamp use class name as res id
                    if(lpResItem->lpszResID)
                        strResName = lpResItem->lpszResID;
                    else strResName = "";

                    dwItemID = lpResItem->dwItemID;

                    if(lpResItem->dwTypeID==5 &&
                       dwItemID==0 &&
                       lpResItem->dwExtStyle){
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=0x%08x\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISEXTSTYLE,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                lpResItem->dwExtStyle);
                                fileOut.WriteString(strToken);
                    }

                    // Add font info for dialogs
                    if((theApp.IsFlag(CMainApp::FONTS)
                        && (lpResItem->dwTypeID==5) && (dwItemID==0)))
                    {
                        if( (lpResItem->dwStyle & DS_SETFONT)!=DS_SETFONT ){
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISDLGFONTNAME | ISDLGFONTSIZE,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0));

                                WriteCon(CONWRN, "Dialog ID %s is missing the DS_SETFONT bit. Cannot extract font information!\r\n", strToken);

                        }else{
                        // Add font information
                            if (lpResItem->bCharSet != DEFAULT_CHARSET){
                                sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s:%hd:%d\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISDLGFONTNAME | ISDLGFONTSIZE|ISDLGFONTCHARSET,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                Format(lpResItem->lpszFaceName),
                                lpResItem->wPointSize,
                                lpResItem->bCharSet);

                            }else{
                                sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s:%hd\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID,
                                ISDLGFONTNAME | ISDLGFONTSIZE ,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                Format(lpResItem->lpszFaceName),
                                lpResItem->wPointSize);
                            }

                                fileOut.WriteString(strToken);
	                    }

                    }


                    strCaption = lpResItem->lpszCaption;

                    // Set the flag
                    wFlag = 0;


                    if(!(bSkipEmpty && strCaption.IsEmpty()))
                    {
                        CString strExt;
                        switch(lpResItem->dwTypeID)
                        {
                            case 2:
                            case 3:
                            case 23:
                            case 240:
                            case 1024:
                            case 2110:
                            case 2200:
                            {
                                switch(lpResItem->dwTypeID)
                                {
                                    case 2:
                                        strExt = ".bmp";
                                        break;

                                    case 3:
                                        strExt = ".ico";
                                        break;

                                    case 240:
                                    case 1024:
                                        strExt = ".bin";
                                        break;

                                    case 23:
                                    case 2110:
                                        strExt = "";
                                        break;


                                    case 2200:
                                        strExt = ".inf";
                                        break;

                                }

                                // create the output name
                                CString strOutputName;
                                if(lpResItem->dwResID)
                                {
                                    strOutputName = CreateName(
                                                        strFileName,
                                                        strExt,
                                                        lpResItem->dwResID);
                                }
                                else
                                {
                                    strOutputName = CreateName(
                                                        strFileName,
                                                        strExt,
                                                        lpResItem->lpszResID);
                                }

                                // Get the image from the file
                                DWORD dwBufSize = RSGetResImage( hModule,
											                     lpszType,
											                     lpszRes,
											                     dwLang,
											                     NULL,
											                     0 );

                                BYTE * pBuf = (BYTE*)(new BYTE[dwBufSize]);

                                if(pBuf==NULL)
                                {
                                    WriteCon(CONERR,
                                             "Warning: Failed to allocate buffer for image! (%d, %d, %s, Size: %d)\r\n",
                                             lpResItem->dwTypeID,
                                             lpResItem->dwResID,
                                             lpResItem->lpszResID,
                                             dwBufSize);
                                    break;
                                }

                                dwBufSize = RSGetResImage( hModule,
			                                  lpszType,
											  lpszRes,
											  dwLang,
											  pBuf,
											  dwBufSize );

                                // write the data in to a file
                                CFile OutputFile;
                                if(!OutputFile.Open(strOutputDir+strOutputName, CFile::modeCreate | CFile::modeWrite))
                                {
                                    WriteCon(CONERR, "Cannot create file: %s\r\n",
                                        CalcTab(strOutputDir+strOutputName, strOutputName.GetLength()+strOutputDir.GetLength()+5, ' '));
                                    delete pBuf;
                                    break;
                                }

                                switch(lpResItem->dwTypeID)
                                {
                                    case 2:
                                    {
                                        BITMAPFILEHEADER bmpFileHeader;
                                        BITMAPINFO * pbmpInfo = (BITMAPINFO *)pBuf;
                                        DWORD dwNumColor = 0;
                                        if(pbmpInfo->bmiHeader.biBitCount!=24)
                                            dwNumColor = ( 1L << pbmpInfo->bmiHeader.biBitCount);

                                        bmpFileHeader.bfType = 0x4d42;
                                        bmpFileHeader.bfSize = (dwBufSize+sizeof(BITMAPFILEHEADER))/4;
                                        bmpFileHeader.bfReserved1 = 0;
                                        bmpFileHeader.bfReserved2 = 0;
                                        bmpFileHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + pbmpInfo->bmiHeader.biSize + dwNumColor*sizeof(RGBQUAD);

                                        OutputFile.Write(&bmpFileHeader, sizeof(BITMAPFILEHEADER));
                                    }
                                    break;
                                    case 3:
                                    {
                                        ICONHEADER icoHeader;
                                        BITMAPINFOHEADER * pbmpInfoH = (BITMAPINFOHEADER*)pBuf;

                                        icoHeader.idReserved = 0;
                                        icoHeader.idType = 1;
                                        icoHeader.idCount = 1;
                                        icoHeader.bWidth = LOBYTE(pbmpInfoH->biWidth);
                                        icoHeader.bHeight = LOBYTE(pbmpInfoH->biWidth);
                                        icoHeader.bColorCount = 16;
                                        icoHeader.bReserved = 0;
                                        icoHeader.wPlanes = 0;
                                        icoHeader.wBitCount = 0;
                                        icoHeader.dwBytesInRes = dwBufSize;
                                        icoHeader.dwImageOffset = sizeof(ICONHEADER);

                                        OutputFile.Write(&icoHeader, sizeof(ICONHEADER));
                                    }
                                    case 23:
                                    case 240:
                                    case 1024:
                                    case 2110:
                                    case 2200:
                                    {
                                        //
                                        // No header for html stuff.
                                        //
                                        break;
                                    }
                                    break;
                                    default:
                                    break;
                                }

                                OutputFile.Write(pBuf, dwBufSize);

                                OutputFile.Close();
                                delete pBuf;

                                strCaption = strOutputName;
                            }
                            break;
                            case 4:
                                if(lpResItem->dwFlags & MF_POPUP) {
									wFlag = ISPOPUP;

									// check if this popup has a valid ID
									if (LOWORD(dwItemID)==0xffff)
										wFlag |= OLD_POPUP_ID;

                                    dwItemID = (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID);
                                }
                                else if (LOWORD(dwItemID)==0xffff)
                                {
                                    dwItemID = HIWORD(dwItemID);
                                    WriteCon (CONWRN,  TEXT("Token [[%u|%u|%u|%u|%u|\"%s\"]] is generated with a suspicious ID. Please check the resource file for invalid ID's.\n"),
                                               lpResItem->dwTypeID,
                                               lpResItem->dwResID,
                                               dwItemID,
                                               wFlag,
                                               ST_TRANSLATED,
                                               strResName.GetBuffer(0));

                                }

                            break;
                            case 5:
                                if(dwItemID==0) {
                                    wFlag = ISCAP;
                                }

                                // check if this is a duplicated id
                                if (LOWORD(dwItemID)==0xffff)
							        wFlag |= ISDUP;

                                dwItemID = (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID);
                            break;
                            case 9:
                            {
                                CAccel accel(lpResItem->dwFlags, lpResItem->dwStyle);
                                strCaption = accel.GetText();

                                // check if this is a duplicated ID
                                if(HIWORD(dwItemID))
                                {
                                    wFlag |= ISDUP;
                                }
                            }
                            break;
                            case 11:
                                dwItemID = LOWORD(dwItemID);
                            break;
                            case 16:
                                strResName = lpResItem->lpszClassName;
                            break;
                            default:
                            break;
                        }

                        // Create the token file
                        if(lpResItem->dwTypeID==11 && theApp.IsFlag(CMainApp::SPLIT))
                        {
                            // Search for the \r\n and replace them
                            while((iPos = strCaption.Find("\r\n"))!=-1)
                            {
                                sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                    TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s\\r\\n\n"),
                                    lpResItem->dwTypeID,
                                    lpResItem->dwResID,
                                    dwItemID,
                                    wFlag | wMsgCount++,
                                    ST_TRANSLATED,
                                    strResName.GetBuffer(0),
                                    Format(strCaption.Left(iPos)));

                                strCaption = strCaption.Right(strCaption.GetLength()-2-iPos);
                                fileOut.WriteString(strToken);
                            }
                            wMsgCount = 0;
                        }
                        else
                        {
                            if(lpResItem->dwTypeID==16 &&
                                theApp.IsFlag(CMainApp::NOVERSION) &&
                                (strResName==TEXT("FileVersion") ||
                                strResName==TEXT("ProductVersion") ||
                                strResName==TEXT("Platform"))){
                                //
                                // do not generate token for these resources
                                //
                            }else{
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                dwItemID, /*(LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),*/
                                wFlag,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                Format(strCaption));

                            fileOut.WriteString(strToken);
                            }
                        }

                        // If this is a dialog box add the coordinates
                        if(lpResItem->dwTypeID==5)
                        {
                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%hu %hu %hu %hu\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),
                                wFlag | ISCOR,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                lpResItem->wX,
                                lpResItem->wY,
                                lpResItem->wcX,
                                lpResItem->wcY);

                            fileOut.WriteString(strToken);

                         //Extract STATIC control alignment style info
                         if (LOBYTE(lpResItem->wClassName) == 0x82  &&
                             theApp.IsFlag(CMainApp::ALIGNMENT))
                         {

                            CHAR szBuf[20]="SS_LEFT";
                            if ((lpResItem->dwStyle & SS_CENTER) == SS_CENTER)
                                lstrcpy(szBuf, "SS_CENTER");
                            else if ((lpResItem->dwStyle & SS_RIGHT)==SS_RIGHT)
                                lstrcpy(szBuf, "SS_RIGHT");

                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%s\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),
                                wFlag | ISALIGN,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                szBuf);

                            fileOut.WriteString(strToken);
                         }
                        }

                    }
                    else
                    {
                        // If this is a dialog box add the coordinates
                        if(lpResItem->dwTypeID==5) {

                            sprintf(strToken.GetBuffer(MAX_STR_SIZE),
                                TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]=%hu %hu %hu %hu\n"),
                                lpResItem->dwTypeID,
                                lpResItem->dwResID,
                                (LOWORD(dwItemID)==0xffff ? HIWORD(dwItemID) : dwItemID),
                                wFlag | ISCOR,
                                ST_TRANSLATED,
                                strResName.GetBuffer(0),
                                lpResItem->wX,
                                lpResItem->wY,
                                lpResItem->wcX,
                                lpResItem->wcY);

                            fileOut.WriteString(strToken);
                        }
                    }
                    } // end while
                }
            }
        }

		fileOut.Close();

        // Check the size of the new file and remove it if empty...
        CFileStatus fstat;	
        if(CFile::GetStatus(m_strTgtTok, fstat))
            if(fstat.m_size==0)
                CFile::Remove(m_strTgtTok);

        WriteCon(CONBOTH, " %hu Items\r\n", wCount);
        if(bVersionStampOnly) {
            ReturnErr = ERR_FILE_VERSTAMPONLY;
            theApp.SetReturn(ERROR_FILE_VERSTAMPONLY);
            WriteCon(CONWRN, "%s : Version Stamping only!\r\n", strFileName);
        }
        if(bCustomResource) {
            SetReturn(ERROR_FILE_CUSTOMRES);
            WriteCon(CONWRN, "%s : Custom resource!\r\n", strFileName);
        }
	}

exit:
    RSCloseModule(hModule);

    return ReturnErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\token.cpp ===
////////////////////////////////////////
// token.cpp
////////////////////////////////////////
//
//  This file handle all the token strings
//
////////////////////////////////////////

#include "token.h"
#include "main.h"

extern CMainApp theApp;
#define MAX_TOKEN   8192

CToken::CToken()
{
    m_uiTypeID      = 0;
    m_uiResID       = 0;
    m_uiItemID      = 0;
    m_uiFlags       = 0;
    m_uiStatusFlags = 0;
    m_uiLastError   = 0;
    m_strItemName   = "";
    m_strSrcText    = "";
    m_strTgtText    = "";

}

int CToken::Parse(CString strSrc, CString strTgt)
{
    CString strSrcTokenID;
    int pos;

    if(!strSrc.IsEmpty())
    {
        pos = strSrc.Find('=');
        if(pos==-1)
        {
            theApp.WriteCon(CONERR, "Invalid token [equal sign missing]\t%s\r\n", strSrc);
            theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
            return CMainApp::ERR_TOKEN_WRONGFORMAT;
        }

        strSrcTokenID = strSrc.Left(pos-3);
        m_strSrcText = strSrc.Right(strSrc.GetLength()-++pos);
        pos = m_strSrcText.Find('\n');
        if(pos!=-1)
            m_strSrcText = m_strSrcText.Left(pos);
    }
    else
        m_strSrcText = "";

    pos = strTgt.Find('=');
    if(pos==-1)
    {
        theApp.WriteCon(CONERR, "Invalid token  [equal sign missing]\t%s\r\n", strTgt);
        theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
        return CMainApp::ERR_TOKEN_WRONGFORMAT;
    }

    if(pos<=3)
    {
        theApp.WriteCon(CONERR, "Invalid token  [token corruption]\t%s\r\n", strTgt);
        theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
        return CMainApp::ERR_TOKEN_WRONGFORMAT;
    }

    m_strTokenID = strTgt.Left(pos-3);
    m_strTgtText = strTgt.Right(strTgt.GetLength()-++pos);

    //pos = m_strTgtText.Find('\n');
    //if(pos!=-1)
    //    m_strTgtText = m_strTgtText.Left(pos);
    //
    // On FE platforms, "Find" could not find the
    // ending \n when the last char is a High ansi because it is leadbyte.

    char * pStr = m_strTgtText.GetBuffer(0);
    pos = 0;
    while (*pStr){
        if(*pStr == '\n'){
            m_strTgtText = m_strTgtText.Left(pos);
            break;
        }
        if (IsDBCSLeadByteEx(theApp.GetUICodePage(), *pStr))
        {
            pos+=2;
        }
        else
        {
            pos++;
        }
        pStr = CharNextExA((WORD)theApp.GetUICodePage(), pStr, 0);
    }

    if(5>sscanf(m_strTokenID, TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]"),
        &m_uiTypeID,
        &m_uiResID,
        &m_uiItemID,
        &m_uiFlags,
        &m_uiStatusFlags,
        m_strItemName.GetBuffer(128)))
    {
        theApp.WriteCon(CONERR, "Invalid token [not enough arguments converted]\t%s\"]]\r\n", m_strTokenID);
        theApp.SetReturn(ERROR_RET_INVALID_TOKEN);
        return CMainApp::ERR_TOKEN_WRONGFORMAT;
    }

	// Special case the Menu Popup
	if(m_uiTypeID==4 && (m_uiFlags & ISPOPUP)==ISPOPUP && (m_uiFlags & OLD_POPUP_ID)==OLD_POPUP_ID)
    {
        m_uiItemID = MAKELONG( 0xFFFF, LOWORD(m_uiItemID) );
    }
	
    m_strItemName.ReleaseBuffer();
    m_strItemName = m_strTokenID.Mid(m_strTokenID.Find("|\"")+2);

    if(!strSrc.IsEmpty())
    {
        // Perform a consistency check on the token files
        unsigned int    uiTypeID = 0;
        unsigned int    uiResID = 0;
        unsigned int    uiItemID = 0;
        unsigned int    uiFlags = 0;
        unsigned int    uiStatusFlags = 0;
        CString         strItemName = "";

        sscanf(strSrcTokenID, TEXT("[[%u|%u|%u|%u|%u|\"%s\"]]"),
            &uiTypeID,
            &uiResID,
            &uiItemID,
            &uiFlags,
            &uiStatusFlags,
            strItemName.GetBuffer(128));

        strItemName.ReleaseBuffer();
        strItemName = strSrcTokenID.Mid(strSrcTokenID.Find("|\"")+2);

        // Special case the Menu Popup
		if(uiTypeID==4 && (uiFlags & ISPOPUP)==ISPOPUP && (m_uiFlags & OLD_POPUP_ID)==OLD_POPUP_ID)
        {
            uiItemID = MAKELONG( 0xFFFF, LOWORD(uiItemID) );
        } 		
		
        // Compare token ID
        if(!((uiTypeID == m_uiTypeID) &&
           (uiResID  == m_uiResID) &&
           (uiItemID == m_uiItemID) &&
           (uiFlags  == m_uiFlags) &&
           (strItemName == m_strItemName)))
        {
            theApp.WriteCon(CONERR, "Token ID mismatch\t%s\"]]\t%s\"]]\r\n", strSrcTokenID.GetBuffer(0), m_strTokenID.GetBuffer(0));
            theApp.SetReturn(ERROR_RET_TOKEN_MISMATCH);
            return CMainApp::ERR_TOKEN_MISMATCH;
        }
    }

    return 0;
}

BOOL CToken::GetTgtSize(WORD * px, WORD * py,WORD * pcx, WORD * pcy)
{
   return sscanf(m_strTgtText, TEXT("%hu %hu %hu %hu"),
        px,
        py,
        pcx,
        pcy);
}

BOOL CToken::GetSrcSize(WORD * px, WORD * py,WORD * pcx, WORD * pcy)
{
   return sscanf(m_strSrcText, TEXT("%hu %hu %hu %hu"),
        px,
        py,
        pcx,
        pcy);
}


/////////////////////////////////////////////////////////////////////////

CTokenFile::CTokenFile()
{
    m_Tokens.SetSize(0, 10);
    m_iLastPos      = 0;
    m_iUpperBound   = -1;
    m_strSrcFile    = "";
    m_strTgtFile    = "";
}

CTokenFile::~CTokenFile()
{
    for(INT_PTR at=0; at<=m_iUpperBound; at++)
        delete (m_Tokens.GetAt(at));

    m_Tokens.RemoveAll();
}

int CTokenFile::Open(CString strSrcFile, CString strTgtFile)
{
    int iErr = CMainApp::ERR_NOERROR;
    // Open the files
    CStdioFile SrcFile;
    CStdioFile TgtFile;

    // If we are doing an UPDATE we need both src and tgt files
    // while if we are not it is enough the tgt file.
    // If only the tgt file is given no consistency will be done.
    if(theApp.IsFlag(CMainApp::UPDATE))
        if(!SrcFile.Open(strSrcFile, CFile::modeRead | CFile::shareDenyWrite))
        {
            theApp.WriteCon(CONERR, "Cannot open file: %s\r\n", strSrcFile);
            return CMainApp::ERR_FILE_OPEN;
        }

    if(!TgtFile.Open(strTgtFile, CFile::modeRead | CFile::shareDenyWrite))
    {
        theApp.WriteCon(CONERR, "Cannot open file: %s\r\n", strTgtFile);
        return CMainApp::ERR_FILE_OPEN;
    }

    CString strSrc = "";
    CString strTgt = "";
    INT_PTR at;

    while(TgtFile.ReadString(strTgt.GetBuffer(MAX_TOKEN), MAX_TOKEN))
    {
        if(theApp.IsFlag(CMainApp::UPDATE))
            if(!SrcFile.ReadString(strSrc.GetBuffer(MAX_TOKEN), MAX_TOKEN))
            {
                theApp.WriteCon(CONERR, "The file  %s has more tokens than the file %s!\r\n", strTgtFile, strSrcFile);
                theApp.SetReturn(ERROR_RET_TOKEN_MISMATCH);
                return CMainApp::ERR_TOKEN_MISMATCH;
            }

        strSrc.ReleaseBuffer();
        strTgt.ReleaseBuffer();

        at = m_Tokens.Add(new CToken());

        if(iErr = ((CToken*)m_Tokens.GetAt(at))->Parse(strSrc,strTgt))
        {
            goto close;
        }

    }

    m_iUpperBound = m_Tokens.GetUpperBound();

close:
    if(theApp.IsFlag(CMainApp::UPDATE))
        SrcFile.Close();

    TgtFile.Close();

    return iErr;
}

const CToken * CTokenFile::GetTokenSize(CToken * pToken, WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy)
{

    if((pToken!=NULL) && (pToken->m_uiTypeID!=5))
        return NULL;

    CToken * pTokenSize = (CToken *)m_Tokens.GetAt(m_iLastPos++);

    if(pTokenSize==NULL)
        return NULL;

    WORD x, y, cx, cy;
    pTokenSize->GetSrcSize(&x, &y, &cx, &cy);

    // check if the size changed
    if(!theApp.IsFlag(CMainApp::UPDATE) ||
       (x==*px &&
       y==*py &&
       cx==*pcx &&
       cy==*pcy) )
    {
        pTokenSize->GetTgtSize(px, py, pcx, pcy);
    }
    else
    {
        theApp.WriteCon(CONWRN, "Item Resized\t%s\"]]\r\n", pTokenSize->m_strTokenID);
        theApp.AddResized();
    }

    return pTokenSize;
}

const CToken * CTokenFile::GetTokenSize(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName,
                      WORD * px, WORD * py,
                      WORD * pcx, WORD * pcy)
{
    if(TypeID!=5)
        return NULL;

    BOOL bMatch = FALSE;

    ASSERT(m_iUpperBound!=-1);
    if(m_iLastPos>m_iUpperBound)
        m_iLastPos = 0;

    CToken * pToken = NULL;
    INT_PTR iLastPos = m_iLastPos;

    while(!bMatch)
    {
        pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);

        if(pToken==NULL)
            return NULL;

        while(pToken->m_uiTypeID!=TypeID && !bMatch) {
            if(m_iLastPos>m_iUpperBound) {
                m_iLastPos = 0;
                bMatch = TRUE;
            }
            pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);
            if(pToken==NULL)
                return NULL;
        }

        // Let's see if we have at least some parameter to find the token
        if(pToken->m_uiTypeID==TypeID &&
           pToken->m_uiResID==ResID &&
           pToken->m_uiItemID==ItemID &&
           pToken->m_strItemName==strItemName &&
           (pToken->m_uiFlags & ISCOR))      // to be compatible with rlman token ids
        {
            WORD x, y, cx, cy;
            pToken->GetSrcSize(&x, &y, &cx, &cy);

            // check if the size changed
            if(!theApp.IsFlag(CMainApp::UPDATE) ||
               (x==*px &&
               y==*py &&
               cx==*pcx &&
               cy==*pcy) )
            {
                pToken->GetTgtSize(px, py, pcx, pcy);
            }
            else
            {
                theApp.WriteCon(CONWRN, "Item Resized\t%s\"]]\r\n", pToken->m_strTokenID);
                theApp.AddResized();
            }

            return pToken;
        }
        else if(pToken->m_uiTypeID!=TypeID)
        {
            m_iLastPos = iLastPos;
            return NULL;
        }

        if(m_iLastPos>m_iUpperBound)
           return NULL;
    }

    return NULL;
}

const CToken * CTokenFile::GetToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strText,
                      CString strItemName)
{
    if(strText.IsEmpty() && (TypeID != 5L))      // Allow Dialog Strings to be NULL
        return NULL;

    BOOL bMatch = FALSE;

    ASSERT(m_iUpperBound!=-1);
    if(m_iLastPos>m_iUpperBound)
        m_iLastPos = 0;

    CToken * pToken = NULL;
    INT_PTR iLastPos = m_iLastPos;

    while(!bMatch)
    {
        pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);

        if(pToken==NULL)
            return NULL;

        while(pToken->m_uiTypeID!=TypeID && !bMatch) {
            if(m_iLastPos>m_iUpperBound) {
                m_iLastPos = 0;
                bMatch = TRUE;
            }
            pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);
            if(pToken==NULL)
                return NULL;
        }

        // Let's see if we have at least some parameter to find the token
        if(pToken->m_uiTypeID==TypeID &&
           pToken->m_uiResID==ResID &&
           pToken->m_uiItemID==ItemID &&
           pToken->m_strItemName==strItemName &&
           !(pToken->m_uiFlags & ISCOR))    // to be compatible with rlman token ids
        {
            if(!theApp.IsFlag(CMainApp::FONTS) && (pToken->m_uiFlags & ISDLGFONTNAME) || (pToken->m_uiFlags & ISDLGFONTSIZE))
                return pToken;
            else if(!theApp.IsFlag(CMainApp::UPDATE) || pToken->m_strSrcText==strText)
                return pToken;
            else
            {
                theApp.WriteCon(CONWRN, "Context changed\t%s\"]]\r\n", pToken->m_strTokenID);
                theApp.AddChanged();
                pToken->m_uiLastError = 1;
                return pToken;
            }
        }
        else if(pToken->m_uiTypeID!=TypeID) {
                m_iLastPos = iLastPos;
                return NULL;
        }

        if(m_iLastPos>m_iUpperBound)
           return NULL;
    }

    return NULL;
}

const CToken * CTokenFile::GetNoCaptionToken(unsigned int TypeID,
                      unsigned int ResID,
                      unsigned int ItemID,
                      CString strItemName)
{
    BOOL bMatch = FALSE;

    ASSERT(m_iUpperBound!=-1);
    if(m_iLastPos>m_iUpperBound)
        m_iLastPos = 0;

    CToken * pToken = NULL;
    INT_PTR iLastPos = m_iLastPos;

    while(!bMatch)
    {
        pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);

        if(pToken==NULL)
            return NULL;

        while(pToken->m_uiTypeID!=TypeID && !bMatch) {
            if(m_iLastPos>m_iUpperBound) {
                m_iLastPos = 0;
                bMatch = TRUE;
            }
            pToken = (CToken*)m_Tokens.GetAt(m_iLastPos++);
            if(pToken==NULL)
                return NULL;
        }

        // Let's see if we have at least some parameter to find the token
        if(pToken->m_uiTypeID==TypeID &&
           pToken->m_uiResID==ResID &&
           pToken->m_uiItemID==ItemID &&
           pToken->m_strItemName==strItemName &&  // to be compatible with rlman token ids
           (!pToken->m_strSrcText || TypeID !=4)) // Some binaries like shell32.dll uses the same id 0 as MENU SEPARATOR.  Filter those out.
        {
           return pToken;
        }
        else if(pToken->m_uiTypeID!=TypeID) {
                m_iLastPos = iLastPos;
                return NULL;
        }

        if(m_iLastPos>m_iUpperBound)
           return NULL;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\vktbl.h ===
#ifndef __VKTBL_H__
#define __VKTBL_H__


#define ACC_SHIFT   0x04
#define ACC_CTRL    0x08
#define ACC_ALT     0x10
#define ACC_VK      0x01

#define ISACCFLG(x,y)    ((x & y)==y)

class CAccel
{
public:
    CAccel();       // Default
    CAccel(LPCSTR strText);
    CAccel(DWORD dwFlags, DWORD dwEvent);

    DWORD GetEvent()
        { return m_dwEvent; }
    DWORD GetFlags()
        { return m_dwFlags; }
    CString GetText()
        { return m_strText; }

private:
    CString VKToString(DWORD dwVKCode);
    DWORD StringToVK(CString str);

    CString m_strText;
    DWORD   m_dwFlags;
    DWORD   m_dwEvent;
};

#endif // __VKTBL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\bingen\vktbl.cpp ===
#include <afx.h>
#include "vktbl.h"

char vkstrTable[][15] = 
{ 
    "VK_LBUTTON",   
    "VK_RBUTTON",  
    "VK_CANCEL",                
                     
    "VK_MBUTTON",              
    "VK_BACK",                    
    "VK_TAB",                      
                     
    "VK_CLEAR",                  
    "VK_RETURN",                
                    
    "VK_SHIFT",                  
    "VK_CONTROL",              
    "VK_MENU",                    
    "VK_PAUSE",                  
    "VK_CAPITAL",              
                    
    "VK_ESCAPE",                
                    
    "VK_SPACE",                  
    "VK_PRIOR",                  
    "VK_NEXT",                    
    "VK_END",                      
    "VK_HOME",                    
    "VK_LEFT",                    
    "VK_UP",                        
    "VK_RIGHT",                  
    "VK_DOWN",                    
    "VK_SELECT",                
    "VK_PRINT",                  
    "VK_EXECUTE",              
    "VK_SNAPSHOT",            
    "VK_INSERT",                
    "VK_DELETE",                
    "VK_HELP",                    
                     
    "VK_LWIN",                    
    "VK_RWIN",                    
    "VK_APPS",                    
                    
    "VK_NUMPAD0",              
    "VK_NUMPAD1",              
    "VK_NUMPAD2",              
    "VK_NUMPAD3",              
    "VK_NUMPAD4",              
    "VK_NUMPAD5",              
    "VK_NUMPAD6",              
    "VK_NUMPAD7",              
    "VK_NUMPAD8",              
    "VK_NUMPAD9",              
    "VK_MULTIPLY",            
    "VK_ADD",                      
    "VK_SEPARATOR",
    "VK_SUBTRACT",            
    "VK_DECIMAL",              
    "VK_DIVIDE",                
    "VK_F1",                        
    "VK_F2",                        
    "VK_F3",                        
    "VK_F4",                        
    "VK_F5",                        
    "VK_F6",                        
    "VK_F7",                        
    "VK_F8",                        
    "VK_F9",                        
    "VK_F10",                      
    "VK_F11",                      
    "VK_F12",                      
    "VK_F13",                      
    "VK_F14",                      
    "VK_F15",                      
    "VK_F16",                      
    "VK_F17",                      
    "VK_F18",                      
    "VK_F19",                      
    "VK_F20",                      
    "VK_F21",                      
    "VK_F22",                      
    "VK_F23",                      
    "VK_F24",                      
                    
    "VK_NUMLOCK",              
    "VK_SCROLL",                
                    
    "VK_LSHIFT",                
    "VK_RSHIFT",                
    "VK_LCONTROL",            
    "VK_RCONTROL",            
    "VK_LMENU",                  
    "VK_RMENU",                  
                     
    "VK_ATTN",                    
    "VK_CRSEL",                  
    "VK_EXSEL",                  
    "VK_EREOF",                  
    "VK_PLAY",                    
    "VK_ZOOM",                    
    "VK_NONAME",                
    "VK_PA1",                      
    "VK_OEM_CLEAR",

    // added for Pagasus
    "VK_OEM_PLUS",
    "VK_OEM_COMMA",
    "VK_OEM_MINUS",
    "VK_OEM_PERIOD",
    "VK_OEM_1",
    "VK_OEM_2",
    "VK_OEM_3",
    "VK_OEM_4",
    "VK_OEM_5",
    "VK_OEM_6",
    "VK_OEM_7",
    "VK_OEM_102"
};

DWORD vkdwTable[] = 
{
     VK_LBUTTON  
    ,VK_RBUTTON  
    ,VK_CANCEL   
            
    ,VK_MBUTTON  
    ,VK_BACK     
    ,VK_TAB      
            
    ,VK_CLEAR    
    ,VK_RETURN   
            
    ,VK_SHIFT    
    ,VK_CONTROL  
    ,VK_MENU     
    ,VK_PAUSE    
    ,VK_CAPITAL  
            
    ,VK_ESCAPE   
            
    ,VK_SPACE    
    ,VK_PRIOR    
    ,VK_NEXT     
    ,VK_END      
    ,VK_HOME     
    ,VK_LEFT     
    ,VK_UP       
    ,VK_RIGHT    
    ,VK_DOWN     
    ,VK_SELECT   
    ,VK_PRINT    
    ,VK_EXECUTE  
    ,VK_SNAPSHOT 
    ,VK_INSERT   
    ,VK_DELETE   
    ,VK_HELP     
            
    ,VK_LWIN     
    ,VK_RWIN     
    ,VK_APPS     
            
    ,VK_NUMPAD0  
    ,VK_NUMPAD1  
    ,VK_NUMPAD2  
    ,VK_NUMPAD3  
    ,VK_NUMPAD4  
    ,VK_NUMPAD5  
    ,VK_NUMPAD6  
    ,VK_NUMPAD7  
    ,VK_NUMPAD8  
    ,VK_NUMPAD9  
    ,VK_MULTIPLY 
    ,VK_ADD      
    ,VK_SEPARATOR
    ,VK_SUBTRACT 
    ,VK_DECIMAL  
    ,VK_DIVIDE   
    ,VK_F1       
    ,VK_F2       
    ,VK_F3       
    ,VK_F4       
    ,VK_F5       
    ,VK_F6       
    ,VK_F7       
    ,VK_F8       
    ,VK_F9       
    ,VK_F10      
    ,VK_F11      
    ,VK_F12      
    ,VK_F13      
    ,VK_F14      
    ,VK_F15      
    ,VK_F16      
    ,VK_F17      
    ,VK_F18      
    ,VK_F19      
    ,VK_F20      
    ,VK_F21      
    ,VK_F22      
    ,VK_F23      
    ,VK_F24      
            
    ,VK_NUMLOCK  
    ,VK_SCROLL   
            
    ,VK_LSHIFT   
    ,VK_RSHIFT   
    ,VK_LCONTROL 
    ,VK_RCONTROL 
    ,VK_LMENU    
    ,VK_RMENU    
            
    ,VK_ATTN     
    ,VK_CRSEL    
    ,VK_EXSEL    
    ,VK_EREOF    
    ,VK_PLAY     
    ,VK_ZOOM     
    ,VK_NONAME   
    ,VK_PA1      
    ,VK_OEM_CLEAR

    // added for Pagasus
    ,VK_OEM_PLUS
    ,VK_OEM_COMMA
    ,VK_OEM_MINUS
    ,VK_OEM_PERIOD
    ,VK_OEM_1
    ,VK_OEM_2
    ,VK_OEM_3
    ,VK_OEM_4
    ,VK_OEM_5
    ,VK_OEM_6
    ,VK_OEM_7
    ,VK_OEM_102

};

int imaxvktable = sizeof(vkdwTable)/sizeof(DWORD);

CAccel::CAccel()
{
    m_dwFlags = 0;
    m_dwEvent = 0;
    m_strText = "";
}

CAccel::CAccel(LPCSTR strText)
{
    CString strAcc = strText;
    m_dwFlags = 0;
    m_dwEvent = 0;
    m_strText = "";

    // First check for the VIRTKEY or ASCII tag
    if(strAcc.Find("VIRTKEY")!=-1)
    {
        m_dwFlags |= ACC_VK;

        // Check for the Key tags
        if(strAcc.Find("Ctrl")!=-1)
            m_dwFlags |= ACC_CTRL;
        if(strAcc.Find("Shift")!=-1)
            m_dwFlags |= ACC_SHIFT;
        if(strAcc.Find("Alt")!=-1)
            m_dwFlags |= ACC_ALT;

        // Now clean the string and get the VK code
        int iPos = strAcc.Find("VK_");
        if(iPos==-1)
        {
            // something is wrong 
            m_dwFlags = 0;
            m_dwEvent = 0;
            m_strText = "";
        }
        int iCount = 0;
        while(strAcc[iPos+iCount]!=',')
            iCount++;

        m_dwEvent = StringToVK(strAcc.Mid(iPos, iCount));
    }
    else if(strAcc.Find("ASCII")!=-1)
    {
        // Check for the Key tags
        if(strAcc.Find("Ctrl")!=-1)
        {
            int iPos = strAcc.Find('+');
            if(iPos!=-1)
            {
                m_dwEvent = ((DWORD)strAcc[iPos+1])-0x40;
            }
        }
        else if(strAcc.Find("Alt")!=-1)
        {
            int iPos = strAcc.Find('+');
            if(iPos!=-1)
            {
                m_dwEvent = ((DWORD)strAcc[iPos+1]);
                m_dwFlags |= ACC_ALT;
            }
        }
        else
        {
            m_dwEvent = (DWORD)strAcc[0];
        }
    }
}

CAccel::CAccel(DWORD dwFlags, DWORD dwEvent)
{
    m_dwFlags = dwFlags;
    m_dwEvent = dwEvent;
    
    // Accelerator handling
    if(ISACCFLG(m_dwFlags, ACC_CTRL))
        m_strText += "Ctrl+";
    if(ISACCFLG(m_dwFlags, ACC_SHIFT))
        m_strText += "Shift+";
    if(ISACCFLG(m_dwFlags, ACC_ALT))
        m_strText += "Alt+";
    
    if(ISACCFLG(m_dwFlags, ACC_VK))
    {
        m_strText += VKToString(m_dwEvent);
        m_strText += ", VIRTKEY";
    }
    else 
    {
        if(m_dwEvent + 0x40 >= 'A' && m_dwEvent + 0x40 <= 'Z')
        {
            m_strText += "Ctrl+";
            m_strText += (char)(m_dwEvent + 0x40);
        }
        else m_strText += (char)m_dwEvent;

        m_strText += ", ASCII";
    }
}

CString CAccel::VKToString(DWORD dwEvent)
{
    CString strVK = "";

    if((dwEvent >= 0x30) && (dwEvent <= 0x5A))
    {
        strVK = "VK_";
        strVK += (char)dwEvent;
    }

    int i = 0;
    while(i<imaxvktable)
    {
        if(dwEvent==vkdwTable[i++])
        {
            strVK = vkstrTable[i-1];
            break;
        }
    }
    
    return strVK;
}

DWORD CAccel::StringToVK(CString str)
{
    DWORD dwVK = 0;

    if(str.GetLength()==4)
    {
        // remove the VK_ and get the char
        str = str.Mid(3);
        dwVK = (DWORD)str[0];
    }
    else 
    {
        int i = 0;
        while(i<imaxvktable)
        {
            if(str==vkstrTable[i++])
            {
                dwVK = vkdwTable[i-1];
                break;
            }
        }
    }
    
    return dwVK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\io\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by Script1.rc
//
#define IDR_VERSION1                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\delcert\afxres.h ===
// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\inc\iodll.h ===
//+---------------------------------------------------------------------------
//
//  File:       iodll.h
//
//  Contents:   Declarations for the I/O API Layer DLL
//
//  Classes:    none
//
//  History:    27-May-93   alessanm    created
//
//----------------------------------------------------------------------------
#ifndef _IODLL_H_
#define _IODLL_H_


//////////////////////////////////////////////////////////////////////////////
// Type declaration, common to all the module in the Reader/Writer
//////////////////////////////////////////////////////////////////////////////
#define DllExport

typedef unsigned char * LPUCHAR;
typedef void  *      LPVOID;

#define LAST_WRN    100 // last valid value for warning
typedef enum Errors
{                              
    ERROR_NO_ERROR                  = 0,                
    // Warning have values smaller than LAST_WRN
    ERROR_RW_NO_RESOURCES           = 1,    
    ERROR_RW_VXD_MSGPAGE            = 2,
    ERROR_IO_CHECKSUM_MISMATCH      = 3,   
    ERROR_FILE_CUSTOMRES            = 4,
    ERROR_FILE_VERSTAMPONLY         = 5,
    ERROR_RET_RESIZED               = 6,
    ERROR_RET_ID_NOTFOUND           = 7,
    ERROR_RET_CNTX_CHANGED          = 8,
    ERROR_RET_INVALID_TOKEN         = 9,
    ERROR_RET_TOKEN_REMOVED         = 10,
    ERROR_RET_TOKEN_MISMATCH        = 11,
	
    // Errors will have positive values
    ERROR_HANDLE_INVALID            = LAST_WRN + 1,
    ERROR_READING_INI               = LAST_WRN + 2,        
    ERROR_NEW_FAILED                = LAST_WRN + 3,
    ERROR_OUT_OF_DISKSPACE          = LAST_WRN + 4,
    ERROR_FILE_OPEN                 = LAST_WRN + 5,
    ERROR_FILE_CREATE               = LAST_WRN + 6,
    ERROR_FILE_INVALID_OFFSET       = LAST_WRN + 7,
    ERROR_FILE_READ                 = LAST_WRN + 8,
    ERROR_FILE_WRITE                = LAST_WRN + 9,
    ERROR_DLL_LOAD                  = LAST_WRN + 10,
    ERROR_DLL_PROC_ADDRESS          = LAST_WRN + 11,
    ERROR_RW_LOADIMAGE              = LAST_WRN + 12,
    ERROR_RW_PARSEIMAGE             = LAST_WRN + 13,
    ERROR_RW_GETIMAGE               = LAST_WRN + 14,
    ERROR_RW_NOTREADY               = LAST_WRN + 15,
    ERROR_RW_BUFFER_TOO_SMALL       = LAST_WRN + 16,
    ERROR_RW_INVALID_FILE           = LAST_WRN + 17,
    ERROR_RW_IMAGE_TOO_BIG          = LAST_WRN + 18,
    ERROR_RW_TOO_MANY_LEVELS        = LAST_WRN + 19,
    ERROR_IO_INVALIDITEM            = LAST_WRN + 20,
    ERROR_IO_INVALIDID              = LAST_WRN + 21,
    ERROR_IO_INVALID_DLL            = LAST_WRN + 22,
    ERROR_IO_TYPE_NOT_SUPPORTED     = LAST_WRN + 23,
    ERROR_IO_INVALIDMODULE          = LAST_WRN + 24,
    ERROR_IO_RESINFO_NULL           = LAST_WRN + 25,
    ERROR_IO_UPDATEIMAGE            = LAST_WRN + 26,
    ERROR_IO_FILE_NOT_SUPPORTED     = LAST_WRN + 27,
    ERROR_FILE_SYMPATH_NOT_FOUND    = LAST_WRN + 28,
    ERROR_FILE_MULTILANG            = LAST_WRN + 29,
    ERROR_IO_SYMBOLFILE_NOT_FOUND   = LAST_WRN + 30,
    ERROR_RES_NOT_FOUND             = LAST_WRN + 31
};

#define LAST_ERROR      200 // last valid value for IODLL error. System error get passed as LAST_ERROR+syserr
#define IODLL_LAST_ERROR      LAST_ERROR // last valid value for IODLL error. System error get passed as LAST_ERROR+syserr

typedef enum ResourceType
{
	RS_ALL     = 0,
	RS_CURSORS = 1,
	RS_BITMAPS = 2 ,
	RS_ICONS   = 3,
	RS_MENUS   = 4,
	RS_DIALOGS = 5,
	RS_STRINGS = 6,
	RS_FONTDIRS= 7,
	RS_FONTS   = 8,
	RS_ACCELERATORS = 9,
	RS_RCDATA  = 10,
	RS_ERRTABLES = 11,
	RS_GROUP_CURSORS = 12,
	RS_GROUP_ICONS = 14,
	RS_NAMETABLES = 15,
	RS_VERSIONS = 16,
	RS_CUSTOMS = 100
} RESTYPES;

typedef struct _ResItem
{
		DWORD   dwSize;             // Size of the buffer to hold the structure
		
		WORD    wX;                 // POSITION
		WORD    wY;
		WORD    wcX;                // SIZE
		WORD    wcY;
		
		DWORD   dwCheckSum;         // Checksum for bitmap
		DWORD   dwStyle;            // Styles
		DWORD   dwExtStyle;         // Extended style
		DWORD   dwFlags;            // Menu flags
		
		DWORD   dwItemID;           // Item Identifier
		DWORD   dwResID;            // Resource identifier (if ordinal)
		DWORD   dwTypeID;           // Type identifier (if Ordinal)
		DWORD   dwLanguage;         // Language identifier
		
		DWORD   dwCodePage;         // Code page
		WORD    wClassName;         // Class name (if ordinal)
		WORD    wPointSize;         // Point Size
		WORD    wWeight;            // Weight 
		BYTE    bItalic;            // Italic
		BYTE    bCharSet;           // Charset
		
		LPSTR   lpszClassName;      // Class name (if string)
		LPSTR   lpszFaceName;       // Face Name 
		LPSTR   lpszCaption;        // Caption
		LPSTR   lpszResID;          // Resource identifier (if string)
		LPSTR   lpszTypeID;         // Type identifier (if string)
		
} RESITEM, * PRESITEM, FAR * LPRESITEM;

typedef struct _Settings
{
		UINT	cp;
        BOOL    bAppend;        // Append resource to win32 files
        BOOL    bUpdOtherResLang; //update language info of res. not specified.
        char    szDefChar[2];
} SETTINGS, * LPSETTINGS;


//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Module Opening/Closing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
HANDLE 
APIENTRY 
RSOpenModule(
	LPCSTR   lpszSrcfilename,        // File name of the executable to use as source file
	LPCSTR   lpszfiletype );         // Type of the executable file if known

extern "C"
DllExport
HANDLE 
APIENTRY 
RSOpenModuleEx(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,           // Resource Description File (RDF)
    DWORD    dwFlags );             // Flags to be passed to the RW to specify particular behaviour
                                    // LOWORD is for iodll while HIWORD if for RW
extern "C"
DllExport
UINT 
APIENTRY 
RSCloseModule(
	HANDLE  hResFileModule );       // Handle to the session opened before

extern "C"
DllExport
HANDLE
APIENTRY 
RSHandleFromName(
	LPCSTR   lpszfilename );        // Handle to the session with the file name specified

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Enumeration API                        
//--------------------------------------------------------------------------------------------
	
extern "C"
DllExport
LPCSTR
APIENTRY 
RSEnumResType(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszPrevResType);       // Previously enumerated type

extern "C"
DllExport
LPCSTR
APIENTRY 
RSEnumResId(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszPrevResId);         // Previously enumerated id

extern "C"
DllExport
DWORD
APIENTRY 
RSEnumResLang(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwPrevResLang);         // Previously enumerated language
    
extern "C"
DllExport
DWORD
APIENTRY 
RSEnumResItemId(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language
	DWORD   dwPrevResItemId);       // Previously enumerated item id

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Data acquisition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT 
APIENTRY 
RSGetResItemData(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language
	DWORD   dwResItemId,                    // Previously enumerated item id
	LPVOID  lpbuffer,           // Pointer to the buffer that will get the resource info
	UINT    uiBufSize);                     // Size of the buffer that will hold the resource info

extern "C"
DllExport
DWORD
APIENTRY 
RSGetResImage(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language                
	LPVOID  lpbuffer,                       // Pointer to the buffer to get the resource Data
	DWORD   dwBufSize);                     // Size of the allocated buffer
	
//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Update API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSUpdateResItemData(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language                
	DWORD   dwResItemId,            // Previously enumerated items id
	LPVOID  lpbuffer,                       // Pointer to the buffer to the resource item Data
	UINT    uiBufSize);                     // Size of the buffer
	
extern "C"
DllExport
DWORD
APIENTRY 
RSUpdateResImage(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszResType,            // Previously enumerated type
	LPCSTR  lpszResId,                      // Previously enumerated id
	DWORD   dwResLang,                      // Previously enumerated language                
	DWORD   dwUpdLang,                      // Desired output language                
	LPVOID  lpbuffer,                       // Pointer to the buffer to the resource item Data
	DWORD   dwBufSize);                     // Size of the buffer
	
//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Conversion API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSUpdateFromResFile(
	HANDLE  hResFileModule,         // Handle to the file session
	LPSTR   lpszResFilename);       // The resource filename to be converted
	
//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Writing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSWriteResFile(
	HANDLE  hResFileModule,         // Handle to the file session
	LPCSTR  lpszTgtfilename,        // The new filename to be generated
	LPCSTR  lpszTgtfileType,        // Target Resource type 16/32
	LPCSTR  lpszSymbolPath);        // Symbol path for updating symbol checksum

extern "C"
DllExport
HANDLE
APIENTRY
RSCopyModule(
    HANDLE  hSrcfilemodule,         // Handle to the source file
    LPCSTR  lpszModuleName,            // Name of the new module filename
    LPCSTR  lpszfiletype );         // Type of the target module


//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Recognition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSFileType(
	LPCSTR   lpszfilename,   // File name of the executable to use as source file
	LPSTR    lpszfiletype ); // Type of the executable file if known


extern "C"
DllExport
UINT
APIENTRY 
RSLanguages(
	HANDLE  hfilemodule,      // Handle to the file
	LPSTR   lpszLanguages );  // will be filled with a string of all the languages in the file
  

//--------------------------------------------------------------------------------------------           
//********************************************************************************************
//      Global Settings API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY 
RSSetGlobals(    
	SETTINGS	settings);         // Set the global variable, like CP to use.

extern "C"
DllExport
UINT
APIENTRY 
RSGetGlobals(    
	LPSETTINGS	lpSettings);         // Retrieve the global variable


     
#endif   // _IODLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\delcert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RWINF.RC
//

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\restools\rlt32\io\iodll.cpp ===
//+---------------------------------------------------------------------------
//
//  File:   iodll.cpp
//
//  Contents:   Implementation for the I/O module
//
//  Classes:
//
//  History:    27-May-93   alessanm    created
//              25-Jun-93   alessanm    eliminated TRANSCONTEXT and added RESITEM
//
//----------------------------------------------------------------------------

#include <afx.h>
#include <afxwin.h>
#include <afxcoll.h>
#include <iodll.h>
#include <limits.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>
#include <dos.h>
#include <errno.h>
#include <setjmp.h>

//
// UlongToHandle is defined in basetsd.h now
//
// #define UlongToHandle(x)  (HANDLE)UlongToPtr(x)
//


/////////////////////////////////////////////////////////////////////////////
// Initialization of MFC Extension DLL

#include "afxdllx.h"    // standard MFC Extension DLL routines

static AFX_EXTENSION_MODULE extensionDLL = { NULL, NULL };


/////////////////////////////////////////////////////////////////////////////
// General Declarations
#define MODULENAME "iodll.dll"
#define Pad4(x) ((((x+3)>>2)<<2)-x)
#define PadPtr(x) ((((x+(sizeof(PVOID)-1))/sizeof(PVOID))*sizeof(PVOID))-x)

#define LPNULL 0L

// INI Informations
#define SECTION "iodll32"
#define MAXENTRYBUF 1024    // Buffer to entry in the INI file
#define MAXDLLNUM 20        // We hard-code the number of DLL. TO fix later

#define MAXKEYLEN  32

// HANDLE Informations
#define FIRSTVALIDVALUE LAST_ERROR // The first valid value for an HANDLE to a module

typedef unsigned char UCHAR;
typedef char * PCHAR;
typedef UCHAR * PUCHAR;
/////////////////////////////////////////////////////////////////////////////
// Function Declarations

/////////////////////////////////////////////////////////////////////////////
// Helper Function Declarations

/////////////////////////////////////////////////////////////////////////////
// Class declarations

class CFileModule;

class CItemInfo : public CObject
{
public:
    CItemInfo(  WORD x, WORD y,
                WORD cx, WORD cy,
                DWORD dwPosId, WORD wPos,
                DWORD dwStyle, DWORD dwExtendStyle,
                CString szText );

    CItemInfo( LPRESITEM lpResItem, WORD wTabPos );

    CItemInfo( const CItemInfo &iteminfo );

    WORD    GetId()         { return LOWORD(m_dwPosId); }
    CString GetCaption()    { return m_szCaption; }
    WORD    GetX()          { return m_wX; }
    WORD    GetY()          { return m_wY; }
    WORD    GetcX()         { return m_wCX; }
    WORD    GetcY()         { return m_wCY; }
    DWORD   GetPosId()      {
		if (LOWORD(m_dwPosId)==0xFFFF)
            return GetTabPosId();
        return m_dwPosId;
    }
    DWORD   GetStyle()      { return m_dwStyle; }
    DWORD   GetExtStyle()   { return m_dwExtStyle; }
    DWORD   GetTabPosId();
    CString GetFaceName()   { return m_szFaceName; }
    CString GetClassName()  { return m_szClassName; }
    DWORD   GetCheckSum()   { return m_dwCheckSum; }
    DWORD   GetFlags()      { return m_dwFlags; }
    DWORD   GetCodePage()   { return m_dwCodePage; }
    DWORD   GetLanguage()   { return m_dwLanguage; }
    WORD    GetClassNameID(){ return m_wClassName; }
    WORD    GetPointSize()  { return m_wPointSize; }
    WORD    GetWeight()     { return m_wWeight; }
    BYTE    GetItalic()     { return m_bItalic; }
    BYTE    GetCharSet()    { return m_bCharSet; }



    UINT    UpdateData( LPVOID lpbuffer, UINT uiBufSize );
    UINT    UpdateData( LPRESITEM lpResItem );

    void    SetPos( WORD wPos );
    void    SetId( WORD wId );

private:

    WORD    m_wX;
    WORD    m_wY;

    WORD    m_wCX;
    WORD    m_wCY;

    DWORD   m_dwCheckSum;
    DWORD   m_dwStyle;
    DWORD   m_dwExtStyle;
    DWORD   m_dwFlags;

    DWORD   m_dwPosId;
    WORD    m_wTabPos;

    DWORD   m_dwCodePage;
    DWORD   m_dwLanguage;
    WORD    m_wClassName;
    WORD    m_wPointSize;
    WORD    m_wWeight;
    BYTE    m_bItalic;
    BYTE    m_bCharSet;

    CString m_szClassName;
    CString m_szFaceName;
    CString m_szCaption;

};

// This class will keep all the information about each of the resources in the file
class CResInfo : public CObject
{
public:
    CResInfo( WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset, CFileModule* pFileModule );

    ~CResInfo();

    WORD    GetTypeId()
        { return m_TypeId; }
    CString GetTypeName()
        { return m_TypeName; }

    WORD    GetResId()
        { return m_ResId; }
    CString GetResName()
        { return m_ResName; }

    DWORD   GetSize()
        { return m_dwImageSize; }

    DWORD   GetFileOffset()
        { return m_FileOffset; }

    DWORD   GetLanguage()
        { return (DWORD)LOWORD(m_Language); }

    DWORD   GetAllLanguage()
        { return m_Language; }

    BOOL    GetUpdImage()
        { return m_ImageUpdated; }

    DWORD   LoadImage( CString lpszFilename, HINSTANCE hInst );
    void    FreeImage();

    DWORD   ParseImage( HINSTANCE hInst );
    DWORD   GetImage( LPCSTR lpszFilename, HINSTANCE hInst, LPVOID lpbuffer, DWORD dwBufSize );
    DWORD   UpdateImage( LONG dwSize, HINSTANCE hInst, LPCSTR lpszType );
    DWORD   ReplaceImage( LPVOID lpNewImage, DWORD dwNewImageSize, DWORD dwLang );

    UINT    GetData( LPCSTR lpszFilename, HINSTANCE hInst,
                     DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize );

    UINT    UpdateData(  LPCSTR lpszFilename, HINSTANCE hInst,
                         DWORD dwItem, LPVOID lpbuffer, UINT uiBufSize );

    void    SetFileOffset( DWORD dwOffset )
        { m_FileOffset = dwOffset; }

	void    SetFileSize( DWORD dwSize )
        { m_FileSize = dwSize; }

    void    SetImageUpdated( BYTE bStatus )
        { m_ImageUpdated = bStatus; }

    void    FreeItemArray();

    DWORD   EnumItem( LPCSTR lpszFilename, HINSTANCE hInst, DWORD dwPrevItem );
    UINT    Copy( CResInfo* pResInfo, CString szFileName, HINSTANCE hInst );
    UINT    CopyImage( CResInfo* pResInfo );
    int     AddItem( CItemInfo ItemInfo );

private:
    DWORD       m_FileOffset;
    DWORD       m_FileSize;

    DWORD       m_Language;

    CString     m_TypeName;
    WORD        m_TypeId;

    CString     m_ResName;
    WORD        m_ResId;

    BYTE far *  m_lpImageBuf; // This is a pointer to the raw data in the resource
    DWORD       m_dwImageSize;
    BYTE        m_ImageUpdated;

    CObArray    m_ItemArray;
    int         m_ItemPos;

    //
    // FileModule the resource belongs to
    //

    CFileModule* m_pFileModule;

    UINT    AllocImage(DWORD dwSize);
};

// This class has all the information we need on each of the modules that the user
// open. When the DLL is discarded this class will clean all the memory allocated.
class CFileModule : public CObject
{
public:
    CFileModule();
    CFileModule( LPCSTR, LPCSTR, int, DWORD );
    ~CFileModule();

    LPCSTR  EnumType( LPCSTR lpszPrevType );
    LPCSTR  EnumId( LPCSTR lpszType, LPCSTR lpszPrevId );
    DWORD   EnumLang( LPCSTR lpszType, LPCSTR lpszId, DWORD dwPrevLang );
    DWORD   EnumItem( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwPrevItem );

    HINSTANCE   LoadDll();      // Load the Dll Hinstance
    void        FreeDll();      // Free the DLL hInstance
    UINT        CleanUp();      // Clean the module memory

    HINSTANCE GetHInstance()
        { return m_DllHInstance; }

    CString GetName()
        { return m_SrcFileName; }
    CString GetRDFName()
        { return m_RdfFileName; }

    CResInfo* GetResInfo( LPCSTR lpszType, LPCSTR lpszId, DWORD dwPrevLang );
    CResInfo* GetResInfo( int iPos )
        { return ((CResInfo*)m_ResArray.GetAt(iPos)); }

    DWORD   GetImage( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang,
                      LPVOID lpbuffer, DWORD dwBufSize );

    DWORD   UpdateImage( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang,
                      DWORD dwUpdLang, LPVOID lpbuffer, DWORD dwBufSize );

    UINT    GetData( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwItem,
                     LPVOID lpbuffer, UINT uiBufSize );

    UINT    UpdateData( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwItem,
                        LPVOID lpbuffer, UINT uiBufSize );

    int AddTypeInfo( INT_PTR iPos, int iId, CString szId );

    int AddResInfo(
              WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset );

    void GenerateIdTable( LPCSTR lpszType, BOOL bNameOrID );

    UINT WriteUpdatedResource( LPCSTR lpszTgtfilename, HANDLE hFileModule, LPCSTR lpszSymbolPath );


    void SetResBufSize( UINT uiSize )   { m_ResBufSize = uiSize;}
    UINT GetResBufSize()                { return m_ResBufSize;}
    UINT Copy( CFileModule* pFileModule );
    UINT CopyImage( CFileModule* pFileModule, LPCSTR lpszType, LPCSTR lpszResId );

    UINT GetLanguageStr( LPSTR lpszLanguage );

private:
    CString     m_SrcFileName;      // The filename of the file to process
    CString     m_RdfFileName;      // The filename of the RDF file
    UINT        m_DllTypeEntry;     // The CDLLTable position for the file type
    HINSTANCE   m_DllHInstance;     // The HINSTANCE to the dll
    DWORD       m_dwFlags;          // IODLL and RW flags

    CObArray    m_ResArray;         // Array of all the Resources in the file.
    UINT        m_ResBufSize;       // Will be usefull when we have to write the resource

    int         m_TypePos;          // Position in the ResArray for the last enum type
    CWordArray  m_TypeArray;        // Array of resource types in the file

    int         m_IdPos;
    CWordArray  m_IdArray;          // Array of resource id of a types in the file

    int         m_LangPos;
    CWordArray  m_LangArray;        // Array of Language if of a given type/id

    char m_IdStr[100];              // Resource name
    char m_TypeStr[100];            // Type name
	char m_LastTypeName[100];
	LPSTR m_LastTypeID;
};

// This class will old the information on each entry in the INI file related with the
// R/W modules. When the DLL will be discarded the memory will be cleaned.
class CDllEntryTable : public CObject
{
public:
    CDllEntryTable( CString szEntry );
	~CDllEntryTable();

    CString GetType( ) { return m_szDllType; }
    CString GetName( ) { return m_szDllName; }
	HINSTANCE  LoadEntry( );
	BOOL	FreeEntry( );
private:
    CString     m_szDllName;        // Dll Name and directory
    CString     m_szDllType;        // Dll type tag
	HINSTANCE 	m_handle;
};

// This class is a dinamyc array of CDllEntryTable elements.
// When the DLL is initialized the class read the INI file and is ready with the information
// on each of the RW Modules present on the hard disk. When the DLL il discarded the Class
// will take care to delete all the entry allocated.
class CDllTable : public CObArray
{
public:
    CDllTable( UINT );
    ~CDllTable();

    UINT GetPosFromTable( CString szFileType );
    UINT GetMaxEntry() { return m_MaxEntry; }

private:
    UINT m_MaxEntry;
    UINT m_InitNum;
};

class CModuleTable : public CObArray
{
public:
    CModuleTable( UINT );
    ~CModuleTable();

private:
    UINT m_LastHandle;
    UINT m_InitNum;
};

/////////////////////////////////////////////////////////////////////////////
// Global variables
CDllTable gDllTable(MAXENTRYBUF);       // When the DLL is initialized the constructor is called
CModuleTable gModuleTable(2);           // When the DLL is initialized the constructor is called

TCHAR szDefaultRcdata[][MAXKEYLEN] = { "kernel32.dll,rcdata1.dll" };
TCHAR szDefaultRWDll[][MAXKEYLEN] = {"rwwin16.dll,WIN16",
                                     "rwwin32.dll,WIN32",
                                     "rwmac.dll,MAC",
                                     "rwres32.dll,RES32",
                                     "rwinf.dll,INF"};

static BYTE sizeofWord = sizeof(WORD);
static BYTE sizeofDWord = sizeof(DWORD);
static BYTE sizeofDWordPtr = sizeof(DWORD_PTR);
static BYTE sizeofByte = sizeof(BYTE);

/////////////////////////////////////////////////////////////////////////////
// Public C interface implementation

static UINT CopyFile( const char * pszfilein, const char * pszfileout );
static BYTE Allign(LONG bLen);
void CheckError(LPCSTR szStr);

int			g_iDllLoaded;
SETTINGS	g_Settings;

////////////////////////////////////////////////////////////////////////////
// RDF File support code

HANDLE
OpenModule(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,
	DWORD    dwFlags );


//--------------------------------------------------------------------------------------------
//********************************************************************************************
//      Global Settings API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSSetGlobals(
	SETTINGS	Settings)         // Set the global variable, like CP to use.
{
	g_Settings.cp = Settings.cp;
    g_Settings.bAppend = Settings.bAppend;
    g_Settings.bUpdOtherResLang = Settings.bUpdOtherResLang;
    strncpy(g_Settings.szDefChar, Settings.szDefChar, 1);
    g_Settings.szDefChar[1] = '\0';

	return 1;
}

extern "C"
DllExport
UINT
APIENTRY
RSGetGlobals(
	LPSETTINGS	lpSettings)         // Retrieve the global variable
{
	lpSettings->cp = g_Settings.cp;
    lpSettings->bAppend = g_Settings.bAppend;
    lpSettings->bUpdOtherResLang = g_Settings.bUpdOtherResLang;
    strncpy(lpSettings->szDefChar, g_Settings.szDefChar, 1);
    lpSettings->szDefChar[1] = '\0';



	return 1;
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Module Opening/Closing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
HANDLE
APIENTRY
RSOpenModule(
    LPCSTR   lpszSrcfilename,    // File name of the executable to use as source file
    LPCSTR   lpszfiletype )      // Type of the executable file if known
{
    return OpenModule(lpszSrcfilename, lpszfiletype, NULL, 0 );
}

extern "C"
DllExport
HANDLE
APIENTRY
RSOpenModuleEx(
	LPCSTR   lpszSrcfilename,       // File name of the executable to use as source file
	LPCSTR   lpszfiletype,			// Type of the executable file if known
	LPCSTR   lpszRDFfile,           // Resource Description File (RDF)
    DWORD    dwFlags )              // HIWORD=rw flags LOWORD=iodll flags
{
	// Check if we have a RDF file defined
	if(lpszRDFfile) {
		return OpenModule(lpszSrcfilename, lpszfiletype, lpszRDFfile, dwFlags );
	}
	else
		return OpenModule(lpszSrcfilename, lpszfiletype, NULL, dwFlags );
}

extern "C"
DllExport
HANDLE
APIENTRY
RSCopyModule(
    HANDLE  hSrcfilemodule,         // Handle to the source file
    LPCSTR   lpszModuleName,            // Name of the new module filename
    LPCSTR  lpszfiletype )          // Type of the target module
{
    TRACE2("IODLL.DLL: RSCopyModule: %d %s\n", (int)hSrcfilemodule, lpszfiletype);
    UINT uiError = ERROR_NO_ERROR;
    INT_PTR uiHandle = 0 ;

    // Check if the type is not null
    CString szSrcFileType;
    if (!lpszfiletype) {
        return UlongToHandle(ERROR_IO_TYPE_NOT_SUPPORTED);
    } else szSrcFileType = lpszfiletype;

    gModuleTable.Add(new CFileModule( (LPSTR)lpszModuleName,
                                      NULL,
                                      gDllTable.GetPosFromTable(szSrcFileType),
                                      0 ));

    // Get the position in the array.
    uiHandle = gModuleTable.GetSize();

    // Read the informations on the type in the file.
    CFileModule* pFileModule = (CFileModule*)gModuleTable.GetAt(uiHandle-1);

    if (!pFileModule)
        return UlongToHandle(ERROR_IO_INVALIDMODULE);

    // We have to copy the information from the source module
    INT_PTR uiSrcHandle = (UINT_PTR)hSrcfilemodule-FIRSTVALIDVALUE-1;
    if (uiSrcHandle<0)
        return (HANDLE)(ERROR_HANDLE_INVALID);
    CFileModule* pSrcFileModule = (CFileModule*)gModuleTable.GetAt((UINT)uiSrcHandle);
    if (!pSrcFileModule)
        return (HANDLE)(ERROR_IO_INVALIDMODULE);

    if (pSrcFileModule->Copy( pFileModule ))
        return (HANDLE)(ERROR_IO_INVALIDITEM);

    pFileModule->SetResBufSize( pSrcFileModule->GetResBufSize() );

    return (HANDLE)(uiHandle+FIRSTVALIDVALUE);
}


extern "C"
DllExport
UINT
APIENTRY
RSCloseModule(
    HANDLE  hResFileModule )    // Handle to the session opened before
{
    TRACE1("IODLL.DLL: RSCloseModule: %d\n", (int)hResFileModule);
    UINT uiError = ERROR_NO_ERROR;

    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0)
        return ERROR_HANDLE_INVALID;

    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    uiError = pFileModule->CleanUp();

    return uiError;
}

extern "C"
DllExport
HANDLE
APIENTRY
RSHandleFromName(
	LPCSTR   lpszfilename )        // Handle to the session with the file name specified
{
    TRACE("IODLL.DLL: RSHandleFromName: %s\n", lpszfilename);

    INT_PTR UpperBound = gModuleTable.GetUpperBound();
    CFileModule* pFileModule;
    while( UpperBound!=-1 ) {
        pFileModule = (CFileModule*)gModuleTable.GetAt(UpperBound);
        if(pFileModule->GetName()==lpszfilename)
            return (HANDLE)(UpperBound+FIRSTVALIDVALUE+1);
        UpperBound--;
    }

    return (HANDLE)0;
}


//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Enumeration API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
LPCSTR
APIENTRY
RSEnumResType(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszPrevResType)    // Previously enumerated type
{
    TRACE2("IODLL.DLL: RSEnumResType: %u %Fp\n", (UINT)hResFileModule,
                                                 lpszPrevResType);

    // By now all the information on the types should be here.
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0)
        return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return LPNULL;

    return pFileModule->EnumType( lpszPrevResType );
}

extern "C"
DllExport
LPCSTR
APIENTRY
RSEnumResId(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszPrevResId)      // Previously enumerated id
{
    TRACE3("IODLL.DLL: RSEnumResId: %u %Fp %Fp\n", (UINT)hResFileModule,
                                                   lpszResType,
                                                   lpszPrevResId);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    return pFileModule->EnumId( lpszResType, lpszPrevResId );
}

extern "C"
DllExport
DWORD
APIENTRY
RSEnumResLang(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwPrevResLang)      // Previously enumerated language
{
    TRACE3("IODLL.DLL: RSEnumResLang: %u %Fp %Fp ", (UINT)hResFileModule,
                                                    lpszResType,
                                                    lpszResId);
    TRACE1("%ld\n", dwPrevResLang);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->EnumLang( lpszResType, lpszResId, dwPrevResLang );
}

extern "C"
DllExport
DWORD
APIENTRY
RSEnumResItemId(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwPrevResItemId)    // Previously enumerated item id
{
    TRACE3("IODLL.DLL: RSEnumResItemId: %u %Fp %Fp ", (UINT)hResFileModule,
                                                      lpszResType,
                                                      lpszResId);
    TRACE2("%ld %Fp\n", dwResLang,
                      dwPrevResItemId);

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->EnumItem( lpszResType, lpszResId, dwResLang, dwPrevResItemId );
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Data acquisition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSGetResItemData(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwResItemId,        // Previously enumerated item id
    LPVOID  lpbuffer,           // Pointer to the buffer that will get the resource info
    UINT    uiBufSize)          // Size of the buffer that will hold the resource info
{
    TRACE3("IODLL.DLL: RSGetResItemData: %u %Fp %Fp ", (UINT)hResFileModule,
                                                       lpszResType,
                                                       lpszResId);
    TRACE3("%ld %Fp %Fp ", dwResLang,
                           dwResItemId,
                           lpbuffer);
    TRACE1("%d\n", uiBufSize);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->GetData( lpszResType, lpszResId, dwResLang, dwResItemId,
                                 lpbuffer, uiBufSize );
}

extern "C"
DllExport
DWORD
APIENTRY
RSGetResImage(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    LPVOID  lpbuffer,           // Pointer to the buffer to get the resource Data
    DWORD   dwBufSize)          // Size of the allocated buffer
{
    TRACE3("IODLL.DLL: RSGetResImage: %u %Fp %Fp ", (UINT)hResFileModule,
                                                    lpszResType,
                                                    lpszResId);
    TRACE2("%ld %Fp ", dwResLang,
                       lpbuffer);
    TRACE1("%lu\n", dwBufSize);

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->GetImage( lpszResType, lpszResId, dwResLang, lpbuffer, dwBufSize );
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Update API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSUpdateResItemData(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwResItemId,        // Previously enumerated items id
    LPVOID  lpbuffer,           // Pointer to the buffer to the resource item Data
    UINT    uiBufSize)          // Size of the buffer
{
    TRACE3("IODLL.DLL: RSUpdateResItemData: %u %Fp %Fp ", (UINT)hResFileModule,
                                                          lpszResType,
                                                          lpszResId);
    TRACE3("%ld %Fp %Fp ", dwResLang,
                           dwResItemId,
                           lpbuffer);
    TRACE1("%u\n", uiBufSize);
    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->UpdateData( lpszResType, lpszResId, dwResLang, dwResItemId,
                                    lpbuffer, uiBufSize );
}

extern "C"
DllExport
DWORD
APIENTRY
RSUpdateResImage(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszResType,        // Previously enumerated type
    LPCSTR  lpszResId,          // Previously enumerated id
    DWORD   dwResLang,          // Previously enumerated language
    DWORD   dwUpdLang,          // Desired output language
    LPVOID  lpbuffer,           // Pointer to the buffer to the resource item Data
    DWORD   dwBufSize)          // Size of the buffer
{
    TRACE3("IODLL.DLL: RSUpdateResImage: %d %Fp %Fp ", hResFileModule,
                                                       lpszResType,
                                                       lpszResId);
    TRACE("%Fp %Fp %Fp ", dwResLang,
                           lpbuffer);
    TRACE1("%d\n", dwBufSize);
    UINT uiError = ERROR_NO_ERROR;

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;

    return pFileModule->UpdateImage( lpszResType, lpszResId, dwResLang,
                                     dwUpdLang, lpbuffer, dwBufSize );

    return (DWORD)uiError;
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Conversion API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSUpdateFromResFile(
    HANDLE  hResFileModule,     // Handle to the file session
    LPSTR   lpszResFilename)    // The resource filename to be converted
{
    TRACE2("IODLL.DLL: RSUpdateFromResFile: %d %s\n", hResFileModule,
                                                       lpszResFilename);
    UINT uiError = 0;
    const int       CBSTRMAX        = 8192;
    BOOL            fReturn         = TRUE;
    HANDLE          hResFileSrc     = NULL;
    LPCSTR          lpszTypeSrc     = NULL;
    LPCSTR          lpszResSrc      = NULL;
    DWORD           dwLangSrc       = 0L;
    DWORD           dwLangDest      = 0L;
    DWORD           dwItemSrc       = 0L;
    DWORD           dwItemDest      = 0L;
    WORD            cbResItemSrc    = 0;
    WORD            cbResItemDest   = 0;
    LPRESITEM       lpriSrc         = NULL;
    LPRESITEM       lpriDest        = NULL;

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return ERROR_HANDLE_INVALID;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];
    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;


    // Initialize storage for ResItem
    if (lpriSrc = (LPRESITEM)malloc(CBSTRMAX))
        cbResItemSrc = CBSTRMAX;
    else {
        AfxThrowMemoryException();
    }

    // Read in the resource files
    if ((UINT_PTR)(hResFileSrc = RSOpenModule((LPSTR)lpszResFilename, "RES32")) <= 100) {
        uiError = (UINT)(UINT_PTR)hResFileSrc;
        if (lpriSrc)
            free(lpriSrc);
        return uiError;
    }

    // Get the File Module of the Resource file. This is needed for the image conversion

    CFileModule* pResFileModule = (CFileModule*)gModuleTable[(UINT)((UINT_PTR)hResFileSrc-FIRSTVALIDVALUE-1)];
    if(!pResFileModule)
    	return ERROR_IO_INVALIDMODULE;

    while (lpszTypeSrc = RSEnumResType(hResFileSrc,
                                        lpszTypeSrc)) {
        while (lpszResSrc = RSEnumResId(hResFileSrc,
                                         lpszTypeSrc,
                                         lpszResSrc)) {
			// Hack Hack, This is done to handle Bitmap conversion
            // Will need to be done better after the Chicago release
            switch(LOWORD(lpszTypeSrc)) {
            	case 2:
            		TRACE("Here we will have to swap the images!\n");
            		pFileModule->CopyImage( pResFileModule, lpszTypeSrc, lpszResSrc );
            	break;
            	default:
            	break;
            }
            while (dwLangSrc = RSEnumResLang(hResFileSrc,
                                              lpszTypeSrc,
                                              lpszResSrc,
                                              dwLangSrc)) {
                while (dwItemSrc = RSEnumResItemId(hResFileSrc,
                                                    lpszTypeSrc,
                                                    lpszResSrc,
                                                    dwLangSrc,
                                                    dwItemSrc)){

                    WORD wSize;
                    wSize = (WORD)RSGetResItemData(hResFileSrc,
                                             lpszTypeSrc,
                                             lpszResSrc,
                                             dwLangSrc,
                                             dwItemSrc,
                                             (LPRESITEM)lpriSrc,
                                             cbResItemSrc);

                    if (cbResItemSrc < wSize) {
                        if (lpriSrc = (LPRESITEM)realloc(lpriSrc, wSize))
                            cbResItemSrc = wSize;
                        else
                            AfxThrowMemoryException();
                        RSGetResItemData(hResFileSrc,
                                         lpszTypeSrc,
                                         lpszResSrc,
                                         dwLangSrc,
                                         dwItemSrc,
                                         (LPRESITEM)lpriSrc,
                                         cbResItemSrc);
                    }

                    if ((uiError = RSUpdateResItemData(hResFileModule,
                                                   lpszTypeSrc,
                                                   lpszResSrc,
                                                   1033,
                                                   dwItemSrc,
                                                   lpriSrc,
                                                   cbResItemSrc)) != 0) {
                        /*
                        if (lpriSrc)
                            free(lpriSrc);
                        RSCloseModule(hResFileSrc);
                        return uiError;
                        */
                    }
                }
            }
        }
    }


    // Save out to the updated resource file, same format.
    RSCloseModule(hResFileSrc);

    // The user want to write the file with the same format as the original
    uiError = pFileModule->WriteUpdatedResource( pFileModule->GetName(), hResFileModule, NULL);

    // Clean up
    return uiError;
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Writing API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSWriteResFile(
    HANDLE  hResFileModule,     // Handle to the file session
    LPCSTR  lpszTgtfilename,    // The new filename to be generated
    LPCSTR  lpszTgtfileType,    // Target Resource type 16/32
    LPCSTR  lpszSymbolPath)     // Symbol Path for updating symbol checksum
{
    TRACE3("IODLL.DLL: RSWriteResFile: %d %s %s\n", hResFileModule,
                                                      lpszTgtfilename,
                                                      lpszTgtfileType);
    UINT uiError = ERROR_NO_ERROR;

    // Check the HANDLE and see if it is a valid one
    INT_PTR uiHandle = (UINT_PTR)hResFileModule-FIRSTVALIDVALUE-1;
    if (uiHandle<0) return ERROR_HANDLE_INVALID;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return ERROR_IO_INVALIDMODULE;


    if(lpszTgtfileType!=LPNULL) {
        // The user want a conversion.
        // Check if the type the user want is one of the supported one
        CDllEntryTable* pDllEntry;
        INT_PTR iUpperBound = gDllTable.GetUpperBound();
        while(iUpperBound>=0) {
            pDllEntry = (CDllEntryTable*) gDllTable.GetAt(iUpperBound);
            if ( (pDllEntry) && (pDllEntry->GetType()==lpszTgtfileType) )
                    iUpperBound = -1;
            iUpperBound--;
        }
        if (iUpperBound==-1)
            return ERROR_IO_TYPE_NOT_SUPPORTED;

        // We will open a new module now.
        // We will generate the images from the other module
        HANDLE hTgtFileHandle = RSCopyModule( hResFileModule, LPNULL, lpszTgtfileType );
        if ((UINT_PTR)hTgtFileHandle<=FIRSTVALIDVALUE)
            return ((UINT)(UINT_PTR)hTgtFileHandle);

        // Write the file
        CFileModule* pNewFileModule = (CFileModule*)gModuleTable[(UINT)((UINT_PTR)hTgtFileHandle-FIRSTVALIDVALUE-1)];
        if (!pNewFileModule)
            return ERROR_IO_INVALIDMODULE;

        uiError = pNewFileModule->WriteUpdatedResource( lpszTgtfilename, hTgtFileHandle, lpszSymbolPath );

        // Close the module we just create
        RSCloseModule(hTgtFileHandle);
        return uiError;
    }

    // The user want to write the file with the same format as the original
    return pFileModule->WriteUpdatedResource( lpszTgtfilename,
                                              hResFileModule,
                                              lpszSymbolPath);
}

//--------------------------------------------------------------------------------------------
//********************************************************************************************
//  Recognition API
//--------------------------------------------------------------------------------------------

extern "C"
DllExport
UINT
APIENTRY
RSFileType(
    LPCSTR   lpszfilename,   // File name of the executable to use as source file
    LPSTR   lpszfiletype )  // Type of the executable file if known
{
    //Get the executable file format querying all the R/W DLL
    INT_PTR UpperBound = gDllTable.GetUpperBound();
    int c = 0;
    CDllEntryTable* pDllEntry;
    while(c<=UpperBound) {
        // Get the module name
        pDllEntry = (CDllEntryTable*) gDllTable.GetAt(c);

        if (!pDllEntry)
            return ERROR_IO_INVALID_DLL;
        // Get the handle to the dll and query validate
        HINSTANCE hInst = pDllEntry->LoadEntry();

        if (hInst) {
            BOOL (FAR PASCAL * lpfnValidateFile)(LPCSTR);
            // Get the pointer to the function to extract the resources
            lpfnValidateFile = (BOOL (FAR PASCAL *)(LPCSTR))
                                GetProcAddress( hInst, "RWValidateFileType" );
            if (lpfnValidateFile==NULL) {
                return ERROR_DLL_PROC_ADDRESS;
            }
            if( (*lpfnValidateFile)((LPCSTR)lpszfilename) ) {
                // this DLL can handle the file type
                strcpy(lpszfiletype, pDllEntry->GetType());
                return ERROR_NO_ERROR;
            }
        }
		else {
            CheckError("(RSFileType) LoadLibrary()" + pDllEntry->GetName());
		}

        c++;
    }
    strcpy(lpszfiletype, "");
    return ERROR_IO_TYPE_NOT_SUPPORTED;
}


////////////////////////////////////////////////////////////////////////////
// Return TRUE if the file has more than one language.
// Will fill the lpszLanguage with a list of the languages in the file
////////////////////////////////////////////////////////////////////////////
extern "C"
DllExport
UINT
APIENTRY
RSLanguages(
	HANDLE  hfilemodule,      // Handle to the file
	LPSTR   lpszLanguages )   // will be filled with a string of all the languages in the file
 {
    INT_PTR uiHandle = (UINT_PTR)hfilemodule-FIRSTVALIDVALUE-1;
    if (uiHandle<0)
        return LPNULL;

    // Get the File module
    CFileModule* pFileModule = (CFileModule*)gModuleTable[(UINT)uiHandle];

    if (!pFileModule)
        return LPNULL;

    return pFileModule->GetLanguageStr(lpszLanguages);
}


////////////////////////////////////////////////////////////////////////////
// Class implementation
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// CFileModule

CFileModule::CFileModule()
{
    //TRACE("IODLL.DLL: CFileModule::CFileModule\n");

    m_SrcFileName = "";
    m_RdfFileName = "";
    m_DllTypeEntry = 0; // Invalid position
    m_DllHInstance = 0; // Not loaded yet
    m_TypePos = 0;
    m_IdPos = 0;
    m_LangPos = 0;
    m_LastTypeName[0] = '\0';
	m_LastTypeID = LPNULL;
    m_IdStr[0] = '\0';
    m_dwFlags = 0;

	m_ResArray.SetSize(100,10);
	m_TypeArray.SetSize(100,10);
	m_IdArray.SetSize(100,10);
    m_LangArray.SetSize(100,10);
}

CFileModule::CFileModule( LPCSTR lpszSrcfilename,
                          LPCSTR lpszRdffilename,
                          int DllTblPos,
                          DWORD dwFlags)
{
    //TRACE2("IODLL.DLL: CFileModule::CFileModule %s %d\n", lpszSrcfilename,
    //                                                    DllTblPos );


    m_SrcFileName = lpszSrcfilename;
    if(!lpszRdffilename)
    {
        CString strMap;

        // assign a default name
        m_RdfFileName = lpszSrcfilename;

        // remove the the path...
        int iPos = m_RdfFileName.ReverseFind('\\');
        if(iPos!=-1)
            m_RdfFileName = m_RdfFileName.Mid(iPos+1);

        // Get name from INI file
        GetProfileString("IODLL-RCDATA", m_RdfFileName, "", strMap.GetBuffer(MAX_PATH), MAX_PATH);
        strMap.ReleaseBuffer();

        if(strMap.IsEmpty())
        {
            //
            //  Not found in win.ini, we use default.
            //
            int c = 0;
            int iMax = sizeof(szDefaultRcdata)/sizeof(TCHAR)/MAXKEYLEN;
            PCHAR pstr;
            CString Entry;

            for ( pstr = szDefaultRcdata[0]; c< iMax; pstr += MAXKEYLEN, c++)
            {
                Entry = pstr;
                if(Entry.Find (m_RdfFileName) !=-1)
                {
                    strMap = Entry.Mid(lstrlen(m_RdfFileName)+1);
                    break;
                }
            }
        }

        if (!strMap.IsEmpty())
        {
            m_RdfFileName = strMap;
            // we will use the dll in the directory from were we have been spawned
            GetModuleFileName( NULL, strMap.GetBuffer(MAX_PATH), MAX_PATH );
            strMap.ReleaseBuffer(-1);

            // remove the file name
            iPos = strMap.ReverseFind('\\');
            if(iPos!=-1)
                strMap = strMap.Left(iPos+1);

            // append the path to the file name
            m_RdfFileName = strMap + m_RdfFileName;
        }
        else
        {
            m_RdfFileName = "";
        }
    }
    else m_RdfFileName = lpszRdffilename;

    m_SrcFileName.MakeUpper();
    m_DllTypeEntry = DllTblPos;
    m_DllHInstance = 0; // Not loaded yet

    m_TypePos = 0;
    m_IdPos = 0;
    m_LangPos = 0;
    m_LastTypeName[0] = '\0';
	m_LastTypeID = LPNULL;
    m_IdStr[0] = '\0';
    m_dwFlags = dwFlags;
}

CFileModule::~CFileModule()
{
    TRACE("IODLL.DLL: CFileModule::~CFileModule\n");
    CleanUp();
}

HINSTANCE CFileModule::LoadDll()
{
    if (!(m_DllHInstance) && (m_DllTypeEntry))
        if((m_DllHInstance = ((CDllEntryTable*)gDllTable[m_DllTypeEntry-1])->LoadEntry())==NULL) {
            CheckError("(CFileModule::LoadDll) LoadLibrary() for " + ((CDllEntryTable*)gDllTable[m_DllTypeEntry-1])->GetName() );
        } else
            TRACE("CFileModule::LoadDll call %d --->> %08x\n", g_iDllLoaded++, m_DllHInstance);
    return m_DllHInstance;
}

void
CFileModule::FreeDll()
{
    TRACE("IODLL.DLL: CFileModule::FreeDll() m_DllHInstance=%08x\n", m_DllHInstance );

    if (m_DllHInstance)
    	m_DllHInstance = 0;
}

UINT
CFileModule::CleanUp()
{
    INT_PTR UpperBound = m_ResArray.GetUpperBound();
    TRACE1("IODLL.DLL: CFileModule::CleanUp %d\n", UpperBound);

    // Free the memory for the resource information
    CResInfo* pResInfo;
    for(INT_PTR c=0; c<=UpperBound; c++) {
        pResInfo = (CResInfo*)m_ResArray.GetAt(c);
        TRACE("\tCFileModule\t%d\tCResInfo->%Fp\n", c, pResInfo);
        delete pResInfo;
    }
    m_ResArray.RemoveAll();

    // Unload the DLL
	FreeDll();

    return 0;
}

int
CFileModule::AddResInfo(
              WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset )
{
    return (int)m_ResArray.Add( new CResInfo(
        Typeid,
        sztypeid,
        nameid,
        sznameid,
        dwlang,
        dwsize,
        dwfileoffset,
        this
        ));
}

int
CFileModule::AddTypeInfo( INT_PTR iPos, int iId, CString szId )
{
    //TRACE3("IODLL.DLL: CFileModule::AddTypeInfo %d %d %Fp\n", iPos, iId, szId);
    INT_PTR  UpperBound = m_TypeArray.GetUpperBound();

    for( INT_PTR c = 0; c<=UpperBound; c++) {
        int pos = m_TypeArray.GetAt(c);
        CResInfo* pResPos = (CResInfo*)m_ResArray.GetAt(pos);
        CResInfo* pResLast = (CResInfo*)m_ResArray.GetAt(iPos);

        if( ((pResPos->GetTypeId()==pResLast->GetTypeId()) &&
             (pResPos->GetTypeName()==pResLast->GetTypeName())
            )) return 0;
    }
    //TRACE3("IODLL.DLL: CFileModule::AddTypeInfo %d %d %Fp\n", iPos, iId, szId);
    m_TypeArray.Add( (WORD)iPos );
    return 1;
}

UINT
CFileModule::GetLanguageStr( LPSTR lpszLanguage )
{
    CResInfo* pResInfo;
    CString strLang = "";
    char szLang[8];
    BOOL multi_lang = FALSE;

    for(INT_PTR c=0, iUpperBound = m_ResArray.GetUpperBound(); c<=iUpperBound; c++) {
        pResInfo = (CResInfo*)m_ResArray.GetAt(c);

        // Convert the language in to the hex value
        sprintf(szLang,"0x%3.3X", pResInfo->GetLanguage());

        // check if the language is already in the string
        if(strLang.Find(szLang)==-1)
        {
            if(!strLang.IsEmpty())
            {
                multi_lang = TRUE;
                strLang += ", ";
            }

            strLang += szLang;
        }
    }

    strcpy( lpszLanguage, strLang );

    return multi_lang;
}

CResInfo*
CFileModule::GetResInfo( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang )
{
    BOOL fIdName = HIWORD(lpszId);
    BOOL fTypeName = HIWORD(lpszType);
    CResInfo*   pResInfo;

    // We must have at least the type to procede
    if(!lpszType)
        return LPNULL;

    for( INT_PTR i = 0, iUpperBoundRes = m_ResArray.GetUpperBound() ; i<=iUpperBoundRes ; i++)
    {
        pResInfo = (CResInfo*)m_ResArray.GetAt(i);
        if(pResInfo)
        {
            if( fTypeName ? !strcmp(pResInfo->GetTypeName(), lpszType) : pResInfo->GetTypeId()==LOWORD(lpszType))
            {
                // do we need the ID and language or can we exit
                if(!lpszId)
                    return pResInfo;

                if( fIdName ? !strcmp(pResInfo->GetResName(), lpszId) : pResInfo->GetResId()==LOWORD(lpszId))
                {
                    // are we done or we want the language as well
                    if((LONG)dwLang==-1)
                        return pResInfo;

                    if( dwLang==pResInfo->GetLanguage() )
                        return pResInfo;
                }
            }
        }
    }

    return LPNULL;
}

DWORD
CFileModule::GetImage(  LPCSTR lpszType,
                        LPCSTR lpszId,
                        DWORD dwLang,
                        LPVOID lpbuffer,
                        DWORD dwBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (!LoadDll()) return 0L;

    if (pResInfo)
        return pResInfo->GetImage( m_SrcFileName, m_DllHInstance, lpbuffer, dwBufSize );

    return 0L;
}

DWORD
CFileModule::UpdateImage(  LPCSTR lpszType,
                        LPCSTR lpszId,
                        DWORD dwLang,
                        DWORD dwUpdLang,
                        LPVOID lpbuffer,
                        DWORD dwBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (!LoadDll()) return 0L;
    if (pResInfo)
        return pResInfo->ReplaceImage(lpbuffer, dwBufSize, dwUpdLang );

    return 0L;
}


UINT
CFileModule::GetData( LPCSTR lpszType,
                      LPCSTR lpszId,
                      DWORD dwLang,
                      DWORD dwItem,
                      LPVOID lpbuffer,
                      UINT uiBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    UINT uiSize = 0;
    if (pResInfo)
        uiSize = pResInfo->GetData( m_SrcFileName, m_DllHInstance,
                                    dwItem, lpbuffer, uiBufSize );

    return uiSize;
}

UINT
CFileModule::UpdateData(  LPCSTR lpszType,
                          LPCSTR lpszId,
                          DWORD dwLang,
                          DWORD dwItem,
                          LPVOID lpbuffer,
                          UINT uiBufSize )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    UINT uiError = ERROR_NO_ERROR;
    if (pResInfo)
        uiError = pResInfo->UpdateData( m_SrcFileName, m_DllHInstance,
                                        dwItem, lpbuffer, uiBufSize );

    return uiError;
}

void
CFileModule::GenerateIdTable( LPCSTR lpszType, BOOL bNameOrId )
{
    m_IdArray.RemoveAll();

    CResInfo* pResInfo;
	for( WORD c=0, UpperBound= (WORD)m_ResArray.GetUpperBound(); c<=UpperBound; c++) {
        pResInfo = (CResInfo*)m_ResArray.GetAt(c);

		if(bNameOrId) {
	        if (pResInfo->GetTypeId() && pResInfo->GetTypeName()=="") {
	            if (pResInfo->GetTypeId()==(WORD)LOWORD((DWORD)(DWORD_PTR)lpszType)) {
	                //TRACE2("IODLL.DLL: CFileModule::EnumId %d %d\n", c,
	                //  (WORD)LOWORD((DWORD)lpszType) );
	                m_IdArray.Add( c );
	            }
				m_LastTypeID = (LPSTR)lpszType;
				m_LastTypeName[0] = '\0';
	        } else {
				if (HIWORD((DWORD)(DWORD_PTR)lpszType)!=0) {
	                if (pResInfo->GetTypeName()==(CString)(lpszType))
	                    m_IdArray.Add( c );
					strcpy(m_LastTypeName, lpszType);
					m_LastTypeID = LPNULL;
				}
	        }
		}
		else {
			if (pResInfo->GetTypeId()) {
	            if (pResInfo->GetTypeId()==(WORD)LOWORD((DWORD)(DWORD_PTR)lpszType)) {
	                //TRACE2("IODLL.DLL: CFileModule::EnumId %d %d\n", c,
	                //  (WORD)LOWORD((DWORD)lpszType) );
	                m_IdArray.Add( c );
	            }
				m_LastTypeID = (LPSTR)lpszType;
				m_LastTypeName[0] = '\0';
	        } else {
				if (HIWORD((DWORD)(DWORD_PTR)lpszType)!=0) {
	                if (pResInfo->GetTypeName()==(CString)(lpszType))
	                    m_IdArray.Add( c );
					strcpy(m_LastTypeName, lpszType);
					m_LastTypeID = LPNULL;
				}
	        }
		}
    }
}

UINT
CFileModule::WriteUpdatedResource( LPCSTR lpszTgtfilename, HANDLE hFileModule, LPCSTR szSymbolPath)
{
    UINT uiError = ERROR_NO_ERROR;
    // We have to check which resource have been updated and
    // generate a list to give back to the RW module
    CResInfo* pResInfo;
    TRACE1("CFileModule::WriteUpdatedResource\tNewSize: %ld\n", (LONG)m_ResBufSize);
    BYTE * pBuf = new BYTE[m_ResBufSize];
    BYTE * pBufStart = pBuf;
    BYTE * pBufPos = pBuf;
    BYTE bPad = 0;
    BOOL bIsTmp = FALSE;
    if (!pBuf)
        return ERROR_NEW_FAILED;
    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    UINT uiBufSize = 0;

	// MAC RW fixes. Since the MAC RW will update images while updating images
	// The list of updated images could potentialy be wrong. We first scan the list for
	// Updated resources and then we will do the same thing to write the list in the buffer.
	// So for instance updating the DLG image will update a DITL connected with
	// the DLG itself. If the DITL was already gone in the for loop we would
	// skip it and never save the DITL image that is now updated.
	for( INT_PTR c=0, UpperBound = m_ResArray.GetUpperBound(); c<=UpperBound ; c++) {
        pResInfo = (CResInfo*) m_ResArray.GetAt(c);
        if(!pResInfo)
            return ERROR_IO_RESINFO_NULL;

        if(!pResInfo->GetFileOffset()) {
            // The offset is null. This mean that the resource has been updated.
            // Check if the image is up to date or not
            if (!pResInfo->GetUpdImage()) {
                DWORD dwSize = pResInfo->UpdateImage( 0,
                                                      m_DllHInstance,
                                                      (LPCSTR)UlongToPtr(pResInfo->GetTypeId()) );
                if (dwSize)
                    if(pResInfo->UpdateImage( dwSize,
                                              m_DllHInstance,
                                              (LPCSTR)UlongToPtr(pResInfo->GetTypeId()))) {
                        delete []pBufStart;
                        return ERROR_IO_UPDATEIMAGE;
                    }
            }
        }
    }

	// Now add the image to the list...
	for( c=0, UpperBound = m_ResArray.GetUpperBound(); c<=UpperBound ; c++) {
        pResInfo = (CResInfo*) m_ResArray.GetAt(c);
        if(!pResInfo)
            return ERROR_IO_RESINFO_NULL;

        if(!pResInfo->GetFileOffset()) {
            // Write the information in the bufer and give it back to the RW module
            pBufPos = pBuf;
            *((WORD*)pBuf) = pResInfo->GetTypeId();
            pBuf += sizeofWord;

            strcpy((char*)pBuf, pResInfo->GetTypeName());
            pBuf += (pResInfo->GetTypeName()).GetLength()+1;

            // Check the allignment
            bPad = Pad4((BYTE)(pBuf-pBufPos));
            while (bPad) {
               *pBuf = 0x00;
               pBuf += 1;
               bPad--;
            }

            *((WORD*)pBuf) = pResInfo->GetResId();
            pBuf += sizeofWord;

            strcpy((char*)pBuf, pResInfo->GetResName());
            pBuf += (pResInfo->GetResName()).GetLength()+1;

            // Check the allignment
            bPad = Pad4((BYTE)(pBuf-pBufPos));
            while (bPad) {
               *pBuf = 0x00;
               pBuf += 1;
               bPad--;
            }

            *((DWORD*)pBuf) = pResInfo->GetAllLanguage();
            pBuf += sizeofDWord;

            *((DWORD*)pBuf) = pResInfo->GetSize();
            pBuf += sizeofDWord;

            uiBufSize += (UINT)(pBuf-pBufPos);

            TRACE1("TypeId: %d\t", pResInfo->GetTypeId());
            TRACE1("TypeName: %s\t", pResInfo->GetTypeName());
            TRACE1("NameId: %d\t", pResInfo->GetResId());
            TRACE1("NameName: %s\t", pResInfo->GetResName());
            TRACE1("ResLang: %lu\t", pResInfo->GetLanguage());
            TRACE1("ResSize: %lu\n", pResInfo->GetSize());

            //TRACE1("uiError: %u\n", uiSize);
        }
    }

    UINT (FAR PASCAL * lpfnWriteFile)(LPCSTR, LPCSTR, HANDLE, LPVOID, UINT, HINSTANCE, LPCSTR);
    // Get the pointer to the function to extract the resources
    lpfnWriteFile = (UINT (FAR PASCAL *)(LPCSTR, LPCSTR, HANDLE, LPVOID, UINT, HINSTANCE, LPCSTR))
                        GetProcAddress( m_DllHInstance, "RWWriteFile" );
    if (lpfnWriteFile==NULL) {
        delete []pBufStart;
        return (DWORD)ERROR_DLL_PROC_ADDRESS;
    }

    CString szTgtFilename = lpszTgtfilename;


    // We have to check if the filename is a full qualified filename
    CFileStatus status;

	strcpy(status.m_szFullName, lpszTgtfilename);
    if (CFile::GetStatus( lpszTgtfilename, status ))
        // The file exist, get the full file name
        szTgtFilename = status.m_szFullName;

    // Generate a temporary file name
    bIsTmp = TRUE;
	CString cszTmpPath;
	DWORD dwRet = GetTempPath( 512, cszTmpPath.GetBuffer(512));
	cszTmpPath.ReleaseBuffer(-1);
	if(dwRet>512 )
		dwRet = GetTempPath( dwRet, cszTmpPath.GetBuffer(dwRet));
	cszTmpPath.ReleaseBuffer(-1);

	if(dwRet==0 || GetFileAttributes(cszTmpPath) != FILE_ATTRIBUTE_DIRECTORY){
		// Failed to get the temporary path fail, default to local dir
		dwRet = GetCurrentDirectory(512, cszTmpPath.GetBuffer(512));
        if(dwRet>512 )
            dwRet = GetCurrentDirectory( dwRet, cszTmpPath.GetBuffer(dwRet));
    }

    GetTempFileName(cszTmpPath, "RLT", 0, szTgtFilename.GetBuffer(_MAX_PATH));
    szTgtFilename.ReleaseBuffer();
	
	szTgtFilename.MakeUpper();

    // Check if the size of the file is bigger that the size on the HD
    if (CFile::GetStatus( m_SrcFileName, status )) {
        // Get drive number
        BYTE ndrive = ((BYTE)*szTgtFilename.GetBuffer(0)-(BYTE)'A')+1;


        // Get the space on the HD
        struct _diskfree_t diskfree;
        if(_getdiskfree(ndrive, &diskfree)) {
            delete []pBufStart;
            return ERROR_OUT_OF_DISKSPACE;
        }
        if ( (status.m_size*3/diskfree.bytes_per_sector)>
             (DWORD)(diskfree.avail_clusters*(DWORD)diskfree.sectors_per_cluster)) {
            delete []pBufStart;
            return ERROR_OUT_OF_DISKSPACE;
        }

    }

	TRY
	{
    uiError = (*lpfnWriteFile)((LPCSTR)m_SrcFileName,
                               (LPCSTR)szTgtFilename,
                               (HANDLE)hFileModule,
                               (LPVOID)pBufStart,
                               (UINT)uiBufSize,
                               (HINSTANCE)NULL,
                               (LPCSTR)szSymbolPath);
    }
    CATCH(CFileException, fe)
    {
        uiError = fe->m_lOsError+LAST_ERROR;
    }
    AND_CATCH( CMemoryException, e )
    {
        uiError = ERROR_NEW_FAILED;
    }
    AND_CATCH( CException, e )
    {
        uiError = ERROR_NEW_FAILED;
    }
    END_CATCH

    delete []pBufStart;

    if ( bIsTmp ) {
        if (uiError < LAST_WRN) {
            TRY {
                //
                // BUG: 409
                // We will rename if on the same drive. Otherwise copy it
                //
                if (_strnicmp( szTgtFilename, lpszTgtfilename, 1 )) {
                    UINT ErrTmp;
    				TRACE("\t\tCopyFile:\tszTgtFilename: %s\tlpszTgtfilename: %s\n", szTgtFilename.GetBuffer(0), lpszTgtfilename);
                    ErrTmp = CopyFile( szTgtFilename, lpszTgtfilename );
                    if (ErrTmp){
                        uiError = ErrTmp+LAST_ERROR;
                    }
                } else {
                    TRACE("\t\tMoveFile:\tszTgtFilename: %s\tlpszTgtfilename: %s\n", szTgtFilename.GetBuffer(0), lpszTgtfilename );
    				// Remove temporary file
    				if(CFile::GetStatus( lpszTgtfilename, status ))
    					CFile::Remove(lpszTgtfilename);
                    CFile::Rename(szTgtFilename, lpszTgtfilename);
                }
    			// Remove temporary file
    			if(CFile::GetStatus( szTgtFilename, status ))
    				CFile::Remove(szTgtFilename);
            }
            CATCH( CFileException, fe )
            {
                uiError = fe->m_lOsError+LAST_ERROR;
            }
            AND_CATCH( CException, e )
            {
                uiError = ERROR_NEW_FAILED;
            }
            END_CATCH
        }
    }

    return uiError;
}

UINT
CFileModule::CopyImage( CFileModule* pFileModule, LPCSTR lpszType, LPCSTR lpszResId )
{
	CResInfo* pResInfo;
	CResInfo* pTgtResInfo;
	int iResID = (HIWORD(lpszResId) ? 0 : LOWORD(lpszResId) );
	int iTypeID = (HIWORD(lpszType) ? 0 : LOWORD(lpszType) );

	// Find the CResInfo object we have to copy
	INT_PTR c = m_ResArray.GetUpperBound();
	while(c>=0)
	{
		pResInfo = (CResInfo*)m_ResArray.GetAt(c--);								
		if(!pResInfo)
			return  ERROR_IO_INVALIDITEM;

		// Check the type ID
		if( iTypeID && pResInfo->GetTypeName()=="" && (int)pResInfo->GetTypeId()==iTypeID) {
			// Check for the res ID
			if( iResID && (int)pResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
		// check for the type name
		else if( HIWORD(lpszType) && pResInfo->GetTypeName()==lpszType) {
			// Check for the res ID
			if( iResID && (int)pResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
	}
	
	if (c==-1)
		return ERROR_IO_INVALIDID;

	// find were we have to copy it
	c = pFileModule->m_ResArray.GetUpperBound();
	while(c>=0)
	{
		pTgtResInfo = (CResInfo*)pFileModule->m_ResArray.GetAt(c--);
		if(!pTgtResInfo)
			return  ERROR_IO_INVALIDITEM;

		// Check the type ID
		if( iTypeID && pTgtResInfo->GetTypeName()=="" && (int)pTgtResInfo->GetTypeId()==iTypeID) {
			// Check for the res ID
			if( iResID && (int)pTgtResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pTgtResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
		// check for the type name
		else if( HIWORD(lpszType) && pTgtResInfo->GetTypeName()==lpszType) {
			// Check for the res ID
			if( iResID && (int)pTgtResInfo->GetResId()==iResID) {
				c = -2;
			}
			// check for the res name
			else if( (iResID==0) && pTgtResInfo->GetResName()==lpszResId) {
				c = -2;
			}
		}
	}

	if(c==-1)
		return ERROR_IO_INVALIDID;

    // Load the image in memory from the res file
    DWORD dwReadSize = pTgtResInfo->LoadImage( pFileModule->GetName(),
    										   pFileModule->GetHInstance() );
    if (dwReadSize!=pTgtResInfo->GetSize())
        return ERROR_RW_LOADIMAGE;

	// copy the image from the res file
	pTgtResInfo->CopyImage( pResInfo );

	// We have to mark the resource has updated
    pTgtResInfo->SetFileOffset(0L);
    pTgtResInfo->SetImageUpdated(0);

	return 0;
}

UINT
CFileModule::Copy( CFileModule* pFileModule )
{
    CResInfo* pResInfo;
    CResInfo* pTgtResInfo;
    int TgtPos;
    m_dwFlags = pFileModule->m_dwFlags;

    for(INT_PTR u = m_ResArray.GetUpperBound(), c=0; c<=u ; c++) {
        pResInfo = (CResInfo*) m_ResArray.GetAt(c);
        if(!pResInfo)
            return  ERROR_IO_INVALIDITEM;
        TgtPos = pFileModule->AddResInfo( pResInfo->GetTypeId(),
                              pResInfo->GetTypeName(),
                              pResInfo->GetResId(),
                              pResInfo->GetResName(),
                              pResInfo->GetLanguage(),
                              0,
                              0);
        pTgtResInfo = (CResInfo*) pFileModule->GetResInfo( TgtPos );
        if(!pTgtResInfo)
            return  ERROR_IO_INVALIDITEM;
        pResInfo->Copy( pTgtResInfo, m_SrcFileName, m_DllHInstance );
    }
    return ERROR_NO_ERROR;
}

LPCSTR
CFileModule::EnumType( LPCSTR lpszPrevType)
{
    if (lpszPrevType) {
        // Check if the value we get is consistent.
        if (m_TypePos==0) return LPNULL;
        if (m_TypePos==m_TypeArray.GetSize()) {
            m_TypePos = 0;
            return LPNULL;
        }
        CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_TypeArray.GetAt(m_TypePos-1));
		if(HIWORD(lpszPrevType)) {
			if(pResInfo->GetTypeName() != lpszPrevType)
				return LPNULL;
		}
		else {
	        if((DWORD_PTR)pResInfo->GetTypeId()!=(DWORD_PTR)lpszPrevType)
	        	return LPNULL;
		}
    } else {
        // It is the first time we have been called.
        // Generate the list of Types
        m_TypePos = 0;

        if (!m_TypeArray.GetSize())
            // We have to generate the TABLE
            for( INT_PTR c=0, UpperBound=m_ResArray.GetUpperBound(); c<=UpperBound; c++)
                 AddTypeInfo( c,
                              ((CResInfo*)m_ResArray[c])->GetTypeId(),
                              ((CResInfo*)m_ResArray[c])->GetTypeName());

        if (m_TypePos==m_TypeArray.GetSize()) {
            m_TypePos = 0;
            return LPNULL;
        }
    }


    CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_TypeArray.GetAt(m_TypePos++));
    if (pResInfo->GetTypeId() && pResInfo->GetTypeName()==""){
        // It is an ordinal ID
        DWORD dwReturn = 0L;
        dwReturn = (DWORD)pResInfo->GetTypeId();
        return (LPCSTR) UlongToPtr(dwReturn);
    } else {
        // It is a string type
        strcpy( m_TypeStr, pResInfo->GetTypeName());
        return m_TypeStr;
    }
}

LPCSTR
CFileModule::EnumId( LPCSTR lpszType, LPCSTR lpszPrevId )
{
    if (!lpszType) return LPNULL;

    if(!lpszPrevId)
    {
        if(m_IdPos==0)
        {
            // Create the list of resources
            BOOL fTypeName = HIWORD(lpszType);
            CResInfo*   pResInfo;

            m_IdArray.RemoveAll();

            for( WORD i = 0, iUpperBoundRes = (WORD)m_ResArray.GetUpperBound() ; i<=iUpperBoundRes ; i++)
            {
                pResInfo = (CResInfo*)m_ResArray.GetAt(i);
                if(pResInfo)
                {
                    if( fTypeName ? !strcmp(pResInfo->GetTypeName(), lpszType) : pResInfo->GetTypeId()==LOWORD(lpszType))
                    {
                        // add this item to the LangArray
                        m_IdArray.Add(i);
                    }
                }
            }
        }
    }

    ASSERT(m_IdArray.GetSize());

    if (m_IdPos>=m_IdArray.GetSize())
    {
        m_IdPos = 0;
        return LPNULL;
    }

    // We will increment m_IdPos in the lang enum since we use the same array m_IdArray
    CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_IdArray.GetAt(m_IdPos));
    if( pResInfo )
    {
        if (pResInfo->GetResId()){
            // It is an ordinal ID
            return (LPCSTR)pResInfo->GetResId();
        } else {
            // It is a string type
            strcpy( m_IdStr, pResInfo->GetResName());
            return m_IdStr;
        }
    }

    return LPNULL;
}

DWORD
CFileModule::EnumLang( LPCSTR lpszType, LPCSTR lpszId, DWORD dwPrevLang )
{
    // Parameter checking
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;

    ASSERT(m_IdArray.GetSize());

    // This is true when we have done all the languages
    // Return null but keep the m_IdPos, this will let us exit safelly from the
    // EnumId function
    if (m_IdPos==m_IdArray.GetSize())
    {
        return LPNULL;
    }

    CResInfo* pResInfo = (CResInfo*)m_ResArray.GetAt(m_IdArray.GetAt(m_IdPos++));
    if( pResInfo )
    {
        // Check if the ID match
        if(HIWORD(lpszId) ? !strcmp(lpszId, pResInfo->GetResName() ) : LOWORD(lpszId)==pResInfo->GetResId() )
        {
            if(pResInfo->GetLanguage()!=0)
                return pResInfo->GetLanguage();
            else
                return 0xFFFFFFFF;  // for the neutral language case
        }
    }

    m_IdPos--;
    return 0;
}

DWORD
CFileModule::EnumItem( LPCSTR lpszType, LPCSTR lpszId, DWORD dwLang, DWORD dwPrevItem )
{
    // Check if all the parameters are valid
    if (!lpszType) return 0L;
    if (!lpszId) return 0L;
    //if (!dwLang) return 0L;

    CResInfo* pResInfo = GetResInfo( lpszType, lpszId, dwLang );

    if (!m_DllHInstance)
        if (LoadDll()==NULL) return 0L;

    if (pResInfo)
        return pResInfo->EnumItem( m_SrcFileName, m_DllHInstance, dwPrevItem );
    return 0L;
}

////////////////////////////////////////////////////////////////////////////
// CDllTable

CDllTable::CDllTable( UINT InitNum )
{

    //TRACE1("IODLL.DLL: CDllTable::CDllTable %d\n", InitNum);
    m_InitNum = InitNum;
    PCHAR pkey;
    PCHAR pbuf = new char[InitNum];
    if (pbuf==LPNULL) return;
			
	GetProfileString(SECTION, NULL, "", pbuf, InitNum);

    int c;
    if (*pbuf != '\0')
    {
        PCHAR pkey;
        CString szString;

        PCHAR pstr = new char[InitNum];
        for( pkey = pbuf, c = 0;
             *pkey != '\0' ; pkey += strlen(pkey)+1 ) {
            GetProfileString( SECTION, pkey, "Empty", pstr, InitNum);
            szString = pstr;
            if (!szString.IsEmpty())
                Add( new CDllEntryTable(szString) );
            c++;
        }
        delete pstr;
    }
    else
    {
        for (pkey = szDefaultRWDll[0], c=0;
             c < sizeof(szDefaultRWDll)/MAXKEYLEN/sizeof(TCHAR) ; pkey+= MAXKEYLEN)
        {
            Add ( new CDllEntryTable(pkey) );
            c++;
        }
    }
    m_MaxEntry = c+1;

    delete pbuf;

    return;
}

UINT CDllTable::GetPosFromTable( CString szFileType )
{
    UINT c = 0;

    // Check if the string type is not empty
    if (szFileType.IsEmpty()) return 0;

    while( (szFileType!=((CDllEntryTable*)GetAt(c))->GetType()) && (c<m_MaxEntry) ) c++;

    // Be really sure
    if ((szFileType!=((CDllEntryTable*)GetAt(c))->GetType()))
        // 0 Is an invalid position in the Table for us
        return 0;
    return c+1;
}

CDllTable::~CDllTable()
{
    INT_PTR UpperBound = GetUpperBound();
    //TRACE1("IODLL.DLL: CDllTable::~CDllTable %d\n", UpperBound);
    CDllEntryTable* pDllEntry;
    for( int c=0 ; c<=UpperBound ; c++) {
        pDllEntry = (CDllEntryTable*)GetAt(c);
        //TRACE1("\tCDllTable\tCDllEntryTable->%Fp\n", pDllEntry);
        delete pDllEntry;
    }
    RemoveAll();
}

////////////////////////////////////////////////////////////////////////////
// CModuleTable

CModuleTable::CModuleTable( UINT InitNum)
{
    //TRACE1("IODLL.DLL: CModuleTable::CModuleTable %d\n", InitNum);
	m_InitNum = InitNum;
    m_LastHandle = 0;
}

CModuleTable::~CModuleTable()
{
    INT_PTR UpperBound = GetUpperBound();
    //TRACE1("IODLL.DLL: CModuleTable::~CModuleTable %d\n", UpperBound);
    CFileModule* pFileModule;
    for( int c=0 ; c<=UpperBound ; c++) {
        pFileModule = (CFileModule*)GetAt(c);
        //TRACE1("\tCModuleTable\tCFileModule->%Fp\n", pFileModule);
        pFileModule->CleanUp();
        delete pFileModule;
    }
    RemoveAll();
}

////////////////////////////////////////////////////////////////////////////
// CDllEntryTable

CDllEntryTable::CDllEntryTable( CString szEntry )
{
    int chPos;
    if ( (chPos = szEntry.Find(","))==-1 ) {
        m_szDllName = "";
        m_szDllType = "";
        return;
    }

    m_szDllName = szEntry.Left(chPos);
    szEntry = szEntry.Right(szEntry.GetLength()-chPos-1);

    m_szDllType = szEntry;
	m_handle = NULL;
}

CDllEntryTable::~CDllEntryTable()
{
	FreeEntry();
}

HINSTANCE CDllEntryTable::LoadEntry()
{
	if(!m_handle) {
		m_handle = LoadLibrary(m_szDllName);
		TRACE("CDllEntryTable::LoadEntry: %s loaded at %p\n",m_szDllName.GetBuffer(0), (UINT_PTR)m_handle);
	}
	return m_handle;
}

BOOL CDllEntryTable::FreeEntry()
{
	BOOL bRet = FALSE;
	if(m_handle) {
		bRet = FreeLibrary(m_handle);
		TRACE("CDllEntryTable::FreeEntry: %s FreeLibrary return %d\n",m_szDllName.GetBuffer(0),bRet);
	}																
	return bRet;
}

////////////////////////////////////////////////////////////////////////////
// CResInfo

CResInfo::CResInfo( WORD Typeid, CString sztypeid,
              WORD nameid, CString sznameid,
              DWORD dwlang, DWORD dwsize, DWORD dwfileoffset, CFileModule * pFileModule )
{
    m_FileOffset = dwfileoffset;
    m_FileSize = dwsize;

    m_Language = MAKELONG(LOWORD(dwlang),LOWORD(dwlang));

    m_TypeName = sztypeid;
    m_TypeId = Typeid;

    m_ResName = sznameid;
    m_ResId = nameid;

    m_lpImageBuf = LPNULL;
    m_dwImageSize = 0L;

    m_ItemPos = 0;

    m_pFileModule = pFileModule;
}

CResInfo::~CResInfo()
{
    //TRACE("IODLL.DLL: CResInfo::~CResInfo\n");
    FreeImage();
    FreeItemArray();
}

void
CResInfo::FreeImage()
{
    if (m_lpImageBuf)
		delete []m_lpImageBuf;

    m_lpImageBuf = LPNULL;
    m_dwImageSize = 0L;
}

void
CResInfo::FreeItemArray()
{
    CItemInfo* pItemInfo;
    for( INT_PTR c=0, UpperBound=m_ItemArray.GetUpperBound(); c<=UpperBound; c++) {
        pItemInfo = (CItemInfo*)m_ItemArray.GetAt(c);
        delete pItemInfo;
    }

    m_ItemArray.RemoveAll();
}

UINT
CResInfo::AllocImage(DWORD dwSize)
{
    // Check if we have to free the value in m_lpImageBuf
    if (m_lpImageBuf)
        FreeImage();

    //TRACE2("CResInfo::AllocImage\tNewSize: %ld\tNum: %ld\n", (LONG)dwSize, lRequestLast+1);
    TRACE1("CResInfo::AllocImage\tNewSize: %ld\n", (LONG)dwSize);
	m_lpImageBuf = new BYTE[dwSize];
    if (!m_lpImageBuf) {
        TRACE("\n"
              "************* ERROR **********\n"
              "CResInfo::AllocImage: New Failed!! BYTE far * lpImageBuf = new BYTE[dwSize];\n"
              "************* ERROR **********\n"
              "\n" );
        return ERROR_NEW_FAILED;
    }

    m_dwImageSize = dwSize;
    return 0;
}

DWORD
CResInfo::LoadImage( CString lpszFilename, HINSTANCE hInst )
{
	if(!m_FileSize)
		return 0;

    if(AllocImage(m_FileSize))
        return ERROR_NEW_FAILED;

    // Call the RW and read thead the Image from the file
    DWORD (FAR PASCAL * lpfnGetImage)(LPCSTR, DWORD, LPVOID, DWORD);
    // Get the pointer to the function to extract the resources
    lpfnGetImage = (DWORD (FAR PASCAL *)(LPCSTR, DWORD, LPVOID, DWORD))
                        GetProcAddress( hInst, "RWGetImage" );
    if (lpfnGetImage==NULL) {
        FreeImage();
        return (DWORD)ERROR_DLL_PROC_ADDRESS;
    }

    DWORD dwReadSize = 0l;
    if (m_FileOffset)
        dwReadSize = (*lpfnGetImage)((LPCSTR)lpszFilename,
                                       (DWORD)m_FileOffset,
                                       (LPVOID)m_lpImageBuf,
                                       (DWORD)m_FileSize);
    if (dwReadSize!=m_FileSize) {
        FreeImage();
        return 0l;
    }
    return m_dwImageSize;
}

DWORD
CResInfo::GetImage( LPCSTR lpszFilename, HINSTANCE hInst, LPVOID lpbuffer, DWORD dwBufSize )
{
    if(!m_FileSize)
    	return 0;

    if ( (!m_lpImageBuf) && (m_FileOffset)) {
        DWORD dwReadSize = LoadImage( lpszFilename, hInst );
        if (dwReadSize!=m_dwImageSize)
            return 0L;
    }
    if (dwBufSize<m_dwImageSize)
        return m_dwImageSize;

    memcpy( lpbuffer, m_lpImageBuf, (UINT)m_dwImageSize );

    return m_dwImageSize;
}

DWORD
CResInfo::ReplaceImage( LPVOID lpNewImage, DWORD dwNewImageSize, DWORD dwUpdLang )
{
    m_ImageUpdated = 1;
    FreeImage();
    if(!m_lpImageBuf) {
		if(AllocImage(dwNewImageSize))
            return ERROR_NEW_FAILED;

        if (lpNewImage){
            memcpy(m_lpImageBuf, lpNewImage, (UINT)dwNewImageSize);
            if (dwUpdLang != 0xffffffff){
                m_Language=MAKELONG(m_Language,dwUpdLang);
            }
        }else{
            m_lpImageBuf = LPNULL;
        }

        // check if the size of the image is 0
        if(!m_FileOffset) {
            // Chances are that this is a conversion.
            // set the file size to the s