" );
			goto Failure;
		}
	
		pAdapterEntry->SetBaseAddress( pDeviceSocketAddress->GetAddress(), pDeviceSocketAddress->GetAddressSize() );
		pAdapterEntry->AddToAdapterList( pSocketData->GetAdapters() );
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	//
	// At this point we have a reference to an adapter entry that's also in
	// m_ActiveAdapterList (which has a reference, too).
	//

	
	//
	// if a specific port is not needed, check the list of active adapters for a matching
	// base address and reuse that CSocketPort.
	//
	if ( pDeviceSocketAddress->GetPort() == ANY_PORT )
	{
		DPFX(DPFPREP, 8, "Device socket address 0x%p not mapped to a specific port, gateway bind type = %u.",
			pDeviceSocketAddress, GatewayBindType);


		//
		// Convert the preliminary bind type to a real one, based on the fact that
		// the caller allowed any port.
		//
		switch (GatewayBindType)
		{
			case GATEWAY_BIND_TYPE_UNKNOWN:
			{
				//
				// Caller didn't know ahead of time how to bind.
				// Since there's no port, we can let the gateway bind whatever it wants.
				//
				NewGatewayBindType = GATEWAY_BIND_TYPE_DEFAULT;
				break;
			}
			
			case GATEWAY_BIND_TYPE_NONE:
			{
				//
				// Caller didn't actually want to bind on gateway.
				//
				
				NewGatewayBindType = GatewayBindType;
				break;
			}
			
			default:
			{
				//
				// Some wacky value, or a type was somehow already chosen.
				//
				DNASSERT(FALSE);
				NewGatewayBindType = GatewayBindType;
				break;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Device socket address 0x%p specified port %u, gateway bind type = %u.",
			pDeviceSocketAddress, NTOHS(pDeviceSocketAddress->GetPort()),
			GatewayBindType);


		//
		// Convert the preliminary bind type to a real one, based on the fact that
		// the caller gave us a port.
		//
		switch (GatewayBindType)
		{
			case GATEWAY_BIND_TYPE_UNKNOWN:
			{
				//
				// Caller didn't know ahead of time how to bind.
				// Since there's a port, it should be fixed on the gateway, too.
				//
				NewGatewayBindType = GATEWAY_BIND_TYPE_SPECIFIC;
				break;
			}
			
			case GATEWAY_BIND_TYPE_SPECIFIC_SHARED:
			{
				//
				// Caller wanted to bind to a specific port on the gateway,
				// and it needs to be shared (DPNSVR).
				//
				
				NewGatewayBindType = GatewayBindType;
				break;
			}
			
			case GATEWAY_BIND_TYPE_NONE:
			{
				//
				// Caller didn't actually want to bind on gateway.
				//
				
				NewGatewayBindType = GatewayBindType;
				break;
			}
			
			default:
			{
				//
				// Some wacky value, or default/specific was somehow already chosen.
				// That shouldn't happen.
				//
				DNASSERT(FALSE);
				NewGatewayBindType = GatewayBindType;
				break;
			}
		}
	}


	//
	// Look for an existing socketport that's compatible with the specified endpoint.
	//
#ifdef DPNBUILD_ONLYONEADAPTER
	pBilinkEndOfList = pSocketData->GetSocketPorts();
#else // ! DPNBUILD_ONLYONEADAPTER
	pBilinkEndOfList = pAdapterEntry->SocketPortList();
#endif // ! DPNBUILD_ONLYONEADAPTER
	pBilink = pBilinkEndOfList->GetNext();
	while ((pBilink != pBilinkEndOfList) && (pSocketPort == NULL))
	{
		pSocketPort = CSocketPort::SocketPortFromBilink( pBilink );

		if ((pDeviceSocketAddress->GetPort() != ANY_PORT) &&
			(pDeviceSocketAddress->GetPort() != pSocketPort->GetNetworkAddress()->GetPort()))
		{
			DPFX(DPFPREP, 7, "Skipping socket port 0x%p because it is for a different port (%u <> %u).",
				pSocketPort, NTOHS(pDeviceSocketAddress->GetPort()), NTOHS(pSocketPort->GetNetworkAddress()->GetPort()));
			pSocketPort = NULL;
		}
#ifndef DPNBUILD_ONLYONEPROCESSOR
		else if ((dwCPU != -1) && (dwCPU != pSocketPort->GetCPU()))
		{
			DPFX(DPFPREP, 7, "Skipping socket port 0x%p because it is for a different CPU (%u <> %u).",
				pSocketPort, dwCPU, pSocketPort->GetCPU());
			pSocketPort = NULL;
		}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_NONATHELP
		else if (pSocketPort->GetUserTraversalMode() != pEndpoint->GetUserTraversalMode())
		{
			DPFX(DPFPREP, 7, "Skipping socket port 0x%p because its traversal mode=%u but endpoint 0x%p traversal mode=%u.",
				pSocketPort, pSocketPort->GetUserTraversalMode(), pEndpoint, pEndpoint->GetUserTraversalMode());
			pSocketPort = NULL;
		}
#endif // ! DPNBUILD_NONATHELP
		else
		{
			switch (pEndpoint->GetType())
			{
				case ENDPOINT_TYPE_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
				case ENDPOINT_TYPE_MULTICAST_LISTEN:
#endif // ! DPNBUILD_NOMULTICAST
				{
					//
					// If there's already a listen/multicast listen started on the socket port,
					// we can't select it.
					// NOTE: The socketport's endpoint data lock is not held while checking
					// the listen endpoint handle!  This should be fine because we're just
					// doing "if exists" check.  If the endpoint later gets removed, we will
					// end up binding to a new socketport that might not have been
					// necessary.  If an endpoint gets added, BindEndpoint will notice and
					// fail.  Either way, we're not going to cause any crashes. 
					//
					if (pSocketPort->GetListenEndpoint() != NULL)
					{
						DPFX(DPFPREP, 7, "Skipping socket port 0x%p because it already has a listen/multicast listen (0x%p).",
							pSocketPort, pSocketPort->GetListenEndpoint());
						pSocketPort = NULL;
					}
					else
					{
						DPFX(DPFPREP, 6, "Picked socket port 0x%p for binding new listen/multicast listen.",
							pSocketPort);
						
						//
						// Attempt to add a reference for the endpoint we're going to bind to
						// this socket port.  If it fails, the socket is in the process of being
						// unbound, so we cannot use this socket port now.  Move on to using
						// other socket ports or creating a new one.
						//
						fEndpointReferenceAdded = pSocketPort->EndpointAddRef();
						if (! fEndpointReferenceAdded)
						{
							DPFX(DPFPREP, 1, "Couldn't re-use existing socket port 0x%p for listen/multicast listen because it is unbinding, continuing.",
								pSocketPort);
							pSocketPort = NULL;
						}
					}
					break;
				}
				
				case ENDPOINT_TYPE_CONNECT:
				case ENDPOINT_TYPE_ENUM:
				case ENDPOINT_TYPE_CONNECT_ON_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
				case ENDPOINT_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
				{
					DPFX(DPFPREP, 6, "Picked socket port 0x%p for binding new connect or enum.",
						pSocketPort);
						
					//
					// Attempt to add a reference for the endpoint we're going to bind to
					// this socket port.  If it fails, the socket is in the process of being
					// unbound, so we cannot use this socket port now.  Move on to using
					// other socket ports or creating a new one.
					//
					fEndpointReferenceAdded = pSocketPort->EndpointAddRef();
					if (! fEndpointReferenceAdded)
					{
						DPFX(DPFPREP, 1, "Couldn't re-use existing socket port 0x%p for connect/enum because it is unbinding, continuing.",
							pSocketPort);
						pSocketPort = NULL;
					}
					break;
				}

#ifndef DPNBUILD_NOMULTICAST
				case ENDPOINT_TYPE_MULTICAST_SEND:
				{
					//
					// If this socketport has already had its multicast TTL value set, and
					// it's not the same as what we're looking to use, we can't select it.
					// NOTE: The socketport's endpoint data lock is not held while checking
					// the multicast TTL setting.
					//
					if ((pSocketPort->GetMulticastTTL() != 0) &&
						(pSocketPort->GetMulticastTTL() != bMulticastTTL))
					{
						DPFX(DPFPREP, 7, "Skipping socket port 0x%p because it already has a different multicast TTL setting (%u != %u).",
							pSocketPort, pSocketPort->GetMulticastTTL(), bMulticastTTL);
						pSocketPort = NULL;
					}
					else
					{
						DPFX(DPFPREP, 6, "Picked socket port 0x%p for binding new multicast send.",
							pSocketPort);
						
						//
						// Attempt to add a reference for the endpoint we're going to bind to
						// this socket port.  If it fails, the socket is in the process of being
						// unbound, so we cannot use this socket port now.  Move on to using
						// other socket ports or creating a new one.
						//
						fEndpointReferenceAdded = pSocketPort->EndpointAddRef();
						if (! fEndpointReferenceAdded)
						{
							DPFX(DPFPREP, 1, "Couldn't re-use existing socket port 0x%p for multicast send because it is unbinding, continuing.",
								pSocketPort);
							pSocketPort = NULL;
						}
					}
					break;
				}
#endif // ! DPNBUILD_NOMULTICAST
				
				default:
				{
					DNASSERT(FALSE);
					hr = DPNERR_INVALIDENDPOINT;
					goto Failure;
					break;
				}
			}
		}
		
		pBilink = pBilink->GetNext();
	}


	//
	// If a socket port has not been found, attempt to create a new socket port,
  	// initialize it, and add it to the list (may result in a duplicate, see below).
  	// Whatever happens there will be a socket port to bind the endpoint to.
  	// Save the reference on the CSocketPort from the call to 'Create' until the
	// socket port is removed from the active list.
	//
	//
	if ( pSocketPort == NULL )
	{
		pSocketData->Unlock();
		fSocketDataLocked = FALSE;

		pSocketPort = (CSocketPort*)g_SocketPortPool.Get();
		if ( pSocketPort == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Failed to create new socket port!" );
			goto Failure;
		}
		pSocketPort->AddRef();
		fSocketCreated = TRUE;

		DPFX(DPFPREP, 6, "Created new socket port 0x%p.", pSocketPort);

		//
		// We don't need to add a reference for the endpoint we're going to
		// bind since new socket ports should already have the endpoint
		// reference added before it comes out of the pool.  We can't assert
		// that because we don't have access to the refcount variables.
		//
		//DNASSERT( pSocketPort->m_iRefCount == 1 );
		//DNASSERT( pSocketPort->m_iEndpointRefCount == 1 );
		fEndpointReferenceAdded = TRUE;


		hr = pSocketPort->Initialize( pSocketData, m_pThreadPool, pDeviceSocketAddress );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to initialize new socket port!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
		pDeviceSocketAddress = NULL;

#ifndef DPNBUILD_ONLYONEADAPTER
		pAdapterEntry->AddRef();
		pSocketPort->SetAdapterEntry( pAdapterEntry );
		fAdapterEntrySet = TRUE;
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifndef DPNBUILD_NONATHELP
		pSocketPort->SetUserTraversalMode(pEndpoint->GetUserTraversalMode());
#endif // ! DPNBUILD_NONATHELP

#ifdef DPNBUILD_ONLYONEPROCESSOR
		hr = pSocketPort->BindToNetwork( NewGatewayBindType );
#else // ! DPNBUILD_ONLYONEPROCESSOR
		hr = pSocketPort->BindToNetwork( dwCPU, NewGatewayBindType );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to bind new socket port to network!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}

		pSocketData->Lock();
		fSocketDataLocked = TRUE;	
		
		//
		// The only way to get here is to have the socket bound to the
		// network.  The socket can't be bound twice, if there was a
		// race to bind the socket, Winsock would have decided which
		// thread lost and failed 'BindToNetwork'.
		//
		// However, the order in which sockets are marked as unusable
		// and then pulled from the active list is such that there could
		// still be an unbinding socketport with this same address in the
		// list.
		//
#ifdef DBG
		CSocketPort	*pDuplicateSocket;
		if ( pSocketData->FindSocketPort( pSocketPort->GetNetworkAddress(), &pDuplicateSocket ) )
		{
			DPFX(DPFPREP, 1, "Socketport with same address still exists in list (0x%p).",
				pDuplicateSocket);
			DumpSocketAddress( 1, pSocketPort->GetNetworkAddress()->GetAddress(), pSocketPort->GetNetworkAddress()->GetFamily() );
			DNASSERT( pDuplicateSocket->GetSocket() == INVALID_SOCKET );
		}
#endif // DBG

#ifdef DPNBUILD_ONLYONEADAPTER
		pSocketPort->AddToActiveList( pSocketData->GetSocketPorts() );
#else // ! DPNBUILD_ONLYONEADAPTER
		pSocketPort->AddToActiveList( pAdapterEntry->SocketPortList() );
#endif // ! DPNBUILD_ONLYONEADAPTER
		fSocketPortInActiveList = TRUE;
	}


	DNASSERT( pSocketPort != NULL );
	DNASSERT( fEndpointReferenceAdded );
	
#if ((! defined(DPNBUILD_NOWINSOCK2)) || (! defined(DPNBUILD_NOREGISTRY)))
	//
	// Munge the public address into a local alias, if there is one for the given device.
	// It's OK for the device socket address to not have a port yet.
	//
	// Note that doing this causes all other multiplexed operations to use the munged
	// result from this first adapter because we indicate the modified address info,
	// not the original proxied address.
	//
	switch ( pEndpoint->GetType() )
	{
		case ENDPOINT_TYPE_CONNECT:
#ifndef DPNBUILD_NOMULTICAST
		case ENDPOINT_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
		{
			pHostAddress = pEndpoint->GetCommandParameters()->PendingCommandData.ConnectData.pAddressHost;
			DNASSERT( pHostAddress != NULL );
			pEndpoint->MungeProxiedAddress( pSocketPort, pHostAddress, FALSE );
			break;
		}
		
		case ENDPOINT_TYPE_ENUM:
		{
			pHostAddress = pEndpoint->GetCommandParameters()->PendingCommandData.EnumQueryData.pAddressHost;
			DNASSERT( pHostAddress != NULL );
			pEndpoint->MungeProxiedAddress( pSocketPort, pHostAddress, TRUE );
			break;
		}

		default:
		{
			break;
		}
	}
#endif // ! DPNBUILD_NOWINSOCK2 or ! DPNBUILD_NOREGISTRY
	
	//
	// bind the endpoint to whatever socketport we have
	//
	hr = pSocketPort->BindEndpoint( pEndpoint, NewGatewayBindType );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to bind endpoint!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	
Exit:

#ifndef DPNBUILD_ONLYONEADAPTER
	if (pAdapterEntry != NULL)
	{
		pAdapterEntry->DecRef();
		pAdapterEntry = NULL;
	}
#endif // ! DPNBUILD_ONLYONEADAPTER

	if ( pSocketData != NULL )
	{
		if ( fSocketDataLocked != FALSE )
		{
			pSocketData->Unlock();
			fSocketDataLocked = FALSE;
		}

		pSocketData->Release();
		pSocketData = NULL;
	}
	
	if ( pDeviceSocketAddress != NULL )
	{
		g_SocketAddressPool.Release( pDeviceSocketAddress );
		pDeviceSocketAddress = NULL;
	}
	
	DPFX(DPFPREP, 6, "(0x%p) Return [0x%lx]", this, hr);
	
	return	hr;

Failure:
	//
	// If we're failing and cleanup will require removal of some resources.
	// This requires the socket port data lock.
	//
	if ( ( pSocketData != NULL ) && ( fSocketDataLocked == FALSE ) )
	{
		pSocketData->Lock();
		fSocketDataLocked = TRUE;
	}

	if ( pSocketPort != NULL )
	{
		if ( fEndpointReferenceAdded != FALSE )
		{
			pSocketPort->EndpointDecRef();
			fEndpointReferenceAdded = FALSE;
		}

#ifndef DPNBUILD_ONLYONEADAPTER
		if (fAdapterEntrySet)
		{
			pSocketPort->SetAdapterEntry( NULL );
			pAdapterEntry->DecRef();
			fAdapterEntrySet = FALSE;
		}
#endif // ! DPNBUILD_ONLYONEADAPTER

		if ( fSocketPortInActiveList != FALSE )
		{
			pSocketPort->RemoveFromActiveList();
			fSocketPortInActiveList = FALSE;
		}
	
		if ( fSocketCreated != FALSE )
		{
			pSocketPort->DecRef();
			fSocketCreated = FALSE;
			pSocketPort = NULL;
		}
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::UnbindEndpoint - unbind an endpoint from a socket port
//
// Entry:		Pointer to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::UnbindEndpoint"

void	CSPData::UnbindEndpoint( CEndpoint *const pEndpoint )
{
	CSocketData *	pSocketData;
	CSocketPort *	pSocketPort;
	BOOL			fCleanUpSocketPort;
#ifndef DPNBUILD_ONLYONEADAPTER
	CAdapterEntry *	pAdapterEntry;
#endif // ! DPNBUILD_ONLYONEADAPTER


	DNASSERT( pEndpoint != NULL );

	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p)", this, pEndpoint);

	//
	// initialize
	//
	pSocketData = GetSocketData();
	DNASSERT( pSocketData != NULL );
	pSocketPort = pEndpoint->GetSocketPort();
	DNASSERT( pSocketPort != NULL );
	fCleanUpSocketPort = FALSE;

	pSocketPort->UnbindEndpoint( pEndpoint );
	if ( pSocketPort->EndpointDecRef() == 0 )
	{
		fCleanUpSocketPort = TRUE;
		
		pSocketData->Lock();
		
		pSocketPort->RemoveFromActiveList();
		
#ifndef DPNBUILD_ONLYONEADAPTER
		pAdapterEntry = pSocketPort->GetAdapterEntry();
		DNASSERT( pAdapterEntry != NULL );
		pSocketPort->SetAdapterEntry( NULL );
		pAdapterEntry->DecRef();
#endif // ! DPNBUILD_ONLYONEADAPTER
		
		pSocketData->Unlock();
	}

	if ( fCleanUpSocketPort != FALSE )
	{
		pSocketPort->DecRef();
		fCleanUpSocketPort = FALSE;
	}

	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************


#ifndef DPNBUILD_NOMULTICAST
//**********************************************************************
// ------------------------------
// CSPData::GetEndpointFromAddress - retrieves an endpoint handle and context given addressing info
//
// Entry:		Pointer to host address
//				Pointer to device address
//				Place to store endpoint handle
//				Place to store user context
//
// Exit:		Error
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetEndpointFromAddress"

HRESULT	CSPData::GetEndpointFromAddress( IDirectPlay8Address *const pHostAddress,
									  IDirectPlay8Address *const pDeviceAddress,
									  HANDLE * phEndpoint,
									  PVOID * ppvEndpointContext )
{
	HRESULT				hr;
	CSocketAddress *	pDeviceSocketAddress;
	CSocketAddress *	pHostSocketAddress;
	CSocketData *		pSocketData;
	BOOL				fSocketDataLocked;
	CSocketPort *		pSocketPort;
	CEndpoint *			pEndpoint;


	//
	// initialize
	//
	hr = DPN_OK;
	pHostSocketAddress = NULL;
	pDeviceSocketAddress = NULL;
	pSocketData = NULL;
	fSocketDataLocked = FALSE;
	pSocketPort = NULL;
	pEndpoint = NULL;


	//
	// Get SP addresses from the pool to perform conversions.
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pHostSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
	pDeviceSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pHostSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) GetType()));
	pDeviceSocketAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) GetType()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ((pHostSocketAddress == NULL) || (pDeviceSocketAddress == NULL))
	{
		DPFX(DPFPREP, 0, "Failed to get addresses for conversions!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Convert the device address.
	//
	hr = pDeviceSocketAddress->SocketAddressFromDP8Address(pDeviceAddress,
#ifdef DPNBUILD_XNETSECURITY
															NULL,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
															FALSE,
#endif // DPNBUILD_ONLYONETHREAD
															SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get socket address from device DP8 address (err = 0x%lx)!", hr);
		hr = DPNERR_INVALIDDEVICEADDRESS;
		goto Failure;
	}


	//
	// Convert the host address.
	//
	hr = pHostSocketAddress->SocketAddressFromDP8Address(pHostAddress,
#ifdef DPNBUILD_XNETSECURITY
														NULL,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
														FALSE,
#endif // DPNBUILD_ONLYONETHREAD
														SP_ADDRESS_TYPE_HOST);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get socket address from host DP8 address (err = 0x%lx)!", hr);
		hr = DPNERR_INVALIDHOSTADDRESS;
		goto Failure;
	}


#ifndef DPNBUILD_NONATHELP
	//
	// Make sure we have the local version of the host, as reported by NAT Help.
	//
	MungePublicAddress(pDeviceSocketAddress, pHostSocketAddress, FALSE);
#endif // ! DPNBUILD_NONATHELP


	//
	// Get the socket port data.
	//
	pSocketData = GetSocketDataRef();
	if (pSocketData == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't retrieve socket data!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	pSocketData->Lock();
	fSocketDataLocked = TRUE;	


	//
	// Look up the socket port for the given address.
	//
	if (! (pSocketData->FindSocketPort(pDeviceSocketAddress, &pSocketPort)))
	{
		DPFX(DPFPREP, 0, "Couldn't find socket port for given device address (err = 0x%lx)!", hr);
		hr = DPNERR_INVALIDDEVICEADDRESS;
		goto Failure;
	}

	pSocketPort->AddRef();

	pSocketData->Unlock();
	fSocketDataLocked = FALSE;	



	//
	// Locate the connect endpoint for the host address.
	//
	pSocketPort->ReadLockEndpointData();
	if (pSocketPort->FindConnectEndpoint(pHostSocketAddress, &pEndpoint))
	{
		(*phEndpoint) = (HANDLE) pEndpoint;
		(*ppvEndpointContext) = pEndpoint->GetUserEndpointContext();
	}
	else
	{
		DPFX(DPFPREP, 0, "Couldn't find endpoint for given host address!");
		hr = DPNERR_INVALIDHOSTADDRESS;

		//
		// Drop through...
		//
	}
	pSocketPort->UnlockEndpointData();



Exit:

	if (pSocketPort != NULL)
	{
		pSocketPort->DecRef();
		pSocketPort = NULL;
	}

	if (pSocketData != NULL)
	{
		if (fSocketDataLocked)
		{
			pSocketData->Unlock();
			fSocketDataLocked = FALSE;	
		}

		pSocketData->Release();
		pSocketData = NULL;
	}

	if (pHostSocketAddress != NULL)
	{
		g_SocketAddressPool.Release( pHostSocketAddress );
		pHostSocketAddress = NULL;
	}

	if (pDeviceSocketAddress != NULL)
	{
		g_SocketAddressPool.Release( pDeviceSocketAddress );
		pDeviceSocketAddress = NULL;
	}

	DPFX(DPFPREP, 6, "Returning: [0x%lx] (handle = 0x%p, context = 0x%p",
		hr, (*phEndpoint), (*ppvEndpointContext));

	return	hr;


Failure:

	goto Exit;
}
//**********************************************************************
#endif // ! DPNBUILD_NOMULTICAST


//**********************************************************************
// ------------------------------
// CSPData::GetNewEndpoint - get a new endpoint
//
// Entry:		Nothing
//
// Exit:		Pointer to new endpoint
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetNewEndpoint"

CEndpoint	*CSPData::GetNewEndpoint( void )
{
	CEndpoint	*pEndpoint;

	
	pEndpoint = (CEndpoint*)g_EndpointPool.Get( this );
	if ( pEndpoint == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to create endpoint!" );
	}

	// NOTE: Endpoints are returned with one CommandRef and one regular Ref.

	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::EndpointFromHandle - get endpoint from handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::EndpointFromHandle"

CEndpoint	*CSPData::EndpointFromHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;
	BOOL		fGotCommandRef;


	pEndpoint = (CEndpoint*) hEndpoint;
	DNASSERT( pEndpoint->IsValid() );
	fGotCommandRef = pEndpoint->AddCommandRef();
	DNASSERT( fGotCommandRef );

	return	pEndpoint;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::CloseEndpointHandle - close endpoint handle
//
// Entry:		Poiner to endpoint
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::CloseEndpointHandle"

void	CSPData::CloseEndpointHandle( CEndpoint *const pEndpoint )
{
	pEndpoint->DecCommandRef();
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetEndpointAndCloseHandle - get endpoint from handle and close the
//		handle
//
// Entry:		Handle
//
// Exit:		Pointer to endpoint (it needs a call to 'DecCommandRef' when done)
//				NULL = invalid handle
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetEndpointAndCloseHandle"

CEndpoint	*CSPData::GetEndpointAndCloseHandle( const HANDLE hEndpoint )
{
	CEndpoint	*pEndpoint;


	pEndpoint = (CEndpoint*) hEndpoint;
	DNASSERT( pEndpoint->IsValid() );
	pEndpoint->AddRef();
	
	return	pEndpoint;
}
//**********************************************************************


#ifndef DPNBUILD_NONATHELP
//**********************************************************************
// ------------------------------
// CSPData::MungePublicAddress - get a public socket address' local alias, if any
//							it also converts the IPv6 loopback address to the device address
//
// Entry:		Pointer to device address
//				Pointer to public address to munge
//				Whether it's an enum or not
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::MungePublicAddress"

void	CSPData::MungePublicAddress( const CSocketAddress * const pDeviceBaseAddress, CSocketAddress * const pPublicAddress, const BOOL fEnum )
{
	HRESULT		hr = DPNHERR_NOMAPPING;
	SOCKADDR	SocketAddress;
	DWORD		dwTemp;


	DNASSERT( pDeviceBaseAddress != NULL );
	DNASSERT( pPublicAddress != NULL );
	DNASSERT( m_pThreadPool != NULL );
	
	
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	if ( m_pThreadPool->IsNATHelpLoaded() )
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if (( pDeviceBaseAddress->GetFamily() == AF_INET ) &&
		( pPublicAddress->GetFamily() == AF_INET ) &&
		( m_pThreadPool->IsNATHelpLoaded() ))
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
		//
		// Don't bother looking up the broadcast address, that's a waste of
		// time.
		//
		if (((SOCKADDR_IN*) pPublicAddress->GetAddress())->sin_addr.S_un.S_addr == INADDR_BROADCAST)

		{
			//
			// This had better be an enum, you can't connect to the broadcast
			// address.
			//
			DNASSERT(fEnum);
			DPFX(DPFPREP, 8, "Not attempting to lookup alias for broadcast address." );
		}
		else
		{
			DBG_CASSERT( sizeof( SocketAddress ) == sizeof( *pPublicAddress->GetAddress() ) );


			//
			// Start by copying the 
			//
			for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
			{
				if (g_papNATHelpObjects[dwTemp] != NULL)
				{
		  			//
		  			// IDirectPlayNATHelp::GetCaps had better have been called with the
	  				// DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to this.
	  				// See CThreadPool::EnsureNATHelpLoaded
	  				//
					hr = IDirectPlayNATHelp_QueryAddress( g_papNATHelpObjects[dwTemp],
													pDeviceBaseAddress->GetAddress(),
													pPublicAddress->GetAddress(),
													&SocketAddress,
													sizeof(SocketAddress),
													(DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND) );
					if ( hr == DPNH_OK )
					{
						//
						// There is a local alias for the address.
						//

						//
						// Bad news:
						// The PAST protocol can only return one address, but the SHARED
						// UDP LISTENER extension which allows multiple machines to listen
						// on the same fixed port.  Someone querying for the local alias
						// for that address will only get the first person to register the
						// shared port, which may not be the machine desired.
						//
						// Good news:
						// Only DPNSVR uses SHARED UDP LISTENERs, and thus it only happens
						// with enums on DPNSVRs port.  Further, it only affects a person
						// behind the same ICS machine.  So we can workaround this by
						// detecting an enum attempt on the public address and DPNSVR port,
						// and instead of using the single address returned by PAST, use
						// the broadcast address.  Since anyone registered with the ICS
						// server would have to be local, broadcasting should find the same
						// servers (and technically more, but that shouldn't matter).
						//
						// So:
						// If the address has a local alias, and it's the DPNSVR port
						// (which is the only one that can be shared), and its an enum,
						// broadcast instead.
						//
 						if ((fEnum) && (((SOCKADDR_IN*) pPublicAddress->GetAddress())->sin_port == HTONS(DPNA_DPNSVR_PORT)))
						{
							((SOCKADDR_IN*) pPublicAddress->GetAddress())->sin_addr.S_un.S_addr = INADDR_BROADCAST;

							DPFX(DPFPREP, 7, "Address for enum has local alias (via object %u), but is on DPNSVR's shared fixed port, substituting broadcast address instead:",
								dwTemp );
							DumpSocketAddress( 7, pPublicAddress->GetAddress(), pPublicAddress->GetFamily() );
						}
						else
						{
							pPublicAddress->SetAddressFromSOCKADDR( &SocketAddress, sizeof( SocketAddress ) );
							DPFX(DPFPREP, 7, "Object %u had mapping, modified address is now:", dwTemp );
							DumpSocketAddress( 7, pPublicAddress->GetAddress(), pPublicAddress->GetFamily() );
						}

						//
						// Stop searching.
						//
						break;
					}


					DPFX(DPFPREP, 8, "Address was not modified by object %u (err = 0x%lx).",
						dwTemp, hr );
				}
				else
				{
					//
					// No DPNATHelp object in this slot.
					//
				}
			} // end for (each DPNATHelp object)


			//
			// If no object touched it, remember that.
			//
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 7, "Address was not modified by any objects:" );
				DumpSocketAddress( 7, pPublicAddress->GetAddress(), pPublicAddress->GetFamily() );
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "NAT Help not loaded or not necessary, not modifying address." );
	}
}
//**********************************************************************
#endif // !DPNBUILD_NONATHELP



#ifndef WINCE

//**********************************************************************
// ------------------------------
// CSPData::SetWinsockBufferSizeOnAllSockets - set buffer size on all sockets
//
// Entry:		New buffer size
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::SetWinsockBufferSizeOnAllSockets"
void	CSPData::SetWinsockBufferSizeOnAllSockets( const INT iBufferSize )
{
	CSocketData		*pSocketData;
#ifndef DPNBUILD_ONLYONEADAPTER
	CAdapterEntry	*pAdapterEntry;
	CBilink			*pAdapterEntryLink;
#endif // ! DPNBUILD_ONLYONEADAPTER
	CBilink			*pSocketPortList;
	CBilink			*pBilinkSocketPortListEnd;
	CSocketPort		*pSocketPort;

	
	//
	// Don't use GetSocketDataRef to retrieve the socket data because
	// this is just a caps setting.  We don't want to create the socket
	// data object if it didn't exist.
	//
	Lock();
	if (m_pSocketData != NULL)
	{
		m_pSocketData->AddRef();
		pSocketData = m_pSocketData;
		Unlock();

		pSocketData->Lock();
		
#ifndef DPNBUILD_ONLYONEADAPTER
		pAdapterEntryLink = pSocketData->GetAdapters()->GetNext();
		while ( pAdapterEntryLink != pSocketData->GetAdapters() )
#endif // ! DPNBUILD_ONLYONEADAPTER
		{
#ifdef DPNBUILD_ONLYONEADAPTER
			pBilinkSocketPortListEnd = pSocketData->GetSocketPorts();
#else // ! DPNBUILD_ONLYONEADAPTER
			pAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage( pAdapterEntryLink );
			pBilinkSocketPortListEnd = pAdapterEntry->SocketPortList();
#endif // ! DPNBUILD_ONLYONEADAPTER
			pSocketPortList = pBilinkSocketPortListEnd->GetNext();
			while ( pSocketPortList != pBilinkSocketPortListEnd )
			{
				pSocketPort = CSocketPort::SocketPortFromBilink( pSocketPortList );
				pSocketPort->SetWinsockBufferSize( iBufferSize );

				pSocketPortList = pSocketPortList->GetNext();
			}

#ifndef DPNBUILD_ONLYONEADAPTER
			pAdapterEntryLink = pAdapterEntryLink->GetNext();
#endif // ! DPNBUILD_ONLYONEADAPTER
		}
		
		pSocketData->Unlock();
		pSocketData->Release();
		pSocketData = NULL;
	}
	else
	{
		Unlock();
	}
}
//**********************************************************************

#endif // ! WINCE


//**********************************************************************
// ------------------------------
// CSPData::DestroyThisObject - destroy this object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::DestroyThisObject"
void	CSPData::DestroyThisObject( void )
{	
	Deinitialize();
	DNFree(this);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSPData::GetSocketDataRef - retrieves a referenced pointer to this interface's
//								socket data object.  If none has been created yet,
//								allocate one (after which we cannot begin sharing
//								the socket data with another interface object).
//
// Entry:		Nothing
//
// Exit:		Pointer to active socket data
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::GetSocketDataRef"

CSocketData *	CSPData::GetSocketDataRef( void )
{
	CSocketData *	pSocketData;


	DNEnterCriticalSection( &m_Lock );

	if ( m_pSocketData == NULL )
	{
		pSocketData = (CSocketData*) g_SocketDataPool.Get( m_pThreadPool );
		if ( pSocketData != NULL )
		{
			pSocketData->AddRef();
			m_pSocketData = pSocketData;
		}
	}
	else
	{
		m_pSocketData->AddRef();
		pSocketData = m_pSocketData;
	}

	DNLeaveCriticalSection( &m_Lock );

	return pSocketData;
}

#ifdef DBG

#ifndef DPNBUILD_ONLYONEADAPTER
//**********************************************************************
// ------------------------------
// CSPData::DebugPrintOutstandingAdapterEntries - print out all the outstanding adapter entries for this interface
//
// Entry:		None
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CSPData::DebugPrintOutstandingAdapterEntries"

void	CSPData::DebugPrintOutstandingAdapterEntries( void )
{
	CSocketData *		pSocketData;
	CBilink *			pBilink;
	CAdapterEntry *		pAdapterEntry;


	//
	// Don't use GetSocketDataRef to retrieve the socket data because
	// this is just a debug print routine.  We don't want to create the
	// socket data object if it didn't exist.
	//
	Lock();
	if (m_pSocketData != NULL)
	{
		m_pSocketData->AddRef();
		pSocketData = m_pSocketData;
		Unlock();

		DPFX(DPFPREP, 4, "SP data 0x%p (socket data 0x%p) outstanding adapter entries:",
			this, pSocketData);

		pSocketData->Lock();

		pBilink = pSocketData->GetAdapters()->GetNext();
		while (pBilink != pSocketData->GetAdapters())
		{
			pAdapterEntry = CAdapterEntry::AdapterEntryFromAdapterLinkage(pBilink);
			pAdapterEntry->DebugPrintOutstandingSocketPorts();
			pBilink = pBilink->GetNext();
		}
		
		pSocketData->Unlock();
		pSocketData->Release();
		pSocketData = NULL;
	}
	else
	{
		Unlock();

		DPFX(DPFPREP, 4, "SP Data 0x%p does not have socket data.", this);
	}
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYONEADAPTER

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\spaddress.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPAddress.h
 *  Content:	Winsock address base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/11/1999	jtk		Split out to make a base class
 *  01/10/2000	rmt		Updated to build with Millenium build process
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SP_ADDRESS_H__
#define __SP_ADDRESS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// enumerated values for noting which components have been initialized
//
typedef enum
{
	SPADDRESS_PARSE_KEY_DEVICE = 0,
	SPADDRESS_PARSE_KEY_HOSTNAME,
	SPADDRESS_PARSE_KEY_PORT,

	// this must be the last item
	SPADDRESS_PARSE_KEY_MAX
} SPADDRESS_PARSE_KEY_INDEX;

//
// these are only for the debug build, but make sure they don't match
// any legal values, anyway
//
#define	INVALID_SOCKET_FAMILY		0
#define	INVALID_SOCKET_PROTOCOL		5000

//
// types of addresses
//
typedef	enum
{
	SP_ADDRESS_TYPE_UNKNOWN = 0,				// unknown
	SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT,		// address is for local device and dynamically bind to a port
	SP_ADDRESS_TYPE_DEVICE,						// address is for local device the port must be set
	SP_ADDRESS_TYPE_HOST,						// address is for a remote host (default port always used if none specified)
	SP_ADDRESS_TYPE_READ_HOST,					// address is for a remote host address from a socket read
	SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS,		// public address for this host
#ifndef DPNBUILD_NOMULTICAST
	SP_ADDRESS_TYPE_MULTICAST_GROUP,			// multicast group address
#endif // ! DPNBUILD_NOMULTICAST
} SP_ADDRESS_TYPE;

//
// define for any port
//
#define	ANY_PORT	((WORD) 0)

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// external variables
//
extern const WCHAR	g_IPBroadcastAddress[];
extern const DWORD	g_dwIPBroadcastAddressSize;

//**********************************************************************
// Function prototypes
//**********************************************************************
		
//
// GUID encryption/decription code.  Note that it's presently an XOR function
// so map the decryption code to the encryption function.
//
void	EncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncrpytionKey );

inline void	DecryptGuid( const GUID *const pSourceGuid,
						 GUID *const pDestinationGuid,
						 const GUID *const pEncryptionKey ) { EncryptGuid( pSourceGuid, pDestinationGuid, pEncryptionKey ); }


//**********************************************************************
// Class definition
//**********************************************************************

//
// This class assumes that the size of a SOCKADDR is constant, and equal to
// the size of a SOCKADDR_IN and 2 bytes larger than a SOCKADDR_IPX!
//
class	CSocketAddress
{
	public:
		//
		// Pool functions
		//
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolGetFunction( void* pvItem, void* pvContext );
		static void	PoolReturnFunction( void* pvItem );
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetPort"
		WORD	GetPort( void ) const 
		{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			switch (m_SocketAddress.SocketAddress.sa_family)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
			{
#ifndef DPNBUILD_NOIPV6
				case AF_INET6:
				{
					return m_SocketAddress.IPv6SocketAddress.sin6_port; 
					break;
				}
#endif // ! DPNBUILD_NOIPV6
				
#ifndef DPNBUILD_NOIPX
				case AF_IPX:
				{
					return m_SocketAddress.IPXSocketAddress.sa_socket; 
					break;
				}
#endif // ! DPNBUILD_NOIPX
				
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
				default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				{
					DNASSERT(m_SocketAddress.SocketAddress.sa_family == AF_INET);
					return m_SocketAddress.IPSocketAddress.sin_port;			
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
					break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				}
			}
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::SetPort"
		void	SetPort( const WORD wPort ) 
		{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			switch (m_SocketAddress.SocketAddress.sa_family)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
			{
#ifndef DPNBUILD_NOIPV6
				case AF_INET6:
				{
					m_SocketAddress.IPv6SocketAddress.sin6_port = wPort; 
					break;
				}
#endif // ! DPNBUILD_NOIPV6
				
#ifndef DPNBUILD_NOIPX
				case AF_IPX:
				{
					m_SocketAddress.IPXSocketAddress.sa_socket = wPort; 
					break;
				}
#endif // ! DPNBUILD_NOIPX
				
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
				default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				{
					DNASSERT(m_SocketAddress.SocketAddress.sa_family == AF_INET);
					m_SocketAddress.IPSocketAddress.sin_port = wPort;			
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
					break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				}
			}
		}

		void	InitializeWithBroadcastAddress( void );
		void	SetAddressFromSOCKADDR( const SOCKADDR *pAddress, const INT_PTR iAddressSize );
		HRESULT	SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
											 ULONGLONG * const pullKeyID,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
											 const BOOL fAllowNameResolution,
#endif // ! DPNBUILD_ONLYONETHREAD
											 const SP_ADDRESS_TYPE AddressType );
#ifdef DPNBUILD_XNETSECURITY
		IDirectPlay8Address *DP8AddressFromSocketAddress( ULONGLONG * const pullKeyID,
																const XNADDR * const pxnaddr,
																const SP_ADDRESS_TYPE AddressType ) const;
#else // ! DPNBUILD_XNETSECURITY
		IDirectPlay8Address *DP8AddressFromSocketAddress( const SP_ADDRESS_TYPE AddressType ) const;
#endif // ! DPNBUILD_XNETSECURITY

		static BOOL CompareFunction( PVOID pvKey1, PVOID pvKey2 );
		static DWORD HashFunction( PVOID pvKey, BYTE bBitDepth );

		INT_PTR	CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const;

#ifndef DPNBUILD_ONLYONEADAPTER
		HRESULT	EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const;
#ifndef DPNBUILD_NOIPX
		HRESULT	EnumIPXAdapters( SPENUMADAPTERSDATA *const pEnumData ) const;
#endif // ! DPNBUILD_NOIPX
		HRESULT	EnumIPv4Adapters( SPENUMADAPTERSDATA *const pEnumData ) const;
#ifndef DPNBUILD_NOIPV6
		HRESULT	EnumIPv6and4Adapters( SPENUMADAPTERSDATA *const pEnumData ) const;
#endif // ! DPNBUILD_NOIPV6
#endif // ! DPNBUILD_ONLYONEADAPTER

#ifndef DPNBUILD_NOMULTICAST
		HRESULT	EnumMulticastScopes( SPENUMMULTICASTSCOPESDATA *const pEnumData, BOOL const fUseMADCAP ) const;

		HRESULT	SocketAddressFromMulticastDP8Address( IDirectPlay8Address * const pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
													ULONGLONG * const pullKeyID,
#endif // DPNBUILD_XNETSECURITY
													GUID * const pScopeGuid );
#endif // ! DPNBUILD_NOMULTICAST

		void	GuidFromInternalAddressWithoutPort( GUID * pOutputGuid ) const;
		
		BOOL	IsUndefinedHostAddress( void ) const;
		BOOL	IsValidUnicastAddress( BOOL fAllowBroadcastAddress ) const;
#ifndef DPNBUILD_NOREGISTRY
		BOOL	IsBannedAddress( void ) const;
#endif // ! DPNBUILD_NOREGISTRY
		void	ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherAddress );


		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::AddressFromGuid"
#ifdef DPNBUILD_NOIPV6
		void	AddressFromGuid( const GUID * pInputGuid, SOCKADDR * pSocketAddress ) const
#else // ! DPNBUILD_NOIPV6
		void	AddressFromGuid( const GUID * pInputGuid, SOCKADDR_STORAGE * pSocketAddress ) const
#endif // ! DPNBUILD_NOIPV6
		{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			switch (m_SocketAddress.SocketAddress.sa_family)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
			{
#ifndef DPNBUILD_NOIPV6
				case AF_INET6:
				{
					SOCKADDR_IN6 *		psaddrin6 = (SOCKADDR_IN6*) pSocketAddress;

					
					DecryptGuid( pInputGuid, reinterpret_cast<GUID*>( &(psaddrin6->sin6_addr) ), &g_IPSPEncryptionGuid );

					//
					// Link local and site local addresses have the scope ID packed into the
					// address as well.  See CSocketAddress::GuidFromAddress.
					//
					if ((IN6_IS_ADDR_LINKLOCAL(&psaddrin6->sin6_addr)) ||
						(IN6_IS_ADDR_SITELOCAL(&psaddrin6->sin6_addr)))
					{
						WORD *	pawSrcAddr;
						WORD *	pawDstAddr;


						//
						// Copy the scope ID then zero out the parts of the address that
						// were used.
						// The source bits are WORD, but not DWORD aligned.
						//
						pawSrcAddr = (WORD*) (&psaddrin6->sin6_addr);
						pawDstAddr = (WORD*) (&psaddrin6->sin6_scope_id);
						DBG_CASSERT(sizeof(psaddrin6->sin6_scope_id) == 4);
						pawDstAddr[0] = pawSrcAddr[1];
						pawDstAddr[1] = pawSrcAddr[2];
						pawSrcAddr[1] = 0;
						pawSrcAddr[2] = 0;
						DNASSERT(psaddrin6->sin6_scope_id != 0);
					}
					else
					{
						psaddrin6->sin6_scope_id = 0;
					}

					break;
				}
#endif // ! DPNBUILD_NOIPV6
				
#ifndef DPNBUILD_NOIPX
				case AF_IPX:
				{
					DecryptGuid( pInputGuid, reinterpret_cast<GUID*>( pSocketAddress ), &g_IPXSPEncryptionGuid );
					break;
				}
#endif // ! DPNBUILD_NOIPX
				
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
				default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				{
					DNASSERT(m_SocketAddress.SocketAddress.sa_family == AF_INET);
					DecryptGuid( pInputGuid, reinterpret_cast<GUID*>( pSocketAddress ), &g_IPSPEncryptionGuid );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
					break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				}
			}
		}

#ifndef DPNBUILD_NOMULTICAST
#ifdef WINNT
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::CreateScopeGuid"
#ifdef DPNBUILD_NOIPV6
		static void CreateScopeGuid( const MCAST_SCOPE_CTX * const pMcastScopeCtx, const BYTE bTTL, GUID * const pOutputGuid )
#else // ! DPNBUILD_NOIPV6
		static void CreateScopeGuid( const USHORT usAddressFamily, const MCAST_SCOPE_CTX * const pMcastScopeCtx, const BYTE bTTL, GUID * const pOutputGuid )
#endif // ! DPNBUILD_NOIPV6
		{
			GUID	guidTemp;
			BYTE *	pCurrent;


#ifndef DPNBUILD_NOIPV6
			if (usAddressFamily == AF_INET6)
			{
#pragma TODO(vanceo, "Make IPv6 ready"
			}
			else
#endif // ! DPNBUILD_NOIPV6
			{
				DBG_CASSERT( (sizeof( pMcastScopeCtx->ScopeID.IpAddrV4 ) + sizeof( pMcastScopeCtx->Interface.IpAddrV4 ) + sizeof( pMcastScopeCtx->ServerID.IpAddrV4 ) + sizeof( bTTL ) ) <= sizeof( guidTemp ) );

				memset( &guidTemp, 0, sizeof( guidTemp ) );
				pCurrent = reinterpret_cast<BYTE*>( &guidTemp );

				memcpy( pCurrent, &pMcastScopeCtx->ScopeID.IpAddrV4, sizeof( pMcastScopeCtx->ScopeID.IpAddrV4 ) );
				pCurrent += sizeof( pMcastScopeCtx->ScopeID.IpAddrV4 );
				memcpy( pCurrent, &pMcastScopeCtx->Interface.IpAddrV4, sizeof( pMcastScopeCtx->Interface.IpAddrV4 ) );
				pCurrent += sizeof( pMcastScopeCtx->Interface.IpAddrV4 );
				memcpy( pCurrent, &pMcastScopeCtx->ServerID.IpAddrV4, sizeof( pMcastScopeCtx->ServerID.IpAddrV4 ) );
				pCurrent += sizeof( pMcastScopeCtx->ServerID.IpAddrV4 );
				*pCurrent = bTTL;
			}

			EncryptGuid( &guidTemp, pOutputGuid, &g_IPSPEncryptionGuid );
		}

		static void GetScopeGuidMcastScopeCtx( const GUID * const pInputGuid, MCAST_SCOPE_CTX * const pMcastScopeCtx )
		{
			GUID	guidTemp;
			BYTE *	pCurrent;


			DecryptGuid( pInputGuid, &guidTemp, &g_IPSPEncryptionGuid );

			pCurrent = reinterpret_cast<BYTE*>( &guidTemp );
			memcpy( &pMcastScopeCtx->ScopeID.IpAddrV4, pCurrent, sizeof( pMcastScopeCtx->ScopeID.IpAddrV4 ) );
			pCurrent += sizeof( pMcastScopeCtx->ScopeID.IpAddrV4 );
			memcpy( &pMcastScopeCtx->Interface.IpAddrV4, pCurrent, sizeof( pMcastScopeCtx->Interface.IpAddrV4 ) );
			pCurrent += sizeof( pMcastScopeCtx->Interface.IpAddrV4 );
			memcpy( &pMcastScopeCtx->ServerID.IpAddrV4, pCurrent, sizeof( pMcastScopeCtx->ServerID.IpAddrV4 ) );
		}
#endif // WINNT

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetScopeGuidTTL"
		static BYTE GetScopeGuidTTL( const GUID * const pInputGuid )
		{
			GUID	guidTemp;
			BYTE *	pCurrent;
			BYTE	bTTL;


			DecryptGuid( pInputGuid, &guidTemp, &g_IPSPEncryptionGuid );
			pCurrent = reinterpret_cast<BYTE*>( &guidTemp );
			bTTL = *(pCurrent + ( sizeof( DWORD ) * 3 ));
			if (bTTL == 0)
			{
				DPFX(DPFPREP, 0, "Overriding invalid TTL, setting to 1!", 0);
				bTTL = 1;
			}
			return bTTL;
		}
#endif // ! DPNBUILD_NOMULTICAST


		const SOCKADDR *GetAddress( void ) const { return	&m_SocketAddress.SocketAddress; }

		SOCKADDR	*GetWritableAddress( void ) { return &m_SocketAddress.SocketAddress; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetAddressSize"
		const INT	GetAddressSize( void ) const
		{
			DNASSERT( m_iSocketAddressSize != 0 );
			return	m_iSocketAddressSize;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::CopyAddressSettings"
		void	CopyAddressSettings( const CSocketAddress * const pOtherAddress )
		{
			DBG_CASSERT( sizeof( m_SocketAddress ) == sizeof( pOtherAddress->m_SocketAddress ) );
			memcpy( &m_SocketAddress, &pOtherAddress->m_SocketAddress, sizeof( m_SocketAddress ) );
			m_iSocketAddressSize = pOtherAddress->m_iSocketAddressSize;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetFamily"
		USHORT	GetFamily( void ) const
		{
			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPSocketAddress.sin_family ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IN, sin_family ) );
#ifndef DPNBUILD_NOIPV6
			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPv6SocketAddress.sin6_family ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IN6, sin6_family ) );
#endif // DPNBUILD_NOIPV6
#ifndef DPNBUILD_NOIPX
			DBG_CASSERT( sizeof( m_SocketAddress.SocketAddress.sa_family ) == sizeof( m_SocketAddress.IPXSocketAddress.sa_family ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR, sa_family ) == OFFSETOF( SOCKADDR_IPX, sa_family ) );
#endif // DPNBUILD_NOIPX

			DNASSERT( m_SocketAddress.SocketAddress.sa_family != INVALID_SOCKET_FAMILY );
#ifdef DPNBUILD_NOIPX
#ifdef DPNBUILD_NOIPV6
			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ));
#else
			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_INET6 ));
#endif // DPNBUILD_NOIPV6
#else
#ifdef DPNBUILD_NOIPV6
			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ));
#else
			DNASSERT( ( m_SocketAddress.SocketAddress.sa_family == AF_INET ) || ( m_SocketAddress.SocketAddress.sa_family == AF_INET6 ) || ( m_SocketAddress.SocketAddress.sa_family == AF_IPX ));
#endif // DPNBUILD_NOIPV6
#endif // DPNBUILD_NOIPX
			return	m_SocketAddress.SocketAddress.sa_family;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::SetFamilyProtocolAndSize"
		void	SetFamilyProtocolAndSize( short sFamily )
		{
			memset( &m_SocketAddress, 0x00, sizeof( m_SocketAddress ) );

			switch (sFamily)
			{
#ifndef DPNBUILD_NOIPV6
				case AF_INET6:
				{
					m_SocketAddress.IPv6SocketAddress.sin6_family = AF_INET6;
					m_iSocketAddressSize = sizeof( m_SocketAddress.IPv6SocketAddress );
					m_iSocketProtocol = IPPROTO_UDP;
					break;
				}
#endif // ! DPNBUILD_NOIPV6
				
#ifndef DPNBUILD_NOIPX
				case AF_IPX:
				{
					m_SocketAddress.IPXSocketAddress.sa_family = AF_IPX;
					m_iSocketAddressSize = sizeof( m_SocketAddress.IPXSocketAddress );
					m_iSocketProtocol = NSPROTO_IPX;
					break;
				}
#endif // ! DPNBUILD_NOIPX
				
				case AF_INET:
				{
					m_SocketAddress.IPSocketAddress.sin_family = AF_INET;
					m_iSocketAddressSize = sizeof( m_SocketAddress.IPSocketAddress );
					m_iSocketProtocol = IPPROTO_UDP;
					break;
				}

				default:
				{
					DNASSERT(FALSE);
				}
			}
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSocketAddress::GetProtocol"
		INT	GetProtocol( void ) const
		{
			DNASSERT( m_iSocketProtocol != INVALID_SOCKET_PROTOCOL );
#ifndef DPNBUILD_NOIPX
			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) || ( m_iSocketProtocol == NSPROTO_IPX ) );
#else
			DNASSERT( ( m_iSocketProtocol == IPPROTO_UDP ) );
#endif // DPNBUILD_NOIPX
				
			return	m_iSocketProtocol;
		}

	protected:
		BYTE				m_Sig[4];	// debugging signature ('SPAD')

		//
		// combine all of the SOCKADDR variants into one item
		//
		union
		{
			SOCKADDR		SocketAddress;
			SOCKADDR_IN		IPSocketAddress;
#ifndef DPNBUILD_NOIPV6
			SOCKADDR_IN6	IPv6SocketAddress;
#endif // DPNBUILD_NOIPV6
#ifndef DPNBUILD_NOIPX
			SOCKADDR_IPX	IPXSocketAddress;
#endif // DPNBUILD_NOIPX
		} m_SocketAddress;

		INT				m_iSocketAddressSize;
		INT				m_iSocketProtocol;
		
	private:

		void	GuidFromAddress( GUID * pOutputGuid, const SOCKADDR * pSocketAddress ) const;
};

#undef DPF_MODNAME

#endif	// __SP_ADDRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\spdata.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		SPData.h
 *  Content:	Global information for the DPNWSOCK service provider in class
 *				format.
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/15/1999	jtk		Derived from Locals.h
 *  03/22/2000	jtk		Updated with changes to interface names
 ***************************************************************************/

#ifndef __SPDATA_H__
#define __SPDATA_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

#define	DEFAULT_ADDRESS_BUFFER_SIZE	151

//
// enumeration of the states the SP can be in
//
typedef enum
{
	SPSTATE_UNKNOWN = 0,		// uninitialized state
	SPSTATE_UNINITIALIZED = 0,	// uninitialized state
	SPSTATE_INITIALIZED,		// service provider has been initialized
	SPSTATE_CLOSING				// service provider is closing
} SPSTATE;

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

// forward structure and class references
class	CCommandData;
class	CEndpoint;
class	CSocketAddress;
class	CSocketPort;
class	CThreadPool;
typedef	enum	_ENDPOINT_TYPE		ENDPOINT_TYPE;
typedef	enum	_GATEWAY_BIND_TYPE	GATEWAY_BIND_TYPE;
typedef	struct	_SPRECEIVEDBUFFER	SPRECEIVEDBUFFER;

//**********************************************************************
// Class definitions
//**********************************************************************

//
// class for information used by the provider
//
class	CSPData
{
	public:
		CSPData()	{};
		~CSPData()	{};
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::AddRef"
		LONG	AddRef( void ) 
		{
			LONG	lResult;

			lResult = DNInterlockedIncrement( const_cast<LONG*>(&m_lRefCount) );
			DPFX(DPFPREP, 9, "(0x%p) Refcount = %i.", this, lResult);
			return lResult;
		}
		
		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::DecRef"
		LONG	DecRef( void )
		{
			LONG	lResult;


			DNASSERT( m_lRefCount != 0 );	
			lResult = DNInterlockedDecrement( const_cast<LONG*>(&m_lRefCount) );
			if ( lResult == 0 )
			{
				DPFX(DPFPREP, 9, "(0x%p) Refcount = 0, destroying this object.", this);

				//
				// WARNING, the following function deletes this object!!!
				//
				DestroyThisObject();
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Refcount = %i.", this, lResult);
			}

			return lResult;
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectAddRef"
		void	ObjectAddRef( void )
		{
			LONG	lResult;


			AddRef();
			
			Lock();

			//
			// This is actually bogus on 95, since you can only count on
			// negative, 0, or positive.  Doesn't seem to hurt, though.
			//
			lResult = DNInterlockedIncrement( const_cast<LONG*>(&m_lObjectRefCount) );
			if ( lResult == 1 )
			{
				DPFX(DPFPREP, 8, "(0x%p) Resetting shutdown event.",
					this);
				
				DNASSERT( m_hShutdownEvent != NULL );
				if ( DNResetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Failed to reset shutdown event!");
					DisplayErrorCode( 0, dwError );
				}
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Not resetting shutdown event, refcount = %i.",
					this, lResult);
			}

			Unlock();
		}

		#undef DPF_MODNAME
		#define	DPF_MODNAME "CSPData::ObjectDecRef"
		void	ObjectDecRef( void )
		{
			LONG	lResult;


			Lock();

			lResult = DNInterlockedDecrement( const_cast<LONG*>(&m_lObjectRefCount) );
			if ( lResult == 0 )
			{
				DPFX(DPFPREP, 8, "(0x%p) Setting shutdown event.",
					this);
				
				if ( DNSetEvent( m_hShutdownEvent ) == FALSE )
				{
					DWORD	dwError;


					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Failed to set shutdown event!");
					DisplayErrorCode( 0, dwError );
				}
			}
			else
			{
				DPFX(DPFPREP, 9, "(0x%p) Not setting shutdown event, refcount = %i.",
					this, lResult);
			}
			
			Unlock();
			
			DecRef();
		}
		

		HRESULT	Initialize(
							IDP8ServiceProviderVtbl *const pVtbl
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
							,const short sSPType
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							,const XDP8CREATE_PARAMS * const pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
							);
		void	Deinitialize( void );
		HRESULT	Startup( SPINITIALIZEDATA *pInitializeData );
		void	Shutdown( void );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		short	GetType( void ) const { return m_sSPType; }
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX

		const SPSTATE	GetState( void ) const { return m_SPState; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetState"
		void SetState( const SPSTATE NewState )
		{
			DNASSERT( ( NewState == SPSTATE_UNINITIALIZED ) ||
					  ( NewState == SPSTATE_INITIALIZED ) ||
					  ( NewState == SPSTATE_CLOSING ) );

			m_SPState = NewState;
		}

		CThreadPool	*GetThreadPool( void ) const { return m_pThreadPool; }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetThreadPool"
		void	SetThreadPool( CThreadPool *const pThreadPool )
		{
			DNASSERT( ( m_pThreadPool == NULL ) || ( pThreadPool == NULL ) );
			m_pThreadPool = pThreadPool;
		}


		//
		// functions to manage the endpoint list
		//
		HRESULT	BindEndpoint( CEndpoint *const pEndpoint,
							  IDirectPlay8Address *const pDeviceAddress,
							  const CSocketAddress *const pSocketAddress,
							  const GATEWAY_BIND_TYPE GatewayBindType );
		void	UnbindEndpoint( CEndpoint *const pEndpoint );
#ifndef DPNBUILD_NOMULTICAST
		HRESULT	GetEndpointFromAddress( IDirectPlay8Address *const pHostAddress,
									  IDirectPlay8Address *const pDeviceAddress,
									  HANDLE * phEndpoint,
									  PVOID * ppvEndpointContext );
#endif // ! DPNBUILD_NOMULTICAST


		//
		// endpoint pool management
		//
		CEndpoint	*GetNewEndpoint( void );
		CEndpoint	*EndpointFromHandle( const HANDLE hEndpoint );
		void		CloseEndpointHandle( CEndpoint *const pEndpoint );
		CEndpoint	*GetEndpointAndCloseHandle( const HANDLE hEndpoint );

#ifndef DPNBUILD_NONATHELP
		void	MungePublicAddress( const CSocketAddress * const pDeviceBaseAddress, CSocketAddress * const pPublicAddress, const BOOL fEnum );
#endif // !DPNBUILD_NONATHELP

		IDP8SPCallback	*DP8SPCallbackInterface( void ) { return reinterpret_cast<IDP8SPCallback*>( m_InitData.pIDP ); }
		IDP8ServiceProvider	*COMInterface( void ) { return reinterpret_cast<IDP8ServiceProvider*>( &m_COMInterface ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SPDataFromCOMInterface"
		static	CSPData	*SPDataFromCOMInterface( IDP8ServiceProvider *const pCOMInterface )
		{
			CSPData *	pResult;
			
			
			DNASSERT( pCOMInterface != NULL );
			
			DBG_CASSERT( sizeof( BYTE* ) == sizeof( pCOMInterface ) );
			DBG_CASSERT( sizeof( CSPData* ) == sizeof( BYTE* ) );

			pResult = reinterpret_cast<CSPData*>( &reinterpret_cast<BYTE*>( pCOMInterface )[ -OFFSETOF( CSPData, m_COMInterface ) ] );

			// Verify signature is 'TDPS' DWORD a.k.a. 'SPDT' in bytes.
			DNASSERT(*((DWORD*) (&pResult->m_Sig)) == 0x54445053);

			return pResult;
		}

#ifndef WINCE
		void	SetWinsockBufferSizeOnAllSockets( const INT iBufferSize );
#endif // ! WINCE

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::GetSocketData"
		CSocketData *	GetSocketData( void )
		{
			return m_pSocketData;
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CSPData::SetSocketData"
		void	SetSocketData( CSocketData * const pSocketData )
		{
			AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
			m_pSocketData = pSocketData;
		}
		CSocketData *	GetSocketDataRef( void );



	private:
		BYTE					m_Sig[4];				// debugging signature ('SPDT')
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION		m_Lock;					// lock
#endif // !DPNBUILD_ONLYONETHREAD
		volatile LONG			m_lRefCount;			// reference count
		volatile LONG			m_lObjectRefCount;		// reference count of outstanding objects (CEndpoint, CSocketPort, etc.)
		DNHANDLE				m_hShutdownEvent;		// handle for shutdown
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		short					m_sSPType;				// type of SP (AF_xxx)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		SPSTATE					m_SPState;				// what state is the SP in?
		SPINITIALIZEDATA		m_InitData;				// initialization data

		//
		// job management
		//
		CThreadPool				*m_pThreadPool;

		CSocketData				*m_pSocketData;			// pointer to socket port data
		

		struct
		{
			IDP8ServiceProviderVtbl	*m_pCOMVtbl;
		} m_COMInterface;

		void	DestroyThisObject( void );

#ifdef DBG
#ifndef DPNBUILD_ONLYONEADAPTER
		void	DebugPrintOutstandingAdapterEntries( void );
#endif // ! DPNBUILD_ONLYONEADAPTER
#endif // DBG
		
		//
		// prevent unwarranted copies
		//
		CSPData( const CSPData & );
		CSPData& operator=( const CSPData & );
};

#undef DPF_MODNAME

#endif	// __SPDATA_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\spaddress.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SPAddress.cpp
 *  Content:	Winsock address base class
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	01/20/1999	jtk		Created
 *	05/12/1999	jtk		Derived from modem endpoint class
 ***************************************************************************/

#include "dnwsocki.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum allowed hostname string size, in bytes, including NULL termination
//
#define	MAX_HOSTNAME_SIZE						512

//
// broadcast address as a string
//
const WCHAR	g_IPBroadcastAddress[]				= L"255.255.255.255";
const DWORD	g_dwIPBroadcastAddressSize			= sizeof( g_IPBroadcastAddress );

//
// string for IP helper API
//
static const TCHAR		c_tszIPHelperDLLName[]			= TEXT("IPHLPAPI.DLL");
static const char		c_szAdapterNameTemplate[]		= "%s - %s";

#ifndef DPNBUILD_NOIPX
//
// length of IPX host names 'xxxxxxxx,xxxxxxxxxxxx' including NULL
//
#define	IPX_ADDRESS_STRING_LENGTH				22

//
// default broadcast and listen addresses
//
static const WCHAR	g_IPXBroadcastAddress[]		= L"00000000,FFFFFFFFFFFF";
static const WCHAR	g_IPXListenAddress[]		= L"00000000,000000000000";

//
// string used for single IPX adapter
//
static const WCHAR	g_IPXAdapterString[]		= L"Local IPX Adapter";

#endif // ! DPNBUILD_NOIPX

#ifndef DPNBUILD_NOIPV6

static const WCHAR		c_wszIPv6AdapterNameTemplate[]	= L"%s - IPv6 - %s";
static const WCHAR		c_wszIPv4AdapterNameTemplate[]	= L"%s - IPv4 - %s";
static const WCHAR		c_wszIPv6AdapterNameNoDescTemplate[]	= L"IPv6 - %s";
static const WCHAR		c_wszIPv4AdapterNameNoDescTemplate[]	= L"IPv4 - %s";

//
// string used for IPv4 loopback adapter
//
static const WCHAR		c_wszIPv4LoopbackAdapterString[]	= L"IPv4 Loopback Adapter";

#endif // ! DPNBUILD_NOIPV6


#ifndef DPNBUILD_NOMULTICAST
//
// 238.1.1.1 in network byte order
//
#define SAMPLE_MULTICAST_ADDRESS				0x010101EE

#define INVALID_INTERFACE_INDEX					-1

static const WCHAR	c_wszPrivateScopeString[]	= L"Private Multicast Scope - TTL " MULTICAST_TTL_PRIVATE_AS_STRING;
static const WCHAR	c_wszLocalScopeString[]		= L"Local Multicast Scope - TTL " MULTICAST_TTL_LOCAL_AS_STRING;
static const WCHAR	c_wszGlobalScopeString[]	= L"Global Multicast Scope - TTL " MULTICAST_TTL_GLOBAL_AS_STRING;
#endif // ! DPNBUILD_NOMULTICAST

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#ifndef DPNBUILD_NOIPV6

typedef struct _SORTADAPTERADDRESS
{
	SOCKADDR *		psockaddr;
	WCHAR *			pwszDescription;
} SORTADAPTERADDRESS;

#endif // ! DPNBUILD_NOIPV6


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifndef DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOWINSOCK2
typedef DWORD (WINAPI *PFNGETADAPTERSINFO)(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);

#ifndef DPNBUILD_NOMULTICAST
typedef DWORD (WINAPI *PFNGETBESTINTERFACE)(IPAddr dwDestAddr, PDWORD pdwBestIfIndex);
#endif // ! DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_NOIPV6
typedef DWORD (WINAPI *PFNGETADAPTERSADDRESSES)(ULONG ulFamily, DWORD dwFlags, PVOID pvReserved, PIP_ADAPTER_ADDRESSES pAdapterAddresses, PULONG pulOutBufLen);
#endif // ! DPNBUILD_NOIPV6

#endif // ! DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_ONLYONEADAPTER

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketAddress::InitializeWithBroadcastAddress - initialize with the IP broadcast address
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::InitializeWithBroadcastAddress"

void	CSocketAddress::InitializeWithBroadcastAddress( void )
{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( DWORD ) );
			*reinterpret_cast<DWORD*>( m_SocketAddress.IPXSocketAddress.sa_netnum ) = 0x00000000;
			
			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 6 );
			DBG_CASSERT( sizeof( DWORD ) == 4 );
			*reinterpret_cast<DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum ) = 0xFFFFFFFF;
			*reinterpret_cast<DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ 2 ] ) = 0xFFFFFFFF;
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		case AF_INET:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = INADDR_BROADCAST;
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
		}

		default:
		{
			//
			// We should never try to initialize an IPv6 address with the broadcast
			// address.  We use IPv4 broadcast addresses, and then convert to the
			// IPv6 enum multicast address on the fly.
			//
			DNASSERT(FALSE);
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSocketAddress::SetAddressFromSOCKADDR - set address from a socket address
//
// Entry:		Reference to address
//				Size of address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::SetAddressFromSOCKADDR"

void	CSocketAddress::SetAddressFromSOCKADDR( const SOCKADDR *pAddress, const INT_PTR iAddressSize )
{
	DNASSERT( iAddressSize == GetAddressSize() );
	memcpy( &m_SocketAddress.SocketAddress, pAddress, iAddressSize );

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			//
			// We don't validate anything in the address.
			//
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			//
			// IPX addresses are only 14 of the 16 bytes in the socket address structure,
			// make sure the extra bytes are zero!
			//
			DNASSERT( m_SocketAddress.SocketAddress.sa_data[ 12 ] == 0 );
			DNASSERT( m_SocketAddress.SocketAddress.sa_data[ 13 ] == 0 );
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			//
			// Since Winsock won't guarantee that the sin_zero part of an IP address is
			// really zero, we need to do it ourself.  If we don't, it'll make a mess out
			// of the Guid<-->Address code.
			//
			DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress.sin_zero[ 0 ] ) == sizeof( DWORD* ) );
			DBG_CASSERT( sizeof( &m_SocketAddress.IPSocketAddress.sin_zero[ sizeof( DWORD ) ] ) == sizeof( DWORD* ) );
			*reinterpret_cast<DWORD*>( &m_SocketAddress.IPSocketAddress.sin_zero[ 0 ] ) = 0;
			*reinterpret_cast<DWORD*>( &m_SocketAddress.IPSocketAddress.sin_zero[ sizeof( DWORD ) ] ) = 0;
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketAddress::SocketAddressFromDP8Address - convert a DP8Address into a socket address
//											NOTE: The address object may be modified
//
// Entry:		Pointer to DP8Address
//				Secure transport key ID, or NULL if none.
//				Whether name resoultion (potentially blocking) is allowed.
//				Address type
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::SocketAddressFromDP8Address"

HRESULT	CSocketAddress::SocketAddressFromDP8Address( IDirectPlay8Address *const pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
													ULONGLONG * const pullKeyID,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
													const BOOL fAllowNameResolution,
#endif // ! DPNBUILD_ONLYONETHREAD
													const SP_ADDRESS_TYPE AddressType )
{
	HRESULT		hr;
	HRESULT		hTempResult;
	BYTE		abBuffer[MAX_HOSTNAME_SIZE];
	DWORD		dwPort;
	DWORD		dwTempSize;
	DWORD		dwDataType;
#ifndef DPNBUILD_ONLYONEADAPTER
	GUID		AdapterGuid;
#endif // ! DPNBUILD_ONLYONEADAPTER


	DPFX(DPFPREP, 8, "(0x%p) Parameters: (0x%p, %u)", this, pDP8Address, AddressType);

	//
	// initialize
	//
	hr = DPN_OK;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			DNASSERT( pDP8Address != NULL );
#ifdef DPNBUILD_XNETSECURITY
			DNASSERT( pullKeyID == NULL );
#endif // DPNBUILD_XNETSECURITY

			//
			// the address type will determine how the address is handled
			//
			switch ( AddressType )
			{
				//
				// local device address, ask for the device guid and port to build a socket
				// address
				//
				case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
				case SP_ADDRESS_TYPE_DEVICE:
				{
					union
					{
						SOCKADDR			SocketAddress;
						SOCKADDR_IPX		IPXSocketAddress;
#ifndef DPNBUILD_NOIPV6
						SOCKADDR_STORAGE	SocketAddressStorage;
#endif // ! DPNBUILD_NOIPV6
					} NetAddress;


					//
					// Ask for the adapter guid.  If none is found, fail.
					//
					dwTempSize = sizeof( AdapterGuid );
					hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_DEVICE, &AdapterGuid, &dwTempSize, &dwDataType );
					switch ( hTempResult )
					{
						//
						// ok
						//
						case DPN_OK:
						{
							DNASSERT( dwDataType == DPNA_DATATYPE_GUID );
							break;
						}

						//
						// remap missing component to 'addressing' error
						//
						case DPNERR_DOESNOTEXIST:
						{
							hr = DPNERR_ADDRESSING;
							goto Failure;
							break;
						}

						default:
						{
							hr = hTempResult;
							goto Failure;
							break;
						}
					}
					DNASSERT( sizeof( AdapterGuid ) == dwTempSize );

					//
					// Ask for the port.  If none is found, choose a default.
					//
					dwTempSize = sizeof( dwPort );
					hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
					switch ( hTempResult )
					{
						//
						// port present, nothing to do
						//
						case DPN_OK:
						{
							DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
							break;
						}

						//
						// port not present, fill in the appropriate default
						//
						case DPNERR_DOESNOTEXIST:
						{
							DNASSERT( hr == DPN_OK );
							switch ( AddressType )
							{
								case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
								{
									dwPort = ANY_PORT;
									break;
								}

								default:
								{
									DNASSERT( FALSE );
									break;
								}
							}

							break;
						}

						//
						// other error, fail
						//
						default:
						{
							hr = hTempResult;
							goto Failure;
							break;
						}
					}
					DNASSERT( sizeof( dwPort ) == dwTempSize );

					//
					// convert the GUID to an address in temp space because the GUID contains ALL address information (port, etc)
					// and we don't want to blindly wail on any information that might have already been set.  Verify data
					// integrity and then only copy the raw address.
					//
#ifndef DPNBUILD_NOIPV6
					AddressFromGuid( &AdapterGuid, &NetAddress.SocketAddressStorage );
#else // ! DPNBUILD_NOIPV6
					AddressFromGuid( &AdapterGuid, &NetAddress.SocketAddress );
#endif // ! DPNBUILD_NOIPV6
					if ( NetAddress.IPXSocketAddress.sa_family != m_SocketAddress.IPXSocketAddress.sa_family )
					{
						DNASSERT( FALSE );
						hr = DPNERR_ADDRESSING;
						DPFX(DPFPREP,  0, "Invalid device guid!" );
						goto Failure;
					}

					DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress ) == sizeof( NetAddress.IPXSocketAddress ) );
					memcpy( &m_SocketAddress.IPXSocketAddress, &NetAddress.IPXSocketAddress, sizeof( m_SocketAddress.IPXSocketAddress ) );
					m_SocketAddress.IPXSocketAddress.sa_socket = HTONS( static_cast<WORD>( dwPort ) );
					break;
				}

				//
				// hostname
				//
				case SP_ADDRESS_TYPE_HOST:
				{
					//
					// Ask for the port.  If none is found, choose a default.
					//
					dwTempSize = sizeof( dwPort );
					hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
					switch ( hTempResult )
					{
						//
						// port present, nothing to do
						//
						case DPN_OK:
						{
							DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
							m_SocketAddress.IPXSocketAddress.sa_socket = HTONS( static_cast<WORD>( dwPort ) );
							break;
						}

						//
						// port not present, fill in the appropriate default
						//
						case DPNERR_DOESNOTEXIST:
						{
#ifdef DPNBUILD_SINGLEPROCESS
							const DWORD	dwTempPort = BASE_DPLAY8_PORT;
#else // ! DPNBUILD_SINGLEPROCESS
							const DWORD	dwTempPort = DPNA_DPNSVR_PORT;
#endif // ! DPNBUILD_SINGLEPROCESS


							m_SocketAddress.IPXSocketAddress.sa_socket = HTONS( static_cast<const WORD>( dwTempPort ) );
							hTempResult = IDirectPlay8Address_AddComponent( pDP8Address,
																			DPNA_KEY_PORT,
																			&dwTempPort,
																			sizeof( dwTempPort ),
																			DPNA_DATATYPE_DWORD
																			);
							if ( hTempResult != DPN_OK )
							{
								hr = hTempResult;
								goto Failure;
							}

							break;
						}

						//
						// remap everything else to an addressing failure
						//
						default:
						{
							hr = DPNERR_ADDRESSING;
							goto Failure;
						}
					}

					//
					// attempt to determine host name
					//
					dwTempSize = sizeof(abBuffer);
					hr = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_HOSTNAME, abBuffer, &dwTempSize, &dwDataType );
					switch ( hr )
					{
						//
						// keep the following codes and fail
						//
						case DPNERR_OUTOFMEMORY:
						case DPNERR_INCOMPLETEADDRESS:
						{
							goto Failure;
							break;
						}

						//
						// no problem
						//
						case DPN_OK:
						{
							switch (dwDataType)
							{
								case DPNA_DATATYPE_STRING:
								{
									BYTE	abBuffer2[MAX_HOSTNAME_SIZE];


									//
									// Unicode string, convert it to ANSI.
									//
									dwTempSize /= sizeof(WCHAR);
									hr = STR_jkWideToAnsi( (char*) abBuffer2, (WCHAR*) abBuffer, dwTempSize );
									if ( hr != DPN_OK )
									{
										DPFX(DPFPREP, 0, "Failed to convert hostname to ANSI!" );
										DisplayDNError( 0, hr );
										goto Failure;
									}

									strncpy((char*) abBuffer, (char*) abBuffer2, dwTempSize);

									//
									// Fall through...
									//
								}

								case DPNA_DATATYPE_STRING_ANSI:
								{
									long		val;
									char		temp[3];
									char		*a, *b;
									UINT_PTR	uIndex;


									//
									// convert the text host name into the SOCKADDR structure
									//

									if ( dwTempSize != IPX_ADDRESS_STRING_LENGTH )
									{
										DPFX(DPFPREP,  0, "Invalid IPX net/node.  Must be %d bytes of ASCII hex (net,node:socket)", ( IPX_ADDRESS_STRING_LENGTH - 1 ) );
										DPFX(DPFPREP,  0, "IPXAddressFromDP8Address: Failed to parse IPX host name!" );
										goto Failure;
									}

									// we convert the string for the hostname field into the components
									temp[ 2 ] = 0;
									a = (char*) abBuffer;

									// the net number is 4 bytes
									for ( uIndex = 0; uIndex < 4; uIndex++ )
									{
										strncpy( temp, a, 2 );
										val = strtol( temp, &b, 16 );
										m_SocketAddress.IPXSocketAddress.sa_netnum[ uIndex ] = (char) val;
										a += 2;
									}

									// followed by a dot
									a++;

									// the node is 6 bytes
									for ( uIndex = 0; uIndex < 6; uIndex++ )
									{
										strncpy( temp, a, 2 );
										val = strtol( temp, &b, 16 );
										m_SocketAddress.IPXSocketAddress.sa_nodenum[ uIndex ] = (char) val;
										a += 2;
									}

									break;
								}

								default:
								{
									DPFX(DPFPREP, 0, "Hostname component wasn't a string (%u)!", dwDataType );
									hr = DPNERR_ADDRESSING;
									goto Failure;
									break;
								}
							}
							break;
						}

						//
						// hostname does not exist, treat as an incomplete address
						//
						case DPNERR_DOESNOTEXIST:
						{
							hr = DPNERR_INCOMPLETEADDRESS;
							break;
						}

						//
						// remap other errors to an addressing error
						//
						default:
						{
							DNASSERT( FALSE );
							hr = DPNERR_ADDRESSING;
							goto Failure;
							break;
						}
					}

					break;
				}

				//
				// unknown address type
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
#endif // ! DPNBUILD_NOIPV6
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			DNASSERT( pDP8Address != NULL );

			switch ( AddressType )
			{
				//
				// local device address, ask for the device guid and port to build a socket
				// address
				//
				case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
				case SP_ADDRESS_TYPE_DEVICE:
				{
					union
					{
						SOCKADDR			SocketAddress;
						SOCKADDR_IN		INetAddress;
#ifndef DPNBUILD_NOIPV6
						SOCKADDR_IN6		INet6Address;
						SOCKADDR_STORAGE	SocketAddressStorage;
#endif // ! DPNBUILD_NOIPV6
					} INetSocketAddress;
#ifdef DPNBUILD_ONLYONEADAPTER
					XNADDR		xnaddr;
					DWORD		dwStatus;

					
#else // ! DPNBUILD_ONLYONEADAPTER


					//
					// Ask for the adapter guid.  If none is found, fail.
					//
					hTempResult = IDirectPlay8Address_GetDevice( pDP8Address, &AdapterGuid );
					switch ( hTempResult )
					{
						//
						// ok
						//
						case DPN_OK:
						{
							break;
						}

						//
						// remap missing component to 'addressing' error
						//
						case DPNERR_DOESNOTEXIST:
						{
							DPFX(DPFPREP, 0, "Device GUID does not exist!" );
							DNASSERTX(! "Device GUID does not exist", 2);
							hr = DPNERR_ADDRESSING;
							goto Failure;
							break;
						}

						default:
						{
							DPFX(DPFPREP, 0, "Couldn't get device (0x%lx)!", hr );
							hr = hTempResult;
							goto Failure;
							break;
						}
					}
#endif // ! DPNBUILD_ONLYONEADAPTER

					//
					// Ask for the port.  If none is found, choose a default.
					//
					dwTempSize = sizeof( dwPort );
					hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
					switch ( hTempResult )
					{
						//
						// port present, nothing to do
						//
						case DPN_OK:
						{
							DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
							break;
						}

						//
						// port not present, fill in the appropriate default
						//
						case DPNERR_DOESNOTEXIST:
						{
							DPFX(DPFPREP, 6, "Port component does not exist in address 0x%p.", pDP8Address );
							DNASSERT( hr == DPN_OK );
							switch ( AddressType )
							{
								case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
								{
									dwPort = ANY_PORT;
									break;
								}

								default:
								{
									DNASSERT( FALSE );
									break;
								}
							}

							break;
						}

						//
						// other error, fail
						//
						default:
						{
							DPFX(DPFPREP, 0, "Couldn't get port component (0x%lx)!", hr );
							hr = hTempResult;
							goto Failure;
							break;
						}
					}
					DNASSERT( sizeof( dwPort ) == dwTempSize );


#ifdef DPNBUILD_ONLYONEADAPTER
					DNASSERT( GetFamily() == AF_INET );
					//
					// Zero out the entire structure.  This implies we use INADDR_ANY.
					//
					memset(&INetSocketAddress, 0, sizeof(INetSocketAddress));

					dwStatus = XNetGetTitleXnAddr(&xnaddr);
					if ((dwStatus != XNET_GET_XNADDR_PENDING) &&
						(dwStatus != XNET_GET_XNADDR_NONE))
					{
						DPFX(DPFPREP, 5, "Using device %u.%u.%u.%u.",
							xnaddr.ina.S_un.S_un_b.s_b1,
							xnaddr.ina.S_un.S_un_b.s_b2,
							xnaddr.ina.S_un.S_un_b.s_b3,
							xnaddr.ina.S_un.S_un_b.s_b4);
						INetSocketAddress.INetAddress.sin_addr.S_un.S_addr = xnaddr.ina.S_un.S_addr;
					}
					else
					{
						DPFX(DPFPREP, 1, "Couldn't get XNet address, status = %u.",
							dwStatus);
					}
#else // ! DPNBUILD_ONLYONEADAPTER
					//
					// convert the GUID to an address in temp space because the GUID is large enough to potentially hold
					// ALL address information (port, etc) and we don't want to blindly wail on any information that might
					// have already been set.  Verify data integrity and then only copy the raw address.
					//
#ifdef DPNBUILD_NOIPV6
					AddressFromGuid( &AdapterGuid, &INetSocketAddress.SocketAddress );
#else // ! DPNBUILD_NOIPV6
					AddressFromGuid( &AdapterGuid, &INetSocketAddress.SocketAddressStorage );
#endif // ! DPNBUILD_NOIPV6
					if ( ( INetSocketAddress.INetAddress.sin_family != AF_INET ) ||
						 ( reinterpret_cast<DWORD*>( &INetSocketAddress.INetAddress.sin_zero[ 0 ] )[ 0 ] != 0 ) ||
						 ( reinterpret_cast<DWORD*>( &INetSocketAddress.INetAddress.sin_zero[ 0 ] )[ 1 ] != 0 ) )
					{
#ifdef DPNBUILD_NOIPV6
						hr = DPNERR_ADDRESSING;
						DPFX(DPFPREP,  0, "Invalid device guid!" );
						goto Exit;
#else // ! DPNBUILD_NOIPV6
						//
						// Assume it is an IPv6 address.
						//
						SetFamilyProtocolAndSize(AF_INET6);
						AddressFromGuid( &AdapterGuid, &INetSocketAddress.SocketAddressStorage );
						
						m_SocketAddress.IPv6SocketAddress.sin6_addr = INetSocketAddress.INet6Address.sin6_addr;
						m_SocketAddress.IPv6SocketAddress.sin6_port = HTONS( static_cast<WORD>( dwPort ) );
						m_SocketAddress.IPv6SocketAddress.sin6_scope_id = INetSocketAddress.INet6Address.sin6_scope_id;
#endif // ! DPNBUILD_NOIPV6
					}
					else
#endif // ! DPNBUILD_ONLYONEADAPTER
					{
						m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = INetSocketAddress.INetAddress.sin_addr.S_un.S_addr;
						m_SocketAddress.IPSocketAddress.sin_port = HTONS( static_cast<WORD>( dwPort ) );
					}
					break;
				}

				//
				// hostname
				//
				case SP_ADDRESS_TYPE_HOST:
				{
					//
					// Ask for the port.  If none is found, choose a default.
					//
					dwTempSize = sizeof( dwPort );
					hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_PORT, &dwPort, &dwTempSize, &dwDataType );
					switch ( hTempResult )
					{
						//
						// port present, nothing to do
						//
						case DPN_OK:
						{
							DNASSERT( dwDataType == DPNA_DATATYPE_DWORD );
							break;
						}

						//
						// port not present, fill in the appropriate default
						//
						case DPNERR_DOESNOTEXIST:
						{
#ifdef DPNBUILD_SINGLEPROCESS
							dwPort = BASE_DPLAY8_PORT;
#else // ! DPNBUILD_SINGLEPROCESS
							dwPort = DPNA_DPNSVR_PORT;
#endif // ! DPNBUILD_SINGLEPROCESS
							DPFX(DPFPREP, 6, "Port component does not exist in address 0x%p, defaulting to %u.",
								pDP8Address, dwPort );
							break;
						}

						//
						// remap everything else to an addressing failure
						//
						default:
						{
							DPFX(DPFPREP, 0, "Couldn't get port component (0x%lx)!", hr );
							hr = DPNERR_ADDRESSING;
							goto Failure;
						}
					}

					m_SocketAddress.IPSocketAddress.sin_port = HTONS( static_cast<WORD>( dwPort ) );

					//
					// get the host name
					//
					dwTempSize = sizeof(abBuffer);
					hTempResult = IDirectPlay8Address_GetComponentByName( pDP8Address, DPNA_KEY_HOSTNAME, abBuffer, &dwTempSize, &dwDataType );
					switch ( hTempResult )
					{
						//
						// host name present, convert from string to valid binary value
						//
						case DPN_OK:
						{
							switch (dwDataType)
							{
								case DPNA_DATATYPE_STRING:
								{
									BYTE	abBuffer2[MAX_HOSTNAME_SIZE];


#ifdef DPNBUILD_XNETSECURITY
									//
									// The buffer should be large enough to hold an XNet address.
									//
									DBG_CASSERT(MAX_HOSTNAME_SIZE > ((sizeof(XNADDR) * 2) + 1) * sizeof(WCHAR));
#endif // DPNBUILD_XNETSECURITY

									//
									// Unicode string, convert it to ANSI.
									//
									dwTempSize /= sizeof(WCHAR);
									hr = STR_jkWideToAnsi( (char*) abBuffer2, (WCHAR*) abBuffer, dwTempSize );
									if ( hr != DPN_OK )
									{
										DPFX(DPFPREP, 0, "Failed to convert hostname to ANSI!" );
										DisplayDNError( 0, hr );
										goto Failure;
									}

									strncpy((char*) abBuffer, (char*) abBuffer2, dwTempSize);

									//
									// Fall through...
									//
								}

								case DPNA_DATATYPE_STRING_ANSI:
								{
#ifdef DPNBUILD_XNETSECURITY
									//
									// This may be an XNet address.  If we're allowed to check, and
									// the string is the right size, convert it.
									//
									if ((pullKeyID != NULL) &&
										(dwTempSize == ((sizeof(XNADDR) * 2) + 1))) // 2 characters for every byte + NULL termination
									{
										char *	pcCurrentSrc;
										XNADDR	xnaddr;
										BYTE *	pbCurrentDest;
										int		iError;


										//
										// Convert all the hex characters into digits.
										//
										pcCurrentSrc = (char*) abBuffer;
										memset(&xnaddr, 0, sizeof(xnaddr));
										for (pbCurrentDest = (BYTE*) &xnaddr; pbCurrentDest < (BYTE*) (&xnaddr + 1); pbCurrentDest++)
										{
											if (((*pcCurrentSrc) >= '0') && ((*pcCurrentSrc) <= '9'))
											{
												*pbCurrentDest = (*pcCurrentSrc) - '0';
											}
											else if (((*pcCurrentSrc) >= 'a') && ((*pcCurrentSrc) <= 'f'))
											{
												*pbCurrentDest = (*pcCurrentSrc) - 'a' + 10;
											}
											else if (((*pcCurrentSrc) >= 'A') && ((*pcCurrentSrc) <= 'F'))
											{
												*pbCurrentDest = (*pcCurrentSrc) - 'A' + 10;
											}
											else
											{
												//
												// If the current character is not a valid hex digit
												// this is not a valid secure transport address.
												//
												break;
											}
											pcCurrentSrc++;
											*pbCurrentDest <<= 4;

											if (((*pcCurrentSrc) >= '0') && ((*pcCurrentSrc) <= '9'))
											{
												*pbCurrentDest += (*pcCurrentSrc) - '0';
											}
											else if (((*pcCurrentSrc) >= 'a') && ((*pcCurrentSrc) <= 'f'))
											{
												*pbCurrentDest += (*pcCurrentSrc) - 'a' + 10;
											}
											else if (((*pcCurrentSrc) >= 'A') && ((*pcCurrentSrc) <= 'F'))
											{
												*pbCurrentDest += (*pcCurrentSrc) - 'A' + 10;
											}
											else
											{
												//
												// If the current character is not a valid hex digit
												// this is not a valid secure transport address.
												//
												break;
											}
											pcCurrentSrc++;
										}

										iError = XNetXnAddrToInAddr(&xnaddr,
																	(XNKID*) pullKeyID,
																	&m_SocketAddress.IPSocketAddress.sin_addr);
										if (iError == 0)
										{
											DNASSERT(hr == DPN_OK);
											goto Exit;
										}

										DPFX(DPFPREP, 1, "Couldn't convert XNet address \"%hs\" to InAddr (err = %i).",
											(char*) abBuffer, iError);
										DNASSERTX(! "Address exactly matching XNet address size and format failed to be converted!", 2);

										//
										// Continue on to trying to decode it as a
										// host name.
										//
									}
									else
									{
										//
										// XNet addresses should not be recognized,
										// or the string wasn't the right size.
										//
									}
#endif // ! DPNBUILD_XNETSECURITY

									//
									// If we're here, it wasn't an XNet address.
									//
									
#ifdef DPNBUILD_NOIPV6
									//
									// Try to convert as a raw IPv4 address first.
									//
									m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = inet_addr((char*) abBuffer);
									if ((m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == INADDR_NONE) &&
										(strcmp((char*) abBuffer, "255.255.255.255") != 0))
									{
#ifdef _XBOX
#pragma TODO(vanceo, "Use Xbox specific name lookup if available")
										DPFX(DPFPREP, 0, "Unable to resolve IP address \"%hs\"!",
											(char*) abBuffer);
										DNASSERTX(! "Unable to resolve IP address!", 2);
										hr = DPNERR_INVALIDHOSTADDRESS;
										goto Failure;
#else // ! _XBOX
										//
										// Converting raw IP failed, and it wasn't supposed to
										// be the broadcast address.  Convert as a host name if
										// we're allowed.
										//
#ifndef DPNBUILD_ONLYONETHREAD
										if (! fAllowNameResolution)
										{
											DPFX(DPFPREP, 2, "Couldn't convert \"%hs\" to IP address, not allowed to resolve as hostname.",
												(char*) abBuffer);
											hr = DPNERR_TIMEDOUT;
										}
										else
#endif // ! DPNBUILD_ONLYONETHREAD
										{
											PHOSTENT	phostent;

											
											phostent = gethostbyname((char*) abBuffer);
											if (phostent == NULL)
											{
												DPFX(DPFPREP, 0, "Couldn't get IP address from \"%hs\"!",
													(char*) abBuffer);
												DNASSERTX(! "Unable to resolve IP address!", 2);
												hr = DPNERR_INVALIDHOSTADDRESS;
												goto Failure;
											}

											//
											// Select the first IP address returned.
											//
											m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = ((IN_ADDR*) (phostent->h_addr_list[0]))->S_un.S_addr;
										}
#endif // ! _XBOX
									}
									else
									{
										DNASSERT(hr == DPN_OK);
									}
#else // ! DPNBUILD_NOIPV6
									char			szPort[32];
									addrinfo		addrinfoHints;
									addrinfo *	paddrinfoResult;
									addrinfo *	paddrinfoCurrent;
									int			iError;

									
									//
									// Try to convert the host name or raw address.
									//
									memset(&addrinfoHints, 0, sizeof(addrinfoHints));
									if (! fAllowNameResolution)
									{
										addrinfoHints.ai_flags |= AI_NUMERICHOST;
									}
									addrinfoHints.ai_family = g_iIPAddressFamily;	// IPv4, IPv6, or both
									addrinfoHints.ai_socktype = SOCK_DGRAM;
									addrinfoHints.ai_protocol  = IPPROTO_UDP;
									//addrinfoHints.ai_addrlen = 0;
									//addrinfoHints.ai_canonname  = NULL;
									//addrinfoHints.ai_addr = NULL;
									//addrinfoHints.ai_next = NULL;

									wsprintfA(szPort, "%u", dwPort);
									iError = getaddrinfo((char*) abBuffer, szPort, &addrinfoHints, &paddrinfoResult);
									if (iError == 0)
									{
										//
										// Pick the first valid address returned.
										//
#pragma BUGBUG(vanceo, "Should we implement some mechanism to try the other results?")
										paddrinfoCurrent = paddrinfoResult;
										while (paddrinfoCurrent != NULL)
										{
											DNASSERT(paddrinfoCurrent->ai_addr != NULL);
											if ((paddrinfoCurrent->ai_addr->sa_family == AF_INET) ||
												(paddrinfoCurrent->ai_addr->sa_family == AF_INET6))
											{
												DNASSERT(paddrinfoCurrent->ai_addrlen <= sizeof(m_SocketAddress));
												memcpy(&m_SocketAddress, paddrinfoCurrent->ai_addr, paddrinfoCurrent->ai_addrlen);
												m_iSocketAddressSize = paddrinfoCurrent->ai_addrlen;
												DNASSERT(GetPort() != 0);
												freeaddrinfo(paddrinfoResult);
												paddrinfoResult = NULL;
												DNASSERT(hr == DPN_OK);
												goto Exit;
											}

											DPFX(DPFPREP, 1, "Ignoring address family %u.",
												paddrinfoCurrent->ai_addr->sa_family);

											paddrinfoCurrent = paddrinfoCurrent->ai_next;
										}

										//
										// We didn't find any valid addresses.
										//
										DPFX(DPFPREP, 0, "Got address(es) from \"%hs\", but none were IP!",
											(char*) abBuffer);
										freeaddrinfo(paddrinfoResult);
										paddrinfoResult = NULL;
										hr = DPNERR_INVALIDHOSTADDRESS;
										goto Failure;
									}
									else
									{
#ifndef DPNBUILD_ONLYONETHREAD
										if (! fAllowNameResolution)
										{
											DPFX(DPFPREP, 2, "Couldn't convert \"%hs\" to IP address (err = %i), not allowed to resolve as hostname.",
												(char*) abBuffer, iError);
											hr = DPNERR_TIMEDOUT;
										}
										else
#endif // ! DPNBUILD_ONLYONETHREAD
										{
											DPFX(DPFPREP, 0, "Couldn't get IP address from \"%hs\" (err = %i)!",
												(char*) abBuffer, iError);
											DNASSERTX(! "Unable to resolve IP address!", 2);
											hr = DPNERR_INVALIDHOSTADDRESS;
											goto Failure;
										}
									}
#endif // ! DPNBUILD_NOIPV6
									break;
								}

								default:
								{
									DPFX(DPFPREP, 0, "Hostname component wasn't a string (%u)!", dwDataType );
									hr = DPNERR_ADDRESSING;
									goto Failure;
									break;
								}
							}
							break;
						}

						//
						// return DPNERR_INCOMPLETEADDRESS if the host name didn't exist
						//
						case DPNERR_DOESNOTEXIST:
						{
							DPFX(DPFPREP, 6, "Hostname component does not exist in address 0x%p.", pDP8Address );
							hr = DPNERR_INCOMPLETEADDRESS;
							goto Failure;
						}

						//
						// remap everything else to an addressing failure
						//
						default:
						{
							DPFX(DPFPREP, 0, "Couldn't get hostname component (0x%lx)!", hr );
							hr = DPNERR_ADDRESSING;
							goto Failure;
						}
					}
					
					break;
				}

				//
				// unknown address type
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}


Exit:

	DPFX(DPFPREP, 8, "(0x%p) Returning [0x%lx]", this, hr);

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CSocketAddress::DP8AddressFromSocketAddress - convert a socket address to a DP8Address
//
// Entry:		Address type
//
// Exit:		Pointer to DP8Address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::DP8AddressFromSocketAddress"

#ifdef DPNBUILD_XNETSECURITY
IDirectPlay8Address *CSocketAddress::DP8AddressFromSocketAddress( ULONGLONG * const pullKeyID,
															const XNADDR * const pxnaddr,
															const SP_ADDRESS_TYPE AddressType ) const
#else // ! DPNBUILD_XNETSECURITY
IDirectPlay8Address *CSocketAddress::DP8AddressFromSocketAddress( const SP_ADDRESS_TYPE AddressType ) const
#endif // ! DPNBUILD_XNETSECURITY
{
	HRESULT					hr;
	IDirectPlay8Address *	pDP8Address;
	DWORD					dwPort;


	//
	// initialize
	//
	hr = DPN_OK;
	pDP8Address = NULL;


	//
	// create and initialize the address
	//
#ifdef DPNBUILD_LIBINTERFACE
	hr = DP8ACF_CreateInstance( IID_IDirectPlay8Address,
								reinterpret_cast<void**>( &pDP8Address ) );
#else // ! DPNBUILD_LIBINTERFACE
	hr = COM_CoCreateInstance( CLSID_DirectPlay8Address,
							   NULL,
							   CLSCTX_INPROC_SERVER,
							   IID_IDirectPlay8Address,
							   reinterpret_cast<void**>( &pDP8Address ),
							   FALSE );
#endif // ! DPNBUILD_LIBINTERFACE
	if ( hr != S_OK )
	{
		DNASSERT( pDP8Address == NULL );
		DPFX(DPFPREP,  0, "Failed to create DP8Address when converting socket address" );
		return NULL;
	}


#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
#ifdef DPNBUILD_XNETSECURITY
			DNASSERT(pullKeyID == NULL);
#endif // DPNBUILD_XNETSECURITY

			//
			// set SP
			//
			hr = IDirectPlay8Address_SetSP( pDP8Address, &CLSID_DP8SP_IPX );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "Failed to set SP type!" );
				DisplayDNError( 0, hr );
				goto FailureIPX;
			}

			//
			// add on the port because it's always set
			//
			dwPort = NTOHS( m_SocketAddress.IPXSocketAddress.sa_socket );
			hr = IDirectPlay8Address_AddComponent( pDP8Address, DPNA_KEY_PORT, &dwPort, sizeof( dwPort ), DPNA_DATATYPE_DWORD );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "Failed to set port!" );
				DisplayDNError( 0, hr );
				goto FailureIPX;
			}

			//
			// add on the device or hostname depending on what type of address this is
			//
			switch ( AddressType )
			{
				case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
				case SP_ADDRESS_TYPE_DEVICE:
				{
					GUID		DeviceGuid;


					GuidFromInternalAddressWithoutPort( &DeviceGuid );
					hr = IDirectPlay8Address_AddComponent( pDP8Address,
														   DPNA_KEY_DEVICE,
														   &DeviceGuid,
														   sizeof( DeviceGuid ),
														   DPNA_DATATYPE_GUID );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Failed to add device!" );
						DisplayDNError( 0, hr );
						goto FailureIPX;
					}

					break;
				}

				//
				// host address type
				//
				case SP_ADDRESS_TYPE_READ_HOST:
				case SP_ADDRESS_TYPE_HOST:
				{
					char    HostName[ 255 ];
					WCHAR	WCharHostName[ sizeof( HostName ) ];
					DWORD   dwHostNameLength;
					DWORD	dwWCharHostNameLength;


					//
					// remove constness of parameter for broken Socket API
					//
					dwHostNameLength = LENGTHOF( HostName );
					if ( IPXAddressToStringNoSocket( const_cast<SOCKADDR*>( &m_SocketAddress.SocketAddress ),
													 sizeof( m_SocketAddress.IPXSocketAddress ),
													 HostName,
													 &dwHostNameLength
													 ) != 0 )
					{
						DPFERR("Error returned from IPXAddressToString");
						hr = DPNERR_ADDRESSING;
						goto ExitIPX;
					}

					//
					// convert ANSI host name to WCHAR
					//
					dwWCharHostNameLength = LENGTHOF( WCharHostName );
					hr = STR_AnsiToWide( HostName, -1, WCharHostName, &dwWCharHostNameLength );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Failed to convert hostname to WCHAR!" );
						DisplayDNError( 0, hr );
						goto FailureIPX;
					}

					hr = IDirectPlay8Address_AddComponent( pDP8Address,
														   DPNA_KEY_HOSTNAME,
														   WCharHostName,
														   dwWCharHostNameLength * sizeof( WCHAR ),
														   DPNA_DATATYPE_STRING );
					if ( hr != DPN_OK )
					{
						DPFX(DPFPREP,  0, "Failed to add hostname!" );
						DisplayDNError( 0, hr );
						goto FailureIPX;
					}

					break;
				}

				//
				// unknown address type
				//
				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

		ExitIPX:
			return	pDP8Address;

		FailureIPX:
			if ( pDP8Address != NULL )
			{
				IDirectPlay8Address_Release( pDP8Address );
				pDP8Address = NULL;
			}

			goto ExitIPX;
			break;
		}
#endif // !DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
#endif // ! DPNBUILD_NOIPV6
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
#ifndef DPNBUILD_ONLYONESP
			//
			// set SP
			//
			hr = IDirectPlay8Address_SetSP( pDP8Address, &CLSID_DP8SP_TCPIP );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP,  0, "Failed to set SP GUID!" );
				DisplayDNError( 0, hr );
				goto FailureIP;
			}
#endif // ! DPNBUILD_ONLYONESP

			switch ( AddressType )
			{
				case SP_ADDRESS_TYPE_DEVICE_USE_ANY_PORT:
				case SP_ADDRESS_TYPE_DEVICE:
				{
#ifndef DPNBUILD_ONLYONEADAPTER
					GUID		DeviceGuid;


					GuidFromInternalAddressWithoutPort( &DeviceGuid );
					hr = IDirectPlay8Address_SetDevice( pDP8Address, &DeviceGuid );
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't add device GUID!");
						goto FailureIP;
					}
#endif // ! DPNBUILD_ONLYONEADAPTER
					break;
				}

				case SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS:
				case SP_ADDRESS_TYPE_READ_HOST:
				case SP_ADDRESS_TYPE_HOST:
#ifndef DPNBUILD_NOMULTICAST
				case SP_ADDRESS_TYPE_MULTICAST_GROUP:
#endif // ! DPNBUILD_NOMULTICAST
				{
					TCHAR		tszHostname[MAX_HOSTNAME_SIZE / sizeof(TCHAR)];
#ifdef DPNBUILD_XNETSECURITY
					TCHAR *		ptszCurrent;
					BYTE *		pbCurrent;
					DWORD		dwTemp;

					//
					// The buffer should be large enough to hold an XNet address.
					//
					DBG_CASSERT(MAX_HOSTNAME_SIZE > ((sizeof(XNADDR) * 2) + 1) * sizeof(WCHAR));
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_NOIPV6
					if (GetFamily() == AF_INET6)
					{
						DBG_CASSERT((sizeof(tszHostname) / sizeof(TCHAR)) >= INET6_ADDRSTRLEN);
#ifdef UNICODE
						DNIpv6AddressToStringW(&m_SocketAddress.IPv6SocketAddress.sin6_addr, tszHostname);
#else // ! UNICODE
Won't compile because we haven't implemented DNIpv6AddressToStringA
#endif // ! UNICODE
					}
					else
#endif // ! DPNBUILD_NOIPV6
					{
#ifdef DPNBUILD_XNETSECURITY
						if (pxnaddr != NULL)
						{
							ptszCurrent = tszHostname;
							pbCurrent = (BYTE*) pxnaddr;
							for(dwTemp = 0; dwTemp < sizeof(XNADDR); dwTemp++)
							{
								ptszCurrent += wsprintf(ptszCurrent, _T("%02X"), (*pbCurrent));
								pbCurrent++;
							}
						}
						else if ((pullKeyID != NULL) &&
								(m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr != INADDR_BROADCAST))
						{
							int		iError;
							XNADDR	xnaddr;
#ifdef DBG
							XNKID	xnkid;
#endif // DBG


							DBG_CASSERT(sizeof(xnkid) == sizeof(*pullKeyID));
#ifdef DPNBUILD_ONLYONEADAPTER
							IN_ADDR		inaddrToUse;

							//
							// Special case 0.0.0.0, the XNet library expects the loopback address
							// instead when retrieving the local address.
							//
							inaddrToUse = m_SocketAddress.IPSocketAddress.sin_addr;
							if (inaddrToUse.S_un.S_addr == 0)
							{
								inaddrToUse.S_un.S_addr = IP_LOOPBACK_ADDRESS;
							}
							iError = XNetInAddrToXnAddr(inaddrToUse,
#else // ! DPNBUILD_ONLYONEADAPTER
							iError = XNetInAddrToXnAddr(m_SocketAddress.IPSocketAddress.sin_addr,
#endif // ! DPNBUILD_ONLYONEADAPTER
														&xnaddr,
#ifdef DBG
														&xnkid);
#else // ! DBG
														NULL);
#endif // ! DBG

							if (iError != 0)
							{
								DPFX(DPFPREP, 0, "Converting XNet address to InAddr failed (err = %i)!",
									iError);
								DNASSERT(FALSE);
								//hr = DPNERR_NOCONNECTION;
								goto FailureIP;
							}

#ifdef DPNBUILD_ONLYONEADAPTER
							if (inaddrToUse.S_un.S_addr != IP_LOOPBACK_ADDRESS)
#endif // DPNBUILD_ONLYONEADAPTER
							{
#ifdef DBG
								DNASSERT(memcmp(&xnkid, pullKeyID, sizeof(xnkid)) == 0);
#endif // DBG
							}

							ptszCurrent = tszHostname;
							pbCurrent = (BYTE*) (&xnaddr);
							for(dwTemp = 0; dwTemp < sizeof(XNADDR); dwTemp++)
							{
								ptszCurrent += wsprintf(tszHostname, _T("%02X"), (*pbCurrent));
								pbCurrent++;
							}
						}
						else
#endif // DPNBUILD_XNETSECURITY
						{
							wsprintf(tszHostname, _T("%u.%u.%u.%u"),
									m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b1,
									m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b2,
									m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b3,
									m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b4);
						}
					}

#ifdef UNICODE
					hr = IDirectPlay8Address_AddComponent( pDP8Address,
															DPNA_KEY_HOSTNAME,
															tszHostname,
															(_tcslen(tszHostname) + 1) * sizeof (TCHAR),
															DPNA_DATATYPE_STRING );
#else // ! UNICODE
					hr = IDirectPlay8Address_AddComponent( pDP8Address,
															DPNA_KEY_HOSTNAME,
															tszHostname,
															(_tcslen(tszHostname) + 1) * sizeof (TCHAR),
															DPNA_DATATYPE_STRING_ANSI );
#endif // ! UNICODE
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't add hostname component!");
						goto FailureIP;
					}
					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}
			
			dwPort = NTOHS( m_SocketAddress.IPSocketAddress.sin_port );

			hr = IDirectPlay8Address_AddComponent( pDP8Address,
													DPNA_KEY_PORT,
													&dwPort,
													(sizeof(dwPort)),
													DPNA_DATATYPE_DWORD );
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't add port component!");
				goto FailureIP;
			}

		ExitIP:

			return	pDP8Address;

		FailureIP:

			if ( pDP8Address != NULL )
			{
				IDirectPlay8Address_Release( pDP8Address );
				pDP8Address = NULL;
			}

			goto ExitIP;
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketAddress::CompareToBaseAddress - compare this address to a 'base' address
//		of this class
//
// Entry:		Pointer to base address
//
// Exit:		Integer indicating relative magnitude:
//				0 = items equal
//				-1 = other item is of greater magnitude
//				1 = this item is of lesser magnitude
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::CompareToBaseAddress"

INT_PTR	CSocketAddress::CompareToBaseAddress( const SOCKADDR *const pBaseAddress ) const
{
	DNASSERT( pBaseAddress != NULL );

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			const SOCKADDR_IN6	*pBaseIPv6Address;


			if ( pBaseAddress->sa_family != m_SocketAddress.SocketAddress.sa_family )
			{
				DNASSERT(pBaseAddress->sa_family == AF_INET);
				return -1;
			}
			
			pBaseIPv6Address = reinterpret_cast<const SOCKADDR_IN6*>( pBaseAddress );
			return (memcmp(&m_SocketAddress.IPv6SocketAddress.sin6_addr,
							&pBaseIPv6Address->sin6_addr,
							sizeof(m_SocketAddress.IPv6SocketAddress.sin6_addr)));
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			const SOCKADDR_IPX	*pBaseIPXAddress;
			

			DNASSERT( pBaseAddress->sa_family == m_SocketAddress.SocketAddress.sa_family );
			pBaseIPXAddress = reinterpret_cast<const SOCKADDR_IPX *>( pBaseAddress );
			DBG_CASSERT( OFFSETOF( SOCKADDR_IPX, sa_nodenum ) == OFFSETOF( SOCKADDR_IPX, sa_netnum ) + sizeof( pBaseIPXAddress->sa_netnum ) );
			return	memcmp( &m_SocketAddress.IPXSocketAddress.sa_nodenum,
							&pBaseIPXAddress->sa_nodenum,
							sizeof( pBaseIPXAddress->sa_nodenum ) );
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			const SOCKADDR_IN	*pBaseIPAddress;

			DNASSERT( GetFamily() == AF_INET );
			
#ifndef DPNBUILD_NOIPV6
			if ( pBaseAddress->sa_family != m_SocketAddress.SocketAddress.sa_family )
			{
				DNASSERT(pBaseAddress->sa_family == AF_INET6);
				return -1;
			}
#endif // ! DPNBUILD_NOIPV6
			
			pBaseIPAddress = reinterpret_cast<const SOCKADDR_IN*>( pBaseAddress );
			if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == pBaseIPAddress->sin_addr.S_un.S_addr )
			{
				return 0;
			}
			else
			{
				if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr < pBaseIPAddress->sin_addr.S_un.S_addr )
				{
					return	1;
				}
				else
				{
					return	-1;
				}
			}
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************



#ifndef DPNBUILD_ONLYONEADAPTER

//**********************************************************************
// ------------------------------
// CSocketAddress::EnumAdapters - enumerate all of the adapters for this machine
//
// Entry:		Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::EnumAdapters"

HRESULT	CSocketAddress::EnumAdapters( SPENUMADAPTERSDATA *const pEnumData ) const
{
#ifndef DPNBUILD_NOIPX
	if (GetFamily() == AF_IPX)
	{
		return EnumIPXAdapters(pEnumData);
	}
	else
#endif // ! DPNBUILD_NOIPX
	{
#ifdef DPNBUILD_NOIPV6
		return EnumIPv4Adapters(pEnumData);
#else // ! DPNBUILD_NOIPV6
		return EnumIPv6and4Adapters(pEnumData);
#endif // ! DPNBUILD_NOIPV6
	}
}
//**********************************************************************



#ifndef DPNBUILD_NOIPX

//**********************************************************************
// ------------------------------
// CSocketAddress::EnumIPXAdapters - enumerate all of the adapters for this machine
//
// Entry:		Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::EnumIPXAdapters"

HRESULT	CSocketAddress::EnumIPXAdapters( SPENUMADAPTERSDATA *const pEnumData ) const
{
	HRESULT				hr;
	CPackedBuffer		PackedBuffer;
	SOCKET				TestSocket;
	INT					iWSAReturn;
	DWORD				dwAddressCount;
	union
	{
		SOCKADDR_IPX	IPXSocketAddress;
		SOCKADDR		SocketAddress;
	} SockAddr;


	//
	// initialize
	//
	hr = DPN_OK;

			
	DNASSERT( pEnumData != NULL );

	//
	// initialize
	//
	DEBUG_ONLY( memset( pEnumData->pAdapterData, 0xAA, pEnumData->dwAdapterDataSize ) );
	PackedBuffer.Initialize( pEnumData->pAdapterData, pEnumData->dwAdapterDataSize );
	pEnumData->dwAdapterCount = 0;
	TestSocket = INVALID_SOCKET;
	dwAddressCount = 0;

	//
	// create a socket and attempt to query for all of the IPX addresses.  If
	// that fails, fall back to using just the address from 'getsockname'.
	//
	TestSocket = socket( GetFamily(), SOCK_DGRAM, NSPROTO_IPX );
	if ( TestSocket == INVALID_SOCKET )
	{
		DWORD	dwWSAError;


		hr = DPNERR_UNSUPPORTED;
		dwWSAError = WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to create IPX socket when enumerating adapters!" );
		DisplayWinsockError( 0, dwWSAError );
		goto Failure;
	}

	memset( &SockAddr, 0x00, sizeof( SockAddr ) );
	SockAddr.IPXSocketAddress.sa_family = GetFamily();
	
	iWSAReturn = bind( TestSocket, &SockAddr.SocketAddress, sizeof( SockAddr.IPXSocketAddress ) );
	if ( iWSAReturn == SOCKET_ERROR )
	{
		DWORD	dwWSAError;


		hr = DPNERR_OUTOFMEMORY;
		dwWSAError = WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to bind IPX socket when enumerating adapters!" );
		DisplayWinsockError( 0, dwWSAError );
		goto Failure;
	}

//
// NOTE: THE CODE TO EXTRACT ALL IPX ADDRESSES ON NT HAS BEEN DISABLED BECAUSE
// NT TREATS ALL OF THEM AS THE SAME ONCE THEY ARE BOUND TO THE NETWORK.  IF THE
// CORE IS ATTEMPTING TO BIND TO ALL ADAPTERS THIS WILL CAUSE ALL OF THE BINDS
// AFTER THE FIRST TO FAIL!
//

//	iIPXAdapterCount = 0;
//	iIPXAdapterCountSize = sizeof( iIPXAdapterCount );
//	iWSAReturn = getsockopt( TestSocket,
//			    			   NSPROTO_IPX,
//			    			   IPX_MAX_ADAPTER_NUM,
//			    			   reinterpret_cast<char*>( &iIPXAdapterCount ),
//			    			   &iIPXAdapterCountSize );
//	if ( iWSAReturn != 0 )
//	{
//		DWORD   dwWSAError;
//
//
//		dwWSAError = WSAGetLastError();
//		switch ( dwWSAError )
//		{
//			//
//			// can't enumerate adapters on this machine, fallback to getsockname()
//			//
//			case WSAENOPROTOOPT:
//			{
				INT		iReturn;
				INT		iSocketNameSize;
				union
				{
					SOCKADDR		SocketAddress;
					SOCKADDR_IPX	SocketAddressIPX;
				} SocketAddress;


				memset( &SocketAddress, 0x00, sizeof( SocketAddress ) );
				iSocketNameSize = sizeof( SocketAddress );
				iReturn = getsockname( TestSocket, &SocketAddress.SocketAddress, &iSocketNameSize );
				if ( iReturn != 0 )
				{
					DWORD	dwWSAError;


					hr = DPNERR_OUTOFMEMORY;
					dwWSAError = WSAGetLastError();
					DPFX(DPFPREP, 0, "Failed to get socket name enumerating IPX sockets!", dwWSAError );
					goto Failure;
				}
				else
				{
					GUID	SocketAddressGUID;


					SocketAddress.SocketAddressIPX.sa_socket = 0;
					GuidFromAddress( &SocketAddressGUID, &SocketAddress.SocketAddress );
					
					DPFX(DPFPREP, 7, "Returning adapter 0: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, flags = 0x0.",
						g_IPXAdapterString,
						SocketAddressGUID.Data1,
						SocketAddressGUID.Data2,
						SocketAddressGUID.Data3,
						SocketAddressGUID.Data4[0],
						SocketAddressGUID.Data4[1],
						SocketAddressGUID.Data4[2],
						SocketAddressGUID.Data4[3],
						SocketAddressGUID.Data4[4],
						SocketAddressGUID.Data4[5],
						SocketAddressGUID.Data4[6],
						SocketAddressGUID.Data4[7]);
		
					hr = AddInfoToBuffer( &PackedBuffer, g_IPXAdapterString, &SocketAddressGUID, 0 );
					if ( ( hr != DPN_OK ) && ( hr != DPNERR_BUFFERTOOSMALL ) )
					{
						DPFX(DPFPREP, 0, "Failed to add adapter (getsockname)!" );
						DisplayDNError( 0, hr );
						goto Failure;
					}

					dwAddressCount++;
				}
				
//	    		break;
//	    	}
//
//	    	//
//	    	// other Winsock error
//	    	//
//	    	default:
//	    	{
//	    		DWORD	dwWSAError;
//
//
//	    		hr = DPNERR_OUTOFMEMORY;
//	    		dwWSAError = WSAGetLastError();
//	    		DPFX(DPFPREP,  0, "Failed to get IPX adapter count!" );
//	    		DisplayWinsockError( 0, dwWSAError );
//	    		goto Failure;
//
//	    		break;
//	    	}
//	    }
//	}
//	else
//	{
//	    while ( iIPXAdapterCount != 0 )
//	    {
//	    	IPX_ADDRESS_DATA	IPXData;
//	    	int					iIPXDataSize;
//
//
//	    	iIPXAdapterCount--;
//	    	memset( &IPXData, 0x00, sizeof( IPXData ) );
//	    	iIPXDataSize = sizeof( IPXData );
//	    	IPXData.adapternum = iIPXAdapterCount;
//
//	    	iWSAReturn = p_getsockopt( TestSocket,
//	    							   NSPROTO_IPX,
//	    							   IPX_ADDRESS,
//	    							   reinterpret_cast<char*>( &IPXData ),
//	    							   &iIPXDataSize );
//	    	if ( iWSAReturn != 0 )
//	    	{
//	    		DPFX(DPFPREP,  0, "Failed to get adapter information for adapter: 0x%x", ( iIPXAdapterCount + 1 ) );
//	    	}
//	    	else
//	    	{
//	    		char	Buffer[ 500 ];
//	    		GUID	SocketAddressGUID;
//	    		union
//	    		{
//	    			SOCKADDR_IPX	IPXSocketAddress;
//	    			SOCKADDR		SocketAddress;
//	    		} SocketAddress;
//
//
//	    		wsprintf( Buffer,
//	    				  "IPX Adapter %d - (%02X%02X%02X%02X-%02X%02X%02X%02X%02X%02X)",
//	    				  ( iIPXAdapterCount + 1 ),
//	    				  IPXData.netnum[ 0 ],
//	    				  IPXData.netnum[ 1 ],
//	    				  IPXData.netnum[ 2 ],
//	    				  IPXData.netnum[ 3 ],
//	    				  IPXData.nodenum[ 0 ],
//	    				  IPXData.nodenum[ 1 ],
//	    				  IPXData.nodenum[ 2 ],
//	    				  IPXData.nodenum[ 3 ],
//	    				  IPXData.nodenum[ 4 ],
//	    				  IPXData.nodenum[ 5 ] );
//
//	    		memset( &SocketAddress, 0x00, sizeof( SocketAddress ) );
//	    		SocketAddress.IPXSocketAddress.sa_family = GetFamily();
//	    		DBG_CASSERT( sizeof( SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( IPXData.netnum ) );
//	    		memcpy( &SocketAddress.IPXSocketAddress.sa_netnum, IPXData.netnum, sizeof( SocketAddress.IPXSocketAddress.sa_netnum ) );
//	    		DBG_CASSERT( sizeof( SocketAddress.IPXSocketAddress.sa_nodenum ) == sizeof( IPXData.nodenum ) );
//	    		memcpy( &SocketAddress.IPXSocketAddress.sa_nodenum, IPXData.nodenum, sizeof( SocketAddress.IPXSocketAddress.sa_nodenum ) );
//	    		GuidFromAddress( SocketAddressGUID, SocketAddress.SocketAddress );
//
//	    		hr = AddInfoToBuffer( &PackedBuffer, Buffer, &SocketAddressGUID, 0 );
//	    		if ( ( hr != DPN_OK ) && ( hr != DPNERR_BUFFERTOOSMALL ) )
//	    		{
//	    			DPFX(DPFPREP,  0, "Failed to add adapter (getsockname)!" );
//	    			DisplayDNError( 0, hr );
//	    			goto Failure;
//	    		}
//
//	    		dwAddressCount++;
//	    	}
//	    }
//	}

//	//
//	// if there was one adapter added, we can return 'All Adapters'
//	//
//	if ( dwAddressCount != 0 )
//	{
//	    dwAddressCount++;
//	    hr = AddInfoToBuffer( &PackedBuffer, g_AllAdaptersString, &ALL_ADAPTERS_GUID, 0 );
//	    if ( ( hr != DPN_OK ) && ( hr != DPNERR_BUFFERTOOSMALL ) )
//	    {
//	    	DPFX(DPFPREP,  0, "Failed to add 'All Adapters'" );
//	    	DisplayDNError( 0, hr );
//	    	goto Failure;
//	    }
//	}

	pEnumData->dwAdapterCount = dwAddressCount;
	pEnumData->dwAdapterDataSize = PackedBuffer.GetSizeRequired();

Exit:
	if ( TestSocket != INVALID_SOCKET )
	{
		closesocket( TestSocket );
		TestSocket = INVALID_SOCKET;
	}

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************

#endif // ! DPNBUILD_NOIPX


//**********************************************************************
// ------------------------------
// CSocketAddress::EnumIPv4Adapters - enumerate all of the IPv4 adapters for this machine
//
// Entry:		Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::EnumIPv4Adapters"

HRESULT	CSocketAddress::EnumIPv4Adapters( SPENUMADAPTERSDATA *const pEnumData ) const
{
	HRESULT				hr = DPN_OK;
#if !defined(DPNBUILD_NOWINSOCK2) || defined(DBG)
	DWORD				dwError;
#endif //  !DPNBUILD_NOWINSOCK2 OR DBG
	SOCKADDR_IN		saddrinTemp;
	const HOSTENT *		pHostData;
	IN_ADDR **			ppinaddrTemp;
	DWORD				dwAddressCount;
	BOOL				fFoundPrivateICS = FALSE;
	IN_ADDR *			pinaddrBuffer = NULL;
	DWORD				dwIndex;
	ULONG				ulAdapterInfoBufferSize = 0;
	GUID				guidAdapter;
	DWORD				dwDeviceFlags;
	CPackedBuffer		PackedBuffer;
	char					acBuffer[512];
	WCHAR				wszIPAddress[512];
#ifndef DPNBUILD_NOWINSOCK2
	HMODULE			hIpHlpApiDLL;
	IP_ADAPTER_INFO *	pCurrentAdapterInfo;
	PIP_ADDR_STRING	pIPAddrString;
	PFNGETADAPTERSINFO	pfnGetAdaptersInfo;
	IP_ADAPTER_INFO *	pAdapterInfoBuffer = NULL;
	const char *			pszIPAddress;
#ifndef DPNBUILD_NOMULTICAST
	DWORD				dwMcastInterfaceIndex;
#endif // ! DPNBUILD_NOMULTICAST
#endif // ! DPNBUILD_NOWINSOCK2


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pEnumData);


	PackedBuffer.Initialize( pEnumData->pAdapterData, pEnumData->dwAdapterDataSize );

	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family	= GetFamily();


	//
	// Get the list of local IPs from WinSock.  We use this method since it's
	// available on all platforms and conveniently returns the loopback address
	// when no valid adapters are currently available.
	//
	
	if (gethostname(acBuffer, sizeof(acBuffer)) == SOCKET_ERROR)
	{
#ifdef DBG
		dwError = WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to get host name into fixed size buffer (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	pHostData = gethostbyname(acBuffer);
	if (pHostData == NULL)
	{
#ifdef DBG
		dwError = WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to get host data (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}


	//
	// Count number of addresses.
	//
	dwAddressCount = 0;
	ppinaddrTemp = (IN_ADDR**) (pHostData->h_addr_list);
	while ((*ppinaddrTemp) != NULL)
	{
		//
		// Remember if it's 192.168.0.1.  See below
		//
		if ((*ppinaddrTemp)->S_un.S_addr == IP_PRIVATEICS_ADDRESS)
		{
			fFoundPrivateICS = TRUE;
		}

		dwAddressCount++;
		ppinaddrTemp++;
	}

	if (dwAddressCount == 0)
	{
		DPFX(DPFPREP, 1, "No IP addresses, forcing loopback address.");
		DNASSERTX(!" No IP addresses!", 2);
		dwAddressCount++;
	}
	else
	{
		DPFX(DPFPREP, 3, "WinSock reported %u addresses.", dwAddressCount);
	}


	//
	// Winsock says we should copy this data before any other Winsock calls.
	//
	// We also use this as an opportunity to ensure that the order returned to the caller is
	// to our liking.  In particular, we make sure the private address 192.168.0.1 appears
	// first.
	//
	DNASSERT(pHostData->h_length == sizeof(IN_ADDR));
	pinaddrBuffer = (IN_ADDR*) DNMalloc(dwAddressCount * sizeof(IN_ADDR));
	if (pinaddrBuffer == NULL)
	{
		DPFX(DPFPREP,  0, "Failed to allocate memory to store copy of addresses!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	dwIndex = 0;

	//
	// First, store 192.168.0.1 if we found it.
	//
	if (fFoundPrivateICS)
	{
		pinaddrBuffer[dwIndex].S_un.S_addr = IP_PRIVATEICS_ADDRESS;
		dwIndex++;
	}

	//
	// Then copy the rest.
	//
	ppinaddrTemp = (IN_ADDR**) (pHostData->h_addr_list);
	while ((*ppinaddrTemp) != NULL)
	{
		if ((*ppinaddrTemp)->S_un.S_addr != IP_PRIVATEICS_ADDRESS)
		{
			pinaddrBuffer[dwIndex].S_un.S_addr = (*ppinaddrTemp)->S_un.S_addr;
			dwIndex++;
		}

		ppinaddrTemp++;
	}

	//
	// If we didn't have any addresses, slap in the loopback address.
	//
	if (dwIndex == 0)
	{
		pinaddrBuffer[0].S_un.S_addr = IP_LOOPBACK_ADDRESS;
		dwIndex++;
	}


	DNASSERT(dwIndex == dwAddressCount);
	

	//
	// Now we try to generate names and GUIDs for these IP addresses.
	// We'll use what IPHLPAPI reports for a name if possible, and fall
	// back to just using the IP address string as the name.
	//

#ifndef DPNBUILD_NOWINSOCK2
	//
	// Load the IPHLPAPI module and get the adapter list if possible.
	//
	hIpHlpApiDLL = LoadLibrary(c_tszIPHelperDLLName);
	if (hIpHlpApiDLL != NULL)
	{
#ifndef DPNBUILD_NOMULTICAST
		PFNGETBESTINTERFACE		pfnGetBestInterface;


		pfnGetBestInterface = (PFNGETBESTINTERFACE) GetProcAddress(hIpHlpApiDLL, _TWINCE("GetBestInterface"));
		if (pfnGetBestInterface != NULL)
		{
			//
			// Ask IPHLPAPI for its opinion on the best multicast interface.
			// We use an arbitrary multicast address, and assume that the
			// TCP/IP stack doesn't treat individual multicast addresses
			// differently.
			//
			dwError = pfnGetBestInterface(SAMPLE_MULTICAST_ADDRESS, &dwMcastInterfaceIndex);
			if (dwError != ERROR_SUCCESS)
			{
				DPFX(DPFPREP, 0, "Couldn't determine best multicast interface index (err = %u)!  Continuing.",
					dwError);
				dwMcastInterfaceIndex = INVALID_INTERFACE_INDEX;
			}
			else
			{
				DPFX(DPFPREP, 7, "Best interface for multicasting is index 0x%x.",
					dwMcastInterfaceIndex);
			}
		}
		else
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load \"GetBestInterface\" function (err = %u)!  Continuing.",
				dwError);
		}
#endif // ! DPNBUILD_NOMULTICAST

		pfnGetAdaptersInfo = (PFNGETADAPTERSINFO) GetProcAddress(hIpHlpApiDLL, _TWINCE("GetAdaptersInfo"));
		if (pfnGetAdaptersInfo != NULL)
		{
			//
			// Keep resizing the buffer until there's enough room.
			//
			do
			{
				dwError = pfnGetAdaptersInfo(pAdapterInfoBuffer,
											&ulAdapterInfoBufferSize);
				if (dwError == ERROR_SUCCESS)
				{
					//
					// We got all the info we're going to get.  Make sure it
					// was something.
					//
					if (ulAdapterInfoBufferSize == 0)
					{
						DPFX(DPFPREP, 0, "GetAdaptersInfo returned 0 byte size requirement!  Ignoring.");

						//
						// Get rid of the buffer if allocated.
						//
						if (pAdapterInfoBuffer != NULL)
						{
							DNFree(pAdapterInfoBuffer);
							pAdapterInfoBuffer = NULL;
						}

						//
						// Continue with exiting the loop.
						//
					}
#ifdef DBG
					else
					{
						int		iStrLen;
						char	szIPList[256];
						char *	pszCurrentIP;


						//
						// Print out all the adapters for debugging purposes.
						//
						pCurrentAdapterInfo = pAdapterInfoBuffer;
						while (pCurrentAdapterInfo != NULL)
						{
							//
							// Initialize IP address list string.
							//
							szIPList[0] = '\0';
							pszCurrentIP = szIPList;


							//
							// Loop through all addresses for this adapter.
							//
							pIPAddrString = &pCurrentAdapterInfo->IpAddressList;
							while (pIPAddrString != NULL)
							{
								//
								// Copy the IP address string (if there's enough room),
								// then tack on a space and NULL terminator.
								//
								iStrLen = strlen(pIPAddrString->IpAddress.String);
								if ((pszCurrentIP + iStrLen + 2) < (szIPList + sizeof(szIPList)))
								{
									memcpy(pszCurrentIP, pIPAddrString->IpAddress.String, iStrLen);
									pszCurrentIP += iStrLen;
									(*pszCurrentIP) = ' ';
									pszCurrentIP++;
									(*pszCurrentIP) = '\0';
									pszCurrentIP++;
								}

								pIPAddrString = pIPAddrString->Next;
							}


							DPFX(DPFPREP, 8, "Adapter index %u IPs = %hs, %hs, \"%hs\".",
								pCurrentAdapterInfo->Index,
								szIPList,
								pCurrentAdapterInfo->AdapterName,
								pCurrentAdapterInfo->Description);


							//
							// Go to next adapter.
							//
							pCurrentAdapterInfo = pCurrentAdapterInfo->Next;
						}
					} // end else (got valid buffer size)
#endif // DBG

					break;
				}

				if ((dwError != ERROR_BUFFER_OVERFLOW) &&
					(dwError != ERROR_INSUFFICIENT_BUFFER))
				{
					DPFX(DPFPREP, 0, "GetAdaptersInfo failed (err = 0x%lx)!  Ignoring.", dwError);

					//
					// Get rid of the buffer if allocated, and then bail out of
					// the loop.
					//
					if (pAdapterInfoBuffer != NULL)
					{
						DNFree(pAdapterInfoBuffer);
						pAdapterInfoBuffer = NULL;
					}

					break;
				}


				//
				// If we're here, then we need to reallocate the buffer.
				//
				if (pAdapterInfoBuffer != NULL)
				{
					DNFree(pAdapterInfoBuffer);
					pAdapterInfoBuffer = NULL;
				}

				pAdapterInfoBuffer = (IP_ADAPTER_INFO*) DNMalloc(ulAdapterInfoBufferSize);
				if (pAdapterInfoBuffer == NULL)
				{
					//
					// Couldn't allocate memory.  Bail out of the loop.
					//
					break;
				}

				//
				// Successfully allocated buffer.  Try again.
				//
			}
			while (TRUE);


			//
			// We get here in all cases, so we may have failed to get an info
			// buffer.  That's fine, we'll use the fallback to generate the
			// names.
			//
		}
		else
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Failed to get proc address for GetAdaptersInfo!");
			DisplayErrorCode(0, dwError);
#endif // DBG

			//
			// Continue.  We'll use the fallback to generate the names.
			//
		}


		//
		// We don't need the library anymore.
		//
		FreeLibrary(hIpHlpApiDLL);
		hIpHlpApiDLL = NULL;
	}
	else
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to get proc address for GetAdaptersInfo!");
		DisplayErrorCode(0, dwError);
#endif // DBG

		//
		// Continue.  We'll use the fallback to generate the names.
		//
	}
#endif // !DPNBUILD_NOWINSOCK2

	//
	// Loop through all IP addresses, generating names and GUIDs.
	//
	for(dwIndex = 0; dwIndex < dwAddressCount; dwIndex++)
	{
		//
		// Start off assuming this IP address won't have any special
		// flags.
		//
		dwDeviceFlags = 0;

#ifndef DPNBUILD_NOMULTICAST
		//
		// If this is the first device and we couldn't use IPHLPAPI to
		// determine the best multicast interface, then just say the
		// default multicast interface is the first (for lack of a
		// better idea).
		//
#ifdef DPNBUILD_NOWINSOCK2
		if (dwIndex == 0)
#else // ! DPNBUILD_NOWINSOCK2
		if ((dwIndex == 0) && (dwMcastInterfaceIndex == INVALID_INTERFACE_INDEX))
#endif // ! DPNBUILD_NOWINSOCK2
		{
			dwDeviceFlags |= DPNSPINFO_DEFAULTMULTICASTDEVICE;
		}
#endif // ! DPNBUILD_NOMULTICAST


#ifdef DPNBUILD_NOWINSOCK2
		DNinet_ntow(pinaddrBuffer[dwIndex], wszIPAddress);
#else // ! DPNBUILD_NOWINSOCK2
		//
		// Get the IP address string.  We don't make any other WinSock
		// calls, so holding on to the pointer is OK.  This pointer
		// may be used as the device name string, too.
		//
		pszIPAddress = inet_ntoa(pinaddrBuffer[dwIndex]);

		//
		// Look for an adapter name from IPHLPAPI if possible.
		//
		if (pAdapterInfoBuffer != NULL)
		{
			pCurrentAdapterInfo = pAdapterInfoBuffer;
			while (pCurrentAdapterInfo != NULL)
			{
				//
				// Look for matching IP.
				//
				pIPAddrString = &pCurrentAdapterInfo->IpAddressList;
				while (pIPAddrString != NULL)
				{
					if (strcmp(pIPAddrString->IpAddress.String, pszIPAddress) == 0)
					{
#ifndef DPNBUILD_NOMULTICAST
						//
						// If it's the interface reported earlier as the best
						// multicast interface, remember that fact.
						//
						if (pCurrentAdapterInfo->Index == dwMcastInterfaceIndex)
						{
							DPFX(DPFPREP, 7, "Found %hs under adapter index %u (\"%hs\"), and it's the best multicast interface.",
								pszIPAddress, pCurrentAdapterInfo->Index,
								pCurrentAdapterInfo->Description);
							DNASSERT(pCurrentAdapterInfo->Index != INVALID_INTERFACE_INDEX); 

							dwDeviceFlags |= DPNSPINFO_DEFAULTMULTICASTDEVICE;
						}
						else
#endif // ! DPNBUILD_NOMULTICAST
						{
							DPFX(DPFPREP, 9, "Found %hs under adapter index %u (\"%hs\").",
								pszIPAddress, pCurrentAdapterInfo->Index,
								pCurrentAdapterInfo->Description);
						}


						//
						// Build the name string.
						//
						DBG_CASSERT(sizeof(acBuffer) > MAX_ADAPTER_DESCRIPTION_LENGTH); 
						wsprintfA(acBuffer,
								  c_szAdapterNameTemplate,
								  pCurrentAdapterInfo->Description,
								  pszIPAddress);

						//
						// Point the name string to the buffer and drop out
						// of the loop.
						//
						pszIPAddress = acBuffer;
						break;
					}

					//
					// Move to next IP address.
					//
					pIPAddrString = pIPAddrString->Next;
				}


				//
				// If we found the address, stop looping through adapters,
				// too.
				//
				if (pszIPAddress == acBuffer)
				{
					break;
				}


				//
				// Otherwise, go to next adapter.
				//
				pCurrentAdapterInfo = pCurrentAdapterInfo->Next;
			}

			//
			// If we never found the adapter, pszIPAddress will still point to
			// the IP address string.
			//
		}
		else
		{
			//
			// Didn't successfully get IPHLPAPI adapter info.  pszIPAddress will
			// still point to the IP address string.
			//
		}

		hr = STR_jkAnsiToWide(wszIPAddress, pszIPAddress, 512);
		if (FAILED(hr))
		{
			DPFX(DPFPREP,  0, "Failed to convert adapter name to wide (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
			goto Failure;
		}
#endif // ! DPNBUILD_NOWINSOCK2


		//
		// Generate the GUID.
		//
		saddrinTemp.sin_addr = pinaddrBuffer[dwIndex];
		GuidFromAddress(&guidAdapter, (SOCKADDR*) (&saddrinTemp));

		
		DPFX(DPFPREP, 7, "Returning adapter %u: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, flags = 0x%lx.",
			dwIndex,
			wszIPAddress,
			guidAdapter.Data1,
			guidAdapter.Data2,
			guidAdapter.Data3,
			guidAdapter.Data4[0],
			guidAdapter.Data4[1],
			guidAdapter.Data4[2],
			guidAdapter.Data4[3],
			guidAdapter.Data4[4],
			guidAdapter.Data4[5],
			guidAdapter.Data4[6],
			guidAdapter.Data4[7],
			dwDeviceFlags);

		
		//
		// Add adapter to buffer.
		//
		hr = AddInfoToBuffer(&PackedBuffer, wszIPAddress, &guidAdapter, dwDeviceFlags);
		if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
		{
			DPFX(DPFPREP,  0, "Failed to add adapter to buffer (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
			goto Failure;
		}
	} // end for (each IP address)


	//
	// If we're here, we successfully built the list of adapters, although
	// the caller may not have given us enough buffer space to store it.
	//
	pEnumData->dwAdapterCount = dwAddressCount;
	pEnumData->dwAdapterDataSize = PackedBuffer.GetSizeRequired();


Exit:

#ifndef DPNBUILD_NOWINSOCK2
	if (pAdapterInfoBuffer != NULL)
	{
		DNFree(pAdapterInfoBuffer);
		pAdapterInfoBuffer = NULL;
	}
#endif // !DPNBUILD_NOWINSOCK2

	if (pinaddrBuffer != NULL)
	{
		DNFree(pinaddrBuffer);
		pinaddrBuffer = NULL;
	}

	DPFX(DPFPREP, 6, "Return [0x%lx]", hr);

	return hr;


Failure:

	goto Exit;
}
//**********************************************************************



#ifndef DPNBUILD_NOIPV6

//**********************************************************************
// ------------------------------
// CSocketAddress::EnumIPv6and4Adapters - enumerate all of the IPv6 and IPv4 adapters for this machine
//
// Entry:		Pointer to enum adapters data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::EnumIPv6and4Adapters"

HRESULT	CSocketAddress::EnumIPv6and4Adapters( SPENUMADAPTERSDATA *const pEnumData ) const
{
	HRESULT							hr;
	DWORD							dwError;
	HMODULE						hIpHlpApiDLL = NULL;
	PFNGETADAPTERSADDRESSES		pfnGetAdaptersAddresses;
	CPackedBuffer					PackedBuffer;
	IP_ADAPTER_ADDRESSES *			pIpAdapterAddresses = NULL;
	ULONG							ulIpAdapterAddressesLength = 0;
	DWORD							dwTotalNumIPv6Addresses = 0;
	DWORD							dwTotalNumIPv4Addresses = 0;
	DWORD							dwLongestDescription = 0;
	WCHAR *							pwszBuffer = NULL;
	IP_ADAPTER_ADDRESSES *			pIpAdapterAddressesCurrent;
	IP_ADAPTER_UNICAST_ADDRESS *	pIpAdapterUnicastAddressCurrent;
	SORTADAPTERADDRESS *			paSortAdapterAddress = NULL;
	DWORD							dwNumIPv6Addresses = 0;
	DWORD							dwNumIPv4Addresses = 0;
	BOOL							fSkipIPv4Loopback = FALSE;
	BOOL							fFoundIPv4Loopback = FALSE;
	SOCKADDR_IN					saddrinLoopback;
	GUID							guidAdapter;
	DWORD							dwTemp;
	DWORD							dwDeviceFlags;
	WCHAR							wszIPAddress[INET6_ADDRSTRLEN];


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pEnumData);


	PackedBuffer.Initialize( pEnumData->pAdapterData, pEnumData->dwAdapterDataSize );
	
	//
	// Load the IPHLPAPI module and get the adapter list if possible.
	//
	hIpHlpApiDLL = LoadLibrary(c_tszIPHelperDLLName);
	if (hIpHlpApiDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Couldn't load IPHLPAPI, unable to look for IPv6 adapters (err = %u).", dwError);
#endif // DBG

		//
		// Just enumerate IPv4 adapters.
		//
		hr = EnumIPv4Adapters(pEnumData);

		goto Exit;
	}
	
	pfnGetAdaptersAddresses = (PFNGETADAPTERSADDRESSES) GetProcAddress(hIpHlpApiDLL, _TWINCE("GetAdaptersAddresses"));
	if (pfnGetAdaptersAddresses == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Couldn't find \"GetAdaptersAddresses\" function, unable to look for IPv6 adapters (err = %u).", dwError);
#endif // DBG

		//
		// Just enumerate IPv4 adapters.
		//
		hr = EnumIPv4Adapters(pEnumData);

		goto Exit;
	}


	//
	// OK, we're on a platform where it's possible to look for both IPv6 & IPv4 adapters.
	//
	
	do
	{
		dwError = pfnGetAdaptersAddresses(g_iIPAddressFamily,
										(GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER),
										NULL,
										pIpAdapterAddresses,
										&ulIpAdapterAddressesLength);

		if (dwError == ERROR_SUCCESS)
		{
			//
			// We got all the info we're going to get.  Make sure it was something.
			//
			if (ulIpAdapterAddressesLength < sizeof(IP_ADAPTER_ADDRESSES))
			{
				DPFX(DPFPREP, 0, "GetAdaptersAddresses returned invalid size %u!", ulIpAdapterAddressesLength);
				
				//
				// Get rid of the buffer if allocated.
				//
				if (pIpAdapterAddresses != NULL)
				{
					DNFree(pIpAdapterAddresses);
					pIpAdapterAddresses = NULL;
					ulIpAdapterAddressesLength = 0;
				}

				//
				// Continue with exiting the loop.
				//
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "GetAdaptersAddresses failed (err = 0x%lx)!", dwError);
			hr = DPNERR_OUTOFMEMORY;	// assume it's a resource issue
			goto Failure;
		}

		//
		// If we're here, then we need to reallocate the buffer.
		//
		if (pIpAdapterAddresses != NULL)
		{
			DNFree(pIpAdapterAddresses);
			pIpAdapterAddresses = NULL;
		}

		pIpAdapterAddresses = (IP_ADAPTER_ADDRESSES*) DNMalloc(ulIpAdapterAddressesLength);
		if (pIpAdapterAddresses == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate memory for adapter list!");
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	}
	while (TRUE);



	//
	// If there aren't any addresses, throw in the IPv4 loopback address.  We will assume that
	// IPv4 is available because IPv6 should always report loopback/link local address and
	// therefore cause pIpAdapterAddresses to be allocated.  If IPv6 is not available, then IPv4
	// must be available otherwise we wouldn't have allowed this SP to be loaded.
	//
	// If there are addresses, loop through all the adapters we found to count them and to
	// figure out the longest description name.
	//
	if (pIpAdapterAddresses == NULL)
	{
		DNASSERT(pIpAdapterAddresses == NULL);
		dwTotalNumIPv4Addresses++;
	}
	else
	{
		pIpAdapterAddressesCurrent = pIpAdapterAddresses;
		while (pIpAdapterAddressesCurrent != NULL)
		{
			if (pIpAdapterAddressesCurrent->FriendlyName != NULL)
			{
				dwTemp = wcslen(pIpAdapterAddressesCurrent->FriendlyName);
				if (dwTemp > dwLongestDescription)
				{
					dwLongestDescription = dwTemp;
				}
			}
			else
			{
				if (pIpAdapterAddressesCurrent->Description != NULL)
				{
					dwTemp = wcslen(pIpAdapterAddressesCurrent->Description);
					if (dwTemp > dwLongestDescription)
					{
						dwLongestDescription = dwTemp;
					}
				}
				else
				{
					//
					// No friendly name or description.
					//
				}
			}

			//
			// Count the number of addresses.
			//
			pIpAdapterUnicastAddressCurrent = pIpAdapterAddressesCurrent->FirstUnicastAddress;
			while (pIpAdapterUnicastAddressCurrent != NULL)
			{
				DumpSocketAddress(8, pIpAdapterUnicastAddressCurrent->Address.lpSockaddr, pIpAdapterUnicastAddressCurrent->Address.lpSockaddr->sa_family);
				
#pragma TODO(vanceo, "Option to allow non-preferred addresses?  See below, too.")
				if (pIpAdapterUnicastAddressCurrent->DadState == IpDadStatePreferred)
				{
					if (pIpAdapterUnicastAddressCurrent->Address.lpSockaddr->sa_family == AF_INET6)
					{
						//
						// Skip the loopback pseudo-interface. Windows reports the true
						// loopback address, and then a link-local-looking address.  We
						// don't care about the link-local one either because there should
						// be real link-local addresses available under other interfaces.
						// So completely jump out of the address loop when we see the
						// IPv6 loopback address.  See sorting loop below as well.
						//
						if (IN6_IS_ADDR_LOOPBACK(&(((SOCKADDR_IN6*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin6_addr)))
						{
							DNASSERT(pIpAdapterUnicastAddressCurrent == pIpAdapterAddressesCurrent->FirstUnicastAddress);
#pragma TODO(vanceo, "Are we sure we want to depend on the order the addresses are reported?  See below, too.")
							break;
						}

						if ((IN6_IS_ADDR_LINKLOCAL(&(((SOCKADDR_IN6*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin6_addr))) ||
							(IN6_IS_ADDR_SITELOCAL(&(((SOCKADDR_IN6*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin6_addr))))
						{
							DNASSERT(((SOCKADDR_IN6*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin6_scope_id != 0);
						}
						
						dwTotalNumIPv6Addresses++;
						fSkipIPv4Loopback = TRUE;
					}
					else
					{
						DNASSERT(pIpAdapterUnicastAddressCurrent->Address.lpSockaddr->sa_family == AF_INET);

						//
						// Skip the IPv4 loopback address if there are other addresses.
						//
						if (((SOCKADDR_IN*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin_addr.S_un.S_addr != IP_LOOPBACK_ADDRESS)
						{
							fSkipIPv4Loopback = TRUE;
						}
						else
						{
							fFoundIPv4Loopback = TRUE;
						}
						dwTotalNumIPv4Addresses++;
					}
				}
				else
				{
					DPFX(DPFPREP, 7, "Skipping address whose state (%u) is not preferred.",
						pIpAdapterUnicastAddressCurrent->DadState);
				}
				pIpAdapterUnicastAddressCurrent = pIpAdapterUnicastAddressCurrent->Next;
			}
			
			pIpAdapterAddressesCurrent = pIpAdapterAddressesCurrent->Next;
		}

		//
		// If we found the IPv4 loopback address but we can skip it, decrement our IPv4
		// address count.
		//
		if ((fFoundIPv4Loopback) && (fSkipIPv4Loopback))
		{
			DNASSERT(dwTotalNumIPv4Addresses > 0);
			dwTotalNumIPv4Addresses--;
		}
	}

	//
	// Allocate a buffer to hold the largest friendly name + the other info we add to the
	// adapter description.  INET6_ADDRSTRLEN is larger than INET_ADDRSTRLEN, and
	// includes NULL termination char (+ other things we don't actually use).
	//
	pwszBuffer = (WCHAR*) DNMalloc((dwLongestDescription + sizeof(c_wszIPv6AdapterNameTemplate) + INET6_ADDRSTRLEN) * sizeof(WCHAR));
	if (pwszBuffer == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for name string!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	paSortAdapterAddress = (SORTADAPTERADDRESS*) DNMalloc((dwTotalNumIPv6Addresses + dwTotalNumIPv4Addresses) * sizeof(SORTADAPTERADDRESS));
	if (paSortAdapterAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for sorted adapter list!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	memset(paSortAdapterAddress, 0, ((dwTotalNumIPv6Addresses + dwTotalNumIPv4Addresses) * sizeof(SORTADAPTERADDRESS)));

	if (pIpAdapterAddresses == NULL)
	{
		memset(&saddrinLoopback, 0, sizeof(saddrinLoopback));
		saddrinLoopback.sin_family				= AF_INET;
		saddrinLoopback.sin_addr.S_un.S_addr	= IP_LOOPBACK_ADDRESS;

		paSortAdapterAddress[0].psockaddr = (SOCKADDR*) &saddrinLoopback;
		paSortAdapterAddress[0].pwszDescription = (WCHAR*) c_wszIPv4LoopbackAdapterString;
	}
	else
	{
		//
		// Loop through all the adapters again to sort them.
		// The rules are (in order of precedence):
		//	1) Skip addresses that are not in the 'preferred' state.
		//	2) IPv6 before IPv4.
		//	3) Skip IPv6 loopback pseudo-interface.
		//	4) IPv4 ICS-private-adapter-looking IP addresses (192.168.0.1) first.
		//	5) Skip IPv4 loopback address (127.0.0.1) if we determined there were other addresses.
		//
		pIpAdapterAddressesCurrent = pIpAdapterAddresses;
		while (pIpAdapterAddressesCurrent != NULL)
		{
			pIpAdapterUnicastAddressCurrent = pIpAdapterAddressesCurrent->FirstUnicastAddress;
			while (pIpAdapterUnicastAddressCurrent != NULL)
			{
				if (pIpAdapterUnicastAddressCurrent->DadState == IpDadStatePreferred)
				{
					//
					// Insert IPv6 adapters in the first half of the array, IPv4 in the second half.  
					//
					if (pIpAdapterUnicastAddressCurrent->Address.lpSockaddr->sa_family == AF_INET6)
					{
						SOCKADDR_IN6 *		psaddrin6;


						psaddrin6 = (SOCKADDR_IN6*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr;
						
						//
						// Skip the loopback pseudo-interface as described earlier.
						//
						if (IN6_IS_ADDR_LOOPBACK(&psaddrin6->sin6_addr))
						{
							break;
						}

						//
						// Save the pointers in the current slot.
						//
						
						paSortAdapterAddress[dwNumIPv6Addresses].psockaddr = (SOCKADDR*) psaddrin6;
						
						if (pIpAdapterAddressesCurrent->FriendlyName != NULL)
						{
							paSortAdapterAddress[dwNumIPv6Addresses].pwszDescription = pIpAdapterAddressesCurrent->FriendlyName;
						}
						else
						{
							if (pIpAdapterAddressesCurrent->Description != NULL)
							{
								paSortAdapterAddress[dwNumIPv6Addresses].pwszDescription = pIpAdapterAddressesCurrent->Description;
							}
						}
						
						DNASSERT(dwNumIPv6Addresses < dwTotalNumIPv6Addresses);
						dwNumIPv6Addresses++;
					}
					else
					{
						DNASSERT(pIpAdapterUnicastAddressCurrent->Address.lpSockaddr->sa_family == AF_INET);

						if ((((SOCKADDR_IN*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin_addr.S_un.S_addr != IP_LOOPBACK_ADDRESS) ||
							(! fSkipIPv4Loopback))
						{
							//
							// If this looks like an ICS private adapter and there are other adapters, put it first,
							// otherwise add to the end.
							//
							if ((((SOCKADDR_IN*) pIpAdapterUnicastAddressCurrent->Address.lpSockaddr)->sin_addr.S_un.S_addr == IP_PRIVATEICS_ADDRESS) &&
								(dwNumIPv4Addresses > 0))
							{
								//
								// Move all existing entries down one.
								//
								for(dwTemp = dwTotalNumIPv6Addresses + dwNumIPv4Addresses; dwTemp > dwTotalNumIPv6Addresses; dwTemp--)
								{
									memcpy(&paSortAdapterAddress[dwTemp],
											&paSortAdapterAddress[dwTemp - 1],
											sizeof(SORTADAPTERADDRESS));
								}

								//
								// Add this new entry at the start of the IPv4 addresses.
								//
								
								paSortAdapterAddress[dwTotalNumIPv6Addresses].psockaddr = pIpAdapterUnicastAddressCurrent->Address.lpSockaddr;
								
								if (pIpAdapterAddressesCurrent->FriendlyName != NULL)
								{
									paSortAdapterAddress[dwTotalNumIPv6Addresses].pwszDescription = pIpAdapterAddressesCurrent->FriendlyName;
								}
								else
								{
									if (pIpAdapterAddressesCurrent->Description != NULL)
									{
										paSortAdapterAddress[dwTotalNumIPv6Addresses].pwszDescription = pIpAdapterAddressesCurrent->Description;
									}
								}
							}
							else
							{
								//
								// Add this entry at the current IPv4 address slot.
								//

								paSortAdapterAddress[dwTotalNumIPv6Addresses + dwNumIPv4Addresses].psockaddr = pIpAdapterUnicastAddressCurrent->Address.lpSockaddr;
								
								if (pIpAdapterAddressesCurrent->FriendlyName != NULL)
								{
									paSortAdapterAddress[dwTotalNumIPv6Addresses + dwNumIPv4Addresses].pwszDescription = pIpAdapterAddressesCurrent->FriendlyName;
								}
								else
								{
									if (pIpAdapterAddressesCurrent->Description != NULL)
									{
										paSortAdapterAddress[dwTotalNumIPv6Addresses + dwNumIPv4Addresses].pwszDescription = pIpAdapterAddressesCurrent->Description;
									}
								}
							}
							
							DNASSERT(dwNumIPv4Addresses < dwTotalNumIPv4Addresses);
							dwNumIPv4Addresses++;
						}
						else
						{
							//
							// Skip the IPv4 loopback address.
							//
						}
					}
				}
				else
				{
					//
					// Deprecated or otherwise non-preferred address.
					//
				}
				pIpAdapterUnicastAddressCurrent = pIpAdapterUnicastAddressCurrent->Next;
			}
			
			pIpAdapterAddressesCurrent = pIpAdapterAddressesCurrent->Next;
		}
	}

	//
	// Finally loop through the sorted adapters and store them in the buffer (or get size needed).
	//
	for(dwTemp = 0; dwTemp < dwTotalNumIPv6Addresses + dwTotalNumIPv4Addresses; dwTemp++)
	{
		//
		// Start off assuming this IP address won't have any special
		// flags.
		//
		dwDeviceFlags = 0;

#pragma BUGBUG(vanceo, "Move to appropriate location so that turning on DPNBUILD_NOMULTICAST doesn't break")
		/*
#ifndef DPNBUILD_NOMULTICAST
		//
		// If this is the first device and we couldn't use IPHLPAPI to
		// determine the best multicast interface, then just say the
		// default multicast interface is the first (for lack of a
		// better idea).
		//
#ifdef DPNBUILD_NOWINSOCK2
		if (dwIndex == 0)
#else // ! DPNBUILD_NOWINSOCK2
		if ((dwIndex == 0) && (dwMcastInterfaceIndex == INVALID_INTERFACE_INDEX))
#endif // ! DPNBUILD_NOWINSOCK2
		{
			dwDeviceFlags |= DPNSPINFO_DEFAULTMULTICASTDEVICE;
		}
#endif // ! DPNBUILD_NOMULTICAST
		*/


		//
		// Create a string representation of the IP address and generate the name.
		//
		if (paSortAdapterAddress[dwTemp].psockaddr->sa_family == AF_INET6)
		{
			DNIpv6AddressToStringW(&((SOCKADDR_IN6*) paSortAdapterAddress[dwTemp].psockaddr)->sin6_addr,
								wszIPAddress);
			
			if (paSortAdapterAddress[dwTemp].pwszDescription != NULL)
			{
				wsprintfW(pwszBuffer,
						  c_wszIPv6AdapterNameTemplate,
						  paSortAdapterAddress[dwTemp].pwszDescription,
						  wszIPAddress);
			}
			else
			{
				wsprintfW(pwszBuffer,
						  c_wszIPv6AdapterNameNoDescTemplate,
						  wszIPAddress);
			}
		}
		else
		{
			DNinet_ntow(((SOCKADDR_IN*) paSortAdapterAddress[dwTemp].psockaddr)->sin_addr,
						wszIPAddress);
			
			if (paSortAdapterAddress[dwTemp].pwszDescription != NULL)
			{
				wsprintfW(pwszBuffer,
						  c_wszIPv4AdapterNameTemplate,
						  paSortAdapterAddress[dwTemp].pwszDescription,
						  wszIPAddress);
			}
			else
			{
				wsprintfW(pwszBuffer,
						  c_wszIPv4AdapterNameNoDescTemplate,
						  wszIPAddress);
			}
		}
	
		
		//
		// Generate the GUID.
		//
		GuidFromAddress(&guidAdapter, paSortAdapterAddress[dwTemp].psockaddr);

		
		DPFX(DPFPREP, 7, "Returning adapter %u: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}, flags = 0x%lx.",
			dwTemp,
			pwszBuffer,
			guidAdapter.Data1,
			guidAdapter.Data2,
			guidAdapter.Data3,
			guidAdapter.Data4[0],
			guidAdapter.Data4[1],
			guidAdapter.Data4[2],
			guidAdapter.Data4[3],
			guidAdapter.Data4[4],
			guidAdapter.Data4[5],
			guidAdapter.Data4[6],
			guidAdapter.Data4[7],
			dwDeviceFlags);

		
		//
		// Add adapter to buffer.
		//
		hr = AddInfoToBuffer(&PackedBuffer, pwszBuffer, &guidAdapter, dwDeviceFlags);
		if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
		{
			DPFX(DPFPREP,  0, "Failed to add adapter to buffer (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
	
	//
	// If we're here, we successfully built the list of adapters, although
	// the caller may not have given us enough buffer space to store it.
	//
	pEnumData->dwAdapterCount = dwTotalNumIPv6Addresses + dwTotalNumIPv4Addresses;
	pEnumData->dwAdapterDataSize = PackedBuffer.GetSizeRequired();


Exit:

	if (paSortAdapterAddress != NULL)
	{
		DNFree(paSortAdapterAddress);
		paSortAdapterAddress = NULL;
	}

	if (pwszBuffer != NULL)
	{
		DNFree(pwszBuffer);
		pwszBuffer = NULL;
	}

	if (pIpAdapterAddresses != NULL)
	{
		DNFree(pIpAdapterAddresses);
		pIpAdapterAddresses = NULL;
	}

	if (hIpHlpApiDLL != NULL)
	{
		FreeLibrary(hIpHlpApiDLL);
		hIpHlpApiDLL = NULL;
	}
	
	DPFX(DPFPREP, 6, "Return [0x%lx]", hr);

	return hr;

Failure:
	
	goto Exit;
}
//**********************************************************************
#endif // ! DPNBUILD_NOIPV6

#endif // ! DPNBUILD_ONLYONEADAPTER



#ifndef DPNBUILD_NOMULTICAST

//**********************************************************************
// ------------------------------
// CSocketAddress::EnumMulticastScopes - enumerate all multicast scopes for an adapter
//
// Entry:		Pointer to enum multicast scopes data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::EnumMulticastScopes"

HRESULT	CSocketAddress::EnumMulticastScopes( SPENUMMULTICASTSCOPESDATA *const pEnumData, BOOL const fUseMADCAP ) const
{
	HRESULT				hr;
	CPackedBuffer		PackedBuffer;
#ifdef DPNBUILD_NOIPV6
	SOCKADDR			saddrAdapter;
#else // ! DPNBUILD_NOIPV6
	SOCKADDR_STORAGE	saddrAdapter;
#endif // ! DPNBUILD_NOIPV6
	SOCKET				sTemp = INVALID_SOCKET;
	DWORD				dwScopeCount = 0;
#ifdef DBG
	DWORD				dwError;
#endif // DBG


	DPFX(DPFPREP, 6, "Parameters: (0x%p, %i)", pEnumData, fUseMADCAP);

	PackedBuffer.Initialize(pEnumData->pScopeData, pEnumData->dwScopeDataSize);

#pragma TODO(vanceo, "Make IPv6 ready")
	AddressFromGuid(pEnumData->pguidAdapter, &saddrAdapter);

	//
	// Make sure the adapter is valid by asking WinSock.
	//

	sTemp = socket(GetFamily(), SOCK_DGRAM, IPPROTO_UDP);
	if (sTemp == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = WSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create temporary UDP socket (err = %u)!", dwError);
		DNASSERT(FALSE);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}

#ifndef DPNBUILD_NOIPV6
	if (saddrAdapter.ss_family == AF_INET6)
	{
		saddrAdapter.ss_family = GetFamily();

#pragma TODO(vanceo, "Make IPv6 ready")
	}
	else
#endif // ! DPNBUILD_NOIPV6
	{
		((SOCKADDR_IN*) (&saddrAdapter))->sin_family = GetFamily();
		((SOCKADDR_IN*) (&saddrAdapter))->sin_port = ANY_PORT;
	}

	if (bind(sTemp, (SOCKADDR*) (&saddrAdapter), sizeof(saddrAdapter)) != 0)
	{
#ifdef DBG
		dwError = WSAGetLastError();
		DPFX(DPFPREP, 0, "Adapter GUID is invalid (err = %u)!", dwError);
		DisplayWinsockError(0, dwError);
		DNASSERT(dwError == WSAEADDRNOTAVAIL);
#endif // DBG
		hr = DPNERR_INVALIDDEVICEADDRESS;
		goto Failure;
	}

	closesocket(sTemp);
	sTemp = INVALID_SOCKET;


	//
	// The adapter is valid.  First, fill in the 3 default multicast scopes.
	//

	hr = AddInfoToBuffer(&PackedBuffer, c_wszPrivateScopeString, &GUID_DP8MULTICASTSCOPE_PRIVATE, 0);
	if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
	{
		DPFX(DPFPREP, 0, "Failed to add private scope to buffer (err = 0x%lx)!", hr);
		DisplayDNError(0, hr);
		goto Failure;
	}
	DPFX(DPFPREP, 7, "Returning scope %u: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
		dwScopeCount,
		c_wszPrivateScopeString,
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data1,
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data2,
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data3,
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[0],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[1],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[2],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[3],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[4],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[5],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[6],
		GUID_DP8MULTICASTSCOPE_PRIVATE.Data4[7]);
	dwScopeCount++;

	hr = AddInfoToBuffer(&PackedBuffer, c_wszLocalScopeString, &GUID_DP8MULTICASTSCOPE_LOCAL, 0);
	if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
	{
		DPFX(DPFPREP, 0, "Failed to add local scope to buffer (err = 0x%lx)!", hr);
		DisplayDNError(0, hr);
		goto Failure;
	}
	DPFX(DPFPREP, 7, "Returning scope %u: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
		dwScopeCount,
		c_wszLocalScopeString,
		GUID_DP8MULTICASTSCOPE_LOCAL.Data1,
		GUID_DP8MULTICASTSCOPE_LOCAL.Data2,
		GUID_DP8MULTICASTSCOPE_LOCAL.Data3,
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[0],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[1],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[2],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[3],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[4],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[5],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[6],
		GUID_DP8MULTICASTSCOPE_LOCAL.Data4[7]);
	dwScopeCount++;

	hr = AddInfoToBuffer(&PackedBuffer, c_wszGlobalScopeString, &GUID_DP8MULTICASTSCOPE_GLOBAL, 0);
	if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
	{
		DPFX(DPFPREP, 0, "Failed to add global scope to buffer (err = 0x%lx)!", hr);
		DisplayDNError(0, hr);
		goto Failure;
	}
	DPFX(DPFPREP, 7, "Returning scope %u: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
		dwScopeCount,
		c_wszGlobalScopeString,
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data1,
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data2,
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data3,
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[0],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[1],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[2],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[3],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[4],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[5],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[6],
		GUID_DP8MULTICASTSCOPE_GLOBAL.Data4[7]);
	dwScopeCount++;


	//
	// If this platform supports MADCAP, retrieve its list of scopes for
	// this adapter.
	// NOTE: This assumes MADCAP has been loaded by the thread pool
	// already.
	//
#ifdef WINNT
	if (fUseMADCAP)
	{
#ifndef DBG
		DWORD				dwError;
#endif // ! DBG
		PMCAST_SCOPE_ENTRY	paScopes = NULL;
		DWORD				dwScopesSize = 0;
		DWORD				dwNumScopeEntries;
		DWORD				dwTemp;
		WCHAR *				pwszScratch;
		GUID				guidScope;


		//
		// Determine how much room we need to hold the list of scopes.
		//
		dwError = McastEnumerateScopes(GetFamily(),
										TRUE,
										NULL,
										&dwScopesSize,
										&dwNumScopeEntries);
		if (((dwError == ERROR_SUCCESS) || (dwError == ERROR_MORE_DATA)) &&
			(dwScopesSize >= sizeof(MCAST_SCOPE_ENTRY)) &&
			(dwNumScopeEntries > 0))
		{
			//
			// We want to add " - TTL xxx" to every string entry, so allocate
			// enough extra room for a scratch buffer for the largest possible
			// string plus that extra information.
			//
			dwTemp = dwScopesSize - (dwNumScopeEntries * sizeof(MCAST_SCOPE_ENTRY)) + (10 * sizeof(WCHAR));

			paScopes = (PMCAST_SCOPE_ENTRY) DNMalloc(dwScopesSize + dwTemp);
			if (paScopes != NULL)
			{
				pwszScratch = (WCHAR*) (((BYTE*) (paScopes)) + dwScopesSize);

				//
				// Retrieve the list of scopes.
				//
				dwError = McastEnumerateScopes(GetFamily(),
												FALSE,
												paScopes,
												&dwScopesSize,
												&dwNumScopeEntries);
				if ((dwError == ERROR_SUCCESS) &&
					(dwScopesSize >= sizeof(MCAST_SCOPE_ENTRY)) &&
					(dwNumScopeEntries > 0))
				{
					//
					// Look for scopes that match the device we were given.
					//
					for(dwTemp = 0; dwTemp < dwNumScopeEntries; dwTemp++)
					{
						BOOL	fResult;


#ifndef DPNBUILD_NOIPV6
						if (GetFamily() == AF_INET6)
						{
							if (memcmp(&paScopes[dwTemp].ScopeCtx.Interface.IpAddrV6, &(((SOCKADDR_IN6*) (&saddrAdapter))->sin6_addr), sizeof(paScopes[dwTemp].ScopeCtx.Interface.IpAddrV6)) == 0)
							{
								fResult = TRUE;
							}
							else
							{
								fResult = FALSE;
							}
						}
						else
#endif // ! DPNBUILD_NOIPV6
						{
							if (paScopes[dwTemp].ScopeCtx.Interface.IpAddrV4 == ((SOCKADDR_IN*) (&saddrAdapter))->sin_addr.S_un.S_addr)
							{
								fResult = TRUE;
							}
							else
							{
								fResult = FALSE;
							}
						}

						if (fResult)
						{
							//
							// Encrypt the scope context and TTL as a GUID.
							//
#ifdef DPNBUILD_NOIPV6
							CSocketAddress::CreateScopeGuid(&(paScopes[dwTemp].ScopeCtx),
#else // ! DPNBUILD_NOIPV6
							CSocketAddress::CreateScopeGuid(GetFamily(),
															&(paScopes[dwTemp].ScopeCtx),
#endif // ! DPNBUILD_NOIPV6
															(BYTE) (paScopes[dwTemp].TTL),
															&guidScope);

							//
							// Use the scratch space at the end of our buffer to
							// append " - TTL xxx" to the description string.
							//
							wsprintfW(pwszScratch, L"%ls - TTL %u",
									paScopes[dwTemp].ScopeDesc.Buffer,
									(BYTE) (paScopes[dwTemp].TTL));

							hr = AddInfoToBuffer(&PackedBuffer, pwszScratch, &guidScope, 0);
							if ((hr != DPN_OK) && (hr != DPNERR_BUFFERTOOSMALL))
							{
								DPFX(DPFPREP, 0, "Failed to add scope \"%ls\" to buffer (err = 0x%lx)!",
									pwszScratch, hr);
								DisplayDNError(0, hr);
								DNFree(paScopes);
								paScopes = NULL;
								goto Failure;
							}
							DPFX(DPFPREP, 7, "Returning scope %u: \"%ls\" {%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}.",
								dwScopeCount,
								pwszScratch,
								guidScope.Data1,
								guidScope.Data2,
								guidScope.Data3,
								guidScope.Data4[0],
								guidScope.Data4[1],
								guidScope.Data4[2],
								guidScope.Data4[3],
								guidScope.Data4[4],
								guidScope.Data4[5],
								guidScope.Data4[6],
								guidScope.Data4[7]);
							dwScopeCount++;
						}
						else
						{
							DPFX(DPFPREP, 7, "Ignoring scope \"%ls - TTL %u\" for different adapter.",
								paScopes[dwTemp].ScopeDesc.Buffer, paScopes[dwTemp].TTL);
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 0, "Failed enumerating MADCAP scopes (err = %u, size %u, expected size %u, count %u)!  Ignoring.",
						dwError, dwScopesSize, sizeof(MCAST_SCOPE_ENTRY), dwNumScopeEntries);
				}

				DNFree(paScopes);
				paScopes = NULL;
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed allocating memory for MADCAP scopes!  Ignoring.");
			}
		}
		else
		{
			DPFX(DPFPREP, 0, "Enumerating scopes for size required didn't return expected error or size (err = %u, size %u, expected size %u, count %u)!  Ignoring.",
				dwError, dwScopesSize, sizeof(MCAST_SCOPE_ENTRY), dwNumScopeEntries);
		}
	} // end if (MADCAP should be used)
	else
	{
		DPFX(DPFPREP, 7, "Not enumerating MADCAP scopes.");
	}
#endif // WINNT


	//
	// If we're here, we successfully built the list of adapters, although
	// the caller may not have given us enough buffer space to store it.
	//
	pEnumData->dwScopeCount = dwScopeCount;
	pEnumData->dwScopeDataSize = PackedBuffer.GetSizeRequired();


Exit:

	DPFX(DPFPREP, 6, "Returning: [0x%lx]", hr);

	return hr;

Failure:

	if (sTemp != INVALID_SOCKET)
	{
		closesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketAddress::SocketAddressFromMulticastDP8Address - convert a multicast style DP8Address into a socket address (may not be complete)
//
// Entry:		Pointer to DP8Address
//				Place to store scope GUID.
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::SocketAddressFromMulticastDP8Address"

HRESULT	CSocketAddress::SocketAddressFromMulticastDP8Address( IDirectPlay8Address *const pDP8Address,
#ifdef DPNBUILD_XNETSECURITY
															ULONGLONG * const pullKeyID,
#endif // DPNBUILD_XNETSECURITY
															GUID * const pScopeGuid )
{
	HRESULT		hr;
	WCHAR		wszMulticastAddress[16]; // nnn.nnn.nnn.nnn + NULL termination
	char		szMulticastAddress[16]; // nnn.nnn.nnn.nnn + NULL termination
	DWORD		dwSize;
	DWORD		dwDataType;
	DWORD		dwPort;


	DNASSERT(pDP8Address != NULL);

#ifdef DPNBUILD_XNETSECURITY
#error ("Multicast doesn't currently support secure transport!")
#endif // DPNBUILD_XNETSECURITY

	//
	// Get the multicast IP address, if it's there.
	//
	dwSize = sizeof(wszMulticastAddress);
	hr = IDirectPlay8Address_GetComponentByName(pDP8Address,
												DPNA_KEY_HOSTNAME,
												wszMulticastAddress,
												&dwSize,
												&dwDataType);
	if (hr == DPN_OK)
	{
		switch (dwDataType)
		{
			case DPNA_DATATYPE_STRING:
			{
				STR_jkWideToAnsi(szMulticastAddress,
								wszMulticastAddress,
								(sizeof(szMulticastAddress) / sizeof(char)));
				break;
			}

			case DPNA_DATATYPE_STRING_ANSI:
			{
				DWORD	dwStrSize;


				//
				// For some reason, addressing returned the string as ANSI,
				// not Unicode.  Not sure why this would happen, but go
				// ahead and convert it.
				// First make sure it's a reasonable size.
				// If you're wondering about the funkiness of this copying,
				// it's because PREfast goes a little overboard...
				//
				dwStrSize = (strlen((char*) wszMulticastAddress) + 1) * sizeof(char);
				DNASSERT(dwStrSize == dwSize);
				if (dwStrSize > (sizeof(szMulticastAddress) / sizeof(char)))
				{
					DPFX(DPFPREP, 0, "Unexpectedly long ANSI hostname string (%u bytes)!", dwStrSize);
					hr = DPNERR_INVALIDADDRESSFORMAT;
					goto Failure;
				}
				memcpy(szMulticastAddress, (char*) wszMulticastAddress, dwStrSize);
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Unexpected data type %u for hostname component!", dwDataType);
				hr = DPNERR_INVALIDADDRESSFORMAT;
				goto Failure;
				break;
			}
		}


		//
		// Convert the IP address string into an address.
		//
		m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = inet_addr(szMulticastAddress);


		//
		// Make sure it's a valid multicast IP address.
		//
		if (! (IS_CLASSD_IPV4_ADDRESS(m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr)))
		{
			DPFX(DPFPREP, 0, "Hostname component \"%hs\" does not resolve to valid multicast IP address!",
				szMulticastAddress);
			hr = DPNERR_INVALIDHOSTADDRESS;
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 3, "Address didn't contain multicast hostname (err = 0x%lx).", hr);
		DNASSERT(m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == INADDR_ANY);
	}


	//
	// Get the multicast port, if it's there.
	//
	dwSize = sizeof(dwPort);
	hr = IDirectPlay8Address_GetComponentByName(pDP8Address,
												DPNA_KEY_PORT,
												&dwPort,
												&dwSize,
												&dwDataType);
	if (hr == DPN_OK)
	{
		if (dwDataType != DPNA_DATATYPE_DWORD)
		{
			DPFX(DPFPREP, 0, "Unexpected data type %u for port component!", dwDataType);
			hr = DPNERR_INVALIDADDRESSFORMAT;
			goto Failure;
		}
		m_SocketAddress.IPSocketAddress.sin_port = HTONS((WORD) dwPort);
	}
	else
	{
		DPFX(DPFPREP, 3, "Address didn't contain multicast port (err = 0x%lx).", hr);
		DNASSERT(m_SocketAddress.IPSocketAddress.sin_port == ANY_PORT);
	}


	//
	// Get the multicast scope, if it's there.
	//
	dwSize = sizeof(*pScopeGuid);
	hr = IDirectPlay8Address_GetComponentByName(pDP8Address,
												DPNA_KEY_SCOPE,
												pScopeGuid,
												&dwSize,
												&dwDataType);
	if (hr == DPN_OK)
	{
		if (dwDataType != DPNA_DATATYPE_GUID)
		{
			DPFX(DPFPREP, 0, "Unexpected data type %u for scope component!", dwDataType);
			hr = DPNERR_INVALIDADDRESSFORMAT;
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 3, "Address didn't contain multicast scope (err = 0x%lx), using private scope.", hr);
		memcpy(pScopeGuid, &GUID_DP8MULTICASTSCOPE_PRIVATE, sizeof(*pScopeGuid));
	}

	hr = DPN_OK;


Exit:

	return hr;


Failure:

	goto Exit;
}
//**********************************************************************


#endif // ! DPNBUILD_NOMULTICAST


//**********************************************************************
// ------------------------------
// CSocketAddress::CompareFunction - compare against another address
//
// Entry:		Pointer to other address
//
// Exit:		Bool indicating equality of two addresses
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::CompareFunction"

BOOL CSocketAddress::CompareFunction( PVOID pvKey1, PVOID pvKey2 )
{
	CSocketAddress* pAddress1 = (CSocketAddress*)pvKey1;
	CSocketAddress* pAddress2 = (CSocketAddress*)pvKey2;

	DNASSERT(pAddress1 != NULL);
	DNASSERT(pAddress2 != NULL);

	DNASSERT(pAddress1->GetFamily() == pAddress2->GetFamily());

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (pAddress1->GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			//
			// we need to compare the IPv6 address and port to guarantee uniqueness
			//
			if (IN6_ADDR_EQUAL(&(pAddress1->m_SocketAddress.IPv6SocketAddress.sin6_addr),
								&(pAddress2->m_SocketAddress.IPv6SocketAddress.sin6_addr)))
			{
				if ( pAddress1->m_SocketAddress.IPv6SocketAddress.sin6_port == 
					 pAddress2->m_SocketAddress.IPv6SocketAddress.sin6_port )
				{
					return TRUE;
				}
			}

			return	FALSE;
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			//
			// We only need to compare:
			//	netnumber (IPX network address) [ 4 bytes ]
			//	nodenumber (netcard adapter address) [ 6 bytes ]
			// 	port [ 2 bytes ]
			//
			// Note that the nodenumber and port fields are sequentially arranged in the
			// address structure and can be compared with DWORDs
			//
			DBG_CASSERT( OFFSETOF( SOCKADDR_IPX, sa_nodenum ) == ( OFFSETOF( SOCKADDR_IPX, sa_netnum ) + sizeof( pAddress1->m_SocketAddress.IPXSocketAddress.sa_netnum ) ) );
			DBG_CASSERT( OFFSETOF( SOCKADDR_IPX, sa_socket ) == ( OFFSETOF( SOCKADDR_IPX, sa_nodenum ) + sizeof( pAddress1->m_SocketAddress.IPXSocketAddress.sa_nodenum ) ) );
			
			return	memcmp( &pAddress1->m_SocketAddress.IPXSocketAddress.sa_netnum,
							pAddress2->m_SocketAddress.IPXSocketAddress.sa_netnum,
							( sizeof( pAddress1->m_SocketAddress.IPXSocketAddress.sa_netnum ) +
							  sizeof( pAddress1->m_SocketAddress.IPXSocketAddress.sa_nodenum ) +
							  sizeof( pAddress1->m_SocketAddress.IPXSocketAddress.sa_socket ) ) ) == 0;
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			DNASSERT(pAddress1->GetFamily() == AF_INET);

			//
			// we need to compare the IP address and port to guarantee uniqueness
			//
			if ( pAddress1->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == 
				 pAddress2->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr )
			{
				if ( pAddress1->m_SocketAddress.IPSocketAddress.sin_port == 
					 pAddress2->m_SocketAddress.IPSocketAddress.sin_port )
				{
					return TRUE;
				}
			}

			return	FALSE;
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketAddress::HashFunction - hash address to N bits
//
// Entry:		Count of bits to hash to
//
// Exit:		Hashed value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::HashFunction"

DWORD CSocketAddress::HashFunction( PVOID pvKey, BYTE bBitDepth )
{
	DWORD				dwReturn;
	UINT_PTR			Temp;
	CSocketAddress*		pAddress = (CSocketAddress*) pvKey;

	DNASSERT( bBitDepth != 0 );
	DNASSERT( bBitDepth < 32 );

	//
	// initialize
	//
	dwReturn = 0;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (pAddress->GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			DWORD	dwTemp;


			//
			// hash IPv6 address
			//
			for(dwTemp = 0; dwTemp < (sizeof(pAddress->m_SocketAddress.IPv6SocketAddress.sin6_addr) / sizeof(UINT_PTR)); dwTemp++)
			{
				Temp = ((UINT_PTR*) (&pAddress->m_SocketAddress.IPv6SocketAddress.sin6_addr))[dwTemp];

				do
				{
					dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
					Temp >>= bBitDepth;
				} while ( Temp != 0 );
			}

			//
			// hash IPv6 port
			//
			Temp = pAddress->m_SocketAddress.IPv6SocketAddress.sin6_port;

			do
			{
				dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
				Temp >>= bBitDepth;
			} while ( Temp != 0 );
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			//
			// hash first DWORD of IPX address
			//
			Temp = *reinterpret_cast<const DWORD*>( &pAddress->m_SocketAddress.IPXSocketAddress.sa_nodenum[ 0 ] );

			do
			{
				dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
				Temp >>= bBitDepth;
			} while ( Temp != 0 );

			//
			// hash second DWORD of IPX address and IPX socket
			//
			Temp = *reinterpret_cast<const WORD*>( &pAddress->m_SocketAddress.IPXSocketAddress.sa_nodenum[ sizeof( DWORD ) ] );
			Temp += ( pAddress->m_SocketAddress.IPXSocketAddress.sa_socket << ( sizeof( WORD ) * 8 ) );

			do
			{
				dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
				Temp >>= bBitDepth;
			} while ( Temp != 0 );
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			DNASSERT(pAddress->GetFamily() == AF_INET);

			//
			// hash IP address
			//
			Temp = pAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;

			do
			{
				dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
				Temp >>= bBitDepth;
			} while ( Temp != 0 );

			//
			// hash IP port
			//
			Temp = pAddress->m_SocketAddress.IPSocketAddress.sin_port;

			do
			{
				dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
				Temp >>= bBitDepth;
			} while ( Temp != 0 );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
	return dwReturn;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CSocketAddress::GuidFromInternalAddressWithoutPort - get a guid from the internal
//		address without a port.
//
// Entry:		Reference to desintation GUID
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::GuidFromInternalAddressWithoutPort"

void	CSocketAddress::GuidFromInternalAddressWithoutPort( GUID * pOutputGuid ) const
{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			GuidFromAddress( pOutputGuid, &m_SocketAddress.SocketAddress );
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			union
			{
				SOCKADDR		SockAddr;
				SOCKADDR_IPX	IPXSockAddr;
			} TempSocketAddress;


			memcpy( &TempSocketAddress.SockAddr, &m_SocketAddress.SocketAddress, sizeof( TempSocketAddress.SockAddr ) );
			TempSocketAddress.IPXSockAddr.sa_socket = 0;
			GuidFromAddress( pOutputGuid, &TempSocketAddress.SockAddr );
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			union
			{
				SOCKADDR		SockAddr;
				SOCKADDR_IN		IPSockAddr;
			} TempSocketAddress;


			DNASSERT(GetFamily() == AF_INET);
			memcpy( &TempSocketAddress.SockAddr, &m_SocketAddress.SocketAddress, sizeof( TempSocketAddress.SockAddr ) );
			TempSocketAddress.IPSockAddr.sin_port = 0;
			GuidFromAddress( pOutputGuid, &TempSocketAddress.SockAddr );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CSocketAddress::IsUndefinedHostAddress - determine if this is an undefined host
//		address
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether this is an undefined host address
//				TRUE = this is an undefined address
//				FALSE = this is not an undefined address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::IsUndefinedHostAddress"

BOOL	CSocketAddress::IsUndefinedHostAddress( void ) const
{
	BOOL	fReturn;


	fReturn = FALSE;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			if (IN6_IS_ADDR_UNSPECIFIED(&m_SocketAddress.IPv6SocketAddress.sin6_addr))
			{
				fReturn = TRUE;
			}
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			
			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( DWORD ) );
			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 6 );
			if ( ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_netnum ) == 0 ) &&
				 ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 0 ) &&
				 ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ 2 ] ) == 0 ) )
			{
				fReturn = TRUE;
			}
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == INADDR_ANY )
			{
				fReturn = TRUE;
			}
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}

	return	fReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CSocketAddress::IsValidUnicastAddress - determine if this is valid unicast address
//		address
//
// Entry:		Whether to also allow the broadcast address or not.
//
// Exit:		Boolean indicating whether this is a reachable address
//				TRUE = this is a reachable address
//				FALSE = this is not a reachable address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::IsValidUnicastAddress"

BOOL	CSocketAddress::IsValidUnicastAddress( BOOL fAllowBroadcastAddress ) const
{
	BOOL	fReturn;


	fReturn = TRUE;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			//
			// Make sure the address is not all zeros.
			//
			if (IN6_IS_ADDR_UNSPECIFIED(&m_SocketAddress.IPv6SocketAddress.sin6_addr))
			{
				fReturn = FALSE;
				DNASSERTX(! "IPv6 address is :: (all zeros)!", 2);
			}
			
			//
			// Make sure the address is not a multicast address, unless broadcast is allowed
			// and it's the special enum multicast address.
			//
			if (IN6_IS_ADDR_MULTICAST(&m_SocketAddress.IPv6SocketAddress.sin6_addr))
			{
				if ((! fAllowBroadcastAddress) ||
					(! IN6_ADDR_EQUAL(&m_SocketAddress.IPv6SocketAddress.sin6_addr, &c_in6addrEnumMulticast)))
				{
					fReturn = FALSE;
					DNASSERTX(! "IPv6 address is a multicast address!", 2);
				}
			}
			
			//
			// Disallow port 0.
			//
			if (m_SocketAddress.IPv6SocketAddress.sin6_port == 0)
			{
				fReturn = FALSE;
				DNASSERTX(! "IPv6 port is 0!", 2);
			}
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			
			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_netnum ) == sizeof( DWORD ) );
			DBG_CASSERT( sizeof( m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 6 );
			if ( ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_netnum ) == 0 ) &&
				 ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum ) == 0 ) &&
				 ( *reinterpret_cast<const DWORD*>( &m_SocketAddress.IPXSocketAddress.sa_nodenum[ 2 ] ) == 0 ) )
			{
				fReturn = FALSE;
			}

			if (m_SocketAddress.IPXSocketAddress.sa_socket == 0)
			{
				fReturn = FALSE;
				DNASSERTX(! "IPX socket/port is 0!", 2);
			}
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			//
			// Disallow 0.0.0.0, and multicast addresses 224.0.0.0 - 239.255.255.255.
			//
			if ( ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == INADDR_ANY ) ||
				( IS_CLASSD_IPV4_ADDRESS( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr ) ) )
			{
				fReturn = FALSE;
				DNASSERTX(! "IPv4 address is 0.0.0.0 or multicast!", 2);
			}

			//
			// Prevent the broadcast address, unless caller allows it.
			//
			if ( ( ! fAllowBroadcastAddress ) &&
				( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == INADDR_BROADCAST ) )
			{
				fReturn = FALSE;
				DNASSERTX(! "IPv4 address is broadcast!", 2);
			}

			//
			// Disallow ports 0, 1900 (SSDP), 2234 (PAST), and 47624 (DPlay4).
			//
			if ( ( m_SocketAddress.IPSocketAddress.sin_port == HTONS( 0 ) ) ||
				( m_SocketAddress.IPSocketAddress.sin_port == HTONS( 1900 ) ) ||
				( m_SocketAddress.IPSocketAddress.sin_port == HTONS( 2234 ) ) ||
				( m_SocketAddress.IPSocketAddress.sin_port == HTONS( 47624 ) ) )
			{
				fReturn = FALSE;
				DNASSERTX(! "IPv4 port is 0, 1900, 2234, or 47624!", 2);
			}
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}

	return	fReturn;
}
//**********************************************************************


#ifndef DPNBUILD_NOREGISTRY
//**********************************************************************
// ------------------------------
// CSocketAddress::IsBannedAddress - determine if this is a banned address
//
// Entry:		Nothing
//
// Exit:		Boolean indicating whether this is a banned address
//				TRUE = this is a banned address
//				FALSE = this is not a banned address
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::IsBannedAddress"

BOOL	CSocketAddress::IsBannedAddress( void ) const
{
	BOOL	fReturn;


	fReturn = FALSE;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			if (g_pHashBannedIPv4Addresses != NULL)
			{
				DWORD		dwAddr;
				DWORD		dwBit;
				PVOID		pvMask;

				
				//
				// Try matching the IP address using masks.
				// Start with a 32 bit mask (meaning match the IP address exactly)
				// and gradually relax the mask until we get to a class A mask.
				// We expect the network byte order of the IP address to be the
				// opposite of host byte order.
				//
				dwAddr = m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;
				for(dwBit = 0x80000000; dwBit >= 0x00000080; dwBit >>= 1)
				{
					//
					// Only hash based on this mask if we read in at least one entry that used it.
					//
					if (dwBit & g_dwBannedIPv4Masks)
					{
						if (g_pHashBannedIPv4Addresses->Find((PVOID) ((DWORD_PTR) dwAddr), &pvMask))
						{
							DNASSERT(((DWORD) ((DWORD_PTR) pvMask)) & dwBit);
							DPFX(DPFPREP, 7, "Address %u.%u.%u.%u is banned (found as 0x%08x, bit 0x%08x).",
								m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b1,
								m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b2,
								m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b3,
								m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b4,
								dwAddr,
								dwBit);
							fReturn = TRUE;
							break;
						}
					}

					dwAddr &= ~dwBit;
				}
			}
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}

	return	fReturn;
}
//**********************************************************************
#endif // ! DPNBUILD_NOREGISTRY



//**********************************************************************
// ------------------------------
// CSocketAddress::ChangeLoopBackToLocalAddress - change loopback to a local address
//
// Entry:		Pointer to other address
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::ChangeLoopBackToLocalAddress"

void	CSocketAddress::ChangeLoopBackToLocalAddress( const CSocketAddress *const pOtherSocketAddress )
{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (pOtherSocketAddress->GetFamily())
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			if (GetFamily() == AF_INET6)
			{
				SOCKADDR_IN6	*psaddrin6;


				psaddrin6 = (SOCKADDR_IN6*) GetAddress();
				if (IN6_IS_ADDR_LOOPBACK(&psaddrin6->sin6_addr))
				{
					memcpy(&psaddrin6->sin6_addr,
							&(((SOCKADDR_IN6*) pOtherSocketAddress->GetAddress())->sin6_addr),
							sizeof(psaddrin6->sin6_addr));
					psaddrin6->sin6_scope_id = ((SOCKADDR_IN6*) pOtherSocketAddress->GetAddress())->sin6_scope_id;
					
					DPFX(DPFPREP, 2, "Changing IPv6 loopback address to:" );
					DumpSocketAddress( 2, (SOCKADDR*) psaddrin6, AF_INET6 );
				}
			}
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			DNASSERT( pOtherSocketAddress != NULL );
			//
			// there is no 'loopback' for IPX so this function doesn't do anything
			//
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
#ifndef DPNBUILD_NOIPV6
			if (GetFamily() == AF_INET)
#endif // ! DPNBUILD_NOIPV6
			{
				if ( m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr == IP_LOOPBACK_ADDRESS )
				{
					DPFX(DPFPREP, 2, "Changing IPv4 loopback address to %u.%u.%u.%u.",
						m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b1,
						m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b2,
						m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b3,
						m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_un_b.s_b4);
					m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr = pOtherSocketAddress->m_SocketAddress.IPSocketAddress.sin_addr.S_un.S_addr;
				}
			}
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// EncryptGuid - encrypt a guid
//
// Entry:		Pointer to source guid
//				Pointer to destination guid
//				Pointer to encryption key
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "EncryptGuid"

void	EncryptGuid( const GUID *const pSourceGuid,
					 GUID *const pDestinationGuid,
					 const GUID *const pEncryptionKey )
{
	const char	*pSourceBytes;
	char		*pDestinationBytes;
	const char	*pEncryptionBytes;
	DWORD_PTR	dwIndex;


	DNASSERT( pSourceGuid != NULL );
	DNASSERT( pDestinationGuid != NULL );
	DNASSERT( pEncryptionKey != NULL );

	DBG_CASSERT( sizeof( pSourceBytes ) == sizeof( pSourceGuid ) );
	pSourceBytes = reinterpret_cast<const char*>( pSourceGuid );
	
	DBG_CASSERT( sizeof( pDestinationBytes ) == sizeof( pDestinationGuid ) );
	pDestinationBytes = reinterpret_cast<char*>( pDestinationGuid );
	
	DBG_CASSERT( sizeof( pEncryptionBytes ) == sizeof( pEncryptionKey ) );
	pEncryptionBytes = reinterpret_cast<const char*>( pEncryptionKey );
	
	DBG_CASSERT( ( sizeof( *pSourceGuid ) == sizeof( *pEncryptionKey ) ) &&
				 ( sizeof( *pDestinationGuid ) == sizeof( *pEncryptionKey ) ) );
	dwIndex = sizeof( *pSourceGuid );
	while ( dwIndex != 0 )
	{
		dwIndex--;
		pDestinationBytes[ dwIndex ] = pSourceBytes[ dwIndex ] ^ pEncryptionBytes[ dwIndex ];
	}
}
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::GuidFromAddress"
void	CSocketAddress::GuidFromAddress( GUID * pOutputGuid, const SOCKADDR * pSocketAddress ) const
{
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (pSocketAddress->sa_family)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			const SOCKADDR_IN6	*pSocketAddressIPv6 = reinterpret_cast<const SOCKADDR_IN6*>( pSocketAddress );


			DNASSERT((GetFamily() == AF_INET) || (GetFamily() == AF_INET6));
			DBG_CASSERT(sizeof(pSocketAddressIPv6->sin6_addr) == sizeof(GUID));

			//
			// Hopefully the beginning of IPv6 addresses will never look like an IPv4
			// socket family so our unpacking routine won't get confused.
			//
			DNASSERT(((SOCKADDR*) (&pSocketAddressIPv6->sin6_addr))->sa_family != AF_INET);

			//
			// Even though IPv6 addresses are already 128 bits long and fill an entire
			// entire GUID, we need to somehow pack the scope ID for link local and
			// site local addresses into the GUID as well.  We do this by storing the
			// scope ID in bytes 3-6.  This is because the prefix identifier for link local
			// addresses is FE80::/64, and for site local addresses is FEC0::/48,
			// leaving us 38 bits of what should always be zeros after the 10 bit prefix
			// headers.  We round to 16 to get to the WORD boundary, and therefore
			// have a handy 32 bits left.
			//
			if ((IN6_IS_ADDR_LINKLOCAL(&pSocketAddressIPv6->sin6_addr)) ||
				(IN6_IS_ADDR_SITELOCAL(&pSocketAddressIPv6->sin6_addr)))
			{
				GUID	guidTemp;
				WORD *	pawSrcAddr;
				WORD *	pawDstAddr;


				memcpy(&guidTemp, &pSocketAddressIPv6->sin6_addr, sizeof(GUID));

				//
				// Assert that the scope is not 0 and that bits 17-48 really are zero.
				// Then copy the scope ID.
				// The destination bits are WORD, but not DWORD aligned.
				//
				DNASSERT(pSocketAddressIPv6->sin6_scope_id != 0);
				pawSrcAddr = (WORD*) (&pSocketAddressIPv6->sin6_scope_id);
				pawDstAddr = (WORD*) (&guidTemp);
				DBG_CASSERT(sizeof(pSocketAddressIPv6->sin6_scope_id) == 4);
				DNASSERT((pawDstAddr[1] == 0) && (pawDstAddr[2] == 0));
				pawDstAddr[1] = pawSrcAddr[0];
				pawDstAddr[2] = pawSrcAddr[1];
				
				EncryptGuid( &guidTemp, pOutputGuid, &g_IPSPEncryptionGuid );
			}
			else
			{
				EncryptGuid( (GUID*) (&pSocketAddressIPv6->sin6_addr), pOutputGuid, &g_IPSPEncryptionGuid );
			}
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			const SOCKADDR_IPX	*pSocketAddressIPX = reinterpret_cast<const SOCKADDR_IPX*>( pSocketAddress );


			DNASSERT(GetFamily() == AF_IPX);
			memcpy( pOutputGuid, pSocketAddressIPX, sizeof( *pSocketAddressIPX ) );
			memset( &( reinterpret_cast<BYTE*>( pOutputGuid )[ sizeof( *pSocketAddressIPX ) ] ), 0, ( sizeof( *pOutputGuid ) - sizeof( *pSocketAddressIPX ) ) );
			EncryptGuid( pOutputGuid, pOutputGuid, &g_IPXSPEncryptionGuid );	
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			const SOCKADDR_IN	*pSocketAddressIP = reinterpret_cast<const SOCKADDR_IN*>( pSocketAddress );


			DNASSERT(GetFamily() == AF_INET);
			memcpy( pOutputGuid, pSocketAddressIP, ( sizeof( *pOutputGuid ) - sizeof( pSocketAddressIP->sin_zero ) ) );
			memset( &( reinterpret_cast<BYTE*>( pOutputGuid )[ OFFSETOF( SOCKADDR_IN, sin_zero ) ] ), 0, sizeof( pSocketAddressIP->sin_zero ) );
			EncryptGuid( pOutputGuid, pOutputGuid, &g_IPSPEncryptionGuid );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::PoolAllocFunction"
BOOL	CSocketAddress::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CSocketAddress* pAddress = (CSocketAddress*)pvItem;


	// Base class
	pAddress->m_Sig[0] = 'S';
	pAddress->m_Sig[1] = 'P';
	pAddress->m_Sig[2] = 'A';
	pAddress->m_Sig[3] = 'D';

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::PoolGetFunction"
void	CSocketAddress::PoolGetFunction( void* pvItem, void* pvContext )
{
	CSocketAddress* pAddress = (CSocketAddress*)pvItem;


	//
	// The context is the socket address type if IPv6 and/or IPX are available in
	// this build.  If neither are available, it will be NULL, but SetFamilyProtocolAndSize
	// should ignore the value.
	//
	pAddress->SetFamilyProtocolAndSize((short)(DWORD_PTR)pvContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CSocketAddress::PoolReturnFunction"
void	CSocketAddress::PoolReturnFunction( void* pvItem )
{
#ifdef DBG
	const CSocketAddress*		pAddress = (CSocketAddress*)pvItem;

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	switch (pAddress->m_SocketAddress.SocketAddress.sa_family)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
#ifndef DPNBUILD_NOIPV6
		case AF_INET6:
		{
			DNASSERT( pAddress->m_iSocketAddressSize == sizeof( pAddress->m_SocketAddress.IPv6SocketAddress ) );
			DNASSERT( pAddress->m_SocketAddress.IPSocketAddress.sin_family == AF_INET6 );
			DNASSERT( pAddress->m_iSocketProtocol == IPPROTO_UDP );
			break;
		}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
		case AF_IPX:
		{
			DNASSERT( pAddress->m_iSocketAddressSize == sizeof( pAddress->m_SocketAddress.IPXSocketAddress ) );
			DNASSERT( pAddress->m_SocketAddress.IPXSocketAddress.sa_family == AF_IPX );
			DNASSERT( pAddress->m_iSocketProtocol == NSPROTO_IPX );
			break;
		}
#endif // ! DPNBUILD_NOIPX

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
		default:
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		{
			DNASSERT( pAddress->m_iSocketAddressSize == sizeof( pAddress->m_SocketAddress.IPSocketAddress ) );
			DNASSERT( pAddress->m_SocketAddress.IPSocketAddress.sin_family == AF_INET );
			DNASSERT( pAddress->m_iSocketProtocol == IPPROTO_UDP );
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
			break;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		}
	}
#endif // DBG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\threadpool.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		ThreadPool.cpp
 *  Content:	main job thread pool
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/1998	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"





//**********************************************************************
// Constant definitions
//**********************************************************************

//
// select polling period and duration for I/O (milliseconds)
//
static const DWORD	g_dwSelectTimePeriod = 4;	// wait for jobs for 4 ms, then wait for I/O
static const DWORD	g_dwSelectTimeSlice = 0;	// wait for I/O for 0 ms, then wait for jobs


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

#ifndef DPNBUILD_NOSPUI
//
// structure passed to dialog threads
//
typedef	struct	_DIALOG_THREAD_PARAM
{
	DIALOG_FUNCTION	*pDialogFunction;
	void			*pContext;
	CThreadPool		*pThisThreadPool;
} DIALOG_THREAD_PARAM;
#endif // !DPNBUILD_NOSPUI

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************
DWORD WINAPI DPNBlockingJobThreadProc(PVOID pvParameter);



//**********************************************************************
// ------------------------------
// CThreadPool::PoolAllocFunction
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PoolAllocFunction"

BOOL	CThreadPool::PoolAllocFunction( void* pvItem, void* pvContext )
{
	CThreadPool* pThreadPool = (CThreadPool*)pvItem;

	pThreadPool->m_iRefCount = 0;
	pThreadPool->m_fAllowThreadCountReduction = FALSE;
#ifndef DPNBUILD_ONLYONETHREAD
	pThreadPool->m_iIntendedThreadCount = 0;
#endif // ! DPNBUILD_ONLYONETHREAD

#ifndef DPNBUILD_ONLYWINSOCK2
	pThreadPool->m_uReservedSocketCount = 0;
	memset( &pThreadPool->m_SocketSet, 0x00, sizeof( pThreadPool->m_SocketSet ) );
	memset( &pThreadPool->m_pSocketPorts, 0x00, sizeof( pThreadPool->m_pSocketPorts ) );
	pThreadPool->m_pvTimerDataWinsock1IO = NULL;
	pThreadPool->m_uiTimerUniqueWinsock1IO = 0;
	pThreadPool->m_fCancelWinsock1IO = FALSE;
#endif // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NONATHELP
	pThreadPool->m_fNATHelpLoaded = FALSE;
	pThreadPool->m_fNATHelpTimerJobSubmitted = FALSE;
	pThreadPool->m_dwNATHelpUpdateThreadID = 0;
#endif // DPNBUILD_NONATHELP

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
	pThreadPool->m_fMadcapLoaded = FALSE;
#endif // WINNT and not DPNBUILD_NOMULTICAST


	pThreadPool->m_Sig[0] = 'T';
	pThreadPool->m_Sig[1] = 'H';
	pThreadPool->m_Sig[2] = 'P';
	pThreadPool->m_Sig[3] = 'L';
	
	pThreadPool->m_TimerJobList.Initialize();

#ifndef DPNBUILD_ONLYONETHREAD
	pThreadPool->m_blBlockingJobQueue.Initialize();
	pThreadPool->m_hBlockingJobThread = NULL;
	pThreadPool->m_hBlockingJobEvent = NULL;
#endif // ! DPNBUILD_ONLYONETHREAD

	return TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::PoolDellocFunction
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PoolDeallocFunction"

void	CThreadPool::PoolDeallocFunction( void* pvItem )
{
#ifdef DBG
	const CThreadPool* pThreadPool = (CThreadPool*)pvItem;

#ifndef DPNBUILD_ONLYWINSOCK2
	DNASSERT( pThreadPool->m_uReservedSocketCount == 0 );
	DNASSERT( pThreadPool->m_pvTimerDataWinsock1IO == NULL );
	DNASSERT( ! pThreadPool->m_fCancelWinsock1IO );
#endif // ! DPNBUILD_ONLYWINSOCK2

	DNASSERT( pThreadPool->m_iRefCount == 0 );
#ifndef DPNBUILD_NONATHELP
	DNASSERT( pThreadPool->m_fNATHelpLoaded == FALSE );
	DNASSERT( pThreadPool->m_fNATHelpTimerJobSubmitted == FALSE );
	DNASSERT( pThreadPool->m_dwNATHelpUpdateThreadID == 0 );
#endif // DPNBUILD_NONATHELP
#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
	DNASSERT( pThreadPool->m_fMadcapLoaded == FALSE );
#endif // WINNT and not DPNBUILD_NOMULTICAST
	DNASSERT( pThreadPool->m_TimerJobList.IsEmpty() != FALSE );

#ifndef DPNBUILD_ONLYONETHREAD
	DNASSERT( pThreadPool->m_blBlockingJobQueue.IsEmpty() );
	DNASSERT( pThreadPool->m_hBlockingJobThread == NULL );
	DNASSERT( pThreadPool->m_hBlockingJobEvent == NULL );
#endif // ! DPNBUILD_ONLYONETHREAD
#endif // DBG
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::Initialize - initialize work threads
//
// Entry:		Nothing
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Initialize"

HRESULT	CThreadPool::Initialize( void )
{
	HRESULT		hr;
	BOOL		fInittedLock = FALSE;
	BOOL		fInittedTimerDataLock = FALSE;
#ifndef DPNBUILD_ONLYONETHREAD
	BOOL		fInittedBlockingJobLock = FALSE;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, 4, "(0x%p) Enter", this);

	//
	// initialize
	//
	hr = DPN_OK;

	//
	// initialize critical sections
	//
	if ( DNInitializeCriticalSection( &m_Lock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_Lock, 0 );
	DebugSetCriticalSectionGroup( &m_Lock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes

	fInittedLock = TRUE;


	//
	// Create the thread pool work interface
	//
#ifdef DPNBUILD_LIBINTERFACE
#if ((defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	DPTPCF_GetObject(reinterpret_cast<void**>(&m_pDPThreadPoolWork));
	hr = S_OK;
#else // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
	hr = DPTPCF_CreateObject(reinterpret_cast<void**>(&m_pDPThreadPoolWork));
#endif // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#else // ! DPNBUILD_LIBINTERFACE
	hr = COM_CoCreateInstance( CLSID_DirectPlay8ThreadPool,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IDirectPlay8ThreadPoolWork,
						   reinterpret_cast<void**>( &m_pDPThreadPoolWork ),
						   FALSE );
#endif // ! DPNBUILD_LIBINTERFACE
	if ( hr != S_OK )
	{
		DPFX(DPFPREP, 0, " Failed to create thread pool work interface (err = 0x%lx)!", hr);
		goto Failure;
	}


	if ( DNInitializeCriticalSection( &m_TimerDataLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_TimerDataLock, 1 );
	DebugSetCriticalSectionGroup( &m_TimerDataLock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes
	fInittedTimerDataLock = TRUE;


	DNASSERT( m_fAllowThreadCountReduction == FALSE );
	m_fAllowThreadCountReduction = TRUE;


#ifndef DPNBUILD_ONLYONETHREAD
	if ( DNInitializeCriticalSection( &m_csBlockingJobLock ) == FALSE )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount( &m_csBlockingJobLock, 0 );
	DebugSetCriticalSectionGroup( &m_csBlockingJobLock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes
	fInittedBlockingJobLock = TRUE;

	DPFX(DPFPREP, 7, "SetIntendedThreadCount %i", g_iThreadCount);
	SetIntendedThreadCount( g_iThreadCount );
#endif // ! DPNBUILD_ONLYONETHREAD


Exit:

	DPFX(DPFPREP, 4, "(0x%p) Return [0x%lx]", this, hr);

	return	hr;

Failure:

#ifndef DPNBUILD_ONLYONETHREAD
	if (fInittedBlockingJobLock)
	{
		DNDeleteCriticalSection(&m_csBlockingJobLock);
		fInittedBlockingJobLock = FALSE;
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	if (fInittedTimerDataLock)
	{
		DNDeleteCriticalSection(&m_TimerDataLock);
		fInittedTimerDataLock = FALSE;
	}

	if (m_pDPThreadPoolWork != NULL)
	{
		IDirectPlay8ThreadPoolWork_Release(m_pDPThreadPoolWork);
		m_pDPThreadPoolWork = NULL;
	}

	if (fInittedLock)
	{
		DNDeleteCriticalSection(&m_Lock);
		fInittedLock = FALSE;
	}

	goto Exit;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CThreadPool::Deinitialize - destroy work threads
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::Deinitialize"

void	CThreadPool::Deinitialize( void )
{
	DPFX(DPFPREP, 4, "(0x%p) Enter", this );


#ifndef DPNBUILD_ONLYWINSOCK2
	//
	// Keep trying to cancel the Winsock1 timer.  It may fail because it's in the
	// process of actively executing, but eventually we will catch it while only
	// the timer is active.
	//
	Lock();
	if (m_pvTimerDataWinsock1IO != NULL)
	{
		HRESULT		hr;
		DWORD		dwInterval;


		DPFX(DPFPREP, 1, "Cancelling Winsock 1 I/O timer.");
		dwInterval = 10;
		do
		{
			hr = IDirectPlay8ThreadPoolWork_CancelTimer(m_pDPThreadPoolWork,
														m_pvTimerDataWinsock1IO,
														m_uiTimerUniqueWinsock1IO,
														0);
			if (hr != DPN_OK)
			{
				Unlock();
				IDirectPlay8ThreadPoolWork_SleepWhileWorking(m_pDPThreadPoolWork,
															dwInterval,
															0);
				dwInterval += 5;	// next time wait a bit longer
				DNASSERT(dwInterval < 600);
				Lock();
			}
			else
			{
				m_pvTimerDataWinsock1IO = NULL;
			}
		}
		while (m_pvTimerDataWinsock1IO != NULL);
	}
	Unlock();
#endif // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_NONATHELP
	//
	// Stop submitting new NAT help refresh jobs.
	//
	if ( IsNATHelpTimerJobSubmitted() )
	{
		//
		// Try to cancel the job.  It could fail if the timer is in the
		// process of firing right now.  If it is firing, keep looping
		// until we see that the timer has noticed cancellation.
		//
		DPFX(DPFPREP, 5, "Cancelling NAT Help refresh timer job.");
		if (! StopTimerJob( this, DPNERR_USERCANCEL ))
		{
			DWORD	dwInterval;

			
			DPFX(DPFPREP, 4, "Couldn't cancel NAT Help refresh timer job, waiting for completion.");
			dwInterval = 10;
			while (*((volatile BOOL *) (&m_fNATHelpTimerJobSubmitted)))
			{
				IDirectPlay8ThreadPoolWork_SleepWhileWorking(m_pDPThreadPoolWork,
															dwInterval,
															0);
				dwInterval += 5;	// next time wait a bit longer
				if (dwInterval > 500)
				{
					dwInterval = 500;
				}
			}
		}
		else
		{
			DNASSERT(! m_fNATHelpTimerJobSubmitted);
		}
	}
#endif // DPNBUILD_NONATHELP

#ifndef DPNBUILD_ONLYONETHREAD
	//
	// Stop the blocking job thread, if it was running.
	//
	if (m_hBlockingJobThread != NULL)
	{
		HRESULT		hr;
		
		
		//
		// Queue an item with a NULL callback to signal that the thread
		// should quit.
		//
		hr = SubmitBlockingJob(NULL, NULL);
		DNASSERT(hr == DPN_OK);

		//
		// Wait for the thread to complete.
		//
		hr = IDirectPlay8ThreadPoolWork_WaitWhileWorking(m_pDPThreadPoolWork,
														HANDLE_FROM_DNHANDLE(m_hBlockingJobThread),
														0);
		DNASSERT(hr == DPN_OK);
		DNASSERT(m_blBlockingJobQueue.IsEmpty());

		DNCloseHandle(m_hBlockingJobThread);
		m_hBlockingJobThread = NULL;

		DNCloseHandle(m_hBlockingJobEvent);
		m_hBlockingJobEvent = NULL;
	}
#endif // ! DPNBUILD_ONLYONETHREAD

#ifndef DPNBUILD_NONATHELP
	//
	// The refresh timer and blocking jobs should have finished earlier,
	// it should be safe to unload NAT help now (if we even loaded it).
	//
	if ( IsNATHelpLoaded() )
	{
		UnloadNATHelp();
		m_fNATHelpLoaded = FALSE;
	}
#endif // DPNBUILD_NONATHELP

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
	//
	// Unload MADCAP, if we had loaded it.
	//
	if ( IsMadcapLoaded() )
	{
		UnloadMadcap();
		m_fMadcapLoaded = FALSE;
	}
#endif // WINNT and not DPNBUILD_NOMULTICAST

	if ( m_pDPThreadPoolWork != NULL )
	{
		IDirectPlay8ThreadPoolWork_Release(m_pDPThreadPoolWork);
		m_pDPThreadPoolWork = NULL;
	}
	
	m_fAllowThreadCountReduction = FALSE;

	DNDeleteCriticalSection( &m_TimerDataLock );
	DNDeleteCriticalSection( &m_Lock );

#ifndef DPNBUILD_ONLYONETHREAD
	DNDeleteCriticalSection(&m_csBlockingJobLock);
#endif // ! DPNBUILD_ONLYONETHREAD

	DPFX(DPFPREP, 4, "(0x%p) Leave", this );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GetNewReadIOData - get new read request from pool
//
// Entry:		Pointer to context
//
// Exit:		Pointer to new read request
//				NULL = out of memory
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetNewReadIOData"

#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
CReadIOData	*CThreadPool::GetNewReadIOData( READ_IO_DATA_POOL_CONTEXT *const pContext, const BOOL fNeedOverlapped )
#else // DPNBUILD_NOWINSOCK2 or DPNBUILD_ONLYWINSOCK2
CReadIOData	*CThreadPool::GetNewReadIOData( READ_IO_DATA_POOL_CONTEXT *const pContext )
#endif // DPNBUILD_NOWINSOCK2 or DPNBUILD_ONLYWINSOCK2
{
	CReadIOData *	pTempReadData;
#ifndef DPNBUILD_NOWINSOCK2
	OVERLAPPED *	pOverlapped;
#endif // ! DPNBUILD_NOWINSOCK2


	DNASSERT( pContext != NULL );

	//
	// initialize
	//
	pTempReadData = NULL;
	pContext->pThreadPool = this;

	pTempReadData = (CReadIOData*)g_ReadIODataPool.Get( pContext );
	if ( pTempReadData == NULL )
	{
		DPFX(DPFPREP, 0, "Failed to get new ReadIOData from pool!" );
		goto Failure;
	}

	//
	// we have data, immediately add a reference to it
	//
	pTempReadData->AddRef();

	DNASSERT( pTempReadData->m_pSourceSocketAddress != NULL );

#ifndef DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_ONLYWINSOCK2
	if (! fNeedOverlapped)
	{
		DNASSERT( pTempReadData->GetOverlapped() == NULL );
	}
	else
#endif // ! DPNBUILD_ONLYWINSOCK2
	{
		HRESULT		hr;


#ifdef DPNBUILD_ONLYONEPROCESSOR
		hr = IDirectPlay8ThreadPoolWork_CreateOverlapped( m_pDPThreadPoolWork,
														0,
														CSocketPort::Winsock2ReceiveComplete,
														pTempReadData,
														&pOverlapped,
														0 );
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't create overlapped structure (err = 0x%lx)!", hr);
			goto Failure;
		}
#else // ! DPNBUILD_ONLYONEPROCESSOR
		hr = IDirectPlay8ThreadPoolWork_CreateOverlapped( m_pDPThreadPoolWork,
														pContext->dwCPU,
														CSocketPort::Winsock2ReceiveComplete,
														pTempReadData,
														&pOverlapped,
														0 );
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't create overlapped structure for CPU %i (err = 0x%lx)!",
				pContext->dwCPU, hr);
			goto Failure;
		}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

		pTempReadData->SetOverlapped( pOverlapped );
	}
#endif // ! DPNBUILD_NOWINSOCK2


Exit:

	return pTempReadData;

Failure:
	if ( pTempReadData != NULL )
	{
		pTempReadData->DecRef();
		pTempReadData = NULL;
	}

	goto Exit;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// CThreadPool::ReturnReadIOData - return read data item to pool
//
// Entry:		Pointer to read data
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ReturnReadIOData"

void	CThreadPool::ReturnReadIOData( CReadIOData *const pReadData )
{
	DNASSERT( pReadData != NULL );
	DNASSERT( pReadData->m_pSourceSocketAddress != NULL );

	g_ReadIODataPool.Release( pReadData );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitTimerJob - add a timer job to the timer list
//
// Entry:		Whether to perform immediately or not
//				Retry count
//				Boolean indicating that we retry forever
//				Retry interval
//				Boolean indicating that we wait forever
//				Idle wait interval
//				Pointer to callback when event fires
//				Pointer to callback when event complete
//				User context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitTimerJob"

#ifdef DPNBUILD_ONLYONEPROCESSOR
HRESULT	CThreadPool::SubmitTimerJob( const BOOL fPerformImmediately,
									const UINT_PTR uRetryCount,
									const BOOL fRetryForever,
									const DWORD dwRetryInterval,
									const BOOL fIdleWaitForever,
									const DWORD dwIdleTimeout,
									TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
									TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
									void *const pContext )
#else // ! DPNBUILD_ONLYONEPROCESSOR
HRESULT	CThreadPool::SubmitTimerJob( const DWORD dwCPU,
									const BOOL fPerformImmediately,
									const UINT_PTR uRetryCount,
									const BOOL fRetryForever,
									const DWORD dwRetryInterval,
									const BOOL fIdleWaitForever,
									const DWORD dwIdleTimeout,
									TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
									TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
									void *const pContext )
#endif // ! DPNBUILD_ONLYONEPROCESSOR
{
	HRESULT					hr = DPN_OK;
	TIMER_OPERATION_ENTRY	*pEntry = NULL;
	BOOL					fTimerDataLocked = FALSE;
#ifdef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPU = -1;
#endif // DPNBUILD_ONLYONEPROCESSOR


	DNASSERT( uRetryCount != 0 );
	DNASSERT( pTimerCallbackFunction != NULL );
	DNASSERT( pTimerCompleteFunction != NULL );
	DNASSERT( pContext != NULL );				// must be non-NULL because it's the lookup key to remove job


	//
	// allocate new enum entry
	//
	pEntry = static_cast<TIMER_OPERATION_ENTRY*>( g_TimerEntryPool.Get() );
	if ( pEntry == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot allocate memory to add to timer list!" );
		goto Failure;
	}
	DNASSERT( pEntry->pContext == NULL );


	DPFX(DPFPREP, 7, "Created timer entry 0x%p (CPU %i, context 0x%p, immed. %i, tries %u, forever %i, interval %u, timeout %u, forever = %i).",
		pEntry, dwCPU, pContext, fPerformImmediately, uRetryCount, fRetryForever, dwRetryInterval, dwIdleTimeout, fIdleWaitForever);

	//
	// build timer entry block
	//
	pEntry->pContext = pContext;
	pEntry->uRetryCount = uRetryCount;
	pEntry->fRetryForever = fRetryForever;
	pEntry->dwRetryInterval = dwRetryInterval;
	pEntry->dwIdleTimeout = dwIdleTimeout;
	pEntry->fIdleWaitForever = fIdleWaitForever;
	pEntry->pTimerCallback = pTimerCallbackFunction;
	pEntry->pTimerComplete = pTimerCompleteFunction;
	pEntry->pThreadPool = this;
	pEntry->fCancelling = FALSE;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	pEntry->dwCPU = dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	pEntry->dwNextRetryTime = GETTIMESTAMP();
	if (fPerformImmediately)
	{
		pEntry->dwNextRetryTime -= 1; // longest possible time, so that the time has already passed
	}
	else
	{
		pEntry->dwNextRetryTime += dwRetryInterval;
	}

	LockTimerData();
	fTimerDataLocked = TRUE;

	pEntry->pvTimerData = NULL;
	pEntry->uiTimerUnique = 0;
	if (fPerformImmediately)
	{
		hr = IDirectPlay8ThreadPoolWork_QueueWorkItem(m_pDPThreadPoolWork,
													dwCPU,								// CPU
													CThreadPool::GenericTimerCallback,	// callback
													pEntry,								// user context
													0);									// flags
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Problem queueing immediate work item!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
	else
	{
		hr = IDirectPlay8ThreadPoolWork_ScheduleTimer(m_pDPThreadPoolWork,
													dwCPU,								// CPU
													dwRetryInterval,					// delay
													CThreadPool::GenericTimerCallback,	// callback
													pEntry,								// user context
													&pEntry->pvTimerData,				// timer data (returned)
													&pEntry->uiTimerUnique,				// timer unique(returned)
													0);									// flags
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Problem scheduling timer!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}


	//
	// debug block to check for duplicate contexts
	//
	DEBUG_ONLY(
				{
					CBilink	*pTempLink;


					pTempLink = m_TimerJobList.GetNext();
					while ( pTempLink != &m_TimerJobList )
					{
						TIMER_OPERATION_ENTRY	*pTempTimerEntry;
					
						
						pTempTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempLink );
						DNASSERT( pTempTimerEntry->pContext != pContext );
						pTempLink = pTempLink->GetNext();
					}
				}
			);

	//
	// link to rest of list
	//
	pEntry->Linkage.InsertAfter( &m_TimerJobList );

	UnlockTimerData();
	fTimerDataLocked = FALSE;


Exit:

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem with SubmitTimerJob" );
		DisplayDNError( 0, hr );
	}

	return	hr;


Failure:

	if ( pEntry != NULL )
	{
		g_TimerEntryPool.Release( pEntry );
		DEBUG_ONLY( pEntry = NULL );
	}

	if ( fTimerDataLocked != FALSE )
	{
		UnlockTimerData();
		fTimerDataLocked = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::StopTimerJob - remove timer job from list
//
// Entry:		Pointer to job context (these MUST be unique for jobs)
//				Command result
//
// Exit:		Boolean indicating whether a job was stopped or not
//
// Note:	This function is for the forced removal of a job from the timed job
//			list.  It is assumed that the caller of this function will clean
//			up any messes.
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::StopTimerJob"

BOOL	CThreadPool::StopTimerJob( void *const pContext, const HRESULT hCommandResult )
{
	BOOL						fComplete = FALSE;
	CBilink *					pTempEntry;
	TIMER_OPERATION_ENTRY *		pTimerEntry = NULL;


	DNASSERT( pContext != NULL );

	DPFX(DPFPREP, 8, "Parameters (0x%p, 0x%lx)", pContext, hCommandResult);

	
	//
	// initialize
	//
	LockTimerData();

	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			HRESULT		hr;


			//
			// Mark the entry as cancelling.
			//
			pTimerEntry->fCancelling = TRUE;


			//
			// Make sure an actual timer has been submitted.
			//
			if (pTimerEntry->pvTimerData != NULL)
			{
				//
				// Attempt to cancel the timer.  If it succeeds, we're cool.
				//
				hr = IDirectPlay8ThreadPoolWork_CancelTimer(m_pDPThreadPoolWork,
															pTimerEntry->pvTimerData,
															pTimerEntry->uiTimerUnique,
															0);
			}
			else
			{
				if ((! pTimerEntry->fIdleWaitForever) ||
					(pTimerEntry->uRetryCount > 0))
				{
					//
					// Timer hasn't been submitted yet, the completion function should
					// notice that it is now cancelling.
					//
					DPFX(DPFPREP, 1, "Timer for entry 0x%p not submitted yet, reporting that timer will still fire.",
						pTimerEntry);
					hr = DPNERR_CANNOTCANCEL;
				}
				else
				{
					//
					// No other timer will ever be submitted because the job is now
					// waiting forever.
					//
					DPFX(DPFPREP, 1, "Entry 0x%p was idling forever, cancelling.",
						pTimerEntry);
					hr = DPN_OK;
				}
			}

			if (hr != DPN_OK)
			{
				//
				// The processing function is still going to fire.  It should notice
				// that it needs to complete.
				//
			}
			else
			{
				//
				// remove this link from the list
				//
				pTimerEntry->Linkage.RemoveFromList();

				fComplete = TRUE;
			}

			//
			// terminate loop
			//
			break;
		}

		pTempEntry = pTempEntry->GetNext();
	}

	UnlockTimerData();

	//
 	// tell owner that the job is complete and return the job to the pool
 	// outside of the lock
 	//
	if (fComplete)
	{
		DPFX(DPFPREP, 8, "Found cancellable timer entry 0x%p (context 0x%p), completing with result 0x%lx.",
			pTimerEntry, pTimerEntry->pContext, hCommandResult);

		pTimerEntry->pTimerComplete( hCommandResult, pTimerEntry->pContext );

		//
		// Relock the timer list so we can safely put items back in the pool,
		//
		LockTimerData();
		
		g_TimerEntryPool.Release( pTimerEntry );
		
		UnlockTimerData();
	}


	DPFX(DPFPREP, 8, "Returning [%i]", fComplete);

	return fComplete;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ModifyTimerJobNextRetryTime - update a timer job's next retry time
//
// Entry:		Pointer to job context (these MUST be unique for jobs)
//				New time for next retry
//
// Exit:		Boolean indicating whether a job was found & updated or not
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ModifyTimerJobNextRetryTime"

BOOL	CThreadPool::ModifyTimerJobNextRetryTime( void *const pContext,
												DWORD const dwNextRetryTime)
{
	BOOL						fFound;
	CBilink *					pTempEntry;
	TIMER_OPERATION_ENTRY *		pTimerEntry;
	INT_PTR						iResult;



	DNASSERT( pContext != NULL );

	DPFX(DPFPREP, 7, "Parameters (0x%p, %u)", pContext, dwNextRetryTime);

	
	//
	// initialize
	//
	fFound = FALSE;

	
	LockTimerData();


	pTempEntry = m_TimerJobList.GetNext();
	while ( pTempEntry != &m_TimerJobList )
	{
		pTimerEntry = TIMER_OPERATION_ENTRY::TimerOperationFromLinkage( pTempEntry );
		if ( pTimerEntry->pContext == pContext )
		{
			iResult = (int) (pTimerEntry->dwNextRetryTime - dwNextRetryTime);
			if (iResult != 0)
			{
				HRESULT		hr;
				DWORD		dwNextRetryTimeDifference;
				DWORD		dwNewRetryInterval;


				if (iResult < 0)
				{
					//
					// Next time to fire is now later.
					//

					dwNextRetryTimeDifference = dwNextRetryTime - pTimerEntry->dwNextRetryTime;
					dwNewRetryInterval = pTimerEntry->dwRetryInterval + dwNextRetryTimeDifference;

					DPFX(DPFPREP, 7, "Timer 0x%p next retry time delayed by %u ms from offset %u to offset %u, modifying interval from %u to %u.",
						pTimerEntry,
						dwNextRetryTimeDifference,
						pTimerEntry->dwNextRetryTime,
						dwNextRetryTime,
						pTimerEntry->dwRetryInterval,
						dwNewRetryInterval);
				}
				else
				{
					//
					// Next time to fire is now earlier.
					//

					dwNextRetryTimeDifference = pTimerEntry->dwNextRetryTime - dwNextRetryTime;
					dwNewRetryInterval = pTimerEntry->dwRetryInterval - dwNextRetryTimeDifference;

					DPFX(DPFPREP, 7, "Timer 0x%p next retry time moved up by %u ms from offset %u to offset %u, modifying interval from %u to %u.",
						pTimerEntry,
						dwNextRetryTimeDifference,
						pTimerEntry->dwNextRetryTime,
						dwNextRetryTime,
						pTimerEntry->dwRetryInterval,
						dwNewRetryInterval);
				}

				//
				// Force the timer to expire right away if the calculations returned a really
				// long delay.
				//
				if (dwNewRetryInterval > 0x80000000)
				{
					DPFX(DPFPREP, 1, "Timer 0x%p delay 0x%x/%u (next retry time %u) being set to 0.",
						pTimerEntry, dwNewRetryInterval, dwNewRetryInterval, dwNextRetryTime);
					pTimerEntry->dwRetryInterval = 0;
					pTimerEntry->dwNextRetryTime = GETTIMESTAMP();
				}
				else
				{
					pTimerEntry->dwRetryInterval = dwNewRetryInterval;
					pTimerEntry->dwNextRetryTime = dwNextRetryTime;
				}


				//
				// Attempt to cancel the existing timer.
				//
				hr = IDirectPlay8ThreadPoolWork_CancelTimer(m_pDPThreadPoolWork,
															pTimerEntry->pvTimerData,
															pTimerEntry->uiTimerUnique,
															0);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 1, "Couldn't cancel existing timer for entry 0x%p (err = 0x%lx), modifying retry timer only.",
						pTimerEntry, hr);
				}
				else
				{
					//
					// Restart the timer.
					//
#ifdef DPNBUILD_ONLYONEPROCESSOR
					hr = IDirectPlay8ThreadPoolWork_ScheduleTimer(m_pDPThreadPoolWork,
																-1,										// pick any CPU
																dwNewRetryInterval,						// delay
																CThreadPool::GenericTimerCallback,		// callback
																pTimerEntry,							// user context
																&pTimerEntry->pvTimerData,				// timer data (returned)
																&pTimerEntry->uiTimerUnique,			// timer unique (returned)
																0);										// flags
#else // ! DPNBUILD_ONLYONEPROCESSOR
					hr = IDirectPlay8ThreadPoolWork_ScheduleTimer(m_pDPThreadPoolWork,
																pTimerEntry->dwCPU,					// use same CPU as before
																dwNewRetryInterval,						// delay
																CThreadPool::GenericTimerCallback,		// callback
																pTimerEntry,							// user context
																&pTimerEntry->pvTimerData,				// timer data (returned)
																&pTimerEntry->uiTimerUnique,			// timer unique (returned)
																0);										// flags
#endif // ! DPNBUILD_ONLYONEPROCESSOR
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't reschedule timer for entry 0x%p (err = 0x%lx)!",
							pTimerEntry, hr);

						pTimerEntry->pvTimerData = NULL;

						//
						// Drop lock while we complete timer.
						//
						UnlockTimerData();

						pTimerEntry->pTimerComplete(hr, pTimerEntry->pContext);
						g_TimerEntryPool.Release(pTimerEntry);

						LockTimerData();

						//
						// Drop through...
						//
					}
				}
			}
			else
			{
				//
				// The intervals are the same, no change necessary.
				//

				DPFX(DPFPREP, 7, "Timer 0x%p next retry time was unchanged (offset %u), not changing interval from %u.",
					pTimerEntry,
					pTimerEntry->dwNextRetryTime,
					pTimerEntry->dwRetryInterval);
			}

			
			fFound = TRUE;

			
			//
			// Terminate loop
			//
			break;
		}

		pTempEntry = pTempEntry->GetNext();
	}


	UnlockTimerData();


	DPFX(DPFPREP, 7, "Returning [%i]", fFound);

	return fFound;
}
//**********************************************************************



#ifndef DPNBUILD_ONLYONETHREAD

//**********************************************************************
// ------------------------------
// CThreadPool::SubmitBlockingJob - submits a blocking job to the be processed by the blockable thread
//								duplicate commands (matching callback and context) are disallowed
//
// Entry:		Pointer to callback that executes blocking job
//				User context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitBlockingJob"

HRESULT	CThreadPool::SubmitBlockingJob( BLOCKING_JOB_CALLBACK *const pfnBlockingJobCallback,
									void *const pvContext )
{
	HRESULT			hr;
	BLOCKING_JOB *	pJob = NULL;
	DWORD			dwTemp;
	BOOL			fQueueLocked = FALSE;
	CBilink *		pBilink;
	BLOCKING_JOB *	pExistingJob;


	//
	// allocate new enum entry
	//
	pJob = (BLOCKING_JOB*) g_BlockingJobPool.Get();
	if (pJob == NULL)
	{
		DPFX(DPFPREP, 0, "Cannot allocate memory for blocking job!" );
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}


	DPFX(DPFPREP, 6, "Created blocking job 0x%p (callback 0x%p, context 0x%p).",
		pJob, pfnBlockingJobCallback, pvContext);

	pJob->Linkage.Initialize();
	pJob->pfnBlockingJobCallback = pfnBlockingJobCallback;
	pJob->pvContext = pvContext;


	DNEnterCriticalSection(&m_csBlockingJobLock);
	fQueueLocked = TRUE;

	//
	// Start the blocking job thread, if we haven't already.
	//
	if (m_hBlockingJobThread == NULL)
	{
		m_hBlockingJobEvent = DNCreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hBlockingJobEvent == NULL)
		{
#ifdef DBG
			dwTemp = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't create blocking job event (err = %u)!", dwTemp);
#endif // DBG
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		m_hBlockingJobThread = DNCreateThread(NULL,
											0,
											DPNBlockingJobThreadProc,
											this,
											0,
											&dwTemp);
		if (m_hBlockingJobThread == NULL)
		{
#ifdef DBG
			dwTemp = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't create blocking job thread (err = %u)!", dwTemp);
#endif // DBG
			DNCloseHandle(m_hBlockingJobEvent);
			m_hBlockingJobEvent = NULL;
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}

		DNASSERT(m_blBlockingJobQueue.IsEmpty());
	}
	else
	{
		pBilink = m_blBlockingJobQueue.GetNext();
		while (pBilink != &m_blBlockingJobQueue)
		{
			pExistingJob = CONTAINING_OBJECT(pBilink, BLOCKING_JOB, Linkage);
			if ((pExistingJob->pfnBlockingJobCallback == pfnBlockingJobCallback) &&
				(pExistingJob->pvContext == pvContext))
			{
				DPFX(DPFPREP, 1, "Existing blocking job 0x%p matches new job 0x%p, not submitting.",
					pExistingJob, pJob);
				hr = DPNERR_DUPLICATECOMMAND;
				goto Failure;
			}
			
			pBilink = pBilink->GetNext();
		}
	}

	
	//
	// Add job to queue.
	//
	pJob->Linkage.InsertBefore(&m_blBlockingJobQueue);

	DNLeaveCriticalSection(&m_csBlockingJobLock);
	fQueueLocked = FALSE;

	//
	// Alert the thread.
	//
	DNSetEvent( m_hBlockingJobEvent );

	hr = DPN_OK;

Exit:

	return hr;


Failure:

	if (fQueueLocked)
	{
		DNLeaveCriticalSection(&m_csBlockingJobLock);
		fQueueLocked = FALSE;
	}

	if (pJob != NULL)
	{
		g_BlockingJobPool.Release(pJob);
		pJob = NULL;
	}

	goto Exit;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// CThreadPool::DoBlockingJobs - processes all blocking jobs.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::DoBlockingJobs"

void	CThreadPool::DoBlockingJobs( void )
{
	BOOL			fRunning = TRUE;
	CBilink *		pBilink;
	BLOCKING_JOB *	pJob;


	//
	// Keep looping until it's time to shutdown.
	//
	while (fRunning)
	{
		//
		// Wait for more work.
		//
		DNWaitForSingleObject( m_hBlockingJobEvent, INFINITE );
		
		//
		// Keep looping while we have work.
		//
		do
		{
			DNEnterCriticalSection(&m_csBlockingJobLock);
			pBilink = m_blBlockingJobQueue.GetNext();
			if (pBilink == &m_blBlockingJobQueue)
			{
				//
				// Bail out of the inner loop.
				//
				DNLeaveCriticalSection(&m_csBlockingJobLock);
				break;
			}

			pJob = CONTAINING_OBJECT(pBilink, BLOCKING_JOB, Linkage);
			pJob->Linkage.RemoveFromList();

			DNLeaveCriticalSection(&m_csBlockingJobLock);

			//
			// Bail out of both loops if it's the quit job.
			//
			if (pJob->pfnBlockingJobCallback == NULL)
			{
				DPFX(DPFPREP, 5, "Recognized quit job 0x%p.", pJob);
				g_BlockingJobPool.Release(pJob);
				fRunning = FALSE;
				break;
			}

			DPFX(DPFPREP, 6, "Processing blocking job 0x%p (callback 0x%p, context 0x%p).",
				pJob, pJob->pfnBlockingJobCallback, pJob->pvContext);

			pJob->pfnBlockingJobCallback(pJob->pvContext);

			DPFX(DPFPREP, 7, "Returning blocking job 0x%p to pool.", pJob);
			g_BlockingJobPool.Release(pJob);
		}
		while (TRUE);
	}
}
//**********************************************************************

#endif // ! DPNBUILD_ONLYONETHREAD



#ifndef DPNBUILD_NOSPUI
//**********************************************************************
// ------------------------------
// CThreadPool::SpawnDialogThread - start a secondary thread to display service
//		provider UI.
//
// Entry:		Pointer to dialog function
//				Dialog context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SpawnDialogThread"

HRESULT	CThreadPool::SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction, void *const pDialogContext )
{
	HRESULT	hr;
	DNHANDLE	hDialogThread;
	DIALOG_THREAD_PARAM		*pThreadParam;
	DWORD	dwThreadID;


	DNASSERT( pDialogFunction != NULL );
	DNASSERT( pDialogContext != NULL );		// why would anyone not want a dialog context??


	//
	// initialize
	//
	hr = DPN_OK;
	pThreadParam = NULL;

	//
	// create and initialize thread param
	//
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( DNMalloc( sizeof( *pThreadParam ) ) );
	if ( pThreadParam == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to allocate memory for dialog thread!" );
		goto Failure;
	}

	pThreadParam->pDialogFunction = pDialogFunction;
	pThreadParam->pContext = pDialogContext;
	pThreadParam->pThisThreadPool = this;

	//
	// create thread
	//
	hDialogThread = DNCreateThread( NULL,					// pointer to security (none)
								  0,					// stack size (default)
								  DialogThreadProc,		// thread procedure
								  pThreadParam,			// thread param
								  0,					// creation flags (none)
								  &dwThreadID );		// pointer to thread ID
	if ( hDialogThread == NULL )
	{
		DWORD	dwError;

	
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to start dialog thread!" );
		DisplayErrorCode( 0, dwError );
		goto Failure;
	}
  								
	if ( DNCloseHandle( hDialogThread ) == FALSE )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Problem closing handle from create dialog thread!" );
		DisplayErrorCode( 0, dwError );
	}

Exit:	
	return	hr;

Failure:
	if ( pThreadParam != NULL )
	{
		DNFree( pThreadParam );
		pThreadParam = NULL;
	}

	goto Exit;
}
//**********************************************************************
#endif // !DPNBUILD_NOSPUI


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// CThreadPool::GetIOThreadCount - get I/O thread count
//
// Entry:		Pointer to variable to fill
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GetIOThreadCount"

HRESULT	CThreadPool::GetIOThreadCount( LONG *const piThreadCount )
{
	HRESULT			hr;
	DWORD			dwThreadPoolCount;


	DNASSERT( piThreadCount != NULL );

	Lock();

	hr = IDirectPlay8ThreadPoolWork_GetThreadCount(m_pDPThreadPoolWork,
													-1,
													&dwThreadPoolCount,
													0);
	switch (hr)
	{
		case DPN_OK:
		{
			*piThreadCount = dwThreadPoolCount;
			DPFX(DPFPREP, 6, "User has explicitly started %u threads.", (*piThreadCount));
			break;
		}
		
		case DPNSUCCESS_PENDING:
		{
			if ((IsThreadCountReductionAllowed()) &&
				(((DWORD) GetIntendedThreadCount()) > dwThreadPoolCount))
			{
				*piThreadCount = GetIntendedThreadCount();
				DPFX(DPFPREP, 6, "Thread pool not locked down and only %u threads currently started, using intended count of %u.",
					dwThreadPoolCount, (*piThreadCount));
			}
			else
			{
				*piThreadCount = dwThreadPoolCount;
				DPFX(DPFPREP, 6, "Thread pool locked down (%i) or more than %u threads already started, using actual count of %u.",
					(! IsThreadCountReductionAllowed()), GetIntendedThreadCount(),
					(*piThreadCount));
			}
			hr = DPN_OK;
			break;
		}
		
		case DPNERR_NOTREADY:
		{
			DNASSERT(IsThreadCountReductionAllowed());
			
			*piThreadCount = GetIntendedThreadCount();
			DPFX(DPFPREP, 6, "Thread pool does not have a thread count set, using intended count of %u.",
				(*piThreadCount));
			
			hr = DPN_OK;
			break;
		}
		
		default:
		{
			DPFX(DPFPREP, 0, "Failed getting thread count!");
			break;
		}
	}
	
	Unlock();
	
	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::SetIOThreadCount - set I/O thread count
//
// Entry:		New thread count
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SetIOThreadCount"

HRESULT	CThreadPool::SetIOThreadCount( const LONG iThreadCount )
{
	HRESULT		hr;
	DWORD		dwThreadCount;


	DNASSERT( iThreadCount > 0 );

	//
	// initialize
	//
	hr = DPN_OK;

	Lock();

	if ( IsThreadCountReductionAllowed() )
	{
		DPFX(DPFPREP, 4, "Thread pool not locked down, setting intended thread count to %i.", iThreadCount );
		SetIntendedThreadCount( iThreadCount );
	}
	else
	{
		hr = IDirectPlay8ThreadPoolWork_GetThreadCount(m_pDPThreadPoolWork,
														-1,
														&dwThreadCount,
														0);
		switch (hr)
		{
			case DPN_OK:
			case DPNSUCCESS_PENDING:
			case DPNERR_NOTREADY:
			{
				if ( (DWORD) iThreadCount != dwThreadCount )
				{
					if (hr == DPN_OK)
					{
						DPFX(DPFPREP, 1, "Thread count already set to %u by user, not changing to %i total.",
							dwThreadCount, iThreadCount);
						hr = DPNERR_NOTALLOWED;
					}
					else
					{
						//
						// Artificially prevent thread pool reduction after operations have
						// started, to simulate pre-unified-threadpool behavior.  Only
						// request a thread count change if the new count is greater
						// than the old count.
						//
						if ( (DWORD) iThreadCount > dwThreadCount )
						{
							hr = IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(m_pDPThreadPoolWork,
																					(DWORD) iThreadCount,
																					0);
						}
						else
						{
							DPFX(DPFPREP, 4, "Thread pool locked down and already has %u threads, not adjusting to %i.",
								dwThreadCount, iThreadCount );
							hr = DPN_OK;
						}
					}
				}
				else
				{
					DPFX(DPFPREP, 4, "Thread pool thread count matches (%u).",
						dwThreadCount);
					hr = DPN_OK;
				}
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Getting current thread count failed!");
				break;
			}
		}
	}

	Unlock();

	return	hr;
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYONETHREAD



//**********************************************************************
// ------------------------------
// CThreadPool::PreventThreadPoolReduction - prevents the thread pool size from being reduced
//
// Entry:		None
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::PreventThreadPoolReduction"

HRESULT CThreadPool::PreventThreadPoolReduction( void )
{
	HRESULT		hr;
#ifndef DPNBUILD_ONLYONETHREAD
	LONG		iDesiredThreads;
#endif // ! DPNBUILD_ONLYONETHREAD
#ifdef _XBOX
	DWORD		dwStatus;
	DWORD		dwInterval;
	XNADDR		xnaddr;
#endif //  _XBOX
#ifdef DBG
	DWORD		dwStartTime;
#endif // DBG


	Lock();

	//
	// If we haven't already clamped down, do so, and spin up the threads.
	//
	if ( IsThreadCountReductionAllowed() )
	{
		m_fAllowThreadCountReduction = FALSE;

#ifdef DPNBUILD_ONLYONETHREAD
		DPFX(DPFPREP, 3, "Locking down thread pool." );
#else // ! DPNBUILD_ONLYONETHREAD
		iDesiredThreads = GetIntendedThreadCount();
		DNASSERT( iDesiredThreads > 0 );
		SetIntendedThreadCount( 0 );

		DPFX(DPFPREP, 3, "Locking down thread count at %i.", iDesiredThreads );
#endif // ! DPNBUILD_ONLYONETHREAD
		

#ifndef DPNBUILD_ONLYONETHREAD
#ifdef DBG
		dwStartTime = GETTIMESTAMP();
#endif // DBG

		//
		// Have the thread pool object try to start the requested number of threads.
		//
		// We'll ignore failure, because we could still operate in DoWork mode even
		// when starting the threads fails.  It most likely failed because the user
		// is in that mode already anyway (DPNERR_ALREADYINITIALIZED).
		//
		hr = IDirectPlay8ThreadPoolWork_RequestTotalThreadCount(m_pDPThreadPoolWork,
																iDesiredThreads,
																0);
		if (hr != DPN_OK)
		{
			if (hr != DPNERR_ALREADYINITIALIZED)
			{
				DPFX(DPFPREP, 0, "Requesting thread count failed (err = 0x%lx)!", hr);
			}

			//
			// Continue...
			//
		}

#ifdef DBG
		DPFX(DPFPREP, 8, "Spent %u ms trying to start %i threads.",
			(GETTIMESTAMP() - dwStartTime), iDesiredThreads);
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD


#ifdef _XBOX
#ifdef DBG
		dwStartTime = GETTIMESTAMP();
#endif // DBG

#pragma TODO(vanceo, "Use #defines")
		//
		// Wait until the Ethernet link is active.
		//
		DPFX(DPFPREP, 1, "Ensuring Ethernet link status is active...");
		dwStatus = XNetGetEthernetLinkStatus();
		dwInterval = 5;
		while (! (dwStatus & XNET_ETHERNET_LINK_ACTIVE))
		{
			if (dwInterval > 100)
			{
				DPFX(DPFPREP, 0, "Ethernet link never became ready (status = 0x%x)!",
					dwStatus);
				hr = DPNERR_NOCONNECTION;
				goto Failure;
			}

			DPFX(DPFPREP, 0, "Ethernet link is not ready (0x%x).", dwStatus);
			IDirectPlay8ThreadPoolWork_SleepWhileWorking(m_pDPThreadPoolWork, dwInterval, 0);
			dwInterval += 5;

			dwStatus = XNetGetEthernetLinkStatus();
		}
	
		//
		// Wait until a DHCP address has been acquired or we give up trying.
		// If we're not using DHCP, this should return something other than
		// XNET_GET_XNADDR_PENDING right away.
		//
		DPFX(DPFPREP, 1, "Waiting for a valid address...");
		dwStatus = XNetGetTitleXnAddr(&xnaddr);
		dwInterval = 5;
		while (dwStatus == XNET_GET_XNADDR_PENDING)
		{
			if (dwInterval > 225)
			{
				DPFX(DPFPREP, 0, "Never acquired an address (status = 0x%x)!",
					dwStatus);
				hr = DPNERR_NOTREADY;
				goto Failure;
			}

			IDirectPlay8ThreadPoolWork_SleepWhileWorking(m_pDPThreadPoolWork, dwInterval, 0);
			dwInterval += 5;

			dwStatus = XNetGetTitleXnAddr(&xnaddr);
		}

		if (dwStatus == XNET_GET_XNADDR_NONE)
		{
			DPFX(DPFPREP, 0, "Couldn't get an address!");
			hr = DPNERR_NOCONNECTION;
			goto Failure;
		}

		DPFX(DPFPREP, 1, "Network ready.");

#pragma TODO(vanceo, "Ethernet link status timer?")

#ifdef DBG
		DPFX(DPFPREP, 8, "Spent %u ms waiting for network.",
			(GETTIMESTAMP() - dwStartTime));
#endif // DBG
#endif // _XBOX
	}
	else
	{
		DPFX(DPFPREP, 3, "Thread count already locked down." );
	}

	//
	// If we're here, everything is successful.
	//
	hr = DPN_OK;

#ifdef _XBOX
Exit:
#endif // _XBOX
	
	Unlock();

	return	hr;

#ifdef _XBOX
Failure:

	//
	// The only time we can fail in this function is if we disabled thread
	// count reduction.  In order to return to the previous state, re-enable
	// reduction.
	//
	m_fAllowThreadCountReduction = TRUE;

	goto Exit;
#endif // _XBOX
}
//**********************************************************************



#if ((! defined(DPNBUILD_NOMULTICAST)) && (defined(WINNT)))
//**********************************************************************
// ------------------------------
// CThreadPool::EnsureMadcapLoaded - Load the MADCAP API if it hasn't been
//									already, and it can be loaded.
//
// Entry:		Nothing
//
// Exit:		TRUE if MADCAP is loaded, FALSE otherwise
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CThreadPool::EnsureMadcapLoaded"

BOOL	CThreadPool::EnsureMadcapLoaded( void )
{
	BOOL	fReturn;

	
	DPFX(DPFPREP, 7, "Enter");
	
#ifndef DPNBUILD_NOREGISTRY
	if (! g_fDisableMadcapSupport)
#endif // ! DPNBUILD_NOREGISTRY
	{
		Lock();
		
		if (! IsMadcapLoaded())
		{
			if ( LoadMadcap() == FALSE )
			{
				DPFX(DPFPREP, 0, "Failed to load MADCAP API, continuing." );
				fReturn = FALSE;
			}
			else
			{
				m_fMadcapLoaded = TRUE;
				fReturn = TRUE;
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "MADCAP already loaded." );
			fReturn = TRUE;
		}
	
		Unlock();
	}
#ifndef DPNBUILD_NOREGISTRY
	else
	{
		DPFX(DPFPREP, 0, "Not loading MADCAP API." );
		fReturn = FALSE;
	}
#endif // ! DPNBUILD_NOREGISTRY

	DPFX(DPFPREP, 7, "Return [%i]", fReturn);

	return fReturn;
}
#endif // ! DPNBUILD_NOMULTICAST and WINNT



#ifndef DPNBUILD_NONATHELP
//**********************************************************************
// ------------------------------
// CThreadPool::EnsureNATHelpLoaded - Load NAT Help if it hasn't been already.
//									This has no return values, so if NAT
//									traversal is explicitly disabled, or some
//									error occurs, NAT Help will not actually
//									get loaded.
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CThreadPool::EnsureNATHelpLoaded"

void	CThreadPool::EnsureNATHelpLoaded( void )
{
	HRESULT		hr;
	DWORD		dwTemp;
	DPNHCAPS	dpnhcaps;
	DWORD		dwNATHelpRetryTime;
#ifdef DBG
	DWORD		dwStartTime;
#endif // DBG


	DPFX(DPFPREP, 7, "Enter");


#ifndef DPNBUILD_NOREGISTRY
	if ((! g_fDisableDPNHGatewaySupport) || (! g_fDisableDPNHFirewallSupport))
#endif // ! DPNBUILD_NOREGISTRY
	{
		Lock();
		
		if ( ! IsNATHelpLoaded() )
		{
			//
			// Attempt to load the NAT helper(s).
			//
			if ( LoadNATHelp() )
			{
				m_fNATHelpLoaded = TRUE;

#ifdef DBG
				dwStartTime = GETTIMESTAMP();		
#endif // DBG

				//
				// Initialize the timer values.
				//
				dwNATHelpRetryTime = -1;


				//
				// Loop through each NAT help object.
				//
				for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
				{
					if (g_papNATHelpObjects[dwTemp] != NULL)
					{
						//
						// Determine how often to refresh the NAT help caps in the future.
						//
						// We're going to force server detection now.  This will increase the time
						// it takes to startup up this Enum/Connect/Listen operation, but is
						// necessary since the IDirectPlayNATHelp::GetRegisteredAddresses call in
						// CSocketPort::BindToInternetGateway and possibly the
	 					// IDirectPlayNATHelp::QueryAddress call in CSocketPort::MungePublicAddress
	 					// could occur before the first NATHelp GetCaps timer fires.
	 					// In the vast majority of NAT cases, the gateway is already available.
	 					// If we hadn't detected that yet (because we hadn't called
	 					// IDirectPlayNATHelp::GetCaps with DPNHGETCAPS_UPDATESERVERSTATUS)
	 					// then we would get an incorrect result from GetRegisteredAddresses or
	 					// QueryAddress.
						//
						ZeroMemory(&dpnhcaps, sizeof(dpnhcaps));
						dpnhcaps.dwSize = sizeof(dpnhcaps);

		 				hr = IDirectPlayNATHelp_GetCaps(g_papNATHelpObjects[dwTemp],
		 												&dpnhcaps,
		 												DPNHGETCAPS_UPDATESERVERSTATUS);
						if (FAILED(hr))
						{
							DPFX(DPFPREP, 0, "Failed getting NAT Help capabilities (error = 0x%lx), continuing.",
								hr);

							//
							// NAT Help will probably not work correctly, but that won't prevent
							// local connections from working.  Consider it non-fatal.
							//
						}
						else
						{
							//
							// See if this is the shortest interval.
							//
							if (dpnhcaps.dwRecommendedGetCapsInterval < dwNATHelpRetryTime)
							{
								dwNATHelpRetryTime = dpnhcaps.dwRecommendedGetCapsInterval;
							}

#ifndef DPNBUILD_NOLOCALNAT
							//
							// Remember if there's a local NAT.
							//
							if ((dpnhcaps.dwFlags & DPNHCAPSFLAG_GATEWAYPRESENT) &&
								(dpnhcaps.dwFlags & DPNHCAPSFLAG_GATEWAYISLOCAL))
							{
								g_fLocalNATDetectedAtStartup = TRUE;
							}
							else
							{
								g_fLocalNATDetectedAtStartup = FALSE;
							}
#endif // ! DPNBUILD_NOLOCALNAT
						}
					}
					else
					{
						//
						// No object loaded in this slot.
						//
					}
				}
			
				
				//
				// If there's a retry interval, submit a timer job.
				//
				if (dwNATHelpRetryTime != -1)
				{
					//
					// Attempt to add timer job that will refresh the lease and server
					// status.
					// Although we're submitting it as a periodic timer, it's actually
					// not going to be called at regular intervals.
					// There is a race condition where the alert event/IOCP may have
					// been fired already, and another thread tried to cancel this timer
					// which hasn't been submitted yet.  The logic to handle this race
					// is placed there (HandleNATHelpUpdate); here we can assume we
					// are the first person to submit the refresh timer.
					//


					DPFX(DPFPREP, 7, "Submitting NAT Help refresh timer (for every %u ms) for thread pool 0x%p.",
						dwNATHelpRetryTime, this);

					DNASSERT(! m_fNATHelpTimerJobSubmitted );
					m_fNATHelpTimerJobSubmitted = TRUE;

#ifdef DPNBUILD_ONLYONEPROCESSOR
					hr = SubmitTimerJob(FALSE,								// don't perform immediately
										1,									// retry count
										TRUE,								// retry forever
										dwNATHelpRetryTime,					// retry timeout
										TRUE,								// wait forever
										0,									// idle timeout
										CThreadPool::NATHelpTimerFunction,	// periodic callback function
										CThreadPool::NATHelpTimerComplete,	// completion function
										this);								// context
#else // ! DPNBUILD_ONLYONEPROCESSOR
					hr = SubmitTimerJob(-1,									// pick any CPU
										FALSE,								// don't perform immediately
										1,									// retry count
										TRUE,								// retry forever
										dwNATHelpRetryTime,					// retry timeout
										TRUE,								// wait forever
										0,									// idle timeout
										CThreadPool::NATHelpTimerFunction,	// periodic callback function
										CThreadPool::NATHelpTimerComplete,	// completion function
										this);								// context
#endif // ! DPNBUILD_ONLYONEPROCESSOR
					if (hr != DPN_OK)
					{
						m_fNATHelpTimerJobSubmitted = FALSE;
						DPFX(DPFPREP, 0, "Failed to submit timer job to watch over NAT Help (err = 0x%lx)!", hr );
						
						//
						// NAT Help will probably not work correctly, but that won't
						// prevent local connections from working.  Consider it
						// non-fatal.
						//
					}
				}
				
#ifdef DBG
				DPFX(DPFPREP, 8, "Spent %u ms preparing NAT Help.",
					(GETTIMESTAMP() - dwStartTime));
#endif // DBG
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to load NAT Help, continuing." );
			}
		}
		else
		{
			DPFX(DPFPREP, 4, "NAT Help already loaded." );
		}
	
		Unlock();
	}
#ifndef DPNBUILD_NOREGISTRY
	else
	{
		DPFX(DPFPREP, 0, "Not loading NAT Help." );
	}
#endif // ! DPNBUILD_NOREGISTRY

	DPFX(DPFPREP, 7, "Leave");
}


//**********************************************************************
// ------------------------------
// CThreadPool::PerformSubsequentNATHelpGetCaps - blocking function to get NAT Help caps again
//
// Entry:		Pointer to job information
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CEndpoint::EnumQueryJobCallback"

void	CThreadPool::PerformSubsequentNATHelpGetCaps( void * const pvContext )
{
	CThreadPool *	pThisThreadPool;


	DNASSERT( pvContext != NULL );
	pThisThreadPool = (CThreadPool*) pvContext;

	pThisThreadPool->HandleNATHelpUpdate(NULL);
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::NATHelpTimerComplete - NAT Help timer job has completed
//
// Entry:		Timer result code
//				Context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CThreadPool::NATHelpTimerComplete"

void	CThreadPool::NATHelpTimerComplete( const HRESULT hResult, void * const pContext )
{
	CThreadPool *	pThisThreadPool;
	
	DNASSERT( pContext != NULL );
	pThisThreadPool = (CThreadPool*) pContext;

	DPFX(DPFPREP, 5, "Threadpool 0x%p NAT Help Timer complete.", pThisThreadPool);

	pThisThreadPool->m_fNATHelpTimerJobSubmitted = FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::NATHelpTimerFunction - NAT Help timer job needs service
//
// Entry:		Pointer to context
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CThreadPool::NATHelpTimerFunction"

void	CThreadPool::NATHelpTimerFunction( void * const pContext )
{
	CThreadPool *	pThisThreadPool;


	DNASSERT( pContext != NULL );
	pThisThreadPool = (CThreadPool*) pContext;
	
	//
	// Attempt to submit a blocking job to update the NAT capabilites.  If it
	// fails, we'll just try again later.  It might also fail because a previous
	// blocking job took so long that there's still a job scheduled in the queue
	// already (we disallow duplicates).
	//
	pThisThreadPool->SubmitBlockingJob(CThreadPool::PerformSubsequentNATHelpGetCaps, pThisThreadPool);
}
//**********************************************************************
#endif // DPNBUILD_NONATHELP



#ifndef DPNBUILD_ONLYWINSOCK2

//**********************************************************************
// ------------------------------
// CThreadPool::AddSocketPort - add a socket to the Win9x watch list
//
// Entry:		Pointer to SocketPort
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::AddSocketPort"

HRESULT	CThreadPool::AddSocketPort( CSocketPort *const pSocketPort )
{
	HRESULT	hr;
	BOOL	fSocketAdded;

	
	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p)", this, pSocketPort);
	DNASSERT( pSocketPort != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	fSocketAdded = FALSE;

	Lock();

	//
	// We're capped by the number of sockets we can use for Winsock1.  Make
	// sure we don't allocate too many sockets.
	//
	if ( m_uReservedSocketCount == FD_SETSIZE )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "There are too many sockets allocated on Winsock1!" );
		goto Failure;
	}

	m_uReservedSocketCount++;
	
	DNASSERT( m_SocketSet.fd_count < FD_SETSIZE );
	m_pSocketPorts[ m_SocketSet.fd_count ] = pSocketPort;
	m_SocketSet.fd_array[ m_SocketSet.fd_count ] = pSocketPort->GetSocket();
	m_SocketSet.fd_count++;
	fSocketAdded = TRUE;

	//
	// add a reference to note that this socket port is being used by the thread
	// pool
	//
	pSocketPort->AddRef();

	if (m_pvTimerDataWinsock1IO == NULL)
	{
		hr = IDirectPlay8ThreadPoolWork_ScheduleTimer(m_pDPThreadPoolWork,
													0,										// use CPU 0, we shouldn't have multiple CPUs anyway
													g_dwSelectTimePeriod,					// delay
													CThreadPool::CheckWinsock1IOCallback,	// callback
													this,									// user context
													&m_pvTimerDataWinsock1IO,				// timer data (returned)
													&m_uiTimerUniqueWinsock1IO,				// timer unique (returned)
													0);										// flags
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't schedule Winsock 1 I/O poll timer!");
			goto Failure;
		}
	}
	else
	{
		//
		// It's possible there's still an outstanding lazy cancellation
		// attempt.  If so, don't try to cancel I/O anymore.
		//
		if (m_fCancelWinsock1IO)
		{
			DPFX(DPFPREP, 1, "Retracting lazy cancellation attempt.");
			m_fCancelWinsock1IO = FALSE;
		}
	}

Exit:
	Unlock();
	
	DPFX(DPFPREP, 6, "(0x%p) Return: [0x%08x]", this, hr);

	return	hr;

Failure:
	if ( fSocketAdded != FALSE )
	{
		AssertCriticalSectionIsTakenByThisThread( &m_Lock, TRUE );
		m_SocketSet.fd_count--;
		m_pSocketPorts[ m_SocketSet.fd_count ] = NULL;
		m_SocketSet.fd_array[ m_SocketSet.fd_count ] = NULL;
		fSocketAdded = FALSE;
	}

	m_uReservedSocketCount--;

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::RemoveSocketPort - remove a socket from the Win9x watch list
//
// Entry:		Pointer to socket port to remove
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::RemoveSocketPort"

void	CThreadPool::RemoveSocketPort( CSocketPort *const pSocketPort )
{
	UINT_PTR	uIndex;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p)", this, pSocketPort);
	DNASSERT( pSocketPort != NULL );
	
	Lock();

	uIndex = m_SocketSet.fd_count;
	DNASSERT( uIndex != 0 );

	//
	// If this is the last socket, cancel the I/O timer.
	//
	if ( uIndex == 1 )
	{
		HRESULT		hr;


		//
		// Keep trying to cancel the Winsock1 timer.  It may fail because it's in the
		// process of actively executing, but we will set the cancel flag so that the
		// timer will eventually notice.
		//
		DPFX(DPFPREP, 5, "Cancelling Winsock 1 I/O timer.");
		DNASSERT(m_pvTimerDataWinsock1IO != NULL);
		hr = IDirectPlay8ThreadPoolWork_CancelTimer(m_pDPThreadPoolWork,
													m_pvTimerDataWinsock1IO,
													m_uiTimerUniqueWinsock1IO,
													0);
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 2, "Couldn't stop Winsock1 I/O timer, marking for lazy cancellation.");
			m_fCancelWinsock1IO = TRUE;
		}
		else
		{
			m_pvTimerDataWinsock1IO = NULL;
		}
	}
	
	while ( uIndex != 0 )
	{
		uIndex--;

		if ( m_pSocketPorts[ uIndex ] == pSocketPort )
		{
			m_uReservedSocketCount--;
			m_SocketSet.fd_count--;

			memmove( &m_pSocketPorts[ uIndex ],
					 &m_pSocketPorts[ uIndex + 1 ],
					 ( sizeof( m_pSocketPorts[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );

			memmove( &m_SocketSet.fd_array[ uIndex ],
					 &m_SocketSet.fd_array[ uIndex + 1 ],
					 ( sizeof( m_SocketSet.fd_array[ uIndex ] ) * ( m_SocketSet.fd_count - uIndex ) ) );

			//
			// clear last entry which is now unused
			//
			memset( &m_pSocketPorts[ m_SocketSet.fd_count ], 0x00, sizeof( m_pSocketPorts[ m_SocketSet.fd_count ] ) );
			memset( &m_SocketSet.fd_array[ m_SocketSet.fd_count ], 0x00, sizeof( m_SocketSet.fd_array[ m_SocketSet.fd_count ] ) );

			//
			// end the loop
			//
			uIndex = 0;
		}
	}

	Unlock();
	
	pSocketPort->DecRef();

	DPFX(DPFPREP, 6, "(0x%p) Leave", this);
}
//**********************************************************************

#endif // ! DPNBUILD_ONLYWINSOCK2



#ifdef WIN95
#ifndef DPNBUILD_NOWINSOCK2
#endif // ! DPNBUILD_NOWINSOCK2
#endif // WIN95


#ifndef DPNBUILD_NONATHELP
//**********************************************************************
// ------------------------------
// CThreadPool::HandleNATHelpUpdate - handle a NAT Help update event
//
// Entry:		Timer interval if update is occurring periodically, or
//				NULL if a triggered event.
//				This function may take a while, because updating NAT Help
//				can block.
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::HandleNATHelpUpdate"

void	CThreadPool::HandleNATHelpUpdate( DWORD * const pdwTimerInterval )
{
	HRESULT		hr;
	DWORD		dwTemp;
	DPNHCAPS	dpnhcaps;
	DWORD		dwNATHelpRetryTime;
	BOOL		fModifiedRetryInterval;
	DWORD		dwFirstUpdateTime;
	DWORD		dwCurrentTime;
	DWORD		dwNumGetCaps = 0;


	DNASSERT(IsNATHelpLoaded());


	Lock();

	//
	// Prevent multiple threads from trying to update NAT Help status at the same
	// time.  If we're a duplicate, just bail.
	//

	if (m_dwNATHelpUpdateThreadID != 0)
	{
		DPFX(DPFPREP, 1, "Thread %u/0x%x already handling NAT Help update, not processing again (thread pool = 0x%p, timer = 0x%p).",
			m_dwNATHelpUpdateThreadID, m_dwNATHelpUpdateThreadID, this, pdwTimerInterval);
		
		Unlock();
		
		return;
	}

	m_dwNATHelpUpdateThreadID = GetCurrentThreadId();
	
	if (! m_fNATHelpTimerJobSubmitted)
	{
		DPFX(DPFPREP, 1, "Handling NAT Help update without a NAT refresh timer job submitted (thread pool = 0x%p).",
			this);
		DNASSERT(pdwTimerInterval == NULL);
	}
	
	Unlock();


	DPFX(DPFPREP, 6, "Beginning thread pool 0x%p NAT Help update.", this);

	
	//
	// Initialize the timer values.
	//
	dwNATHelpRetryTime	= -1;
	dwFirstUpdateTime	= GETTIMESTAMP() - 1; // longest possible time


	for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
	{
		if (g_papNATHelpObjects[dwTemp] != NULL)
		{
			ZeroMemory(&dpnhcaps, sizeof(dpnhcaps));
			dpnhcaps.dwSize = sizeof(dpnhcaps);

			hr = IDirectPlayNATHelp_GetCaps(g_papNATHelpObjects[dwTemp],
											&dpnhcaps,
											DPNHGETCAPS_UPDATESERVERSTATUS);
			switch (hr)
			{
				case DPNH_OK:
				{
					//
					// See if this is the shortest interval.
					//
					if (dpnhcaps.dwRecommendedGetCapsInterval < dwNATHelpRetryTime)
					{
						dwNATHelpRetryTime = dpnhcaps.dwRecommendedGetCapsInterval;
					}
					break;
				}

				case DPNHSUCCESS_ADDRESSESCHANGED:
				{
					DPFX(DPFPREP, 1, "NAT Help index %u indicated public addresses changed.",
						dwTemp);

					//
					// We don't actually store any public address information,
					// we query it each time.  Therefore we don't need to
					// actually do anything with the change notification.
					//


					//
					// See if this is the shortest interval.
					//
					if (dpnhcaps.dwRecommendedGetCapsInterval < dwNATHelpRetryTime)
					{
						dwNATHelpRetryTime = dpnhcaps.dwRecommendedGetCapsInterval;
					}
					break;
				}

				case DPNHERR_OUTOFMEMORY:
				{
					//
					// This should generally only happen in stress.  We'll
					// continue on to other NAT help objects, and hope we
					// aren't totally hosed.
					//

					DPFX(DPFPREP, 0, "NAT Help index %u returned out-of-memory error!  Continuing.",
						dwTemp);
					break;
				}
				
				default:
				{
					//
					// Some other unknown error occurred.  Ignore it.
					//

					DPFX(DPFPREP, 0, "NAT Help index %u returned unknown error 0x%lx!  Continuing.",
						dwTemp, hr);
					break;
				}
			}


			//
			// Save the current time, if this is the first GetCaps.
			//
			if (dwNumGetCaps == 0)
			{
				dwFirstUpdateTime = GETTIMESTAMP();
			}

			dwNumGetCaps++;
		}
		else
		{
			//
			// No DPNATHelp object in that slot.
			//
		}
	}


	//
	// Assert that at least one NAT Help object is loaded.
	//
	DNASSERT(dwNumGetCaps > 0);



	dwCurrentTime = GETTIMESTAMP();

	//
	// We may need to make some adjustments to the timer.  Either subtract out time
	// we've spent fiddling around with other NAT Help interfaces, or make sure the
	// time isn't really large because that can screw up time calculations.  It's
	// not a big deal to wake up after 24 days even though we wouldn't need to
	// according to the logic above.
	//
	if (dwNATHelpRetryTime & 0x80000000)
	{
		DPFX(DPFPREP, 3, "NAT Help refresh timer for thread pool 0x%p is set to longest possible without going negative.",
			this);

		dwNATHelpRetryTime = 0x7FFFFFFF;
	}
	else
	{
		DWORD	dwTimeElapsed;


		//
		// Find out how much time has elapsed since the first GetCaps completed.
		//
		dwTimeElapsed = dwCurrentTime - dwFirstUpdateTime;

		//
		// Remove it from the retry interval, unless it's already overdue.
		//
		if (dwTimeElapsed < dwNATHelpRetryTime)
		{
			dwNATHelpRetryTime -= dwTimeElapsed;
		}
		else
		{
			dwNATHelpRetryTime = 0; // shortest time possible
		}
	}


	//
	// Modify the next time when we should refresh the NAT Help information based
 	// on the reported recommendation.
	//
	if (pdwTimerInterval != NULL)
	{
		DPFX(DPFPREP, 6, "Modifying NAT Help refresh timer for thread pool 0x%p in place (was %u ms, changing to %u).",
			this, (*pdwTimerInterval), dwNATHelpRetryTime);

		(*pdwTimerInterval) = dwNATHelpRetryTime;
	}
	else
	{
		//
		// Add the interval to the current time to find the new retry time.
		//
		dwCurrentTime += dwNATHelpRetryTime;


		DPFX(DPFPREP, 6, "Modifying NAT Help refresh timer for thread pool 0x%p to run at offset %u (in %u ms).",
			this, dwCurrentTime, dwNATHelpRetryTime);


		//
		// Try to modify the existing timer job.  There are two race conditions:
		// 1) the recurring timer that triggered this refresh (which occurs on a
		// separate non-blockable thread) has not rescheduled itself yet.  It
		// should pick up the new timer setting we're about to apply when it
		// eventually does reschedule.  ModifyTimerJobNextRetryTime should
		// succeed.
		// 2) the NAT help timer is being killed.  ModifyTimerJobNextRetryTime
		// will fail, but there's nothing we can or should do.
		//
		fModifiedRetryInterval = ModifyTimerJobNextRetryTime(this, dwCurrentTime);
		if (! fModifiedRetryInterval)
		{
			DPFX(DPFPREP, 1, "Unable to modify NAT Help refresh timer (thread pool 0x%p), timer should be cancelled.",
				this);
		}
	}


	//
	// Now that we're done handling the update, let other threads do what they
	// want.
	//
	Lock();
	DNASSERT(m_dwNATHelpUpdateThreadID == GetCurrentThreadId());
	m_dwNATHelpUpdateThreadID = 0;
	Unlock();

}
//**********************************************************************
#endif // DPNBUILD_NONATHELP



#ifndef DPNBUILD_NOSPUI
//**********************************************************************
// ------------------------------
// CThreadPool::DialogThreadProc - thread proc for spawning dialogs
//
// Entry:		Pointer to startup parameter
//
// Exit:		Error Code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::DialogThreadProc"

DWORD WINAPI	CThreadPool::DialogThreadProc( void *pParam )
{
	const DIALOG_THREAD_PARAM	*pThreadParam;
	BOOL	fComInitialized;


	//
	// Initialize COM.  If this fails, we'll have problems later.
	//
	fComInitialized = FALSE;
	switch ( COM_CoInitialize( NULL ) )
	{
		case S_OK:
		{
			fComInitialized = TRUE;
			break;
		}

		case S_FALSE:
		{
			DNASSERT( FALSE );
			fComInitialized = TRUE;
			break;
		}

		//
		// COM init failed!
		//
		default:
		{
			DPFX(DPFPREP, 0, "Failed to initialize COM!" );
			DNASSERT( FALSE );
			break;
		}
	}
	
	DNASSERT( pParam != NULL );
	pThreadParam = static_cast<DIALOG_THREAD_PARAM*>( pParam );
	
	pThreadParam->pDialogFunction( pThreadParam->pContext );

	DNFree( pParam );
	
	if ( fComInitialized != FALSE )
	{
		COM_CoUninitialize();
		fComInitialized = FALSE;
	}

	return	0;
}
//**********************************************************************
#endif // ! DPNBUILD_NOSPUI



#ifndef DPNBUILD_ONLYWINSOCK2

//**********************************************************************
// ------------------------------
// CThreadPool::CheckWinsock1IO - check the IO status for Winsock1 sockets
//
// Entry:		Pointer to sockets to watch
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CheckWinsock1IO"

BOOL	CThreadPool::CheckWinsock1IO( FD_SET *const pWinsock1Sockets )
{
#ifdef DPNBUILD_NONEWTHREADPOOL
static	const TIMEVAL	SelectTime = { 0, 0 }; // zero, do an instant check
#else // ! DPNBUILD_NONEWTHREADPOOL
	TIMEVAL		SelectTime = { 0, (g_dwSelectTimeSlice * 1000)}; // convert ms into microseconds
#endif // ! DPNBUILD_NONEWTHREADPOOL
	BOOL		fIOServiced;
	INT			iSelectReturn;
	FD_SET		ReadSocketSet;
	FD_SET		ErrorSocketSet;


	//
	// Make a local copy of all of the sockets.  This isn't totally
	// efficient, but it works.  Multiplying by active socket count will
	// spend half the time in the integer multiply.
	//
	fIOServiced = FALSE;
	Lock();

	if (m_fCancelWinsock1IO)
	{
		DPFX(DPFPREP, 1, "Detected Winsock 1 I/O cancellation, aborting.");
		Unlock();
		return FALSE;
	}

	memcpy( &ReadSocketSet, pWinsock1Sockets, sizeof( ReadSocketSet ) );
	memcpy( &ErrorSocketSet, pWinsock1Sockets, sizeof( ErrorSocketSet ) );
	Unlock();

	//
	// Don't check write sockets here because it's very likely that they're ready
	// for service but have no outgoing data and will thrash
	//
	iSelectReturn = select( 0,					// compatibility parameter (ignored)
							  &ReadSocketSet,	// sockets to check for read
							  NULL,				// sockets to check for write (none)
							  &ErrorSocketSet,	// sockets to check for error
							  &SelectTime		// wait timeout
							  );
	switch ( iSelectReturn )
	{
		//
		// timeout
		//
		case 0:
		{
			break;
		}

		//
		// select got pissed
		//
		case SOCKET_ERROR:
		{
			DWORD	dwWSAError;


			dwWSAError = WSAGetLastError();
			switch ( dwWSAError )
			{
				//
				// WSAENOTSOCK = This socket was probably closed
				//
				case WSAENOTSOCK:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting 'Not a socket' when selecting read or error sockets!" );
					break;
				}

				//
				// WSAEINTR = this operation was interrupted
				//
				case WSAEINTR:
				{
					DPFX(DPFPREP, 1, "Winsock1 reporting interrupted operation when selecting read or error sockets!" );
					break;
				}

				//
				// other
				//
				default:
				{
					DPFX(DPFPREP, 0, "Problem selecting read or error sockets for service!" );
					DisplayWinsockError( 0, dwWSAError );
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// Check for sockets needing read service and error service.
		//
		default:
		{
			fIOServiced |= ServiceWinsock1Sockets( &ReadSocketSet, CSocketPort::Winsock1ReadService );
			fIOServiced |= ServiceWinsock1Sockets( &ErrorSocketSet, CSocketPort::Winsock1ErrorService );
			break;
		}
	}

	return	fIOServiced;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::ServiceWinsock1Sockets - service requests on Winsock1 sockets ports
//
// Entry:		Pointer to set of sockets
//				Pointer to service function
//
// Exit:		Boolean indicating whether I/O was serviced
//				TRUE = I/O serviced
//				FALSE = I/O not serviced
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::ServiceWinsock1Sockets"

BOOL	CThreadPool::ServiceWinsock1Sockets( FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction )
{
	BOOL		fReturn;
	UINT_PTR	uWaitingSocketCount;
	UINT_PTR	uSocketPortCount;
	CSocketPort	*pSocketPorts[ FD_SETSIZE ];


	//
	// initialize
	//
	fReturn = FALSE;
	uSocketPortCount = 0;
	uWaitingSocketCount = pSocketSet->fd_count;
	
	Lock();
	while ( uWaitingSocketCount > 0 )
	{
		UINT_PTR	uIdx;


		uWaitingSocketCount--;
		uIdx = m_SocketSet.fd_count;
		while ( uIdx != 0 )
		{
			uIdx--;
			if ( __WSAFDIsSet( m_SocketSet.fd_array[ uIdx ], pSocketSet ) != FALSE )
			{
				//
				// this socket is still available, add a reference to the socket
				// port and keep it around to be processed outside of the lock
				//
				pSocketPorts[ uSocketPortCount ] = m_pSocketPorts[ uIdx ];
				pSocketPorts[ uSocketPortCount ]->AddRef();
				uSocketPortCount++;
				uIdx = 0;
			}
		}
	}
	Unlock();

	while ( uSocketPortCount != 0 )
	{
		uSocketPortCount--;
		
		//
		// call the service function and remove the reference
		//
		fReturn |= (pSocketPorts[ uSocketPortCount ]->*pServiceFunction)();
		pSocketPorts[ uSocketPortCount ]->DecRef();
	}

	return	fReturn;
}
//**********************************************************************
#endif // ! DPNBUILD_ONLYWINSOCK2


//**********************************************************************
// ------------------------------
// CThreadPool::SubmitDelayedCommand - submit request to perform work in another thread
//
// Entry:		CPU index (non DPNBUILD_ONLYONEPROCESSOR builds only)
//				Pointer to callback function
//				Pointer to callback context
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::SubmitDelayedCommand"

#ifdef DPNBUILD_ONLYONEPROCESSOR
HRESULT	CThreadPool::SubmitDelayedCommand( const PFNDPTNWORKCALLBACK pFunction,
										  void *const pContext )
{
	return IDirectPlay8ThreadPoolWork_QueueWorkItem(m_pDPThreadPoolWork,
													-1,
													pFunction,
													pContext,
													0);
}
#else // ! DPNBUILD_ONLYONEPROCESSOR
HRESULT	CThreadPool::SubmitDelayedCommand( const DWORD dwCPU,
										  const PFNDPTNWORKCALLBACK pFunction,
										  void *const pContext )
{
	return IDirectPlay8ThreadPoolWork_QueueWorkItem(m_pDPThreadPoolWork,
													dwCPU,
													pFunction,
													pContext,
													0);
}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
//**********************************************************************


//**********************************************************************
// ------------------------------
// CThreadPool::GenericTimerCallback - generic timer callback
//
// Entry:		Pointer to callback context
//				Pointer to timer data
//				Pointer to timer uniqueness value
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::GenericTimerCallback"

void WINAPI CThreadPool::GenericTimerCallback( void * const pvContext,
										void * const pvTimerData,
										const UINT uiTimerUnique )
{
	TIMER_OPERATION_ENTRY *		pTimerEntry;
	CThreadPool *				pThisThreadPool;
	DWORD						dwCurrentTime;
	HRESULT						hr;
	DWORD						dwNewTimerDelay;
#ifdef DBG
	DWORD						dwNextRetryTime;
#endif // DBG


	pTimerEntry = (TIMER_OPERATION_ENTRY*) pvContext;
	DNASSERT((pvTimerData == pTimerEntry->pvTimerData) || (pTimerEntry->pvTimerData == NULL));
	DNASSERT((uiTimerUnique == pTimerEntry->uiTimerUnique) || (pTimerEntry->uiTimerUnique == 0));
	
	pThisThreadPool = pTimerEntry->pThreadPool;


	//
	// Process the timer, unless we just went through the idle timeout.
	//
	if (pTimerEntry->uRetryCount != 0)
	{
		dwCurrentTime = GETTIMESTAMP();
		
#ifdef DBG
		dwNextRetryTime = pTimerEntry->dwNextRetryTime;	// copy since lock is not held
		if ((int) (dwNextRetryTime - dwCurrentTime) <= 0)
		{
			//
			// Timer expired and has not been rescheduled yet.
			//
			DPFX(DPFPREP, 7, "Threadpool 0x%p performing timed job 0x%p approximately %u ms after intended time of %u.",
				pThisThreadPool, pTimerEntry, (dwCurrentTime - dwNextRetryTime), pTimerEntry->dwNextRetryTime);
		}
		else
		{
			//
			// Another thread may have modified the timer already.
			//
			DPFX(DPFPREP, 7, "Threadpool 0x%p performing timed job 0x%p (next time already modified to be %u).",
				pThisThreadPool, pTimerEntry,  dwNextRetryTime);
		}
#endif // DBG

		//
		// Execute this timed item.
		//
		pTimerEntry->pTimerCallback(pTimerEntry->pContext);

		//
		// Reschedule the job, unless it was *just* cancelled, or it's idling
		// forever.
		//
		pThisThreadPool->LockTimerData();
		if (pTimerEntry->fCancelling)
		{
			DPFX(DPFPREP, 5, "Timer 0x%p was just cancelled, completing.", pTimerEntry);

			pTimerEntry->Linkage.RemoveFromList();
			pThisThreadPool->UnlockTimerData();

			pTimerEntry->pTimerComplete(DPNERR_USERCANCEL, pTimerEntry->pContext);
			g_TimerEntryPool.Release(pTimerEntry);
		}
		else
		{
			//
			// If this job isn't running forever, decrement the retry count.
			// If there are no more retries, set up the idle timer.
			//
			if ( pTimerEntry->fRetryForever == FALSE )
			{
				pTimerEntry->uRetryCount--;
				if ( pTimerEntry->uRetryCount == 0 )
				{
					if ( pTimerEntry->fIdleWaitForever == FALSE )
					{
						//
						// Compute stopping time for this job's 'Timeout' phase.
						//
						dwNewTimerDelay = pTimerEntry->dwIdleTimeout;
						pTimerEntry->dwIdleTimeout += dwCurrentTime;
					}
					else
					{
						//
						// We're waiting forever for enum returns.  ASSERT that we
						// have the maximum timeout.
						//
						DNASSERT( pTimerEntry->dwIdleTimeout == -1 );

						//
						// Set this value to avoid a false PREfast warning.
						//
						dwNewTimerDelay = 0;
					}

					goto SkipNextRetryTimeComputation;
				}
			} // end if (don't retry forever)

			dwNewTimerDelay = pTimerEntry->dwRetryInterval;
			pTimerEntry->dwNextRetryTime = dwCurrentTime + pTimerEntry->dwRetryInterval;

SkipNextRetryTimeComputation:
		
			if ((! pTimerEntry->fIdleWaitForever) ||
				(pTimerEntry->uRetryCount > 0))
			{
				//
				// Make sure we aren't trying to schedule something too far in
				// the future or backward in time.  If we are, we'll just force
				// the timer to expire earlier.
				//
				if ((int) dwNewTimerDelay < 0)
				{
					DNASSERT(! "Job time is unexpectedly long or backward in time!");
					dwNewTimerDelay = 0x7FFFFFFF;
				}

				hr = IDirectPlay8ThreadPoolWork_ResetCompletingTimer(pThisThreadPool->m_pDPThreadPoolWork,
																	pvTimerData,								// timer data
																	dwNewTimerDelay,							// delay
																	CThreadPool::GenericTimerCallback,			// callback
																	pTimerEntry,								// user context
																	&pTimerEntry->uiTimerUnique,				// new timer uniqueness value
																	0);											// flags
				DNASSERT(hr == DPN_OK);
				pTimerEntry->pvTimerData = pvTimerData; // ensure that we remember the timer handle
				pThisThreadPool->UnlockTimerData();
			}
			else
			{
				DPFX(DPFPREP, 5, "Timer 0x%p now idling forever.", pTimerEntry);

				pTimerEntry->pvTimerData = NULL;
				pThisThreadPool->UnlockTimerData();
			}
		}
	}
	else
	{
		DNASSERT((int) (pTimerEntry->dwIdleTimeout - GETTIMESTAMP()) <= 0);
		
		//
		// Remove this link from the list, tell owner that the job is
		// complete and return the job to the pool.
		//
		pThisThreadPool->LockTimerData();
		pTimerEntry->Linkage.RemoveFromList();
		pThisThreadPool->UnlockTimerData();
		pTimerEntry->pTimerComplete(DPN_OK, pTimerEntry->pContext);
		g_TimerEntryPool.Release(pTimerEntry);
	}
}
//**********************************************************************


#ifndef DPNBUILD_ONLYWINSOCK2

//**********************************************************************
// ------------------------------
// CThreadPool::CheckWinsock1IOCallback - Winsock1 I/O servicing callback
//
//				Pointer to timer data
//				Pointer to timer uniqueness value
// Entry:		Pointer to callback context
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"CThreadPool::CheckWinsock1IOCallback"

void WINAPI CThreadPool::CheckWinsock1IOCallback( void * const pvContext,
											void * const pvTimerData,
											const UINT uiTimerUnique )
{
	CThreadPool *	pThisThreadPool = (CThreadPool*) pvContext;
	BOOL			fResult;
	HRESULT			hr;


	//
	// Service all Winsock1 I/O possible.
	//
	do
	{
		fResult = pThisThreadPool->CheckWinsock1IO(&pThisThreadPool->m_SocketSet);
	}
	while (fResult);


	//
	// Schedule the timer again, unless we're cancelling it.
	//
	pThisThreadPool->Lock();

	DNASSERT(pvTimerData == pThisThreadPool->m_pvTimerDataWinsock1IO);
	DNASSERT(uiTimerUnique == pThisThreadPool->m_uiTimerUniqueWinsock1IO);
	
	if (! pThisThreadPool->m_fCancelWinsock1IO)
	{
		hr = IDirectPlay8ThreadPoolWork_ResetCompletingTimer(pThisThreadPool->m_pDPThreadPoolWork,
														pvTimerData,									// timer data
														g_dwSelectTimePeriod,							// delay
														CThreadPool::CheckWinsock1IOCallback,			// callback
														pThisThreadPool,								// user context
														&pThisThreadPool->m_uiTimerUniqueWinsock1IO,	// updated timer uniqueness value
														0);												// flags
		DNASSERT(hr == DPN_OK);
	}
	else
	{
		DPFX(DPFPREP, 1, "Not resubmitting Winsock1 I/O timer due to cancellation.");

		pThisThreadPool->m_fCancelWinsock1IO = FALSE;
		pThisThreadPool->m_pvTimerDataWinsock1IO = NULL;
	}

	pThisThreadPool->Unlock();
}
//**********************************************************************

#endif // ! DPNBUILD_ONLYWINSOCK2



#ifndef DPNBUILD_ONLYONETHREAD

//**********************************************************************
// ------------------------------
// DPNBlockingJobThreadProc - thread procedure for executing blocking jobs
//
// Entry:		Parameter
//
// Exit:		Result code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"DPNBlockingJobThreadProc"

DWORD WINAPI DPNBlockingJobThreadProc(PVOID pvParameter)
{
	HRESULT			hr;
	CThreadPool *	pThisThreadPool;
	BOOL			fUninitializeCOM = TRUE;


	DPFX(DPFPREP, 5, "Parameters: (0x%p)", pvParameter);

	pThisThreadPool = (CThreadPool*) pvParameter;

	//
	// Init COM.
	//
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed to initialize COM (err = 0x%lx)!  Continuing.", hr);
		fUninitializeCOM = FALSE;

		//
		// Continue...
		//
	}

	//
	// Process all jobs until we're told to quit.
	//
	pThisThreadPool->DoBlockingJobs();

	if (fUninitializeCOM)
	{
		CoUninitialize();
		fUninitializeCOM = FALSE;
	}
	
	DPFX(DPFPREP, 5, "Leave");

	return 0;
}
//**********************************************************************

#endif // ! DPNBUILD_ONLYONETHREAD




//**********************************************************************
// ------------------------------
// TimerEntry_Alloc - allocate a new timer job entry
//
// Entry:		Pointer to new entry
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization failed
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"TimerEntry_Alloc"

BOOL TimerEntry_Alloc( void *pvItem, void* pvContext )
{
	TIMER_OPERATION_ENTRY* pTimerEntry = (TIMER_OPERATION_ENTRY*)pvItem;

	DNASSERT( pvItem != NULL );

	DEBUG_ONLY( memset( pTimerEntry, 0x00, sizeof( *pTimerEntry ) ) );
	pTimerEntry->Linkage.Initialize();

	return	TRUE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// TimerEntry_Get - get new timer job entry from pool
//
// Entry:		Pointer to new entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"TimerEntry_Get"

void TimerEntry_Get( void *pvItem, void* pvContext )
{
#ifdef DBG
	const TIMER_OPERATION_ENTRY* pTimerEntry = (TIMER_OPERATION_ENTRY*)pvItem;

	DNASSERT( pvItem != NULL );
	DNASSERT( pTimerEntry->pContext == NULL );
	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
#endif // DBG
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// TimerEntry_Release - return timer job entry to pool
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"TimerEntry_Release"
void TimerEntry_Release( void *pvItem )
{
	TIMER_OPERATION_ENTRY* pTimerEntry = (TIMER_OPERATION_ENTRY*)pvItem;

	DNASSERT( pvItem != NULL );
	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );

	pTimerEntry->pContext= NULL;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// TimerEntry_Dealloc - deallocate a timer job entry
//
// Entry:		Pointer to entry
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME	"TimerEntry_Dealloc"
void TimerEntry_Dealloc( void *pvItem )
{
#ifdef DBG
	const TIMER_OPERATION_ENTRY* pTimerEntry = (TIMER_OPERATION_ENTRY*)pvItem;

	DNASSERT( pvItem != NULL );
	DNASSERT( pTimerEntry->Linkage.IsEmpty() != FALSE );
	DNASSERT( pTimerEntry->pContext == NULL );
#endif // DBG
}
//**********************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\threadpool.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ThreadPool.h
 *  Content:	Functions to manage a thread pool
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	03/01/1999	jtk		Derived from Utils.h
 ***************************************************************************/

#ifndef __THREAD_POOL_H__
#define __THREAD_POOL_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward class and structure references
//
class	CSocketPort;
class	CThreadPool;

typedef	void	TIMER_EVENT_CALLBACK( void *const pContext );
typedef	void	TIMER_EVENT_COMPLETE( const HRESULT hCompletionCode, void *const pContext );

typedef struct	_TIMER_OPERATION_ENTRY
{
	CBilink					Linkage;				// list links
	void					*pContext;				// user context passed back in timer events

	//
	// timer information
	//
	UINT_PTR				uRetryCount;			// number of times to retry this event
	BOOL					fRetryForever;			// Boolean for retrying forever
	DWORD					dwRetryInterval;		// time between enums (milliseconds)
	DWORD					dwIdleTimeout;			// time at which the command sits idle after all retrys are complete
	BOOL					fIdleWaitForever;		// Boolean for waiting forever in idle state
	DWORD					dwNextRetryTime;		// time at which this event will fire next (milliseconds)

	TIMER_EVENT_CALLBACK	*pTimerCallback;		// callback for when this event fires
	TIMER_EVENT_COMPLETE	*pTimerComplete;		// callback for when this event is complete

	CThreadPool *			pThreadPool;			// handle to owning thread pool
	PVOID					pvTimerData;			// cancellable handle to timer, or NULL if not scheduled
	UINT					uiTimerUnique;			// uniqueness value for timer
	BOOL					fCancelling;			// boolean denoting whether the timer is cancelling or not
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPU;				// CPU on which timer is scheduled
#endif // ! DPNBUILD_ONLYONEPROCESSOR

	#undef DPF_MODNAME
	#define	DPF_MODNAME	"_TIMER_OPERATION_ENTRY::TimerOperationFromLinkage"
	static _TIMER_OPERATION_ENTRY	*TimerOperationFromLinkage( CBilink *const pLinkage )
	{
		DNASSERT( pLinkage != NULL );
		DBG_CASSERT( OFFSETOF( _TIMER_OPERATION_ENTRY, Linkage ) == 0 );
		return	reinterpret_cast<_TIMER_OPERATION_ENTRY*>( pLinkage );
	}

} TIMER_OPERATION_ENTRY;


#ifndef DPNBUILD_ONLYONETHREAD

typedef	void	BLOCKING_JOB_CALLBACK( void *const pvContext );

typedef struct _BLOCKING_JOB
{
	CBilink					Linkage;					// list links
	void					*pvContext;					// user context passed back in job callback
	BLOCKING_JOB_CALLBACK	*pfnBlockingJobCallback;	// callback for when this job is processed
} BLOCKING_JOB;

#endif // ! DPNBUILD_ONLYONETHREAD


//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

typedef	BOOL	(CSocketPort::*PSOCKET_SERVICE_FUNCTION)( void );
typedef	void	DIALOG_FUNCTION( void *const pDialogContext );

//
// functions for managing the timer data pool
//
BOOL	TimerEntry_Alloc( void *pItem, void* pvContext );
void	TimerEntry_Get( void *pItem, void* pvContext );
void	TimerEntry_Release( void *pItem );
void	TimerEntry_Dealloc( void *pItem );

//**********************************************************************
// Class prototypes
//**********************************************************************

//
// class for thread pool
//
class	CThreadPool
{
	public:
		static BOOL	PoolAllocFunction( void* pvItem, void* pvContext );
		static void	PoolDeallocFunction( void* pvItem );

		void	Lock( void ) { DNEnterCriticalSection( &m_Lock ); }
		void	Unlock( void ) { DNLeaveCriticalSection( &m_Lock ); }

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::AddRef"
		void	AddRef( void ) 
		{ 
			DNInterlockedIncrement( const_cast<LONG*>(&m_iRefCount) ); 
		}

		#undef DPF_MODNAME
		#define DPF_MODNAME "CThreadPool::DecRef"
		void	DecRef( void )
		{
			DNASSERT( m_iRefCount != 0 );
			if ( DNInterlockedDecrement( const_cast<LONG*>(&m_iRefCount) ) == 0 )
			{
				Deinitialize();
				g_ThreadPoolPool.Release( this );
			}
		}


		HRESULT	Initialize( void );
		void	Deinitialize( void );

#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
		CReadIOData * GetNewReadIOData(READ_IO_DATA_POOL_CONTEXT * const pContext, const BOOL fNeedOverlapped );
#else // DPNBUILD_NOWINSOCK2 or DPNBUILD_ONLYWINSOCK2
		CReadIOData * GetNewReadIOData(READ_IO_DATA_POOL_CONTEXT * const pContext);
#endif // DPNBUILD_NOWINSOCK2 or DPNBUILD_ONLYWINSOCK2

		static void ReturnReadIOData(CReadIOData *const pReadIOData);

#ifndef DPNBUILD_ONLYWINSOCK2
		HRESULT	AddSocketPort( CSocketPort *const pSocketPort );

		void	RemoveSocketPort( CSocketPort *const pSocketPort );

		BOOL	CheckWinsock1IO( FD_SET *const pWinsock1Sockets );

		BOOL	ServiceWinsock1Sockets( FD_SET *pSocketSet, PSOCKET_SERVICE_FUNCTION pServiceFunction );

		static void	WINAPI CheckWinsock1IOCallback( void * const pvContext,
											void * const pvTimerData,
											const UINT uiTimerUnique );
#endif // ! DPNBUILD_ONLYWINSOCK2

#ifdef DPNBUILD_ONLYONEPROCESSOR
		HRESULT	SubmitDelayedCommand( const PFNDPTNWORKCALLBACK pFunction,
									void *const pContext );
#else // ! DPNBUILD_ONLYONEPROCESSOR
		HRESULT	SubmitDelayedCommand( const DWORD dwCPU,
									const PFNDPTNWORKCALLBACK pFunction,
									void *const pContext );
#endif // ! DPNBUILD_ONLYONEPROCESSOR

		static void WINAPI GenericTimerCallback( void * const pvContext,
										void * const pvTimerData,
										const UINT uiTimerUnique );

#ifdef DPNBUILD_ONLYONEPROCESSOR
		HRESULT	SubmitTimerJob( const BOOL fPerformImmediately,
								const UINT_PTR uRetryCount,
								const BOOL fRetryForever,
								const DWORD dwRetryInterval,
								const BOOL fIdleWaitForever,
								const DWORD dwIdleTimeout,
								TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
								TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
								void *const pContext );
#else // ! DPNBUILD_ONLYONEPROCESSOR
		HRESULT	SubmitTimerJob( const DWORD dwCPU,
								const BOOL fPerformImmediately,
								const UINT_PTR uRetryCount,
								const BOOL fRetryForever,
								const DWORD dwRetryInterval,
								const BOOL fIdleWaitForever,
								const DWORD dwIdleTimeout,
								TIMER_EVENT_CALLBACK *const pTimerCallbackFunction,
								TIMER_EVENT_COMPLETE *const pTimerCompleteFunction,
								void *const pContext );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		
		BOOL	StopTimerJob( void *const pContext, const HRESULT hCommandResult );

		BOOL	ModifyTimerJobNextRetryTime( void *const pContext,
											DWORD const dwNextRetryTime );

		void	LockTimerData( void ) { DNEnterCriticalSection( &m_TimerDataLock ); }
		void	UnlockTimerData( void ) { DNLeaveCriticalSection( &m_TimerDataLock ); }

#ifndef DPNBUILD_ONLYONETHREAD
		HRESULT	SubmitBlockingJob( BLOCKING_JOB_CALLBACK *const pfnBlockingJobCallback,
									void *const pvContext );

		void	DoBlockingJobs( void );
#endif // ! DPNBUILD_ONLYONETHREAD


#ifndef DPNBUILD_NOSPUI		
		HRESULT	SpawnDialogThread( DIALOG_FUNCTION *const pDialogFunction,
								   void *const pDialogContext );

		static	DWORD WINAPI	DialogThreadProc( void *pParam );
#endif // ! DPNBUILD_NOSPUI

#ifndef DPNBUILD_ONLYONETHREAD
		LONG	GetIntendedThreadCount( void ) const { return m_iIntendedThreadCount; }
		void	SetIntendedThreadCount( const LONG iIntendedThreadCount ) { m_iIntendedThreadCount = iIntendedThreadCount; }
		HRESULT	GetIOThreadCount( LONG *const piThreadCount );
		HRESULT	SetIOThreadCount( const LONG iMaxThreadCount );
#endif // ! DPNBUILD_ONLYONETHREAD
		BOOL IsThreadCountReductionAllowed( void ) const { return m_fAllowThreadCountReduction; }
		HRESULT PreventThreadPoolReduction( void );
#if ((! defined(DPNBUILD_NOMULTICAST)) && (defined(WINNT)))
		BOOL EnsureMadcapLoaded( void );
#endif // ! DPNBUILD_MULTICAST and WINNT
#ifndef DPNBUILD_NONATHELP
		void EnsureNATHelpLoaded( void );
#endif // ! DPNBUILD_NONATHELP

		IDirectPlay8ThreadPoolWork* GetDPThreadPoolWork( void ) const { return m_pDPThreadPoolWork; }

#ifndef DPNBUILD_NONATHELP
		BOOL	IsNATHelpLoaded( void ) const { return m_fNATHelpLoaded; }
		BOOL	IsNATHelpTimerJobSubmitted( void ) const { return m_fNATHelpTimerJobSubmitted; }
		void	SetNATHelpTimerJobSubmitted( BOOL fValue ) { m_fNATHelpTimerJobSubmitted = fValue; }

		void	HandleNATHelpUpdate( DWORD * const pdwTimerInterval );

		static void	PerformSubsequentNATHelpGetCaps( void * const pvContext );
		static void	NATHelpTimerComplete( const HRESULT hResult, void * const pContext );
		static void	NATHelpTimerFunction( void * const pContext );
#endif // DPNBUILD_NONATHELP

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
		BOOL	IsMadcapLoaded( void ) const { return m_fMadcapLoaded; }
#endif // WINNT and not DPNBUILD_NOMULTICAST


	private:
		BYTE							m_Sig[4];							// debugging signature ('THPL')
		volatile LONG					m_iRefCount;						// reference count
		IDirectPlay8ThreadPoolWork *	m_pDPThreadPoolWork;				// pointer to DirectPlay Thread Pool Work interface
		BOOL							m_fAllowThreadCountReduction;		// boolean indicating that the thread count is locked from being reduced
#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION				m_Lock;								// local object lock
		LONG							m_iIntendedThreadCount;				// how many threads will be started
		DNCRITICAL_SECTION				m_TimerDataLock;					// lock protecting timer data
#endif // ! DPNBUILD_ONLYONETHREAD
		CBilink							m_TimerJobList;						// list of current active timer jobs
#ifndef DPNBUILD_NONATHELP
		BOOL							m_fNATHelpLoaded;					// boolean indicating whether the NAT Help interface has been loaded
		BOOL							m_fNATHelpTimerJobSubmitted;		// whether the NAT Help refresh timer has been submitted or not
		DWORD							m_dwNATHelpUpdateThreadID;			// ID of current thread updating NAT Help status, or 0 if none
#endif // DPNBUILD_NONATHELP
#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
		BOOL							m_fMadcapLoaded;					// boolean indicating whether the MADCAP API has been loaded
#endif // WINNT and not DPNBUILD_NOMULTICAST

#ifndef DPNBUILD_ONLYWINSOCK2
		UINT_PTR						m_uReservedSocketCount;				// count of sockets that are 'reserved' for use
		FD_SET							m_SocketSet;						// set of all sockets in use
		CSocketPort *					m_pSocketPorts[FD_SETSIZE];			// set of corresponding socket ports
		PVOID							m_pvTimerDataWinsock1IO;			// cancellable handle to Winsock 1 I/O poll timer
		UINT							m_uiTimerUniqueWinsock1IO;			// uniqueness value for Winsock 1 I/O poll timer
		BOOL							m_fCancelWinsock1IO;				// whether the Winsock 1 I/O poll timer should be cancelled or not
#endif // ! DPNBUILD_ONLYWINSOCK2

#ifndef DPNBUILD_ONLYONETHREAD
		DNCRITICAL_SECTION				m_csBlockingJobLock;				// lock protecting blocking job queue information
		CBilink							m_blBlockingJobQueue;					// queue of blocking jobs
		DNHANDLE						m_hBlockingJobThread;				// handle to blocking job thread
		DNHANDLE						m_hBlockingJobEvent;				// handle to event used to signal blocking job thread
#endif // ! DPNBUILD_ONLYONETHREAD
};




#undef DPF_MODNAME

#endif	// __THREAD_POOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\wsocksp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   WSockSP.h
 *  Content:	declaration of DN Winsock SP functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/26/98	jwo		Created it.
 ***************************************************************************/

#ifndef __WSOCKSP_H__
#define __WSOCKSP_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************
STDMETHODIMP DNSP_Initialize( IDP8ServiceProvider*, SPINITIALIZEDATA* );
STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider* pDNSP );
STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider* pDNSP );
STDMETHODIMP DNSP_Connect( IDP8ServiceProvider*, SPCONNECTDATA* );
STDMETHODIMP DNSP_Disconnect( IDP8ServiceProvider*, SPDISCONNECTDATA* );
STDMETHODIMP DNSP_Listen( IDP8ServiceProvider*, SPLISTENDATA* );
STDMETHODIMP DNSP_EnumQuery( IDP8ServiceProvider*, SPENUMQUERYDATA* );
STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider*, SPENUMRESPONDDATA* );
STDMETHODIMP DNSP_SendData( IDP8ServiceProvider*, SPSENDDATA* );
STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider*, HANDLE, DWORD );
STDMETHODIMP DNSP_Close( IDP8ServiceProvider* );
STDMETHODIMP DNSP_GetCaps( IDP8ServiceProvider*, SPGETCAPSDATA* );
STDMETHODIMP DNSP_SetCaps( IDP8ServiceProvider*, SPSETCAPSDATA* );
STDMETHODIMP DNSP_ReturnReceiveBuffers( IDP8ServiceProvider*, SPRECEIVEDBUFFER* );
STDMETHODIMP DNSP_GetAddressInfo( IDP8ServiceProvider*, SPGETADDRESSINFODATA* );
STDMETHODIMP DNSP_Update( IDP8ServiceProvider*, SPUPDATEDATA* );
#ifndef DPNBUILD_LIBINTERFACE
STDMETHODIMP DNSP_IsApplicationSupported( IDP8ServiceProvider*, SPISAPPLICATIONSUPPORTEDDATA* );
#endif // ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONEADAPTER
STDMETHODIMP DNSP_EnumAdapters( IDP8ServiceProvider*, SPENUMADAPTERSDATA* );
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_SINGLEPROCESS
STDMETHODIMP DNSP_ProxyEnumQuery( IDP8ServiceProvider*, SPPROXYENUMQUERYDATA* );
#endif // ! DPNBUILD_SINGLEPROCESS

STDMETHODIMP DNSP_NotSupported( IDP8ServiceProvider*, PVOID );

#ifndef DPNBUILD_NOMULTICAST
STDMETHODIMP DNSP_EnumMulticastScopes( IDP8ServiceProvider*, SPENUMMULTICASTSCOPESDATA* );
STDMETHODIMP DNSP_ShareEndpointInfo( IDP8ServiceProvider*, SPSHAREENDPOINTINFODATA* );
STDMETHODIMP DNSP_GetEndpointByAddress( IDP8ServiceProvider*, SPGETENDPOINTBYADDRESSDATA* );
#endif // ! DPNBUILD_NOMULTICAST


#endif	// __WSOCKSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\unk.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		Unk.cpp
 *  Content:	IUnknown implementation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  08/06/00    RichGr  IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 ***************************************************************************/

#include "dnwsocki.h"

#ifndef DPNBUILD_NOIPX
#define DPN_REG_LOCAL_WSOCK_IPX_ROOT		L"\\DPNSPWinsockIPX"
#endif // ! DPNBUILD_NOIPX
#ifndef DPNBUILD_NOIPV6
#define DPN_REG_LOCAL_WSOCK_IPV6_ROOT		L"\\DPNSPWinsockIPv6"
#endif // ! DPNBUILD_NOIPV6
#define DPN_REG_LOCAL_WSOCK_TCPIP_ROOT		L"\\DPNSPWinsockTCP"

#if ((! defined(WINCE)) && (! defined(_XBOX)))

#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH

HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString );

#endif // ! WINCE and ! _XBOX



#undef DPF_MODNAME
#define DPF_MODNAME "DNWsockInit"
BOOL DNWsockInit(HANDLE hModule)
{
	DNASSERT( hModule != NULL );
#ifdef _XBOX
	XDP8STARTUP_PARAMS *		pStartupParams;
	XNetStartupParams			xnsp;
	int							iResult;


	//
	// The instance handle is actually a pointer to the startup parameters.
	//
	pStartupParams = (XDP8STARTUP_PARAMS*) hModule;


	//
	// Initialize the Xbox networking layer, unless we were forbidden.
	//

	if (! (pStartupParams->dwFlags & XDP8STARTUP_BYPASSXNETSTARTUP))
	{
		memset(&xnsp, 0, sizeof(xnsp));
		xnsp.cfgSizeOfStruct = sizeof(xnsp);

#pragma TODO(vanceo, "Does this actually do anything?")
		if (pStartupParams->dwFlags & XDP8STARTUP_BYPASSSECURITY)
		{
			xnsp.cfgFlags |= XNET_STARTUP_BYPASS_SECURITY;
		}

		DPFX(DPFPREP, 1, "Initializing Xbox networking layer.");

		iResult = XNetStartup(&xnsp);
		if (iResult != 0)
		{
			DPFX(DPFPREP, 0, "Couldn't start XNet (err = %i)!", iResult);
			return FALSE;
		}

		g_fStartedXNet = TRUE;
	}
#else // ! _XBOX
#ifndef WINCE
	DNASSERT( g_hDLLInstance == NULL );
	g_hDLLInstance = (HINSTANCE) hModule;
#endif // ! WINCE
#endif // ! _XBOX

	//
	// attempt to initialize process-global items
	//
	if ( InitProcessGlobals() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to initialize globals!" );

#ifdef _XBOX
		if (g_fStartedXNet)
		{
			XNetCleanup();
		}
#endif // _XBOX
		return FALSE;
	}
	
#ifdef DPNBUILD_LIBINTERFACE
	//
	// Attempt to load Winsock.
	//
	if ( LoadWinsock() == FALSE )
	{
		DPFX(DPFPREP, 0, "Failed to load winsock!" );

		DeinitProcessGlobals();
#ifdef _XBOX
		if (g_fStartedXNet)
		{
			XNetCleanup();
		}
#endif // _XBOX
		return FALSE;
	}
#endif // DPNBUILD_LIBINTERFACE

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	//
	// Pre-allocate a threadpool object.
	//
	if  ( g_ThreadPoolPool.Preallocate( 1, NULL ) < 1 )
	{
		DPFX(DPFPREP, 0, "Failed to preallocate a threadpool object!" );

#ifdef DPNBUILD_LIBINTERFACE
		UnloadWinsock();
#endif // DPNBUILD_LIBINTERFACE
		DeinitProcessGlobals();
#ifdef _XBOX
		if (g_fStartedXNet)
		{
			XNetCleanup();
		}
#endif // _XBOX
		return FALSE;
	}
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNWsockDeInit"
void DNWsockDeInit()
{
	DPFX(DPFPREP, 5, "Deinitializing Wsock SP");

#if ((! defined(WINCE)) && (! defined(_XBOX)))
	DNASSERT( g_hDLLInstance != NULL );
	g_hDLLInstance = NULL;
#endif // ! WINCE and ! _XBOX
	
#ifdef DPNBUILD_LIBINTERFACE
	//
	// Unload Winsock.
	//
	UnloadWinsock();
#endif // DPNBUILD_LIBINTERFACE

	DeinitProcessGlobals();

#ifdef _XBOX
	//
	// Clean up the Xbox networking layer if we started it.
	//
	if (g_fStartedXNet)
	{
		DPFX(DPFPREP, 1, "Cleaning up Xbox networking layer.");
#ifdef DBG
		DNASSERT(XNetCleanup() == 0);
#else // ! DBG
		XNetCleanup();
#endif // ! DBG
		g_fStartedXNet = FALSE;
	}
#endif // _XBOX
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DNWsockRegister"
BOOL DNWsockRegister(LPCWSTR wszDLLName)
{
	HRESULT hr = S_OK;
	BOOL fReturn = TRUE;
	CRegistry creg;
#if ((! defined(WINCE)) && (! defined(_XBOX)))
	WCHAR *wszFriendlyName = NULL;
#endif // ! WINCE and ! _XBOX


#ifndef DPNBUILD_NOIPX
	if( !CRegistry::Register( L"DirectPlay8SPWSock.IPX.1", L"DirectPlay8 WSock IPX Provider Object",
							  wszDLLName, &CLSID_DP8SP_IPX, L"DirectPlay8SPWSock.IPX") )
	{
		DPFERR( "Could not register dp8 IPX object" );
		fReturn = FALSE;
	}
#endif // ! DPNBUILD_NOIPX

	if( !CRegistry::Register( L"DirectPlay8SPWSock.TCPIP.1", L"DirectPlay8 WSock TCPIP Provider Object",
							  wszDLLName, &CLSID_DP8SP_TCPIP, L"DirectPlay8SPWSock.TCPIP") )
	{
		DPFERR( "Could not register dp8 IP object" );
		fReturn = FALSE;
	}

#ifndef DPNBUILD_NOIPX
	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_WSOCK_IPX_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create IPX sub-area!" );
		fReturn = FALSE;
	}
	else
	{
#if ((! defined(WINCE)) && (! defined(_XBOX)))
		hr = LoadAndAllocString( IDS_FRIENDLYNAME_IPX, &wszFriendlyName );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP, 0, "Could not load IPX name!  hr=0x%x", hr );
			fReturn = FALSE;
		}
		else
		{
			// Load from resource file
			creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );

			delete [] wszFriendlyName;

			creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
		}
#else // ! WINCE and ! _XBOX
		// Don't use the resource, just do it directly
		creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, L"DirectPlay8 IPX Service Provider" );
		creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_IPX );
#endif // ! WINCE and ! _XBOX

		creg.Close();
	}
#endif // ! DPNBUILD_NOIPX

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY DPN_REG_LOCAL_WSOCK_TCPIP_ROOT, FALSE, TRUE ) )
	{
		DPFERR( "Cannot create TCPIP sub-area!" );
		fReturn = FALSE;
	}
	else
	{
#if ((! defined(WINCE)) && (! defined(_XBOX)))
		hr = LoadAndAllocString( IDS_FRIENDLYNAME_TCPIP, &wszFriendlyName );

		if( FAILED( hr ) )
		{
			DPFX(DPFPREP, 0, "Could not load IPX name!  hr=0x%x", hr );
			fReturn = FALSE;
		}
		else
		{
			// Load from resource file
			creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, wszFriendlyName );

			delete [] wszFriendlyName;

			creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
		}
#else // ! WINCE and ! _XBOX
		// Don't use the resource, just do it directly
		creg.WriteString( DPN_REG_KEYNAME_FRIENDLY_NAME, L"DirectPlay8 TCP/IP Service Provider" );
		creg.WriteGUID( DPN_REG_KEYNAME_GUID, CLSID_DP8SP_TCPIP );
#endif // ! WINCE and ! _XBOX

		creg.Close();
	}
	
	return fReturn;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNWsockUnRegister"
BOOL DNWsockUnRegister()
{
	HRESULT hr = S_OK;
	BOOL fReturn = TRUE;

#ifndef DPNBUILD_NOIPX
	if( !CRegistry::UnRegister(&CLSID_DP8SP_IPX) )
	{
		DPFX(DPFPREP, 0, "Failed to unregister IPX object" );
		fReturn = FALSE;
	}
#endif // ! DPNBUILD_NOIPX

	if( !CRegistry::UnRegister(&CLSID_DP8SP_TCPIP) )
	{
		DPFX(DPFPREP, 0, "Failed to unregister IP object" );
		fReturn = FALSE;
	}

	CRegistry creg;

	if( !creg.Open( HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, TRUE ) )
	{
		DPFERR( "Cannot remove app, does not exist" );
	}
	else
	{
#ifndef DPNBUILD_NOIPX
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_WSOCK_IPX_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove IPX sub-key, could have elements" );
		}
#endif // ! DPNBUILD_NOIPX

#pragma TODO(vanceo, "Uncomment IPv6 when ready")
/*
#ifndef DPNBUILD_NOIPV6
		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_WSOCK_IPV6_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove IPv6 sub-key, could have elements" );
		}
#endif // ! DPNBUILD_NOIPV6
*/

		if( !creg.DeleteSubKey( &(DPN_REG_LOCAL_WSOCK_TCPIP_ROOT)[1] ) )
		{
			DPFERR( "Cannot remove TCPIP sub-key, could have elements" );
		}
	}

	return fReturn;
}

#endif // ! DPNBUILD_NOCOMREGISTER


#ifndef DPNBUILD_LIBINTERFACE
#undef DPF_MODNAME
#define DPF_MODNAME "DNWsockGetRemainingObjectCount"
DWORD DNWsockGetRemainingObjectCount()
{
	return g_lOutstandingInterfaceCount;
}
#endif // ! DPNBUILD_LIBINTERFACE


//**********************************************************************
// Constant definitions
//**********************************************************************

#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif // __MWERKS__

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj);

#define NOTSUPPORTED(parm)	(HRESULT (__stdcall *) (struct IDP8ServiceProvider *, parm)) DNSP_NotSupported


//**********************************************************************
// Function definitions
//**********************************************************************

// these are the vtables for the various WSock service providers  One or the
// other is used depending on what is passed to DoCreateInstance.
#ifndef DPNBUILD_NOIPX
static IDP8ServiceProviderVtbl	ipxInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
	NOTSUPPORTED(PSPENUMMULTICASTSCOPESDATA),		// EnumMulticastScopes
	NOTSUPPORTED(PSPSHAREENDPOINTINFODATA),			// ShareEndpointInfo
	NOTSUPPORTED(PSPGETENDPOINTBYADDRESSDATA),		// GetEndpointByAddress
	DNSP_Update,
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
#ifdef DPNBUILD_LIBINTERFACE
	NOTSUPPORTED(PSPISAPPLICATIONSUPPORTEDDATA),	// IsApplicationSupported
#else // ! DPNBUILD_LIBINTERFACE
	DNSP_IsApplicationSupported,
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_ONLYONEADAPTER
	NOTSUPPORTED(PSPENUMADAPTERSDATA),				// EnumAdapters
#else // ! DPNBUILD_ONLYONEADAPTER
	DNSP_EnumAdapters,
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_SINGLEPROCESS
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA),			// ProxyEnumQuery
#else // ! DPNBUILD_SINGLEPROCESS
	DNSP_ProxyEnumQuery
#endif // ! DPNBUILD_SINGLEPROCESS
};
#endif // DPNBUILD_NOIPX

#ifndef DPNBUILD_NOIPV6
static IDP8ServiceProviderVtbl	ipv6Interface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
#ifdef DPNBUILD_NOMULTICAST
	NOTSUPPORTED(PSPENUMMULTICASTSCOPESDATA),		// EnumMulticastScopes
	NOTSUPPORTED(PSPSHAREENDPOINTINFODATA),			// ShareEndpointInfo
	NOTSUPPORTED(PSPGETENDPOINTBYADDRESSDATA),		// GetEndpointByAddress
#else // ! DPNBUILD_NOMULTICAST
	DNSP_EnumMulticastScopes,
	DNSP_ShareEndpointInfo,
	DNSP_GetEndpointByAddress,
#endif // ! DPNBUILD_NOMULTICAST
	DNSP_Update,
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
#ifdef DPNBUILD_LIBINTERFACE
	NOTSUPPORTED(PSPISAPPLICATIONSUPPORTEDDATA),	// IsApplicationSupported
#else // ! DPNBUILD_LIBINTERFACE
	DNSP_IsApplicationSupported,
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_ONLYONEADAPTER
	NOTSUPPORTED(PSPENUMADAPTERSDATA),				// EnumAdapters
#else // ! DPNBUILD_ONLYONEADAPTER
	DNSP_EnumAdapters,
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_SINGLEPROCESS
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA),			// ProxyEnumQuery
#else // ! DPNBUILD_SINGLEPROCESS
	DNSP_ProxyEnumQuery
#endif // ! DPNBUILD_SINGLEPROCESS
};
#endif // DPNBUILD_NOIPV6

static IDP8ServiceProviderVtbl	ipInterface =
{
	DNSP_QueryInterface,
	DNSP_AddRef,
	DNSP_Release,
	DNSP_Initialize,
	DNSP_Close,
	DNSP_Connect,
	DNSP_Disconnect,
	DNSP_Listen,
	DNSP_SendData,
	DNSP_EnumQuery,
	DNSP_EnumRespond,
	DNSP_CancelCommand,
#ifdef DPNBUILD_NOMULTICAST
	NOTSUPPORTED(PSPENUMMULTICASTSCOPESDATA),		// EnumMulticastScopes
	NOTSUPPORTED(PSPSHAREENDPOINTINFODATA),			// ShareEndpointInfo
	NOTSUPPORTED(PSPGETENDPOINTBYADDRESSDATA),		// GetEndpointByAddress
#else // ! DPNBUILD_NOMULTICAST
	DNSP_EnumMulticastScopes,
	DNSP_ShareEndpointInfo,
	DNSP_GetEndpointByAddress,
#endif // ! DPNBUILD_NOMULTICAST
	DNSP_Update,
	DNSP_GetCaps,
	DNSP_SetCaps,
	DNSP_ReturnReceiveBuffers,
	DNSP_GetAddressInfo,
#ifdef DPNBUILD_LIBINTERFACE
	NOTSUPPORTED(PSPISAPPLICATIONSUPPORTEDDATA),	// IsApplicationSupported
#else // ! DPNBUILD_LIBINTERFACE
	DNSP_IsApplicationSupported,
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_ONLYONEADAPTER
	NOTSUPPORTED(PSPENUMADAPTERSDATA),				// EnumAdapters
#else // ! DPNBUILD_ONLYONEADAPTER
	DNSP_EnumAdapters,
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifdef DPNBUILD_SINGLEPROCESS
	NOTSUPPORTED(PSPPROXYENUMQUERYDATA),			// ProxyEnumQuery
#else // ! DPNBUILD_SINGLEPROCESS
	DNSP_ProxyEnumQuery
#endif // ! DPNBUILD_SINGLEPROCESS
};

//**********************************************************************
// ------------------------------
// DNSP_QueryInterface - query for interface
//
// Entry:		Pointer to current interface
//				GUID of desired interface
//				Pointer to pointer to new interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNSP_QueryInterface"

STDMETHODIMP DNSP_QueryInterface( IDP8ServiceProvider *lpDNSP, REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = S_OK;


#ifndef DPNBUILD_LIBINTERFACE
	// hmmm, switch would be cleaner...
	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8ServiceProvider)))
	{
		*ppvObj = NULL;
		hr = E_NOINTERFACE;		
	}
	else
#endif // ! DPNBUILD_LIBINTERFACE
	{
#ifdef DPNBUILD_LIBINTERFACE
		DNASSERT(! "Querying SP interface when using DPNBUILD_LIBINTERFACE!");
#endif // DPNBUILD_LIBINTERFACE
		*ppvObj = lpDNSP;
		DNSP_AddRef(lpDNSP);
	}

	return hr;
}
//**********************************************************************

#ifndef DPNBUILD_NOIPX
//**********************************************************************
// ------------------------------
// CreateIPXInterface - create an IPX interface
//
// Entry:		Pointer to pointer to SP interface
//				Pointer to pointer to associated SP data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateIPXInterface"

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateIPXInterface( const XDP8CREATE_PARAMS * const pDP8CreateParams, IDP8ServiceProvider **const ppiDP8SP )
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateIPXInterface( IDP8ServiceProvider **const ppiDP8SP )
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	HRESULT 	hr;
	CSPData		*pSPData;


	DNASSERT( ppiDP8SP != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDP8SP = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData,
						AF_IPX,
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
						pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
						&ipxInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData == NULL );
		DPFX(DPFPREP, 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDP8SP = pSPData->COMInterface();

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************
#endif // ! DPNBUILD_NOIPX



//**********************************************************************
// ------------------------------
// CreateIPInterface - create an IP interface
//
// Entry:		Pointer to pointer to SP interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "CreateIPInterface"

#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateIPInterface( const XDP8CREATE_PARAMS * const pDP8CreateParams, IDP8ServiceProvider **const ppiDP8SP )
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
HRESULT CreateIPInterface( IDP8ServiceProvider **const ppiDP8SP )
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
{
	HRESULT 	hr;
	CSPData		*pSPData;

	
	DNASSERT( ppiDP8SP != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = NULL;
	*ppiDP8SP = NULL;

	//
	// create main data class
	//
	hr = CreateSPData( &pSPData,
#if ((! defined(DPNBUILD_NOIPX)) || (! defined(DPNBUILD_NOIPV6)))
						AF_INET,
#endif // ! DPNBUILD_NOIPX or ! DPNBUILD_NOIPV6
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
						pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
						&ipInterface );
	if ( hr != DPN_OK )
	{
		DNASSERT( pSPData == NULL );
		DPFX(DPFPREP, 0, "Problem creating SPData!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}

	DNASSERT( pSPData != NULL );
	*ppiDP8SP = pSPData->COMInterface();

Exit:
	return hr;

Failure:
	if ( pSPData != NULL )
	{
		pSPData->DecRef();
		pSPData = NULL;
	}

	goto Exit;
}
//**********************************************************************



#ifndef DPNBUILD_LIBINTERFACE

//**********************************************************************
// ------------------------------
// DoCreateInstance - create an instance of an interface
//
// Entry:		Pointer to class factory
//				Pointer to unknown interface
//				Refernce of GUID of desired interface
//				Reference to another GUID?
//				Pointer to pointer to interface
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
HRESULT DoCreateInstance( LPCLASSFACTORY This,
						  LPUNKNOWN pUnkOuter,
						  REFCLSID rclsid,
						  REFIID riid,
						  LPVOID *ppvObj )
{
	HRESULT		hr;


	DNASSERT( ppvObj != NULL );

	//
	// initialize
	//
	*ppvObj = NULL;

	//
	// we can either create an IPX instance or an IP instance
	//
	if (IsEqualCLSID(rclsid, CLSID_DP8SP_TCPIP))
	{
		hr = CreateIPInterface( reinterpret_cast<IDP8ServiceProvider**>( ppvObj ) );
	}
#ifndef DPNBUILD_NOIPX
	else if (IsEqualCLSID(rclsid, CLSID_DP8SP_IPX))
	{
		hr = CreateIPXInterface( reinterpret_cast<IDP8ServiceProvider**>( ppvObj ) );
	}
#endif // ! DPNBUILD_NOIPX
	else
	{
		// this shouldn't happen if they called IClassFactory::CreateObject correctly
		DPFX(DPFPREP, 0, "Got unexpected CLSID!");
		hr = E_UNEXPECTED;
	}

	return hr;
}
//**********************************************************************

#endif // ! DPNBUILD_LIBINTERFACE



#if ((! defined(WINCE)) && (! defined(_XBOX)))

#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH

#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"

HRESULT LoadAndAllocString( UINT uiResourceID, wchar_t **lpswzString )
{
	int length;
	HRESULT hr;

	TCHAR szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		
	length = LoadString( g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );

	if( length == 0 )
	{
		hr = GetLastError();		
		
		DPFX(DPFPREP, 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr );
		*lpswzString = NULL;

		return DPNERR_GENERIC;
	}
	else
	{
		*lpswzString = new wchar_t[length+1];

		if( *lpswzString == NULL )
		{
			DPFX(DPFPREP, 0, "Alloc failure" );
			return DPNERR_OUTOFMEMORY;
		}

#ifdef UNICODE
		wcscpy( *lpswzString, szTmpBuffer );
#else // !UNICODE
		if( STR_jkAnsiToWide( *lpswzString, szTmpBuffer, length+1 ) != DPN_OK )
		{
			hr = GetLastError();
			
			delete[] *lpswzString;
			*lpswzString = NULL;

			DPFX(DPFPREP, 0, "Unable to upconvert from ansi to unicode hr=0x%x", hr );
			return DPNERR_GENERIC;
		}
#endif // !UNICODE

		return DPN_OK;
	}
}

#endif // !WINCE and ! _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\wsocksp.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       WSockSP.cpp
 *  Content:	Protocol-independent APIs for the DN Winsock SP
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/26/1998	jwo		Created it.
 *	11/1/1998	jwo		Un-subclassed everything (moved it to this generic
 *						file from IP and IPX specific ones
 *	03/22/2000	jtk		Updated with changes to interface names
 *	04/22/2000	mjn		Allow all flags in DNSP_GetAddressInfo()
 *	08/06/2000	RichGr	IA64: Use %p format specifier in DPFs for 32/64-bit pointers and handles.
 *	03/12/2001	mjn		Prevent enum responses from being indicated up after completion
 ***************************************************************************/

#include "dnwsocki.h"



//**********************************************************************
// Constant definitions
//**********************************************************************

//
// maximum bandwidth in bits per second
//
#define	UNKNOWN_BANDWIDTH	0

#define WAIT_FOR_CLOSE_TIMEOUT 30000		// milliseconds

#define	ADDRESS_ENCODE_KEY	0

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Initialize initializes the instance of the SP.  It must be called
 *		at least once before using any other functions.  Further attempts
 *		to initialize the SP are ignored.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Initialize"

STDMETHODIMP DNSP_Initialize( IDP8ServiceProvider *pThis, SPINITIALIZEDATA *pData )
{
	HRESULT			hr;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pData);

	DNASSERT( pThis != NULL );
	DNASSERT( pData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	// Trust protocol to call us only in the uninitialized state
	DNASSERT( pSPData->GetState() == SPSTATE_UNINITIALIZED );

	//
	// prevent anyone else from messing with this interface
	//
	pSPData->Lock();

	hr = pSPData->Startup( pData );
	if (hr != DPN_OK)
	{
		goto Failure;
	}

	pSPData->Unlock();

	IDP8ServiceProvider_AddRef( pThis );

Exit:

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);
	
	return hr;

Failure:
	pSPData->Unlock();
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Close is the opposite of Initialize.  Call it when you're done
 *		using the SP
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Close"

STDMETHODIMP DNSP_Close( IDP8ServiceProvider *pThis )
{
	HRESULT		hr;
	CSPData		*pSPData;
	
	
	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	pSPData->Shutdown();
	IDP8ServiceProvider_Release( pThis );
			
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_AddRef - increment reference count
//
// Entry:		Pointer to interface
//
// Exit:		New reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_AddRef"

STDMETHODIMP_(ULONG) DNSP_AddRef( IDP8ServiceProvider *pThis )
{	
	CSPData *	pSPData;
	ULONG		ulResult;


	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->AddRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);

	return ulResult;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_Release - decrement reference count
//
// Entry:		Pointer to interface
//
// Exit:		New reference count
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Release"

STDMETHODIMP_(ULONG) DNSP_Release( IDP8ServiceProvider *pThis )
{
	CSPData *	pSPData;
	ULONG		ulResult;

	
	DPFX(DPFPREP, 2, "Parameters: (0x%p)", pThis);

	DNASSERT( pThis != NULL );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	
	ulResult = pSPData->DecRef();

	
	DPFX(DPFPREP, 2, "Returning: [0x%u]", ulResult);

	return ulResult;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_EnumQuery  sends out the
 *		specified data to the specified address.  If the SP is unable to
 *		determine the address based on the input params, it checks to see
 *		if it's allowed to put up a dialog querying the user for address
 *		info.  If it is, it queries the user for address info.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumQuery"

STDMETHODIMP DNSP_EnumQuery( IDP8ServiceProvider *pThis, SPENUMQUERYDATA *pEnumQueryData)
{
	HRESULT					hr;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;
#ifndef DPNBUILD_NONATHELP
	DWORD					dwTraversalMode;
	DWORD					dwComponentSize;
	DWORD					dwComponentType;
#endif // ! DPNBUILD_NONATHELP
#ifdef DBG
	DWORD					dwAllowedFlags;
	DWORD					dwTotalBufferSize;
	DWORD					dwTemp;
#endif // DBG


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumQueryData != NULL );
	DNASSERT( pEnumQueryData->pAddressHost != NULL );
	DNASSERT( pEnumQueryData->pAddressDeviceInfo != NULL );

#ifdef DBG
	dwAllowedFlags = DPNSPF_NOBROADCASTFALLBACK | DPNSPF_SESSIONDATA;
#ifndef DPNBUILD_NOSPUI
	dwAllowedFlags |= DPNSPF_OKTOQUERY;
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_ONLYONEADAPTER
	dwAllowedFlags |= DPNSPF_ADDITIONALMULTIPLEXADAPTERS;
#endif // ! DPNBUILD_ONLYONEADAPTER

	DNASSERT( ( pEnumQueryData->dwFlags & ~( dwAllowedFlags ) ) == 0 );

	if ( pEnumQueryData->dwFlags & DPNSPF_SESSIONDATA )
	{
		DNASSERT( pEnumQueryData->pvSessionData!= NULL );
		DNASSERT( pEnumQueryData->dwSessionDataSize > 0 );
	}
#endif // DBG

	DBG_CASSERT( sizeof( pEnumQueryData->dwRetryInterval ) == sizeof( DWORD ) );


#ifndef DPNBUILD_NOREGISTRY
	//
	// Make sure someone isn't getting silly.
	//
	if ( g_fIgnoreEnums )
	{
		DPFX(DPFPREP, 0, "Trying to initiate an enumeration when registry option to ignore all enums/response is set!");
		DNASSERT( ! "Trying to initiate an enumeration when registry option to ignore all enums/response is set!" );
	}
#endif // ! DPNBUILD_NOREGISTRY
	

	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( pSPData != NULL );

	pEnumQueryData->hCommand = NULL;
	pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, _T("Enum destination:"), pEnumQueryData->pAddressHost );
	DumpAddress( 8, _T("Enuming on device:"), pEnumQueryData->pAddressDeviceInfo );


	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );
	

	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.  This also performs other
	// first time initialization.
	//
	hr = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


#ifdef DBG
	//
	// Make sure message is not too large.
	//
	dwTotalBufferSize = 0;
	for(dwTemp = 0; dwTemp < pEnumQueryData->dwBufferCount; dwTemp++)
	{
		dwTotalBufferSize += pEnumQueryData->pBuffers[dwTemp].dwBufferSize;
	}

#ifdef DPNBUILD_NOREGISTRY
	DNASSERT(dwTotalBufferSize <= DEFAULT_MAX_ENUM_DATA_SIZE);
#else // ! DPNBUILD_NOREGISTRY
	DNASSERT(dwTotalBufferSize <= g_dwMaxEnumDataSize);
#endif // ! DPNBUILD_NOREGISTRY
#endif // DBG


	//
	// create and new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot create new endpoint in DNSP_EnumQuery!" );
		goto Failure;
	}

	
#ifndef DPNBUILD_NONATHELP
	//
	// We need to detect up front whether NAT traversal is disabled or not so we can optimize
	// the Open call below.
	//
	dwComponentSize = sizeof(dwTraversalMode);
	hr = IDirectPlay8Address_GetComponentByName(pEnumQueryData->pAddressDeviceInfo,
												DPNA_KEY_TRAVERSALMODE,
												&dwTraversalMode,
												&dwComponentSize,
												&dwComponentType);
	if ( hr == DPN_OK )
	{
		//
		// We found the component.  Make sure it's the right size and type.
		//
		if ((dwComponentSize == sizeof(dwTraversalMode)) && (dwComponentType == DPNA_DATATYPE_DWORD))
		{
			switch (dwTraversalMode)
			{
				case DPNA_TRAVERSALMODE_NONE:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is NONE.");
					break;
				}

				case DPNA_TRAVERSALMODE_PORTREQUIRED:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is PORTREQUIRED.");
					break;
				}

				case DPNA_TRAVERSALMODE_PORTRECOMMENDED:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is PORTRECOMMENDED.");
					break;
				}

				default:
				{
					DPFX(DPFPREP, 0, "Ignoring correctly formed traversal mode key with invalid value %u!  Using default mode %u.",
						dwTraversalMode, g_dwDefaultTraversalMode);
					dwTraversalMode = g_dwDefaultTraversalMode;
					break;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 0, "Traversal mode key exists, but doesn't match expected type (%u != %u) or size (%u != %u)!  Using default mode %u.",
				dwComponentSize, sizeof(dwTraversalMode),
				dwComponentType, DPNA_DATATYPE_DWORD,
				g_dwDefaultTraversalMode);
			dwTraversalMode = g_dwDefaultTraversalMode;
		}
	}
	else
	{
		//
		// The key is not there, it's the wrong size (too big for our buffer
		// and returned BUFFERTOOSMALL), or something else bad happened.
		// It doesn't matter.  Carry on.
		//
		DPFX(DPFPREP, 8, "Could not get traversal mode key, error = 0x%lx, component size = %u, type = %u, using default mode %u.",
			hr, dwComponentSize, dwComponentType, g_dwDefaultTraversalMode);
		dwTraversalMode = g_dwDefaultTraversalMode;
	}
	
	if (g_dwDefaultTraversalMode & FORCE_TRAVERSALMODE_BIT)
	{
		DPFX(DPFPREP, 1, "Forcing traversal mode %u.");
		dwTraversalMode = g_dwDefaultTraversalMode & (~FORCE_TRAVERSALMODE_BIT);
	}
	
	pEndpoint->SetUserTraversalMode(dwTraversalMode);
#endif // ! DPNBUILD_NONATHELP


	//
	// get new command and initialize it
	//
	pCommand = (CCommandData*)g_CommandDataPool.Get();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get command handle for DNSP_EnumQuery!" );
		goto Failure;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Enum query command 0x%p created.",
		pSPData, pCommand);

	pEnumQueryData->hCommand = pCommand;
	pEnumQueryData->dwCommandDescriptor = pCommand->GetDescriptor();
	pCommand->SetType( COMMAND_TYPE_ENUM_QUERY );
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
	hr = pEndpoint->Open( ENDPOINT_TYPE_ENUM,
						pEnumQueryData->pAddressHost,
						((pEnumQueryData->dwFlags & DPNSPF_SESSIONDATA) ? pEnumQueryData->pvSessionData: NULL),
						((pEnumQueryData->dwFlags & DPNSPF_SESSIONDATA) ? pEnumQueryData->dwSessionDataSize : 0),
						NULL );
	switch ( hr )
	{
		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  If we're on IPX (no dialog available), don't attempt
		// to display the dialog, skip to checking for broadcast fallback.
		// Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
#ifndef DPNBUILD_NOSPUI
			if ( ( ( pEnumQueryData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
#ifdef DPNBUILD_NOIPV6
				&& (( pSPData->GetType() == AF_INET6 ) || ( pSPData->GetType() == AF_INET ))
#else // ! DPNBUILD_NOIPV6
				&& ( pSPData->GetType() == AF_INET )
#endif // ! DPNBUILD_NOIPV6
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
				)
			{
				//
				// Copy the connect data locally and start the dialog.  When the
				// dialog completes, the connection will attempt to complete.
				// Since the dialog is being popped, this command is in progress,
				// not pending.
				//
				DNASSERT( pSPData != NULL );

				pCommand->SetState( COMMAND_STATE_INPROGRESS );
				
				hr = pEndpoint->CopyEnumQueryData( pEnumQueryData );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Failed to copy enum query data before settings dialog!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}


				//
				// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem showing settings dialog for enum query!" );
					DisplayDNError( 0, hr );

					goto Failure;
				}

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				hr = DPNERR_PENDING;

				goto Exit;
			}
#endif // !DPNBUILD_NOSPUI

			if ( pEnumQueryData->dwFlags & DPNSPF_NOBROADCASTFALLBACK )
			{
				goto Failure;
			}
			
			//
			// we're OK, we can use the broadcast address.
			//
			
#if ((! defined(DPNBUILD_NONATHELP)) && (! defined(DPNBUILD_ONLYONETHREAD)))
			//
			// If NAT traversal is allowed, we may need to load and start
			// NAT Help, which can block.  Submit a blocking job.  This
			// will redetect the incomplete address and use broadcast (see
			// CEndpoint::EnumQueryBlockingJob).
			//
			if ( pEndpoint->GetUserTraversalMode() != DPNA_TRAVERSALMODE_NONE )
			{
				goto SubmitBlockingJob;
			}
#endif // ! DPNBUILD_NONATHELP and ! DPNBUILD_ONLYONETHREAD

			//
			// Mash in the broadcast address, but actually complete the
			// enum on another thread.
			//
			pEndpoint->ReinitializeWithBroadcast();
			goto SubmitDelayedCommand;
			
			break;
		}

#ifndef DPNBUILD_ONLYONETHREAD
		//
		// some blocking operation might occur, submit it to be run
		// on a background thread.
		//
		case DPNERR_TIMEDOUT:
		{
SubmitBlockingJob:
			//
			// Copy enum data and submit job to finish off enum.
			//
			DNASSERT( pSPData != NULL );
			hr = pEndpoint->CopyEnumQueryData( pEnumQueryData );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy enum query data before blocking job!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
			//
			pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitBlockingJob( CEndpoint::EnumQueryBlockingJobWrapper,
															pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to submit blocking enum query job!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
SubmitDelayedCommand:
			//
			// Copy enum data and submit job to finish off enum.
			//
			DNASSERT( pSPData != NULL );
			hr = pEndpoint->CopyEnumQueryData( pEnumQueryData );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy enum query data before delayed command!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
			//
			pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


			pEndpoint->AddRef();

#ifdef DPNBUILD_ONLYONEPROCESSOR
			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::EnumQueryJobCallback,
																pEndpoint );
#else // ! DPNBUILD_ONLYONEPROCESSOR
			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( -1,								// we don't know the CPU yet, so pick any
																CEndpoint::EnumQueryJobCallback,
																pEndpoint );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to set delayed enum query!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;

			break;
		}

		default:
		{
			//
			// this endpoint is screwed
			//
			DPFX(DPFPREP, 0, "Problem initializing endpoint in DNSP_EnumQuery!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:

	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP, 0, "Problem with DNSP_EnumQuery()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pEnumQueryData->hCommand = NULL;
		pEnumQueryData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}
		
		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_EnumRespond  sends a response to an enum request by
 *		sending the specified data to the address provided (on
 *		unreliable transport).
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumRespond"

STDMETHODIMP DNSP_EnumRespond( IDP8ServiceProvider *pThis, SPENUMRESPONDDATA *pEnumRespondData )
{
	HRESULT								hr;
	CEndpoint							*pEndpoint;
	CSPData								*pSPData;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEnumQueryContext;
	PREPEND_BUFFER						PrependBuffer;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumRespondData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumRespondData != NULL );
	DNASSERT( pEnumRespondData->dwFlags == 0 );

	//
	// initialize
	//
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEnumQueryContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pEnumRespondData->pQuery );
	pEndpoint = NULL;
	pEnumRespondData->hCommand = NULL;
	pEnumRespondData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );
	
	//
	// check for valid endpoint
	//
	pEndpoint = pSPData->EndpointFromHandle( pEnumQueryContext->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		DPFX(DPFPREP, 8, "Invalid endpoint handle in DNSP_EnumRespond" );
		goto Failure;
	}

	//
	// no need to poke at the thread pool here to lock down threads because we
	// can only really be here if there's an enum and that enum locked down the
	// thread pool.
	//

	DNASSERT( pEnumQueryContext->dwEnumKey <= WORD_MAX );

	pEnumRespondData->pBuffers[-1].pBufferData = reinterpret_cast<BYTE*>( &PrependBuffer.EnumResponseDataHeader );
	pEnumRespondData->pBuffers[-1].dwBufferSize = sizeof( PrependBuffer.EnumResponseDataHeader );

	PrependBuffer.EnumResponseDataHeader.bSPLeadByte = SP_HEADER_LEAD_BYTE;
	PrependBuffer.EnumResponseDataHeader.bSPCommandByte = ENUM_RESPONSE_DATA_KIND;
	PrependBuffer.EnumResponseDataHeader.wEnumResponsePayload = static_cast<WORD>( pEnumQueryContext->dwEnumKey );

#ifdef DPNBUILD_XNETSECURITY
	//
	// Secure transport does not allow directed replies without having a
	// security context established.  We need to broadcast the reply.
	//
	if (pEndpoint->IsUsingXNetSecurity())
	{
		SOCKADDR_IN *	psaddrin;
		XNADDR			xnaddr;
		DWORD			dwAddressType;


#pragma BUGBUG(vanceo, "Is it possible to have a security context?  How can we tell?  XNetInAddrToXnAddr failing?")
#pragma TODO(vanceo, "Cache title address?")

		dwAddressType = XNetGetTitleXnAddr(&xnaddr);
		if ((dwAddressType != XNET_GET_XNADDR_PENDING) &&
			(dwAddressType != XNET_GET_XNADDR_NONE))
		{
			DNASSERT(pEnumQueryContext->pReturnAddress->GetFamily() == AF_INET);
			psaddrin = (SOCKADDR_IN*) (pEnumQueryContext->pReturnAddress->GetWritableAddress());
			psaddrin->sin_addr.S_un.S_addr = INADDR_BROADCAST;

			pEnumRespondData->pBuffers[-1].dwBufferSize = sizeof( PrependBuffer.XNetSecEnumResponseDataHeader );
			
			PrependBuffer.EnumResponseDataHeader.bSPCommandByte = XNETSEC_ENUM_RESPONSE_DATA_KIND;

			memcpy(&PrependBuffer.XNetSecEnumResponseDataHeader.xnaddr,
					&xnaddr,
					sizeof(xnaddr));
		}
		else
		{
			DPFX(DPFPREP, 0, "Couldn't get XNAddr (type = %u)!  Ignoring and trying to send unsecure response.",
				dwAddressType);
		}
	}
#endif // DPNBUILD_XNETSECURITY

#ifdef DPNBUILD_ASYNCSPSENDS
	pEndpoint->GetSocketPort()->SendData( (pEnumRespondData->pBuffers - 1),
											(pEnumRespondData->dwBufferCount + 1),
											pEnumQueryContext->pReturnAddress,
											NULL );
#else // ! DPNBUILD_ASYNCSPSENDS
	pEndpoint->GetSocketPort()->SendData( (pEnumRespondData->pBuffers - 1),
											(pEnumRespondData->dwBufferCount + 1),
											pEnumQueryContext->pReturnAddress );
#endif // ! DPNBUILD_ASYNCSPSENDS

	// We can only return DPNERR_PENDING or failure, so we need to separately call the completion if 
	// we want to return DPN_OK.
	DPFX(DPFPREP, 5, "Endpoint 0x%p completing command synchronously (result = DPN_OK, user context = 0x%p) to interface 0x%p.",
		pEndpoint, pEnumRespondData->pvContext, pSPData->DP8SPCallbackInterface());

	hr = IDP8SPCallback_CommandComplete( pSPData->DP8SPCallbackInterface(),	// pointer to callbacks
										NULL,								// command handle
										DPN_OK,								// return
										pEnumRespondData->pvContext			// user cookie
										);

	DPFX(DPFPREP, 5, "Endpoint 0x%p returning from command complete [0x%lx].", pEndpoint, hr);
	hr = DPNERR_PENDING;

	pEndpoint->DecCommandRef();
	pEndpoint = NULL;


Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:

	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Connect "connects" to the specified address.  This doesn't
 *		necessarily mean a real (TCP) connection is made.  It could
 *		just be a virtual UDP connection
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Connect"

STDMETHODIMP DNSP_Connect( IDP8ServiceProvider *pThis, SPCONNECTDATA *pConnectData )
{
	HRESULT					hr;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;
#ifndef DPNBUILD_NONATHELP
	DWORD					dwTraversalMode;
	DWORD					dwComponentSize;
	DWORD					dwComponentType;
#endif // ! DPNBUILD_NONATHELP
#ifdef DBG
	DWORD					dwAllowedFlags;
#endif // DBG


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pConnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pConnectData != NULL );
	DNASSERT( pConnectData->pAddressHost != NULL );
	DNASSERT( pConnectData->pAddressDeviceInfo != NULL );

#ifdef DBG
	dwAllowedFlags = DPNSPF_SESSIONDATA;
#ifndef DPNBUILD_NOSPUI
	dwAllowedFlags |= DPNSPF_OKTOQUERY;
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_ONLYONEADAPTER
	dwAllowedFlags |= DPNSPF_ADDITIONALMULTIPLEXADAPTERS;
#endif // ! DPNBUILD_ONLYONEADAPTER
#ifndef DPNBUILD_NOMULTICAST
	dwAllowedFlags |= DPNSPF_CONNECT_MULTICAST_SEND | DPNSPF_CONNECT_MULTICAST_RECEIVE;
#endif // ! DPNBUILD_NOMULTICAST

	DNASSERT( ( pConnectData->dwFlags & ~( dwAllowedFlags ) ) == 0 );
#ifndef DPNBUILD_NOMULTICAST
	DNASSERT( !( ( pConnectData->dwFlags & DPNSPF_CONNECT_MULTICAST_SEND ) && ( pConnectData->dwFlags & DPNSPF_CONNECT_MULTICAST_RECEIVE ) ) );
#endif // ! DPNBUILD_NOMULTICAST

	if ( pConnectData->dwFlags & DPNSPF_SESSIONDATA )
	{
		DNASSERT( pConnectData->pvSessionData != NULL );
		DNASSERT( pConnectData->dwSessionDataSize > 0 );
	}
#endif // DBG


	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	pConnectData->hCommand = NULL;
	pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;

	
	// Trust protocol to call us only in the initialized state
	DNASSERT(pSPData->GetState() == SPSTATE_INITIALIZED);


	DumpAddress( 8, _T("Connect destination:"), pConnectData->pAddressHost );
	DumpAddress( 8, _T("Connecting on device:"), pConnectData->pAddressDeviceInfo );

	
	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.  This also performs other
	// first time initialization.
	//
	hr = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}

	//
	// create and new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot create new endpoint in DNSP_Connect!" );
		goto Failure;
	}
	
	
#ifndef DPNBUILD_NONATHELP
	//
	// We need to detect up front whether NAT traversal is disabled or not so we can optimize
	// the Open call below.
	//
	dwComponentSize = sizeof(dwTraversalMode);
	hr = IDirectPlay8Address_GetComponentByName(pConnectData->pAddressDeviceInfo,
												DPNA_KEY_TRAVERSALMODE,
												&dwTraversalMode,
												&dwComponentSize,
												&dwComponentType);
	if ( hr == DPN_OK )
	{
		//
		// We found the component.  Make sure it's the right size and type.
		//
		if ((dwComponentSize == sizeof(dwTraversalMode)) && (dwComponentType == DPNA_DATATYPE_DWORD))
		{
			switch (dwTraversalMode)
			{
				case DPNA_TRAVERSALMODE_NONE:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is NONE.");
					break;
				}

				case DPNA_TRAVERSALMODE_PORTREQUIRED:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is PORTREQUIRED.");
					break;
				}

				case DPNA_TRAVERSALMODE_PORTRECOMMENDED:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is PORTRECOMMENDED.");
					break;
				}

				default:
				{
					DPFX(DPFPREP, 0, "Ignoring correctly formed traversal mode key with invalid value %u!  Using default mode %u.",
						dwTraversalMode, g_dwDefaultTraversalMode);
					dwTraversalMode = g_dwDefaultTraversalMode;
					break;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 0, "Traversal mode key exists, but doesn't match expected type (%u != %u) or size (%u != %u)!  Using default mode %u.",
				dwComponentSize, sizeof(dwTraversalMode),
				dwComponentType, DPNA_DATATYPE_DWORD,
				g_dwDefaultTraversalMode);
			dwTraversalMode = g_dwDefaultTraversalMode;
		}
	}
	else
	{
		//
		// The key is not there, it's the wrong size (too big for our buffer
		// and returned BUFFERTOOSMALL), or something else bad happened.
		// It doesn't matter.  Carry on.
		//
		DPFX(DPFPREP, 8, "Could not get traversal mode key, error = 0x%lx, component size = %u, type = %u, using default mode %u.",
			hr, dwComponentSize, dwComponentType, g_dwDefaultTraversalMode);
		dwTraversalMode = g_dwDefaultTraversalMode;
	}
	
	if (g_dwDefaultTraversalMode & FORCE_TRAVERSALMODE_BIT)
	{
		DPFX(DPFPREP, 1, "Forcing traversal mode %u.");
		dwTraversalMode = g_dwDefaultTraversalMode & (~FORCE_TRAVERSALMODE_BIT);
	}
	
	pEndpoint->SetUserTraversalMode(dwTraversalMode);
#endif // ! DPNBUILD_NONATHELP


	//
	// get new command and initialize it
	//
	pCommand = (CCommandData*)g_CommandDataPool.Get();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get command handle for DNSP_Connect!" );
		goto Failure;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Connect command 0x%p created.",
		pSPData, pCommand);

	pConnectData->hCommand = pCommand;
	pConnectData->dwCommandDescriptor = pCommand->GetDescriptor();
#ifndef DPNBUILD_NOMULTICAST
	if ( pConnectData->dwFlags & DPNSPF_CONNECT_MULTICAST_SEND )
	{
		pCommand->SetType( COMMAND_TYPE_MULTICAST_SEND );
	}
	else if ( pConnectData->dwFlags & DPNSPF_CONNECT_MULTICAST_RECEIVE )
	{
		pCommand->SetType( COMMAND_TYPE_MULTICAST_RECEIVE );
	}
	else
#endif // ! DPNBUILD_NOMULTICAST
	{
		pCommand->SetType( COMMAND_TYPE_CONNECT );
	}
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
#ifndef DPNBUILD_NOMULTICAST
	if ( pConnectData->dwFlags & DPNSPF_CONNECT_MULTICAST_SEND )
	{
		hr = pEndpoint->Open( ENDPOINT_TYPE_MULTICAST_SEND,
							  pConnectData->pAddressHost,
							  ((pConnectData->dwFlags & DPNSPF_SESSIONDATA) ? pConnectData->pvSessionData : NULL),
							  ((pConnectData->dwFlags & DPNSPF_SESSIONDATA) ? pConnectData->dwSessionDataSize : 0),
							  NULL );
	}
	else if ( pConnectData->dwFlags & DPNSPF_CONNECT_MULTICAST_RECEIVE )
	{
		hr = pEndpoint->Open( ENDPOINT_TYPE_MULTICAST_RECEIVE,
							  pConnectData->pAddressHost,
							  ((pConnectData->dwFlags & DPNSPF_SESSIONDATA) ? pConnectData->pvSessionData : NULL),
							  ((pConnectData->dwFlags & DPNSPF_SESSIONDATA) ? pConnectData->dwSessionDataSize : 0),
							  NULL );
	}
	else
#endif // ! DPNBUILD_NOMULTICAST
	{
		hr = pEndpoint->Open( ENDPOINT_TYPE_CONNECT,
							  pConnectData->pAddressHost,
							  ((pConnectData->dwFlags & DPNSPF_SESSIONDATA) ? pConnectData->pvSessionData : NULL),
							  ((pConnectData->dwFlags & DPNSPF_SESSIONDATA) ? pConnectData->dwSessionDataSize : 0),
							  NULL );
	}
	switch ( hr )
	{
		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
			//
			// Copy connection data and submit job to finish off connection.
			//
			DNASSERT( pSPData != NULL );

			hr = pEndpoint->CopyConnectData( pConnectData );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy connect data before delayed command!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
			//
			pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


			pEndpoint->AddRef();

#ifdef DPNBUILD_ONLYONEPROCESSOR
			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::ConnectJobCallback,
																pEndpoint );
#else // ! DPNBUILD_ONLYONEPROCESSOR
			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( -1,								// we don't know the CPU yet, so pick any
																CEndpoint::ConnectJobCallback,
																pEndpoint );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to set delayed connect!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;

			break;
		}

		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
#ifndef DPNBUILD_NOSPUI
			if ( ( pConnectData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// Copy the connect data locally and start the dialog.  When the
				// dialog completes, the connection will attempt to complete.
				// Since a dialog is being displayed, the command is in-progress,
				// not pending.  However, you can't cancel the dialog once it's
				// displayed (the UI would suddenly disappear).
				//
				pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );
				
				hr = pEndpoint->CopyConnectData( pConnectData );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Failed to copy connect data before dialog!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}

				//
				// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem showing settings dialog for connect!" );
					DisplayDNError( 0, hr );

					goto Failure;
				}

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				hr = DPNERR_PENDING;

				goto Exit;
			}
			else
#endif // !DPNBUILD_NOSPUI
			{
				goto Failure;
			}

			break;
		}

#ifndef DPNBUILD_ONLYONETHREAD
		//
		// some blocking operation might occur, submit it to be run
		// on a background thread.
		//
		case DPNERR_TIMEDOUT:
		{
			//
			// Copy connect data and submit job to finish off enum.
			//
			DNASSERT( pSPData != NULL );
			hr = pEndpoint->CopyConnectData( pConnectData );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy connect data before blocking job!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.  It will get changed to DEFAULT or SPECIFIC
			//
			pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);


			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitBlockingJob( CEndpoint::ConnectBlockingJobWrapper,
															pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to submit blocking connect job!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		default:
		{
			DPFX(DPFPREP, 0, "Problem initializing endpoint in DNSP_Connect!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
	
	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP, 0, "Problem with DNSP_Connect()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pConnectData->hCommand = NULL;
		pConnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Disconnect disconnects an active connection
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Disconnect"

STDMETHODIMP DNSP_Disconnect( IDP8ServiceProvider *pThis, SPDISCONNECTDATA *pDisconnectData )
{
	HRESULT		hr;
	HRESULT		hTempResult;
	CEndpoint	*pEndpoint;
	CSPData		*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pDisconnectData);

	DNASSERT( pThis != NULL );
	DNASSERT( pDisconnectData != NULL );
	DNASSERT( pDisconnectData->dwFlags == 0 );
	DNASSERT( pDisconnectData->hEndpoint != INVALID_HANDLE_VALUE && pDisconnectData->hEndpoint != 0 );
	DNASSERT( pDisconnectData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	pEndpoint = NULL;
	pDisconnectData->hCommand = NULL;
	pDisconnectData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to poke at the thread pool here because there was already a connect
	// issued and that connect should have locked down the thread pool.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// look up the endpoint and if it's found, close its handle
	//
	pEndpoint = pSPData->GetEndpointAndCloseHandle( pDisconnectData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		goto Failure;
	}
	
	hTempResult = pEndpoint->Disconnect();
	switch ( hTempResult )
	{
		//
		// endpoint disconnected immediately
		//
		case DPNERR_PENDING:
		case DPN_OK:
		{
			break;
		}

		//
		// Other return.  Since the disconnect didn't complete, we need
		// to unlock the endpoint.
		//
		default:
		{
			DPFX(DPFPREP, 0, "Error reported when attempting to disconnect endpoint in DNSP_Disconnect!" );
			DisplayDNError( 0, hTempResult );
			DNASSERT( FALSE );

			break;
		}
	}

Exit:
	//
	// remove outstanding reference from GetEndpointHandleAndClose()
	//
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecRef();
		pEndpoint = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
/*
 *
 *	DNSP_Listen "listens" on the specified address/port.  This doesn't
 *		necessarily mean that a true TCP socket is used.  It could just
 *		be a UDP port that's opened for receiving packets
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Listen"

STDMETHODIMP DNSP_Listen( IDP8ServiceProvider *pThis, SPLISTENDATA *pListenData)
{
	HRESULT					hr;
	CEndpoint				*pEndpoint;
	CCommandData			*pCommand;
	IDirectPlay8Address		*pDeviceAddress;
	BOOL					fEndpointOpen;
	CSPData					*pSPData;
#ifndef DPNBUILD_NONATHELP
	DWORD					dwTraversalMode;
	DWORD					dwComponentSize;
	DWORD					dwComponentType;
#endif // ! DPNBUILD_NONATHELP
#ifdef DBG
	DWORD					dwAllowedFlags;
#endif // DBG


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pListenData);

	DNASSERT( pThis != NULL );
	DNASSERT( pListenData != NULL );

#ifdef DBG
	dwAllowedFlags = DPNSPF_BINDLISTENTOGATEWAY | DPNSPF_LISTEN_DISALLOWENUMS | DPNSPF_SESSIONDATA;
#ifndef DPNBUILD_NOSPUI
	dwAllowedFlags |= DPNSPF_OKTOQUERY;
#endif // ! DPNBUILD_NOSPUI
#ifndef DPNBUILD_NOMULTICAST
	dwAllowedFlags |= DPNSPF_LISTEN_MULTICAST | DPNSPF_LISTEN_ALLOWUNKNOWNSENDERS;
#endif // ! DPNBUILD_NOMULTICAST

	DNASSERT( ( pListenData->dwFlags & ~( dwAllowedFlags ) ) == 0 );

	if ( pListenData->dwFlags & DPNSPF_SESSIONDATA )
	{
		DNASSERT( pListenData->pvSessionData!= NULL );
		DNASSERT( pListenData->dwSessionDataSize > 0 );
	}
#endif // DBG


	//
	// initialize
	//
	hr = DPNERR_PENDING;
	pEndpoint = NULL;
	pCommand = NULL;
	pDeviceAddress = NULL;
	fEndpointOpen = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	pListenData->hCommand = NULL;
	pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;

	DumpAddress( 8, _T("Listening on device:"), pListenData->pAddressDeviceInfo );


	//
	// the user is attempting an operation that relies on the thread pool, lock
	// it down to prevent threads from being lost.  This also performs other
	// first time initialization.
	//
	hr = pSPData->GetThreadPool()->PreventThreadPoolReduction();
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Failed to prevent thread pool reduction!" );
		goto Failure;
	}


	//
	// AddRef the device address.
	//
	IDirectPlay8Address_AddRef(pListenData->pAddressDeviceInfo);
	pDeviceAddress = pListenData->pAddressDeviceInfo;
	
	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// create and new endpoint
	//
	pEndpoint = pSPData->GetNewEndpoint();
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot create new endpoint in DNSP_Listen!" );
		goto Failure;
	}
	
	
#ifndef DPNBUILD_NONATHELP
	//
	// We need to detect up front whether NAT traversal is disabled or not so we can optimize
	// the Open call below.
	//
	dwComponentSize = sizeof(dwTraversalMode);
	hr = IDirectPlay8Address_GetComponentByName(pListenData->pAddressDeviceInfo,
												DPNA_KEY_TRAVERSALMODE,
												&dwTraversalMode,
												&dwComponentSize,
												&dwComponentType);
	if ( hr == DPN_OK )
	{
		//
		// We found the component.  Make sure it's the right size and type.
		//
		if ((dwComponentSize == sizeof(dwTraversalMode)) && (dwComponentType == DPNA_DATATYPE_DWORD))
		{
			switch (dwTraversalMode)
			{
				case DPNA_TRAVERSALMODE_NONE:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is NONE.");
					break;
				}

				case DPNA_TRAVERSALMODE_PORTREQUIRED:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is PORTREQUIRED.");
					break;
				}

				case DPNA_TRAVERSALMODE_PORTRECOMMENDED:
				{
					DPFX(DPFPREP, 1, "Found traversal mode key, value is PORTRECOMMENDED.");
					break;
				}

				default:
				{
					DPFX(DPFPREP, 0, "Ignoring correctly formed traversal mode key with invalid value %u!  Using PORTRECOMMENDED.",
						dwTraversalMode);
					dwTraversalMode = g_dwDefaultTraversalMode;
					break;
				}
			}
		}
		else
		{
			DPFX(DPFPREP, 0, "Traversal mode key exists, but doesn't match expected type (%u != %u) or size (%u != %u)!  Using default mode %u.",
				dwComponentSize, sizeof(dwTraversalMode),
				dwComponentType, DPNA_DATATYPE_DWORD,
				g_dwDefaultTraversalMode);
			dwTraversalMode = g_dwDefaultTraversalMode;
		}
	}
	else
	{
		//
		// The key is not there, it's the wrong size (too big for our buffer
		// and returned BUFFERTOOSMALL), or something else bad happened.
		// It doesn't matter.  Carry on.
		//
		DPFX(DPFPREP, 8, "Could not get traversal mode key, error = 0x%lx, component size = %u, type = %u, using default mode %u.",
			hr, dwComponentSize, dwComponentType, g_dwDefaultTraversalMode);
		dwTraversalMode = g_dwDefaultTraversalMode;
	}
	
	if (g_dwDefaultTraversalMode & FORCE_TRAVERSALMODE_BIT)
	{
		DPFX(DPFPREP, 1, "Forcing traversal mode %u.");
		dwTraversalMode = g_dwDefaultTraversalMode & (~FORCE_TRAVERSALMODE_BIT);
	}
	
	pEndpoint->SetUserTraversalMode(dwTraversalMode);
#endif // ! DPNBUILD_NONATHELP


	//
	// get new command and initialize it
	//
	pCommand = (CCommandData*)g_CommandDataPool.Get();
	if ( pCommand == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Cannot get command handle for DNSP_Listen!" );
		goto Failure;
	}
	
	DPFX(DPFPREP, 7, "(0x%p) Listen command 0x%p created.",
		pSPData, pCommand);

	pListenData->hCommand = pCommand;
	pListenData->dwCommandDescriptor = pCommand->GetDescriptor();
#ifndef DPNBUILD_NOMULTICAST
	if (pListenData->dwFlags & DPNSPF_LISTEN_MULTICAST)
	{
		pCommand->SetType( COMMAND_TYPE_MULTICAST_LISTEN );
	}
	else
#endif // ! DPNBUILD_NOMULTICAST
	{
		pCommand->SetType( COMMAND_TYPE_LISTEN );
	}
	pCommand->SetState( COMMAND_STATE_PENDING );
	pCommand->SetEndpoint( pEndpoint );
	pCommand->SetUserContext( pListenData->pvContext );

	//
	// open endpoint with outgoing address
	//
	fEndpointOpen = TRUE;
#ifndef DPNBUILD_NOMULTICAST
	if (pListenData->dwFlags & DPNSPF_LISTEN_MULTICAST)
	{
		//
		// The device address should also contain the multicast address to be joined.
		//
		hr = pEndpoint->Open( ENDPOINT_TYPE_MULTICAST_LISTEN,
							pDeviceAddress,
							((pListenData->dwFlags & DPNSPF_SESSIONDATA) ? pListenData->pvSessionData : NULL),
							((pListenData->dwFlags & DPNSPF_SESSIONDATA) ? pListenData->dwSessionDataSize : 0),
							NULL );
	}
	else
#endif // ! DPNBUILD_NOMULTICAST
	{
		hr = pEndpoint->Open( ENDPOINT_TYPE_LISTEN,
							NULL,
							((pListenData->dwFlags & DPNSPF_SESSIONDATA) ? pListenData->pvSessionData : NULL),
							((pListenData->dwFlags & DPNSPF_SESSIONDATA) ? pListenData->dwSessionDataSize : 0),
							NULL );
	}

	switch ( hr )
	{
		//
		// address conversion was fine, copy connect data and finish connection
		// on background thread.
		//
		case DPN_OK:
		{
			//
			// Copy listen data and submit job to finish off listen.
			//
			DNASSERT( pSPData != NULL );

			hr = pEndpoint->CopyListenData( pListenData, pDeviceAddress );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy listen data before delayed command!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.
			//
			if ((pListenData->dwFlags & DPNSPF_BINDLISTENTOGATEWAY))
			{
				//
				// This must always stay SPECIFIC_SHARED.
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_SPECIFIC_SHARED);
			}
			else
			{
				//
				// This will get changed to DEFAULT or SPECIFIC.
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);
			}


			pEndpoint->AddRef();

#ifdef DPNBUILD_ONLYONEPROCESSOR
			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( CEndpoint::ListenJobCallback,
																pEndpoint );
#else // ! DPNBUILD_ONLYONEPROCESSOR
			hr = pSPData->GetThreadPool()->SubmitDelayedCommand( -1,								// we don't know the CPU yet, so pick any
																CEndpoint::ListenJobCallback,
																pEndpoint );
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to set delayed listen!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference to it
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;

			break;
		}

		//
		// Incomplete address passed in, query user for more information if
		// we're allowed.  Since we don't have a complete address at this time,
		// don't bind this endpoint to the socket port!
		//
		case DPNERR_INCOMPLETEADDRESS:
		{
			//
			// This SP will never encounter the case where there's not enough
			// information to start listening.  Either the adapter GUID is there
			// or not, and we won't know until CEndpoint::CompleteListen.
			//
			DNASSERT( FALSE );
			
#ifndef DPNBUILD_NOSPUI
			if ( ( pListenData->dwFlags & DPNSPF_OKTOQUERY ) != 0 )
			{
				//
				// Copy the listen data locally and start the dialog.  When the
				// dialog completes, the connection will attempt to complete.
				// Since this endpoint is being handed off to another thread,
				// make sure it's in the unbound list.  Since a dialog is being
				// displayed, the command state is in progress, not pending.
				//
				DNASSERT( pSPData != NULL );

				hr = pEndpoint->CopyListenData( pListenData, pDeviceAddress );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Failed to copy listen data before dialog!" );
					DisplayDNError( 0, hr );
					goto Failure;
				}


				//
				// Initialize the bind type.
				//
				if ((pListenData->dwFlags & DPNSPF_BINDLISTENTOGATEWAY))
				{
					//
					// This must always stay SPECIFIC_SHARED.
					//
					pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_SPECIFIC_SHARED);
				}
				else
				{
					//
					// This will get changed to DEFAULT or SPECIFIC.
					//
					pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);
				}


				pCommand->SetState( COMMAND_STATE_INPROGRESS );
				hr = pEndpoint->ShowSettingsDialog( pSPData->GetThreadPool() );
				if ( hr != DPN_OK )
				{
					DPFX(DPFPREP, 0, "Problem showing settings dialog for listen!" );
					DisplayDNError( 0, hr );

					goto Failure;
				}

				//
				// this endpoint has been handed off, remove our reference to it
				//
				pEndpoint = NULL;
				hr = DPNERR_PENDING;

				goto Exit;
			}
			else
#endif // !DPNBUILD_NOSPUI
			{
				goto Failure;
			}

			break;
		}

#ifndef DPNBUILD_ONLYONETHREAD
		//
		// some blocking operation might occur, submit it to be run
		// on a background thread.
		//
		case DPNERR_TIMEDOUT:
		{
			//
			// Copy listen data and submit job to finish off enum.
			//
			DNASSERT( pSPData != NULL );
			hr = pEndpoint->CopyListenData( pListenData, pDeviceAddress );
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Failed to copy listen data before blocking job!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}


			//
			// Initialize the bind type.
			//
			if ((pListenData->dwFlags & DPNSPF_BINDLISTENTOGATEWAY))
			{
				//
				// This must always stay SPECIFIC_SHARED.
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_SPECIFIC_SHARED);
			}
			else
			{
				//
				// This will get changed to DEFAULT or SPECIFIC.
				//
				pEndpoint->SetCommandParametersGatewayBindType(GATEWAY_BIND_TYPE_UNKNOWN);
			}


			pEndpoint->AddRef();

			hr = pSPData->GetThreadPool()->SubmitBlockingJob( CEndpoint::ListenBlockingJobWrapper,
															pEndpoint );
			if ( hr != DPN_OK )
			{
				pEndpoint->DecRef();
				DPFX(DPFPREP, 0, "Failed to submit blocking listen job!" );
				DisplayDNError( 0, hr );
				goto Failure;
			}

			//
			// this endpoint has been handed off, remove our reference
			//
			pEndpoint = NULL;
			hr = DPNERR_PENDING;
			goto Exit;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		default:
		{
			DPFX(DPFPREP, 0, "Problem initializing endpoint in DNSP_Listen!" );
			DisplayDNError( 0, hr );
			goto Failure;

			break;
		}
	}

Exit:
	if ( pDeviceAddress != NULL )
	{
		IDirectPlay8Address_Release( pDeviceAddress );
		pDeviceAddress = NULL;
	}

	DNASSERT( pEndpoint == NULL );

	if ( hr != DPNERR_PENDING )
	{
		// this command cannot complete synchronously!
		DNASSERT( hr != DPN_OK );

		DPFX(DPFPREP, 0, "Problem with DNSP_Listen()" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pListenData->hCommand = NULL;
		pListenData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}

	//
	// is there an endpoint to free?
	//
	if ( pEndpoint != NULL )
	{
		if ( fEndpointOpen != FALSE )
		{
			pEndpoint->Close( hr );
			fEndpointOpen = FALSE;
		}

		pSPData->CloseEndpointHandle( pEndpoint );
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************





//**********************************************************************
/*
 *
 *	DNSP_SendData sends data to the specified "player"
 *
 *	This call MUST BE HIGHLY OPTIMIZED
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_SendData"

STDMETHODIMP DNSP_SendData( IDP8ServiceProvider *pThis, SPSENDDATA *pSendData )
{
	HRESULT				hr;
	CEndpoint			*pEndpoint;
	CSPData				*pSPData;
#ifdef DPNBUILD_ASYNCSPSENDS
	CCommandData *		pCommand = NULL;
	OVERLAPPED *		pOverlapped;
#endif // DPNBUILD_ASYNCSPSENDS
#ifdef DBG
	DWORD				dwTotalBufferSize;
	DWORD				dwTemp;
#endif // DBG


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pSendData);

	DNASSERT( pThis != NULL );
	DNASSERT( pSendData != NULL );
	DNASSERT( pSendData->pBuffers != NULL );
	DNASSERT( pSendData->dwBufferCount != 0 );
	DNASSERT( pSendData->hEndpoint != INVALID_HANDLE_VALUE && pSendData->hEndpoint != 0 );
	DNASSERT( pSendData->dwFlags == 0 );

	//
	// initialize
	//
	pEndpoint = NULL;
	pSendData->hCommand = NULL;
	pSendData->dwCommandDescriptor = NULL_DESCRIPTOR;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// No need to lock down the thread counts here because the user already has
	// a connect or something running or they wouldn't be calling this function.
	// That outstanding connect would have locked down the thread pool.
	//

	//
	// Attempt to grab the endpoint from the handle.  If this succeeds, the
	// endpoint can send.
	//
	pEndpoint = pSPData->EndpointFromHandle( pSendData->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDHANDLE;
		DPFX(DPFPREP, 0, "Invalid endpoint handle on send!" );
		goto Failure;
	}

#ifdef DBG
	//
	// Make sure message is not too large.
	//
	dwTotalBufferSize = 0;
	for(dwTemp = 0; dwTemp < pSendData->dwBufferCount; dwTemp++)
	{
		dwTotalBufferSize += pSendData->pBuffers[dwTemp].dwBufferSize;
	}
#pragma TODO(vanceo, "No direct way for application to retrieve, they think max is g_dwMaxEnumDataSize")
#ifdef DPNBUILD_NOREGISTRY
	DNASSERT(dwTotalBufferSize <= DEFAULT_MAX_USER_DATA_SIZE);
#else // ! DPNBUILD_NOREGISTRY
	DNASSERT(dwTotalBufferSize <= g_dwMaxUserDataSize);
#endif // ! DPNBUILD_NOREGISTRY
	
	// Protocol guarantees that the first byte will never be zero
	DNASSERT(pSendData->pBuffers[ 0 ].pBufferData[ 0 ] != SP_HEADER_LEAD_BYTE);
#endif // DBG

	//
	// Assume user data.  There's no need to prepend a buffer because the
	// receiving machine will realize that it's not a 'special' message and
	// will default the contents to 'user data'.
	//
	
#ifdef DPNBUILD_ASYNCSPSENDS

#ifdef DPNBUILD_NOWINSOCK2
This won't compile because we need the Winsock2 API to perform overlapped sends
#endif // DPNBUILD_NOWINSOCK2

#ifndef DPNBUILD_ONLYWINSOCK2
	DNASSERT(pEndpoint->GetSocketPort() != NULL);
	DNASSERT(pEndpoint->GetSocketPort()->GetNetworkAddress() != NULL);
	if ( ( LOWORD( GetWinsockVersion() ) < 2 ) 
#ifndef DPNBUILD_NOIPX
		|| ( pEndpoint->GetSocketPort()->GetNetworkAddress()->GetFamily() != AF_INET ) 
#endif // ! DPNBUILD_NOIPX
		)
	{
		//
		// We can't perform overlapped sends on Winsock < 2 or on 9x IPX.
		//
		pEndpoint->GetSocketPort()->SendData( pSendData->pBuffers,
											pSendData->dwBufferCount,
											pEndpoint->GetRemoteAddressPointer(),
											NULL );

		hr = DPN_OK;

		pEndpoint->DecCommandRef();
	}
	else
#endif // ! DPNBUILD_ONLYWINSOCK2
	{
		//
		// get new command and initialize it
		//
		pCommand = (CCommandData*)g_CommandDataPool.Get();
		if ( pCommand == NULL )
		{
			hr = DPNERR_OUTOFMEMORY;
			DPFX(DPFPREP, 0, "Cannot get command handle!" );
			goto Failure;
		}
		
		DPFX(DPFPREP, 8, "(0x%p) Send command 0x%p created.",
			pSPData, pCommand);

		pSendData->hCommand = pCommand;
		pSendData->dwCommandDescriptor = pCommand->GetDescriptor();
		pCommand->SetType( COMMAND_TYPE_SEND );
		pCommand->SetState( COMMAND_STATE_INPROGRESS_CANNOT_CANCEL );	// can't cancel async sends
		pCommand->SetEndpoint( pEndpoint );
		pCommand->SetUserContext( pSendData->pvContext );


#ifdef DPNBUILD_ONLYONEPROCESSOR
		hr = IDirectPlay8ThreadPoolWork_CreateOverlapped(pSPData->GetThreadPool()->GetDPThreadPoolWork(),
														-1,
														CEndpoint::CompleteAsyncSend,
														pCommand,
														&pOverlapped,
														0);
#else // ! DPNBUILD_ONLYONEPROCESSOR
		hr = IDirectPlay8ThreadPoolWork_CreateOverlapped(pSPData->GetThreadPool()->GetDPThreadPoolWork(),
														pEndpoint->GetSocketPort()->GetCPU(),
														CEndpoint::CompleteAsyncSend,
														pCommand,
														&pOverlapped,
														0);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't create overlapped structure!");
			goto Failure;
		}
		
		pEndpoint->GetSocketPort()->SendData( pSendData->pBuffers,
												pSendData->dwBufferCount,
												pEndpoint->GetRemoteAddressPointer(),
												pOverlapped );

		//
		// Whether the submission to Winsock succeeds or fails, it should still
		// fill out the overlapped structure, so we will just let the async
		// completion handler do everything.
		//
		hr = IDirectPlay8ThreadPoolWork_SubmitIoOperation(pSPData->GetThreadPool()->GetDPThreadPoolWork(),
															pOverlapped,
															0);
		DNASSERT(hr == DPN_OK);

		//
		// Keep endpoint's command ref on send until send completes.
		//
		
		hr = DPNSUCCESS_PENDING;
	}
#else // ! DPNBUILD_ASYNCSPSENDS
	pEndpoint->GetSocketPort()->SendData( pSendData->pBuffers,
										pSendData->dwBufferCount,
										pEndpoint->GetRemoteAddressPointer() );

	hr = DPN_OK;

	pEndpoint->DecCommandRef();
#endif // ! DPNBUILD_ASYNCSPSENDS
	pEndpoint = NULL;

Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;

Failure:
#ifdef DPNBUILD_ASYNCSPSENDS
	//
	// if there's an allocated command, clean up and then
	// return the command
	//
	if ( pCommand != NULL )
	{
		pCommand->DecRef();
		pCommand = NULL;

		pSendData->hCommand = NULL;
		pSendData->dwCommandDescriptor = NULL_DESCRIPTOR;
	}
#endif // DPNBUILD_ASYNCSPSENDS
	if ( pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}

	goto Exit;
}
//**********************************************************************




//**********************************************************************
/*
 *
 *	DNSP_CancelCommand cancels a command in progress
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_CancelCommand"

STDMETHODIMP DNSP_CancelCommand( IDP8ServiceProvider *pThis, HANDLE hCommand, DWORD dwCommandDescriptor )
{
	HRESULT hr;
	CCommandData	*pCommandData;
	BOOL			fCommandLocked;
	CSPData			*pSPData;
	CEndpoint		*pEndpoint;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p, %ld)", pThis, hCommand, dwCommandDescriptor);

	DNASSERT( pThis != NULL );
	DNASSERT( hCommand != NULL );
	DNASSERT( dwCommandDescriptor != NULL_DESCRIPTOR );

	//
	// initialize
	//
	hr = DPN_OK;
	fCommandLocked = FALSE;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// No need to lock the thread pool counts because there's already some outstanding
	// enum, connect or listen running that has done so.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	pCommandData = static_cast<CCommandData*>( hCommand );

	pCommandData->Lock();
	fCommandLocked = TRUE;

	//
	// make sure the right command is being cancelled
	//
	if ( dwCommandDescriptor != pCommandData->GetDescriptor() )
	{
		hr = DPNERR_INVALIDCOMMAND;
		DPFX(DPFPREP, 0, "Attempt to cancel command (0x%p) with mismatched command descriptor (%u != %u)!",
			hCommand, dwCommandDescriptor, pCommandData->GetDescriptor() );
		goto Exit;
	}

	switch ( pCommandData->GetState() )
	{
		//
		// unknown command state
		//
		case COMMAND_STATE_UNKNOWN:
		{
			hr = DPNERR_INVALIDCOMMAND;
			DNASSERT( FALSE );
			break;
		}

		//
		// command is waiting to be processed, set command state to be cancelling
		// and wait for someone to pick it up
		//
		case COMMAND_STATE_PENDING:
		{
			DPFX(DPFPREP, 5, "Marking command 0x%p as cancelling.", pCommandData);
			pCommandData->SetState( COMMAND_STATE_CANCELLING );
			break;
		}

		//
		// command in progress, and can't be cancelled
		//
		case COMMAND_STATE_INPROGRESS_CANNOT_CANCEL:
		{
			DPFX(DPFPREP, 1, "Cannot cancel command 0x%p.", pCommandData);
			hr = DPNERR_CANNOTCANCEL;
			break;
		}

		//
		// Command is already being cancelled.  This is not a problem, but shouldn't
		// be happening for any endpoints other than connects.
		//
		case COMMAND_STATE_CANCELLING:
		{
			DPFX(DPFPREP, 1, "Cancelled already cancelling command 0x%p.", pCommandData);
			DNASSERT( pCommandData->GetEndpoint()->GetType() == ENDPOINT_TYPE_CONNECT );
			DNASSERT( hr == DPN_OK );
			break;
		}
		
#ifndef DPNBUILD_ONLYONETHREAD
		//
		// A blocking operation is already failing, let it complete.
		//
		case COMMAND_STATE_FAILING:
		{
			DPFX(DPFPREP, 1, "Cancelled already failing command 0x%p.", pCommandData);
			DNASSERT( hr == DPN_OK );
			break;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		//
		// command is in progress, find out what type of command it is
		//
		case COMMAND_STATE_INPROGRESS:
		{
			switch ( pCommandData->GetType() )
			{
				case COMMAND_TYPE_CONNECT:
				case COMMAND_TYPE_LISTEN:
#ifndef DPNBUILD_NOMULTICAST
				case COMMAND_TYPE_MULTICAST_LISTEN:
				case COMMAND_TYPE_MULTICAST_SEND:
				case COMMAND_TYPE_MULTICAST_RECEIVE:
#endif // ! DPNBUILD_NOMULTICAST
				{
					//
					// Set this command to the cancel state before we shut down
					// this endpoint.  Make sure a reference is added to the
					// endpoint so it stays around for the cancel.
					//
					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pEndpoint = pCommandData->GetEndpoint();
					pEndpoint->AddRef();

					DPFX(DPFPREP, 3, "Cancelling connect/listen/multicast command 0x%p (endpoint 0x%p).",
 						pCommandData, pEndpoint);

					pCommandData->Unlock();
					fCommandLocked = FALSE;

					pEndpoint->Lock();
					switch ( pEndpoint->GetState() )
					{
						//
						// endpoint is already disconnecting, no action needs to be taken
						//
						case ENDPOINT_STATE_DISCONNECTING:
						{
							DPFX(DPFPREP, 7, "Endpoint 0x%p already marked as disconnecting.",
								pEndpoint);
							pEndpoint->Unlock();
							pEndpoint->DecRef();
							goto Exit;
							break;
						}

						//
						// Endpoint is connecting.  Flag it as disconnecting and
						// add a reference so it doesn't disappear on us.
						//
						case ENDPOINT_STATE_ATTEMPTING_CONNECT:
						{
							DPFX(DPFPREP, 7, "Endpoint 0x%p attempting to connect, marking as disconnecting.",
								pEndpoint);
#ifdef DPNBUILD_NOMULTICAST
							DNASSERT(pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT);
#else // ! DPNBUILD_NOMULTICAST
							DNASSERT((pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT) || (pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND) || (pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_RECEIVE));
#endif // ! DPNBUILD_NOMULTICAST
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							break;
						}

						//
						// Endpoint has finished connecting.  Report that the
						// command is uncancellable.  Sorry Charlie, we missed
						// the window.
						//
						case ENDPOINT_STATE_CONNECT_CONNECTED:
						{
#ifdef DPNBUILD_NOMULTICAST
							DNASSERT(pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT);
#else // ! DPNBUILD_NOMULTICAST
							DNASSERT((pEndpoint->GetType() == ENDPOINT_TYPE_CONNECT) || (pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_SEND) || (pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_RECEIVE));
#endif // ! DPNBUILD_NOMULTICAST
							DPFX(DPFPREP, 1, "Cannot cancel connect command 0x%p (endpoint 0x%p) that's already (or is about to) complete.",
								pCommandData, pEndpoint);
							pEndpoint->Unlock();
							pEndpoint->DecRef();
							hr = DPNERR_CANNOTCANCEL;
							goto Exit;
							break;
						}

						//
						// Endpoint is listening.  Flag it as disconnecting and
						// add a reference so it doesn't disappear on us
						//
						case ENDPOINT_STATE_LISTEN:
						{
							DPFX(DPFPREP, 7, "Endpoint 0x%p listening, marking as disconnecting.",
								pEndpoint);
#ifdef DPNBUILD_NOMULTICAST
							DNASSERT(pEndpoint->GetType() == ENDPOINT_TYPE_LISTEN);
#else // ! DPNBUILD_NOMULTICAST
							DNASSERT((pEndpoint->GetType() == ENDPOINT_TYPE_LISTEN) || (pEndpoint->GetType() == ENDPOINT_TYPE_MULTICAST_LISTEN));
#endif // ! DPNBUILD_NOMULTICAST
							pEndpoint->SetState( ENDPOINT_STATE_DISCONNECTING );
							break;
						}

						//
						// other state
						//
						default:
						{
							DNASSERT( FALSE );
							break;
						}
					}
					pEndpoint->Unlock();

					pEndpoint->Close( DPNERR_USERCANCEL );
					pSPData->CloseEndpointHandle( pEndpoint );
					pEndpoint->DecRef();

					break;
				}

				case COMMAND_TYPE_ENUM_QUERY:
				{
					pEndpoint = pCommandData->GetEndpoint();
					DNASSERT( pEndpoint != NULL );

					DPFX(DPFPREP, 3, "Cancelling enum query command 0x%p (endpoint 0x%p).",
						pCommandData, pEndpoint);
					
					pEndpoint->AddRef();

					pCommandData->SetState( COMMAND_STATE_CANCELLING );
					pCommandData->Unlock();
					fCommandLocked = FALSE;
						
					pEndpoint->StopEnumCommand( DPNERR_USERCANCEL );
					pEndpoint->DecRef();

					break;
				}

				default:
				{
					DNASSERT( FALSE );
					break;
				}
			}

			break;
		}

		//
		// other command state
		//
		default:
		{
			DNASSERT( FALSE );
			break;
		}
	}


Exit:
	if ( fCommandLocked != FALSE  )
	{
		DNASSERT( pCommandData != NULL );
		pCommandData->Unlock();
		fCommandLocked = FALSE;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetCaps - get SP capabilities
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetCaps"

STDMETHODIMP	DNSP_GetCaps( IDP8ServiceProvider *pThis, SPGETCAPSDATA *pCapsData )
{
	HRESULT		hr;
	CSPData		*pSPData;
#ifndef DPNBUILD_ONLYONETHREAD
	LONG		iIOThreadCount;
#endif // ! DPNBUILD_ONLYONETHREAD
	

	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );
	DNASSERT( pCapsData->hEndpoint == INVALID_HANDLE_VALUE );

	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// set flags
	//

	pCapsData->dwFlags = DPNSPCAPS_SUPPORTSDPNSRV |
							DPNSPCAPS_SUPPORTSBROADCAST |
							DPNSPCAPS_SUPPORTSALLADAPTERS;

#ifndef DPNBUILD_ONLYONETHREAD
	pCapsData->dwFlags |= DPNSPCAPS_SUPPORTSTHREADPOOL;
#endif // ! DPNBUILD_ONLYONETHREAD

#ifndef DPNBUILD_NOMULTICAST
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	if (pSPData->GetType() != AF_IPX)
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	{
		pCapsData->dwFlags |= DPNSPCAPS_SUPPORTSMULTICAST;
	}
#endif // ! DPNBUILD_NOMULTICAST


	//
	// set frame sizes
	//
#ifdef DPNBUILD_NOREGISTRY
	pCapsData->dwUserFrameSize = DEFAULT_MAX_USER_DATA_SIZE;
	pCapsData->dwEnumFrameSize = DEFAULT_MAX_ENUM_DATA_SIZE;
#else // ! DPNBUILD_NOREGISTRY
	pCapsData->dwUserFrameSize = g_dwMaxUserDataSize;
	pCapsData->dwEnumFrameSize = g_dwMaxEnumDataSize;
#endif // ! DPNBUILD_NOREGISTRY

	//
	// Set link speed, no need to check for endpoint because
	// the link speed cannot be determined.
	//
	pCapsData->dwLocalLinkSpeed = UNKNOWN_BANDWIDTH;

#ifdef DPNBUILD_ONLYONETHREAD
	pCapsData->dwIOThreadCount = 0;
#else // ! DPNBUILD_ONLYONETHREAD
	hr = pSPData->GetThreadPool()->GetIOThreadCount( &iIOThreadCount );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "DNSP_GetCaps: Failed to get thread pool count!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	pCapsData->dwIOThreadCount = iIOThreadCount;
#endif // ! DPNBUILD_ONLYONETHREAD

	//
	// set enumeration defaults
	//
	pCapsData->dwDefaultEnumRetryCount = DEFAULT_ENUM_RETRY_COUNT;
	pCapsData->dwDefaultEnumRetryInterval = DEFAULT_ENUM_RETRY_INTERVAL;
	pCapsData->dwDefaultEnumTimeout = DEFAULT_ENUM_TIMEOUT;

	//
	// dwBuffersPerThread is ignored
	//
	pCapsData->dwBuffersPerThread = 1;

	//
	// set receive buffering information
	//
	pCapsData->dwSystemBufferSize = 8192;
	if ( g_fWinsockReceiveBufferSizeOverridden == FALSE )
	{
		SOCKET		TestSocket;
	
		
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
		TestSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		switch (pSPData->GetType())
		{
#ifndef DPNBUILD_NOIPV6
			case AF_INET6:
			{
				TestSocket = socket( AF_INET6, SOCK_DGRAM, IPPROTO_IP );
				break;
			}
#endif // ! DPNBUILD_NOIPV6

#ifndef DPNBUILD_NOIPX
			case AF_IPX:
			{
				TestSocket = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
				break;
			}
#endif // ! DPNBUILD_NOIPX

			default:
			{
				DNASSERT(pSPData->GetType() == AF_INET);
				TestSocket = socket( AF_INET, SOCK_DGRAM, IPPROTO_IP );
				break;
			}
		}
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
		if ( TestSocket != INVALID_SOCKET )
		{
			INT		iBufferSize;
			INT		iBufferSizeSize;
			INT		iWSAReturn;


			iBufferSizeSize = sizeof( iBufferSize );
			iWSAReturn = getsockopt( TestSocket,									// socket
									   SOL_SOCKET,									// socket level option
									   SO_RCVBUF,									// socket option
									   reinterpret_cast<char*>( &iBufferSize ),		// pointer to destination
									   &iBufferSizeSize								// pointer to destination size
									   );
			if ( iWSAReturn != SOCKET_ERROR )
			{
				pCapsData->dwSystemBufferSize = iBufferSize;
			}
			else
			{
				DPFX(DPFPREP, 0, "Failed to get socket receive buffer options!" );
				DisplayWinsockError( 0, iWSAReturn );
			}

			closesocket( TestSocket );
			TestSocket = INVALID_SOCKET;
		}
	}
	else
	{
		pCapsData->dwSystemBufferSize = g_iWinsockReceiveBufferSize;
	}

#ifndef DPNBUILD_ONLYONETHREAD
Exit:
#endif // !DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

#ifndef DPNBUILD_ONLYONETHREAD
Failure:
	goto Exit;
#endif // !DPNBUILD_ONLYONETHREAD
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_SetCaps - set SP capabilities
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_SetCaps"

STDMETHODIMP	DNSP_SetCaps( IDP8ServiceProvider *pThis, SPSETCAPSDATA *pCapsData )
{
	HRESULT			hr;
	CSPData			*pSPData;
#ifndef DPNBUILD_NOREGISTRY
	CRegistry		RegObject;
#endif // ! DPNBUILD_NOREGISTRY


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pCapsData);

	DNASSERT( pThis != NULL );
	DNASSERT( pCapsData != NULL );
	DNASSERT( pCapsData->dwSize == sizeof( *pCapsData ) );


	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// validate caps
	//
	if ( pCapsData->dwBuffersPerThread == 0 )
	{
		DPFX(DPFPREP, 0, "Failing SetCaps because dwBuffersPerThread == 0" );
		hr = DPNERR_INVALIDPARAM;
		goto Failure;
	}

#ifndef DPNBUILD_ONLYONETHREAD
	//
	// change thread count, if requested
	//
	if ( pCapsData->dwIOThreadCount != 0 )
	{
		hr = pSPData->GetThreadPool()->SetIOThreadCount( pCapsData->dwIOThreadCount );
		if ( hr != DPN_OK )
		{
			DPFX(DPFPREP, 0, "Failed to set thread pool count!" );
			DisplayDNError( 0, hr );
			goto Failure;
		}
	}
#endif // ! DPNBUILD_ONLYONETHREAD


	//
	// dwBuffersPerThread is ignored.
	//


	//
	// Set the receive buffer size.
	//
	DBG_CASSERT( sizeof( pCapsData->dwSystemBufferSize ) == sizeof( g_iWinsockReceiveBufferSize ) );
	g_fWinsockReceiveBufferSizeOverridden = TRUE;
	g_iWinsockReceiveBufferSize = pCapsData->dwSystemBufferSize;
#ifndef WINCE
	pSPData->SetWinsockBufferSizeOnAllSockets( g_iWinsockReceiveBufferSize );
#endif // ! WINCE


Exit:
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_ReturnReceiveBuffers - return receive buffers to pool
//
// Entry:		Pointer to DNSP interface
//				Pointer to caps data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ReturnReceiveBuffers"

STDMETHODIMP	DNSP_ReturnReceiveBuffers( IDP8ServiceProvider *pThis, SPRECEIVEDBUFFER *pReceivedBuffers )
{
	SPRECEIVEDBUFFER	*pBuffers;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pReceivedBuffers);

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	DNASSERT( pThis != NULL );
	DNASSERT( pReceivedBuffers != NULL );

	pBuffers = pReceivedBuffers;
	while ( pBuffers != NULL )
	{
		SPRECEIVEDBUFFER	*pTemp;
		CReadIOData			*pReadData;


		pTemp = pBuffers;
		pBuffers = pBuffers->pNext;
		pReadData = CReadIOData::ReadDataFromSPReceivedBuffer( pTemp );
		DEBUG_ONLY( pReadData->m_fRetainedByHigherLayer = FALSE );
		pReadData->DecRef();
	}

	//DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);
	DPFX(DPFPREP, 2, "Returning: DPN_OK");

	return DPN_OK;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNSP_GetAddressInfo - get address information for an endpoint
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetAddressInfo"

STDMETHODIMP	DNSP_GetAddressInfo( IDP8ServiceProvider *pThis, SPGETADDRESSINFODATA *pGetAddressInfoData )
{
	HRESULT		hr;
	CEndpoint	*pEndpoint;
	CSPData		*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pGetAddressInfoData);

	DNASSERT( pThis != NULL );
	DNASSERT( pGetAddressInfoData != NULL );
	DNASSERT( pGetAddressInfoData->hEndpoint != INVALID_HANDLE_VALUE && pGetAddressInfoData->hEndpoint != 0 );
#ifdef DPNBUILD_NOMULTICAST
	DNASSERT( ( pGetAddressInfoData->Flags & ~( SP_GET_ADDRESS_INFO_LOCAL_ADAPTER |
												SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES |
												SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS |
												SP_GET_ADDRESS_INFO_REMOTE_HOST ) ) == 0 );
#else // ! DPNBUILD_NOMULTICAST
	DNASSERT( ( pGetAddressInfoData->Flags & ~( SP_GET_ADDRESS_INFO_LOCAL_ADAPTER |
												SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES |
												SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS |
												SP_GET_ADDRESS_INFO_REMOTE_HOST |
												SP_GET_ADDRESS_INFO_MULTICAST_GROUP ) ) == 0 );
#endif // ! DPNBUILD_NOMULTICAST

	//
	// initialize
	//
	hr = DPN_OK;
	DBG_CASSERT( sizeof( pEndpoint ) == sizeof( pGetAddressInfoData->hEndpoint ) );
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//
	pEndpoint = pSPData->EndpointFromHandle( pGetAddressInfoData->hEndpoint );
	if ( pEndpoint != NULL )
	{
		switch ( pGetAddressInfoData->Flags )
		{
			case SP_GET_ADDRESS_INFO_LOCAL_ADAPTER:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_DEVICE );
				if (pGetAddressInfoData->pAddress == NULL)
				{
					DPFX(DPFPREP, 0, "Couldn't get local adapter device address!");
					hr = DPNERR_OUTOFMEMORY;
				}
				break;
			}

			case SP_GET_ADDRESS_INFO_LISTEN_HOST_ADDRESSES:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_HOST );
				if (pGetAddressInfoData->pAddress == NULL)
				{
					DPFX(DPFPREP, 0, "Couldn't get local adapter host address!");
					hr = DPNERR_OUTOFMEMORY;
				}
				break;
			}

			case SP_GET_ADDRESS_INFO_LOCAL_HOST_PUBLIC_ADDRESS:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetLocalAdapterDP8Address( SP_ADDRESS_TYPE_PUBLIC_HOST_ADDRESS );
				break;
			}

			case SP_GET_ADDRESS_INFO_REMOTE_HOST:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetRemoteHostDP8Address();
				if (pGetAddressInfoData->pAddress == NULL)
				{
					DPFX(DPFPREP, 0, "Couldn't get remote host address!");
					hr = DPNERR_OUTOFMEMORY;
				}
				break;
			}
			
#ifndef DPNBUILD_NOMULTICAST
			case SP_GET_ADDRESS_INFO_MULTICAST_GROUP:
			{
				pGetAddressInfoData->pAddress = pEndpoint->GetRemoteHostDP8Address();

				//
				// If we successfully got an address, add the multicast scope GUID.
				//
				if (pGetAddressInfoData->pAddress != NULL)
				{
					GUID	guidScope;


					pEndpoint->GetScopeGuid(&guidScope);
					hr = IDirectPlay8Address_AddComponent(pGetAddressInfoData->pAddress,
															DPNA_KEY_SCOPE,
															&guidScope,
															sizeof(guidScope),
															DPNA_DATATYPE_GUID);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't add scope GUID component to address (err = 0x%lx)!  Ignoring.", hr);
						hr = DPN_OK;
					}
				}
				else
				{
					DPFX(DPFPREP, 0, "Couldn't get multicast group address!");
					hr = DPNERR_OUTOFMEMORY;
				}
				break;
			}
#endif // ! DPNBUILD_NOMULTICAST
			
			default:
			{
				DNASSERT( FALSE );
				break;
			}
		}
	
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	else
	{
		hr = DPNERR_INVALIDENDPOINT;
	}

	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "Problem getting DNAddress from endpoint!" );
		DisplayDNError( 0, hr );
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// DNSP_Update - update information/status of an endpoint
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_Update"

STDMETHODIMP	DNSP_Update( IDP8ServiceProvider *pThis, SPUPDATEDATA *pUpdateData )
{
	HRESULT		hr;
	CSPData		*pSPData;
	CEndpoint	*pEndpoint;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pUpdateData);

	DNASSERT( pThis != NULL );
	DNASSERT( pUpdateData != NULL );
	
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//
	
	switch ( pUpdateData->UpdateType )
	{
		case SP_UPDATE_HOST_MIGRATE:
		{
#ifdef DBG
			DNASSERT( ( pUpdateData->hEndpoint != INVALID_HANDLE_VALUE ) && ( pUpdateData->hEndpoint != NULL ) );
			DBG_CASSERT( sizeof( pEndpoint ) == sizeof( pUpdateData->hEndpoint ) );
			pEndpoint = pSPData->EndpointFromHandle( pUpdateData->hEndpoint );
			if (pEndpoint == NULL)
			{
				DPFX(DPFPREP, 0, "Host migrate endpoint 0x%p is invalid!", pEndpoint);
				DNASSERT( FALSE );
				hr = DPNERR_INVALIDENDPOINT;
				break;
			}

			DNASSERT( pEndpoint->GetType() == ENDPOINT_TYPE_LISTEN );

			DPFX(DPFPREP, 3, "Host migrated to listen endpoint 0x%p.", pEndpoint);

			pEndpoint->DecCommandRef();
			pEndpoint = NULL;
#endif // DBG

			hr = DPN_OK;
			break;
		}
		
		case SP_UPDATE_ALLOW_ENUMS:
		case SP_UPDATE_DISALLOW_ENUMS:
		{
			DNASSERT( ( pUpdateData->hEndpoint != INVALID_HANDLE_VALUE ) && ( pUpdateData->hEndpoint != NULL ) );
			DBG_CASSERT( sizeof( pEndpoint ) == sizeof( pUpdateData->hEndpoint ) );
			pEndpoint = pSPData->EndpointFromHandle( pUpdateData->hEndpoint );
			if (pEndpoint == NULL)
			{
				DPFX(DPFPREP, 0, "Allow/disallow enums endpoint 0x%p is invalid!", pEndpoint);
				DNASSERT( FALSE );
				hr = DPNERR_INVALIDENDPOINT;
				break;
			}
			
			DNASSERT( pEndpoint->GetType() == ENDPOINT_TYPE_LISTEN );

			if ( pUpdateData->UpdateType == SP_UPDATE_ALLOW_ENUMS )
			{
				DPFX(DPFPREP, 3, "Allowing enums on listen endpoint 0x%p.", pEndpoint);
				pEndpoint->SetEnumsAllowedOnListen( TRUE, TRUE );
			}
			else
			{
				DPFX(DPFPREP, 3, "Disallowing enums on listen endpoint 0x%p.", pEndpoint);
				pEndpoint->SetEnumsAllowedOnListen( FALSE, TRUE );
			}
			
			pEndpoint->DecCommandRef();
			pEndpoint = NULL;
			
			hr = DPN_OK;
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unsupported update type %u!", pUpdateData->UpdateType);
			hr = DPNERR_UNSUPPORTED;
			break;
		}
	}

	
	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;
}
//**********************************************************************

#ifndef DPNBUILD_LIBINTERFACE

//**********************************************************************
// ------------------------------
// DNSP_IsApplicationSupported - determine if this application is supported by this
//		SP.
//
// Entry:		Pointer to DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_IsApplicationSupported"

STDMETHODIMP	DNSP_IsApplicationSupported( IDP8ServiceProvider *pThis, SPISAPPLICATIONSUPPORTEDDATA *pIsApplicationSupportedData )
{
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pIsApplicationSupportedData);

	DNASSERT( pThis != NULL );
	DNASSERT( pIsApplicationSupportedData != NULL );
	DNASSERT( pIsApplicationSupportedData->pApplicationGuid != NULL );
	DNASSERT( pIsApplicationSupportedData->dwFlags == 0 );

	//
	// initialize, we support all applications with this SP
	//
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );


	DPFX(DPFPREP, 2, "Returning: DPN_OK");

	return	DPN_OK;
}
//**********************************************************************

#endif // ! DPNBUILD_LIBINTERFACE



#ifndef DPNBUILD_ONLYONEADAPTER

//**********************************************************************
// ------------------------------
// DNSP_EnumAdapters - get a list of adapters for this SP
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumAdapters"

STDMETHODIMP	DNSP_EnumAdapters( IDP8ServiceProvider *pThis, SPENUMADAPTERSDATA *pEnumAdaptersData )
{
	HRESULT			hr;
	CSocketAddress	*pSPAddress;
	CSPData			*pSPData;	


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumAdaptersData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumAdaptersData != NULL );
	DNASSERT( ( pEnumAdaptersData->pAdapterData != NULL ) ||
			  ( pEnumAdaptersData->dwAdapterDataSize == 0 ) );
	DNASSERT( pEnumAdaptersData->dwFlags == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	pEnumAdaptersData->dwAdapterCount = 0;
	pSPAddress = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// get an SP address from the pool to perform conversions to GUIDs
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pSPAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pSPAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pSPData->GetType()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ( pSPAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get address for GUID conversions in DNSP_EnumAdapters!" );
		goto Failure;
	}

	//
	// enumerate adapters
	//
	hr = pSPAddress->EnumAdapters( pEnumAdaptersData );
	if ( hr != DPN_OK )
	{
		if (hr == DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 1, "Buffer too small for enumerating adapters.");
		}
		else
		{
			DPFX(DPFPREP, 0, "Problem enumerating adapters (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
		}

		goto Failure;
	}

Exit:
	if ( pSPAddress != NULL )
	{
		g_SocketAddressPool.Release( pSPAddress );
		pSPAddress = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************

#endif // ! DPNBUILD_ONLYONEADAPTER


#ifndef DPNBUILD_SINGLEPROCESS
//**********************************************************************
// ------------------------------
// DNSP_ProxyEnumQuery - proxy an enum query
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ProxyEnumQuery"

STDMETHODIMP	DNSP_ProxyEnumQuery( IDP8ServiceProvider *pThis, SPPROXYENUMQUERYDATA *pProxyEnumQueryData )
{
	HRESULT								hr;
	CSPData								*pSPData;
	CSocketAddress						*pDestinationAddress;
	CSocketAddress						*pReturnAddress;
	CEndpoint							*pEndpoint;
	const ENDPOINT_ENUM_QUERY_CONTEXT	*pEndpointEnumContext;
	BUFFERDESC							BufferDesc[2];
	PREPEND_BUFFER						PrependBuffer;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pProxyEnumQueryData);

	DNASSERT( pThis != NULL );
	DNASSERT( pProxyEnumQueryData != NULL );
	DNASSERT( pProxyEnumQueryData->dwFlags == 0 );

	//
	// initialize
	//
	hr = DPN_OK;
	DBG_CASSERT( OFFSETOF( ENDPOINT_ENUM_QUERY_CONTEXT, EnumQueryData ) == 0 );
	pEndpointEnumContext = reinterpret_cast<ENDPOINT_ENUM_QUERY_CONTEXT*>( pProxyEnumQueryData->pIncomingQueryData );
	DNASSERT(pEndpointEnumContext->pReturnAddress != NULL);
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pDestinationAddress = NULL;
	pReturnAddress = NULL;
	pEndpoint = NULL;

	//
	// No need to tell thread pool to lock the thread count for this function
	// because there's already an outstanding enum that did.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// preallocate addresses
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pDestinationAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pDestinationAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pEndpointEnumContext->pReturnAddress->GetFamily()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ( pDestinationAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pReturnAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pReturnAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pEndpointEnumContext->pReturnAddress->GetFamily()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ( pReturnAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// set the endpoint and send it along
	//
	pEndpoint = pSPData->EndpointFromHandle( pEndpointEnumContext->hEndpoint );
	if ( pEndpoint == NULL )
	{
		hr = DPNERR_INVALIDENDPOINT;
		DPFX(DPFPREP, 8, "Invalid endpoint handle in DNSP_ProxyEnumQuery" );
		goto Failure;
	}

	
	//
	// set destination address from the supplied data
	//
	hr = pDestinationAddress->SocketAddressFromDP8Address( pProxyEnumQueryData->pDestinationAdapter,
#ifdef DPNBUILD_XNETSECURITY
															NULL,
#endif // DPNBUILD_XNETSECURITY
#ifndef DPNBUILD_ONLYONETHREAD
															FALSE,
#endif // DPNBUILD_ONLYONETHREAD
															SP_ADDRESS_TYPE_DEVICE );
	if ( hr != DPN_OK )
	{
		DPFX(DPFPREP, 0, "ProxyEnumQuery: Failed to convert target adapter address" );
		goto Failure;
	}

	//
	// set return address from incoming enum query
	//
	memcpy( pReturnAddress->GetWritableAddress(),
			pEndpointEnumContext->pReturnAddress->GetAddress(),
			pEndpointEnumContext->pReturnAddress->GetAddressSize() );
	

	DNASSERT(pProxyEnumQueryData->pIncomingQueryData->pReceivedData->pNext == NULL);
	DNASSERT( pEndpointEnumContext->dwEnumKey <= WORD_MAX );

	BufferDesc[0].pBufferData = reinterpret_cast<BYTE*>(&PrependBuffer.ProxiedEnumDataHeader);
	BufferDesc[0].dwBufferSize = sizeof( PrependBuffer.ProxiedEnumDataHeader );
	memcpy(&BufferDesc[1],
			&pProxyEnumQueryData->pIncomingQueryData->pReceivedData->BufferDesc,
			sizeof(BufferDesc[1]));

	PrependBuffer.ProxiedEnumDataHeader.bSPLeadByte = SP_HEADER_LEAD_BYTE;
	PrependBuffer.ProxiedEnumDataHeader.bSPCommandByte = PROXIED_ENUM_DATA_KIND;
	PrependBuffer.ProxiedEnumDataHeader.wEnumKey = static_cast<WORD>( pEndpointEnumContext->dwEnumKey );
	//
	// We could save 2 bytes on IPX by only passing 14 bytes for the
	// SOCKADDR structure but it's not worth it, especially since it's
	// looping back in the local network stack.  SOCKADDR structures are also
	// 16 bytes so reducing the data passed to 14 bytes would destroy alignment.
	//
	// Note that if we're using the large IPv6 addresses, the IPX wasted space is
	// larger, and IPv4 addresses will now waste some, too.
	//
	DBG_CASSERT( (sizeof( PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) % 4) == 0 );
	memcpy( &PrependBuffer.ProxiedEnumDataHeader.ReturnAddress,
			pReturnAddress->GetAddress(),
			sizeof( PrependBuffer.ProxiedEnumDataHeader.ReturnAddress ) );

#ifdef DPNBUILD_ASYNCSPSENDS
	pEndpoint->GetSocketPort()->SendData( BufferDesc, 2, pDestinationAddress, NULL );
#else // ! DPNBUILD_ASYNCSPSENDS
	pEndpoint->GetSocketPort()->SendData( BufferDesc, 2, pDestinationAddress );
#endif // ! DPNBUILD_ASYNCSPSENDS

	pEndpoint->DecCommandRef();
	pEndpoint = NULL;

Exit:
	if ( pReturnAddress != NULL )
	{
		g_SocketAddressPool.Release( pReturnAddress );
		pReturnAddress = NULL;
	}
	if (pDestinationAddress != NULL )
	{
		g_SocketAddressPool.Release( pDestinationAddress );
		pDestinationAddress = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;

Failure:
	if (pEndpoint != NULL )
	{
		pEndpoint->DecCommandRef();
		pEndpoint = NULL;
	}
	goto Exit;
}
//**********************************************************************

#endif // ! DPNBUILD_SINGLEPROCESS

//**********************************************************************
/*
 *
 *	DNSP_NotSupported is used for methods required to implement the
 *  interface but that are not supported by this SP.
 *
 */
//**********************************************************************
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_NotSupported"

STDMETHODIMP DNSP_NotSupported( IDP8ServiceProvider *pThis, PVOID pvParam )
{
	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pvParam);
	DPFX(DPFPREP, 2, "Returning: [DPNERR_UNSUPPORTED]");
	return DPNERR_UNSUPPORTED;
}
//**********************************************************************



#ifndef DPNBUILD_NOMULTICAST

//**********************************************************************
// ------------------------------
// DNSP_EnumMulticastScopes - get a list of multicast scopes for this SP
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_EnumMulticastScopes"

STDMETHODIMP	DNSP_EnumMulticastScopes( IDP8ServiceProvider *pThis, SPENUMMULTICASTSCOPESDATA *pEnumMulticastScopesData )
{
	HRESULT			hr;
	CSPData			*pSPData;
	CSocketAddress	*pSPAddress;
	BOOL			fUseMADCAP;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pEnumMulticastScopesData);

	DNASSERT( pThis != NULL );
	DNASSERT( pEnumMulticastScopesData != NULL );
	DNASSERT( pEnumMulticastScopesData->pguidAdapter != NULL );
	DNASSERT( ( pEnumMulticastScopesData->pScopeData != NULL ) ||
			  ( pEnumMulticastScopesData->dwScopeDataSize == 0 ) );
	DNASSERT( pEnumMulticastScopesData->dwFlags == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	pEnumMulticastScopesData->dwScopeCount = 0;
	pSPAddress = NULL;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	// get an SP address from the pool to perform conversions to GUIDs
	//
#if ((defined(DPNBUILD_NOIPV6)) && (defined(DPNBUILD_NOIPX)))
	pSPAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) AF_INET));
#else // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	pSPAddress = (CSocketAddress*) g_SocketAddressPool.Get((PVOID) ((DWORD_PTR) pSPData->GetType()));
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
	if ( pSPAddress == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP, 0, "Failed to get address for GUID conversions in DNSP_EnumMulticastScopes!" );
		goto Failure;
	}

	//
	// enumerate adapters
	//
#ifdef WINNT
	fUseMADCAP = pSPData->GetThreadPool()->EnsureMadcapLoaded();
#else // ! WINNT
	fUseMADCAP = FALSE;
#endif // ! WINNT
	hr = pSPAddress->EnumMulticastScopes( pEnumMulticastScopesData, fUseMADCAP );
	if ( hr != DPN_OK )
	{
		if (hr == DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 1, "Buffer too small for enumerating scopes.");
		}
		else
		{
			DPFX(DPFPREP, 0, "Problem enumerating scopes (err = 0x%lx)!", hr);
			DisplayDNError( 0, hr );
		}

		goto Failure;
	}


Exit:

	if ( pSPAddress != NULL )
	{
		g_SocketAddressPool.Release( pSPAddress );
		pSPAddress = NULL;
	}

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;


Failure:

	goto Exit;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNSP_ShareEndpointInfo - get a list of multicast scopes for this SP
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_ShareEndpointInfo"

STDMETHODIMP	DNSP_ShareEndpointInfo( IDP8ServiceProvider *pThis, SPSHAREENDPOINTINFODATA *pShareEndpointInfoData )
{
	HRESULT			hr;
	CSPData			*pSPData;
	CSPData			*pSPDataShare;
	BOOL			fShareInterfaceReferenceAdded;
	CSocketData		*pSocketData;
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	short			sShareSPType;
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pShareEndpointInfoData);

	DNASSERT( pThis != NULL );
	DNASSERT( pShareEndpointInfoData != NULL );
	DNASSERT( pShareEndpointInfoData->pDP8ServiceProvider != NULL );
	DNASSERT( pShareEndpointInfoData->dwFlags == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );
	pSPDataShare = CSPData::SPDataFromCOMInterface( pShareEndpointInfoData->pDP8ServiceProvider );
	fShareInterfaceReferenceAdded = FALSE;
	pSocketData = NULL;

	//
	// no need to tell thread pool to lock the thread count for this function.
	//


	//
	// First, validate the source (shared) SP's state.  We must assume it's a
	// valid dpnwsock SP (CSPData::SPDataFromCOMInterface should assert if not),
	// but we can make sure it has been initialized.
	//
	pSPDataShare->Lock();
	switch ( pSPDataShare->GetState() )
	{
		//
		// provider is initialized, add a reference and proceed
		//
		case SPSTATE_INITIALIZED:
		{
			IDP8ServiceProvider_AddRef( pShareEndpointInfoData->pDP8ServiceProvider );
			fShareInterfaceReferenceAdded = TRUE;
			DNASSERT( hr == DPN_OK );
			break;
		}

		//
		// provider is uninitialized
		//
		case SPSTATE_UNINITIALIZED:
		{
			hr = DPNERR_UNINITIALIZED;
			DPFX(DPFPREP, 0, "ShareEndpointInfo called with uninitialized shared SP 0x%p!",
				pSPDataShare );

			break;
		}

		//
		// provider is closing
		//
		case SPSTATE_CLOSING:
		{
			hr = DPNERR_ABORTED;
				DPFX(DPFPREP, 0, "ShareEndpointInfo called with shared SP 0x%p that is closing!",
					pSPDataShare );

			break;
		}

		//
		// unknown
		//
		default:
		{
			DPFX(DPFPREP, 0, "ShareEndpointInfo called with shared SP 0x%p in unrecognized state %u!",
				pSPDataShare, pSPDataShare->GetState() );
			DNASSERT( FALSE );
			hr = DPNERR_GENERIC;

			break;
		}
	}
	pSPDataShare->Unlock();
	if ( hr != DPN_OK )
	{
		goto Failure;
	}

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	//
	// We can also double check that it's not the wrong type (IP vs. IPX).
	//
	sShareSPType = pSPDataShare->GetType();
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX


	//
	// Make sure the source SP has a valid socket data object, and get a
	// reference to it.  Don't create it if it didn't exist, though.
	//
	pSPDataShare->Lock();
	pSocketData = pSPDataShare->GetSocketData();
	if (pSocketData == NULL)
	{
		pSPDataShare->Unlock();
		
		DPFX(DPFPREP, 0, "Cannot share endpoint info, shared SP has not created its own endpoint information yet!" );
		hr = DPNERR_NOTREADY;
		goto Failure;
	}

	pSocketData->AddRef();
	pSPDataShare->Unlock();


	IDP8ServiceProvider_Release( pShareEndpointInfoData->pDP8ServiceProvider );
	fShareInterfaceReferenceAdded = FALSE;


	//
	// Validate the local SP's state
	//
	pSPData->Lock();

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
	if (pSPData->GetType() != sShareSPType)
	{
		pSPData->Unlock();
		DPFX(DPFPREP, 0, "ShareEndpointInfo called on different SP types (0x%p == state %u, 0x%p == state %u)!",
			pSPData, pSPData->GetState(), pSPDataShare, pSPDataShare->GetState() );
		hr = DPNERR_INVALIDINTERFACE;
		goto Failure;
	}
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX


	//
	// If we're here, the provider is initialized and of the right type.
	// Make sure we do not already have "endpoint info" of our own.
	//
	if (pSPData->GetSocketData() != NULL)
	{
		pSPData->Unlock();
		DPFX(DPFPREP, 0, "Cannot share endpoint info, SP has already created its own endpoint information!" );
		hr = DPNERR_ALREADYINITIALIZED;
		goto Failure;
	}

	//
	// Transfer the local reference to the SP data object.
	//
	pSPData->SetSocketData(pSocketData);
	pSocketData = NULL;

	pSPData->Unlock();

	DNASSERT( hr == DPN_OK );


Exit:

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;


Failure:

	if ( pSocketData != NULL )
	{
		pSocketData->Release();
		pSocketData = NULL;
	}

	if ( fShareInterfaceReferenceAdded != FALSE )
	{
		IDP8ServiceProvider_Release( pThis );
		fShareInterfaceReferenceAdded = FALSE;
	}

	goto Exit;
}
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNSP_GetEndpointByAddress - retrieves an endpoint, given its addressing information
//
// Entry:		Pointer DNSP Interface
//				Pointer to input data
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNSP_GetEndpointByAddress"

STDMETHODIMP	DNSP_GetEndpointByAddress( IDP8ServiceProvider* pThis, SPGETENDPOINTBYADDRESSDATA *pGetEndpointByAddressData )
{
	HRESULT			hr;
	CSPData			*pSPData;


	DPFX(DPFPREP, 2, "Parameters: (0x%p, 0x%p)", pThis, pGetEndpointByAddressData);

	DNASSERT( pThis != NULL );
	DNASSERT( pGetEndpointByAddressData != NULL );
	DNASSERT( pGetEndpointByAddressData->pAddressHost != NULL );
	DNASSERT( pGetEndpointByAddressData->pAddressDeviceInfo != NULL );
	DNASSERT( pGetEndpointByAddressData->dwFlags == 0 );


	//
	// initialize
	//
	hr = DPN_OK;
	pSPData = CSPData::SPDataFromCOMInterface( pThis );

	//
	// no need to tell thread pool to lock the thread count for this function.
	//

	// Trust protocol to call us only in the initialized state
	DNASSERT( pSPData->GetState() == SPSTATE_INITIALIZED );

	//
	//  Look up the endpoint handle and context
	//
	hr = pSPData->GetEndpointFromAddress(pGetEndpointByAddressData->pAddressHost,
										pGetEndpointByAddressData->pAddressDeviceInfo,
										&pGetEndpointByAddressData->hEndpoint,
										&pGetEndpointByAddressData->pvEndpointContext);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get endpoint from address (err = 0x%lx)!", hr);
		goto Failure;
	}


Exit:

	DPFX(DPFPREP, 2, "Returning: [0x%lx]", hr);

	return	hr;


Failure:

	goto Exit;
}
//**********************************************************************

#endif // ! DPNBUILD_NOMULTICAST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\utils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       Utils.cpp
 *  Content:	Serial service provider utility functions
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#include "dnwsocki.h"



//**********************************************************************
// Constant definitions
//**********************************************************************

#define DEFAULT_THREADS_PER_PROCESSOR	3

#define REGSUBKEY_DPNATHELP_DIRECTPLAY8PRIORITY		L"DirectPlay8Priority"
#define REGSUBKEY_DPNATHELP_DIRECTPLAY8INITFLAGS	L"DirectPlay8InitFlags"
#define REGSUBKEY_DPNATHELP_GUID					L"Guid"


//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// global variables that are unique for the process
//
#ifndef DPNBUILD_ONLYONETHREAD
static	DNCRITICAL_SECTION			g_InterfaceGlobalsLock;
#endif // !DPNBUILD_ONLYONETHREAD

static volatile	LONG				g_iThreadPoolRefCount = 0;
static	CThreadPool *				g_pThreadPool = NULL;


static volatile LONG				g_iWinsockRefCount = 0;

#ifndef DPNBUILD_NONATHELP
static volatile LONG				g_iNATHelpRefCount = 0;
#endif // ! DPNBUILD_NONATHELP

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
static volatile LONG				g_iMadcapRefCount = 0;
BYTE								g_abClientID[MCAST_CLIENT_ID_LEN];
#endif // WINNT and not DPNBUILD_NOMULTICAST




//**********************************************************************
// Function prototypes
//**********************************************************************
#ifndef DPNBUILD_NOREGISTRY
static void		ReadSettingsFromRegistry( void );
static BOOL		BannedIPv4AddressCompareFunction( PVOID pvKey1, PVOID pvKey2 );
static DWORD	BannedIPv4AddressHashFunction( PVOID pvKey, BYTE bBitDepth );
static void		ReadBannedIPv4Addresses( CRegistry * pRegObject );
#endif // ! DPNBUILD_NOREGISTRY



//**********************************************************************
// Function definitions
//**********************************************************************


#if defined(WINCE) && !defined(_MAX_DRIVE)
//typedef signed char     _TSCHAR;
#define _MAX_DRIVE  3   /* max. length of drive component */
#define _MAX_DIR    256 /* max. length of path component */
#define _MAX_FNAME  256 /* max. length of file name component */
#define _MAX_EXT    256 /* max. length of extension component */

void __cdecl _tsplitpath (
        register const _TSCHAR *path,
        _TSCHAR *drive,
        _TSCHAR *dir,
        _TSCHAR *fname,
        _TSCHAR *ext
        )
{
        register _TSCHAR *p;
        _TSCHAR *last_slash = NULL, *dot = NULL;
        unsigned len;

        /* we assume that the path argument has the following form, where any
         * or all of the components may be missing.
         *
         *  <drive><dir><fname><ext>
         *
         * and each of the components has the following expected form(s)
         *
         *  drive:
         *  0 to _MAX_DRIVE-1 characters, the last of which, if any, is a
         *  ':'
         *  dir:
         *  0 to _MAX_DIR-1 characters in the form of an absolute path
         *  (leading '/' or '\') or relative path, the last of which, if
         *  any, must be a '/' or '\'.  E.g -
         *  absolute path:
         *      \top\next\last\     ; or
         *      /top/next/last/
         *  relative path:
         *      top\next\last\  ; or
         *      top/next/last/
         *  Mixed use of '/' and '\' within a path is also tolerated
         *  fname:
         *  0 to _MAX_FNAME-1 characters not including the '.' character
         *  ext:
         *  0 to _MAX_EXT-1 characters where, if any, the first must be a
         *  '.'
         *
         */

        /* extract drive letter and :, if any */

        if ((_tcslen(path) >= (_MAX_DRIVE - 2)) && (*(path + _MAX_DRIVE - 2) == _T(':'))) {
            if (drive) {
                _tcsncpy(drive, path, _MAX_DRIVE - 1);
                *(drive + _MAX_DRIVE-1) = _T('\0');
            }
            path += _MAX_DRIVE - 1;
        }
        else if (drive) {
            *drive = _T('\0');
        }

        /* extract path string, if any.  Path now points to the first character
         * of the path, if any, or the filename or extension, if no path was
         * specified.  Scan ahead for the last occurence, if any, of a '/' or
         * '\' path separator character.  If none is found, there is no path.
         * We will also note the last '.' character found, if any, to aid in
         * handling the extension.
         */

        for (last_slash = NULL, p = (_TSCHAR *)path; *p; p++) {
#ifdef _MBCS
            if (_ISLEADBYTE (*p))
                p++;
            else {
#endif  /* _MBCS */
            if (*p == _T('/') || *p == _T('\\'))
                /* point to one beyond for later copy */
                last_slash = p + 1;
            else if (*p == _T('.'))
                dot = p;
#ifdef _MBCS
            }
#endif  /* _MBCS */
        }

        if (last_slash) {

            /* found a path - copy up through last_slash or max. characters
             * allowed, whichever is smaller
             */

            if (dir) {
                len = __min(((char *)last_slash - (char *)path) / sizeof(_TSCHAR),
                    (_MAX_DIR - 1));
                _tcsncpy(dir, path, len);
                *(dir + len) = _T('\0');
            }
            path = last_slash;
        }
        else if (dir) {

            /* no path found */

            *dir = _T('\0');
        }

        /* extract file name and extension, if any.  Path now points to the
         * first character of the file name, if any, or the extension if no
         * file name was given.  Dot points to the '.' beginning the extension,
         * if any.
         */

        if (dot && (dot >= path)) {
            /* found the marker for an extension - copy the file name up to
             * the '.'.
             */
            if (fname) {
                len = __min(((char *)dot - (char *)path) / sizeof(_TSCHAR),
                    (_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            /* now we can get the extension - remember that p still points
             * to the terminating nul character of path.
             */
            if (ext) {
                len = __min(((char *)p - (char *)dot) / sizeof(_TSCHAR),
                    (_MAX_EXT - 1));
                _tcsncpy(ext, dot, len);
                *(ext + len) = _T('\0');
            }
        }
        else {
            /* found no extension, give empty extension and copy rest of
             * string into fname.
             */
            if (fname) {
                len = __min(((char *)p - (char *)path) / sizeof(_TSCHAR),
                    (_MAX_FNAME - 1));
                _tcsncpy(fname, path, len);
                *(fname + len) = _T('\0');
            }
            if (ext) {
                *ext = _T('\0');
            }
        }
}

#endif // WINCE



#ifndef DPNBUILD_NOREGISTRY

//**********************************************************************
// ------------------------------
// ReadSettingsFromRegistry - read custom registry keys
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "ReadSettingsFromRegistry"

static void	ReadSettingsFromRegistry( void )
{
	CRegistry	RegObject;
	CRegistry	RegObjectTemp;
	CRegistry	RegObjectAppEntry;
	DWORD		dwRegValue;
	BOOL		fGotPath;
	WCHAR		wszExePath[_MAX_PATH];
#ifndef UNICODE
	char		szExePath[_MAX_PATH];
#endif // !UNICODE


	if ( RegObject.Open( HKEY_LOCAL_MACHINE, g_RegistryBase ) != FALSE )
	{
		//
		// Find out the current process name.
		//
#ifdef UNICODE
		if (GetModuleFileName(NULL, wszExePath, _MAX_PATH) > 0)
		{
			DPFX(DPFPREP, 3, "Loading DLL in process: %ls", wszExePath);
			_tsplitpath( wszExePath, NULL, NULL, wszExePath, NULL );
			fGotPath = TRUE;
		}
#else // ! UNICODE
		if (GetModuleFileName(NULL, szExePath, _MAX_PATH) > 0)
		{
			HRESULT		hr;

			
			DPFX(DPFPREP, 3, "Loading DLL in process: %hs", szExePath);
			_tsplitpath( szExePath, NULL, NULL, szExePath, NULL );

			dwRegValue = _MAX_PATH;
			hr = STR_AnsiToWide(szExePath, -1, wszExePath, &dwRegValue );
			if ( hr == DPN_OK )
			{
				//
				// Successfully converted ANSI path to Wide characters.
				//
				fGotPath = TRUE;
			}
			else
			{
				//
				// Couldn't convert ANSI path to Wide characters
				//
				fGotPath = FALSE;
			}
		}
#endif // ! UNICODE
		else
		{
			//
			// Couldn't get current process path.
			//
			fGotPath = FALSE;
		}

		
		//
		// read receive buffer size
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyReceiveBufferSize, &dwRegValue ) != FALSE )
		{
			g_fWinsockReceiveBufferSizeOverridden = TRUE;
			g_iWinsockReceiveBufferSize = dwRegValue;
		}

#ifndef DPNBUILD_ONLYONETHREAD
		//
		// read default threads
		//
		if ( RegObject.ReadDWORD( g_RegistryKeyThreadCount, &dwRegValue ) != FALSE )
		{
			g_iThreadCount = dwRegValue;	
		}
	
		//
		// if thread count is zero, use the 'default' for the system
		//
		if ( g_iThreadCount == 0 )
		{
			g_iThreadCount = DEFAULT_THREADS_PER_PROCESSOR;
			
#ifndef DPNBUILD_ONLYONEPROCESSOR
			SYSTEM_INFO		SystemInfo;

			GetSystemInfo(&SystemInfo);
			g_iThreadCount *= SystemInfo.dwNumberOfProcessors;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		}
#endif // ! DPNBUILD_ONLYONETHREAD
	
#if ((! defined(DPNBUILD_NOWINSOCK2)) && (! defined(DPNBUILD_ONLYWINSOCK2)))
		//
		// Winsock2 9x option
		//
		if (RegObject.ReadDWORD( g_RegistryKeyWinsockVersion, &dwRegValue ))
		{
			switch (dwRegValue)
			{
				case 0:
				{
					DPFX(DPFPREP, 1, "Explicitly using available Winsock version.");
					g_dwWinsockVersion = dwRegValue;
					break;
				}
				
				case 1:
				{
					DPFX(DPFPREP, 1, "Explicitly using Winsock 1 only.");
					g_dwWinsockVersion = dwRegValue;
					break;
				}
				
				case 2:
				{
					DPFX(DPFPREP, 1, "Explicitly using Winsock 2 (when available).");
					g_dwWinsockVersion = dwRegValue;
					break;
				}

				default:
				{
					DPFX(DPFPREP, 0, "Ignoring invalid Winsock version setting (%u).", dwRegValue);
					break;
				}
			}
		}
#endif // ! DPNBUILD_NOWINSOCK2 and ! DPNBUILD_ONLYWINSOCK2


#ifndef DPNBUILD_NONATHELP
		//
		// get global NAT traversal disablers, ignore registry reading error
		//
		if (RegObject.ReadBOOL( g_RegistryKeyDisableDPNHGatewaySupport, &g_fDisableDPNHGatewaySupport ))
		{
			if (g_fDisableDPNHGatewaySupport)
			{
				DPFX(DPFPREP, 1, "Disabling NAT Help gateway support.");
			}
			else
			{
				DPFX(DPFPREP, 1, "Explicitly not disabling NAT Help gateway support.");
			}
		}

		if (RegObject.ReadBOOL( g_RegistryKeyDisableDPNHFirewallSupport, &g_fDisableDPNHFirewallSupport ))
		{
			if (g_fDisableDPNHFirewallSupport)
			{
				DPFX(DPFPREP, 1, "Disabling NAT Help firewall support.");
			}
			else
			{
				DPFX(DPFPREP, 1, "Explicitly not disabling NAT Help firewall support.");
			}
		}
#endif // DPNBUILD_NONATHELP

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
		//
		// get global MADCAP API disabler, ignore registry reading error
		//
		if (RegObject.ReadBOOL( g_RegistryKeyDisableMadcapSupport, &g_fDisableMadcapSupport ))
		{
			if (g_fDisableMadcapSupport)
			{
				DPFX(DPFPREP, 1, "Disabling MADCAP support.");
			}
			else
			{
				DPFX(DPFPREP, 1, "Explicitly not disabling MADCAP support.");
			}
		}
#endif // WINNT and not DPNBUILD_NOMULTICAST

		
		//
		// If we have an app name, try opening the subkey and looking up the app
		// to see if enums are disabled, whether we should disconnect based on
		// ICMPs, and which IP protocol families to use.
		//
		if ( fGotPath )
		{
			if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyAppsToIgnoreEnums, TRUE, FALSE ) )
			{
				RegObjectTemp.ReadBOOL( wszExePath, &g_fIgnoreEnums );
				RegObjectTemp.Close();

				if ( g_fIgnoreEnums )
				{
					DPFX(DPFPREP, 0, "Ignoring all enumerations (app = %ls).", wszExePath);
				}
				else
				{
					DPFX(DPFPREP, 2, "Not ignoring all enumerations (app = %ls).", wszExePath);
				}
			}

			if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyAppsToDisconnectOnICMP, TRUE, FALSE ) )
			{
				RegObjectTemp.ReadBOOL( wszExePath, &g_fDisconnectOnICMP );
				RegObjectTemp.Close();

				if ( g_fDisconnectOnICMP )
				{
					DPFX(DPFPREP, 0, "Disconnecting upon receiving ICMP port not reachable messages (app = %ls).", wszExePath);
				}
				else
				{
					DPFX(DPFPREP, 2, "Not disconnecting upon receiving ICMP port not reachable messages (app = %ls).", wszExePath);
				}
			}

			
#ifndef DPNBUILD_NONATHELP
			if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyTraversalModeSettings, TRUE, FALSE ) )
			{
				//
				// Read the global default traversal mode.
				//
				if ( RegObjectTemp.ReadDWORD( g_RegistryKeyDefaultTraversalMode, &dwRegValue ) != FALSE )
				{
					switch (dwRegValue)
					{
						case DPNA_TRAVERSALMODE_NONE:
						case DPNA_TRAVERSALMODE_PORTREQUIRED:
						case DPNA_TRAVERSALMODE_PORTRECOMMENDED:
						{
							g_dwDefaultTraversalMode = dwRegValue;
							DPFX(DPFPREP, 1, "Using global default traversal mode %u.",
								g_dwDefaultTraversalMode);
							break;
						}

						case (DPNA_TRAVERSALMODE_NONE | FORCE_TRAVERSALMODE_BIT):
						case (DPNA_TRAVERSALMODE_PORTREQUIRED | FORCE_TRAVERSALMODE_BIT):
						case (DPNA_TRAVERSALMODE_PORTRECOMMENDED | FORCE_TRAVERSALMODE_BIT):
						{
							g_dwDefaultTraversalMode = dwRegValue;
							DPFX(DPFPREP, 1, "Forcing global traversal mode %u.",
								g_dwDefaultTraversalMode);
							break;
						}

						default:
						{
							DPFX(DPFPREP, 0, "Ignoring invalid global default traversal mode (%u).",
								dwRegValue);
							break;
						}
					}
				}

				//
				// Override with the per app setting.
				//
				if ( RegObjectTemp.ReadDWORD( wszExePath, &dwRegValue ) != FALSE )
				{
					switch (dwRegValue)
					{
						case DPNA_TRAVERSALMODE_NONE:
						case DPNA_TRAVERSALMODE_PORTREQUIRED:
						case DPNA_TRAVERSALMODE_PORTRECOMMENDED:
						{
							g_dwDefaultTraversalMode = dwRegValue;
							DPFX(DPFPREP, 1, "Using default traversal mode %u (app = %ls).",
								g_dwDefaultTraversalMode, wszExePath);
							break;
						}

						case (DPNA_TRAVERSALMODE_NONE | FORCE_TRAVERSALMODE_BIT):
						case (DPNA_TRAVERSALMODE_PORTREQUIRED | FORCE_TRAVERSALMODE_BIT):
						case (DPNA_TRAVERSALMODE_PORTRECOMMENDED | FORCE_TRAVERSALMODE_BIT):
						{
							g_dwDefaultTraversalMode = dwRegValue;
							DPFX(DPFPREP, 1, "Forcing traversal mode %u (app = %ls).",
								g_dwDefaultTraversalMode, wszExePath);
							break;
						}

						default:
						{
							DPFX(DPFPREP, 0, "Ignoring invalid default traversal mode (%u, app %ls).",
								dwRegValue, wszExePath);
							break;
						}
					}
				}
				
				RegObjectTemp.Close();
			}
#endif // DPNBUILD_NONATHELP

		
#ifndef DPNBUILD_NOIPV6
			if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyIPAddressFamilySettings, TRUE, FALSE ) )
			{
				//
				// Read the global IP address family setting.
				//
				if ( RegObjectTemp.ReadDWORD( g_RegistryKeyDefaultIPAddressFamily, &dwRegValue ) != FALSE )
				{
					switch (dwRegValue)
					{
						case PF_UNSPEC:
						case PF_INET:
						case PF_INET6:
						{
							g_iIPAddressFamily = dwRegValue;
							DPFX(DPFPREP, 1, "Using IP address family %i global setting.",
								g_iIPAddressFamily);
							break;
						}

						default:
						{
							DPFX(DPFPREP, 0, "Ignoring invalid IP address family global setting (%u).",
								dwRegValue);
							break;
						}
					}
				}

				//
				// Override with the per app setting.
				//
				if ( RegObjectTemp.ReadDWORD( wszExePath, &dwRegValue ) != FALSE )
				{
					switch (dwRegValue)
					{
						case PF_UNSPEC:
						case PF_INET:
						case PF_INET6:
						{
							g_iIPAddressFamily = dwRegValue;
							DPFX(DPFPREP, 1, "Using IP address family %i (app = %ls).",
								g_iIPAddressFamily, wszExePath);
							break;
						}

						default:
						{
							DPFX(DPFPREP, 0, "Ignoring invalid IP address family setting (%u, app %ls).",
								dwRegValue, wszExePath);
							break;
						}
					}
				}
				
				RegObjectTemp.Close();
			}
#endif // ! DPNBUILD_NOIPV6
		}
	

		//
		// Get the proxy support options, ignore registry reading error.
		//
#ifndef DPNBUILD_NOWINSOCK2
		if (RegObject.ReadBOOL( g_RegistryKeyDontAutoDetectProxyLSP, &g_fDontAutoDetectProxyLSP ))
		{
			if (g_fDontAutoDetectProxyLSP)
			{
				DPFX(DPFPREP, 1, "Not auto-detected ISA Proxy LSP.");
			}
			else
			{
				DPFX(DPFPREP, 1, "Explicitly allowing auto-detection of ISA Proxy LSP.");
			}
		}
#endif // !DPNBUILD_NOWINSOCK2
		if (RegObject.ReadBOOL( g_RegistryKeyTreatAllResponsesAsProxied, &g_fTreatAllResponsesAsProxied ))
		{
			if (g_fTreatAllResponsesAsProxied)
			{
				DPFX(DPFPREP, 1, "Treating all responses as proxied.");
			}
			else
			{
				DPFX(DPFPREP, 1, "Explicitly not treating all responses as proxied.");
			}
		}


		//
		// read MTU overrides
		//
		
		if ( RegObject.ReadDWORD( g_RegistryKeyMaxUserDataSize, &dwRegValue ) != FALSE )
		{
			if ((dwRegValue >= MIN_SEND_FRAME_SIZE) && (dwRegValue <= MAX_SEND_FRAME_SIZE))
			{
				//
				// If the new user data size is smaller than the the default enum setting,
				// shrink the enum size as well.  It can be explicitly overridden below.
				//
				if (dwRegValue < g_dwMaxEnumDataSize)
				{
					g_dwMaxUserDataSize = dwRegValue;
					g_dwMaxEnumDataSize = g_dwMaxUserDataSize - ENUM_PAYLOAD_HEADER_SIZE;
					DPFX(DPFPREP, 1, "Max user data size is set to %u, assuming enum payload is %u.",
						g_dwMaxUserDataSize, g_dwMaxEnumDataSize);
				}
				else
				{
					g_dwMaxUserDataSize = dwRegValue;
					DPFX(DPFPREP, 1, "Max user data size is set to %u.",
						g_dwMaxUserDataSize);
				}
			}
			else
			{
				DPFX(DPFPREP, 0, "Ignoring invalid max user data size setting (%u).",
					dwRegValue);
			}
		}

		if ( RegObject.ReadDWORD( g_RegistryKeyMaxEnumDataSize, &dwRegValue ) != FALSE )
		{
			if ((dwRegValue >= (MIN_SEND_FRAME_SIZE - ENUM_PAYLOAD_HEADER_SIZE)) &&
				(dwRegValue <= (MAX_SEND_FRAME_SIZE - ENUM_PAYLOAD_HEADER_SIZE)))
			{
				DPFX(DPFPREP, 1, "Max user data size is set to %u.",
					dwRegValue);
				g_dwMaxEnumDataSize = dwRegValue;
			}
			else
			{
				DPFX(DPFPREP, 0, "Ignoring invalid max user data size setting (%u).",
					dwRegValue);
			}
		}


		//
		// read default port range
		//
		
		if ( RegObject.ReadDWORD( g_RegistryKeyBaseDPlayPort, &dwRegValue ) != FALSE )
		{
			if (dwRegValue < (WORD_MAX - 100)) // cannot be 65435 or above
			{
				g_wBaseDPlayPort = (WORD) dwRegValue;
				DPFX(DPFPREP, 1, "Base DPlay default port set to %u.",
					g_wBaseDPlayPort);
			}
			else
			{
				DPFX(DPFPREP, 0, "Ignoring invalid base DPlay default port setting (%u).",
					dwRegValue);
			}
		}

		if ( RegObject.ReadDWORD( g_RegistryKeyMaxDPlayPort, &dwRegValue ) != FALSE )
		{
			if (dwRegValue <= WORD_MAX) // cannot be greater than 65535
			{
				g_wMaxDPlayPort = (WORD) dwRegValue;
				DPFX(DPFPREP, 1, "Max DPlay default port set to %u.",
					g_wMaxDPlayPort);
			}
			else
			{
				DPFX(DPFPREP, 0, "Ignoring invalid max DPlay default port setting (%u).",
					dwRegValue);
			}
		}

		if (g_wMaxDPlayPort <= g_wBaseDPlayPort)
		{
			DPFX(DPFPREP, 1, "Max DPlay default port %u is less than or equal to base %u, setting to %u.",
				g_wMaxDPlayPort, g_wBaseDPlayPort, (g_wBaseDPlayPort + 100));
			g_wMaxDPlayPort = g_wBaseDPlayPort + 100;
		}


		RegObject.Close();
	}

#pragma TODO(vanceo, "Be able to read while session is still running")
	if ( RegObject.Open( HKEY_LOCAL_MACHINE, g_RegistryBase, TRUE, FALSE ) != FALSE )
	{
		if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyBannedIPv4Addresses, TRUE, FALSE ) )
		{
			DPFX(DPFPREP, 1, "Reading banned IPv4 addresses for all users.");
			ReadBannedIPv4Addresses(&RegObjectTemp);
		}
		RegObject.Close();
	}
	
	if ( RegObject.Open( HKEY_CURRENT_USER, g_RegistryBase, TRUE, FALSE ) != FALSE )
	{
		if ( RegObjectTemp.Open( RegObject.GetHandle(), g_RegistryKeyBannedIPv4Addresses, TRUE, FALSE ) )
		{
			DPFX(DPFPREP, 1, "Reading banned IPv4 addresses for current user.");
			ReadBannedIPv4Addresses(&RegObjectTemp);
		}
		RegObject.Close();
	}
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// BannedIPv4AddressCompareFunction - compare against another address
//
// Entry:		Addresses to compare
//
// Exit:		Bool indicating equality of two addresses
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BannedIPv4AddressCompareFunction"

static BOOL BannedIPv4AddressCompareFunction( PVOID pvKey1, PVOID pvKey2 )
{
	DWORD		dwAddr1;
	DWORD		dwAddr2;
	
	dwAddr1 = (DWORD) ((DWORD_PTR) pvKey1);
	dwAddr2 = (DWORD) ((DWORD_PTR) pvKey2);

	if (dwAddr1 == dwAddr2)
	{
		return TRUE;
	}

	return FALSE;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// BannedIPv4AddressHashFunction - hash address to N bits
//
// Entry:		Count of bits to hash to
//
// Exit:		Hashed value
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "BannedIPv4AddressHashFunction"

static DWORD BannedIPv4AddressHashFunction( PVOID pvKey, BYTE bBitDepth )
{
	DWORD		dwReturn;
	UINT_PTR	Temp;

	DNASSERT( bBitDepth != 0 );

	//
	// initialize
	//
	dwReturn = 0;

	//
	// hash IP address
	//
	Temp = (DWORD) ((DWORD_PTR) pvKey);

	do
	{
		dwReturn ^= Temp & ( ( 1 << bBitDepth ) - 1 );
		Temp >>= bBitDepth;
	} while ( Temp != 0 );

	return dwReturn;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ReadBannedIPv4Addresses - reads in additional banned IPv4 addresses from the registry
//
// Entry:		Pointer to registry object with values to read
//
// Exit:		None
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "ReadBannedIPv4Addresses"

static void ReadBannedIPv4Addresses( CRegistry * pRegObject )
{
	WCHAR			wszIPAddress[16]; // nnn.nnn.nnn.nnn + NULL termination
	char			szIPAddress[16]; // nnn.nnn.nnn.nnn + NULL termination
	DWORD			dwSize;
	DWORD			dwIndex;
	DWORD			dwMask;
	DWORD			dwBit;
	PVOID			pvMask;
	CSocketAddress	SocketAddressTemp;
	SOCKADDR_IN *	psaddrinTemp;

	
	memset(&SocketAddressTemp, 0, sizeof(SocketAddressTemp));
	psaddrinTemp = (SOCKADDR_IN*) SocketAddressTemp.GetWritableAddress();
	psaddrinTemp->sin_family = AF_INET;
	psaddrinTemp->sin_port = 0xAAAA; // doesn't matter, just anything valid for IsValidUnicastAddress()

	//
	// Create the banned IPv4 addresses hash table, if we don't have it already.
	//
	if (g_pHashBannedIPv4Addresses == NULL)
	{
		g_pHashBannedIPv4Addresses = (CHashTable*) DNMalloc(sizeof(CHashTable));
		if (g_pHashBannedIPv4Addresses == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate banned IPv4 addresses hash table!");
			goto Failure;
		}
		
		//
		// Initialize the banned address hash with 2 entries and grow by a factor of 2.
		//
		if (! g_pHashBannedIPv4Addresses->Initialize(1,
#ifndef DPNBUILD_PREALLOCATEDMEMORYMODEL
													1,
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
													BannedIPv4AddressCompareFunction,
													BannedIPv4AddressHashFunction))
		{
			DPFX(DPFPREP, 0, "Couldn't initialize banned IPv4 addresses hash table!");
			goto Failure;
		}
	}
	
	dwIndex = 0;
	do
	{
		dwSize = 16;
		if (! pRegObject->EnumValues( wszIPAddress, &dwSize, dwIndex ))
		{
			break;
		}

		//
		// Read the mask associated with the IP address.
		//
		if ( pRegObject->ReadDWORD(wszIPAddress, &dwMask))
		{
			//
			// Convert the IP address string to binary.
			//
			if (STR_jkWideToAnsi(szIPAddress, wszIPAddress, 16) == DPN_OK)
			{
				//
				// Convert the IP address string to binary.
				//
				psaddrinTemp->sin_addr.S_un.S_addr = inet_addr(szIPAddress);
				if (SocketAddressTemp.IsValidUnicastAddress(FALSE))
				{
					//
					// Find the first mask bit.  We expect the network byte order of
					// the IP address to be opposite of host byte order.
					//
					dwBit = 0x80000000;
					while (! (dwBit & dwMask))
					{
						psaddrinTemp->sin_addr.S_un.S_addr &= ~dwBit;
						dwBit >>= 1;
						if (dwBit <= 0x80)
						{
							break;
						}
					}

					if (dwBit & dwMask)
					{
						//
						// If the masked address is already in the hash, update the mask.
						// This allows bans to be listed more than once.
						//
						if (g_pHashBannedIPv4Addresses->Find((PVOID) ((DWORD_PTR) psaddrinTemp->sin_addr.S_un.S_addr), &pvMask))
						{
							if (! g_pHashBannedIPv4Addresses->Remove((PVOID) ((DWORD_PTR) psaddrinTemp->sin_addr.S_un.S_addr)))
							{
								DPFX(DPFPREP, 0, "Couldn't remove masked IPv4 entry %u.%u.%u.%u from ban hash.",
									psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
									psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
									psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
									psaddrinTemp->sin_addr.S_un.S_un_b.s_b4);
								dwMask = dwBit;
							}
							else
							{
								dwMask = ((DWORD) ((DWORD_PTR) pvMask)) | dwBit;
							}
						}
						else
						{
							dwMask = dwBit;
						}

						//
						// Add (or readd) the masked address to the hash.
						//
						if (g_pHashBannedIPv4Addresses->Insert((PVOID) ((DWORD_PTR) psaddrinTemp->sin_addr.S_un.S_addr), (PVOID) ((DWORD_PTR) dwMask)))
						{
							g_dwBannedIPv4Masks |= dwBit;
							DPFX(DPFPREP, 5, "Added (or readded) %ls (bits = 0x%08x, masked IPv4 entry %u.%u.%u.%u) to ban hash.",
								wszIPAddress,
								dwMask,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b4);
						}
						else
						{
							DPFX(DPFPREP, 0, "Couldn't add %ls (bits = 0x%08x, masked IPv4 entry %u.%u.%u.%u) to ban hash!",
								wszIPAddress,
								dwMask,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b1,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b2,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b3,
								psaddrinTemp->sin_addr.S_un.S_un_b.s_b4);
						}
					}
					else
					{
						DPFX(DPFPREP, 0, "Ignoring invalid banned IPv4 entry \"%ls\" (mask = 0x%08x)!",
							wszIPAddress, dwMask);
					}
				}
				else
				{
					DPFX(DPFPREP, 0, "Ignoring invalid banned IPv4 entry \"%ls\" (mask = 0x%08x)!",
						wszIPAddress, dwMask);
				}
			}
			else
			{
				DPFX(DPFPREP, 0, "Couldn't convert banned IPv4 entry \"%ls\" (mask = 0x%08x) to ANSI!",
					wszIPAddress, dwMask);
			}
		}
		else
		{
			DPFX(DPFPREP, 0, "Couldn't read banned IPv4 entry \"%ls\"!", wszIPAddress);
		}

		dwIndex++;
	}
	while (TRUE);

	DPFX(DPFPREP, 2, "There are now a total of %u IPv4 addresses to ban, mask bits = 0x%08x.",
		g_pHashBannedIPv4Addresses->GetEntryCount(),
		g_dwBannedIPv4Masks);

Exit:

	return;

Failure:

	goto Exit;
}
//**********************************************************************

#endif // ! DPNBUILD_NOREGISTRY




//**********************************************************************
// ------------------------------
// InitProcessGlobals - initialize the global items needed for the SP to operate
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failure
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitProcessGlobals"

BOOL	InitProcessGlobals( void )
{
	BOOL		fReturn;
	BOOL		fCriticalSectionInitialized;
#ifdef _XBOX
	BOOL		fRefcountXnKeysInitted;
#endif // _XBOX


	//
	// initialize
	//
	fReturn = TRUE;
	fCriticalSectionInitialized = FALSE;
#ifdef _XBOX
	fRefcountXnKeysInitted = FALSE;
#endif // _XBOX


#ifdef DBG
	g_blDPNWSockCritSecsHeld.Initialize();
#endif // DBG


#ifndef DPNBUILD_NOREGISTRY
	ReadSettingsFromRegistry();
#endif // ! DPNBUILD_NOREGISTRY

	if ( DNInitializeCriticalSection( &g_InterfaceGlobalsLock ) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	DebugSetCriticalSectionGroup( &g_InterfaceGlobalsLock, &g_blDPNWSockCritSecsHeld );	 // separate dpnwsock CSes from the rest of DPlay's CSes

	fCriticalSectionInitialized = TRUE;
	

	if ( InitializePools() == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}

#ifdef _XBOX
#pragma BUGBUG(vanceo, "Find way to retrieve value from XNet")
	if ( InitializeRefcountXnKeys(4) == FALSE )
	{
		fReturn = FALSE;
		goto Failure;
	}
	fRefcountXnKeysInitted = TRUE;
#endif // _XBOX

	DNASSERT( g_pThreadPool == NULL );


Exit:
	return	fReturn;

Failure:
#ifdef _XBOX
	if ( fRefcountXnKeysInitted )
	{
		CleanupRefcountXnKeys();
		fRefcountXnKeysInitted = FALSE;
	}
#endif // _XBOX

	DeinitializePools();

	if ( fCriticalSectionInitialized != FALSE )
	{
		DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
		fCriticalSectionInitialized = FALSE;
	}

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitProcessGlobals - deinitialize the global items
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitProcessGlobals"

void	DeinitProcessGlobals( void )
{
	DNASSERT( g_pThreadPool == NULL );
	DNASSERT( g_iThreadPoolRefCount == 0 );

#ifndef DPNBUILD_NOREGISTRY
	if (g_pHashBannedIPv4Addresses != NULL)
	{
		g_pHashBannedIPv4Addresses->RemoveAll();
		g_pHashBannedIPv4Addresses->Deinitialize();
		DNFree(g_pHashBannedIPv4Addresses);
		g_pHashBannedIPv4Addresses = NULL;
		g_dwBannedIPv4Masks = 0;
	}
#endif // ! DPNBUILD_NOREGISTRY

#ifdef _XBOX
	CleanupRefcountXnKeys();
#endif // _XBOX

	DeinitializePools();
	DNDeleteCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// LoadWinsock - load Winsock module into memory
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "LoadWinsock"

BOOL	LoadWinsock( void )
{
	BOOL	fReturn = TRUE;
	int		iResult;

	
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_iWinsockRefCount == 0 )
	{
		//
		// initialize the bindings to Winsock
		//
		iResult = DWSInitWinSock();
		if ( iResult != 0 )	// failure
		{
			DPFX(DPFPREP, 0, "Problem binding dynamic winsock function (err = %i)!", iResult );
			fReturn = FALSE;
			goto Failure;
		}

		DPFX(DPFPREP, 6, "Successfully bound dynamic WinSock functions." );
	}

	DNASSERT(g_iWinsockRefCount >= 0);
	DNInterlockedIncrement( const_cast<LONG*>(&g_iWinsockRefCount) );

Exit:
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
	return	fReturn;

Failure:
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// UnloadWinsock - unload Winsock module
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "UnloadWinsock"

void	UnloadWinsock( void )
{
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT(g_iWinsockRefCount > 0);
	if ( DNInterlockedDecrement( const_cast<LONG*>(&g_iWinsockRefCount) ) == 0 )
	{
		DPFX(DPFPREP, 6, "Unbinding dynamic WinSock functions.");
		DWSFreeWinSock();
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************



#ifndef DPNBUILD_NONATHELP
//**********************************************************************
// ------------------------------
// LoadNATHelp - create and initialize NAT Help object(s)
//
// Entry:		Nothing
//
// Exit:		TRUE if some objects were successfully loaded, FALSE otherwise
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "LoadNATHelp"

BOOL LoadNATHelp(void)
{
	BOOL		fReturn;
	HRESULT		hr;
#ifndef DPNBUILD_ONLYONENATHELP
	CRegistry	RegEntry;
	CRegistry	RegSubentry;
	DWORD		dwMaxKeyLen;
	WCHAR *		pwszKeyName = NULL;
	DWORD		dwEnumIndex;
	DWORD		dwKeyLen;
	GUID		guid;
#endif // ! DPNBUILD_ONLYONENATHELP
	DWORD		dwDirectPlay8Priority;
	DWORD		dwDirectPlay8InitFlags;
	DWORD		dwNumLoaded;

	
	DNEnterCriticalSection(&g_InterfaceGlobalsLock);

	if ( g_iNATHelpRefCount == 0 )
	{
#ifndef DPNBUILD_ONLYONENATHELP
		//
		// Enumerate all the DirectPlayNAT Helpers.
		//
		if (! RegEntry.Open(HKEY_LOCAL_MACHINE, DIRECTPLAYNATHELP_REGKEY, TRUE, FALSE))
		{
			DPFX(DPFPREP,  0, "Couldn't open DirectPlayNATHelp registry key!");
			goto Failure;
		}


		//
		// Find length of largest subkey.
		//
		if (!RegEntry.GetMaxKeyLen(&dwMaxKeyLen))
		{
			DPFERR("RegistryEntry.GetMaxKeyLen() failed!");
			goto Failure;
		}
		
		dwMaxKeyLen++;	// Null terminator
		DPFX(DPFPREP, 9, "dwMaxKeyLen = %ld", dwMaxKeyLen);

		pwszKeyName = (WCHAR*) DNMalloc(dwMaxKeyLen * sizeof(WCHAR));
		if (pwszKeyName == NULL)
		{
			DPFERR("Allocating key name buffer failed!");
			goto Failure;
		}
#endif // ! DPNBUILD_ONLYONENATHELP


		//
		// Allocate an array to hold the helper objects.
		//
		g_papNATHelpObjects = (IDirectPlayNATHelp**) DNMalloc(MAX_NUM_DIRECTPLAYNATHELPERS * sizeof(IDirectPlayNATHelp*));
		if (g_papNATHelpObjects == NULL)
		{
			DPFERR("DNMalloc() failed");
			goto Failure;
		}
		ZeroMemory(g_papNATHelpObjects,
					(MAX_NUM_DIRECTPLAYNATHELPERS * sizeof(IDirectPlayNATHelp*)));


#ifndef DPNBUILD_ONLYONENATHELP
		dwEnumIndex = 0;
#endif // ! DPNBUILD_ONLYONENATHELP
		dwNumLoaded = 0;

		//
		// Enumerate the DirectPlay NAT helpers.
		//
		do
		{
#ifdef DPNBUILD_ONLYONENATHELP
			WCHAR *		pwszKeyName;


			pwszKeyName = L"UPnP";
			dwDirectPlay8Priority = 1;
			dwDirectPlay8InitFlags = 0; // default UPnP flags
#else // ! DPNBUILD_ONLYONENATHELP
			dwKeyLen = dwMaxKeyLen;
			if (! RegEntry.EnumKeys(pwszKeyName, &dwKeyLen, dwEnumIndex))
			{
				break;
			}
			dwEnumIndex++;
			
	
			DPFX(DPFPREP, 8, "%ld - %ls (%ld)", dwEnumIndex, pwszKeyName, dwKeyLen);
			
			if (!RegSubentry.Open(RegEntry, pwszKeyName, TRUE, FALSE))
			{
				DPFX(DPFPREP, 0, "Couldn't open subentry \"%ls\"! Skipping.", pwszKeyName);
				continue;
			}


			//
			// Read the DirectPlay8 priority
			//
			if (!RegSubentry.ReadDWORD(REGSUBKEY_DPNATHELP_DIRECTPLAY8PRIORITY, &dwDirectPlay8Priority))
			{
				DPFX(DPFPREP, 0, "RegSubentry.ReadDWORD \"%ls\\%ls\" failed!  Skipping.",
					pwszKeyName, REGSUBKEY_DPNATHELP_DIRECTPLAY8PRIORITY);
				RegSubentry.Close();
				continue;
			}


			//
			// Read the DirectPlay8 initialization flags
			//
			if (!RegSubentry.ReadDWORD(REGSUBKEY_DPNATHELP_DIRECTPLAY8INITFLAGS, &dwDirectPlay8InitFlags))
			{
				DPFX(DPFPREP, 0, "RegSubentry.ReadDWORD \"%ls\\%ls\" failed!  Defaulting to 0.",
					pwszKeyName, REGSUBKEY_DPNATHELP_DIRECTPLAY8INITFLAGS);
				dwDirectPlay8InitFlags = 0;
			}

			
			//
			// Read the object's CLSID.
			//
			if (!RegSubentry.ReadGUID(REGSUBKEY_DPNATHELP_GUID, &guid))
			{
				DPFX(DPFPREP, 0,"RegSubentry.ReadGUID \"%ls\\%ls\" failed!  Skipping.",
					pwszKeyName, REGSUBKEY_DPNATHELP_GUID);
				RegSubentry.Close();
				continue;
			}


			//
			// Close the subkey.
			//
			RegSubentry.Close();


			//
			// If this helper should be loaded, do so.
			//
			if (dwDirectPlay8Priority == 0)
			{
				DPFX(DPFPREP, 1, "DirectPlay NAT Helper \"%ls\" is not enabled for DirectPlay8.", pwszKeyName);
			}
			else
#endif // ! DPNBUILD_ONLYONENATHELP
			{
#ifdef DPNBUILD_ONLYONENATHELP
				//
				// Try to create the NAT Help object.  COM should have been
 				// initialized by now by someone else.
				//
				hr = COM_CoCreateInstance(CLSID_DirectPlayNATHelpUPnP,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IDirectPlayNATHelp,
										(LPVOID*) (&g_papNATHelpObjects[dwDirectPlay8Priority - 1]), FALSE);
#else // ! DPNBUILD_ONLYONENATHELP
				//
				// Make sure this priority is valid.
				//
				if (dwDirectPlay8Priority > MAX_NUM_DIRECTPLAYNATHELPERS)
				{
					DPFX(DPFPREP, 0, "Ignoring DirectPlay NAT helper \"%ls\" with invalid priority level set too high (%u > %u).",
						pwszKeyName, dwDirectPlay8Priority, MAX_NUM_DIRECTPLAYNATHELPERS);
					continue;
				}


				//
				// Make sure this priority hasn't already been taken.
				//
				if (g_papNATHelpObjects[dwDirectPlay8Priority - 1] != NULL)
				{
					DPFX(DPFPREP, 0, "Ignoring DirectPlay NAT helper \"%ls\" with duplicate priority level %u (existing object = 0x%p).",
						pwszKeyName, dwDirectPlay8Priority,
						g_papNATHelpObjects[dwDirectPlay8Priority - 1]);
					continue;
				}
				

				//
				// Try to create the NAT Help object.  COM should have been
 				// initialized by now by someone else.
				//
				hr = COM_CoCreateInstance(guid,
										NULL,
										CLSCTX_INPROC_SERVER,
										IID_IDirectPlayNATHelp,
										(LPVOID*) (&g_papNATHelpObjects[dwDirectPlay8Priority - 1]), FALSE);
#endif // ! DPNBUILD_ONLYONENATHELP
				if ( hr != S_OK )
				{
					DNASSERT( g_papNATHelpObjects[dwDirectPlay8Priority - 1] == NULL );
					DPFX(DPFPREP,  0, "Failed to create \"%ls\" IDirectPlayNATHelp interface (error = 0x%lx)!  Skipping.",
						pwszKeyName, hr);
					continue;
				}

				
				//
				// Initialize NAT Help.
				//

#ifndef DPNBUILD_NOREGISTRY
				DNASSERT((! g_fDisableDPNHGatewaySupport) || (! g_fDisableDPNHFirewallSupport));

				if (g_fDisableDPNHGatewaySupport)
				{
					dwDirectPlay8InitFlags |= DPNHINITIALIZE_DISABLEGATEWAYSUPPORT;
				}

				if (g_fDisableDPNHFirewallSupport)
				{
					dwDirectPlay8InitFlags |= DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT;
				}
#endif // ! DPNBUILD_NOREGISTRY


				//
				// Make sure the flags we're passing are valid.
				//
				if ((dwDirectPlay8InitFlags & (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)) == (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
				{
					DPFX(DPFPREP, 1, "Not loading NAT Help \"%ls\" because both DISABLEGATEWAYSUPPORT and DISABLELOCALFIREWALLSUPPORT would have been specified (priority = %u, flags = 0x%lx).", 
						pwszKeyName, dwDirectPlay8Priority, dwDirectPlay8InitFlags);
						
					IDirectPlayNATHelp_Release(g_papNATHelpObjects[dwDirectPlay8Priority - 1]);
					g_papNATHelpObjects[dwDirectPlay8Priority - 1] = NULL;
					
					continue;
				}

				
				hr = IDirectPlayNATHelp_Initialize(g_papNATHelpObjects[dwDirectPlay8Priority - 1], dwDirectPlay8InitFlags);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't initialize NAT Help \"%ls\" (error = 0x%lx)!  Skipping.",
						pwszKeyName, hr);
					
					IDirectPlayNATHelp_Release(g_papNATHelpObjects[dwDirectPlay8Priority - 1]);
					g_papNATHelpObjects[dwDirectPlay8Priority - 1] = NULL;
					
					continue;
				}
			
			
				DPFX(DPFPREP, 8, "Initialized NAT Help \"%ls\" (priority = %u, flags = 0x%lx, object = 0x%p).", 
					pwszKeyName, dwDirectPlay8Priority, dwDirectPlay8InitFlags, g_papNATHelpObjects[dwDirectPlay8Priority - 1]);

				dwNumLoaded++;
			}
		}
#ifdef DPNBUILD_ONLYONENATHELP
		while (FALSE);
#else // ! DPNBUILD_ONLYONENATHELP
		while (TRUE);
#endif // ! DPNBUILD_ONLYONENATHELP
			
		
		//
		// If we didn't load any NAT helper objects, free up the memory.
		//
		if (dwNumLoaded == 0)
		{
			DNFree(g_papNATHelpObjects);
			g_papNATHelpObjects = NULL;
	
			//
			// We never got anything.  Fail.
			//
			goto Failure;
		}

		
		DPFX(DPFPREP, 8, "Loaded %u DirectPlay NAT Helper objects.", dwNumLoaded);
	}
	else
	{
		DPFX(DPFPREP, 8, "Already loaded NAT Help objects.");	
	}

	//
	// We have the interface globals lock, don't need DNInterlockedIncrement.
	//
	g_iNATHelpRefCount++;

	//
	// We succeeded.
	//
	fReturn = TRUE;

Exit:
	
	DNLeaveCriticalSection(&g_InterfaceGlobalsLock);

#ifndef DPNBUILD_ONLYONENATHELP
	if (pwszKeyName != NULL)
	{
		DNFree(pwszKeyName);
		pwszKeyName = NULL;
	}
#endif // ! DPNBUILD_ONLYONENATHELP

	return	fReturn;

Failure:

	//
	// We can only fail during the first initialize, so therefore we will never be freeing
	// g_papNATHelpObjects when we didn't allocate it in this function.
	//
	if (g_papNATHelpObjects != NULL)
	{
		DNFree(g_papNATHelpObjects);
		g_papNATHelpObjects = NULL;
	}

	fReturn = FALSE;
	
	goto Exit;
}
//**********************************************************************



//**********************************************************************
// ------------------------------
// UnloadNATHelp - release the NAT Help object
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "UnloadNATHelp"

void UnloadNATHelp(void)
{
	DWORD	dwTemp;
	

	DNEnterCriticalSection(&g_InterfaceGlobalsLock);

	//
	// We have the interface globals lock, don't need DNInterlockedDecrement.
	//
	DNASSERT(g_iNATHelpRefCount > 0);
	g_iNATHelpRefCount--;
	if (g_iNATHelpRefCount == 0 )
	{
		HRESULT		hr;


		DNASSERT(g_papNATHelpObjects != NULL);
		for(dwTemp = 0; dwTemp < MAX_NUM_DIRECTPLAYNATHELPERS; dwTemp++)
		{
			if (g_papNATHelpObjects[dwTemp] != NULL)
			{
				DPFX(DPFPREP, 8, "Closing NAT Help object priority %u (0x%p).",
					dwTemp, g_papNATHelpObjects[dwTemp]);

				hr = IDirectPlayNATHelp_Close(g_papNATHelpObjects[dwTemp], 0);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP,  0, "Problem closing NAT Help object %u (error = 0x%lx), continuing.",
						dwTemp, hr);
				}

				IDirectPlayNATHelp_Release(g_papNATHelpObjects[dwTemp]);
				g_papNATHelpObjects[dwTemp] = NULL;
			}
		}

		DNFree(g_papNATHelpObjects);
		g_papNATHelpObjects = NULL;
	}
	else
	{
		DPFX(DPFPREP, 8, "NAT Help object(s) still have %i references.",
			g_iNATHelpRefCount);
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************
#endif // DPNBUILD_NONATHELP



#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))

//**********************************************************************
// ------------------------------
// LoadMADCAP - create and initialize MADCAP API
//
// Entry:		Nothing
//
// Exit:		TRUE if the API was successfully loaded, FALSE otherwise
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "LoadMadcap"

BOOL LoadMadcap(void)
{
	BOOL	fReturn;
	DWORD	dwError;
	DWORD	dwMadcapVersion;


#ifndef DPNBUILD_NOREGISTRY
	DNASSERT(! g_fDisableMadcapSupport);
#endif // ! DPNBUILD_NOREGISTRY
	
	DNEnterCriticalSection(&g_InterfaceGlobalsLock);

	if ( g_iMadcapRefCount == 0 )
	{
		//
		// Initialize the MADCAP API.
		//
		dwMadcapVersion = MCAST_API_CURRENT_VERSION;
		dwError = McastApiStartup(&dwMadcapVersion);
		if (dwError != ERROR_SUCCESS)
		{
			DPFX(DPFPREP, 0, "Failed starting MADCAP version %u (err = %u)!",
				MCAST_API_CURRENT_VERSION, dwError);
			goto Failure;
		}

		DPFX(DPFPREP, 5, "Using MADCAP version %u (supported version = %u).",
			MCAST_API_CURRENT_VERSION, dwMadcapVersion);


		//
		// Create a unique client ID.
		//
		g_mcClientUid.ClientUID			= g_abClientID;
		g_mcClientUid.ClientUIDLength	= sizeof(g_abClientID);
		dwError = McastGenUID(&g_mcClientUid);
		if (dwError != ERROR_SUCCESS)
		{
			DPFX(DPFPREP, 0, "Failed creating MADCAP client ID (err = %u)!",
				dwError);
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Already loaded MADCAP.");	
	}

	//
	// We have the interface globals lock, don't need DNInterlockedIncrement.
	//
	g_iMadcapRefCount++;

	//
	// We succeeded.
	//
	fReturn = TRUE;

Exit:
	
	DNLeaveCriticalSection(&g_InterfaceGlobalsLock);

	return	fReturn;

Failure:

	fReturn = FALSE;
	
	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// UnloadMadcap - release the MADCAP interface
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "UnloadMadcap"

void UnloadMadcap(void)
{
	DNEnterCriticalSection(&g_InterfaceGlobalsLock);

	//
	// We have the interface globals lock, don't need DNInterlockedDecrement.
	//
	DNASSERT(g_iMadcapRefCount > 0);
	g_iMadcapRefCount--;
	if (g_iMadcapRefCount == 0 )
	{
		DPFX(DPFPREP, 5, "Unloading MADCAP API.");

		McastApiCleanup();
	}
	else
	{
		DPFX(DPFPREP, 8, "MADCAP API still has %i references.",
			g_iMadcapRefCount);
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );
}
//**********************************************************************
#endif // WINNT and not DPNBUILD_NOMULTICAST



//**********************************************************************
// ------------------------------
// CreateSPData - create instance data for SP
//
// Entry:		Pointer to pointer to SPData
//				Interface type
//				Pointer to COM interface vtable
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "CreateSPData"

HRESULT	CreateSPData( CSPData **const ppSPData,
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
					  const short sSPType,
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
					  const XDP8CREATE_PARAMS * const pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
					  IDP8ServiceProviderVtbl *const pVtbl )
{
	HRESULT		hr;
	CSPData		*pSPData;


	DNASSERT( ppSPData != NULL );
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT( pDP8CreateParams != NULL );
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
	DNASSERT( pVtbl != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	*ppSPData = NULL;
	pSPData = NULL;

	//
	// create data
	//
	pSPData = (CSPData*) DNMalloc(sizeof(CSPData));
	if ( pSPData == NULL )
	{
		hr = DPNERR_OUTOFMEMORY;
		DPFX(DPFPREP,  0, "Cannot create data for Winsock interface!" );
		goto Failure;
	}

	hr = pSPData->Initialize( pVtbl
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
							,sSPType
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
							,pDP8CreateParams
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
							);
	if ( hr != DPN_OK  )
	{
		DPFX(DPFPREP,  0, "Failed to intialize SP data!" );
		DisplayDNError( 0, hr );
		goto Failure;
	}
	
	DPFX(DPFPREP, 6, "Created SP Data object 0x%p.", pSPData);

	pSPData->AddRef();	// reference is now 1
	*ppSPData = pSPData;

Exit:

	return	hr;

Failure:
	
	if ( pSPData != NULL )
	{
		DNFree(pSPData);
		pSPData = NULL;	
	}
	
	DPFX(DPFPREP,  0, "Problem with CreateSPData (err = 0x%lx)!", hr);
	DisplayDNError( 0, hr );

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// InitializeInterfaceGlobals - perform global initialization for an interface.
//
// Entry:		Pointer to SPData
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "InitializeInterfaceGlobals"

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData )
{
	HRESULT	hr;
	CThreadPool	*pThreadPool;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	hr = DPN_OK;
	pThreadPool = NULL;

	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	if ( g_pThreadPool == NULL )
	{
		DNASSERT( g_iThreadPoolRefCount == 0 );
		g_pThreadPool = (CThreadPool*)g_ThreadPoolPool.Get();
		if ( g_pThreadPool != NULL )
		{
			hr = g_pThreadPool->Initialize();
			if ( hr != DPN_OK )
			{
				DPFX(DPFPREP, 0, "Initializing thread pool failed (err = 0x%lx)!", hr);
				g_ThreadPoolPool.Release(g_pThreadPool);
				g_pThreadPool = NULL;
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}
			else
			{
				g_pThreadPool->AddRef();
				g_iThreadPoolRefCount++;
				pThreadPool = g_pThreadPool;
			}
		}
	}
	else
	{
		DNASSERT( g_iThreadPoolRefCount != 0 );
		g_iThreadPoolRefCount++;
		g_pThreadPool->AddRef();
		pThreadPool = g_pThreadPool;
	}

Exit:
	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	pSPData->SetThreadPool( g_pThreadPool );

	return	hr;

Failure:

	goto Exit;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DeinitializeInterfaceGlobals - deinitialize thread pool and Rsip
//
// Entry:		Pointer to service provider
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DeinitializeInterfaceGlobals"

void	DeinitializeInterfaceGlobals( CSPData *const pSPData )
{
	CThreadPool		*pThreadPool;


	DNASSERT( pSPData != NULL );

	//
	// initialize
	//
	pThreadPool = NULL;

	//
	// Process as little as possible inside the lock.  If any of the items
	// need to be released, pointers to them will be set.
	//
	DNEnterCriticalSection( &g_InterfaceGlobalsLock );

	DNASSERT( g_pThreadPool != NULL );
	DNASSERT( g_iThreadPoolRefCount != 0 );
	DNASSERT( g_pThreadPool == pSPData->GetThreadPool() );

	pThreadPool = pSPData->GetThreadPool();

	//
	// remove thread pool reference
	//
	DNASSERT( pThreadPool != NULL );
	g_iThreadPoolRefCount--;
	if ( g_iThreadPoolRefCount == 0 )
	{
		g_pThreadPool = NULL;
	}
	else
	{
		pThreadPool = NULL;
	}

	DNLeaveCriticalSection( &g_InterfaceGlobalsLock );

	//
	// The thread pool will be cleaned up when all of the outstanding interfaces
	// close.
	//
}
//**********************************************************************


#ifndef DPNBUILD_NOIPV6

//**********************************************************************
// ------------------------------
// DNIpv6AddressToStringW - Stolen from RtlIpv6AddressToString
//
//						Generates an IPv6 string literal corresponding to the address Addr.
//						The shortened canonical forms are used (RFC 1884 etc).
//						The basic string representation consists of 8 hex numbers
//						separated by colons, with a couple embellishments:
//						- a string of zero numbers (at most one) is replaced
//						with a double-colon.
//						- the last 32 bits are represented in IPv4-style dotted-octet notation
//						if the address is a v4-compatible or ISATAP address.
//
//						For example,
//							::
//							::1
//							::157.56.138.30
//							::ffff:156.56.136.75
//							ff01::
//							ff02::2
//							0:1:2:3:4:5:6:7
//
// Entry:		S - Receives a pointer to the buffer in which to place the string literal
//			Addr - Receives the IPv6 address
//
// Exit:		Pointer to the null byte at the end of the string inserted.
//			This can be used by the caller to easily append more information
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "DNIpv6AddressToStringW"

LPWSTR DNIpv6AddressToStringW(const struct in6_addr *Addr, LPWSTR S)
{
    int maxFirst, maxLast;
    int curFirst, curLast;
    int i;
    int endHex = 8;

    // Check for IPv6-compatible, IPv4-mapped, and IPv4-translated
    // addresses
    if ((Addr->s6_words[0] == 0) && (Addr->s6_words[1] == 0) &&
        (Addr->s6_words[2] == 0) && (Addr->s6_words[3] == 0) &&
        (Addr->s6_words[6] != 0)) {
        if ((Addr->s6_words[4] == 0) &&
             ((Addr->s6_words[5] == 0) || (Addr->s6_words[5] == 0xffff)))
        {
            // compatible or mapped
            S += _stprintf(S, _T("::%hs%u.%u.%u.%u"),
                           Addr->s6_words[5] == 0 ? "" : "ffff:",
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            return S;
        }
        else if ((Addr->s6_words[4] == 0xffff) && (Addr->s6_words[5] == 0)) {
            // translated
            S += _stprintf(S, _T("::ffff:0:%u.%u.%u.%u"),
                           Addr->s6_bytes[12], Addr->s6_bytes[13],
                           Addr->s6_bytes[14], Addr->s6_bytes[15]);
            return S;
        }
    }


    // Find largest contiguous substring of zeroes
    // A substring is [First, Last), so it's empty if First == Last.

    maxFirst = maxLast = 0;
    curFirst = curLast = 0;

    // ISATAP EUI64 starts with 00005EFE (or 02005EFE)...
    if (((Addr->s6_words[4] & 0xfffd) == 0) && (Addr->s6_words[5] == 0xfe5e)) {
        endHex = 6;
    }

    for (i = 0; i < endHex; i++) {

        if (Addr->s6_words[i] == 0) {
            // Extend current substring
            curLast = i+1;

            // Check if current is now largest
            if (curLast - curFirst > maxLast - maxFirst) {

                maxFirst = curFirst;
                maxLast = curLast;
            }
        }
        else {
            // Start a new substring
            curFirst = curLast = i+1;
        }
    }

    // Ignore a substring of length 1.
    if (maxLast - maxFirst <= 1)
        maxFirst = maxLast = 0;

        // Write colon-separated words.
        // A double-colon takes the place of the longest string of zeroes.
        // All zeroes is just "::".

    for (i = 0; i < endHex; i++) {

        // Skip over string of zeroes
        if ((maxFirst <= i) && (i < maxLast)) {

            S += _stprintf(S, _T("::"));
            i = maxLast-1;
            continue;
        }

        // Need colon separator if not at beginning
        if ((i != 0) && (i != maxLast))
            S += _stprintf(S, _T(":"));

        S += _stprintf(S, _T("%x"), NTOHS(Addr->s6_words[i])); // swap bytes
    }

    if (endHex < 8) {
        S += _stprintf(S, _T(":%u.%u.%u.%u"),
                       Addr->s6_bytes[12], Addr->s6_bytes[13],
                       Addr->s6_bytes[14], Addr->s6_bytes[15]);
    }

    return S;
}

#endif // ! DPNBUILD_NOIPV6



//**********************************************************************
// ------------------------------
// AddInfoToBuffer - add an adapter info/multicast scope info structure to a packed buffer
//
// Entry:		Pointer to packed buffer
//				Pointer to adapter/scope name
//				Pointer to adapter/scope guid
//
// Exit:		Error code
// ------------------------------
#undef DPF_MODNAME
#define	DPF_MODNAME "AddInfoToBuffer"

HRESULT	AddInfoToBuffer( CPackedBuffer *const pPackedBuffer,
					   const WCHAR *const pwszInfoName,
					   const GUID *const pInfoGUID,
					   const DWORD dwFlags )
{
	HRESULT						hr;
	DPN_SERVICE_PROVIDER_INFO	AdapterInfo;


#ifndef DPNBUILD_NOMULTICAST
	DBG_CASSERT( sizeof( DPN_SERVICE_PROVIDER_INFO ) == sizeof( DPN_MULTICAST_SCOPE_INFO ) );
	DBG_CASSERT( OFFSETOF( DPN_SERVICE_PROVIDER_INFO, dwFlags ) == OFFSETOF( DPN_MULTICAST_SCOPE_INFO, dwFlags ) );
	DBG_CASSERT( OFFSETOF( DPN_SERVICE_PROVIDER_INFO, guid ) == OFFSETOF( DPN_MULTICAST_SCOPE_INFO, guid ) );
	DBG_CASSERT( OFFSETOF( DPN_SERVICE_PROVIDER_INFO, pwszName ) == OFFSETOF( DPN_MULTICAST_SCOPE_INFO, pwszName ) );
	DBG_CASSERT( OFFSETOF( DPN_SERVICE_PROVIDER_INFO, pvReserved ) == OFFSETOF( DPN_MULTICAST_SCOPE_INFO, pvReserved ) );
	DBG_CASSERT( OFFSETOF( DPN_SERVICE_PROVIDER_INFO, dwReserved ) == OFFSETOF( DPN_MULTICAST_SCOPE_INFO, dwReserved ) );
#endif // ! DPNBUILD_NOMULTICAST

	DNASSERT( pPackedBuffer != NULL );
	DNASSERT( pwszInfoName != NULL );
	DNASSERT( pInfoGUID != NULL );

	//
	// initialize
	//
	hr = DPN_OK;

	memset( &AdapterInfo, 0x00, sizeof( AdapterInfo ) );
	AdapterInfo.dwFlags = dwFlags;
	AdapterInfo.guid = *pInfoGUID;

	hr = pPackedBuffer->AddWCHARStringToBack( pwszInfoName );
	if ( ( hr != DPNERR_BUFFERTOOSMALL ) && ( hr != DPN_OK ) )
	{
		DPFX(DPFPREP,  0, "Failed to add info name to buffer!" );
		goto Failure;
	}
	AdapterInfo.pwszName = static_cast<WCHAR*>( pPackedBuffer->GetTailAddress() );

	hr = pPackedBuffer->AddToFront( &AdapterInfo, sizeof( AdapterInfo ) );

Exit:
	return	hr;

Failure:
	goto Exit;
}
//**********************************************************************



#ifdef _XBOX


typedef struct _REFCOUNTXNKEY
{
	LONG	lRefCount;
	XNKID	xnkid;
	XNKEY	xnkey;
} REFCOUNTXNKEY;

REFCOUNTXNKEY *		g_paRefcountXnKeys = NULL;
DWORD				g_dwMaxNumRefcountXnKeys = 0;



#undef DPF_MODNAME
#define	DPF_MODNAME "InitializeRefcountXnKeys"
BOOL InitializeRefcountXnKeys(const DWORD dwKeyRegMax)
{
	BOOL	fResult;


	DPFX(DPFPREP, 3, "Parameters: (%u)", dwKeyRegMax);
	DNASSERT(dwKeyRegMax != 0);

	DNASSERT(g_paRefcountXnKeys == NULL);

	g_paRefcountXnKeys = (REFCOUNTXNKEY*) DNMalloc(dwKeyRegMax * sizeof(REFCOUNTXNKEY));
	if (g_paRefcountXnKeys == NULL)
	{
		g_dwMaxNumRefcountXnKeys = 0;
		fResult = FALSE;
	}
	else
	{
		memset(g_paRefcountXnKeys, 0, (dwKeyRegMax * sizeof(REFCOUNTXNKEY)));
		g_dwMaxNumRefcountXnKeys = dwKeyRegMax;
		fResult = TRUE;
	}

	DPFX(DPFPREP, 3, "Returning: [%i]", fResult);

	return fResult;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "CleanupRefcountXnKeys"
void WINAPI CleanupRefcountXnKeys(void)
{
#ifdef DBG
	DWORD	dwTemp;

	
	DPFX(DPFPREP, 3, "Enter");

	DNASSERT(g_paRefcountXnKeys != NULL);

	for(dwTemp = 0; dwTemp < g_dwMaxNumRefcountXnKeys; dwTemp++)
	{
		DNASSERT(g_paRefcountXnKeys[dwTemp].lRefCount == 0);
	}
#endif // DBG
	
	DNFree(g_paRefcountXnKeys);
	g_paRefcountXnKeys = NULL;
	g_dwMaxNumRefcountXnKeys = 0;

	DPFX(DPFPREP, 3, "Leave");
}


#undef DPF_MODNAME
#define	DPF_MODNAME "RegisterRefcountXnKey"
INT WINAPI RegisterRefcountXnKey(const XNKID * pxnkid, const XNKEY * pxnkey)
{
	int		iReturn;
	DWORD	dwTemp;
	DWORD	dwIndex = -1;


	DPFX(DPFPREP, 3, "Parameters: (0x%p, 0x%p)", pxnkid, pxnkey);

	DNASSERT(pxnkid != NULL);
	DNASSERT(pxnkey != NULL);
	
	DNASSERT(g_paRefcountXnKeys != NULL);

	for(dwTemp = 0; dwTemp < g_dwMaxNumRefcountXnKeys; dwTemp++)
	{
		if (g_paRefcountXnKeys[dwTemp].lRefCount > 0)
		{
			if (memcmp(pxnkid, &g_paRefcountXnKeys[dwTemp].xnkid, sizeof(XNKID)) == 0)
			{
				DPFX(DPFPREP, 1, "Key has already been registered.");
				g_paRefcountXnKeys[dwTemp].lRefCount++;
				iReturn = 0;
				goto Exit;
			}
		}
		else
		{
			DNASSERT(g_paRefcountXnKeys[dwTemp].lRefCount == 0);
			if (dwIndex == -1)
			{
				dwIndex = dwTemp;
			}
		}
	}

	if (dwIndex == -1)
	{
		DPFX(DPFPREP, 0, "No more keys can be registered!");
		DNASSERTX(! "No more keys can be registered!", 2);
		iReturn = WSAENOBUFS;
		goto Exit;
	}

	iReturn = XNetRegisterKey(pxnkid, pxnkey);
	if (iReturn != 0)
	{
		DPFX(DPFPREP, 0, "Registering key failed!");
		goto Exit;
	}
	
	DNASSERT(g_paRefcountXnKeys[dwIndex].lRefCount == 0);
	g_paRefcountXnKeys[dwIndex].lRefCount = 1;
	memcpy(&g_paRefcountXnKeys[dwIndex].xnkid, pxnkid, sizeof(XNKID));
	memcpy(&g_paRefcountXnKeys[dwIndex].xnkey, pxnkey, sizeof(XNKEY));

Exit:

	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "UnregisterRefcountXnKey"
INT WINAPI UnregisterRefcountXnKey(const XNKID * pxnkid)
{
	int		iReturn;
	DWORD	dwTemp;


	DPFX(DPFPREP, 3, "Parameters: (0x%p)", pxnkid);

	DNASSERT(pxnkid != NULL);
	
	DNASSERT(g_paRefcountXnKeys != NULL);

	for(dwTemp = 0; dwTemp < g_dwMaxNumRefcountXnKeys; dwTemp++)
	{
		if (g_paRefcountXnKeys[dwTemp].lRefCount > 0)
		{
			if (memcmp(pxnkid, &g_paRefcountXnKeys[dwTemp].xnkid, sizeof(XNKID)) == 0)
			{
				g_paRefcountXnKeys[dwTemp].lRefCount--;
				if (g_paRefcountXnKeys[dwTemp].lRefCount == 0)
				{
					iReturn =  XNetUnregisterKey(pxnkid);
					if (iReturn != 0)
					{
						DPFX(DPFPREP, 0, "Unregistering key failed!");
					}
				}
				else
				{
					iReturn = 0;
				}
				goto Exit;
			}
		}
		else
		{
			DNASSERT(g_paRefcountXnKeys[dwTemp].lRefCount == 0);
		}
	}

	DPFX(DPFPREP, 0, "Key has not been registered!");
	DNASSERTX(! "Key has not been registered!", 2);
	iReturn = -1;

Exit:

	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}




#ifdef XBOX_ON_DESKTOP

typedef struct _SECURITYASSOCIATION
{
	BOOL					fInUse;
	XNADDR					xnaddr;
	IN_ADDR					inaddr;
} SECURITYASSOCIATION;

typedef struct _KEYENTRY
{
	BOOL					fInUse;
	XNKID					xnkid;
	XNKEY					xnkey;
	SECURITYASSOCIATION *	paSecurityAssociations;
} KEYENTRY;

KEYENTRY *	g_paKeys = NULL;
DWORD		g_dwMaxNumKeys = 0;
DWORD		g_dwMaxNumAssociations = 0;




#undef DPF_MODNAME
#define	DPF_MODNAME "XNetStartup"
INT WINAPI XNetStartup(const XNetStartupParams * pxnsp)
{
	int					iReturn;
	XNetStartupParams	StartupParamsCapped;
	DWORD				dwTemp;


#ifdef DBG
	//DPFX(DPFPREP, 3, "Parameters: (0x%p)", pxnsp);

	// Not using DNASSERT because DPlay may not be initted yet.
	if (! (g_paKeys == NULL))
	{
		OutputDebugString("Assert failed (g_paKeys == NULL)\n");
		DebugBreak();
	}
#endif // DBG

	if (pxnsp == NULL)
	{
		memset(&StartupParamsCapped, 0, sizeof(StartupParamsCapped));
	}
	else
	{
		memcpy(&StartupParamsCapped, pxnsp, sizeof(StartupParamsCapped));
	}

	if (StartupParamsCapped.cfgKeyRegMax == 0)
	{
		StartupParamsCapped.cfgKeyRegMax = 4;
	}

	if (StartupParamsCapped.cfgSecRegMax == 0)
	{
		StartupParamsCapped.cfgSecRegMax = 32;
	}
		

	// Not using DNMalloc because DPlay may not be initted yet.
	g_paKeys = (KEYENTRY*) HeapAlloc(GetProcessHeap(), 0, StartupParamsCapped.cfgKeyRegMax * sizeof(KEYENTRY));
	if (g_paKeys == NULL)
	{
		iReturn = -1;
		goto Failure;
	}

	memset(g_paKeys, 0, (StartupParamsCapped.cfgKeyRegMax * sizeof(KEYENTRY)));

	for(dwTemp = 0; dwTemp < StartupParamsCapped.cfgKeyRegMax; dwTemp++)
	{
		// Not using DNMalloc because DPlay may not be initted yet.
		g_paKeys[dwTemp].paSecurityAssociations = (SECURITYASSOCIATION*) HeapAlloc(GetProcessHeap(), 0, StartupParamsCapped.cfgSecRegMax * sizeof(SECURITYASSOCIATION));
		if (g_paKeys == NULL)
		{
			iReturn = -1;
			goto Failure;
		}

		memset(g_paKeys[dwTemp].paSecurityAssociations, 0, (StartupParamsCapped.cfgSecRegMax * sizeof(SECURITYASSOCIATION)));
	}

	g_dwMaxNumKeys = StartupParamsCapped.cfgKeyRegMax;
	g_dwMaxNumAssociations = StartupParamsCapped.cfgSecRegMax;

	
	iReturn = 0;


Exit:

	//DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;


Failure:

	if (g_paKeys != NULL)
	{
		for(dwTemp = 0; dwTemp < StartupParamsCapped.cfgKeyRegMax; dwTemp++)
		{
			if (g_paKeys[dwTemp].paSecurityAssociations != NULL)
			{
				HeapFree(GetProcessHeap(), 0, g_paKeys[dwTemp].paSecurityAssociations);
				g_paKeys[dwTemp].paSecurityAssociations = NULL;
			}
		}
		
		HeapFree(GetProcessHeap(), 0, g_paKeys);
		g_paKeys = NULL;
	}

	g_dwMaxNumKeys = 0;
	g_dwMaxNumAssociations = 0;

	goto Exit;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetCleanup"
INT WINAPI XNetCleanup(void)
{
	int		iReturn;
	DWORD	dwTemp;


#ifdef DBG
	//DPFX(DPFPREP, 3, "Enter");

	// Not using DNASSERT because DPlay may not be initted anymore.
	if (! (g_paKeys != NULL))
	{
		OutputDebugString("Assert failed (g_paKeys != NULL)\n");
		DebugBreak();
	}
#endif // DBG
	
	for(dwTemp = 0; dwTemp < g_dwMaxNumKeys; dwTemp++)
	{
		if (g_paKeys[dwTemp].paSecurityAssociations != NULL)
		{
			HeapFree(GetProcessHeap(), 0, g_paKeys[dwTemp].paSecurityAssociations);
			g_paKeys[dwTemp].paSecurityAssociations = NULL;
		}
	}
	
	HeapFree(GetProcessHeap(), 0, g_paKeys);
	g_paKeys = NULL;
	
	g_dwMaxNumKeys = 0;
	g_dwMaxNumAssociations = 0;


	iReturn = 0;

	//DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetRegisterKey"
INT WINAPI XNetRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey)
{
	int		iReturn;
	DWORD	dwTemp;
	DWORD	dwIndex = -1;


	DPFX(DPFPREP, 3, "Parameters: (0x%p, 0x%p)", pxnkid, pxnkey);

	DNASSERT(pxnkid != NULL);
	DNASSERT(pxnkey != NULL);

	for(dwTemp = 0; dwTemp < g_dwMaxNumKeys; dwTemp++)
	{
		if (g_paKeys[dwTemp].fInUse)
		{
			if (memcmp(pxnkid, &g_paKeys[dwTemp].xnkid, sizeof(XNKID)) == 0)
			{
				DPFX(DPFPREP, 2, "Key has already been registered.");
				iReturn = WSAEALREADY;
				goto Exit;
			}
		}
		else
		{
			if (dwIndex == -1)
			{
				dwIndex = dwTemp;
			}
		}
	}

	if (dwIndex == -1)
	{
		DPFX(DPFPREP, 0, "No more keys can be registered!");
		iReturn = WSAENOBUFS;
		goto Exit;
	}

	g_paKeys[dwIndex].fInUse = TRUE;
	memcpy(&g_paKeys[dwIndex].xnkid, pxnkid, sizeof(XNKID));
	memcpy(&g_paKeys[dwIndex].xnkey, pxnkey, sizeof(XNKEY));
	iReturn = 0;

Exit:

	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetUnregisterKey"
INT WINAPI XNetUnregisterKey(const XNKID * pxnkid)
{
	int		iReturn;
	DWORD	dwTemp;


	DPFX(DPFPREP, 3, "Parameters: (0x%p)", pxnkid);

	DNASSERT(pxnkid != NULL);

	for(dwTemp = 0; dwTemp < g_dwMaxNumKeys; dwTemp++)
	{
		if (g_paKeys[dwTemp].fInUse)
		{
			if (memcmp(pxnkid, &g_paKeys[dwTemp].xnkid, sizeof(XNKID)) == 0)
			{
				g_paKeys[dwTemp].fInUse = FALSE;
				iReturn =  0;
				goto Exit;
			}
		}
	}

	DPFX(DPFPREP, 0, "Key has not been registered!");
	DNASSERTX(! "Key has not been registered!", 2);
	iReturn = -1;

Exit:

	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetXnAddrToInAddr"
INT WINAPI XNetXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina)
{
	int		iReturn;
	DWORD	dwKey;
	DWORD	dwAssociation;
	DWORD	dwIndex;


	DPFX(DPFPREP, 3, "Parameters: (0x%p, 0x%p, 0x%p)", pxna, pxnkid, pina);

	DNASSERT(pxna != NULL);
	DNASSERT(pxnkid != NULL);
	DNASSERT(pina != NULL);

	for(dwKey = 0; dwKey < g_dwMaxNumKeys; dwKey++)
	{
		if ((g_paKeys[dwKey].fInUse) &&
			(memcmp(pxnkid, &g_paKeys[dwKey].xnkid, sizeof(XNKID)) == 0))
		{
			dwIndex = -1;
			
			for(dwAssociation = 0; dwAssociation < g_dwMaxNumAssociations; dwAssociation++)
			{
				if (g_paKeys[dwKey].paSecurityAssociations[dwAssociation].fInUse)
				{
					if (memcmp(pxna, &g_paKeys[dwKey].paSecurityAssociations[dwAssociation].xnaddr, sizeof(XNADDR)) == 0)
					{
						memcpy(pina, &g_paKeys[dwKey].paSecurityAssociations[dwAssociation].inaddr, sizeof(IN_ADDR));
						iReturn = 0;
						goto Exit;
					}
				}
				else
				{
					if (dwIndex == -1)
					{
						dwIndex = dwAssociation;
					}
				}
			}
			
			if (dwIndex == -1)
			{
				DPFX(DPFPREP, 0, "No more security associations can be made!");
				iReturn = WSAENOBUFS;
				goto Exit;
			}

			g_paKeys[dwKey].paSecurityAssociations[dwIndex].fInUse = TRUE;
			memcpy(&g_paKeys[dwKey].paSecurityAssociations[dwIndex].xnaddr, pxna, sizeof(XNADDR));
			DBG_CASSERT(sizeof(pxna->abEnet) > (sizeof(IN_ADDR) + 1));
			memcpy(&g_paKeys[dwKey].paSecurityAssociations[dwIndex].inaddr, &pxna->abEnet[1], sizeof(IN_ADDR));
			memcpy(pina, &g_paKeys[dwKey].paSecurityAssociations[dwIndex].inaddr, sizeof(IN_ADDR));
			iReturn = 0;
			goto Exit;
		}
	}

	DPFX(DPFPREP, 0, "Key has not been registered!");
	DNASSERTX(! "Key has not been registered!", 2);
	iReturn = -1;

Exit:

	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetInAddrToXnAddr"
INT WINAPI XNetInAddrToXnAddr(const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid)
{
	int		iReturn;
	DWORD	dwKey;
	DWORD	dwAssociation;


	DPFX(DPFPREP, 3, "Parameters: (%u.%u.%u.%u, 0x%p, 0x%p)",
		ina.S_un.S_un_b.s_b1, ina.S_un.S_un_b.s_b2, ina.S_un.S_un_b.s_b3, ina.S_un.S_un_b.s_b4, pxna, pxnkid);

	//
	// Special case the loopback address, that just means the title address.
	//
	if (ina.S_un.S_addr == IP_LOOPBACK_ADDRESS)
	{
		if (pxna != NULL)
		{
			iReturn = XNetGetTitleXnAddr(pxna);
			DNASSERT((iReturn != XNET_GET_XNADDR_PENDING) && (iReturn != XNET_GET_XNADDR_NONE));
		}

		if (pxnkid != NULL)
		{
			memset(pxnkid, 0, sizeof(XNKID));
		}
		
		iReturn = 0;
		goto Exit;
	}

	for(dwKey = 0; dwKey < g_dwMaxNumKeys; dwKey++)
	{
		if (g_paKeys[dwKey].fInUse)
		{
			for(dwAssociation = 0; dwAssociation < g_dwMaxNumAssociations; dwAssociation++)
			{
				if (g_paKeys[dwKey].paSecurityAssociations[dwAssociation].fInUse)
				{
					if (memcmp(&ina, &g_paKeys[dwKey].paSecurityAssociations[dwAssociation].inaddr, sizeof(IN_ADDR)) == 0)
					{
						if (pxna != NULL)
						{
							memcpy(pxna, &g_paKeys[dwKey].paSecurityAssociations[dwAssociation].xnaddr, sizeof(XNADDR));
						}
						
						if (pxnkid != NULL)
						{
							memcpy(pxnkid, &g_paKeys[dwKey].xnkid, sizeof(XNKID));
						}
						
						iReturn = 0;
						goto Exit;
					}
				}
			}
		}
	}
	
	DPFX(DPFPREP, 0, "No security association for IN_ADDR specified!");
	DNASSERTX(! "No security association for IN_ADDR specified!", 2);
	iReturn = -1;


Exit:
	
	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetGetTitleXnAddr"
DWORD WINAPI XNetGetTitleXnAddr(XNADDR * pxna)
{
	DWORD		dwReturn;
	char		szBuffer[256];
	PHOSTENT	phostent;
	IN_ADDR *	pinaddr;


	DPFX(DPFPREP, 3, "Parameters: (0x%p)", pxna);

	DNASSERT(pxna != NULL);

	if (gethostname(szBuffer, sizeof(szBuffer)) == SOCKET_ERROR)
	{
#ifdef DBG
		dwReturn = WSAGetLastError();
		DPFX(DPFPREP, 0, "Failed to get host name into fixed size buffer (err = %i)!", dwReturn);
		DisplayWinsockError(0, dwReturn);
#endif // DBG
		dwReturn = XNET_GET_XNADDR_NONE;
		goto Exit;
	}

	phostent = gethostbyname(szBuffer);
	if (phostent == NULL)
	{
#ifdef DBG
		dwReturn = WSAGetLastError();
		DPFX(DPFPREP,  0, "Failed to get host data (err = %i)!", dwReturn);
		DisplayWinsockError(0, dwReturn);
#endif // DBG
		dwReturn = XNET_GET_XNADDR_NONE;
		goto Exit;
	}


	memset(pxna, 0, sizeof(XNADDR));

	//
	// We'll use the first address returned.
	//
	pinaddr = (IN_ADDR*) phostent->h_addr_list[0];
	DNASSERT(pinaddr != NULL);

	DBG_CASSERT(sizeof(pxna->abEnet) > (sizeof(IN_ADDR) + 1));
	memset(&pxna->abEnet, 0xFF, sizeof(pxna->abEnet));
	memcpy(&pxna->abEnet[1], pinaddr, sizeof(IN_ADDR));

	memcpy(&pxna->ina, pinaddr, sizeof(IN_ADDR));


	//
	// Pretend it's always DHCP.
	//
	dwReturn = XNET_GET_XNADDR_DHCP;

Exit:

	DPFX(DPFPREP, 3, "Returning: [%u]", dwReturn);

	return dwReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetGetEthernetLinkStatus"
DWORD WINAPI XNetGetEthernetLinkStatus(void)
{
	DWORD		dwReturn;


	DPFX(DPFPREP, 3, "Enter");

	//
	// Hard code an active 10 Mbit link.
	//
	dwReturn = XNET_ETHERNET_LINK_ACTIVE | XNET_ETHERNET_LINK_10MBPS;

	DPFX(DPFPREP, 3, "Returning: [0x%x]", dwReturn);

	return dwReturn;
}


#undef DPF_MODNAME
#define	DPF_MODNAME "XNetPrivCreateAssociation"
INT WINAPI XNetPrivCreateAssociation(const XNKID * pxnkid, const CSocketAddress * const pSocketAddress)
{
	int				iReturn;
	SOCKADDR_IN *	psockaddrin;
	DWORD			dwKey;
	DWORD			dwAssociation;
	DWORD			dwIndex;


	DPFX(DPFPREP, 3, "Parameters: (0x%p, 0x%p)", pxnkid, pSocketAddress);

	DNASSERT(pxnkid != NULL);
	DNASSERT(pSocketAddress != NULL);
	DNASSERT(pSocketAddress->GetFamily() == AF_INET);
	psockaddrin = (SOCKADDR_IN*) pSocketAddress->GetAddress();
	
	for(dwKey = 0; dwKey < g_dwMaxNumKeys; dwKey++)
	{
		if ((g_paKeys[dwKey].fInUse) &&
			(memcmp(pxnkid, &g_paKeys[dwKey].xnkid, sizeof(XNKID)) == 0))
		{
			dwIndex = -1;
			
			for(dwAssociation = 0; dwAssociation < g_dwMaxNumAssociations; dwAssociation++)
			{
				if (g_paKeys[dwKey].paSecurityAssociations[dwAssociation].fInUse)
				{
					if (memcmp(&psockaddrin->sin_addr, &g_paKeys[dwKey].paSecurityAssociations[dwAssociation].xnaddr, sizeof(psockaddrin->sin_addr)) == 0)
					{
						DPFX(DPFPREP, 2, "Security association already made.");
						iReturn = 0;
						goto Exit;
					}
				}
				else
				{
					if (dwIndex == -1)
					{
						dwIndex = dwAssociation;
					}
				}
			}
			
			if (dwIndex == -1)
			{
				DPFX(DPFPREP, 0, "No more security associations can be made!");
				iReturn = WSAENOBUFS;
				goto Exit;
			}

			g_paKeys[dwKey].paSecurityAssociations[dwIndex].fInUse = TRUE;
			memset(&g_paKeys[dwKey].paSecurityAssociations[dwIndex].xnaddr, 0, sizeof(XNADDR));
			memset(&g_paKeys[dwKey].paSecurityAssociations[dwIndex].xnaddr.abEnet, 0xFF,
					sizeof(g_paKeys[dwKey].paSecurityAssociations[dwIndex].xnaddr.abEnet));
			DBG_CASSERT(sizeof(g_paKeys[dwKey].paSecurityAssociations[dwIndex].xnaddr.abEnet) > (sizeof(IN_ADDR) + 1));
			memcpy(&g_paKeys[dwKey].paSecurityAssociations[dwIndex].xnaddr.abEnet[1],
					&psockaddrin->sin_addr, sizeof(IN_ADDR));
			memcpy(&g_paKeys[dwKey].paSecurityAssociations[dwIndex].inaddr, &psockaddrin->sin_addr, sizeof(IN_ADDR));
			iReturn = 0;
			goto Exit;
		}
	}

	DPFX(DPFPREP, 0, "Key has not been registered!");
	DNASSERTX(! "Key has not been registered!", 2);
	iReturn = -1;

Exit:

	DPFX(DPFPREP, 3, "Returning: [%i]", iReturn);

	return iReturn;
}



#endif // XBOX_ON_DESKTOP

#endif // _XBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\dpnthreadpooli.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnthreadpooli.h
 *
 *  Content:	DirectPlay Thread Pool master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __DPNTHREADPOOLI_H__
#define __DPNTHREADPOOLI_H__

//
// Build configuration include
//
#include "dpnbuild.h"


//
// In order to get waitable timers on Win98+, define _WIN32_WINDOWS > 0x0400 as
// indicated by <winbase.h>
//
#ifdef WIN95

#ifdef _WIN32_WINDOWS
#if (_WIN32_WINDOWS <= 0x0400)
#undef _WIN32_WINDOWS
#endif // _WIN32_WINDOWS <= 0x0400
#endif // _WIN32_WINDOWS

#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS	0x0401
#endif // ! _WIN32_WINDOWS

#endif // WIN95

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "creg.h"
#include "fixedpool.h"
#include "classfactory.h"
#include "dnslist.h"
#include "dnnbqueue.h"


// 
// DirectPlay Thread Pool private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_THREADPOOL

#include "work.h"
#include "timers.h"
#include "io.h"
#include "threadpoolapi.h"
#include "threadpooldllmain.h"
#include "threadpoolclassfac.h"
#include "threadpoolparamval.h"




#endif // __DPNTHREADPOOLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\sp\wsock\utils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   Utils.h
 *  Content:	Utilitiy functions
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/25/98	jtk		Created
 ***************************************************************************/

#ifndef __UTILS_H__
#define __UTILS_H__

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// forward references
//
class	CPackedBuffer;
class	CSPData;
class	CThreadPool;



//**********************************************************************
// Variable definitions
//**********************************************************************


//**********************************************************************
// Function prototypes
//**********************************************************************

BOOL	InitProcessGlobals( void );
void	DeinitProcessGlobals( void );

BOOL	LoadWinsock( void );
void	UnloadWinsock( void );

#ifndef DPNBUILD_NONATHELP
BOOL	LoadNATHelp( void );
void	UnloadNATHelp( void );
#endif // ! DPNBUILD_NONATHELP

#if ((defined(WINNT)) && (! defined(DPNBUILD_NOMULTICAST)))
BOOL	LoadMadcap( void );
void	UnloadMadcap( void );
#endif // WINNT and not DPNBUILD_NOMULTICAST

HRESULT	CreateSPData( CSPData **const ppSPData,
#if ((! defined(DPNBUILD_NOIPV6)) || (! defined(DPNBUILD_NOIPX)))
					  const short sSPType,
#endif // ! DPNBUILD_NOIPV6 or ! DPNBUILD_NOIPX
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
					  const XDP8CREATE_PARAMS * const pDP8CreateParams,
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
					  IDP8ServiceProviderVtbl *const pVtbl );

HRESULT	InitializeInterfaceGlobals( CSPData *const pSPData );
void	DeinitializeInterfaceGlobals( CSPData *const pSPData );

#ifndef DPNBUILD_NOIPV6
LPWSTR DNIpv6AddressToStringW(const struct in6_addr *Addr, LPWSTR S);
#endif // ! DPNBUILD_NOIPV6

HRESULT	AddInfoToBuffer( CPackedBuffer *const pPackedBuffer,
					   const WCHAR *const pwszInfoName,
					   const GUID *const pInfoGUID,
					   const DWORD dwFlags );


#ifdef _XBOX


BOOL InitializeRefcountXnKeys(const DWORD dwKeyRegMax);
void WINAPI CleanupRefcountXnKeys(void);
INT WINAPI RegisterRefcountXnKey(const XNKID * pxnkid, const XNKEY * pxnkey);
INT WINAPI UnregisterRefcountXnKey(const XNKID * pxnkid);


#ifdef XBOX_ON_DESKTOP

//
// Emulated Xbox networking library functions
//
INT WINAPI XNetStartup(const XNetStartupParams * pxnsp);
INT WINAPI XNetCleanup(void);

INT WINAPI XNetRegisterKey(const XNKID * pxnkid, const XNKEY * pxnkey);
INT WINAPI XNetUnregisterKey(const XNKID * pxnkid);

INT WINAPI XNetXnAddrToInAddr(const XNADDR * pxna, const XNKID * pxnkid, IN_ADDR * pina);
INT WINAPI XNetInAddrToXnAddr(const IN_ADDR ina, XNADDR * pxna, XNKID * pxnkid);


#define XNET_GET_XNADDR_PENDING             0x0000  // Address acquisition is not yet complete
#define XNET_GET_XNADDR_NONE                0x0001  // XNet is uninitialized or no debugger found
#define XNET_GET_XNADDR_ETHERNET            0x0002  // Host has ethernet address (no IP address)
#define XNET_GET_XNADDR_STATIC              0x0004  // Host has staticically assigned IP address
#define XNET_GET_XNADDR_DHCP                0x0008  // Host has DHCP assigned IP address
#define XNET_GET_XNADDR_PPPOE               0x0010  // Host has PPPoE assigned IP address
#define XNET_GET_XNADDR_GATEWAY             0x0020  // Host has one or more gateways configured
#define XNET_GET_XNADDR_DNS                 0x0040  // Host has one or more DNS servers configured
#define XNET_GET_XNADDR_ONLINE              0x0080  // Host is currently connected to online service
#define XNET_GET_XNADDR_TROUBLESHOOT        0x8000  // Network configuration requires troubleshooting

DWORD WINAPI XNetGetTitleXnAddr(XNADDR * pxna);


#define XNET_ETHERNET_LINK_ACTIVE		0x01	// Ethernet cable is connected and active
#define XNET_ETHERNET_LINK_100MBPS		0x02	// Ethernet link is set to 100 Mbps
#define XNET_ETHERNET_LINK_10MBPS		0x04	// Ethernet link is set to 10 Mbps
#define XNET_ETHERNET_LINK_FULL_DUPLEX	0x08	// Ethernet link is in full duplex mode
#define XNET_ETHERNET_LINK_HALF_DUPLEX	0x10	// Ethernet link is in half duplex mode

DWORD WINAPI XNetGetEthernetLinkStatus(void);



//
// Private functions used to improve simulation of real XNet behavior
//
INT WINAPI XNetPrivCreateAssociation(const XNKID * pxnkid, const CSocketAddress * const pSocketAddress);


#endif // XBOX_ON_DESKTOP

#endif // _XBOX


#endif	// __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\sources.inc ===
TARGETNAME=threadpool
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dpnthreadpooli.h
PRECOMPILED_PCH=dpnthreadpooli.pch
PRECOMPILED_OBJ=dpnthreadpooli.obj

INCLUDES=..\;..\..\common;..\..\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= io.cpp \
	 threadpoolapi.cpp \
	 threadpoolclassfac.cpp \
	 threadpooldllmain.cpp \
         threadpoolparamval.cpp \
	 timers.cpp \
	 work.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpoolclassfac.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		threadpoolclassfac.cpp
 *
 *  Content:	DirectPlay Thread Pool class factory functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  11/02/01  VanceO    Created.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"



//=============================================================================
// Function type definitions
//=============================================================================
#ifndef DPNBUILD_LIBINTERFACE
typedef	STDMETHODIMP UnknownQueryInterface(IUnknown * pInterface, REFIID riid, LPVOID *ppvObj);
typedef	STDMETHODIMP_(ULONG) UnknownAddRef(IUnknown * pInterface);
typedef	STDMETHODIMP_(ULONG) UnknownRelease(IUnknown * pInterface);
#endif // ! DPNBUILD_LIBINTERFACE

#ifndef DPNBUILD_ONLYONETHREAD
typedef	STDMETHODIMP ThreadPoolQueryInterface(IDirectPlay8ThreadPool * pInterface, DP8REFIID riid, LPVOID *ppvObj);
typedef	STDMETHODIMP_(ULONG) ThreadPoolAddRef(IDirectPlay8ThreadPool * pInterface);
typedef	STDMETHODIMP_(ULONG) ThreadPoolRelease(IDirectPlay8ThreadPool * pInterface);
#endif // ! DPNBUILD_ONLYONETHREAD

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DPNBUILD_MULTIPLETHREADPOOLS)))
typedef	STDMETHODIMP ThreadPoolWorkQueryInterface(IDirectPlay8ThreadPoolWork * pInterface, DP8REFIID riid, LPVOID *ppvObj);
typedef	STDMETHODIMP_(ULONG) ThreadPoolWorkAddRef(IDirectPlay8ThreadPoolWork * pInterface);
typedef	STDMETHODIMP_(ULONG) ThreadPoolWorkRelease(IDirectPlay8ThreadPoolWork * pInterface);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS




//=============================================================================
// Function Prototypes
//=============================================================================
#ifndef DPNBUILD_LIBINTERFACE
STDMETHODIMP DPTPCF_CreateInstance(IClassFactory * pInterface, LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID * ppv);

HRESULT DPTPCF_CreateInterface(OBJECT_DATA * pObject,
							REFIID riid,
							INTERFACE_LIST ** const ppv);

HRESULT DPTPCF_CreateObject(IClassFactory * pInterface, LPVOID * ppv, REFIID riid);
#endif // ! DPNBUILD_LIBINTERFACE

HRESULT DPTPCF_FreeObject(PVOID pvObject);

#ifndef DPNBUILD_LIBINTERFACE
INTERFACE_LIST * DPTPCF_FindInterface(void * pvInterface,
									REFIID riid);
#endif // ! DPNBUILD_LIBINTERFACE

#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONETHREAD) )|| (defined(DPNBUILD_MULTIPLETHREADPOOLS)))
STDMETHODIMP DPTP_QueryInterface(void * pvInterface,
								DP8REFIID riid,
								void ** ppv);

STDMETHODIMP_(ULONG) DPTP_AddRef(void * pvInterface);

STDMETHODIMP_(ULONG) DPTP_Release(void * pvInterface);
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS




//=============================================================================
// External globals
//=============================================================================
#ifndef DPNBUILD_LIBINTERFACE
IUnknownVtbl					DPTP_UnknownVtbl =
{
	(UnknownQueryInterface*)			DPTP_QueryInterface,
	(UnknownAddRef*)					DPTP_AddRef,
	(UnknownRelease*)					DPTP_Release
};
#endif // ! DPNBUILD_LIBINTERFACE

#ifndef DPNBUILD_ONLYONETHREAD
IDirectPlay8ThreadPoolVtbl		DPTP_Vtbl =
{
	(ThreadPoolQueryInterface*)			DPTP_QueryInterface,
	(ThreadPoolAddRef*)					DPTP_AddRef,
	(ThreadPoolRelease*)				DPTP_Release,
										DPTP_Initialize,
										DPTP_Close,
										DPTP_GetThreadCount,
										DPTP_SetThreadCount,
										DPTP_DoWork,
};
#endif // ! DPNBUILD_ONLYONETHREAD

IDirectPlay8ThreadPoolWorkVtbl	DPTPW_Vtbl =
{
#if ((! defined(DPNBUILD_LIBINTERFACE)) || (! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	(ThreadPoolWorkQueryInterface*)		DPTP_QueryInterface,
	(ThreadPoolWorkAddRef*)				DPTP_AddRef,
	(ThreadPoolWorkRelease*)			DPTP_Release,
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
										DPTPW_QueueWorkItem,
										DPTPW_ScheduleTimer,
										DPTPW_StartTrackingFileIo,
										DPTPW_StopTrackingFileIo,
										DPTPW_CreateOverlapped,
										DPTPW_SubmitIoOperation,
										DPTPW_ReleaseOverlapped,
										DPTPW_CancelTimer,
										DPTPW_ResetCompletingTimer,
										DPTPW_WaitWhileWorking,
										DPTPW_SleepWhileWorking,
										DPTPW_RequestTotalThreadCount,
										DPTPW_GetThreadCount,
										DPTPW_GetWorkRecursionDepth,
										DPTPW_Preallocate,
#ifdef DPNBUILD_MANDATORYTHREADS
										DPTPW_CreateMandatoryThread,
#endif // DPNBUILD_MANDATORYTHREADS
};

#ifndef DPNBUILD_LIBINTERFACE
IClassFactoryVtbl				DPTPCF_Vtbl =
{
	DPCF_QueryInterface, // dplay8\common\classfactory.cpp will implement the rest of these
	DPCF_AddRef,
	DPCF_Release,
	DPTPCF_CreateInstance,
	DPCF_LockServer
};




#undef DPF_MODNAME
#define DPF_MODNAME "DPTPCF_CreateInstance"
//=============================================================================
// DPTPCF_CreateInstance
//-----------------------------------------------------------------------------
//
// Description:    Creates a new thread pool object COM instance.
//
// Arguments:
//	IClassFactory * pInterface	- ?
//	LPUNKNOWN lpUnkOuter		- ?
//	REFIID riid					- ?
//	LPVOID * ppv				- ?
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP DPTPCF_CreateInstance(IClassFactory * pInterface, LPUNKNOWN lpUnkOuter, REFIID riid, LPVOID * ppv)
{
	HRESULT				hResultCode;
	INTERFACE_LIST		*pIntList;
	OBJECT_DATA			*pObjectData;

	DPFX(DPFPREP, 6,"Parameters: pInterface [%p], lpUnkOuter [%p], riid [%p], ppv [%p]",pInterface,lpUnkOuter,&riid,ppv);
	
	if (pInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (lpUnkOuter != NULL)
	{
		hResultCode = CLASS_E_NOAGGREGATION;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}

	pObjectData = NULL;
	pIntList = NULL;

	if ((pObjectData = static_cast<OBJECT_DATA*>(DNMalloc(sizeof(OBJECT_DATA)))) == NULL)
	{
		DPFERR("Could not allocate object");
		hResultCode = E_OUTOFMEMORY;
		goto Failure;
	}

	// Object creation and initialization
	if ((hResultCode = DPTPCF_CreateObject(pInterface, &pObjectData->pvData,riid)) != S_OK)
	{
		DPFERR("Could not create object");
		goto Failure;
	}
	DPFX(DPFPREP, 7,"Created and initialized object");

	// Get requested interface
	if ((hResultCode = DPTPCF_CreateInterface(pObjectData,riid,&pIntList)) != S_OK)
	{
		DPTPCF_FreeObject(pObjectData->pvData);
		goto Failure;
	}
	DPFX(DPFPREP, 7,"Found interface");

	pObjectData->pIntList = pIntList;
	pObjectData->lRefCount = 1;
	DPTP_AddRef( pIntList );
	DNInterlockedIncrement(&g_lDPTPInterfaceCount);
	*ppv = pIntList;

	DPFX(DPFPREP, 7,"*ppv = [0x%p]",*ppv);
	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 6,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);

Failure:
	if (pObjectData)
	{
		DNFree(pObjectData);
		pObjectData = NULL;
	}
	goto Exit;
} // DPTPCF_CreateInstance



#undef DPF_MODNAME
#define DPF_MODNAME "DPTPCF_CreateInterface"
//=============================================================================
// DPTPCF_CreateInterface
//-----------------------------------------------------------------------------
//
// Description:    Creates a new thread pool object interface.
//
// Arguments:
//	OBJECT_DATA * pObject	- ?
//	REFIID riid				- ?
//	INTERFACE_LIST ** ppv	- ?
//
// Returns: HRESULT
//=============================================================================
HRESULT DPTPCF_CreateInterface(OBJECT_DATA * pObject,
							REFIID riid,
							INTERFACE_LIST ** const ppv)
{
	INTERFACE_LIST	*pIntNew;
	PVOID			lpVtbl;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 6,"Parameters: pObject [%p], riid [%p], ppv [%p]",pObject,&riid,ppv);

	DNASSERT(pObject != NULL);
	DNASSERT(ppv != NULL);

    const DPTHREADPOOLOBJECT* pDPTPObject = ((DPTHREADPOOLOBJECT *)pObject->pvData);

	if (IsEqualIID(riid,IID_IUnknown))
	{
		DPFX(DPFPREP, 7,"riid = IID_IUnknown");
		lpVtbl = &DPTP_UnknownVtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8ThreadPool))
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8ThreadPool");
		lpVtbl = &DPTP_Vtbl;
	}
	else if (IsEqualIID(riid,IID_IDirectPlay8ThreadPoolWork))
	{
		DPFX(DPFPREP, 7,"riid = IID_IDirectPlay8ThreadPoolWork");
		lpVtbl = &DPTPW_Vtbl;
	}
	else
	{
		DPFERR("riid not found !");
		hResultCode = E_NOINTERFACE;
		goto Exit;
	}

	if ((pIntNew = static_cast<INTERFACE_LIST*>(DNMalloc(sizeof(INTERFACE_LIST)))) == NULL)
	{
		DPFERR("Could not allocate interface");
		hResultCode = E_OUTOFMEMORY;
		goto Exit;
	}
	pIntNew->lpVtbl = lpVtbl;
	pIntNew->lRefCount = 0;
	pIntNew->pIntNext = NULL;
	DBG_CASSERT( sizeof( pIntNew->iid ) == sizeof( riid ) );
	memcpy( &(pIntNew->iid), &riid, sizeof( pIntNew->iid ) );
	pIntNew->pObject = pObject;

	*ppv = pIntNew;
	DPFX(DPFPREP, 7,"*ppv = [0x%p]",*ppv);

	hResultCode = S_OK;

Exit:
    DPFX(DPFPREP, 6,"Returning: hResultCode = [%lx]",hResultCode);
	return(hResultCode);
} // DPTPCF_CreateInterface

#endif // ! DPNBUILD_LIBINTERFACE



#undef DPF_MODNAME
#define DPF_MODNAME "DPTPCF_CreateObject"
//=============================================================================
// DPTPCF_CreateObject
//-----------------------------------------------------------------------------
//
// Description:    Creates a new thread pool object.
//
// Arguments:
//	IClassFactory * pInterface	- ?
//	PVOID * ppv					- ?
//	REFIID riid					- ?
//
// Returns: HRESULT
//=============================================================================
#ifdef DPNBUILD_LIBINTERFACE
HRESULT DPTPCF_CreateObject(PVOID * ppv)
#else // ! DPNBUILD_LIBINTERFACE
HRESULT DPTPCF_CreateObject(IClassFactory * pInterface, PVOID * ppv, REFIID riid)
#endif // ! DPNBUILD_LIBINTERFACE
{
	HRESULT						hr;
	DPTHREADPOOLOBJECT *		pDPTPObject = NULL;
#ifndef DPNBUILD_LIBINTERFACE
	const _IDirectPlayClassFactory *	pDPClassFactory = (_IDirectPlayClassFactory*) pInterface;
#endif // ! DPNBUILD_LIBINTERFACE
	BOOL						fHaveGlobalThreadPoolLock = FALSE;
	BOOL						fInittedLock = FALSE;
#ifdef DPNBUILD_ONLYONEPROCESSOR
	BOOL						fInittedWorkQueue = FALSE;
#else // ! DPNBUILD_ONLYONEPROCESSOR
	SYSTEM_INFO					SystemInfo;
	DWORD						dwTemp;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_ONLYONETHREAD
	DWORD						dwWorkerThreadTlsIndex = -1;
#ifdef DBG
	DWORD						dwError;
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD


#ifndef DPNBUILD_LIBINTERFACE
	if ((riid != IID_IDirectPlay8ThreadPool) &&
		(riid != IID_IDirectPlay8ThreadPoolWork))
	{
		DPFX(DPFPREP, 0, "Requesting unknown interface from thread pool CLSID!");
		hr = E_NOINTERFACE;
		goto Failure;
	}
#endif // ! DPNBUILD_LIBINTERFACE


#ifndef DPNBUILD_MULTIPLETHREADPOOLS
	//
	// See if we've already allocated a thread pool object, because you only
	// get one per process.
	//
	DNEnterCriticalSection(&g_csGlobalThreadPoolLock);
	fHaveGlobalThreadPoolLock = TRUE;

#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONETHREAD)))
	DNASSERT(g_pDPTPObject == NULL);
#else // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD 
	if (g_pDPTPObject != NULL)
	{
		LONG	lRefCount;

		
#ifdef DPNBUILD_LIBINTERFACE
		DNASSERT(g_pDPTPObject->lRefCount >= 0);
		lRefCount = DNInterlockedIncrement(&g_pDPTPObject->lRefCount);
#else // ! DPNBUILD_LIBINTERFACE
		lRefCount = ++g_dwDPTPRefCount;
#endif // ! DPNBUILD_LIBINTERFACE
		DPFX(DPFPREP, 1, "Global thread pool object 0x%p already exists, ref count now %u.",
			g_pDPTPObject, lRefCount);
		(*ppv) = g_pDPTPObject;
		hr = S_OK;
		goto Exit;
	}
#endif // ! DPNBUILD_LIBINTERFACE or ! DPNBUILD_ONLYONETHREAD 
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

	pDPTPObject = (DPTHREADPOOLOBJECT*) DNMalloc(sizeof(DPTHREADPOOLOBJECT));
	if (pDPTPObject == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for thread pool object!");
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Zero out the entire structure to start.
	//
	memset(pDPTPObject, 0, sizeof(DPTHREADPOOLOBJECT));

	pDPTPObject->Sig[0] = 'D';
	pDPTPObject->Sig[1] = 'P';
	pDPTPObject->Sig[2] = 'T';
	pDPTPObject->Sig[3] = 'P';


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Start by assuming the user will want parameter validation.
	//
	pDPTPObject->dwFlags = DPTPOBJECTFLAG_USER_PARAMVALIDATION;
#endif // ! DPNBUILD_NOPARAMVAL


#ifndef DPNBUILD_ONLYONEPROCESSOR
	GetSystemInfo(&SystemInfo);
	pDPTPObject->dwNumCPUs						= SystemInfo.dwNumberOfProcessors;
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#ifndef DPNBUILD_ONLYONETHREAD
	pDPTPObject->dwTotalUserThreadCount			= -1;
	pDPTPObject->dwTotalDesiredWorkThreadCount	= -1;
	pDPTPObject->dwWorkRecursionCountTlsIndex	= -1;
	pDPTPObject->lNumThreadCountChangeWaiters	= 0;

#if ((defined(DPNBUILD_MANDATORYTHREADS)) && (defined(DBG)))
	pDPTPObject->blMandatoryThreads.Initialize();
#endif // DPNBUILD_MANDATORYTHREADS and DBG
	

	//
	// Allocate Thread Local Storage for tracking recursion on non-worker
	// threads.
	//
	pDPTPObject->dwWorkRecursionCountTlsIndex = TlsAlloc();
	if (pDPTPObject->dwWorkRecursionCountTlsIndex == -1)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't allocate Thread Local Storage slot for tracking recursion on non-worker threads (err = %u)!", dwError);
#endif // DBG
		hr = E_OUTOFMEMORY;
		goto Failure;
	}
	
	//
	// Allocate Thread Local Storage for tracking worker threads.
	//
	dwWorkerThreadTlsIndex = TlsAlloc();
	if (dwWorkerThreadTlsIndex == -1)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't allocate Thread Local Storage slot for tracking worker threads (err = %u)!", dwError);
#endif // DBG
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Create a semaphore to release threads waiting on another thread changing
	// the thread count.
	//
	pDPTPObject->hThreadCountChangeComplete = DNCreateSemaphore(NULL, 0, 0xFFFF, NULL);
	if (pDPTPObject->hThreadCountChangeComplete == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create thread count change complete semaphore (err = %u)!", dwError);
#endif // DBG
		hr = E_OUTOFMEMORY;
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONETHREAD


#ifdef DPNBUILD_ONLYONEPROCESSOR
#ifdef DPNBUILD_ONLYONETHREAD
	hr = InitializeWorkQueue(&pDPTPObject->WorkQueue);
#else // ! DPNBUILD_ONLYONETHREAD
	hr = InitializeWorkQueue(&pDPTPObject->WorkQueue,
							NULL,
							NULL,
							dwWorkerThreadTlsIndex);
#endif // ! DPNBUILD_ONLYONETHREAD
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize work queue!");
		goto Failure;
	}
	fInittedWorkQueue = TRUE;
#else // ! DPNBUILD_ONLYONEPROCESSOR
	//
	// Allocate the array of work queues pointers, one for each processor.
	//
	pDPTPObject->papCPUWorkQueues = (DPTPWORKQUEUE**) DNMalloc(NUM_CPUS(pDPTPObject) * sizeof(DPTPWORKQUEUE*));
	if (pDPTPObject->papCPUWorkQueues == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for array of work queue pointers!");
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Initialize each of the work queues.
	//
	for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
	{
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
		if (dwTemp > 0)
		{
			pDPTPObject->papCPUWorkQueues[dwTemp] = pDPTPObject->papCPUWorkQueues[0];
		}
		else
#endif // DPNBUILD_USEIOCOMPLETIONPORTS
		{
			//
			// Allocate the actual work queues object.
			//
			pDPTPObject->papCPUWorkQueues[dwTemp] = (DPTPWORKQUEUE*) DNMalloc(sizeof(DPTPWORKQUEUE));
			if (pDPTPObject->papCPUWorkQueues[dwTemp] == NULL)
			{
				DPFX(DPFPREP, 0, "Couldn't allocate memory for work queue %u!", dwTemp);
				hr = E_OUTOFMEMORY;
				goto Failure;
			}


#ifdef DPNBUILD_ONLYONETHREAD
			hr = InitializeWorkQueue(WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp),
									dwTemp);
#else // ! DPNBUILD_ONLYONETHREAD
			hr = InitializeWorkQueue(WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp),
									dwTemp,
									NULL,
									NULL,
									dwWorkerThreadTlsIndex);
#endif // ! DPNBUILD_ONLYONETHREAD
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't intialize work queue %u!", dwTemp);
				
				DNFree(pDPTPObject->papCPUWorkQueues[dwTemp]);
				pDPTPObject->papCPUWorkQueues[dwTemp] = NULL;
				goto Failure;
			}
		}
	}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

	if (! DNInitializeCriticalSection(&pDPTPObject->csLock))
	{
		DPFX(DPFPREP, 0, "Couldn't initialize object lock!");
		hr = E_OUTOFMEMORY;
		goto Failure;
	}
	fInittedLock = TRUE;


#ifdef DPNBUILD_LIBINTERFACE
	//
	// For lib interface builds, the Vtbl and reference are embedded in the
	// object directly.
	//
#ifdef DPNBUILD_ONLYONETHREAD
	pDPTPObject->lpVtbl = &DPTPW_Vtbl;
#ifdef DPNBUILD_MULTIPLETHREADPOOLS
	pDPTPObject->lRefCount = 1;
#endif // DPNBUILD_MULTIPLETHREADPOOLS
#else // ! DPNBUILD_ONLYONETHREAD
	// We assume only the work interface is created.  The ID will have to be
	// passed in or something (see DNCF_CreateObject).
#pragma error("Building with DPNBUILD_LIBINTERFACE but not DPNBUILD_ONLYONETHREAD requires minor changes")
#endif // ! DPNBUILD_ONLYONETHREAD
#endif // DPNBUILD_LIBINTERFACE

#ifndef DPNBUILD_MULTIPLETHREADPOOLS
	//
	// Store this as the only object allowed in this process.
	//
	g_pDPTPObject = pDPTPObject;
#ifndef DPNBUILD_LIBINTERFACE
	g_dwDPTPRefCount++;
#endif // ! DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

	DPFX(DPFPREP, 2, "Created object 0x%p.", pDPTPObject);
	(*ppv) = pDPTPObject;

Exit:

#ifndef DPNBUILD_MULTIPLETHREADPOOLS
	//
	// See if we've already allocated a thread pool object, because you only
	// get one per process.
	//
	if (fHaveGlobalThreadPoolLock)
	{
		DNLeaveCriticalSection(&g_csGlobalThreadPoolLock);
		fHaveGlobalThreadPoolLock = FALSE;
	}
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

	return hr;


Failure:

	if (pDPTPObject != NULL)
	{
		if (fInittedLock)
		{
			DNDeleteCriticalSection(&pDPTPObject->csLock);
			fInittedLock = FALSE;
		}

#ifdef DPNBUILD_ONLYONEPROCESSOR
		if (fInittedWorkQueue)
		{
			DeinitializeWorkQueue(&pDPTPObject->WorkQueue);
			fInittedWorkQueue = FALSE;
		}
#else // ! DPNBUILD_ONLYONEPROCESSOR
		if (pDPTPObject->papCPUWorkQueues != NULL)
		{
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
			dwTemp = 0;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
			for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
			{
				if (WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp) != NULL)
				{
					DeinitializeWorkQueue(WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp));
					DNFree(pDPTPObject->papCPUWorkQueues[dwTemp]);
				}
			}

			DNFree(pDPTPObject->papCPUWorkQueues);
			pDPTPObject->papCPUWorkQueues = NULL;
		}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#ifndef DPNBUILD_ONLYONETHREAD
		if (pDPTPObject->hThreadCountChangeComplete != NULL)
		{
			DNCloseHandle(pDPTPObject->hThreadCountChangeComplete);
			pDPTPObject->hThreadCountChangeComplete = NULL;
		}

		if (dwWorkerThreadTlsIndex != -1)
		{
			TlsFree(dwWorkerThreadTlsIndex);
			dwWorkerThreadTlsIndex = -1;
		}

		if (pDPTPObject->dwWorkRecursionCountTlsIndex != -1)
		{
			TlsFree(pDPTPObject->dwWorkRecursionCountTlsIndex);
			pDPTPObject->dwWorkRecursionCountTlsIndex = -1;
		}
#endif // ! DPNBUILD_ONLYONETHREAD

		DNFree(pDPTPObject);
		pDPTPObject = NULL;
	}

	goto Exit;
} // DPTPCF_CreateObject





#if ((defined(DPNBUILD_LIBINTERFACE)) && (defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
#undef DPF_MODNAME
#define DPF_MODNAME "DPTPCF_GetObject"
//=============================================================================
// DPTPCF_GetObject
//-----------------------------------------------------------------------------
//
// Description:    Gets a pointer to the global thread pool object.
//
// Arguments:
//	PVOID * ppv		- ?
//
// Returns: None
//=============================================================================
void DPTPCF_GetObject(PVOID * ppv)
{
	(*ppv) = g_pDPTPObject;
} // DPTPCF_GetObject
#endif // DPNBUILD_LIBINTERFACE DPNBUILD_ONLYONETHREAD and ! DPNBUILD_MULTIPLETHREADPOOLS





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPCF_FreeObject"
//=============================================================================
// DPTPCF_FreeObject
//-----------------------------------------------------------------------------
//
// Description:    Frees an existing thread pool object.
//
// Arguments:
//	PVOID pvObject	- ?
//
// Returns: HRESULT
//=============================================================================
HRESULT DPTPCF_FreeObject(PVOID pvObject)
{
	DPTHREADPOOLOBJECT *	pDPTPObject = (DPTHREADPOOLOBJECT*) pvObject;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwTemp;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_ONLYONETHREAD
	DWORD					dwWorkerThreadTlsIndex;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, 4, "Parameters: (0x%p)", pvObject);


#ifndef DPNBUILD_MULTIPLETHREADPOOLS
	DNEnterCriticalSection(&g_csGlobalThreadPoolLock);
	DNASSERT(pDPTPObject == g_pDPTPObject);
#ifdef DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONETHREAD
	//
	// It's possible somebody just took a reference on the object, so we may
	// need to bail.
	//
	DNASSERT(pDPTPObject->lRefCount >= 0);
	if (pDPTPObject->lRefCount > 0)
	{
		DPFX(DPFPREP, 1, "Global thread pool object 0x%p just got referenced (refcount now %i), not destroying.",
			g_pDPTPObject, pDPTPObject->lRefCount);
		DNLeaveCriticalSection(&g_csGlobalThreadPoolLock);
		return S_OK;
	}
#endif // ! DPNBUILD_ONLYONETHREAD
#else // ! DPNBUILD_LIBINTERFACE
	//
	// Reduce the global object count.  There might be other users, though.
	//
	g_dwDPTPRefCount--;
	if (g_dwDPTPRefCount != 0)
	{
		DPFX(DPFPREP, 1, "Global thread pool object 0x%p still has other users, refcount now %u.",
			g_pDPTPObject, g_dwDPTPRefCount);
		DNLeaveCriticalSection(&g_csGlobalThreadPoolLock);
		return S_OK;
	}
#endif // ! DPNBUILD_LIBINTERFACE
	g_pDPTPObject = NULL;
	DNLeaveCriticalSection(&g_csGlobalThreadPoolLock);
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

	//
	// Double check to make sure the object is closed.
	//
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED)
	{
		DPFX(DPFPREP, 0, "User has not closed IDirectPlay8ThreadPool interface!");
		DNASSERT(FALSE);

		//
		// Forcefully mark the user's interface as no longer available.
		//
		pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_USER_INITIALIZED;
	}


#ifdef DPNBUILD_LIBINTERFACE
	//
	// For lib interface builds, the reference is embedded in the object
	// directly.
	//
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	DNASSERT(pDPTPObject->lRefCount == 0);
#endif // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#endif // DPNBUILD_LIBINTERFACE


#ifndef DPNBUILD_ONLYONETHREAD
	//
	// Save the Thread Local Storage index value before cleaning up the work
	// queues.  Since all work queues share the same TLS index, just use the
	// first CPU as representative of all of them.
	//
	dwWorkerThreadTlsIndex = (WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex;
#endif // ! DPNBUILD_ONLYONETHREAD


	DNDeleteCriticalSection(&pDPTPObject->csLock);

#ifdef DPNBUILD_ONLYONEPROCESSOR
	DeinitializeWorkQueue(&pDPTPObject->WorkQueue);
#else // ! DPNBUILD_ONLYONEPROCESSOR
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	dwTemp = 0;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
	{
		DeinitializeWorkQueue(WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp));
		DNFree(pDPTPObject->papCPUWorkQueues[dwTemp]);
	}

	DNFree(pDPTPObject->papCPUWorkQueues);
	pDPTPObject->papCPUWorkQueues = NULL;
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#ifndef DPNBUILD_ONLYONETHREAD
	//
	// Close the thread count change complete semaphore.
	//
	DNASSERT(pDPTPObject->lNumThreadCountChangeWaiters == 0);
	DNCloseHandle(pDPTPObject->hThreadCountChangeComplete);
	pDPTPObject->hThreadCountChangeComplete = NULL;

	//
	// Free the Thread Local Storage slot for tracking worker threads.
	//
	TlsFree(dwWorkerThreadTlsIndex);
	dwWorkerThreadTlsIndex = -1;

	//
	// Free the Thread Local Storage slot for tracking recursion on non-worker
	// threads.
	//
	TlsFree(pDPTPObject->dwWorkRecursionCountTlsIndex);
	pDPTPObject->dwWorkRecursionCountTlsIndex = -1;

#ifdef DPNBUILD_MANDATORYTHREADS
	DNASSERT(pDPTPObject->dwMandatoryThreadCount == 0);
#endif // DPNBUILD_MANDATORYTHREADS
#endif // ! DPNBUILD_ONLYONETHREAD

	
	//
	// Make sure there aren't any flags set except possibly
	// USER_PARAMVALIDATION.
	//
	DNASSERT(! (pDPTPObject->dwFlags & ~(DPTPOBJECTFLAG_USER_PARAMVALIDATION)));

	DNFree(pDPTPObject);
	pDPTPObject = NULL;

	DPFX(DPFPREP, 4, "Returning: [S_OK]");

	return S_OK;
} // DPTPCF_FreeObject




#ifdef DPNBUILD_LIBINTERFACE


#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DPNBUILD_MULTIPLETHREADPOOLS)))

#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_QueryInterface"
//=============================================================================
// DPTP_QueryInterface
//-----------------------------------------------------------------------------
//
// Description:    Queries for a new interface for an existing object.
//
// Arguments:
//	void * pvInterface	- ?
//	DP8REFIID riid		- ?
//	void ** ppv			- ?
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP DPTP_QueryInterface(void * pvInterface,
							   DP8REFIID riid,
							   void ** ppv)
{
	HRESULT		hResultCode;

	
	DPFX(DPFPREP, 2,"Parameters: pvInterface [0x%p], riid [0x%p], ppv [0x%p]",pvInterface,&riid,ppv);


	//
	// Get the object Vtbl and make sure it's one of ours
	//
	if (*((PVOID*) pvInterface) == (&DPTPW_Vtbl))
	{
		//
		// It is one of our objects.  Assume the IID is not specified, so just
		// return a reference to the existing object.
		//
		DNASSERT(riid == 0);
		hResultCode = S_OK;
		DPTP_AddRef(pvInterface);
		*ppv = pvInterface;
	}
	else
	{
		DPFX(DPFPREP, 0, "Invalid object!");
		hResultCode = E_POINTER;
	}
	
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
} // DPTP_QueryInterface



#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_AddRef"
//=============================================================================
// DPTP_AddRef
//-----------------------------------------------------------------------------
//
// Description:    Adds a reference to a thread pool interface.
//
// Arguments:
//	void * pvInterface	- ?
//
// Returns: ULONG
//=============================================================================
STDMETHODIMP_(ULONG) DPTP_AddRef(void * pvInterface)
{
	DPTHREADPOOLOBJECT *	pDPTPObject;
	LONG					lRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p]",pvInterface);

#ifndef DPNBUILD_NOPARAMVAL
	if (pvInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pDPTPObject = static_cast<DPTHREADPOOLOBJECT*>(pvInterface);
	lRefCount = DNInterlockedIncrement(&pDPTPObject->lRefCount);
	DNASSERT(lRefCount > 0);
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
} // DPTP_AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_Release"
//=============================================================================
// DPTP_Release
//-----------------------------------------------------------------------------
//
// Description:    Removes a reference from a thread pool interface.  If it is
//				the last reference on the object, the object is destroyed.
//
// Arguments:
//	void * pvInterface	- ?
//
// Returns: ULONG
//=============================================================================
STDMETHODIMP_(ULONG) DPTP_Release(void * pvInterface)
{
	DPTHREADPOOLOBJECT *	pDPTPObject;
	LONG					lRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pvInterface);
	
#ifndef DPNBUILD_NOPARAMVAL
	if (pvInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pDPTPObject = static_cast<DPTHREADPOOLOBJECT*>(pvInterface);
	DNASSERT(pDPTPObject->lRefCount > 0);
	lRefCount = DNInterlockedDecrement(&pDPTPObject->lRefCount);
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

	if (lRefCount == 0)
	{
		// Free object here
		DPFX(DPFPREP, 5,"Free object");
		DPTPCF_FreeObject(pvInterface);
	}

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
} // DPTP_Release

#endif // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS


#else // ! DPNBUILD_LIBINTERFACE


#undef DPF_MODNAME
#define DPF_MODNAME "DPTPCF_FindInterface"
//=============================================================================
// DPTPCF_FindInterface
//-----------------------------------------------------------------------------
//
// Description:    Locates an interface for a given object.
//
//				   Initialize must have been called.
//
// Arguments:
//	void * pvInterface	- ?
//	REFIID riid			- ?
//
// Returns: HRESULT
//=============================================================================
INTERFACE_LIST * DPTPCF_FindInterface(void * pvInterface,
									REFIID riid)
{
	INTERFACE_LIST *	pInterfaceList;


	DPFX(DPFPREP, 6,"Parameters: (0x%p, 0x%p)", pvInterface, &riid);

	DNASSERT(pvInterface != NULL);

	pInterfaceList = (static_cast<INTERFACE_LIST*>(pvInterface))->pObject->pIntList;	// Find first interface
	while (pInterfaceList != NULL)
	{
		if (IsEqualIID(riid, pInterfaceList->iid))
		{
			break;
		}
		pInterfaceList = pInterfaceList->pIntNext;
	}

	DPFX(DPFPREP, 6,"Returning: [0x%p]", pInterfaceList);

	return pInterfaceList;
} // DPTPCF_FindInterface




#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_QueryInterface"
//=============================================================================
// DPTP_QueryInterface
//-----------------------------------------------------------------------------
//
// Description:    Queries for a new interface for an existing object.
//
// Arguments:
//	void * pvInterface	- ?
//	REFIID riid			- ?
//	void ** ppv			- ?
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP DPTP_QueryInterface(void * pvInterface,
							   DP8REFIID riid,
							   void ** ppv)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntNew;
	HRESULT			hResultCode;

	DPFX(DPFPREP, 2,"Parameters: pvInterface [0x%p], riid [0x%p], ppv [0x%p]",pvInterface,&riid,ppv);
	
#ifndef DPNBUILD_NOPARAMVAL
	if (pvInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		hResultCode = E_INVALIDARG;
		goto Exit;
	}
	if (ppv == NULL)
	{
		DPFERR("Invalid target interface pointer specified");
		hResultCode = E_POINTER;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	if ((pIntList = DPTPCF_FindInterface(pvInterface,riid)) == NULL)
	{	// Interface must be created
		pIntList = (static_cast<INTERFACE_LIST*>(pvInterface))->pObject->pIntList;
		if ((hResultCode = DPTPCF_CreateInterface(pIntList->pObject,riid,&pIntNew)) != S_OK)
		{
			goto Exit;
		}
		pIntNew->pIntNext = pIntList;
		pIntList->pObject->pIntList = pIntNew;
		pIntList = pIntNew;
	}
	if (pIntList->lRefCount == 0)		// New interface exposed
	{
		DNInterlockedIncrement(&pIntList->pObject->lRefCount);
	}
	DNInterlockedIncrement(&pIntList->lRefCount);
	*ppv = static_cast<void*>(pIntList);
	DPFX(DPFPREP, 5,"*ppv = [0x%p]", *ppv);

	hResultCode = S_OK;

Exit:
	DPFX(DPFPREP, 2,"Returning: [0x%lx]",hResultCode);
	return(hResultCode);
} // DPTP_QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_AddRef"
//=============================================================================
// DPTP_AddRef
//-----------------------------------------------------------------------------
//
// Description:    Adds a reference to a thread pool interface.
//
// Arguments:
//	void * pvInterface	- ?
//
// Returns: ULONG
//=============================================================================
STDMETHODIMP_(ULONG) DPTP_AddRef(void * pvInterface)
{
	INTERFACE_LIST	*pIntList;
	LONG			lRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [0x%p]",pvInterface);

#ifndef DPNBUILD_NOPARAMVAL
	if (pvInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pIntList = static_cast<INTERFACE_LIST*>(pvInterface);
	lRefCount = DNInterlockedIncrement(&pIntList->lRefCount);
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // !DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
} // DPTP_AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_Release"
//=============================================================================
// DPTP_Release
//-----------------------------------------------------------------------------
//
// Description:    Removes a reference from a thread pool interface.  If it is
//				the last reference on the object, the object is destroyed.
//
// Arguments:
//	void * pvInterface	- ?
//
// Returns: ULONG
//=============================================================================
STDMETHODIMP_(ULONG) DPTP_Release(void * pvInterface)
{
	INTERFACE_LIST	*pIntList;
	INTERFACE_LIST	*pIntCurrent;
	LONG			lRefCount;
	LONG			lObjRefCount;

	DPFX(DPFPREP, 2,"Parameters: pInterface [%p]",pvInterface);
	
#ifndef DPNBUILD_NOPARAMVAL
	if (pvInterface == NULL)
	{
		DPFERR("Invalid COM interface specified");
		lRefCount = 0;
		goto Exit;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	pIntList = static_cast<INTERFACE_LIST*>(pvInterface);
	lRefCount = DNInterlockedDecrement( &pIntList->lRefCount );
	DPFX(DPFPREP, 5,"New lRefCount [%ld]",lRefCount);

	if (lRefCount == 0)
	{
		//
		//	Decrease object's interface count
		//
		lObjRefCount = DNInterlockedDecrement( &pIntList->pObject->lRefCount );

		//
		//	Free object and interfaces
		//
		if (lObjRefCount == 0)
		{
			// Free object here
			DPFX(DPFPREP, 5,"Free object");
			DPTPCF_FreeObject(pIntList->pObject->pvData);
			
			pIntList = pIntList->pObject->pIntList;	// Get head of interface list
			DNFree(pIntList->pObject);

			// Free Interfaces
			DPFX(DPFPREP, 5,"Free interfaces");
			while(pIntList != NULL)
			{
				pIntCurrent = pIntList;
				pIntList = pIntList->pIntNext;
				DNFree(pIntCurrent);
			}

			DNInterlockedDecrement(&g_lDPTPInterfaceCount);
		}
	}

#ifndef DPNBUILD_NOPARAMVAL
Exit:
#endif // ! DPNBUILD_NOPARAMVAL
	DPFX(DPFPREP, 2,"Returning: lRefCount [%ld]",lRefCount);
	return(lRefCount);
} // DPTP_Release

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpoolapi.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		threadpoolapi.cpp
 *
 *  Content:	DirectPlay Thread Pool API implementation functions.
 *
 *  History:
 *   Date	  By		Reason
 *  ========  ========  =========
 *  10/31/01  VanceO	Created.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"




//=============================================================================
// Macros
//=============================================================================
#ifdef DPNBUILD_ONLYONEPROCESSOR
#define GET_OR_CHOOSE_WORKQUEUE(pDPTPObject, dwCPU)		(&pDPTPObject->WorkQueue)
#else // ! DPNBUILD_ONLYONEPROCESSOR
#define GET_OR_CHOOSE_WORKQUEUE(pDPTPObject, dwCPU)		((dwCPU == -1) ? ChooseWorkQueue(pDPTPObject) : WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU))
#endif // ! DPNBUILD_ONLYONEPROCESSOR



//=============================================================================
// Local function prototypes
//=============================================================================
#ifndef DPNBUILD_ONLYONEPROCESSOR
DPTPWORKQUEUE * ChooseWorkQueue(DPTHREADPOOLOBJECT * const pDPTPObject);
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#ifndef DPNBUILD_ONLYONETHREAD
HRESULT SetTotalNumberOfThreads(DPTHREADPOOLOBJECT * const pDPTPObject,
								const DWORD dwNumThreads);
#endif // ! DPNBUILD_ONLYONETHREAD





#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_LIBINTERFACE)))


#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_Initialize"
//=============================================================================
// DPTP_Initialize
//-----------------------------------------------------------------------------
//
// Description:	   Initializes the thread pool interface for the process.  Only
//				one thread pool object per process is used.  If another
//				IDirectPlay8ThreadPool interface was created and initialized,
//				this interface will return DPNERR_ALREADYINITIALIZED.
//
//				   The interface cannot be initialized if a DirectPlay object
//				has already created threads.  DPNERR_NOTALLOWED will be
//				returned in that case.
//
// Arguments:
//	xxx pInterface				- Pointer to interface.
//	PVOID pvUserContext			- User context for all message callbacks.
//	PFNDPNMESSAGEHANDLER pfn	- Pointer to function called to handle
//									thread pool messages.
//	DWORD dwFlags				- Flags to use when initializing.
//
// Returns: HRESULT
//	DPN_OK						- Initializing was successful.
//	DPNERR_ALREADYINITIALIZED	- The interface has already been initialized.
//	DPNERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNERR_NOTALLOWED			- Threads have already been started.
//=============================================================================
STDMETHODIMP DPTP_Initialize(IDirectPlay8ThreadPool * pInterface,
							PVOID const pvUserContext,
							const PFNDPNMESSAGEHANDLER pfn,
							const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
#ifndef DPNBUILD_ONLYONETHREAD
	DWORD					dwTemp;
	DPTPWORKQUEUE *			pWorkQueue;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, 0x%p, 0x%x)",
		pInterface, pvUserContext, pfn, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);
		
#ifndef	DPNBUILD_NOPARAMVAL
	//if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_PARAMVALIDATION)
	{
		//
		// Validate parameters.
		//
		hr = DPTPValidateInitialize(pInterface, pvUserContext, pfn, dwFlags);
		if (hr != DPN_OK)
		{
			DPF_RETURN(hr);
		}
	}
#endif // ! DPNBUILD_NOPARAMVAL


	//
	// Lock the object to prevent multiple threads from trying to change the
	// flags or thread count simultaneously.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);

	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED)
	{
		DPFX(DPFPREP, 0, "Thread pool object already initialized!");
		hr = DPNERR_ALREADYINITIALIZED;
		goto Failure;
	}

#ifndef DPNBUILD_ONLYONETHREAD
	DNASSERT(pDPTPObject->dwTotalUserThreadCount == -1);

	//
	// If a Work interface has already spun up some threads, we must fail.
	//
	if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
	{
		DPFX(DPFPREP, 0, "Threads already exist, can't initialize!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}
#ifdef DPNBUILD_MANDATORYTHREADS
	if (pDPTPObject->dwMandatoryThreadCount > 0)
	{
		DPFX(DPFPREP, 0, "Mandatory threads already exist, can't initialize!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}
#endif // DPNBUILD_MANDATORYTHREADS

	
	//
	// Update all the work queues with the new message handler and context.
	//
	for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
	{
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
		DNASSERT(pWorkQueue->pfnMsgHandler == NULL);
		pWorkQueue->pfnMsgHandler			= pfn;
		pWorkQueue->pvMsgHandlerContext		= pvUserContext;
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	//
	// Mark the user's interface as ready.
	//
	pDPTPObject->dwFlags |= DPTPOBJECTFLAG_USER_INITIALIZED;

#ifndef	DPNBUILD_NOPARAMVAL
	//
	// If user doesn't want validation, turn it off.
	//
	if (dwFlags & DPNINITIALIZE_DISABLEPARAMVAL)
	{
		pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_USER_PARAMVALIDATION;
	}
#endif // ! DPNBUILD_NOPARAMVAL

	DNLeaveCriticalSection(&pDPTPObject->csLock);

	hr = DPN_OK;


Exit:

	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	DNLeaveCriticalSection(&pDPTPObject->csLock);

	goto Exit;
} // DPTP_Initialize





#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_Close"
//=============================================================================
// DPTP_Close
//-----------------------------------------------------------------------------
//
// Description:	   Closes the thread pool interface.  Any threads that exist
//				will call the message handler with DPN_MSGID_DESTROY_THREAD
//				before this method returns.
//
//				   This method cannot be called while a call to DoWork has not
//				returned, or from a thread pool thread.  DPNERR_NOTALLOWED is
//				returned in these cases.
//
// Arguments:
//	xxx pInterface	- Pointer to interface.
//	DWORD dwFlags	- Flags to use when closing.
//
// Returns: HRESULT
//	DPN_OK					- Closing was successful.
//	DPNERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNERR_NOTALLOWED		- A thread is in a call to DoWork or this is a
//								thread pool thread.
//	DPNERR_UNINITIALIZED	- The interface has not yet been initialized.
//=============================================================================
STDMETHODIMP DPTP_Close(IDirectPlay8ThreadPool * pInterface,
						const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
#ifndef DPNBUILD_ONLYONETHREAD
	DPTPWORKERTHREAD *		pWorkerThread;
	DWORD					dwTemp;
	DPTPWORKQUEUE *			pWorkQueue;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%x)", pInterface, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);
	
#ifndef	DPNBUILD_NOPARAMVAL
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_PARAMVALIDATION)
	{
		//
		// Validate parameters.
		//
		hr = DPTPValidateClose(pInterface, dwFlags);
		if (hr != DPN_OK)
		{
			DPF_RETURN(hr);
		}
	}
#endif // ! DPNBUILD_NOPARAMVAL


	//
	// Lock the object to prevent multiple threads from trying to change the
	// flags or thread count simultaneously.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);

	if (! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Thread pool object not initialized!");
		hr = DPNERR_UNINITIALIZED;
		goto Failure;
	}

	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)
	{
		DPFX(DPFPREP, 0, "Another thread is in a call to DoWork!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}

#ifndef DPNBUILD_ONLYONETHREAD
	//
	// If this is a thread pool thread, fail.
	//
	pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
	if (pWorkerThread != NULL)
	{
		DPFX(DPFPREP, 0, "Cannot call Close from a thread pool thread!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}

	//
	// If a thread is currently changing the thread count (or trying
	// to but we got the lock first), bail.
	//
	if ((pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING) ||
		(pDPTPObject->lNumThreadCountChangeWaiters > 0))
	{
		DPFX(DPFPREP, 0, "Cannot call Close with other threads still using other methods!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}

#ifdef DPNBUILD_MANDATORYTHREADS
	//
	// If there are mandatory threads still running, we can't close yet.
	// There is no way to have them issue DESTROY_THREAD callbacks.
	//
	if (pDPTPObject->dwMandatoryThreadCount > 0)
	{
		DPFX(DPFPREP, 0, "Mandatory threads still exist, can't close!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}
#endif // DPNBUILD_MANDATORYTHREADS


	//
	// Clear the message handler information.
	//
	for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
	{
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
		DNASSERT(pWorkQueue->pfnMsgHandler != NULL);
		pWorkQueue->pfnMsgHandler			= NULL;
		pWorkQueue->pvMsgHandlerContext		= NULL;
	}


	//
	// If there were any threads, we must shut them down so they stop using the
	// user's callback.
	//
#pragma TODO(vanceo, "Is there no efficient way to ensure all threads process a 'RemoveCallback' job?")
	if (((pDPTPObject->dwTotalUserThreadCount != -1) && (pDPTPObject->dwTotalUserThreadCount != 0)) ||
		(pDPTPObject->dwTotalDesiredWorkThreadCount != -1))
	{
		hr = SetTotalNumberOfThreads(pDPTPObject, 0);
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't shut down existing threads!");
			goto Failure;
		}

		//
		// If some Work interface wanted threads, we need to spin them back up
		// because we don't know if the user is closing his/her interface
		// before all work is truly done.
		//
		if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
		{
			hr = SetTotalNumberOfThreads(pDPTPObject, pDPTPObject->dwTotalDesiredWorkThreadCount);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't restart Work interface requested number of threads!");
				goto Failure;
			}
		}
	}

	//
	// In case the user had set the thread count, restore it to the "unknown"
	// value.
	//
	pDPTPObject->dwTotalUserThreadCount = -1;
#endif // ! DPNBUILD_ONLYONETHREAD

	//
	// Mark the user's interface as no longer available.
	//
	pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_USER_INITIALIZED;

#ifndef DPNBUILD_NOPARAMVAL
	//
	// Re-enable validation, in case it was off.
	//
	pDPTPObject->dwFlags |= DPTPOBJECTFLAG_USER_PARAMVALIDATION;
#endif // ! DPNBUILD_NOPARAMVAL

	DNLeaveCriticalSection(&pDPTPObject->csLock);

	hr = DPN_OK;


Exit:

	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	DNLeaveCriticalSection(&pDPTPObject->csLock);

	goto Exit;
} // DPTP_Close





#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_GetThreadCount"
//=============================================================================
// DPTP_GetThreadCount
//-----------------------------------------------------------------------------
//
// Description:	   Retrieves the current number of threads for the given
//				processor, of if dwProcessorNum is -1, the total number of
//				threads for all processors.
//
// Arguments:
//	xxx pInterface			- Pointer to interface.
//	DWORD dwProcessorNum	- Processor whose thread count should be retrieved,
//								or -1 to retrieve the total number of threads.
//	DWORD * pdwNumThreads	- Pointer to DWORD in which to store the current
//								number of threads.
//	DWORD dwFlags			- Flags to use when retrieving thread count.
//
// Returns: HRESULT
//	DPN_OK					- Retrieving the number of threads was successful.
//	DPNERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNERR_UNINITIALIZED	- The interface has not yet been initialized.
//=============================================================================
STDMETHODIMP DPTP_GetThreadCount(IDirectPlay8ThreadPool * pInterface,
								const DWORD dwProcessorNum,
								DWORD * const pdwNumThreads,
								const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, 0x%p, 0x%x)",
		pInterface, dwProcessorNum, pdwNumThreads, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);
	
#ifndef	DPNBUILD_NOPARAMVAL
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_PARAMVALIDATION)
	{
		//
		// Validate parameters.
		//
		hr = DPTPValidateGetThreadCount(pInterface,
										dwProcessorNum,
										pdwNumThreads,
										dwFlags);
		if (hr != DPN_OK)
		{
			DPF_RETURN(hr);
		}
	}
#endif // ! DPNBUILD_NOPARAMVAL

	//
	// Check object state (note: done without object lock).
	//
	if (! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Thread pool object not initialized!");
		DPF_RETURN(DPNERR_UNINITIALIZED);
	}


#ifdef DPNBUILD_ONLYONETHREAD
	*pdwNumThreads = 0;
#else // ! DPNBUILD_ONLYONETHREAD
	if (dwProcessorNum == -1)
	{
		if (pDPTPObject->dwTotalUserThreadCount != -1)
		{
			*pdwNumThreads = pDPTPObject->dwTotalUserThreadCount;
		}
		else if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
		{
			*pdwNumThreads = pDPTPObject->dwTotalDesiredWorkThreadCount;
		}
		else
		{
			*pdwNumThreads = 0;
		}
	}
	else
	{
		*pdwNumThreads = (WORKQUEUE_FOR_CPU(pDPTPObject, dwProcessorNum))->dwNumRunningThreads;
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	DPFX(DPFPREP, 7, "Number of threads = %u.", (*pdwNumThreads));
	hr = DPN_OK;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTP_GetThreadCount




#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_SetThreadCount"
//=============================================================================
// DPTP_SetThreadCount
//-----------------------------------------------------------------------------
//
// Description:	   Alters the current number of threads for the given processor
//				number, or if dwProcessorNum is -1, the total number of threads
//				for all processors.
//
//				   If the new thread count is higher than the previous count,
//				the correct number of threads will be started (generating
//				DPN_MSGID_CREATE_THREAD messages) before this method returns.
//
//				   If the new thread count is lower than the previous count,
//				the correct number of threads will be shutdown (generating
//				DPN_MSGID_DESTROY_THREAD messages) before this method returns.
//
//				   This method cannot be used while another thread is
//				performing work.  If a thread is in a call to DoWork, then
//				DPNERR_NOTALLOWED is returned and the thread count remains
//				unchanged.
//
//				   Thread pool threads cannot reduce the thread count.  If this
//				thread is owned by the thread pool and dwNumThreads is less
//				than the current number of threads for the processor,
//				DPNERR_NOTALLOWED is returned and the thread count remains
//				unchanged.
//
// Arguments:
//	xxx pInterface			- Pointer to interface.
//	DWORD dwProcessorNum	- Processor number, or -1 for all processors.
//	DWORD dwNumThreads		- Desired number of threads per processor.
//	DWORD dwFlags			- Flags to use when setting the thread count.
//
// Returns: HRESULT
//	DPN_OK					- Setting the number of threads was successful.
//	DPNERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNERR_NOTALLOWED		- A thread is currently calling DoWork, or this
//								thread pool thread is trying to reduce the
//								thread count.
//	DPNERR_UNINITIALIZED	- The interface has not yet been initialized.
//=============================================================================
STDMETHODIMP DPTP_SetThreadCount(IDirectPlay8ThreadPool * pInterface,
								const DWORD dwProcessorNum,
								const DWORD dwNumThreads,
								const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
#ifndef DPNBUILD_ONLYONETHREAD
	BOOL					fSetThreadCountChanging = FALSE;
	DPTPWORKQUEUE *			pWorkQueue;
	DPTPWORKERTHREAD *		pWorkerThread;
	DWORD					dwDelta;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, %u, 0x%x)",
		pInterface, dwProcessorNum, dwNumThreads, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);
		
#ifndef	DPNBUILD_NOPARAMVAL
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_PARAMVALIDATION)
	{
		//
		// Validate parameters.
		//
		hr = DPTPValidateSetThreadCount(pInterface,
										dwProcessorNum,
										dwNumThreads,
										dwFlags);
		if (hr != DPN_OK)
		{
			DPF_RETURN(hr);
		}
	}
#endif // ! DPNBUILD_NOPARAMVAL

	//
	// Check object state (note: done without object lock).
	//
	if (! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Thread pool object not initialized!");
		DPF_RETURN(DPNERR_UNINITIALIZED);
	}


	//
	// Lock the object to prevent multiple threads from trying to change the
	// thread count simultaneously.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);

	//
	// Make sure no one is trying to perform work at the moment.
	//
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)
	{
		DPFX(DPFPREP, 0, "Cannot change thread count while a thread is in a call to DoWork!");
		hr = DPNERR_NOTALLOWED;
		goto Exit;
	}

#ifdef DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 0, "Not changing thread count to %u!", dwNumThreads);
	hr = DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONETHREAD
	//
	// See if another thread is already changing the thread count.  If so, wait
	// until they're done, unless this is a thread pool thread in the middle of
	// a CREATE_THREAD or DESTROY_THREAD indication.
	//
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING)
	{
		pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
		if ((pWorkerThread != NULL) && (! pWorkerThread->fThreadIndicated))
		{
			//
			// This is a thread pool thread that isn't marked as indicated to
			// the user, i.e. it's before CREATE_THREAD returned or it's after
			// the DESTROY_THREAD has started to be indicated.
			//
			DPFX(DPFPREP, 0, "Cannot change thread count from a thread pool thread in CREATE_THREAD or DESTROY_THREAD callback!");
			hr = DPNERR_NOTALLOWED;
			goto Exit;
		}

		//
		// Otherwise, wait for the previous thread to finish.
		//
		do
		{
			DNASSERT(pDPTPObject->lNumThreadCountChangeWaiters >= 0);
			pDPTPObject->lNumThreadCountChangeWaiters++;
			DPFX(DPFPREP, 1, "Waiting for thread count change to complete (waiters = %i).",
				pDPTPObject->lNumThreadCountChangeWaiters);

			//
			// Drop the lock while we wait.
			//
			DNLeaveCriticalSection(&pDPTPObject->csLock);

			DNWaitForSingleObject(pDPTPObject->hThreadCountChangeComplete, INFINITE);

			//
			// Retake the lock and see if we can move on.
			//
			DNEnterCriticalSection(&pDPTPObject->csLock);
			DNASSERT(pDPTPObject->lNumThreadCountChangeWaiters > 0);
			pDPTPObject->lNumThreadCountChangeWaiters--;
		}
		while (pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING);

		//
		// It's safe to proceed now.
		//
		DPFX(DPFPREP, 1, "Thread count change completed, continuing.");

		//
		// The user would need to be doing something spectacularly silly if
		// we're no longer initialized, or another thread is now calling
		// DoWork.  We'll crash in retail, assert in debug.
		//
		DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED);
		DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK);
	}
#ifdef DPNBUILD_MANDATORYTHREADS
	//
	// Make sure we're not stopping all threads if there are any mandatory
	// threads.
	//
	if ((dwNumThreads == 0) && (pDPTPObject->dwMandatoryThreadCount > 0))
	{
		DPFX(DPFPREP, 0, "Cannot set number of threads to 0 because there is already at least one mandatory thread!");
		hr = DPNERR_NOTALLOWED;
		goto Exit;
	}
#endif // DPNBUILD_MANDATORYTHREADS

	//
	// If the thread count really did change, start or stop the right number of
	// threads for all processors or the specific processor.
	//
	if (dwProcessorNum == -1)
	{
		if (dwNumThreads != pDPTPObject->dwTotalUserThreadCount)
		{
			if (dwNumThreads != pDPTPObject->dwTotalDesiredWorkThreadCount)
			{
				if ((dwNumThreads != 0) ||
					(pDPTPObject->dwTotalUserThreadCount != -1) ||
					(pDPTPObject->dwTotalDesiredWorkThreadCount != -1))
				{
					//
					// Prevent the user from trying to reduce the total thread
					// count from a worker thread.
					//
					pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
					if (pWorkerThread != NULL)
					{
						DWORD	dwNumThreadsPerProcessor;
						DWORD	dwExtraThreads;
						DWORD	dwTemp;


						//
						// Make sure the thread count for any individual
						// processor isn't shrinking.
						//
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
						dwNumThreadsPerProcessor = dwNumThreads;
						dwExtraThreads = 0;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
						dwNumThreadsPerProcessor = dwNumThreads / NUM_CPUS(pDPTPObject);
						dwExtraThreads = dwNumThreads % NUM_CPUS(pDPTPObject);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
						for (dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
						{
							dwDelta = dwNumThreadsPerProcessor - (WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp))->dwNumRunningThreads;
							if (dwTemp < dwExtraThreads)
							{
								dwDelta++;
							}
							if ((int) dwDelta < 0)
							{
								DPFX(DPFPREP, 0, "Cannot reduce thread count from a thread pool thread (processor %u)!",
									dwTemp);
								hr = DPNERR_NOTALLOWED;
								goto Exit;
							}
						}
					}

					//
					// Drop the lock while changing the thread count to prevent
					// deadlocks.  Set the flag to alert other threads while
					// we're doing this.
					//
					DNASSERT(! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING));
					pDPTPObject->dwFlags |= DPTPOBJECTFLAG_THREADCOUNTCHANGING;
					fSetThreadCountChanging = TRUE;
					DNLeaveCriticalSection(&pDPTPObject->csLock);

					//
					// Actually set the total number of threads.
					//
					hr = SetTotalNumberOfThreads(pDPTPObject, dwNumThreads);
					
					//
					// Retake the lock.  We'll clear the alert flag and release
					// any waiting threads at the bottom.
					//
					DNEnterCriticalSection(&pDPTPObject->csLock);

					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't set total number of threads!");
						goto Exit;
					}

					pDPTPObject->dwTotalUserThreadCount = dwNumThreads;
				}
				else
				{
					DPFX(DPFPREP, 1, "No threads running, no change necessary.");
					pDPTPObject->dwTotalUserThreadCount = 0;
				}
			}
			else
			{
				DPFX(DPFPREP, 1, "Correct total number of threads (%u) already running.", dwNumThreads);
				pDPTPObject->dwTotalUserThreadCount = dwNumThreads;
			}
		}
		else
		{
			DPFX(DPFPREP, 1, "Total thread count unchanged (%u).", dwNumThreads);
		}
	}
	else
	{
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwProcessorNum);
		dwDelta = dwNumThreads - pWorkQueue->dwNumRunningThreads;
		if (dwDelta == 0)
		{
			if (pDPTPObject->dwTotalUserThreadCount == -1)
			{
				if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
				{
					DPFX(DPFPREP, 1, "Correct number of threads (%u) already running on processor.", dwNumThreads);
					pDPTPObject->dwTotalUserThreadCount = pDPTPObject->dwTotalDesiredWorkThreadCount;
				}
				else
				{
					DNASSERT(dwNumThreads == 0);
					DPFX(DPFPREP, 1, "No threads are running on processor, no change necessary.");
					pDPTPObject->dwTotalUserThreadCount = 0;
				}
			}
			else
			{
				DPFX(DPFPREP, 1, "Correct number of threads (%u) already set for processor.", dwNumThreads);
			}
		}
		else
		{
			//
			// Drop the lock while changing the thread count to prevent
			// deadlocks.  Set the flag to alert other threads while we're
			// doing this.
			//
			DNASSERT(! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING));
			pDPTPObject->dwFlags |= DPTPOBJECTFLAG_THREADCOUNTCHANGING;
			fSetThreadCountChanging = TRUE;
			DNLeaveCriticalSection(&pDPTPObject->csLock);

			if ((int) dwDelta > 0)
			{
				//
				// We need to add threads.
				//
				hr = StartThreads(pWorkQueue, dwDelta);
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't start %u threads for processor!", dwDelta);

					//
					// Retake the lock before bailing.
					//
					DNEnterCriticalSection(&pDPTPObject->csLock);

					goto Exit;
				}
			}
			else
			{
				//
				// Prevent the user from trying to reduce the processor's
				// thread count from a worker thread (for any processor).
				//
				pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
				if (pWorkerThread != NULL)
				{
					DPFX(DPFPREP, 0, "Cannot reduce thread count from a thread pool thread!");

					//
					// Retake the lock before bailing.
					//
					DNEnterCriticalSection(&pDPTPObject->csLock);

					hr = DPNERR_NOTALLOWED;
					goto Exit;
				}

				//
				// We need to remove {absolute value of delta} threads.
				//
				hr = StopThreads(pWorkQueue, ((int) dwDelta * -1));
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't stop %u threads for processor!", ((int) dwDelta * -1));

					//
					// Retake the lock before bailing.
					//
					DNEnterCriticalSection(&pDPTPObject->csLock);

					goto Exit;
				}
			}
			DNASSERT(pWorkQueue->dwNumRunningThreads == dwNumThreads);

			//
			// Retake the lock.  We'll clear the alert flag and release any
			// waiting threads at the bottom.
			//
			DNEnterCriticalSection(&pDPTPObject->csLock);

			if (pDPTPObject->dwTotalUserThreadCount == -1)
			{
				pDPTPObject->dwTotalUserThreadCount = dwDelta;
				if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
				{
					pDPTPObject->dwTotalUserThreadCount += pDPTPObject->dwTotalDesiredWorkThreadCount;
				}
			}
			else
			{
				pDPTPObject->dwTotalUserThreadCount += dwDelta;
			}
			DNASSERT(pDPTPObject->dwTotalUserThreadCount != -1);
		}
	}

	hr = DPN_OK;
#endif // ! DPNBUILD_ONLYONETHREAD


Exit:
	//
	// If we start changing the thread count, clear the flag, and release any
	// threads waiting on us (they'll block until we drop the lock again
	// shortly).
	//
	if (fSetThreadCountChanging)
	{
		DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING);
		pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_THREADCOUNTCHANGING;
		fSetThreadCountChanging = FALSE;
		if (pDPTPObject->lNumThreadCountChangeWaiters > 0)
		{
			DPFX(DPFPREP, 1, "Releasing %i waiters.",
				pDPTPObject->lNumThreadCountChangeWaiters);

			DNReleaseSemaphore(pDPTPObject->hThreadCountChangeComplete,
								pDPTPObject->lNumThreadCountChangeWaiters,
								NULL);
		}
	}

	DNLeaveCriticalSection(&pDPTPObject->csLock);

	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTP_SetThreadCount

#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_LIBINTERFACE



#undef DPF_MODNAME
#define DPF_MODNAME "DPTP_DoWork"
//=============================================================================
// DPTP_DoWork
//-----------------------------------------------------------------------------
//
// Description:	   Performs any work that is currently scheduled.  This allows
//				DirectPlay to operate without any threads of its own.  It is
//				expected that this will be called frequently and at regular
//				intervals so that time critical operations can be performed
//				with reasonable accuracy.
//
//				   This method will return DPN_OK when no additional work is
//				immediately available.  If the allowed time slice is not
//				INFINITE, this method will return DPNSUCCESS_PENDING if the
//				time limit is exceeded but there is still work remaining.  If
//				the allowed time slice is 0, only the first work item (if any)
//				will be performed.  The allowed time slice must be less than
//				60,000 milliseconds (1 minute) if it is not INFINITE.
//
//				   This method cannot be called unless the thread count has
//				been set to 0.  It will return DPNERR_NOTREADY if there are
//				threads currently active.
//
//				   If an attempt is made to call this method by more than one
//				thread simultaneously, recursively, or within a DirectPlay
//				callback, DPNERR_NOTALLOWED is returned.
//
//				   
//
// Arguments:
//	xxx pInterface				- Pointer to interface.
//	DWORD dwAllowedTimeSlice	- The maximum number of milliseconds to perform
//									work, or INFINITE to allow all immediately
//									available items to be executed.
//	DWORD dwFlags				- Flags to use when performing work.
//
// Returns: HRESULT
//	DPN_OK					- Performing the work was successful.
//	DPNSUCCESS_PENDING		- No errors occurred, but there is work that could
//								not be accomplished due to the time limit.
//	DPNERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNERR_NOTALLOWED		- This method is already being called by some
//								thread. 
//	DPNERR_NOTREADY			- The thread count has not been set to 0.
//	DPNERR_UNINITIALIZED	- The interface has not yet been initialized.
//=============================================================================
#ifdef DPNBUILD_LIBINTERFACE
STDMETHODIMP DPTP_DoWork(const DWORD dwAllowedTimeSlice,
						const DWORD dwFlags)
#else // ! DPNBUILD_LIBINTERFACE
STDMETHODIMP DPTP_DoWork(IDirectPlay8ThreadPool * pInterface,
						const DWORD dwAllowedTimeSlice,
						const DWORD dwFlags)
#endif // ! DPNBUILD_LIBINTERFACE
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DWORD					dwMaxDoWorkTime;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPU;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	BOOL					fRemainingItems;


#ifdef DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 8, "Parameters: (%i, 0x%x)",
		dwAllowedTimeSlice, dwFlags);
#else // ! DPNBUILD_LIBINTERFACE
	DPFX(DPFPREP, 8, "Parameters: (0x%p, %i, 0x%x)",
		pInterface, dwAllowedTimeSlice, dwFlags);
#endif // ! DPNBUILD_LIBINTERFACE


#ifdef DPNBUILD_LIBINTERFACE
#ifdef DPNBUILD_MULTIPLETHREADPOOLS
#pragma error("Multiple thread pools support under DPNBUILD_LIBINTERFACE requires more work") 
#else // ! DPNBUILD_MULTIPLETHREADPOOLS
	pDPTPObject = g_pDPTPObject;
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS
#else // ! DPNBUILD_LIBINTERFACE
	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
#endif // ! DPNBUILD_LIBINTERFACE
	DNASSERT(pDPTPObject != NULL);
	
#ifndef	DPNBUILD_NOPARAMVAL
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_PARAMVALIDATION)
	{
		//
		// Validate parameters.
		//
#ifdef DPNBUILD_LIBINTERFACE
		hr = DPTPValidateDoWork(dwAllowedTimeSlice, dwFlags);
#else // ! DPNBUILD_LIBINTERFACE
		hr = DPTPValidateDoWork(pInterface, dwAllowedTimeSlice, dwFlags);
#endif // ! DPNBUILD_LIBINTERFACE
		if (hr != DPN_OK)
		{
			DPF_RETURN(hr);
		}
	}
#endif // ! DPNBUILD_NOPARAMVAL

#ifndef DPNBUILD_LIBINTERFACE
	//
	// Check object state (note: done without object lock).
	//
	if (! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Thread pool object not initialized!");
		DPF_RETURN(DPNERR_UNINITIALIZED);
	}
#endif // ! DPNBUILD_LIBINTERFACE


	//
	// Save the time limit we need to use.
	//
	if (dwAllowedTimeSlice != INFINITE)
	{
		dwMaxDoWorkTime = GETTIMESTAMP() + dwAllowedTimeSlice;

		//
		// Make sure the timer never lands exactly on INFINITE, that value has
		// special meaning.
		//
		if (dwMaxDoWorkTime == INFINITE)
		{
			dwMaxDoWorkTime--;
		}
	}
	else
	{
		dwMaxDoWorkTime = INFINITE;
	}

	DNEnterCriticalSection(&pDPTPObject->csLock);

#ifndef DPNBUILD_ONLYONETHREAD
	if (pDPTPObject->dwTotalUserThreadCount != 0)
	{
		DPFX(DPFPREP, 0, "Thread count must be set to 0 prior to using DoWork!");
		hr = DPNERR_NOTREADY;
		goto Failure;
	}
#endif // ! DPNBUILD_ONLYONETHREAD


	//
	// Make sure only one person is trying to call us at a time.
	//
	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)
	{
		DPFX(DPFPREP, 0, "DoWork cannot be performed recursively, or by multiple threads simultaneously!");
		hr = DPNERR_NOTALLOWED;
		goto Failure;
	}

	pDPTPObject->dwFlags |= DPTPOBJECTFLAG_USER_DOINGWORK;

#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
	pDPTPObject->dwCurrentDoWorkThreadID = GetCurrentThreadId();
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL

	DNLeaveCriticalSection(&pDPTPObject->csLock);


	//
	// Set the recursion depth.
	//
#ifdef DPNBUILD_ONLYONETHREAD
	DNASSERT(pDPTPObject->dwWorkRecursionCount == 0);
	pDPTPObject->dwWorkRecursionCount = 1;
#else // ! DPNBUILD_ONLYONETHREAD
	DNASSERT((DWORD) ((DWORD_PTR) (TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex))) == 0);
	TlsSetValue(pDPTPObject->dwWorkRecursionCountTlsIndex,
				(PVOID) ((DWORD_PTR) 1));
#endif // ! DPNBUILD_ONLYONETHREAD


	//
	// Actually perform the work.
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	DoWork(&pDPTPObject->WorkQueue, dwMaxDoWorkTime);
	fRemainingItems = ! DNIsNBQueueEmpty(pDPTPObject->WorkQueue.pvNBQueueWorkItems);
#else // ! DPNBUILD_ONLYONEPROCESSOR
	//
	// Since we're in DoWork mode, technically only one CPU work queue needs to
	// be used, but it's possible that work got scheduled to one of the other
	// CPUs.  Rather than trying to figure out the logic of when and how to
	// move everything from that queue to the first CPU's queue, we will just
	// process all of them every time.
	//
	fRemainingItems = FALSE;
	for(dwCPU = 0; dwCPU < NUM_CPUS(pDPTPObject); dwCPU++)
	{
		DoWork(WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU), dwMaxDoWorkTime);
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
#pragma BUGBUG(vanceo, "Find equivalent for I/O completion ports")
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
		fRemainingItems |= ! DNIsNBQueueEmpty((WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU))->pvNBQueueWorkItems);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

		//
		// Even if the time has expired on this CPU, we will continue to the
		// rest.  That way, we execute at least one item for every CPU queue
		// each time through (to prevent total starvation).  This may make us
		// go even farther over the time limit, but hopefully not by much.  Of
		// course, it's a bit silly to be using DoWork mode on a multiprocessor
		// machine in the first place.
		//
	}
#endif // ! DPNBUILD_ONLYONEPROCESSOR


	//
	// Decrement the recursion count and allow other callers again.
	//

#ifdef DPNBUILD_ONLYONETHREAD
	DNASSERT(pDPTPObject->dwWorkRecursionCount == 1);
	pDPTPObject->dwWorkRecursionCount = 0;
#else // ! DPNBUILD_ONLYONETHREAD
	DNASSERT((DWORD) ((DWORD_PTR) (TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex))) == 1);
	TlsSetValue(pDPTPObject->dwWorkRecursionCountTlsIndex,
				(PVOID) ((DWORD_PTR) 0));
#endif // ! DPNBUILD_ONLYONETHREAD

	DNEnterCriticalSection(&pDPTPObject->csLock);
	DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK);
	pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_USER_DOINGWORK;
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
	DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == GetCurrentThreadId());
	pDPTPObject->dwCurrentDoWorkThreadID = 0;
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL
	DNLeaveCriticalSection(&pDPTPObject->csLock);


	//
	// Return the appropriate error code.
	//
	if (fRemainingItems)
	{
		DPFX(DPFPREP, 7, "Some items remain unprocessed.");
		hr = DPNSUCCESS_PENDING;
	}
	else
	{
		hr = DPN_OK;
	}


Exit:

	DPFX(DPFPREP, 8, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	DNLeaveCriticalSection(&pDPTPObject->csLock);

	goto Exit;
} // DPTP_DoWork



#pragma TODO(vanceo, "Make validation for private interface a build flag (off by default)")


#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_QueueWorkItem"
//=============================================================================
// DPTPW_QueueWorkItem
//-----------------------------------------------------------------------------
//
// Description:	   Queues a new work item for processing.
//
// Arguments:
//	xxx pInterface						- Pointer to interface.
//	DWORD dwCPU							- CPU queue on which item is to be
//											placed, or -1 for any.
//	PFNDPTNWORKCALLBACK pfnWorkCallback	- Callback to execute as soon as
//											possible.
//	PVOID pvCallbackContext				- User specified context to pass to
//											callback.
//	DWORD dwFlags						- Flags to use when queueing.
//
// Returns: HRESULT
//	DPN_OK				- Queuing the work item was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to queue the work item.
//=============================================================================
STDMETHODIMP DPTPW_QueueWorkItem(IDirectPlay8ThreadPoolWork * pInterface,
								const DWORD dwCPU,
								const PFNDPTNWORKCALLBACK pfnWorkCallback,
								PVOID const pvCallbackContext,
								const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DPTPWORKQUEUE *			pWorkQueue;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, 0x%p, 0x%p, 0x%x)",
		pInterface, dwCPU, pfnWorkCallback, pvCallbackContext, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Figure out which CPU queue to use.
	//
	DNASSERT((dwCPU == -1) || (dwCPU < NUM_CPUS(pDPTPObject)));
	pWorkQueue = GET_OR_CHOOSE_WORKQUEUE(pDPTPObject, dwCPU);

	//
	// Call the implementation function.
	//
	if (! QueueWorkItem(pWorkQueue, pfnWorkCallback, pvCallbackContext))
	{
		hr = DPNERR_OUTOFMEMORY;
	}
	else
	{
		hr = DPN_OK;
	}


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTPW_QueueWorkItem




#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_ScheduleTimer"
//=============================================================================
// DPTPW_ScheduleTimer
//-----------------------------------------------------------------------------
//
// Description:	   Schedules a new work item for some point in the future.
//
// Arguments:
//	xxx pInterface						- Pointer to interface.
//	DWORD dwCPU							- CPU on which item is to be scheduled,
//											or -1 for any.
//	DWORD dwDelay						- How much time should elapsed before
//											executing the work item, in ms.
//	PFNDPTNWORKCALLBACK pfnWorkCallback	- Callback to execute when timer
//											elapses.
//	PVOID pvCallbackContext				- User specified context to pass to
//											callback.
//	void ** ppvTimerData				- Place to store pointer to data for
//											timer so that it can be cancelled.
//	UINT * puiTimerUnique				- Place to store uniqueness value for
//											timer so that it can be cancelled.
//
// Returns: HRESULT
//	DPN_OK				- Scheduling the timer was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to schedule the timer.
//=============================================================================
STDMETHODIMP DPTPW_ScheduleTimer(IDirectPlay8ThreadPoolWork * pInterface,
								const DWORD dwCPU,
								const DWORD dwDelay,
								const PFNDPTNWORKCALLBACK pfnWorkCallback,
								PVOID const pvCallbackContext,
								void ** const ppvTimerData,
								UINT * const puiTimerUnique,
								const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DPTPWORKQUEUE *			pWorkQueue;


	DPFX(DPFPREP, 8, "Parameters: (0x%p, %i, %u, 0x%p, 0x%p, 0x%p, 0x%p, 0x%x)",
		pInterface, dwCPU, dwDelay, pfnWorkCallback, pvCallbackContext, ppvTimerData, puiTimerUnique, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Figure out which CPU queue to use.
	//
	DNASSERT((dwCPU == -1) || (dwCPU < NUM_CPUS(pDPTPObject)));
	pWorkQueue = GET_OR_CHOOSE_WORKQUEUE(pDPTPObject, dwCPU);

	//
	// Call the implementation function.
	//
	if (! ScheduleTimer(pWorkQueue,
						dwDelay,
						pfnWorkCallback,
						pvCallbackContext,
						ppvTimerData,
						puiTimerUnique))
	{
		hr = DPNERR_OUTOFMEMORY;
	}
	else
	{
		hr = DPN_OK;
	}


	DPFX(DPFPREP, 8, "Returning: [0x%lx]", hr);

	return hr;
} // DPTPW_ScheduleTimer





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_StartTrackingFileIo"
//=============================================================================
// DPTPW_StartTrackingFileIo
//-----------------------------------------------------------------------------
//
// Description:	   Starts tracking overlapped I/O for a given file handle on
//				the specified CPU (or all CPUs).  The handle is not duplicated
//				and it should remain valid until
//				IDirectPlay8ThreadPoolWork::StopTrackingFileIo is called.
//
//				   This method is not available on Windows CE because it does
//				not support overlapped I/O.
//
// Arguments:
//	xxx pInterface	- Pointer to interface.
//	DWORD dwCPU		- CPU with which I/O is to be tracked, or -1 for all.
//	HANDLE hFile	- Handle of file to track.
//	DWORD dwFlags	- Flags to use when starting to track file I/O.
//
// Returns: HRESULT
//	DPN_OK						- Starting tracking for the file was successful.
//	DPNERR_ALREADYREGISTERED	- The specified file handle is already being
//									tracked.
//	DPNERR_OUTOFMEMORY			- Not enough memory to track the file.
//=============================================================================
STDMETHODIMP DPTPW_StartTrackingFileIo(IDirectPlay8ThreadPoolWork * pInterface,
										const DWORD dwCPU,
										const HANDLE hFile,
										const DWORD dwFlags)
{
#ifdef WINCE
	DPFX(DPFPREP, 0, "Overlapped I/O not supported on Windows CE!", 0);
	return DPNERR_UNSUPPORTED;
#else // ! WINCE
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DWORD					dwTemp;
	DPTPWORKQUEUE *			pWorkQueue;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, 0x%p, 0x%x)",
		pInterface, dwCPU, hFile, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Call the implementation function for all relevant CPUs.
	//
	if (dwCPU == -1)
	{
		for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
		{
			pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
			hr = StartTrackingFileIo(pWorkQueue, hFile);
			if (hr != DPN_OK) 
			{
				//
				// Stop tracking the file on all CPUs where we had already
				// succeeded.  Ignore any error the function might return.
				//
				while (dwTemp > 0)
				{
					dwTemp--;
					pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
					StopTrackingFileIo(pWorkQueue, hFile);
				}
				break;
			}
		}
	}
	else
	{
		DNASSERT(dwCPU < NUM_CPUS(pDPTPObject));
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU);
		hr = StartTrackingFileIo(pWorkQueue, hFile);
	}


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#endif // ! WINCE
} // DPTPW_StartTrackingFileIo





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_StopTrackingFileIo"
//=============================================================================
// DPTPW_StopTrackingFileIo
//-----------------------------------------------------------------------------
//
// Description:	   Stops tracking overlapped I/O for a given file handle on
//				the specified CPU (or all CPUs).
//
//				   This method is not available on Windows CE because it does
//				not support overlapped I/O.
//
// Arguments:
//	xxx pInterface	- Pointer to interface.
//	DWORD dwCPU		- CPU with which I/O was tracked, or -1 for all.
//	HANDLE hFile	- Handle of file to stop tracking.
//	DWORD dwFlags	- Flags to use when no turning off file I/O tracking.
//
// Returns: HRESULT
//	DPN_OK					- Stopping tracking for the file was successful.
//	DPNERR_INVALIDHANDLE	- File handle was not being tracked.
//=============================================================================
STDMETHODIMP DPTPW_StopTrackingFileIo(IDirectPlay8ThreadPoolWork * pInterface,
										const DWORD dwCPU,
										const HANDLE hFile,
										const DWORD dwFlags)
{
#ifdef WINCE
	DPFX(DPFPREP, 0, "Overlapped I/O not supported on Windows CE!", 0);
	return DPNERR_UNSUPPORTED;
#else // ! WINCE
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DWORD					dwTemp;
	DPTPWORKQUEUE *			pWorkQueue;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, 0x%p, 0x%x)",
		pInterface, dwCPU, hFile, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Call the implementation function for all relevant CPUs.
	//
	if (dwCPU == -1)
	{
		for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
		{
			pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
			hr = StopTrackingFileIo(pWorkQueue, hFile);
			if (hr != DPN_OK)
			{
				break;
			}
		}
	}
	else
	{
		DNASSERT(dwCPU < NUM_CPUS(pDPTPObject));
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU);
		hr = StopTrackingFileIo(pWorkQueue, hFile);
	}


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#endif // ! WINCE
} // DPTPW_StopTrackingFileIo





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_CreateOverlapped"
//=============================================================================
// DPTPW_CreateOverlapped
//-----------------------------------------------------------------------------
//
// Description:	   Creates an overlapped structure for an asynchronous I/O
//				operation so it can be monitored for completion.
//
//				   If this implementation is using I/O completion ports, the
//				caller should be prepared for the work callback function to be
//				invoked as soon as he or she calls the intended asynchronous
//				file function.  Otherwise, he or she must call
//				IDirectPlay8ThreadPoolWork::SubmitIoOperation.
//
//				   If the intended asynchronous file function fails immediately
//				and the overlapped structure will never be completed
//				asynchronously, the caller must return the unused overlapped
//				structure with IDirectPlay8ThreadPoolWork::ReleaseOverlapped.
//
//				   This method is not available on Windows CE because it does
//				not support overlapped I/O.
//
// Arguments:
//	xxx pInterface						- Pointer to interface.
//	DWORD dwCPU							- CPU with which I/O is to be
//											monitored, or -1 for any.
//	PFNDPTNWORKCALLBACK pfnWorkCallback	- Callback to execute when operation
//											completes.
//	PVOID pvCallbackContext				- User specified context to pass to
//											callback.
//	OVERLAPPED * pOverlapped			- Pointer to overlapped structure used
//											by OS.
//	DWORD dwFlags						- Flags to use when submitting I/O.
//
// Returns: HRESULT
//	DPN_OK				- Creating the structure was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to create the structure.
//=============================================================================
STDMETHODIMP DPTPW_CreateOverlapped(IDirectPlay8ThreadPoolWork * pInterface,
									const DWORD dwCPU,
									const PFNDPTNWORKCALLBACK pfnWorkCallback,
									PVOID const pvCallbackContext,
									OVERLAPPED ** const ppOverlapped,
									const DWORD dwFlags)
{
#ifdef WINCE
	DPFX(DPFPREP, 0, "Overlapped I/O not supported on Windows CE!", 0);
	return DPNERR_UNSUPPORTED;
#else // ! WINCE
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DPTPWORKQUEUE *			pWorkQueue;
	CWorkItem *				pWorkItem;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, 0x%p, 0x%p, 0x%p, 0x%x)",
		pInterface, dwCPU, pfnWorkCallback, pvCallbackContext, ppOverlapped, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Figure out which CPU queue to use.
	//
	DNASSERT((dwCPU == -1) || (dwCPU < NUM_CPUS(pDPTPObject)));
	pWorkQueue = GET_OR_CHOOSE_WORKQUEUE(pDPTPObject, dwCPU);


	//
	// Call the implementation function.
	//
	pWorkItem = CreateOverlappedIoWorkItem(pWorkQueue,
											pfnWorkCallback,
											pvCallbackContext);
	if (pWorkItem == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
	}
	else
	{
		DNASSERT(ppOverlapped != NULL);
		*ppOverlapped = &pWorkItem->m_Overlapped;
		hr = DPN_OK;
	}


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#endif // ! WINCE
} // DPTPW_CreateOverlapped





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_SubmitIoOperation"
//=============================================================================
// DPTPW_SubmitIoOperation
//-----------------------------------------------------------------------------
//
// Description:	   Submits an overlapped structure for an asynchronous I/O
//				operation so it can be monitored for completion.
//
//				   If this implementation is using I/O completion ports, this
//				method does not need to be used.  Otherwise, the caller should
//				be prepared for the work callback function to be invoked even
//				before this method returns. 
//
//				   The caller must pass a valid OVERLAPPED structure that was
//				allocated using IDirectPlay8ThreadPoolWork::CreateOverlapped.
//
//				   This method is not available on Windows CE because it does
//				not support overlapped I/O.
//
// Arguments:
//	xxx pInterface				- Pointer to interface.
//	OVERLAPPED * pOverlapped	- Pointer to overlapped structure to monitor.
//	DWORD dwFlags				- Flags to use when submitting I/O.
//
// Returns: HRESULT
//	DPN_OK	- Submitting the I/O operation was successful.
//=============================================================================
STDMETHODIMP DPTPW_SubmitIoOperation(IDirectPlay8ThreadPoolWork * pInterface,
									OVERLAPPED * const pOverlapped,
									const DWORD dwFlags)
{
#ifdef WINCE
	DPFX(DPFPREP, 0, "Overlapped I/O not supported on Windows CE!", 0);
	return DPNERR_UNSUPPORTED;
#else // ! WINCE
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	DPFX(DPFPREP, 0, "Implementation using I/O completion ports, SubmitIoOperation should not be used!", 0);
	return DPNERR_INVALIDVERSION;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	DPTHREADPOOLOBJECT *	pDPTPObject;
	CWorkItem *				pWorkItem;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, 0x%x)",
		pInterface, pOverlapped, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);

	pWorkItem = CONTAINING_OBJECT(pOverlapped, CWorkItem, m_Overlapped);
	DNASSERT(pWorkItem->IsValid());


	//
	// Call the implementation function.
	//
	SubmitIoOperation(pWorkItem->m_pWorkQueue, pWorkItem);


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [DPN_OK]");

	return DPN_OK;
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#endif // ! WINCE
} // DPTPW_SubmitIoOperation





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_ReleaseOverlapped"
//=============================================================================
// DPTPW_ReleaseOverlapped
//-----------------------------------------------------------------------------
//
// Description:	   Returns an unused overlapped structure previously created by
//				IDirectPlay8ThreadPoolWork::CreateOverlapped.  This should only
//				be called if the overlapped I/O will never complete
//				asynchronously.
//
//				   This method is not available on Windows CE because it does
//				not support overlapped I/O.
//
// Arguments:
//	xxx pInterface				- Pointer to interface.
//	OVERLAPPED * pOverlapped	- Pointer to overlapped structure to release.
//	DWORD dwFlags				- Flags to use when releasing structure.
//
// Returns: HRESULT
//	DPN_OK	- Releasing the I/O operation was successful.
//=============================================================================
STDMETHODIMP DPTPW_ReleaseOverlapped(IDirectPlay8ThreadPoolWork * pInterface,
									OVERLAPPED * const pOverlapped,
									const DWORD dwFlags)
{
#ifdef WINCE
	DPFX(DPFPREP, 0, "Overlapped I/O not supported on Windows CE!", 0);
	return DPNERR_UNSUPPORTED;
#else // ! WINCE
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	CWorkItem *				pWorkItem;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, 0x%x)",
		pInterface, pOverlapped, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);

	pWorkItem = CONTAINING_OBJECT(pOverlapped, CWorkItem, m_Overlapped);
	DNASSERT(pWorkItem->IsValid());


	//
	// Call the implementation function.
	//
	ReleaseOverlappedIoWorkItem(pWorkItem->m_pWorkQueue, pWorkItem);

	hr = DPN_OK;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#endif // ! WINCE
} // DPTPW_ReleaseOverlapped





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_CancelTimer"
//=============================================================================
// DPTPW_CancelTimer
//-----------------------------------------------------------------------------
//
// Description:	   Attempts to cancel a timed work item.  If the item is
//				already in the process of completing, DPNERR_CANNOTCANCEL is
//				returned, and the callback will still be (or is being) called.
//				If the item could be cancelled, DPN_OK is returned and the
//				callback will not be executed.
//
// Arguments:
//	xxx pInterface			- Pointer to interface.
//	void * pvTimerData		- Pointer to data for timer being cancelled.
//	UINT uiTimerUnique		- Uniqueness value for timer being cancelled.
//	DWORD dwFlags			- Flags to use when cancelling timer.
//
// Returns: HRESULT
//	DPN_OK					- Cancelling the timer was successful.
//	DPNERR_CANNOTCANCEL		- The timer could not be cancelled.
//=============================================================================
STDMETHODIMP DPTPW_CancelTimer(IDirectPlay8ThreadPoolWork * pInterface,
								void * const pvTimerData,
								const UINT uiTimerUnique,
								const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, %u, 0x%x)",
		pInterface, pvTimerData, uiTimerUnique, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Call the implementation function.
	//
	hr = CancelTimer(pvTimerData, uiTimerUnique);


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTPW_CancelTimer





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_ResetCompletingTimer"
//=============================================================================
// DPTPW_ResetCompletingTimer
//-----------------------------------------------------------------------------
//
// Description:	   Reschedules a timed work item whose callback is currently
//				being called.  Resetting timers that have not expired yet,
//				timers that have been cancelled, or timers whose callback has
//				already returned is not allowed.
//
//				   Using this method will never fail, since no new memory is
//				allocated.
//
// Arguments:
//	xxx pInterface							- Pointer to interface.
//	void * pvTimerData						- Pointer to data for timer being
//												reset.
//	DWORD dwNewDelay						- How much time should elapsed
//												before executing the work item
//												again, in ms.
//	PFNDPTNWORKCALLBACK pfnNewWorkCallback	- Callback to execute when timer
//												elapses.
//	PVOID pvNewCallbackContext				- User specified context to pass to
//												callback.
//	UINT * puiNewTimerUnique				- Place to store new uniqueness
//												value for timer so that it can
//												be cancelled.
//	DWORD dwFlags							- Flags to use when resetting
//												timer.
//
// Returns: HRESULT
//	DPN_OK	- Resetting the timer was successful.
//=============================================================================
STDMETHODIMP DPTPW_ResetCompletingTimer(IDirectPlay8ThreadPoolWork * pInterface,
										void * const pvTimerData,
										const DWORD dwNewDelay,
										const PFNDPTNWORKCALLBACK pfnNewWorkCallback,
										PVOID const pvNewCallbackContext,
										UINT * const puiNewTimerUnique,
										const DWORD dwFlags)
{
	DPTHREADPOOLOBJECT *	pDPTPObject;


	DPFX(DPFPREP, 8, "Parameters: (0x%p, 0x%p, %u, 0x%p, 0x%p, 0x%p, 0x%x)",
		pInterface, pvTimerData, dwNewDelay, pfnNewWorkCallback,
		pvNewCallbackContext, puiNewTimerUnique, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


#ifdef DBG
	//
	// We should be in a timer callback, and therefore at least in a threadpool
	// thread or doing work.
	//
#ifndef DPNBUILD_ONLYONETHREAD
	if (TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex) == NULL)
#endif // ! DPNBUILD_ONLYONETHREAD
	{
		DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK);
	}
#endif // DBG


	//
	// Call the implementation function.
	//
	ResetCompletingTimer(pvTimerData,
						dwNewDelay,
						pfnNewWorkCallback,
						pvNewCallbackContext,
						puiNewTimerUnique);


	DPFX(DPFPREP, 8, "Returning: [DPN_OK]");

	return DPN_OK;
} // DPTPW_ResetCompletingTimer





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_WaitWhileWorking"
//=============================================================================
// DPTPW_WaitWhileWorking
//-----------------------------------------------------------------------------
//
// Description:    Waits for the specified kernel object to become signalled,
//				but allows thread pool work to be performed while waiting.  No
//				timeout can be requested, this method will wait on the handle
//				forever.
//
//				   If this thread does not belong to the thread pool or is not
//				currently within a DoWork call, no work is performed.  In this
//				case it behaves exactly the same as WaitForSingleObject with a
//				timeout of INFINITE.
//
// Arguments:
//	xxx pInterface		- Pointer to interface.
//	HANDLE hWaitObject	- Handle on which to wait.
//	DWORD dwFlags		- Flags to use when waiting.
//
// Returns: HRESULT
//	DPN_OK		- The object became signalled.
//=============================================================================
STDMETHODIMP DPTPW_WaitWhileWorking(IDirectPlay8ThreadPoolWork * pInterface,
									const HANDLE hWaitObject,
									const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPU = 0;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifndef DPNBUILD_ONLYONETHREAD
	DPTPWORKERTHREAD *		pWorkerThread;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DPTPWORKQUEUE *			pWorkQueue;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, 0x%x)",
		pInterface, hWaitObject, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Don't call this method while holding locks!
	//
	AssertNoCriticalSectionsTakenByThisThread();

	//
	// Determine if this is a thread pool owned thread or one that is inside a
	// DoWork call.  If it is either, go ahead and start waiting & working.
	// Otherwise, just perform a normal WaitForSingleObject.
	// Since all CPU queues share the same TLS index, just use the one from CPU
	// 0 as representative of all of them.
	//
#ifndef DPNBUILD_ONLYONETHREAD
	pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
	DPFX(DPFPREP, 7, "Worker thread = 0x%p, doing work = 0x%x.",
		pWorkerThread, (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK));
	if (pWorkerThread != NULL)
	{
		pWorkerThread->dwRecursionCount++;
#ifdef DBG
		if (pWorkerThread->dwRecursionCount > pWorkerThread->dwMaxRecursionCount)
		{
			pWorkerThread->dwMaxRecursionCount = pWorkerThread->dwRecursionCount;
		}
#endif // DBG

		//
		// Keep looping until the object is ready.
		//
		while (WaitForSingleObject(hWaitObject, TIMER_BUCKET_GRANULARITY(pWorkerThread->pWorkQueue)) == WAIT_TIMEOUT)
		{
			//
			// The object is not ready, so process some work.
			//
			DoWork(pWorkerThread->pWorkQueue, INFINITE);

#ifndef DPNBUILD_ONLYONEPROCESSOR
			//
			// It's possible to have 0 threads on a subset of processors.  To
			// prevent deadlocks caused by items getting scheduled to a CPU
			// which then has all its threads removed, we need to make an
			// attempt at servicing its items.
			// We won't service every CPU each timeout, just one per loop.  We
			// also won't take the lock while check the thread count, we can
			// stand a little error.  The worst that could happen is that we
			// check the queue unnecessarily or a little late.  Better than
			// hanging...
			//
			pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU);
			if (pWorkQueue->dwNumRunningThreads == 0)
			{
				DNASSERT(pWorkQueue != pWorkerThread->pWorkQueue);
				DoWork(pWorkQueue, INFINITE);
			}

			dwCPU++;
			if (dwCPU >= NUM_CPUS(pDPTPObject))
			{
				dwCPU = 0;
			}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		}

		DNASSERT(pWorkerThread->dwRecursionCount > 0);
		pWorkerThread->dwRecursionCount--;
	}
	else
#endif // ! DPNBUILD_ONLYONETHREAD
	{
		BOOL	fPseudoDoWork;


		//
		// Lock the object to prevent multiple threads from trying to change
		// the settings while we check and change them.
		//
		DNEnterCriticalSection(&pDPTPObject->csLock);

		//
		// If we're in no-threaded DoWork mode, but we're not in a DoWork call
		// at this moment, pretend that we are.
		//
#ifdef DPNBUILD_ONLYONETHREAD
		if (! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK))
#else // ! DPNBUILD_ONLYONETHREAD
		if ((pDPTPObject->dwTotalUserThreadCount == 0) &&
			(! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)))
#endif // ! DPNBUILD_ONLYONETHREAD
		{
			pDPTPObject->dwFlags |= DPTPOBJECTFLAG_USER_DOINGWORK;
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
			pDPTPObject->dwCurrentDoWorkThreadID = GetCurrentThreadId();
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL
			fPseudoDoWork = TRUE;
		}
		else
		{
			fPseudoDoWork = FALSE;
		}

		if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)
		{
#ifndef DPNBUILD_ONLYONETHREAD
			DWORD		dwRecursionDepth;
#endif // ! DPNBUILD_ONLYONETHREAD


#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
			DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == GetCurrentThreadId());
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL

			//
			// We can leave the lock because nobody else should be touching the
			// work queue while we're doing work.
			//
			DNLeaveCriticalSection(&pDPTPObject->csLock);


			//
			// Increment the recursion depth.
			//
#ifdef DPNBUILD_ONLYONETHREAD
			pDPTPObject->dwWorkRecursionCount++;
#else // ! DPNBUILD_ONLYONETHREAD
			dwRecursionDepth = (DWORD) ((DWORD_PTR) TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex));
			dwRecursionDepth++;
			TlsSetValue(pDPTPObject->dwWorkRecursionCountTlsIndex,
						(PVOID) ((DWORD_PTR) dwRecursionDepth));
#endif // ! DPNBUILD_ONLYONETHREAD


			//
			// Keep looping until the object is ready.
			//
			while (WaitForSingleObject(hWaitObject, TIMER_BUCKET_GRANULARITY(WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU))) == WAIT_TIMEOUT)
			{
				//
				// The object is not ready, so process some work.  Note that
				// timers can be missed by an amount proportional to the number
				// of CPUs since we only check a single queue each interval.
				//
				DoWork(WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU), INFINITE);

#ifndef DPNBUILD_ONLYONEPROCESSOR
				//
				// Try the next CPU queue (wrapping appropriately).
				//
				dwCPU++;
				if (dwCPU == NUM_CPUS(pDPTPObject))
				{
					dwCPU = 0;
				}
#endif // ! DPNBUILD_ONLYONEPROCESSOR
			}


			//
			// Decrement the recursion depth.
			//
#ifdef DPNBUILD_ONLYONETHREAD
			pDPTPObject->dwWorkRecursionCount--;
#else // ! DPNBUILD_ONLYONETHREAD
			DNASSERT((DWORD) ((DWORD_PTR) TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex)) == dwRecursionDepth);
			dwRecursionDepth--;
			TlsSetValue(pDPTPObject->dwWorkRecursionCountTlsIndex,
						(PVOID) ((DWORD_PTR) dwRecursionDepth));
#endif // ! DPNBUILD_ONLYONETHREAD

			//
			// Clear the pseudo-DoWork mode flag if necessary.
			//
			if (fPseudoDoWork)
			{
				DNEnterCriticalSection(&pDPTPObject->csLock);
				DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK);
				pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_USER_DOINGWORK;
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
				DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == GetCurrentThreadId());
				pDPTPObject->dwCurrentDoWorkThreadID = 0;
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL
#ifdef DPNBUILD_ONLYONETHREAD
				DNASSERT(pDPTPObject->dwWorkRecursionCount == 0);
#else // ! DPNBUILD_ONLYONETHREAD
				DNASSERT(dwRecursionDepth == 0);
#endif // ! DPNBUILD_ONLYONETHREAD
				DNLeaveCriticalSection(&pDPTPObject->csLock);
			}
		}
		else
		{
			DNLeaveCriticalSection(&pDPTPObject->csLock);
			DNASSERT(! fPseudoDoWork);
			WaitForSingleObject(hWaitObject, INFINITE);
		}
	}

	hr = DPN_OK;

	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTPW_WaitWhileWorking





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_SleepWhileWorking"
//=============================================================================
// DPTPW_SleepWhileWorking
//-----------------------------------------------------------------------------
//
// Description:    Does not return for a specified number of milliseconds, but
//				allows thread pool work to be performed during that time.
//
//				   If this thread does not belong to the thread pool or is not
//				currently within a DoWork call, no work is performed.  In this
//				case it behaves exactly the same as Sleep with the specified
//				timeout.
//
// Arguments:
//	xxx pInterface		- Pointer to interface.
//	DWORD dwTimeout		- Timeout for the sleep operation.
//	DWORD dwFlags		- Flags to use when sleeping.
//
// Returns: HRESULT
//	DPN_OK		- The sleep occurred successfully.
//=============================================================================
STDMETHODIMP DPTPW_SleepWhileWorking(IDirectPlay8ThreadPoolWork * pInterface,
									const DWORD dwTimeout,
									const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DWORD					dwCPU = 0;
#ifndef DPNBUILD_ONLYONETHREAD
	DPTPWORKERTHREAD *		pWorkerThread;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DPTPWORKQUEUE *			pWorkQueue;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
	DWORD					dwStartTime;
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE
#endif // ! DPNBUILD_ONLYONETHREAD
	DWORD					dwStopTime;
	DWORD					dwInterval;
	DWORD					dwTimeLeft;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %u, 0x%x)",
		pInterface, dwTimeout, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Don't call this method while holding locks!
	//
	AssertNoCriticalSectionsTakenByThisThread();

	//
	// We shouldn't sleep for a really long time, it causes bad results in our
	// calculations, and it doesn't make much sense in our case anyway (having
	// a thread be unusable for 24 days?)
	//
	DNASSERT(dwTimeout < 0x80000000);


	//
	// Determine if this is a thread pool owned thread or one that is inside a
	// DoWork call.  If it is either, go ahead and start waiting & working.
	// Otherwise, just perform a normal WaitForSingleObject.
	// Since all CPU queues share the same TLS index, just use the one from CPU
	// 0 as representative of all of them.
	//
#ifndef DPNBUILD_ONLYONETHREAD
	pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
	DPFX(DPFPREP, 7, "Worker thread = 0x%p, doing work = 0x%x.",
		pWorkerThread, (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK));
	if (pWorkerThread != NULL)
	{
		pWorkerThread->dwRecursionCount++;
#ifdef DBG
		if (pWorkerThread->dwRecursionCount > pWorkerThread->dwMaxRecursionCount)
		{
			pWorkerThread->dwMaxRecursionCount = pWorkerThread->dwRecursionCount;
		}
#endif // DBG

		//
		// Keep looping until the timeout expires.  We can be jolted awake
		// earlier if the alert event gets set.
		//
		dwStopTime = GETTIMESTAMP() + dwTimeout;
		dwInterval = TIMER_BUCKET_GRANULARITY(pWorkerThread->pWorkQueue);

		//
		// Give up at least one time slice.
		//
		Sleep(0);

		do
		{
			//
			// Process some work.
			//
			DoWork(pWorkerThread->pWorkQueue, dwStopTime);

#ifndef DPNBUILD_ONLYONEPROCESSOR
			//
			// It's possible to have 0 threads on a subset of processors.  To
			// prevent deadlocks caused by items getting scheduled to a CPU
			// which then has all its threads removed, we need to make an
			// attempt at servicing its items.
			// We won't service every CPU each timeout, just one per loop.  We
			// also won't take the lock while check the thread count, we can
			// stand a little error.  The worst that could happen is that we
			// check the queue unnecessarily or a little late.  Better than
			// hanging...
			//
			pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU);
			if (pWorkQueue->dwNumRunningThreads == 0)
			{
				DNASSERT(pWorkQueue != pWorkerThread->pWorkQueue);
				DoWork(pWorkQueue, dwStopTime);
			}

			dwCPU++;
			if (dwCPU >= NUM_CPUS(pDPTPObject))
			{
				dwCPU = 0;
			}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

			//
			// If it's past time to stop sleeping, bail.
			//
			dwTimeLeft = dwStopTime - GETTIMESTAMP();
			if ((int) dwTimeLeft <= 0)
			{
				break;
			}

			//
			// If the time left is less than the current interval, use that
			// instead for more accurate results.
			//
			if (dwTimeLeft < dwInterval)
			{
				dwInterval = dwTimeLeft;
			}

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			dwStartTime = GETTIMESTAMP();
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
#pragma BUGBUG(vanceo, "Sleep alertably")
			Sleep(dwInterval);
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
			//
			// Ignore the return code, we want to start working on the queue
			// regardless of timeout or alert event.
			//
			DNWaitForSingleObject(pWorkerThread->pWorkQueue->hAlertEvent, dwInterval);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			DNInterlockedExchangeAdd((LPLONG) (&pWorkerThread->pWorkQueue->dwTotalTimeSpentUnsignalled),
									(GETTIMESTAMP() - dwStartTime));
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE
		}
		while (TRUE);

		DNASSERT(pWorkerThread->dwRecursionCount > 0);
		pWorkerThread->dwRecursionCount--;
	}
	else
#endif // ! DPNBUILD_ONLYONETHREAD
	{
		BOOL	fPseudoDoWork;


		//
		// Lock the object to prevent multiple threads from trying to change
		// the settings while we check and change them.
		//
		DNEnterCriticalSection(&pDPTPObject->csLock);

		//
		// If we're in no-threaded DoWork mode, but we're not in a DoWork call
		// at this moment, pretend that we are.
		//
#ifdef DPNBUILD_ONLYONETHREAD
		if (! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK))
#else // ! DPNBUILD_ONLYONETHREAD
		if ((pDPTPObject->dwTotalUserThreadCount == 0) &&
			(! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)))
#endif // ! DPNBUILD_ONLYONETHREAD
		{
			pDPTPObject->dwFlags |= DPTPOBJECTFLAG_USER_DOINGWORK;
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
			pDPTPObject->dwCurrentDoWorkThreadID = GetCurrentThreadId();
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL
			fPseudoDoWork = TRUE;
		}
		else
		{
			fPseudoDoWork = FALSE;
		}

		if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK)
		{
#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
			DNHANDLE	ahWaitObjects[64];
			DWORD		dwNumWaitObjects;
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#ifndef DPNBUILD_ONLYONETHREAD
			DWORD		dwRecursionDepth;
#endif // ! DPNBUILD_ONLYONETHREAD


#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
			DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == GetCurrentThreadId());
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL

			//
			// We can leave the lock because nobody else should be touching the
			// work queue while we're doing work.
			//
			DNLeaveCriticalSection(&pDPTPObject->csLock);


			//
			// Increment the recursion depth.
			//
#ifdef DPNBUILD_ONLYONETHREAD
			pDPTPObject->dwWorkRecursionCount++;
#else // ! DPNBUILD_ONLYONETHREAD
			dwRecursionDepth = (DWORD) ((DWORD_PTR) TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex));
			dwRecursionDepth++;
			TlsSetValue(pDPTPObject->dwWorkRecursionCountTlsIndex,
						(PVOID) ((DWORD_PTR) dwRecursionDepth));
#endif // ! DPNBUILD_ONLYONETHREAD


#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
			//
			// Keep looping until the timeout expires.  We can be jolted awake
			// earlier if one of the alert events gets set.  We can only wait
			// on 64 objects, so we must cap the number of alert events to 64.
			//
			dwNumWaitObjects = NUM_CPUS(pDPTPObject);
			if (dwNumWaitObjects > 64)
			{
				DPFX(DPFPREP, 3, "Capping number of alert events to 64 (num CPUs = %u).",
					dwNumWaitObjects);
				dwNumWaitObjects = 64;
			}

			for(dwCPU = 0; dwCPU < dwNumWaitObjects; dwCPU++)
			{
				ahWaitObjects[dwCPU] = (WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU))->hAlertEvent;
			}
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

			dwStopTime = GETTIMESTAMP() + dwTimeout;
			dwInterval = TIMER_BUCKET_GRANULARITY(WORKQUEUE_FOR_CPU(pDPTPObject, 0));

			//
			// Give up at least one time slice.
			//
			Sleep(0);
			
			do
			{
				//
				// Process all CPU queues.
				//
				for(dwCPU = 0; dwCPU < NUM_CPUS(pDPTPObject); dwCPU++)
				{
					DoWork(WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU), dwStopTime);
				}

				//
				// If it's past time to stop sleeping, bail.
				//
				dwTimeLeft = dwStopTime - GETTIMESTAMP();
				if ((int) dwTimeLeft <= 0)
				{
					break;
				}

				//
				// If the time left is less than the current interval, use that
				// instead for more accurate results.
				//
				if (dwTimeLeft < dwInterval)
				{
					dwInterval = dwTimeLeft;
				}

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
#pragma BUGBUG(vanceo, "Sleep alertably")
				Sleep(dwInterval);
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
				//
				// Ignore return code, we want to start working on all CPUs
				// regardless of timeout or alert event.
				//
				DNWaitForMultipleObjects(dwNumWaitObjects, ahWaitObjects, FALSE, dwInterval);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
			}
			while (TRUE);


			//
			// Decrement the recursion depth.
			//
#ifdef DPNBUILD_ONLYONETHREAD
			pDPTPObject->dwWorkRecursionCount--;
#else // ! DPNBUILD_ONLYONETHREAD
			DNASSERT((DWORD) ((DWORD_PTR) TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex)) == dwRecursionDepth);
			dwRecursionDepth--;
			TlsSetValue(pDPTPObject->dwWorkRecursionCountTlsIndex,
						(PVOID) ((DWORD_PTR) dwRecursionDepth));
#endif // ! DPNBUILD_ONLYONETHREAD

			//
			// Clear the pseudo-DoWork mode flag if necessary.
			//
			if (fPseudoDoWork)
			{
				DNEnterCriticalSection(&pDPTPObject->csLock);
				DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK);
				pDPTPObject->dwFlags &= ~DPTPOBJECTFLAG_USER_DOINGWORK;
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
				DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == GetCurrentThreadId());
				pDPTPObject->dwCurrentDoWorkThreadID = 0;
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL
#ifdef DPNBUILD_ONLYONETHREAD
				DNASSERT(pDPTPObject->dwWorkRecursionCount == 0);
#else // ! DPNBUILD_ONLYONETHREAD
				DNASSERT(dwRecursionDepth == 0);
#endif // ! DPNBUILD_ONLYONETHREAD
				DNLeaveCriticalSection(&pDPTPObject->csLock);
			}
		}
		else
		{
			DNLeaveCriticalSection(&pDPTPObject->csLock);
			DNASSERT(! fPseudoDoWork);
			Sleep(dwTimeout);
		}
	}

	hr = DPN_OK;

	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTPW_SleepWhileWorking




#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_RequestTotalThreadCount"
//=============================================================================
// DPTPW_RequestTotalThreadCount
//-----------------------------------------------------------------------------
//
// Description:	   Requests a minimum number of threads for all processors.
//
// Arguments:
//	xxx pInterface		- Pointer to interface.
//	DWORD dwNumThreads	- Desired number of threads.
//	DWORD dwFlags		- Flags to use when setting the thread count.
//
// Returns: HRESULT
//	DPN_OK						- Requesting the number of threads was
//									successful.
//	DPNERR_ALREADYINITIALIZED	- The user has already set an incompatible
//									number of threads.
//=============================================================================
STDMETHODIMP DPTPW_RequestTotalThreadCount(IDirectPlay8ThreadPoolWork * pInterface,
										const DWORD dwNumThreads,
										const DWORD dwFlags)
{
#ifdef DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 0, "Requesting threads is unsupported!");
	DNASSERT(!"Requesting threads is unsupported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONETHREAD
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %u, 0x%x)",
		pInterface, dwNumThreads, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


#pragma TODO(vanceo, "Possibly prevent calling on last thread pool thread or while DoWork in progress")

	//
	// Lock the object to prevent multiple threads from trying to change the
	// thread count simultaneously.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);

	//
	// This is a minimum request, so if a Work interface has already requested
	// more threads, we're fine.  But if the user has already set a specific
	// number of threads then this Work interface can't override that.
	//
	if (pDPTPObject->dwTotalUserThreadCount == -1)
	{
		if ((pDPTPObject->dwTotalDesiredWorkThreadCount == -1) ||
			(pDPTPObject->dwTotalDesiredWorkThreadCount < dwNumThreads))
		{
			hr = SetTotalNumberOfThreads(pDPTPObject, dwNumThreads);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't set new minimum number of threads!");

				//
				// Drop through...
				//
			}
			else
			{
				pDPTPObject->dwTotalDesiredWorkThreadCount = dwNumThreads;
			}
		}
		else
		{
			DPFX(DPFPREP, 1, "Work interface has already requested %u threads, succeeding.",
				pDPTPObject->dwTotalDesiredWorkThreadCount);
			hr = DPN_OK;
		}
	}
	else
	{
		if (pDPTPObject->dwTotalUserThreadCount < dwNumThreads)
		{
			DPFX(DPFPREP, 1, "User has already requested a lower number of threads (%u).",
				pDPTPObject->dwTotalUserThreadCount);
			hr = DPNERR_ALREADYINITIALIZED;

			//
			// Drop through...
			//
		}
		else
		{
			DPFX(DPFPREP, 1, "User has already requested %u threads, succeeding.",
				pDPTPObject->dwTotalUserThreadCount);
			hr = DPN_OK;
		}
	}

	DNLeaveCriticalSection(&pDPTPObject->csLock);


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#endif // ! DPNBUILD_ONLYONETHREAD
} // DPTPW_RequestTotalThreadCount





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_GetTotalThreadCount"
//=============================================================================
// DPTPW_GetTotalThreadCount
//-----------------------------------------------------------------------------
//
// Description:	   Retrieves the current number of threads on the specified
//				processor(s) requested by the main user interface.  If the user
//				interface has not specified a thread count, but a work
//				interface has, then pdwNumThreads is set to the requested
//				thread count and DPNSUCCESS_PENDING is returned.  If neither
//				the main user interface nor a work interface have set the
//				number of threads, then pdwNumThreads is set to 0 and
//				DPNERR_NOTREADY is returned.
//
// Arguments:
//	xxx pInterface			- Pointer to interface.
//	DWORD dwCPU				- CPU whose thread count is to be retrieved, or -1
//								for total thread count.
//	DWORD * pdwNumThreads	- Pointer to DWORD in which to store the current
//								number of threads per processor.
//	DWORD dwFlags			- Flags to use when retrieving thread count.
//
// Returns: HRESULT
//	DPN_OK				- Retrieving the number of threads specified by user
//							was successful.
//	DPNSUCCESS_PENDING	- The user hasn't specified a thread count, but the
//							number requested by work interfaces is available.
//	DPNERR_NOTREADY		- No thread count has been specified yet.
//=============================================================================
STDMETHODIMP DPTPW_GetThreadCount(IDirectPlay8ThreadPoolWork * pInterface,
								const DWORD dwCPU,
								DWORD * const pdwNumThreads,
								const DWORD dwFlags)
{
#ifdef DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 0, "Retrieving thread count is unsupported!");
	DNASSERT(!"Retrieving thread count is unsupported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONETHREAD
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DPTPWORKQUEUE *			pWorkQueue;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %i, 0x%p, 0x%x)",
		pInterface, dwCPU, pdwNumThreads, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);

	DNASSERT((dwCPU == -1) || (dwCPU < NUM_CPUS(pDPTPObject)));


	//
	// Lock the object while we retrieve the thread counts.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);

	if (dwCPU == -1)
	{
		//
		// Get the total thread count.
		//

		if (pDPTPObject->dwTotalUserThreadCount != -1)
		{
			*pdwNumThreads = pDPTPObject->dwTotalUserThreadCount;
			hr = DPN_OK;
		}
		else if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
		{
			*pdwNumThreads = pDPTPObject->dwTotalDesiredWorkThreadCount;
			hr = DPNSUCCESS_PENDING;
		}
		else
		{
			*pdwNumThreads = 0;
			hr = DPNERR_NOTREADY;
		}
	}
	else
	{
		//
		// Get the thread count for the specific CPU.
		//
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwCPU);

		*pdwNumThreads = pWorkQueue->dwNumRunningThreads;

		if (pDPTPObject->dwTotalUserThreadCount != -1)
		{
			hr = DPN_OK;
		}
		else if (pDPTPObject->dwTotalDesiredWorkThreadCount != -1)
		{
			hr = DPNSUCCESS_PENDING;
		}
		else
		{
			hr = DPNERR_NOTREADY;
		}
	}

	DNLeaveCriticalSection(&pDPTPObject->csLock);


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#endif // ! DPNBUILD_ONLYONETHREAD
} // DPTPW_GetTotalThreadCount





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_GetWorkRecursionDepth"
//=============================================================================
// DPTPW_GetWorkRecursionDepth
//-----------------------------------------------------------------------------
//
// Description:	   Stores the Work recursion depth of the current thread in the
//				value pointed to by pdwDepth.  The recursion depth is the
//				number of times the thread has called DoWork, WaitWhileWorking,
//				or SleepWhileWorking.  If the thread is not currently in any
//				of those functions, then the depth returned is 0.
//
// Arguments:
//	xxx pInterface		- Pointer to interface.
//	DWORD * pdwDepth	- Place to store recursion depth of current thread.
//	DWORD dwFlags		- Flags to use when retrieving recursion depth.
//
// Returns: HRESULT
//	DPN_OK	- The recursion depth was retrieved successfully.
//=============================================================================
STDMETHODIMP DPTPW_GetWorkRecursionDepth(IDirectPlay8ThreadPoolWork * pInterface,
										DWORD * const pdwDepth,
										const DWORD dwFlags)
{
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
#ifndef DPNBUILD_ONLYONETHREAD
	DPTPWORKERTHREAD *		pWorkerThread;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, 0x%x)",
		pInterface, pdwDepth, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


#ifdef DPNBUILD_ONLYONETHREAD
	//
	// Retrieve the recursion count for the only thread..
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);
#ifdef DBG
	if (pDPTPObject->dwWorkRecursionCount > 0)
	{
		DPFX(DPFPREP, 5, "Thread is in a DoWork call with recursion depth %u.",
			pDPTPObject->dwWorkRecursionCount);
		DNASSERT(pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK);
#ifndef DPNBUILD_NOPARAMVAL
		DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == GetCurrentThreadId());
#endif // ! DPNBUILD_NOPARAMVAL
	}
	else
	{
		DPFX(DPFPREP, 5, "Thread is not in a DoWork call.");
		DNASSERT(! (pDPTPObject->dwFlags & DPTPOBJECTFLAG_USER_DOINGWORK));
#ifndef DPNBUILD_NOPARAMVAL
		DNASSERT(pDPTPObject->dwCurrentDoWorkThreadID == 0);
#endif // ! DPNBUILD_NOPARAMVAL
	}
#endif // DBG
	*pdwDepth = pDPTPObject->dwWorkRecursionCount;
	DNLeaveCriticalSection(&pDPTPObject->csLock);
#else // ! DPNBUILD_ONLYONETHREAD
	//
	// Retrieve the worker thread state.  Since all CPU queues share the same
	// TLS index, just use the one from CPU 0 as representative of all of them.
	//
	pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
	if (pWorkerThread != NULL)
	{
		DPFX(DPFPREP, 5, "Worker thread 0x%p has recursion count of %u.",
			pWorkerThread, pWorkerThread->dwRecursionCount);
		*pdwDepth = pWorkerThread->dwRecursionCount;
	}
	else
	{
		//
		// It's an app thread.  Retrieve the recursion count from the TLS slot
		// dedicated to that purpose.
		//
		*pdwDepth = (DWORD) ((DWORD_PTR) TlsGetValue(pDPTPObject->dwWorkRecursionCountTlsIndex));
		DPFX(DPFPREP, 5, "App thread has recursion count of %u.", *pdwDepth);
	}
#endif // ! DPNBUILD_ONLYONETHREAD

	hr = DPN_OK;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
} // DPTPW_GetWorkRecursionDepth





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_Preallocate"
//=============================================================================
// DPTPW_Preallocate
//-----------------------------------------------------------------------------
//
// Description:    Pre-allocates per-CPU pooled resources for the given object.
//
// Arguments:
//	xxx pInterface				- Pointer to interface.
//	DWORD dwNumWorkItems		- Number of work items to pre-allocate per CPU.
//	DWORD dwNumTimers			- Number of timers to pre-allocate per CPU.
//	DWORD dwNumIoOperations		- Number of I/O operations to pre-allocate per
//									CPU.
//	DWORD dwFlags				- Flags to use when pre-allocating.
//
// Returns: HRESULT
//	DPN_OK	- The recursion depth was retrieved successfully.
//=============================================================================
STDMETHODIMP DPTPW_Preallocate(IDirectPlay8ThreadPoolWork * pInterface,
						const DWORD dwNumWorkItems,
						const DWORD dwNumTimers,
						const DWORD dwNumIoOperations,
						const DWORD dwFlags)
{
#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
	HRESULT					hr = DPN_OK;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DWORD					dwNumToAllocate;
	DWORD					dwTemp;
	DPTPWORKQUEUE *			pWorkQueue;
	DWORD					dwAllocated;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, %u, %u, %u, 0x%x)",
		pInterface, dwNumWorkItems, dwNumTimers, dwNumIoOperations, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);


	//
	// Work items, timers, and I/O operations all come from the same pool.
	//
	dwNumToAllocate = dwNumWorkItems + dwNumTimers + dwNumIoOperations;

	//
	// Populate the pools for each CPU.
	//
	for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
	{
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
		dwAllocated = pWorkQueue->pWorkItemPool->Preallocate(dwNumToAllocate,
															pWorkQueue;
		if (dwAllocated < dwNumToAllocate)
		{
			DPFX(DPFPREP, 0, "Only preallocated %u of %u address elements!",
				dwAllocated, dwNumToAllocate);
			hr = DPNERR_OUTOFMEMORY;
			break;
		}
	}


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;
#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
	DPFX(DPFPREP, 0, "Preallocation is unsupported!");
	DNASSERT(!"Preallocation is unsupported!");
	return DPNERR_UNSUPPORTED;
#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL
} // DPTPW_PreallocateItems




#ifdef DPNBUILD_MANDATORYTHREADS

#undef DPF_MODNAME
#define DPF_MODNAME "DPTPW_CreateMandatoryThread"
//=============================================================================
// DPTPW_CreateMandatoryThread
//-----------------------------------------------------------------------------
//
// Description:    Creates a mandatory thread that is aware of the thread pool
//				but not directly controllable through the thread pool.
//
//				   This is largely a wrapper for the OS' CreateThread function.
//				The lpThreadAttributes, dwStackSize, lpStartAddress,
//				lpParameter and lpThreadId  parameters are described in more
//				detail in the documentation for that function.  The dwFlags
//				parameter is also passed straight through to the OS.  However
//				the CREATE_SUSPENDED flag is not supported.
//
//				   The thread routine must simply return when finished.  It
//				must not call ExitThread, endthread, or TerminateThread.
//
//				   Threads cannot be created when the user has put the
//				threadpool in "DoWork" mode.  Similarly, "DoWork" mode cannot
//				be enabled when mandatory threads exist (see
//				IDirectPlay8ThreadPool::SetThreadCount).
//
// Arguments:
//	xxx pInterface								- Pointer to interface.
//	LPSECURITY_ATTRIBUTES lpThreadAttributes	- Attributes for thread.
//	SIZE_T dwStackSize							- Stack size for thread.
//	LPTHREAD_START_ROUTINE lpStartAddress		- Entry point for thread.
//	LPVOID lpParameter							- Entry parameter for thread.
//	LPDWORD lpThreadId							- Place to store ID of new
//													thread.
//	HANDLE * phThread							- Place to store handle of
//													new thread.
//	DWORD dwFlags								- Flags to use when creating
//													thread.
//
// Returns: HRESULT
//	DPN_OK				- Creating the thread was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to create the thread.
//	DPNERR_NOTALLOWED	- The user is in DoWork mode, threads cannot be
//							created.
//=============================================================================
STDMETHODIMP DPTPW_CreateMandatoryThread(IDirectPlay8ThreadPoolWork * pInterface,
										LPSECURITY_ATTRIBUTES lpThreadAttributes,
										SIZE_T dwStackSize,
										LPTHREAD_START_ROUTINE lpStartAddress,
										LPVOID lpParameter,
										LPDWORD lpThreadId,
										HANDLE *const phThread,
										const DWORD dwFlags)
{
#ifdef DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 0, "Thread creation is not supported!");
	DNASSERT(!"Thread creation is not supported!");
	return DPNERR_UNSUPPORTED;
#else // ! DPNBUILD_ONLYONETHREAD
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	DNHANDLE				hThread = NULL;
	DNHANDLE				hStartedEvent = NULL;
	DPTPMANDATORYTHREAD *	pMandatoryThread = NULL;
	DWORD					dwThreadID;
	DNHANDLE				ahWaitObjects[2];
	DWORD					dwResult;


	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Parameters: (0x%p, 0x%p, %u, 0x%p, 0x%p, 0x%p, 0x%p, 0x%x)",
		pInterface, lpThreadAttributes, dwStackSize, lpStartAddress,
		lpParameter, lpThreadId, phThread, dwFlags);


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pInterface);
	DNASSERT(pDPTPObject != NULL);

	DNASSERT(lpStartAddress != NULL);
	DNASSERT(lpThreadId != NULL);
	DNASSERT(phThread != NULL);
	DNASSERT(! (dwFlags & CREATE_SUSPENDED));


	//
	// We could check to see if we're in DoWork mode, but we don't want to hold
	// the lock while creating the thread.  We would end up checking twice,
	// once here, and again in the thread when it was about to increment the
	// mandatory thread count, so we'll just use the one in the thread.  See
	// DPTPMandatoryThreadProc
	//


	//
	// Create event so we can be notified when the thread starts.
	//
	hStartedEvent = DNCreateEvent(NULL, FALSE, FALSE, NULL);
	if (hStartedEvent == NULL)
	{
#ifdef DBG
		dwResult = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create start event (err = %u)!", dwResult);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}


	//
	// Allocate a tracking structure for the thread.
	//
	pMandatoryThread = (DPTPMANDATORYTHREAD*) DNMalloc(sizeof(DPTPMANDATORYTHREAD));
	if (pMandatoryThread == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for tracking mandatory thread!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	pMandatoryThread->Sig[0] = 'M';
	pMandatoryThread->Sig[1] = 'N';
	pMandatoryThread->Sig[2] = 'D';
	pMandatoryThread->Sig[3] = 'T';

	pMandatoryThread->pDPTPObject			= pDPTPObject;
	pMandatoryThread->hStartedEvent			= hStartedEvent;
	pMandatoryThread->pfnMsgHandler			= (WORKQUEUE_FOR_CPU(pDPTPObject, 0))->pfnMsgHandler;
	pMandatoryThread->pvMsgHandlerContext	= (WORKQUEUE_FOR_CPU(pDPTPObject, 0))->pvMsgHandlerContext;
	pMandatoryThread->lpStartAddress		= lpStartAddress;
	pMandatoryThread->lpParameter			= lpParameter;
#ifdef DBG
	pMandatoryThread->dwThreadID			= 0;
	pMandatoryThread->blList.Initialize();
#endif // DBG


	hThread = DNCreateThread(lpThreadAttributes,
							dwStackSize,
							DPTPMandatoryThreadProc,
							pMandatoryThread,
							dwFlags,
							&dwThreadID);
	if (hThread == NULL)
	{
#ifdef DBG
		dwResult = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create thread (err = %u)!", dwResult);
#endif // DBG
		hr = DPNERR_GENERIC;
		goto Failure;
	}

	ahWaitObjects[0] = hStartedEvent;
	ahWaitObjects[1] = hThread;

	dwResult = DNWaitForMultipleObjects(2, ahWaitObjects, FALSE, INFINITE);
	switch (dwResult)
	{
		case WAIT_OBJECT_0:
		{
			//
			// The thread started successfully.  Drop through.
			//
			break;
		}

		case WAIT_OBJECT_0 + 1:
		{
			//
			// The thread shut down prematurely.
			//
			GetExitCodeThread(HANDLE_FROM_DNHANDLE(hThread), &dwResult);
			if ((HRESULT) dwResult == DPNERR_NOTALLOWED)
			{
				DPFX(DPFPREP, 0, "Thread started while in DoWork mode!");
				hr = DPNERR_NOTALLOWED;
			}
			else
			{
				DPFX(DPFPREP, 0, "Thread shutdown prematurely (exit code = %u)!", dwResult);
				hr = DPNERR_GENERIC;
			}

			goto Failure;
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Thread failed waiting (result = %u)!", dwResult);
			hr = DPNERR_GENERIC;
			goto Failure;
			break;
		}
	}

	//
	// At this point, the thread owns the pMandatoryThread object, and could
	// delete it at any time.  We must not reference it again.
	//

	//
	// Return the thread ID and handle to the caller.
	//
	*lpThreadId = dwThreadID;
	*phThread = HANDLE_FROM_DNHANDLE(hThread);
	hr = DPN_OK;


Exit:

	//
	// Close the started event, we no longer need it.
	//
	if (hStartedEvent != NULL)
	{
		DNCloseHandle(hStartedEvent);
		hStartedEvent = NULL;
	}

	DPFX(DPFPREP, DPF_ENTRYLEVEL, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	if (hThread != NULL)
	{
		DNCloseHandle(hThread);
		hThread = NULL;
	}

	if (pMandatoryThread != NULL)
	{
		DNFree(pMandatoryThread);
		pMandatoryThread = NULL;
	}

	goto Exit;
#endif // ! DPNBUILD_ONLYONETHREAD
} // DPTPW_CreateMandatoryThread

#endif // DPNBUILD_MANDATORYTHREADS



#ifndef DPNBUILD_ONLYONEPROCESSOR

#undef DPF_MODNAME
#define DPF_MODNAME "ChooseWorkQueue"
//=============================================================================
// ChooseWorkQueue
//-----------------------------------------------------------------------------
//
// Description:	Selects the best CPU for a given operation, and returns a
//				pointer to its work queue object.
//
// Arguments:
//	DPTHREADPOOLOBJECT * pDPTPObject	- Pointer to interface object.
//
// Returns: Pointer to work queue selected.
//=============================================================================
DPTPWORKQUEUE * ChooseWorkQueue(DPTHREADPOOLOBJECT * const pDPTPObject)
{
	DPTPWORKQUEUE *		pWorkQueue;
	DPTPWORKERTHREAD *	pWorkerThread;


	//
	// If this is a thread pool thread, choose the CPU associated with this
	// thread.  
	//
	pWorkerThread = (DPTPWORKERTHREAD*) TlsGetValue((WORKQUEUE_FOR_CPU(pDPTPObject, 0))->dwWorkerThreadTlsIndex);
	if (pWorkerThread != NULL)
	{
		pWorkQueue = pWorkerThread->pWorkQueue;
		goto Exit;
	}


	DNEnterCriticalSection(&pDPTPObject->csLock);

	//
	// If we are in DoWork mode, or no threads have been started, just use
	// processor 0's work queue.
	//
	if ((pDPTPObject->dwTotalUserThreadCount == 0) ||
		((pDPTPObject->dwTotalUserThreadCount == -1) && (pDPTPObject->dwTotalDesiredWorkThreadCount == -1)))
	{
		DNLeaveCriticalSection(&pDPTPObject->csLock);
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, 0);
		goto Exit;
	}

	//
	// Otherwise keep cycling through each CPU to distribute items equally
	// round-robin style.  Don't queue items for CPUs that don't have any
	// running threads, though.
	//
	do
	{
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, pDPTPObject->dwCurrentCPUSelection);
		pDPTPObject->dwCurrentCPUSelection++;
		if (pDPTPObject->dwCurrentCPUSelection >= NUM_CPUS(pDPTPObject))
		{
			pDPTPObject->dwCurrentCPUSelection = 0;
		}
	}
	while (pWorkQueue->dwNumRunningThreads == 0);

	DNLeaveCriticalSection(&pDPTPObject->csLock);

Exit:

	return pWorkQueue;
} // ChooseWorkQueue

#endif // ! DPNBUILD_ONLYONEPROCESSOR



#ifndef DPNBUILD_ONLYONETHREAD

#undef DPF_MODNAME
#define DPF_MODNAME "SetTotalNumberOfThreads"
//=============================================================================
// SetTotalNumberOfThreads
//-----------------------------------------------------------------------------
//
// Description:    Modifies the total number of threads for all processors.
//
//				   The DPTHREADPOOLOBJECT lock is assumed to be held.
//
// Arguments:
//	DPTHREADPOOLOBJECT * pDPTPObject	- Pointer to interface object.
//	DWORD dwNumThreads					- New desired totla number of threads.
//
// Returns: HRESULT
//	DPN_OK				- Setting the number of threads was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to alter the number of threads.
//=============================================================================
HRESULT SetTotalNumberOfThreads(DPTHREADPOOLOBJECT * const pDPTPObject,
							const DWORD dwNumThreads)
{
	HRESULT				hr = DPN_OK;
	DWORD				dwNumThreadsPerProcessor;
	DWORD				dwExtraThreads;
	DWORD				dwTemp;
	DPTPWORKQUEUE *		pWorkQueue;
	DWORD				dwDelta;


#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	dwNumThreadsPerProcessor = dwNumThreads;
	dwExtraThreads = 0;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	dwNumThreadsPerProcessor = dwNumThreads / NUM_CPUS(pDPTPObject);
	dwExtraThreads = dwNumThreads % NUM_CPUS(pDPTPObject);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

	if (pDPTPObject->dwFlags & DPTPOBJECTFLAG_THREADCOUNTCHANGING)
	{
		AssertCriticalSectionIsTakenByThisThread(&pDPTPObject->csLock, FALSE);
	}
	else
	{
		AssertCriticalSectionIsTakenByThisThread(&pDPTPObject->csLock, TRUE);
	}

	//
	// Loop through each of the CPU specific work queues and adjust their
	// thread counts.
	//
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	dwTemp = 0;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	for(dwTemp = 0; dwTemp < NUM_CPUS(pDPTPObject); dwTemp++)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
	{
		pWorkQueue = WORKQUEUE_FOR_CPU(pDPTPObject, dwTemp);
		dwDelta = dwNumThreadsPerProcessor - pWorkQueue->dwNumRunningThreads;
		if (dwTemp < dwExtraThreads)
		{
			dwDelta++;
		}

		if ((int) dwDelta > 0)
		{
			//
			// We need to add threads.
			//
			hr = StartThreads(pWorkQueue, dwDelta);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't start %u threads!", dwDelta);
				goto Exit;
			}
		}
		else if ((int) dwDelta < 0)
		{
			//
			// We need to remove threads.
			//
			dwDelta = (int) dwDelta * -1;	// get absolute value
			hr = StopThreads(pWorkQueue, dwDelta);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't stop %u threads!", dwDelta);
				goto Exit;
			}
		}
		else
		{
			//
			// The thread count is already correct.
			//
		}

		if (dwTemp < dwExtraThreads)
		{
			DNASSERT(pWorkQueue->dwNumRunningThreads == (dwNumThreadsPerProcessor + 1));
		}
		else
		{
			DNASSERT(pWorkQueue->dwNumRunningThreads == dwNumThreadsPerProcessor);
		}
	}


Exit:

	return hr;
} // SetTotalNumberOfThreads

#endif // ! DPNBUILD_ONLYONETHREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpoolapi.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threadpoolapi.h
 *
 *  Content:	DirectPlay Thread Pool API implementation header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  11/02/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __THREADPOOLAPI_H__
#define __THREADPOOLAPI_H__




//=============================================================================
// Macros
//=============================================================================
#ifdef DPNBUILD_ONLYONEPROCESSOR
#define NUM_CPUS(pDPTPObject)							1
#define WORKQUEUE_FOR_CPU(pDPTPObject, dwCPUNum)		(&(pDPTPObject)->WorkQueue)
#else // ! DPNBUILD_ONLYONEPROCESSOR
#define NUM_CPUS(pDPTPObject)							(pDPTPObject)->dwNumCPUs
#define WORKQUEUE_FOR_CPU(pDPTPObject, dwCPUNum)		(pDPTPObject)->papCPUWorkQueues[dwCPUNum]
#endif // ! DPNBUILD_ONLYONEPROCESSOR








//=============================================================================
// Thread pool interface object flags
//=============================================================================
#define DPTPOBJECTFLAG_USER_INITIALIZED			0x00000001	// the user interface has been initialized
#define DPTPOBJECTFLAG_USER_DOINGWORK			0x00000002	// the user interface is currently calling the DoWork method
#ifndef DPNBUILD_NOPARAMVAL
#define DPTPOBJECTFLAG_USER_PARAMVALIDATION		0x00008000	// the user interface should perform parameter validation
#endif // ! DPNBUILD_NOPARAMVAL
#ifndef DPNBUILD_ONLYONETHREAD
#define DPTPOBJECTFLAG_THREADCOUNTCHANGING		0x00010000	// threads are currently being added or removed
#endif // ! DPNBUILD_ONLYONETHREAD


//=============================================================================
// Thread pool interface object
//=============================================================================
typedef struct _DPTHREADPOOLOBJECT
{
#ifdef DPNBUILD_LIBINTERFACE
	//
	//	For lib interface builds, the interface Vtbl and refcount are embedded
	// in the object itself.
	//
	LPVOID				lpVtbl;							// must be first entry in structure
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (defined(DPNBUILD_MULTIPLETHREADPOOLS)))
	LONG				lRefCount;						// reference count for object
#endif // ! DPNBUILD_ONLYONETHREAD or DPNBUILD_MULTIPLETHREADPOOLS
#endif // DPNBUILD_LIBINTERFACE
	BYTE				Sig[4];							// debugging signature ('DPTP')
	DWORD				dwFlags;						// flags describing this thread pool object
#ifdef DPNBUILD_ONLYONEPROCESSOR
	DPTPWORKQUEUE		WorkQueue;						// work queue structure for only CPU
#else // ! DPNBUILD_ONLYONEPROCESSOR
	DWORD				dwNumCPUs;						// number of CPUs in this machine
	DPTPWORKQUEUE **	papCPUWorkQueues;				// pointer to array of work queue structure pointers for each CPU
	DWORD				dwCurrentCPUSelection;			// current CPU selection for items that can be run on any processor
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifdef DPNBUILD_ONLYONETHREAD
	DWORD				dwWorkRecursionCount;			// how many times DoWork, WaitWhileWorking, or SleepWhileWorking have been recursively called
#else // ! DPNBUILD_ONLYONETHREAD
	DWORD				dwTotalUserThreadCount;			// the sum of what the user requested for thread counts for all processors, or -1 if unknown
	DWORD				dwTotalDesiredWorkThreadCount;	// the maximum number of threads requested via the work interface, or -1 if unknown
	DWORD				dwWorkRecursionCountTlsIndex;	// Thread Local Storage index for storing the Work recursion count for non-worker threads
	LONG				lNumThreadCountChangeWaiters;	// number of threads waiting for an existing thread to complete its thread count change
	DNHANDLE			hThreadCountChangeComplete;		// semaphore to be signalled when the existing thread completes the thread count change
#endif // ! DPNBUILD_ONLYONETHREAD
#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_NOPARAMVAL)))
	DWORD				dwCurrentDoWorkThreadID;		// ID of the current thread inside DoWork
#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_NOPARAMVAL
#ifndef DPNBUILD_ONLYONETHREAD
	DNCRITICAL_SECTION	csLock;							// lock protecting this object
#ifdef DPNBUILD_MANDATORYTHREADS
	DWORD				dwMandatoryThreadCount;			// number of mandatory threads currently active
#ifdef DBG
	CBilink				blMandatoryThreads;				// list of mandatory threads that are currently active
#endif // DBG
#endif // DPNBUILD_MANDATORYTHREADS
#endif // !DPNBUILD_ONLYONETHREAD
} DPTHREADPOOLOBJECT, * PDPTHREADPOOLOBJECT;




//=============================================================================
// Interface functions
//=============================================================================

#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_LIBINTERFACE)))

//
// IDirectPlay8ThreadPool
//

STDMETHODIMP DPTP_Initialize(IDirectPlay8ThreadPool * pInterface,
							PVOID const pvUserContext,
							const PFNDPNMESSAGEHANDLER pfn,
							const DWORD dwFlags);

STDMETHODIMP DPTP_Close(IDirectPlay8ThreadPool * pInterface,
						const DWORD dwFlags);

STDMETHODIMP DPTP_GetThreadCount(IDirectPlay8ThreadPool * pInterface,
								const DWORD dwProcessorNum,
								DWORD * const pdwNumThreads,
								const DWORD dwFlags);

STDMETHODIMP DPTP_SetThreadCount(IDirectPlay8ThreadPool * pInterface,
								const DWORD dwProcessorNum,
								const DWORD dwNumThreads,
								const DWORD dwFlags);

#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_LIBINTERFACE


#ifdef DPNBUILD_LIBINTERFACE
STDMETHODIMP DPTP_DoWork(const DWORD dwAllowedTimeSlice,
						const DWORD dwFlags);
#else // ! DPNBUILD_LIBINTERFACE
STDMETHODIMP DPTP_DoWork(IDirectPlay8ThreadPool * pInterface,
						const DWORD dwAllowedTimeSlice,
						const DWORD dwFlags);
#endif // ! DPNBUILD_LIBINTERFACE



//
// IDirectPlay8ThreadPoolWork
//

STDMETHODIMP DPTPW_QueueWorkItem(IDirectPlay8ThreadPoolWork * pInterface,
								const DWORD dwCPU,
								const PFNDPTNWORKCALLBACK pfnWorkCallback,
								PVOID const pvCallbackContext,
								const DWORD dwFlags);

STDMETHODIMP DPTPW_ScheduleTimer(IDirectPlay8ThreadPoolWork * pInterface,
								const DWORD dwCPU,
								const DWORD dwDelay,
								const PFNDPTNWORKCALLBACK pfnWorkCallback,
								PVOID const pvCallbackContext,
								void ** const ppvTimerData,
								UINT * const puiTimerUnique,
								const DWORD dwFlags);

STDMETHODIMP DPTPW_StartTrackingFileIo(IDirectPlay8ThreadPoolWork * pInterface,
										const DWORD dwCPU,
										const HANDLE hFile,
										const DWORD dwFlags);

STDMETHODIMP DPTPW_StopTrackingFileIo(IDirectPlay8ThreadPoolWork * pInterface,
									const DWORD dwCPU,
									const HANDLE hFile,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_CreateOverlapped(IDirectPlay8ThreadPoolWork * pInterface,
									const DWORD dwCPU,
									const PFNDPTNWORKCALLBACK pfnWorkCallback,
									PVOID const pvCallbackContext,
									OVERLAPPED ** const ppOverlapped,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_SubmitIoOperation(IDirectPlay8ThreadPoolWork * pInterface,
									OVERLAPPED * const pOverlapped,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_ReleaseOverlapped(IDirectPlay8ThreadPoolWork * pInterface,
									OVERLAPPED * const pOverlapped,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_CancelTimer(IDirectPlay8ThreadPoolWork * pInterface,
								void * const pvTimerData,
								const UINT uiTimerUnique,
								const DWORD dwFlags);

STDMETHODIMP DPTPW_ResetCompletingTimer(IDirectPlay8ThreadPoolWork * pInterface,
										void * const pvTimerData,
										const DWORD dwNewDelay,
										const PFNDPTNWORKCALLBACK pfnNewWorkCallback,
										PVOID const pvNewCallbackContext,
										UINT * const puiNewTimerUnique,
										const DWORD dwFlags);

STDMETHODIMP DPTPW_WaitWhileWorking(IDirectPlay8ThreadPoolWork * pInterface,
									const HANDLE hWaitObject,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_SleepWhileWorking(IDirectPlay8ThreadPoolWork * pInterface,
									const DWORD dwTimeout,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_RequestTotalThreadCount(IDirectPlay8ThreadPoolWork * pInterface,
											const DWORD dwNumThreads,
											const DWORD dwFlags);

STDMETHODIMP DPTPW_GetThreadCount(IDirectPlay8ThreadPoolWork * pInterface,
									const DWORD dwCPU,
									DWORD * const pdwNumThreads,
									const DWORD dwFlags);

STDMETHODIMP DPTPW_GetWorkRecursionDepth(IDirectPlay8ThreadPoolWork * pInterface,
										DWORD * const pdwDepth,
										const DWORD dwFlags);

STDMETHODIMP DPTPW_Preallocate(IDirectPlay8ThreadPoolWork * pInterface,
								const DWORD dwNumWorkItems,
								const DWORD dwNumTimers,
								const DWORD dwNumIoOperations,
								const DWORD dwFlags);

#ifdef DPNBUILD_MANDATORYTHREADS
STDMETHODIMP DPTPW_CreateMandatoryThread(IDirectPlay8ThreadPoolWork * pInterface,
										LPSECURITY_ATTRIBUTES lpThreadAttributes,
										SIZE_T dwStackSize,
										LPTHREAD_START_ROUTINE lpStartAddress,
										LPVOID lpParameter,
										LPDWORD lpThreadId,
										HANDLE *const phThread,
										const DWORD dwFlags);
#endif // DPNBUILD_MANDATORYTHREADS




#endif // __THREADPOOLAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\io.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       io.h
 *
 *  Content:	DirectPlay Thread Pool I/O functions header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __IO_H__
#define __IO_H__



// Overlapped I/O is not supported on Windows CE.
#ifndef WINCE



//=============================================================================
// External Globals
//=============================================================================
extern CFixedPool	g_TrackedFilePool;




//=============================================================================
// Classes
//=============================================================================

class CTrackedFile
{
	public:

#undef DPF_MODNAME
#define DPF_MODNAME "CTrackedFile::FPM_Alloc"
		static BOOL FPM_Alloc(void * pvItem, void * pvContext)
		{
			CTrackedFile *		pTrackedFile = (CTrackedFile*) pvItem;


			pTrackedFile->m_Sig[0] = 'T';
			pTrackedFile->m_Sig[1] = 'K';
			pTrackedFile->m_Sig[2] = 'F';
			pTrackedFile->m_Sig[3] = 'L';

			pTrackedFile->m_blList.Initialize();
			pTrackedFile->m_hFile = DNINVALID_HANDLE_VALUE;

			return TRUE;
		}

		/*
#undef DPF_MODNAME
#define DPF_MODNAME "CTrackedFile::FPM_Get"
		static void FPM_Get(void * pvItem, void * pvContext)
		{
			CTrackedFile *		pTrackedFile = (CTrackedFile*) pvItem;
		}

#undef DPF_MODNAME
#define DPF_MODNAME "CTrackedFile::FPM_Release"
		static void FPM_Release(void * pvItem)
		{
			CTrackedFile *		pTrackedFile = (CTrackedFile*) pvItem;
		}

#undef DPF_MODNAME
#define DPF_MODNAME "CTrackedFile::FPM_Dealloc"
		static void FPM_Dealloc(void * pvItem)
		{
			CTrackedFile *		pTrackedFile = (CTrackedFile*) pvItem;
		}
		*/

#ifdef DBG
		BOOL IsValid(void)
		{
			if ((m_Sig[0] == 'T') &&
				(m_Sig[1] == 'K') &&
				(m_Sig[2] == 'F') &&
				(m_Sig[3] == 'L'))
			{
				return TRUE;
			}

			return FALSE;
		}
#endif // DBG


		BYTE		m_Sig[4];	// debugging signature ('TKFL')
		CBilink		m_blList;	// entry in list of tracked handles
		DNHANDLE	m_hFile;	// handle to file
};




//=============================================================================
// Function prototypes
//=============================================================================
HRESULT InitializeWorkQueueIoInfo(DPTPWORKQUEUE * const pWorkQueue);

void DeinitializeWorkQueueIoInfo(DPTPWORKQUEUE * const pWorkQueue);

HRESULT StartTrackingFileIo(DPTPWORKQUEUE * const pWorkQueue,
						const HANDLE hFile);

HRESULT StopTrackingFileIo(DPTPWORKQUEUE * const pWorkQueue,
						const HANDLE hFile);

void CancelIoForThisThread(DPTPWORKQUEUE * const pWorkQueue);

CWorkItem * CreateOverlappedIoWorkItem(DPTPWORKQUEUE * const pWorkQueue,
									const PFNDPTNWORKCALLBACK pfnWorkCallback,
									PVOID const pvCallbackContext);

void ReleaseOverlappedIoWorkItem(DPTPWORKQUEUE * const pWorkQueue,
								CWorkItem * const pWorkItem);

#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
void SubmitIoOperation(DPTPWORKQUEUE * const pWorkQueue,
						CWorkItem * const pWorkItem);

void ProcessIo(DPTPWORKQUEUE * const pWorkQueue,
				DNSLIST_ENTRY ** const ppHead,
				DNSLIST_ENTRY ** const ppTail,
				USHORT * const pusCount);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS



#endif // ! WINCE



#endif // __IO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpoolclassfac.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threadpoolclassfac.h
 *
 *  Content:	DirectPlay Thread Pool class factory functions header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  11/02/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __THREADPOOLCLASSFAC_H__
#define __THREADPOOLCLASSFAC_H__



//=============================================================================
// External Functions
//=============================================================================
#ifdef DPNBUILD_LIBINTERFACE
#if ((defined(DPNBUILD_ONLYONETHREAD)) && (! defined(DPNBUILD_MULTIPLETHREADPOOLS)))
void DPTPCF_GetObject(PVOID * ppv);
HRESULT DPTPCF_FreeObject(PVOID pvObject);
#endif // DPNBUILD_ONLYONETHREAD and ! DPNBUILD_MULTIPLETHREADPOOLS
HRESULT DPTPCF_CreateObject(PVOID * ppv);
#endif // DPNBUILD_LIBINTERFACE



//=============================================================================
// External globals
//=============================================================================
#ifndef DPNBUILD_LIBINTERFACE
extern IUnknownVtbl						DPTP_UnknownVtbl;
extern IClassFactoryVtbl				DPTPCF_Vtbl;
#endif // ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_ONLYONETHREAD
extern IDirectPlay8ThreadPoolVtbl		DPTP_Vtbl;
#endif // ! DPNBUILD_ONLYONETHREAD
extern IDirectPlay8ThreadPoolWorkVtbl	DPTPW_Vtbl;






#endif // __THREADPOOLCLASSFAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\io.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		io.cpp
 *
 *  Content:	DirectPlay Thread Pool I/O functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"




// Overlapped I/O is not supported on Windows CE.
#ifndef WINCE
//=============================================================================
// Macros
//=============================================================================
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#define DNHasOverlappedIoCompleted(pOverlapped)		((pOverlapped)->OffsetHigh != HRESULT_FROM_WIN32(ERROR_IO_PENDING))
#else // ! _XBOX or XBOX_ON_DESKTOP
#define DNHasOverlappedIoCompleted(pOverlapped)		HasOverlappedIoCompleted(pOverlapped)
#endif // ! _XBOX or XBOX_ON_DESKTOP




//=============================================================================
// Globals
//=============================================================================
CFixedPool		g_TrackedFilePool;






#undef DPF_MODNAME
#define DPF_MODNAME "InitializeWorkQueueIoInfo"
//=============================================================================
// InitializeWorkQueueIoInfo
//-----------------------------------------------------------------------------
//
// Description:    Initializes the I/O info for the given work queue.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to initialize.
//
// Returns: HRESULT
//	DPN_OK				- Successfully initialized the work queue object's
//							I/O information.
//	DPNERR_OUTOFMEMORY	- Failed to allocate memory while initializing.
//=============================================================================
HRESULT InitializeWorkQueueIoInfo(DPTPWORKQUEUE * const pWorkQueue)
{
	HRESULT		hr = DPN_OK;


	DNInitializeSListHead(&pWorkQueue->SlistOutstandingIO);
	pWorkQueue->blTrackedFiles.Initialize();

	return hr;
} // InitializeWorkQueueIoInfo




#undef DPF_MODNAME
#define DPF_MODNAME "DeinitializeWorkQueueIoInfo"
//=============================================================================
// DeinitializeWorkQueueIoInfo
//-----------------------------------------------------------------------------
//
// Description:    Cleans up work queue I/O info.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to initialize.
//
// Returns: Nothing.
//=============================================================================
void DeinitializeWorkQueueIoInfo(DPTPWORKQUEUE * const pWorkQueue)
{
	DNASSERT(DNInterlockedFlushSList(&pWorkQueue->SlistOutstandingIO) == NULL);
	DNASSERT(pWorkQueue->blTrackedFiles.IsEmpty());
} // DeinitializeWorkQueueIoInfo




#undef DPF_MODNAME
#define DPF_MODNAME "StartTrackingFileIo"
//=============================================================================
// StartTrackingFileIo
//-----------------------------------------------------------------------------
//
// Description:    Starts tracking overlapped I/O for a given file handle on
//				the specified work queue.  The handle is not duplicated
//				and it should remain valid until StopTrackingFileIo is called.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	HANDLE hFile				- Handle of file to track.
//
// Returns: HRESULT
//	DPN_OK						- Starting tracking for the file was successful.
//	DPNERR_ALREADYREGISTERED	- The specified file handle is already being
//									tracked.
//	DPNERR_OUTOFMEMORY			- Not enough memory to track the file.
//=============================================================================
HRESULT StartTrackingFileIo(DPTPWORKQUEUE * const pWorkQueue,
							const HANDLE hFile)
{
	HRESULT			hr;
	CTrackedFile *	pTrackedFile;
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	HANDLE			hIoCompletionPort;
#endif // DPNBUILD_USEIOCOMPLETIONPORTS
#ifdef DBG
	CBilink *		pBilink;
	CTrackedFile *	pTrackedFileTemp;
#endif // DBG


	//
	// Get a tracking container from the pool.
	//
	pTrackedFile = (CTrackedFile*) g_TrackedFilePool.Get(pWorkQueue);
	if (pTrackedFile == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't get item for tracking file 0x%p!",
			hFile);
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	pTrackedFile->m_hFile = MAKE_DNHANDLE(hFile);


#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	//
	// Associate the file with the I/O completion port.
	//
	hIoCompletionPort = CreateIoCompletionPort(hFile,
												HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
												0,
												1);
	if (hIoCompletionPort != HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort))
	{
#ifdef DBG
		DWORD	dwError;

		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't associate file 0x%p with I/O completion port 0x%p (err = %u)!",
			hFile, pWorkQueue->hIoCompletionPort, dwError);
#endif // DBG
#pragma BUGBUG(vanceo, "Can't fail because of our hack")
		//hr = DPNERR_GENERIC;
		//goto Failure;
	}
#endif // DPNBUILD_USEIOCOMPLETIONPORTS


	DPFX(DPFPREP, 7, "Work queue 0x%p starting to tracking I/O for file 0x%p using object 0x%p.",
		pWorkQueue, hFile, pTrackedFile);

	//
	// Add the item to the list.
	//

	DNEnterCriticalSection(&pWorkQueue->csListLock);

#ifdef DBG
	//
	// Assert that the handle isn't already being tracked.
	//
	pBilink = pWorkQueue->blTrackedFiles.GetNext();
	while (pBilink != &pWorkQueue->blTrackedFiles)
	{
		pTrackedFileTemp = CONTAINING_OBJECT(pBilink, CTrackedFile, m_blList);
		DNASSERT(pTrackedFileTemp->IsValid());
		DNASSERT(HANDLE_FROM_DNHANDLE(pTrackedFileTemp->m_hFile) != hFile);
		pBilink = pBilink->GetNext();
	}
#endif // DBG

	pTrackedFile->m_blList.InsertBefore(&pWorkQueue->blTrackedFiles);
	DNLeaveCriticalSection(&pWorkQueue->csListLock);

	hr = DPN_OK;


Exit:

	return hr;

Failure:

	if (pTrackedFile != NULL)
	{
		g_TrackedFilePool.Release(pTrackedFile);
		pTrackedFile = NULL;
	}

	goto Exit;
} // StartTrackingFileIo




#undef DPF_MODNAME
#define DPF_MODNAME "StopTrackingFileIo"
//=============================================================================
// StopTrackingFileIo
//-----------------------------------------------------------------------------
//
// Description:    Stops tracking overlapped I/O for a given file handle on
//				the specified work queue.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	HANDLE hFile				- Handle of file to stop tracking.
//
// Returns: HRESULT
//	DPN_OK					- Stopping tracking for the file was successful.
//	DPNERR_INVALIDHANDLE	- File handle was not being tracked.
//=============================================================================
HRESULT StopTrackingFileIo(DPTPWORKQUEUE * const pWorkQueue,
							const HANDLE hFile)
{
	HRESULT			hr = DPNERR_INVALIDHANDLE;
	CBilink *		pBilink;
	CTrackedFile *	pTrackedFile;


	DNEnterCriticalSection(&pWorkQueue->csListLock);
	pBilink = pWorkQueue->blTrackedFiles.GetNext();
	while (pBilink != &pWorkQueue->blTrackedFiles)
	{
		pTrackedFile = CONTAINING_OBJECT(pBilink, CTrackedFile, m_blList);
		DNASSERT(pTrackedFile->IsValid());
		pBilink = pBilink->GetNext();

		if (HANDLE_FROM_DNHANDLE(pTrackedFile->m_hFile) == hFile)
		{
			DPFX(DPFPREP, 7, "Work queue 0x%p no longer tracking I/O for file 0x%p under object 0x%p.",
				pWorkQueue, hFile, pTrackedFile);
			REMOVE_DNHANDLE(pTrackedFile->m_hFile);
			pTrackedFile->m_blList.RemoveFromList();
			g_TrackedFilePool.Release(pTrackedFile);
			pTrackedFile = NULL;
			hr = DPN_OK;
			break;
		}
	}
	DNLeaveCriticalSection(&pWorkQueue->csListLock);

	return hr;
} // StopTrackingFileIo




#undef DPF_MODNAME
#define DPF_MODNAME "CancelIoForThisThread"
//=============================================================================
// CancelIoForThisThread
//-----------------------------------------------------------------------------
//
// Description:    Cancels asynchronous I/O operations submitted by this thread
//				for all tracked files.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object owning this
//									thread.
//
// Returns: None.
//=============================================================================
void CancelIoForThisThread(DPTPWORKQUEUE * const pWorkQueue)
{
	CBilink *		pBilink;
	CTrackedFile *	pTrackedFile;
	BOOL			fResult;


	DNEnterCriticalSection(&pWorkQueue->csListLock);
	pBilink = pWorkQueue->blTrackedFiles.GetNext();
	while (pBilink != &pWorkQueue->blTrackedFiles)
	{
		pTrackedFile = CONTAINING_OBJECT(pBilink, CTrackedFile, m_blList);
		DNASSERT(pTrackedFile->IsValid());

		DPFX(DPFPREP, 3, "Cancelling file 0x%p I/O for this thread (queue = 0x%p).",
			HANDLE_FROM_DNHANDLE(pTrackedFile->m_hFile), pWorkQueue);

		fResult = CancelIo(HANDLE_FROM_DNHANDLE(pTrackedFile->m_hFile));
		if (! fResult)
		{
#ifdef DBG
			DWORD	dwError;

			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't cancel file 0x%p I/O for this thread (err = %u)!",
				HANDLE_FROM_DNHANDLE(pTrackedFile->m_hFile), dwError);
#endif // DBG

			//
			// Continue...
			//
		}

		pBilink = pBilink->GetNext();
	}
	DNLeaveCriticalSection(&pWorkQueue->csListLock);
} // CancelIoForThisThread





#undef DPF_MODNAME
#define DPF_MODNAME "CreateOverlappedIoWorkItem"
//=============================================================================
// CreateOverlappedIoWorkItem
//-----------------------------------------------------------------------------
//
// Description:    Creates a new asynchronous I/O operation work item for the
//				work queue.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue			- Pointer to work queue object to use.
//	PFNDPTNWORKCALLBACK pfnWorkCallback	- Callback to execute when operation
//											completes.
//	PVOID pvCallbackContext				- User specified context to pass to
//											callback.
//
// Returns: Pointer to work item, or NULL if couldn't allocate memory.
//=============================================================================
CWorkItem * CreateOverlappedIoWorkItem(DPTPWORKQUEUE * const pWorkQueue,
									const PFNDPTNWORKCALLBACK pfnWorkCallback,
									PVOID const pvCallbackContext)
{
	CWorkItem *		pWorkItem;


	//
	// Get an entry from the pool.
	//
	pWorkItem = (CWorkItem*) pWorkQueue->pWorkItemPool->Get(pWorkQueue);
	if (pWorkItem != NULL)
	{
		//
		// Initialize the work item.
		//

		pWorkItem->m_pfnWorkCallback			= pfnWorkCallback;
		pWorkItem->m_pvCallbackContext			= pvCallbackContext;

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
		pWorkItem->m_Overlapped.hEvent			= NULL;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
		pWorkItem->m_Overlapped.hEvent			= HANDLE_FROM_DNHANDLE(pWorkQueue->hAlertEvent);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

#ifdef DBG
		pWorkItem->m_fCancelledOrCompleting		= TRUE;
#endif // DBG

		DPFX(DPFPREP, 7, "New work item = 0x%p, overlapped = 0x%p, queue = 0x%p.",
			pWorkItem, &pWorkItem->m_Overlapped, pWorkQueue);

		ThreadpoolStatsCreate(pWorkItem);
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
		ThreadpoolStatsQueue(pWorkItem);	// we can't tell when completion port I/O gets queued
#endif // DPNBUILD_USEIOCOMPLETIONPORTS
	}

	return pWorkItem;
} // CreateOverlappedIoWorkItem




#undef DPF_MODNAME
#define DPF_MODNAME "ReleaseOverlappedIoWorkItem"
//=============================================================================
// ReleaseOverlappedIoWorkItem
//-----------------------------------------------------------------------------
//
// Description:    Returns an unused asynchronous I/O operation work item back
//				to the pool.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	CWorkItem * pWorkItem		- Pointer to work item with overlapped
//									structure that is no longer needed.
//
// Returns: None.
//=============================================================================
void ReleaseOverlappedIoWorkItem(DPTPWORKQUEUE * const pWorkQueue,
								CWorkItem * const pWorkItem)
{
	DPFX(DPFPREP, 7, "Returning work item = 0x%p, overlapped = 0x%p, queue = 0x%p.",
		pWorkItem, &pWorkItem->m_Overlapped, pWorkQueue);

	pWorkQueue->pWorkItemPool->Release(pWorkItem);
} // ReleaseOverlappedIoWorkItem





#ifndef DPNBUILD_USEIOCOMPLETIONPORTS

#undef DPF_MODNAME
#define DPF_MODNAME "SubmitIoOperation"
//=============================================================================
// SubmitIoOperation
//-----------------------------------------------------------------------------
//
// Description:    Submits a new asynchronous I/O operation work item to the
//				work queue to be monitored for completion.
//
//				   This is only necessary when not using I/O completion ports.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	CWorkItem * pWorkItem		- Pointer to work item with overlapped
//									structure used by OS and completion
//									callback information.
//
// Returns: None.
//=============================================================================
void SubmitIoOperation(DPTPWORKQUEUE * const pWorkQueue,
						CWorkItem * const pWorkItem)
{
	//
	// The caller must have pre-populated the overlapped structure's hEvent
	// field with the work queue's alert event.
	//
	DNASSERT(pWorkItem != NULL);
	DNASSERT(pWorkItem->m_Overlapped.hEvent == HANDLE_FROM_DNHANDLE(pWorkQueue->hAlertEvent));

	DNASSERT(pWorkItem->m_fCancelledOrCompleting);


	DPFX(DPFPREP, 5, "Submitting I/O work item 0x%p (context = 0x%p, fn = 0x%p, queue = 0x%p).",
		pWorkItem, pWorkItem->m_pvCallbackContext, pWorkItem->m_pfnWorkCallback,
		pWorkQueue);

	//
	// Push this I/O onto the watch list.
	//
	DNInterlockedPushEntrySList(&pWorkQueue->SlistOutstandingIO,
								&pWorkItem->m_SlistEntry);
} // SubmitIoOperation




#undef DPF_MODNAME
#define DPF_MODNAME "ProcessIo"
//=============================================================================
// ProcessIo
//-----------------------------------------------------------------------------
//
// Description:    Queues any completed I/O operations as work items in the
//				passed in list pointers.  The new work items are added without
//				using Interlocked functions
//
//				   This is only necessary when not using I/O completion ports.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	DNSLIST_ENTRY ** ppHead		- Pointer to initial list head pointer, and
//									place to store new head pointer.
//	DNSLIST_ENTRY ** ppTail		- Pointer to existing list tail pointer, or
//									place to store new tail pointer.
//	USHORT * pusCount			- Pointer to existing list count, it will be
//									updated to reflect new items.
//
// Returns: Nothing.
//=============================================================================
void ProcessIo(DPTPWORKQUEUE * const pWorkQueue,
				DNSLIST_ENTRY ** const ppHead,
				DNSLIST_ENTRY ** const ppTail,
				USHORT * const pusCount)
{
	DNSLIST_ENTRY *		pSlistEntryHeadNotComplete = NULL;
	USHORT				usCountNotComplete = 0;
	DNSLIST_ENTRY *		pSlistEntryTailNotComplete = NULL;
	DNSLIST_ENTRY *		pSlistEntry;
	CWorkItem *			pWorkItem;


	//
	// Pop off the entire list of I/O, and check it for completions.
	//
	pSlistEntry = DNInterlockedFlushSList(&pWorkQueue->SlistOutstandingIO);
	while (pSlistEntry != NULL)
	{
		pWorkItem = CONTAINING_OBJECT(pSlistEntry, CWorkItem, m_SlistEntry);
		pSlistEntry = pSlistEntry->Next;


		//
		// If the I/O operation is complete, then queue it as a work item.
		// Otherwise, put it back in the list.
		//
		if (DNHasOverlappedIoCompleted(&pWorkItem->m_Overlapped))
		{
			DPFX(DPFPREP, 5, "Queueing I/O work item 0x%p for completion on queue 0x%p, (Internal = 0x%x, InternalHigh = 0x%x, Offset = 0x%x, OffsetHigh = 0x%x).",
				pWorkItem, pWorkQueue,
				pWorkItem->m_Overlapped.Internal,
				pWorkItem->m_Overlapped.InternalHigh,
				pWorkItem->m_Overlapped.Offset,
				pWorkItem->m_Overlapped.OffsetHigh);
			
			ThreadpoolStatsQueue(pWorkItem);

			//
			// Add it to the caller's list.
			//
			if ((*ppHead) == NULL)
			{
				*ppTail = &pWorkItem->m_SlistEntry;
			}
			pWorkItem->m_SlistEntry.Next = *ppHead;
			*ppHead = &pWorkItem->m_SlistEntry;
			*pusCount = (*pusCount) + 1;
		}
		else
		{
			//DPFX(DPFPREP, 9, "Putting I/O work item 0x%p back into list.", pWorkItem);

			//
			// Add it to our local "not complete" list.
			//
			if (pSlistEntryHeadNotComplete == NULL)
			{
				pSlistEntryTailNotComplete = &pWorkItem->m_SlistEntry;
			}
			pWorkItem->m_SlistEntry.Next = pSlistEntryHeadNotComplete;
			pSlistEntryHeadNotComplete = &pWorkItem->m_SlistEntry;
			usCountNotComplete++;
		}
	}

	//
	// If we encountered any I/O that hadn't completed, put it all back on the
	// list in one fell swoop.
	//
	if (pSlistEntryHeadNotComplete != NULL)
	{
		DNInterlockedPushListSList(&pWorkQueue->SlistOutstandingIO,
									pSlistEntryHeadNotComplete,
									pSlistEntryTailNotComplete,
									usCountNotComplete);
	}
} // ProcessIo

#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS


#endif // ! WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpooldllmain.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		threadpooldllmain.cpp
 *
 *  Content:	DirectPlay Thread Pool DllMain functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  11/02/01  VanceO    Created.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"



//=============================================================================
// External globals
//=============================================================================
#ifndef DPNBUILD_LIBINTERFACE
LONG					g_lDPTPInterfaceCount = 0;	// number of thread pool interfaces outstanding
#endif // ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_MULTIPLETHREADPOOLS
#ifndef DPNBUILD_ONLYONETHREAD
DNCRITICAL_SECTION		g_csGlobalThreadPoolLock;	// lock protecting the following globals
#endif // !DPNBUILD_ONLYONETHREAD
DWORD					g_dwDPTPRefCount = 0;		// number of references on the global thread pool object
DPTHREADPOOLOBJECT *	g_pDPTPObject = NULL;		// pointer to the global thread pool object
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS





#undef DPF_MODNAME
#define DPF_MODNAME "DPThreadPoolInit"
//=============================================================================
// DPThreadPoolInit
//-----------------------------------------------------------------------------
//
// Description:    Performs any DLL initialization necessary.
//
// Arguments: None.
//
// Returns: BOOL
//	TRUE	- Initialization was successful.
//	FALSE	- An error prevented initialization.
//=============================================================================
BOOL DPThreadPoolInit(HANDLE hModule)
{
#ifndef WINCE
	BOOL					fInittedTrackedFilePool = FALSE;
#endif // ! WINCE
#ifndef DPNBUILD_MULTIPLETHREADPOOLS
	BOOL					fInittedGlobalThreadPoolLock = FALSE;
#ifdef DPNBUILD_LIBINTERFACE
	HRESULT					hr;
	DPTHREADPOOLOBJECT *	pDPTPObject = NULL;
#endif // DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS


#ifndef WINCE
	if (! g_TrackedFilePool.Initialize(sizeof(CTrackedFile),
										CTrackedFile::FPM_Alloc,
										NULL,
										NULL,
										NULL))
	{
		DPFX(DPFPREP, 0, "Couldn't initialize tracked file pool!");
		goto Failure;
	}
	fInittedTrackedFilePool = TRUE;
#endif // ! WINCE

#ifndef DPNBUILD_MULTIPLETHREADPOOLS
	if (! DNInitializeCriticalSection(&g_csGlobalThreadPoolLock))
	{
		DPFX(DPFPREP, 0, "Couldn't initialize global thread pool lock!");
		goto Failure;
	}
	fInittedGlobalThreadPoolLock = TRUE;

#ifdef DPNBUILD_LIBINTERFACE
	hr = DPTPCF_CreateObject((PVOID*) (&pDPTPObject));
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create base thread pool object (err = 0x%lx)!", hr);
		goto Failure;
	}

	//
	// Forget about the object, we'll keep an extra reference on it until we
	// shut down.
	//
	pDPTPObject = NULL;
#endif // DPNBUILD_LIBINTERFACE
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

#ifndef DPNBUILD_NOWINMM
	//
	// Set our time resolution to 1ms, ignore failure.
	//
	timeBeginPeriod(1);
#endif // ! DPNBUILD_NOWINMM

	return TRUE;


Failure:

#ifndef DPNBUILD_MULTIPLETHREADPOOLS
#ifdef DPNBUILD_LIBINTERFACE
	if (pDPTPObject != NULL)
	{
		DPTPCF_FreeObject(g_pDPTPObject);
		pDPTPObject;
	}
#endif // DPNBUILD_LIBINTERFACE

	if (fInittedGlobalThreadPoolLock)
	{
		DNDeleteCriticalSection(&g_csGlobalThreadPoolLock);
		fInittedGlobalThreadPoolLock = FALSE;
	}
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

#ifndef WINCE
	if (fInittedTrackedFilePool)
	{
		g_TrackedFilePool.DeInitialize();
		fInittedTrackedFilePool = FALSE;
	}
#endif // ! WINCE

	return FALSE;
} // DPThreadPoolInit



#undef DPF_MODNAME
#define DPF_MODNAME "DPThreadPoolDeInit"
//=============================================================================
// DPThreadPoolDeInit
//-----------------------------------------------------------------------------
//
// Description:    Cleans up any DLL global resources.
//
// Arguments: None.
//
// Returns: Nothing.
//=============================================================================
void DPThreadPoolDeInit(void)
{
#ifndef DPNBUILD_NOWINMM
	timeEndPeriod(1);
#endif // ! DPNBUILD_NOWINMM


#ifndef DPNBUILD_MULTIPLETHREADPOOLS
#ifdef DPNBUILD_LIBINTERFACE
	//
	// Free the thread pool object we've had since initialization.
	//
	DNASSERT(g_pDPTPObject != NULL);
	DPTPCF_FreeObject(g_pDPTPObject);
#endif // DPNBUILD_LIBINTERFACE

	DNDeleteCriticalSection(&g_csGlobalThreadPoolLock);
	DNASSERT(g_dwDPTPRefCount == 0);
	DNASSERT(g_pDPTPObject == NULL);
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS

#ifndef WINCE
	g_TrackedFilePool.DeInitialize();
#endif // ! WINCE
} // DPThreadPoolDeInit



#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "DPThreadPoolRegister"
//=============================================================================
// DPThreadPoolRegister
//-----------------------------------------------------------------------------
//
// Description:    Registers this DLL.
//
// Arguments:
//	LPCWSTR wszDLLName	- Pointer to Unicode DLL name.
//
// Returns: BOOL
//	TRUE	- Registration was successful.
//	FALSE	- An error prevented registration.
//=============================================================================
BOOL DPThreadPoolRegister(LPCWSTR wszDLLName)
{
	BOOL	fReturn = TRUE;


	if (! CRegistry::Register(L"DirectPlay8ThreadPool.1",
								L"DirectPlay8 Thread Pool Object",
								wszDLLName,
								&CLSID_DirectPlay8ThreadPool,
								L"DirectPlay8ThreadPool"))
	{
		DPFX(DPFPREP, 0, "Could not register DirectPlay8ThreadPool object!");
		fReturn = FALSE;
	}

	return fReturn;
} // DPThreadPoolRegister



#undef DPF_MODNAME
#define DPF_MODNAME "DPThreadPoolUnRegister"
//=============================================================================
// DPThreadPoolUnRegister
//-----------------------------------------------------------------------------
//
// Description:    Unregisters this DLL.
//
// Arguments: None.
//
// Returns: BOOL
//	TRUE	- Unregistration was successful.
//	FALSE	- An error prevented unregistration.
//=============================================================================
BOOL DPThreadPoolUnRegister(void)
{
	BOOL	fReturn = TRUE;


	if (! CRegistry::UnRegister(&CLSID_DirectPlay8ThreadPool))
	{
		DPFX(DPFPREP, 0, "Could not register DirectPlay8ThreadPool object!");
		fReturn = FALSE;
	}

	return fReturn;
} // DPThreadPoolRegister

#endif // ! DPNBUILD_NOCOMREGISTER



#ifndef DPNBUILD_LIBINTERFACE

#undef DPF_MODNAME
#define DPF_MODNAME "DPThreadPoolGetRemainingObjectCount"
//=============================================================================
// DPThreadPoolGetRemainingObjectCount
//-----------------------------------------------------------------------------
//
// Description:    Returns the number of objects owned by this DLL that are
//				still outstanding.
//
// Arguments: None.
//
// Returns: DWORD count of objects.
//=============================================================================
DWORD DPThreadPoolGetRemainingObjectCount(void)
{
	return g_lDPTPInterfaceCount;
} // DPThreadPoolGetRemainingObjectCount

#endif // ! DPNBUILD_LIBINTERFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpooldllmain.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threadpooldllmain.h
 *
 *  Content:	DirectPlay Thread Pool DllMain functions header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  11/02/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __THREADPOOLDLLMAIN_H__
#define __THREADPOOLDLLMAIN_H__


//=============================================================================
// Forward declarations
//=============================================================================
typedef struct _DPTHREADPOOLOBJECT	DPTHREADPOOLOBJECT, * PDPTHREADPOOLOBJECT;


//=============================================================================
// External globals
//=============================================================================
#ifndef DPNBUILD_LIBINTERFACE
extern LONG						g_lDPTPInterfaceCount;
#endif // ! DPNBUILD_LIBINTERFACE
#ifndef DPNBUILD_MULTIPLETHREADPOOLS
#ifndef DPNBUILD_ONLYONETHREAD
extern DNCRITICAL_SECTION		g_csGlobalThreadPoolLock;
#endif // !DPNBUILD_ONLYONETHREAD
extern DWORD					g_dwDPTPRefCount;
extern DPTHREADPOOLOBJECT *		g_pDPTPObject;
#endif // ! DPNBUILD_MULTIPLETHREADPOOLS



//=============================================================================
// Functions
//=============================================================================
BOOL DPThreadPoolInit(HANDLE hModule);

void DPThreadPoolDeInit(void);

#ifndef DPNBUILD_NOCOMREGISTER
BOOL DPThreadPoolRegister(LPCWSTR wszDLLName);

BOOL DPThreadPoolUnRegister(void);
#endif // ! DPNBUILD_NOCOMREGISTER

#ifndef DPNBUILD_LIBINTERFACE
DWORD DPThreadPoolGetRemainingObjectCount(void);
#endif // ! DPNBUILD_LIBINTERFACE






#endif // __THREADPOOLDLLMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpoolparamval.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       threadpoolparamval.h
 *
 *  Content:	DirectPlay Thread Pool parameter validation header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  11/02/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __THREADPOOLPARAMVAL_H__
#define __THREADPOOLPARAMVAL_H__



#ifndef DPNBUILD_NOPARAMVAL


//=============================================================================
// Functions
//=============================================================================

#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_LIBINTERFACE)))

//
// IDirectPlay8ThreadPool interface
//
HRESULT DPTPValidateInitialize(IDirectPlay8ThreadPool * pInterface,
							PVOID const pvUserContext,
							const PFNDPNMESSAGEHANDLER pfn,
							const DWORD dwFlags);

HRESULT DPTPValidateClose(IDirectPlay8ThreadPool * pInterface,
							const DWORD dwFlags);

HRESULT DPTPValidateGetThreadCount(IDirectPlay8ThreadPool * pInterface,
									const DWORD dwProcessorNum,
									DWORD * const pdwNumThreads,
									const DWORD dwFlags);

HRESULT DPTPValidateSetThreadCount(IDirectPlay8ThreadPool * pInterface,
									const DWORD dwProcessorNum,
									const DWORD dwNumThreads,
									const DWORD dwFlags);

#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_LIBINTERFACE

#ifdef DPNBUILD_LIBINTERFACE
HRESULT DPTPValidateDoWork(const DWORD dwAllowedTimeSlice,
							const DWORD dwFlags);
#else // ! DPNBUILD_LIBINTERFACE
HRESULT DPTPValidateDoWork(IDirectPlay8ThreadPool * pInterface,
							const DWORD dwAllowedTimeSlice,
							const DWORD dwFlags);
#endif // ! DPNBUILD_LIBINTERFACE



#endif // ! DPNBUILD_NOPARAMVAL


#endif // __THREADPOOLPARAMVAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\timers.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		timers.cpp
 *
 *  Content:	DirectPlay Thread Pool timer functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Based on DPlay Protocol Quick Start Timers.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"




#undef DPF_MODNAME
#define DPF_MODNAME "InitializeWorkQueueTimerInfo"
//=============================================================================
// InitializeWorkQueueTimerInfo
//-----------------------------------------------------------------------------
//
// Description:    Initializes the timer info for the given work queue.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to initialize.
//
// Returns: HRESULT
//	DPN_OK				- Successfully initialized the work queue object's
//							timer information.
//	DPNERR_OUTOFMEMORY	- Failed to allocate memory while initializing.
//=============================================================================
HRESULT InitializeWorkQueueTimerInfo(DPTPWORKQUEUE * const pWorkQueue)
{
	HRESULT			hr;
	DWORD			dwTemp;
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
	LARGE_INTEGER	liDueTime;
	HANDLE			hTimer;
#ifdef DBG
	DWORD			dwError;
#endif // DBG
#endif // WINNT or (WIN95 AND ! DPNBUILD_NOWAITABLETIMERSON9X)


#ifdef DPNBUILD_DYNAMICTIMERSETTINGS
	pWorkQueue->dwTimerBucketGranularity			= DEFAULT_TIMER_BUCKET_GRANULARITY;
	//
	// The granularity must be a power of 2 in order for our ceiling, mask and
	// divisor optimizations to work.
	//
	DNASSERT(! ((pWorkQueue->dwTimerBucketGranularity - 1) & pWorkQueue->dwTimerBucketGranularity));
	pWorkQueue->dwTimerBucketGranularityCeiling		= pWorkQueue->dwTimerBucketGranularity - 1;
	pWorkQueue->dwTimerBucketGranularityFloorMask	= ~(pWorkQueue->dwTimerBucketGranularityCeiling);	// negating the ceiling round factor (which happens to also be the modulo mask) gives us the floor mask
	pWorkQueue->dwTimerBucketGranularityDivisor		= pWorkQueue->dwTimerBucketGranularity >> 1;


	pWorkQueue->dwNumTimerBuckets					= DEFAULT_NUM_TIMER_BUCKETS;
	//
	// The bucket count must be a power of 2 in order for our mask optimizations
	// to work.
	//
	DNASSERT(! ((pWorkQueue->dwNumTimerBuckets - 1) & pWorkQueue->dwNumTimerBuckets));
	pWorkQueue->dwNumTimerBucketsModMask			= pWorkQueue->dwNumTimerBuckets - 1;
#endif // DPNBUILD_DYNAMICTIMERSETTINGS


	//
	// Initialize the last process time, rounding down to the last whole bucket.
	//
	pWorkQueue->dwLastTimerProcessTime				= GETTIMESTAMP() & TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue);
	DPFX(DPFPREP, 7, "Current bucket index = %u at time %u, array time length = %u.",
		((pWorkQueue->dwLastTimerProcessTime / TIMER_BUCKET_GRANULARITY(pWorkQueue)) % NUM_TIMER_BUCKETS(pWorkQueue)),
		pWorkQueue->dwLastTimerProcessTime,
		(TIMER_BUCKET_GRANULARITY(pWorkQueue) * NUM_TIMER_BUCKETS(pWorkQueue)));


	//
	// Allocate the timer bucket array.
	//
	pWorkQueue->paSlistTimerBuckets = (DNSLIST_HEADER*) DNMalloc(NUM_TIMER_BUCKETS(pWorkQueue) * sizeof(DNSLIST_HEADER));
	if (pWorkQueue->paSlistTimerBuckets == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for %u timer buckets!",
			NUM_TIMER_BUCKETS(pWorkQueue));
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Initialize all of the timer buckets.
	//
	for(dwTemp = 0; dwTemp < NUM_TIMER_BUCKETS(pWorkQueue); dwTemp++)
	{
		DNInitializeSListHead(&pWorkQueue->paSlistTimerBuckets[dwTemp]);
	}

#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	pWorkQueue->dwPossibleMissedTimerWindow = 0;
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT


#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
	//
	// Create a waitable timer for the timer thread.
	//
	hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
	if (hTimer == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create waitable timer (err = %u)!", dwError);
#endif // DBG
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pWorkQueue->hTimer = MAKE_DNHANDLE(hTimer);


	//
	// Kick off the waitable timer so that it wakes up every 'granularity'
	// milliseconds.  Tell it not to start until 1 resolution period elapses
	// because there probably aren't any timers yet, and more importantly,
	// there probably aren't any threads that are waiting yet.  Delaying the
	// start hopefully will reduce unnecessary CPU usage.
	//
	// The due-time value is negative because that indicates relative time to
	// SetWaitableTimer, and multiplied by 10000 because it is in 100
	// nanosecond increments.
	//
	liDueTime.QuadPart = -1 * TIMER_BUCKET_GRANULARITY(pWorkQueue) * 10000;
	if (! SetWaitableTimer(HANDLE_FROM_DNHANDLE(pWorkQueue->hTimer),
							&liDueTime,
							TIMER_BUCKET_GRANULARITY(pWorkQueue),
							NULL,
							NULL,
							FALSE))
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create waitable timer (err = %u)!", dwError);
#endif // DBG
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

#pragma TODO(vanceo, "We should avoid setting this timer until there are threads, and stop it when there aren't any")

#endif // WINNT or (WIN95 AND ! DPNBUILD_NOWAITABLETIMERSON9X)



#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Initialize the timer package debugging/tuning statistics.
	//
	pWorkQueue->dwTotalNumTimerChecks				= 0;
	pWorkQueue->dwTotalNumBucketsProcessed			= 0;
	pWorkQueue->dwTotalNumTimersScheduled			= 0;
	pWorkQueue->dwTotalNumLongTimersRescheduled		= 0;
	pWorkQueue->dwTotalNumSuccessfulCancels			= 0;
	pWorkQueue->dwTotalNumFailedCancels				= 0;
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	pWorkQueue->dwTotalPossibleMissedTimerWindows	= 0;
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT
#endif // DPNBUILD_THREADPOOLSTATISTICS

	hr = DPN_OK;

Exit:

	return hr;

Failure:

#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
	if (pWorkQueue->hTimer != NULL)
	{
		DNCloseHandle(pWorkQueue->hTimer);
		pWorkQueue->hTimer = NULL;
	}
#endif // WINNT or (WIN95 AND ! DPNBUILD_NOWAITABLETIMERSON9X)

	if (pWorkQueue->paSlistTimerBuckets != NULL)
	{
		DNFree(pWorkQueue->paSlistTimerBuckets);
		pWorkQueue->paSlistTimerBuckets = NULL;
	}

	goto Exit;
} // InitializeWorkQueueTimerInfo




#undef DPF_MODNAME
#define DPF_MODNAME "DeinitializeWorkQueueTimerInfo"
//=============================================================================
// DeinitializeWorkQueueTimerInfo
//-----------------------------------------------------------------------------
//
// Description:    Cleans up work queue timer info.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to initialize.
//
// Returns: Nothing.
//=============================================================================
void DeinitializeWorkQueueTimerInfo(DPTPWORKQUEUE * const pWorkQueue)
{
	DWORD				dwTemp;
	DNSLIST_ENTRY *		pSlistEntry;
	CWorkItem *			pWorkItem;
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
	BOOL				fResult;


	fResult = DNCloseHandle(pWorkQueue->hTimer);
	DNASSERT(fResult);
	pWorkQueue->hTimer = NULL;
#endif // WINNT or (WIN95 AND ! DPNBUILD_NOWAITABLETIMERSON9X)

	//
	// Empty out the timer buckets.  The only thing left should be cancelled
	// timers that the threads/DoWork didn't happen to clean up.
	//
	DNASSERT(pWorkQueue->paSlistTimerBuckets != NULL);
	for(dwTemp = 0; dwTemp < NUM_TIMER_BUCKETS(pWorkQueue); dwTemp++)
	{
		//
		// This doesn't really need to be interlocked since no one should be
		// using it anymore, but oh well...
		//
		pSlistEntry = DNInterlockedFlushSList(&pWorkQueue->paSlistTimerBuckets[dwTemp]);
		while (pSlistEntry != NULL)
		{
			pWorkItem = CONTAINING_OBJECT(pSlistEntry, CWorkItem, m_SlistEntry);
			pSlistEntry = pSlistEntry->Next;

			//
			// Make sure the item has been cancelled as noted above.
			//
			DNASSERT(pWorkItem->m_fCancelledOrCompleting);

			pWorkQueue->pWorkItemPool->Release(pWorkItem);
			pWorkItem = NULL;
		}
	}
	DNFree(pWorkQueue->paSlistTimerBuckets);
	pWorkQueue->paSlistTimerBuckets = NULL;

#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Print our debugging/tuning statistics.
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	DPFX(DPFPREP, 7, "Work queue 0x%p timer stats:", pWorkQueue);
#else // ! DPNBUILD_ONLYONEPROCESSOR
	DPFX(DPFPREP, 7, "Work queue 0x%p (CPU %u) timer stats:", pWorkQueue, pWorkQueue->dwCPUNum);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	DPFX(DPFPREP, 7, "     TotalNumTimerChecks             = %u", pWorkQueue->dwTotalNumTimerChecks);
	DPFX(DPFPREP, 7, "     TotalNumBucketsProcessed        = %u", pWorkQueue->dwTotalNumBucketsProcessed);
	DPFX(DPFPREP, 7, "     TotalNumTimersScheduled         = %u", pWorkQueue->dwTotalNumTimersScheduled);
	DPFX(DPFPREP, 7, "     TotalNumLongTimersRescheduled   = %u", pWorkQueue->dwTotalNumLongTimersRescheduled);
	DPFX(DPFPREP, 7, "     TotalNumSuccessfulCancels       = %u", pWorkQueue->dwTotalNumSuccessfulCancels);
	DPFX(DPFPREP, 7, "     TotalNumFailedCancels           = %u", pWorkQueue->dwTotalNumFailedCancels);
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	DPFX(DPFPREP, 7, "     TotalPossibleMissedTimerWindows = %u", pWorkQueue->dwTotalPossibleMissedTimerWindows);
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT
#endif // DPNBUILD_THREADPOOLSTATISTICS
} // DeinitializeWorkQueueTimerInfo



#undef DPF_MODNAME
#define DPF_MODNAME "ScheduleTimer"
//=============================================================================
// ScheduleTimer
//-----------------------------------------------------------------------------
//
// Description:    Schedules a new work item for some point in the future.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue			- Pointer to work queue object to use.
//	DWORD dwDelay						- How much time should elapsed before
//											executing the work item, in ms.
//	PFNDPTNWORKCALLBACK pfnWorkCallback	- Callback to execute when timer
//											elapses.
//	PVOID pvCallbackContext				- User specified context to pass to
//											callback.
//	void ** ppvTimerData				- Place to store pointer to data for
//											timer so that it can be cancelled.
//	UINT * puiTimerUnique				- Place to store uniqueness value for
//											timer so that it can be cancelled.
//
// Returns: BOOL
//	TRUE	- Successfully scheduled the item.
//	FALSE	- Failed to allocate memory for scheduling the item.
//=============================================================================
BOOL ScheduleTimer(DPTPWORKQUEUE * const pWorkQueue,
					const DWORD dwDelay,
					const PFNDPTNWORKCALLBACK pfnWorkCallback,
					PVOID const pvCallbackContext,
					void ** const ppvTimerData,
					UINT * const puiTimerUnique)
{
	CWorkItem *		pWorkItem;
	DWORD			dwCurrentTime;
	DWORD			dwBucket;
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	DWORD			dwPossibleMissWindow;
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT


	//
	// Delays of over 24 days seem a bit excessive.
	//
	DNASSERT(dwDelay < 0x80000000);

	//
	// Get an entry from the pool.
	//
	pWorkItem = (CWorkItem*) pWorkQueue->pWorkItemPool->Get(pWorkQueue);
	if (pWorkItem == NULL)
	{
		return FALSE;
	}


	//
	// Fill in the return values used for cancellation.
	//
	(*ppvTimerData)		= pWorkItem;
	(*puiTimerUnique)	= pWorkItem->m_uiUniqueID;


	//
	// Initialize the work item.
	//
	pWorkItem->m_pfnWorkCallback	= pfnWorkCallback;
	pWorkItem->m_pvCallbackContext	= pvCallbackContext;

	ThreadpoolStatsCreate(pWorkItem);
	
	dwCurrentTime = GETTIMESTAMP();
	pWorkItem->m_dwDueTime			= dwCurrentTime + dwDelay;


	//
	// Calculate how far in the future this is.  Round up to the next bucket
	// time.
	//
	dwBucket = pWorkItem->m_dwDueTime + TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue);
	//
	// Convert into units of buckets by dividing by dwTimerBucketGranularity.
	//
	dwBucket = dwBucket >> TIMER_BUCKET_GRANULARITY_DIVISOR(pWorkQueue);
	//
	// The actual index will be modulo dwNumTimerBuckets.
	//
	dwBucket = dwBucket & NUM_TIMER_BUCKETS_MOD_MASK(pWorkQueue);
	//
	// Note that the timer thread theoretically could be processing the bucket
	// into which we are inserting, but since both threads are working from the
	// same time base, as long as we are at least one bucket in the future, we
	// should not get missed.  We rounded up and the processing function rounds
	// down in an attempt to insure that.
	//


	DPFX(DPFPREP, 8, "Scheduling timer work item 0x%p, context = 0x%p, due time = %u, fn = 0x%p, unique ID %u, queue = 0x%p, delay = %u, bucket = %u.",
		pWorkItem, pvCallbackContext, pWorkItem->m_dwDueTime, pfnWorkCallback,
		pWorkItem->m_uiUniqueID, pWorkQueue, dwDelay, dwBucket);


	//
	// Push this timer onto the appropriate timer bucket list.
	//
	DNInterlockedPushEntrySList(&pWorkQueue->paSlistTimerBuckets[dwBucket],
								&pWorkItem->m_SlistEntry);

#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	//
	// Although this function is very short, it's still possible that it took
	// too long, especially on timers with miniscule delays.  Give a hint to
	// the timer thread that it needs to look for timers that got missed.
	//
	// Note that really long delays could confuse this.
	//
	dwPossibleMissWindow = GETTIMESTAMP() - pWorkItem->m_dwDueTime;
	if ((int) dwPossibleMissWindow >= 0)
	{
		DWORD	dwResult;


		dwPossibleMissWindow++; // make it so a value of 0 still adds something to dwPossibleMissedTimerWindow
		dwResult = DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwPossibleMissedTimerWindow), dwPossibleMissWindow);
		DPFX(DPFPREP, 4, "Possibly missed timer work item 0x%p (delay %u ms), increased missed timer window (%u ms) by %u ms.",
			pWorkItem, dwDelay, dwResult, dwPossibleMissWindow);
	}
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT

#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Update the timer package debugging/tuning statistics.
	//
	DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumTimersScheduled));
#endif // DPNBUILD_THREADPOOLSTATISTICS

	return TRUE;
} // ScheduleTimer




#undef DPF_MODNAME
#define DPF_MODNAME "CancelTimer"
//=============================================================================
// CancelTimer
//-----------------------------------------------------------------------------
//
// Description:    Attempts to cancel a timed work item.  If the item is
//				already in the process of completing, DPNERR_CANNOTCANCEL is
//				returned, and the callback will still be (or is being) called.
//				If the item could be cancelled, DPN_OK is returned and the
//				callback will not be executed.
//
// Arguments:
//	void * pvTimerData		- Pointer to data for timer being cancelled.
//	UINT uiTimerUnique		- Uniqueness value for timer being cancelled.
//
// Returns: HRESULT
//	DPN_OK					- Successfully cancelled.
//	DPNERR_CANNOTCANCEL		- Could not cancel the item.
//=============================================================================
HRESULT CancelTimer(void * const pvTimerData,
					const UINT uiTimerUnique)
{
	HRESULT			hr;
	CWorkItem *		pWorkItem;


	//
	// This cancellation lookup mechanism assumes that the memory for already
	// completed entries is still allocated.  If the pooling mechanism changes,
	// this will have to be revised.  Obviously, that also means we assume the
	// memory was valid in the first place.  Passing in a garbage pvTimerData
	// value will cause a crash.  Also see the various calls to
	// pWorkItem->m_pfnWorkCallback.
	//
	DNASSERT(pvTimerData != NULL);
	pWorkItem = (CWorkItem*) pvTimerData;
	if (pWorkItem->m_uiUniqueID == uiTimerUnique)
	{
		//
		// Attempt to mark the item as cancelled.  If it was already in the
		// process of completing, (or I suppose if you had already cancelled
		// this same timer, but don't do that :), this would have already been
		// set to TRUE.
		//
		if (! DNInterlockedExchange((LPLONG) (&pWorkItem->m_fCancelledOrCompleting), TRUE))
		{
			DPFX(DPFPREP, 5, "Marked timer work item 0x%p (unique ID %u) as cancelled.",
				pWorkItem, uiTimerUnique);

#ifdef DPNBUILD_THREADPOOLSTATISTICS
			//
			// Update the timer package debugging/tuning statistics.
			//
			DNInterlockedIncrement((LPLONG) (&pWorkItem->m_pWorkQueue->dwTotalNumSuccessfulCancels));
#endif // DPNBUILD_THREADPOOLSTATISTICS

			hr = DPN_OK;
		}
		else
		{
			DPFX(DPFPREP, 5, "Timer work item 0x%p (unique ID %u) already completing.",
				pWorkItem, uiTimerUnique);

#ifdef DPNBUILD_THREADPOOLSTATISTICS
			//
			// Update the timer package debugging/tuning statistics.
			//
			DNInterlockedIncrement((LPLONG) (&pWorkItem->m_pWorkQueue->dwTotalNumFailedCancels));
#endif // DPNBUILD_THREADPOOLSTATISTICS

			hr = DPNERR_CANNOTCANCEL;
		}
	}
	else
	{
		DPFX(DPFPREP, 5, "Timer work item 0x%p unique ID does not match (%u != %u).",
			pWorkItem, pWorkItem->m_uiUniqueID, uiTimerUnique);

#ifdef DPNBUILD_THREADPOOLSTATISTICS
		//
		// Update the timer package debugging/tuning statistics.
		//
		DNInterlockedIncrement((LPLONG) (&pWorkItem->m_pWorkQueue->dwTotalNumFailedCancels));
#endif // DPNBUILD_THREADPOOLSTATISTICS

		hr = DPNERR_CANNOTCANCEL;
	}

	return hr;
} // CancelTimer





#undef DPF_MODNAME
#define DPF_MODNAME "ResetCompletingTimer"
//=============================================================================
// ResetCompletingTimer
//-----------------------------------------------------------------------------
//
// Description:	   Reschedules a timed work item whose callback is currently
//				being called.  Resetting timers that have not expired yet,
//				timers that have been cancelled, or timers whose callback has
//				already returned is not allowed.
//
// Arguments:
//	void * pvTimerData						- Pointer to data for timer being
//												reset.
//	DWORD dwNewDelay						- How much time should elapsed
//												before executing the work item
//												again, in ms.
//	PFNDPTNWORKCALLBACK pfnNewWorkCallback	- Callback to execute when timer
//												elapses.
//	PVOID pvNewCallbackContext				- User specified context to pass to
//												callback.
//	UINT * puiNewTimerUnique				- Place to store new uniqueness
//												value for timer so that it can
//												be cancelled.
//
// Returns: None.
//=============================================================================
void ResetCompletingTimer(void * const pvTimerData,
						const DWORD dwNewDelay,
						const PFNDPTNWORKCALLBACK pfnNewWorkCallback,
						PVOID const pvNewCallbackContext,
						UINT *const puiNewTimerUnique)
{
	CWorkItem *			pWorkItem;
	DPTPWORKQUEUE *		pWorkQueue;
	DWORD				dwCurrentTime;
	DWORD				dwBucket;
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	DWORD				dwPossibleMissWindow;
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT


	//
	// The timer must be valid, similar to CancelTimer.
	//
	DNASSERT(pvTimerData != NULL);
	pWorkItem = (CWorkItem*) pvTimerData;
	DNASSERT(pWorkItem->m_fCancelledOrCompleting);

	//
	// Delays of over 24 days seem a bit excessive.
	//
	DNASSERT(dwNewDelay < 0x80000000);


	pWorkQueue = pWorkItem->m_pWorkQueue;


	//
	// Reinitialize the work item.
	//
	pWorkItem->m_pfnWorkCallback		= pfnNewWorkCallback;
	pWorkItem->m_pvCallbackContext		= pvNewCallbackContext;

	ThreadpoolStatsCreate(pWorkItem);

	dwCurrentTime = GETTIMESTAMP();
	pWorkItem->m_dwDueTime				= dwCurrentTime + dwNewDelay;
	pWorkItem->m_fCancelledOrCompleting	= FALSE;
	pWorkItem->m_uiUniqueID++;
	
	//
	// Fill in the return value for cancellation.
	//
	(*puiNewTimerUnique) = pWorkItem->m_uiUniqueID;


	//
	// Calculate how far in the future this is.  Round up to the next bucket
	// time.
	//
	dwBucket = pWorkItem->m_dwDueTime + TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue);
	//
	// Convert into units of buckets by dividing by dwTimerBucketGranularity.
	//
	dwBucket = dwBucket >> TIMER_BUCKET_GRANULARITY_DIVISOR(pWorkQueue);
	//
	// The actual index will be modulo dwNumTimerBuckets.
	//
	dwBucket = dwBucket & NUM_TIMER_BUCKETS_MOD_MASK(pWorkQueue);
	//
	// Note that the timer thread theoretically could be processing the bucket
	// into which we are inserting, but since both threads are working from the
	// same time base, as long as we are at least one bucket in the future, we
	// should not get missed.  We rounded up and the processing function rounds
	// down in an attempt to insure that.
	//


	DPFX(DPFPREP, 8, "Rescheduling timer work item 0x%p, context = 0x%p, due time = %u, fn = 0x%p, unique ID %u, queue = 0x%p, delay = %u, bucket = %u.",
		pWorkItem, pvNewCallbackContext, pWorkItem->m_dwDueTime, pfnNewWorkCallback,
		pWorkItem->m_uiUniqueID, pWorkQueue, dwNewDelay, dwBucket);


	//
	// Push this timer onto the appropriate timer bucket list.
	//
	DNInterlockedPushEntrySList(&pWorkQueue->paSlistTimerBuckets[dwBucket],
								&pWorkItem->m_SlistEntry);

#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	//
	// Although this function is very short, it's still possible that it took
	// too long, especially on timers with miniscule delays.  Give a hint to
	// the timer thread that it needs to look for timers that got missed.
	//
	// Note that really long delays could confuse this.
	//
	dwPossibleMissWindow = GETTIMESTAMP() - pWorkItem->m_dwDueTime;
	if ((int) dwPossibleMissWindow >= 0)
	{
		DWORD	dwResult;


		dwPossibleMissWindow++; // make it so a value of 0 still adds something to dwPossibleMissedTimerWindow
		dwResult = DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwPossibleMissedTimerWindow), dwPossibleMissWindow);
		DPFX(DPFPREP, 4, "Possibly missed timer work item 0x%p (delay %u ms), increased missed timer window (%u ms) by %u ms.",
			pWorkItem, dwNewDelay, dwResult, dwPossibleMissWindow);
	}
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT

#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Update the timer package debugging/tuning statistics.
	//
	DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumTimersScheduled));
#endif // DPNBUILD_THREADPOOLSTATISTICS
} // ResetCompletingTimer




#undef DPF_MODNAME
#define DPF_MODNAME "ProcessTimers"
//=============================================================================
// ProcessTimers
//-----------------------------------------------------------------------------
//
// Description:    Queues any expired timers as work items and performs lazy
//				pool releases of cancelled timers.
//
//				   When this implementation does not use I/O completion ports,
//				the new work items are added to the passed in list without
//				using Interlocked functions.
//
//				   It is assumed that only one thread will call this function
//				at a time.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	DNSLIST_ENTRY ** ppHead		- Pointer to initial list head pointer, and
//									place to store new head pointer.
//	DNSLIST_ENTRY ** ppTail		- Pointer to existing list tail pointer, or
//									place to store new tail pointer.
//	USHORT * pusCount			- Pointer to existing list count, it will be
//									updated to reflect new items.
//
// Returns: Nothing.
//=============================================================================
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
void ProcessTimers(DPTPWORKQUEUE * const pWorkQueue)
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
void ProcessTimers(DPTPWORKQUEUE * const pWorkQueue,
					DNSLIST_ENTRY ** const ppHead,
					DNSLIST_ENTRY ** const ppTail,
					USHORT * const pusCount)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
{
	DWORD				dwCurrentTime;
	DWORD				dwElapsedTime;
	DWORD				dwExpiredBuckets;
	DWORD				dwBucket;
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	DWORD				dwPossibleMissedTimerWindow;
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT
	DNSLIST_ENTRY *		pSlistEntry;
	CWorkItem *			pWorkItem;
	BOOL				fCancelled;
#ifdef DBG
	BOOL				fNotServicedForLongTime = FALSE;
	DWORD				dwBucketTime;
#endif // DBG


	//
	// Retrieve the current time, rounding down to the last fully completed
	// bucket time slice.
	//
	dwCurrentTime = GETTIMESTAMP() & TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue);

#ifndef DPNBUILD_DONTCHECKFORMISSEDTIMERS
#ifdef DPNBUILD_NOMISSEDTIMERSHINT
	//
	// Always re-check the previous bucket.
	//
	pWorkQueue->dwLastTimerProcessTime -= TIMER_BUCKET_GRANULARITY(pWorkQueue);
#else // ! DPNBUILD_NOMISSEDTIMERSHINT
	//
	// See if any threads hinted that there might be missed timers.  If so, we
	// will artifically open the window a bit more, hopefully to include them.
	//
	dwPossibleMissedTimerWindow = DNInterlockedExchange((LPLONG) (&pWorkQueue->dwPossibleMissedTimerWindow), 0);
	dwPossibleMissedTimerWindow = (dwPossibleMissedTimerWindow + TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue))
									& TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue);
#ifdef DPNBUILD_THREADPOOLSTATISTICS
	pWorkQueue->dwTotalPossibleMissedTimerWindows += dwPossibleMissedTimerWindow;
#endif // DPNBUILD_THREADPOOLSTATISTICS
	pWorkQueue->dwLastTimerProcessTime -= dwPossibleMissedTimerWindow;
#endif // ! DPNBUILD_NOMISSEDTIMERSHINT
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS

	//
	// See if enough time has elapsed to cause any buckets to expire.  If not,
	// there's nothing to do.
	//
	dwElapsedTime = dwCurrentTime - pWorkQueue->dwLastTimerProcessTime;
	if (dwElapsedTime > 0)
	{
		//DPFX(DPFPREP, 9, "Processing timers for worker queue 0x%p, rounded time = %u, elapsed time = %u", pWorkQueue, dwCurrentTime, dwElapsedTime);

		//
		// The time difference should be an even multiple of the timer bucket
		// granularity (negating the floor mask gives us the modulo mask).
		//
		DNASSERT((dwElapsedTime & ~(TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue))) == 0);
		//
		// We should not have failed to run for over 24 days, so if this assert
		// fires, time probably went backward or some such nonsense.
		//
		DNASSERT(dwElapsedTime < 0x80000000);


		//
		// Figure out how many buckets we need to process by dividing by
		// dwTimerBucketGranularity.
		//
		dwExpiredBuckets = dwElapsedTime >> TIMER_BUCKET_GRANULARITY_DIVISOR(pWorkQueue);
		if (dwExpiredBuckets > NUM_TIMER_BUCKETS(pWorkQueue))
		{
			//
			// A really long time has elapsed since the last time we serviced
			// the timers (equal to or longer than the range of the entire
			// array).  We must complete everything that is on the array.  To
			// prevent us from walking the same bucket more than once, cap the
			// number we're going to check.
			//
			dwExpiredBuckets = NUM_TIMER_BUCKETS(pWorkQueue);
#ifdef DBG
			fNotServicedForLongTime = FALSE;
#endif // DBG
		}

#ifdef DPNBUILD_THREADPOOLSTATISTICS
		//
		// Update the timer package debugging/tuning statistics.
		//
		pWorkQueue->dwTotalNumTimerChecks++;
		pWorkQueue->dwTotalNumBucketsProcessed += dwExpiredBuckets;
#endif // DPNBUILD_THREADPOOLSTATISTICS


		//
		// Convert the start time into units of buckets by dividing by
		// dwTimerBucketGranularity.
		//
		dwBucket = pWorkQueue->dwLastTimerProcessTime >> TIMER_BUCKET_GRANULARITY_DIVISOR(pWorkQueue);

		//
		// The actual index will be modulo dwNumTimerBuckets.
		//
		dwBucket = dwBucket & NUM_TIMER_BUCKETS_MOD_MASK(pWorkQueue);

#ifdef DBG
		dwBucketTime = pWorkQueue->dwLastTimerProcessTime;
#endif // DBG

		//
		// Walk through the list of expired buckets.  Since the bucket array
		// started at time 0, the current bucket is the current time modulo
		// the number of buckets.
		//
		while (dwExpiredBuckets > 0)
		{
			dwExpiredBuckets--;

#ifdef DBG
			//DPFX(DPFPREP, 9, "Servicing bucket #%u, time = %u, %u buckets remaining.", dwBucket, dwBucketTime, dwExpiredBuckets);
			DNASSERT((int) (dwCurrentTime - dwBucketTime) >= 0);
#endif // DBG

			//
			// Dump the entire list of timer entries (if any) into a local
			// variable and walk through it at our leisure.
			//
			pSlistEntry = DNInterlockedFlushSList(&pWorkQueue->paSlistTimerBuckets[dwBucket]);
			while (pSlistEntry != NULL)
			{
				pWorkItem = CONTAINING_OBJECT(pSlistEntry, CWorkItem, m_SlistEntry);
				pSlistEntry = pSlistEntry->Next;

				//
				// Queue it for processing or reschedule the timer depending on
				// whether it's actually due now, and whether it's cancelled.
				//
				if (((int) (dwCurrentTime - pWorkItem->m_dwDueTime)) > 0)
				{
					//
					// The timer has expired.  It may have been cancelled; if
					// not, we need to queue if for completion.  Either way,
					// it's not cancellable any more.
					//
					fCancelled = (BOOL) DNInterlockedExchange((LPLONG) (&pWorkItem->m_fCancelledOrCompleting),
															TRUE);

					//
					// If the timer was cancelled, just put the entry back into
					// the pool.  Otherwise, queue the work item.
					//
					if (fCancelled)
					{
						DPFX(DPFPREP, 5, "Returning timer work item 0x%p (unique ID %u, due time = %u, bucket %u) back to pool.",
							pWorkItem, pWorkItem->m_uiUniqueID,
							pWorkItem->m_dwDueTime, dwBucket);

						pWorkQueue->pWorkItemPool->Release(pWorkItem);
					}
					else
					{
						DPFX(DPFPREP, 8, "Queueing timer work item 0x%p (unique ID %u, due time = %u, bucket %u) for completion on queue 0x%p.",
							pWorkItem, pWorkItem->m_uiUniqueID,
							pWorkItem->m_dwDueTime, dwBucket,
							pWorkQueue);

#ifdef DBG
						//
						// Make sure we didn't miss any timers last time around,
						// unless we were really, really delayed.
						//
						{
							DWORD	dwTimePastDueTime;
							DWORD	dwElapsedTimeWithRoundError;


							dwTimePastDueTime = dwCurrentTime - pWorkItem->m_dwDueTime;
							dwElapsedTimeWithRoundError = dwElapsedTime + TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue);
							if (dwTimePastDueTime > dwElapsedTimeWithRoundError)
							{
								DPFX(DPFPREP, 1, "Missed timer work item 0x%p, its due time of %u is off by about %u ms.",
									pWorkItem, pWorkItem->m_dwDueTime, dwTimePastDueTime);

#if ((defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) || (defined(DPNBUILD_NOMISSEDTIMERSHINT)))
								DNASSERTX(fNotServicedForLongTime, 2);
#else // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT
								DNASSERT(fNotServicedForLongTime);
#endif // ! ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and DPNBUILD_NOMISSEDTIMERSHINT
							}
						}
#endif // DBG

						ThreadpoolStatsQueue(pWorkItem);

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
						//
						// Queue it to the I/O completion port.
						//
						BOOL	fResult;

						fResult = PostQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
															0,
															0,
															&pWorkItem->m_Overlapped);
						DNASSERT(fResult);
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
						//
						// Add it to the caller's list.
						//
						if ((*ppHead) == NULL)
						{
							*ppTail = &pWorkItem->m_SlistEntry;
						}
						pWorkItem->m_SlistEntry.Next = *ppHead;
						*ppHead = &pWorkItem->m_SlistEntry;

						(*pusCount)++;
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
					}
				}
				else
				{
					//
					// It's a "long" timer, and hasn't expired yet.  Sample the
					// boolean to see if it has been cancelled.  If so, just
					// put the entry back into the pool.  Otherwise, put it
					// back into the bucket.
					//
					fCancelled = pWorkItem->m_fCancelledOrCompleting;
					if (fCancelled)
					{
						DPFX(DPFPREP, 5, "Returning timer work item 0x%p (unique ID %u, due time = %u, bucket %u) back to pool.",
							pWorkItem, pWorkItem->m_uiUniqueID,
							pWorkItem->m_dwDueTime, dwBucket);

						pWorkQueue->pWorkItemPool->Release(pWorkItem);
					}
					else
					{
						DPFX(DPFPREP, 8, "Putting long timer work item 0x%p (unique ID %u, due time = %u) back in bucket %u.",
							pWorkItem, pWorkItem->m_uiUniqueID,
							pWorkItem->m_dwDueTime, dwBucket);

#ifdef DBG
						//
						// Make sure it really is in the future.
						//
						DWORD	dwRoundedDueTime = (pWorkItem->m_dwDueTime + TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue))
													& TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue);
						DWORD	dwTotalArrayTime = TIMER_BUCKET_GRANULARITY(pWorkQueue) * NUM_TIMER_BUCKETS(pWorkQueue);
						DNASSERT((dwRoundedDueTime - dwBucketTime) >= dwTotalArrayTime);
#endif // DBG

#pragma TODO(vanceo, "Investigate if saving up all long timers and pushing the whole list on at once will be beneficial")
						DNInterlockedPushEntrySList(&pWorkQueue->paSlistTimerBuckets[dwBucket],
													&pWorkItem->m_SlistEntry);

#ifdef DPNBUILD_THREADPOOLSTATISTICS
						DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumLongTimersRescheduled));
#endif // DPNBUILD_THREADPOOLSTATISTICS
					}
				}
			} // end while (still more timer entries in bucket)

			dwBucket = (dwBucket + 1) & NUM_TIMER_BUCKETS_MOD_MASK(pWorkQueue);
#ifdef DBG
			dwBucketTime += TIMER_BUCKET_GRANULARITY(pWorkQueue);
#endif // DBG
		} // end while (still more expired buckets)


		//
		// Remember when we started processing for use the next time through.
		//
		pWorkQueue->dwLastTimerProcessTime = dwCurrentTime;
	}
} // ProcessTimers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\work.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		work.cpp
 *
 *  Content:	DirectPlay Thread Pool work processing functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"



//=============================================================================
// Defines
//=============================================================================
#define MAX_SIMULTANEOUS_THREAD_START	(MAXIMUM_WAIT_OBJECTS - 1)	// WaitForMultipleObjects can only handle 64 items at a time, we need one slot for the start event




#undef DPF_MODNAME
#define DPF_MODNAME "InitializeWorkQueue"
//=============================================================================
// InitializeWorkQueue
//-----------------------------------------------------------------------------
//
// Description:    Initializes the specified work queue.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue			- Pointer to work queue object to
//											initialize.
//	DWORD dwCPUNum						- CPU number this queue is to
//											represent.
//	PFNDPNMESSAGEHANDLER pfnMsgHandler	- User's message handler callback, or
//											NULL if none.
//	PVOID pvMsgHandlerContext			- Context for user's message handler.
//	DWORD dwWorkerThreadTlsIndex		- TLS index to use for storing worker
//											thread data.
//
// Returns: HRESULT
//	DPN_OK				- Successfully initialized the work queue object.
//	DPNERR_OUTOFMEMORY	- Failed to allocate memory while initializing.
//=============================================================================
#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DPNBUILD_ONLYONEPROCESSOR
HRESULT InitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue)
#else // ! DPNBUILD_ONLYONEPROCESSOR
HRESULT InitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue,
							const DWORD dwCPUNum)
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#else // ! DPNBUILD_ONLYONETHREAD
HRESULT InitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue,
#ifndef DPNBUILD_ONLYONEPROCESSOR
							const DWORD dwCPUNum,
#endif // ! DPNBUILD_ONLYONEPROCESSOR
							const PFNDPNMESSAGEHANDLER pfnMsgHandler,
							PVOID const pvMsgHandlerContext,
							const DWORD dwWorkerThreadTlsIndex)
#endif // ! DPNBUILD_ONLYONETHREAD
{
	HRESULT		hr;
	BOOL		fInittedWorkItemPool = FALSE;
#if ((! defined(WINCE)) || (defined(DBG)))
	BOOL		fInittedListLock = FALSE;
#endif // ! WINCE or DBG
	BOOL		fInittedTimerInfo = FALSE;
#ifndef WINCE
	BOOL		fInittedIoInfo = FALSE;
#endif // ! WINCE
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pWorkQueue);


	pWorkQueue->Sig[0] = 'W';
	pWorkQueue->Sig[1] = 'R';
	pWorkQueue->Sig[2] = 'K';
	pWorkQueue->Sig[3] = 'Q';


	pWorkQueue->pWorkItemPool = (CFixedPool*) DNMalloc(sizeof(CFixedPool));
	if (pWorkQueue->pWorkItemPool == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate new work item pool!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	if (! pWorkQueue->pWorkItemPool->Initialize(sizeof(CWorkItem),
												CWorkItem::FPM_Alloc,
												CWorkItem::FPM_Get,
												CWorkItem::FPM_Release,
												//CWorkItem::FPM_Dealloc))
												NULL))
	{
		DPFX(DPFPREP, 0, "Couldn't initialize work item pool!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	fInittedWorkItemPool = TRUE;

#if ((! defined(WINCE)) || (defined(DBG)))
	if (! DNInitializeCriticalSection(&pWorkQueue->csListLock))
	{
		DPFX(DPFPREP, 0, "Couldn't initialize list lock!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	DebugSetCriticalSectionRecursionCount(&pWorkQueue->csListLock, 0);
	fInittedListLock = TRUE;
#endif // ! WINCE or DBG

#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
	DNInitializeSListHead(&pWorkQueue->SlistFreeQueueNodes);

	//
	// Add an initial node entry as required by NB Queue implementation.
	//
	DNInterlockedPushEntrySList(&pWorkQueue->SlistFreeQueueNodes,
								(DNSLIST_ENTRY*) (&pWorkQueue->NBQueueBlockInitial));


	//
	// Initialize the actual non-blocking queue.
	//
	pWorkQueue->pvNBQueueWorkItems = DNInitializeNBQueueHead(&pWorkQueue->SlistFreeQueueNodes);
	if (pWorkQueue->pvNBQueueWorkItems == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize non-blocking queue!");
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS


#ifndef DPNBUILD_ONLYONETHREAD
	pWorkQueue->fTimerThreadNeeded					= TRUE;
	pWorkQueue->dwNumThreadsExpected				= 0;
	pWorkQueue->dwNumBusyThreads					= 0;
	pWorkQueue->dwNumRunningThreads					= 0;
#endif // ! DPNBUILD_ONLYONETHREAD


#ifndef DPNBUILD_ONLYONEPROCESSOR
	pWorkQueue->dwCPUNum							= dwCPUNum;
#endif // ! DPNBUILD_ONLYONEPROCESSOR

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	//
	// Create an I/O completion port.
	//
	HANDLE	hIoCompletionPort;

	hIoCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,
												NULL,
												0,
												0);
	if (hIoCompletionPort == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create I/O completion port (err = %u)!", dwError);
#endif // DBG
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
	pWorkQueue->hIoCompletionPort = MAKE_DNHANDLE(hIoCompletionPort);
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	//
	// Create an event used to wake up idle worker threads.
	//
	pWorkQueue->hAlertEvent = DNCreateEvent(NULL, FALSE, FALSE, NULL);
	if (pWorkQueue->hAlertEvent == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create alert event (err = %u)!", dwError);
#endif // DBG
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

#ifndef DPNBUILD_ONLYONETHREAD
	pWorkQueue->hExpectedThreadsEvent				= NULL;
	pWorkQueue->pfnMsgHandler						= pfnMsgHandler;
	pWorkQueue->pvMsgHandlerContext					= pvMsgHandlerContext;
	pWorkQueue->dwWorkerThreadTlsIndex				= dwWorkerThreadTlsIndex;
#endif // ! DPNBUILD_ONLYONETHREAD

#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Initialize our debugging/tuning statistics.
	//
	pWorkQueue->dwTotalNumWorkItems					= 0;
#ifndef WINCE
	pWorkQueue->dwTotalTimeSpentUnsignalled			= 0;
	pWorkQueue->dwTotalTimeSpentInWorkCallbacks		= 0;
#endif // ! WINCE
#ifndef DPNBUILD_ONLYONETHREAD
	pWorkQueue->dwTotalNumTimerThreadAbdications	= 0;
#endif // ! DPNBUILD_ONLYONETHREAD
	pWorkQueue->dwTotalNumWakesWithoutWork			= 0;
	pWorkQueue->dwTotalNumContinuousWork			= 0;
	pWorkQueue->dwTotalNumDoWorks					= 0;
	pWorkQueue->dwTotalNumDoWorksTimeLimit			= 0;
	pWorkQueue->dwTotalNumSimultaneousQueues		= 0;
	memset(pWorkQueue->aCallbackStats, 0, sizeof(pWorkQueue->aCallbackStats));
#endif // DPNBUILD_THREADPOOLSTATISTICS


#ifdef DBG
#ifndef DPNBUILD_ONLYONETHREAD
	//
	// Initialize the structures helpful for debugging.
	//
	pWorkQueue->blThreadList.Initialize();
#endif // ! DPNBUILD_ONLYONETHREAD
#endif // DBG

	//
	// Initialize the timer aspects of the work queue
	//
	hr = InitializeWorkQueueTimerInfo(pWorkQueue);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize timer info for work queue!");
		goto Failure;
	}
	fInittedTimerInfo = TRUE;


#ifndef WINCE
	//
	// Initialize the I/O aspects of the work queue
	//
	hr = InitializeWorkQueueIoInfo(pWorkQueue);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize I/O info for work queue!");
		goto Failure;
	}
	fInittedIoInfo = TRUE;
#endif // ! WINCE


Exit:

	DPFX(DPFPREP, 6, "Returning: [0x%lx]", hr);

	return hr;

Failure:

#ifndef WINCE
	if (fInittedIoInfo)
	{
		DeinitializeWorkQueueIoInfo(pWorkQueue);
		fInittedIoInfo = FALSE;
	}
#endif // ! WINCE

	if (fInittedTimerInfo)
	{
		DeinitializeWorkQueueTimerInfo(pWorkQueue);
		fInittedTimerInfo = FALSE;
	}

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	if (pWorkQueue->hIoCompletionPort != NULL)
	{
		DNCloseHandle(pWorkQueue->hIoCompletionPort);
		pWorkQueue->hIoCompletionPort = NULL;
	}
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	if (pWorkQueue->hAlertEvent != NULL)
	{
		DNCloseHandle(pWorkQueue->hAlertEvent);
		pWorkQueue->hAlertEvent = NULL;
	}

	if (pWorkQueue->pvNBQueueWorkItems != NULL)
	{
		DNDeinitializeNBQueueHead(pWorkQueue->pvNBQueueWorkItems);
		pWorkQueue->pvNBQueueWorkItems = NULL;
	}
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

#if ((! defined(WINCE)) || (defined(DBG)))
	if (fInittedListLock)
	{
		DNDeleteCriticalSection(&pWorkQueue->csListLock);
		fInittedListLock = FALSE;
	}
#endif // ! WINCE or DBG

	if (pWorkQueue->pWorkItemPool != NULL)
	{
		if (fInittedWorkItemPool)
		{
			pWorkQueue->pWorkItemPool->DeInitialize();
			fInittedWorkItemPool = FALSE;
		}

		DNFree(pWorkQueue->pWorkItemPool);
		pWorkQueue->pWorkItemPool = NULL;
	}

	goto Exit;
} // InitializeWorkQueue




#undef DPF_MODNAME
#define DPF_MODNAME "DeinitializeWorkQueue"
//=============================================================================
// DeinitializeWorkQueue
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the work queue.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to clean up.
//
// Returns: Nothing.
//=============================================================================
void DeinitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue)
{
#ifndef DPNBUILD_ONLYONETHREAD
	HRESULT				hr;
#endif // ! DPNBUILD_ONLYONETHREAD
	BOOL				fResult;
#ifdef DBG
	DWORD				dwMaxRecursionCount = 0;
#ifdef WINNT
	HANDLE				hThread;
	FILETIME			ftIgnoredCreation;
	FILETIME			ftIgnoredExit;
	ULONGLONG			ullKernel;
	ULONGLONG			ullUser;
#endif // WINNT
#endif // DBG


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pWorkQueue);


#ifndef DPNBUILD_ONLYONETHREAD
#ifdef DBG
	//
	// Assert that there are truly threads running if there's supposed to be,
	// and that we're not being called on one of those threads.
	//
	DNEnterCriticalSection(&pWorkQueue->csListLock);
	if (pWorkQueue->dwNumRunningThreads > 0)
	{
		CBilink *			pBilink;
		DPTPWORKERTHREAD *	pWorkerThread;


		DNASSERT(! pWorkQueue->blThreadList.IsEmpty());
		pBilink = pWorkQueue->blThreadList.GetNext();
		while (pBilink != &pWorkQueue->blThreadList)
		{
			pWorkerThread = CONTAINING_OBJECT(pBilink, DPTPWORKERTHREAD, blList);

#ifdef WINNT
			hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, pWorkerThread->dwThreadID);
			if (hThread != NULL)
			{
				if (GetThreadTimes(hThread, &ftIgnoredCreation, &ftIgnoredExit, (LPFILETIME) (&ullKernel), (LPFILETIME) (&ullUser)))
				{
					DPFX(DPFPREP, 6, "Found worker thread ID %u/0x%x, max recursion = %u, user time = %u, kernel time = %u.",
						pWorkerThread->dwThreadID, pWorkerThread->dwThreadID,
						pWorkerThread->dwMaxRecursionCount,
						(ULONG) (ullUser / ((ULONGLONG) 10000)),
						(ULONG) (ullKernel / ((ULONGLONG) 10000)));
				}
				else
				{
					DPFX(DPFPREP, 6, "Found worker thread ID %u/0x%x, max recursion = %u (get thread times failed).",
						pWorkerThread->dwThreadID, pWorkerThread->dwThreadID,
						pWorkerThread->dwMaxRecursionCount);
				}

				CloseHandle(hThread);
				hThread = NULL;
			}
			else
#endif // WINNT
			{
				DPFX(DPFPREP, 6, "Found worker thread ID %u/0x%x, max recursion = %u.",
					pWorkerThread->dwThreadID, pWorkerThread->dwThreadID,
					pWorkerThread->dwMaxRecursionCount);
			}

			DNASSERT(pWorkerThread->dwThreadID != GetCurrentThreadId());

			if (pWorkerThread->dwMaxRecursionCount > dwMaxRecursionCount)
			{
				dwMaxRecursionCount = pWorkerThread->dwMaxRecursionCount;
			}

			pBilink = pBilink->GetNext();
		}
	}
	else
	{
		DNASSERT(pWorkQueue->blThreadList.IsEmpty());
	}
	DNLeaveCriticalSection(&pWorkQueue->csListLock);
#endif // DBG


	//
	// Stop all threads, if there were any.
	//
	if (pWorkQueue->dwNumRunningThreads > 0)
	{
		hr = StopThreads(pWorkQueue, pWorkQueue->dwNumRunningThreads);
		DNASSERT(hr == DPN_OK);
	}
	else
	{
		//
		// Make sure the count didn't go negative.
		//
		DNASSERT(pWorkQueue->dwNumRunningThreads == 0);
	}


	//
	// All threads should be gone by now.  Technically, that isn't true because
	// they still have some minor cleanup code to run after decrementing
	// lNumRunningThreads.  But for our purposes, the threads are gone.
	// We also know that they pull themselves out of blThreadList prior to
	// alerting us that they've left, so the list should be empty by now.
	//
#ifdef DBG
	DNASSERT(pWorkQueue->blThreadList.IsEmpty());
#endif // DBG
#endif // ! DPNBUILD_ONLYONETHREAD


#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Print our debugging/tuning statistics.
	//
#ifdef DPNBUILD_ONLYONEPROCESSOR
	DPFX(DPFPREP, 7, "Work queue 0x%p work stats:", pWorkQueue);
#else // ! DPNBUILD_ONLYONEPROCESSOR
	DPFX(DPFPREP, 7, "Work queue 0x%p (CPU %u) work stats:", pWorkQueue, pWorkQueue->dwCPUNum);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
	DPFX(DPFPREP, 7, "     TotalNumWorkItems              = %u", pWorkQueue->dwTotalNumWorkItems);
#ifndef WINCE
	DPFX(DPFPREP, 7, "     TotalTimeSpentUnsignalled      = %u", pWorkQueue->dwTotalTimeSpentUnsignalled);
	DPFX(DPFPREP, 7, "     TotalTimeSpentInWorkCallbacks  = %u", pWorkQueue->dwTotalTimeSpentInWorkCallbacks);
#endif // ! WINCE
#ifndef DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 7, "     TotalNumTimerThreadAbdications = %u", pWorkQueue->dwTotalNumTimerThreadAbdications);
#endif // ! DPNBUILD_ONLYONETHREAD
	DPFX(DPFPREP, 7, "     TotalNumWakesWithoutWork       = %u", pWorkQueue->dwTotalNumWakesWithoutWork);
	DPFX(DPFPREP, 7, "     TotalNumContinuousWork         = %u", pWorkQueue->dwTotalNumContinuousWork);
	DPFX(DPFPREP, 7, "     TotalNumDoWorks                = %u", pWorkQueue->dwTotalNumDoWorks);
	DPFX(DPFPREP, 7, "     TotalNumDoWorksTimeLimit       = %u", pWorkQueue->dwTotalNumDoWorksTimeLimit);
	DPFX(DPFPREP, 7, "     TotalNumSimultaneousQueues     = %u", pWorkQueue->dwTotalNumSimultaneousQueues);
	DPFX(DPFPREP, 7, "     MaxRecursionCount              = %u", dwMaxRecursionCount);
#endif // DPNBUILD_THREADPOOLSTATISTICS

#ifndef WINCE
	DeinitializeWorkQueueIoInfo(pWorkQueue);
#endif // ! WINCE

	DeinitializeWorkQueueTimerInfo(pWorkQueue);

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	fResult = DNCloseHandle(pWorkQueue->hIoCompletionPort);
	DNASSERT(fResult);
	pWorkQueue->hIoCompletionPort = NULL;
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	fResult = DNCloseHandle(pWorkQueue->hAlertEvent);
	DNASSERT(fResult);
	pWorkQueue->hAlertEvent = NULL;


	DNASSERT(DNIsNBQueueEmpty(pWorkQueue->pvNBQueueWorkItems));
	DNDeinitializeNBQueueHead(pWorkQueue->pvNBQueueWorkItems);
	pWorkQueue->pvNBQueueWorkItems = NULL;
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

#if ((! defined(WINCE)) || (defined(DBG)))
	DNDeleteCriticalSection(&pWorkQueue->csListLock);
#endif // ! WINCE or DBG

	//
	// All of the NB queue nodes should be back in the pool, but there's no way
	// to tell if we have the correct amount.
	//

	DNASSERT(pWorkQueue->pWorkItemPool != NULL);
	pWorkQueue->pWorkItemPool->DeInitialize();
	DNFree(pWorkQueue->pWorkItemPool);
	pWorkQueue->pWorkItemPool = NULL;


	DPFX(DPFPREP, 6, "Leave");
} // DeinitializeWorkQueue




#undef DPF_MODNAME
#define DPF_MODNAME "QueueWorkItem"
//=============================================================================
// QueueWorkItem
//-----------------------------------------------------------------------------
//
// Description:    Queues a new work item for processing.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue			- Pointer to work queue object to use.
//	PFNDPTNWORKCALLBACK pfnWorkCallback	- Callback to execute as soon as
//											possible.
//	PVOID pvCallbackContext				- User specified context to pass to
//											callback.
//
// Returns: BOOL
//	TRUE	- Successfully queued the item.
//	FALSE	- Failed to allocate memory for queueing the item.
//=============================================================================
BOOL QueueWorkItem(DPTPWORKQUEUE * const pWorkQueue,
					const PFNDPTNWORKCALLBACK pfnWorkCallback,
					PVOID const pvCallbackContext)
{
	CWorkItem *		pWorkItem;
	BOOL			fResult;


	pWorkItem = (CWorkItem*) pWorkQueue->pWorkItemPool->Get(pWorkQueue);
	if (pWorkItem == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't get new work item from pool!");
		return FALSE;
	}

	DPFX(DPFPREP, 5, "Creating and queuing work item 0x%p (fn = 0x%p, context = 0x%p, queue = 0x%p).",
		pWorkItem, pfnWorkCallback, pvCallbackContext, pWorkQueue);

	pWorkItem->m_pfnWorkCallback			= pfnWorkCallback;
	pWorkItem->m_pvCallbackContext			= pvCallbackContext;
#ifdef DPNBUILD_THREADPOOLSTATISTICS
	pWorkItem->m_fCancelledOrCompleting		= TRUE;

	DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumWorkItems));
	ThreadpoolStatsCreate(pWorkItem);
	ThreadpoolStatsQueue(pWorkItem);
#endif // DPNBUILD_THREADPOOLSTATISTICS

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	fResult = PostQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
										0,
										0,
										&pWorkItem->m_Overlapped);
	if (! fResult)
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't post queued completion status to port 0x%p (err = %u)!",
			pWorkQueue->hIoCompletionPort, dwError);
#endif // DBG

		//
		// Careful, the item has been queued but it's possibly nobody knows...
		//
	}
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	DNInsertTailNBQueue(pWorkQueue->pvNBQueueWorkItems,
						(ULONG64) pWorkItem);


	//
	// Alert the threads that there's a new item to process.
	//
	fResult = DNSetEvent(pWorkQueue->hAlertEvent);
	if (! fResult)
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't set alert event 0x%p (err = %u)!",
			pWorkQueue->hAlertEvent, dwError);
#endif // DBG

		//
		// Careful, the item has been queued but it's possibly nobody knows...
		//
	}
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

	return TRUE;
} // QueueWorkItem




#ifndef DPNBUILD_ONLYONETHREAD

#undef DPF_MODNAME
#define DPF_MODNAME "StartThreads"
//=============================================================================
// StartThreads
//-----------------------------------------------------------------------------
//
// Description:    Increases the number of threads for the work queue.
//
//				   It is assumed that only one thread will call this function
//				at a time, and no threads are currently being stopped.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object.
//	DWORD dwNumThreads			- Number of threads to start.
//
// Returns: HRESULT
//	DPN_OK				- Increasing the number of threads was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to alter the number of threads.
//=============================================================================
HRESULT StartThreads(DPTPWORKQUEUE * const pWorkQueue,
					const DWORD dwNumThreads)
{
	HRESULT		hr = DPN_OK;
	DNHANDLE	ahWaitObjects[MAX_SIMULTANEOUS_THREAD_START + 1];
	DWORD		adwThreadID[MAX_SIMULTANEOUS_THREAD_START];
	DWORD		dwNumThreadsExpected;
	DWORD		dwTotalThreadsRemaining;
	DWORD		dwTemp;
	DWORD		dwResult;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	DNASSERT(dwNumThreads > 0);

	//
	// Fill the entire array with NULL.
	//
	memset(ahWaitObjects, 0, sizeof(ahWaitObjects));

	//
	// Initialize the remaining count.
	//
	dwTotalThreadsRemaining = dwNumThreads;

	//
	// Create an event that will be set when an entire batch of threads has
	// successfully started.
	//
	ahWaitObjects[0] = DNCreateEvent(NULL, FALSE, FALSE, NULL);
	if (ahWaitObjects[0] == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create event (err = %u)!", dwError);
#endif // DBG
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DNASSERT(pWorkQueue->hExpectedThreadsEvent == NULL);
	pWorkQueue->hExpectedThreadsEvent = ahWaitObjects[0];


	//
	// Keep adding batches of threads until we've started the requested amount.
	//
	while (dwTotalThreadsRemaining > 0)
	{
		//
		// Set the counter of how many threads we're starting in this batch.
		// WaitForSingleObjects can only handle a fixed amount of handles
		// at a time, so if we can't fit any more, we'll have to pick them
		// up again in the next loop.
		//
		//
		dwNumThreadsExpected = dwTotalThreadsRemaining;
		if (dwNumThreadsExpected > MAX_SIMULTANEOUS_THREAD_START)
		{
			dwNumThreadsExpected = MAX_SIMULTANEOUS_THREAD_START;
		}

		DNASSERT(pWorkQueue->dwNumThreadsExpected == 0);
		pWorkQueue->dwNumThreadsExpected = dwNumThreadsExpected;

		for(dwTemp = 1; dwTemp <= dwNumThreadsExpected; dwTemp++)
		{
			ahWaitObjects[dwTemp] = DNCreateThread(NULL,
													0,
													DPTPWorkerThreadProc,
													pWorkQueue,
													0,
													&adwThreadID[dwTemp - 1]);
			if (ahWaitObjects[dwTemp] == NULL)
			{
#ifdef DBG
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Couldn't create thread (err = %u)!", dwError);
#endif // DBG
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}

			dwTotalThreadsRemaining--;
		}


		//
		// Wait for either the successful start event or one of the threads to
		// die prematurely.
		//
		DPFX(DPFPREP, 4, "Waiting for %u threads for queue 0x%p to start.",
			dwNumThreadsExpected, pWorkQueue);
		dwResult = DNWaitForMultipleObjects((dwNumThreadsExpected + 1),
											ahWaitObjects,
											FALSE,
											INFINITE);
		if (dwResult != WAIT_OBJECT_0)
		{
			if ((dwResult > WAIT_OBJECT_0) &&
				(dwResult <= (WAIT_OBJECT_0 + (MAX_SIMULTANEOUS_THREAD_START - 1))))
			{
#ifdef DBG
				dwResult -= WAIT_OBJECT_0;
				dwError = 0;
				GetExitCodeThread(ahWaitObjects[dwResult + 1], &dwError);
				DPFX(DPFPREP, 0, "Thread index %u (ID %u/0x%x shut down before starting successfully (err = %u)!",
					dwResult, adwThreadID[dwResult], adwThreadID[dwResult], dwError);
#endif // DBG
				hr = DPNERR_OUTOFMEMORY;
				goto Failure;
			}

#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Waiting for threads to start failed (err = %u)!",
				dwError);
#endif // DBG
			hr = DPNERR_GENERIC;
			goto Failure;
		}

		//
		// All the threads we were expecting to start, did.
		//
		DPFX(DPFPREP, 4, "Successfully started %u threads for queue 0x%p.",
			dwNumThreadsExpected, pWorkQueue);

		//
		// Close the handles for those threads since we will never use them
		// again.
		//
		while (dwNumThreadsExpected > 0)
		{
			DNCloseHandle(ahWaitObjects[dwNumThreadsExpected]);
			ahWaitObjects[dwNumThreadsExpected] = NULL;
			dwNumThreadsExpected--;
		}
	} // end while (still more threads to add)


	DNCloseHandle(ahWaitObjects[0]);
	ahWaitObjects[0] = NULL;


Exit:

	pWorkQueue->hExpectedThreadsEvent = NULL;

	return hr;

Failure:

	for(dwTemp = 0; dwTemp <= MAX_SIMULTANEOUS_THREAD_START; dwTemp++)
	{
		if (ahWaitObjects[dwTemp] != NULL)
		{
			DNCloseHandle(ahWaitObjects[dwTemp]);
			ahWaitObjects[dwTemp] = NULL;
		}
	}

	//
	// Stop all threads that we successfully launched so that we end up back in
	// the same state as when we started.  Ignore error because we're already
	// failing.
	//
	dwNumThreadsExpected = dwNumThreads - dwTotalThreadsRemaining;
	if (dwNumThreadsExpected > 0)
	{
		pWorkQueue->hExpectedThreadsEvent = NULL;
		StopThreads(pWorkQueue, dwNumThreadsExpected);
	}

	goto Exit;
} // StartThreads




#undef DPF_MODNAME
#define DPF_MODNAME "StopThreads"
//=============================================================================
// StopThreads
//-----------------------------------------------------------------------------
//
// Description:    Decreases the number of threads for the work queue.
//
//				   It is assumed that only one thread will call this function
//				at a time, and no threads are currently being started.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object.
//	DWORD dwNumThreads			- Number of threads to stop.
//
// Returns: HRESULT
//	DPN_OK				- Decreasing the number of threads was successful.
//	DPNERR_OUTOFMEMORY	- Not enough memory to alter the number of threads.
//=============================================================================
HRESULT StopThreads(DPTPWORKQUEUE * const pWorkQueue,
					const DWORD dwNumThreads)
{
	HRESULT		hr;
	DWORD		dwTemp;
	DWORD		dwResult;


	DNASSERT(dwNumThreads > 0);

	//
	// Create an event that will be set when the desired number of threads has
	// started shutting down.
	//
	DNASSERT(pWorkQueue->hExpectedThreadsEvent == NULL);
	pWorkQueue->hExpectedThreadsEvent = DNCreateEvent(NULL, FALSE, FALSE, NULL);
	if (pWorkQueue->hExpectedThreadsEvent == NULL)
	{
#ifdef DBG
		DWORD		dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create event (err = %u)!", dwError);
#endif // DBG
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DNASSERT(pWorkQueue->dwNumThreadsExpected == 0);
	pWorkQueue->dwNumThreadsExpected = dwNumThreads;


	for(dwTemp = 0; dwTemp < dwNumThreads; dwTemp++)
	{
		//
		// Queueing something with a NULL callback signifies "exit thread".
		//
		if (! QueueWorkItem(pWorkQueue, NULL, NULL))
		{
			DPFX(DPFPREP, 0, "Couldn't queue exit thread work item!");
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}
	} // end while (still more threads to remove)


	//
	// Wait for the last thread out to set the event.
	//
	DPFX(DPFPREP, 4, "Waiting for %u threads from queue 0x%p to stop.",
		dwNumThreads, pWorkQueue);
	dwResult = DNWaitForSingleObject(pWorkQueue->hExpectedThreadsEvent, INFINITE);
	DNASSERT(dwResult == WAIT_OBJECT_0);


	//
	// When the wait completes successfully, it means that the threads are on
	// their way out.  It does *not* mean the threads have stopped completely.
	// We have to assume that the threads will have time to fully quit before
	// anything major happens, such as unloading this module.
	//

	hr = DPN_OK;


Exit:

	if (pWorkQueue->hExpectedThreadsEvent != NULL)
	{
		DNCloseHandle(pWorkQueue->hExpectedThreadsEvent);
		pWorkQueue->hExpectedThreadsEvent = NULL;
	}

	return hr;

Failure:

	goto Exit;
} // StopThreads


#endif // ! DPNBUILD_ONLYONETHREAD




#undef DPF_MODNAME
#define DPF_MODNAME "DoWork"
//=============================================================================
// DoWork
//-----------------------------------------------------------------------------
//
// Description:	   Performs any work that is currently scheduled for the given
//				queue.  If dwMaxDoWorkTime is not INFINITE, work is started up
//				until that time.  At least one work item (if there is one) will
//				always be executed.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//	DWORD dwMaxDoWorkTime		- Maximum time at which a new job can be
//									started, or INFINITE if all jobs should be
//									processed before returning.
//
// Returns: Nothing.
//=============================================================================
void DoWork(DPTPWORKQUEUE * const pWorkQueue,
			const DWORD dwMaxDoWorkTime)
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
{
	BOOL			fNeedToServiceTimers;
	CWorkItem *		pWorkItem;
	BOOL			fResult;
	DWORD			dwBytesTransferred;
	DWORD			dwCompletionKey;
	OVERLAPPED *	pOverlapped;
	UINT			uiOriginalUniqueID;


	DPFX(DPFPREP, 8, "Parameters: (0x%p, %i)", pWorkQueue, dwMaxDoWorkTime);


#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Update the debugging/tuning statistics.
	//
	DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumDoWorks));
#endif // DPNBUILD_THREADPOOLSTATISTICS

	//
	// See if no one is processing timers.
	//
	fNeedToServiceTimers = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
												FALSE);

	//
	// If need be, handle any expired or cancelled timer entries.
	//
	if (fNeedToServiceTimers)
	{
		ProcessTimers(pWorkQueue);

		DPFX(DPFPREP, 8, "Abdicating timer thread responsibilities because of DoWork.");
	
#ifdef DPNBUILD_THREADPOOLSTATISTICS
		//
		// Update the debugging/tuning statistics.
		//
		pWorkQueue->dwTotalNumTimerThreadAbdications++;
#endif // DPNBUILD_THREADPOOLSTATISTICS

		DNASSERT(! pWorkQueue->fTimerThreadNeeded);
#pragma TODO(vanceo, "Does this truly need to be interlocked?")
		fNeedToServiceTimers = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
													(LONG) TRUE);
		DNASSERT(! fNeedToServiceTimers); // there had better not be more than one timer thread
	}

	//
	// Keep looping until we run out of items to do.  Note that this thread
	// does not try to count itself as busy.  Either we are in DoWork mode
	// proper where the busy thread concept has no meaning, or we are a worker
	// thread processing a job that called WaitWhileWorking where
	// pWorkQueue->lNumBusyThreads would already have been incremented.
	//
	while ((GetQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
									&dwBytesTransferred,
									&dwCompletionKey,
									&pOverlapped,
									0)) ||
			(pOverlapped != NULL))
	{
		pWorkItem = CONTAINING_OBJECT(pOverlapped, CWorkItem, m_Overlapped);
		DNASSERT(pWorkItem->IsValid());


		//
		// Call the user's function or note that we may need to stop running.
		//
		if (pWorkItem->m_pfnWorkCallback != NULL)
		{
			//
			// Save the uniqueness ID to determine if this item was a timer
			// that got rescheduled.
			//
			uiOriginalUniqueID = pWorkItem->m_uiUniqueID;

			DPFX(DPFPREP, 8, "Begin executing work item 0x%p (fn = 0x%p, context = 0x%p, unique = %u, queue = 0x%p).",
				pWorkItem, pWorkItem->m_pfnWorkCallback,
				pWorkItem->m_pvCallbackContext, uiOriginalUniqueID,
				pWorkQueue);

			ThreadpoolStatsBeginExecuting(pWorkItem);
			pWorkItem->m_pfnWorkCallback(pWorkItem->m_pvCallbackContext,
										pWorkItem,
										uiOriginalUniqueID);

			//
			// Return the item to the pool unless it got rescheduled.  This
			// assumes that the actual pWorkItem memory remains valid even
			// though it may have been rescheduled and then completed/cancelled
			// by the time we perform this test.  See CancelTimer.
			//
			if (uiOriginalUniqueID == pWorkItem->m_uiUniqueID)
			{
				ThreadpoolStatsEndExecuting(pWorkItem);
				DPFX(DPFPREP, 8, "Done executing work item 0x%p, returning to pool.", pWorkItem);
				pWorkQueue->pWorkItemPool->Release(pWorkItem);
			}
			else
			{
				ThreadpoolStatsEndExecutingRescheduled(pWorkItem);
				DPFX(DPFPREP, 8, "Done executing work item 0x%p, it was rescheduled.", pWorkItem);
			}
		}
		else
		{
			DPFX(DPFPREP, 3, "Requeuing exit thread work item 0x%p for other threads.",
				pWorkItem);

			fResult = PostQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
												0,
												0,
												&pWorkItem->m_Overlapped);
			DNASSERT(fResult);

#pragma BUGBUG(vanceo, "May not have processed everything we want")
			break;
		}


		//
		// Make sure we haven't exceeded our time limit (if we have one).
		//
		if ((dwMaxDoWorkTime != INFINITE) &&
			((int) (dwMaxDoWorkTime - GETTIMESTAMP()) < 0))
		{
			DPFX(DPFPREP, 5, "Exceeded time limit, not processing any more work.");

#ifdef DPNBUILD_THREADPOOLSTATISTICS
			//
			// Update the debugging/tuning statistics.
			//
			DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumDoWorksTimeLimit));
#endif // DPNBUILD_THREADPOOLSTATISTICS

			break;
		}
	}

	DPFX(DPFPREP, 8, "Leave");
} // DoWork
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
{
	DNSLIST_ENTRY *		pSlistEntryHead = NULL;
	USHORT				usCount = 0;
	DNSLIST_ENTRY *		pSlistEntryTail;
	CWorkItem *			pWorkItem;
	UINT				uiOriginalUniqueID;
#ifndef DPNBUILD_ONLYONETHREAD
	BOOL				fNeedToServiceTimers;
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, 8, "Parameters: (0x%p, %i)", pWorkQueue, dwMaxDoWorkTime);


#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Update the debugging/tuning statistics.
	//
	DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumDoWorks));
#endif // DPNBUILD_THREADPOOLSTATISTICS

#ifndef WINCE
	//
	// Handle any I/O completions.
	//
	ProcessIo(pWorkQueue, &pSlistEntryHead, &pSlistEntryTail, &usCount);
#endif // ! WINCE

#ifndef DPNBUILD_ONLYONETHREAD
	//
	// See if no one is processing timers.
	//
	fNeedToServiceTimers = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
												FALSE);

	//
	// If need be, handle any expired or cancelled timer entries.
	//
	if (fNeedToServiceTimers)
#endif // ! DPNBUILD_ONLYONETHREAD
	{
		ProcessTimers(pWorkQueue, &pSlistEntryHead, &pSlistEntryTail, &usCount);
	}


	//
	// Queue any work items we accumulated in one fell swoop.
	//
	if (pSlistEntryHead != NULL)
	{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
		if (usCount > 1)
		{
			DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumSimultaneousQueues));
		}
#ifdef WINCE
		LONG	lCount;

		lCount = usCount;
		while (lCount > 0)
		{
			DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumWorkItems));
			lCount--;
		}
#else // ! WINCE
		DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwTotalNumWorkItems), usCount);
#endif // ! WINCE
#endif // DPNBUILD_THREADPOOLSTATISTICS

		DNAppendListNBQueue(pWorkQueue->pvNBQueueWorkItems,
							pSlistEntryHead,
							OFFSETOF(CWorkItem, m_SlistEntry));
	}


#ifndef DPNBUILD_ONLYONETHREAD
	//
	// In case other threads are running, one of them should become a timer
	// thread.  We will need to kick them via the alert event so that they
	// notice.
	//
	if (fNeedToServiceTimers)
	{
		DPFX(DPFPREP, 8, "Abdicating timer thread responsibilities because of DoWork.");
	
#ifdef DPNBUILD_THREADPOOLSTATISTICS
		//
		// Update the debugging/tuning statistics.
		//
		pWorkQueue->dwTotalNumTimerThreadAbdications++;
#endif // DPNBUILD_THREADPOOLSTATISTICS

		DNASSERT(! pWorkQueue->fTimerThreadNeeded);
#pragma TODO(vanceo, "Does this truly need to be interlocked?")
		fNeedToServiceTimers = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
													(LONG) TRUE);
		DNASSERT(! fNeedToServiceTimers); // there had better not be more than one timer thread

		DNSetEvent(pWorkQueue->hAlertEvent);
	}

	//
	// Reset the tracking variables.
	//
	pSlistEntryHead = NULL;
	usCount = 0;
#endif // ! DPNBUILD_ONLYONETHREAD

	//
	// Keep looping until we run out of items to do.  Note that this thread
	// does not try to count itself as busy.  Either we are in DoWork mode
	// proper where the busy thread concept has no meaning, or we are a worker
	// thread processing a job that called WaitWhileWorking where
	// pWorkQueue->lNumBusyThreads would already have been incremented.
	//
	pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
	while (pWorkItem != NULL)
	{
		//
		// Call the user's function or note that we need to stop running.
		//
		if (pWorkItem->m_pfnWorkCallback != NULL)
		{
			//
			// Save the uniqueness ID to determine if this item was a timer
			// that got rescheduled.
			//
			uiOriginalUniqueID = pWorkItem->m_uiUniqueID;

			DPFX(DPFPREP, 8, "Begin executing work item 0x%p (fn = 0x%p, context = 0x%p, unique = %u, queue = 0x%p).",
				pWorkItem, pWorkItem->m_pfnWorkCallback,
				pWorkItem->m_pvCallbackContext, uiOriginalUniqueID,
				pWorkQueue);

			ThreadpoolStatsBeginExecuting(pWorkItem);
			pWorkItem->m_pfnWorkCallback(pWorkItem->m_pvCallbackContext,
										pWorkItem,
										uiOriginalUniqueID);

			//
			// Return the item to the pool unless it got rescheduled.  This
			// assumes that the actual pWorkItem memory remains valid even
			// though it may have been rescheduled and then completed/cancelled
			// by the time we perform this test.  See CancelTimer.
			//
			if (uiOriginalUniqueID == pWorkItem->m_uiUniqueID)
			{
				ThreadpoolStatsEndExecuting(pWorkItem);
				DPFX(DPFPREP, 8, "Done executing work item 0x%p, returning to pool.", pWorkItem);
				pWorkQueue->pWorkItemPool->Release(pWorkItem);
			}
			else
			{
				ThreadpoolStatsEndExecutingRescheduled(pWorkItem);
				DPFX(DPFPREP, 8, "Done executing work item 0x%p, it was rescheduled.", pWorkItem);
			}
		}
		else
		{
			DPFX(DPFPREP, 3, "Recognized exit thread work item 0x%p.", pWorkItem);

			//
			// This thread shouldn't get told to exit when either in DoWork
			// mode proper, or while performing work while waiting.  However,
			// it is possible in the latter case to pick up a quit event
			// "intended" (in a sense) for another thread.  We need to resubmit
			// the exit thread request so that another thread that can process
			// it, will.
			//
			// If we just put it back on the queue now, our while loop would
			// probably just pull it off again getting us nowhere.  Instead, we
			// will save up all of the exit requests we mistakenly receive and
			// dump them all back on the queue once we've run out of things to
			// do.
			//
#ifdef DPNBUILD_ONLYONETHREAD
			DNASSERT(FALSE);
#else // ! DPNBUILD_ONLYONETHREAD
			DNASSERT(pWorkQueue->dwNumRunningThreads > 1);
			if (pSlistEntryHead == NULL)
			{
				pSlistEntryTail = pSlistEntryHead;
			}
			pWorkItem->m_SlistEntry.Next = pSlistEntryHead;
			pSlistEntryHead = &pWorkItem->m_SlistEntry;
			usCount++;
#endif // ! DPNBUILD_ONLYONETHREAD
		}


		//
		// Make sure we haven't exceeded our time limit (if we have one).
		//
		if ((dwMaxDoWorkTime != INFINITE) &&
			((int) (dwMaxDoWorkTime - GETTIMESTAMP()) < 0))
		{
			DPFX(DPFPREP, 5, "Exceeded time limit, not processing any more work.");

#ifdef DPNBUILD_THREADPOOLSTATISTICS
			//
			// Update the debugging/tuning statistics.
			//
			DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumDoWorksTimeLimit));
#endif // DPNBUILD_THREADPOOLSTATISTICS

			break;
		}


		//
		// Try to get the next work item.
		//
		pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
#ifdef DPNBUILD_THREADPOOLSTATISTICS
		if (pWorkItem != NULL)
		{
			DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumContinuousWork));
		}
#endif // DPNBUILD_THREADPOOLSTATISTICS
	} // end while (more items)


#ifndef DPNBUILD_ONLYONETHREAD
	//
	// Re-queue any exit thread work items we accumulated.
	//
	if (pSlistEntryHead != NULL)
	{
		DPFX(DPFPREP, 1, "Re-queuing %u exit thread work items for queue 0x%p.",
			usCount, pWorkQueue);

		DNAppendListNBQueue(pWorkQueue->pvNBQueueWorkItems,
							pSlistEntryHead,
							OFFSETOF(CWorkItem, m_SlistEntry));
	}
	else
	{
		DNASSERT(usCount == 0);
	}
#endif // ! DPNBUILD_ONLYONETHREAD


	DPFX(DPFPREP, 8, "Leave");
} // DoWork
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS




#ifndef DPNBUILD_ONLYONETHREAD

#undef DPF_MODNAME
#define DPF_MODNAME "DPTPWorkerThreadProc"
//=============================================================================
// DPTPWorkerThreadProc
//-----------------------------------------------------------------------------
//
// Description:    The standard worker thread function for executing work
//				items.
//
// Arguments:
//	PVOID pvParameter	- Pointer to thread parameter data.
//
// Returns: DWORD
//=============================================================================
DWORD WINAPI DPTPWorkerThreadProc(PVOID pvParameter)
{
	DPTPWORKQUEUE *			pWorkQueue = (DPTPWORKQUEUE*) pvParameter;
	DPTPWORKERTHREAD		WorkerThread;
	BOOL					fUninitializeCOM = TRUE;
	PFNDPNMESSAGEHANDLER	pfnMsgHandler;
	PVOID					pvMsgHandlerContext;
	PVOID					pvUserThreadContext;
	HRESULT					hr;
	DWORD					dwResult;
#ifndef DPNBUILD_ONLYONEPROCESSOR
#if ((! defined(DPNBUILD_SOFTTHREADAFFINITY)) && (! defined(DPNBUILD_USEIOCOMPLETIONPORTS)))
	DWORD_PTR				dwpAffinityMask;
#endif // ! DPNBUILD_SOFTTHREADAFFINITY and ! DPNBUILD_USEIOCOMPLETIONPORTS
#ifdef DBG
	SYSTEM_INFO				SystemInfo;
#endif // DBG
#endif // ! DPNBUILD_ONLYONEPROCESSOR


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pvParameter);


#ifndef DPNBUILD_ONLYONEPROCESSOR
	//
	// Bind to a specific CPU.  First, assert that the CPU number is valid in
	// debug builds.
	//
#ifdef DBG
	GetSystemInfo(&SystemInfo);
	DNASSERT(pWorkQueue->dwCPUNum < SystemInfo.dwNumberOfProcessors);
#endif // DBG
#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
	SetThreadIdealProcessor(GetCurrentThread(), pWorkQueue->dwCPUNum);
#ifndef DPNBUILD_SOFTTHREADAFFINITY
	DNASSERT(pWorkQueue->dwCPUNum < (sizeof(dwpAffinityMask) * 8));
	dwpAffinityMask = 1 << pWorkQueue->dwCPUNum;
	SetThreadAffinityMask(GetCurrentThread(), dwpAffinityMask);
#endif // ! DPNBUILD_SOFTTHREADAFFINITY
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#endif // ! DPNBUILD_ONLYONEPROCESSOR

	//
	// Boost the thread priority.
	//
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	//
	// Init COM.
	//
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed to initialize COM (err = 0x%lx)!  Continuing.", hr);
		fUninitializeCOM = FALSE;

		//
		// Continue...
		//
	}


	//
	// Initialize the worker thread data.
	//

	memset(&WorkerThread, 0, sizeof(WorkerThread));

	WorkerThread.Sig[0] = 'W';
	WorkerThread.Sig[1] = 'K';
	WorkerThread.Sig[2] = 'T';
	WorkerThread.Sig[3] = 'D';

	WorkerThread.pWorkQueue = pWorkQueue;

#ifdef DBG
	WorkerThread.dwThreadID = GetCurrentThreadId();

	WorkerThread.blList.Initialize();

	DNEnterCriticalSection(&pWorkQueue->csListLock);
	WorkerThread.blList.InsertBefore(&pWorkQueue->blThreadList);
	DNLeaveCriticalSection(&pWorkQueue->csListLock);
#endif // DBG

	//
	// Save the worker thread data.
	//
	TlsSetValue(pWorkQueue->dwWorkerThreadTlsIndex, &WorkerThread);


	dwResult = DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwNumRunningThreads));
	DPFX(DPFPREP, 7, "Thread %u/0x%x from queue 0x%p started, num running threads is now %u.",
		GetCurrentThreadId(), GetCurrentThreadId(), pWorkQueue, dwResult);


	//
	// Save the current user message handler.  If there is one, call it now
	// with thread initialization information.
	//
	pfnMsgHandler = pWorkQueue->pfnMsgHandler;
	if (pfnMsgHandler != NULL)
	{
		DPNMSG_CREATE_THREAD	MsgCreateThread;


		//
		// Save the message handler context.
		//
		pvMsgHandlerContext = pWorkQueue->pvMsgHandlerContext;


		//
		// Call the user's message handler with a CREATE_THREAD message.
		//

		MsgCreateThread.dwSize			= sizeof(MsgCreateThread);
		MsgCreateThread.dwFlags			= 0;
#ifdef DPNBUILD_ONLYONEPROCESSOR
		MsgCreateThread.dwProcessorNum	= 0;
#else // ! DPNBUILD_ONLYONEPROCESSOR
		MsgCreateThread.dwProcessorNum	= pWorkQueue->dwCPUNum;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		MsgCreateThread.pvUserContext	= NULL;

		hr = pfnMsgHandler(pvMsgHandlerContext,
							DPN_MSGID_CREATE_THREAD,
							&MsgCreateThread);
#ifdef DBG
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "User returned error 0x%08x from CREATE_THREAD indication!",
				1, hr);
		}
#endif // DBG

		//
		// Save what the user returned for a thread context.
		//
		pvUserThreadContext = MsgCreateThread.pvUserContext;
	}

	//
	// The user (if any) now knows about the thread.
	//
	WorkerThread.fThreadIndicated = TRUE;

	DNASSERT(pWorkQueue->dwNumThreadsExpected > 0);
	dwResult = DNInterlockedDecrement((LPLONG) (&pWorkQueue->dwNumThreadsExpected));
	if (dwResult == 0)
	{
		DPFX(DPFPREP, 9, "All threads expected to start have, setting event.");
		DNASSERT(pWorkQueue->hExpectedThreadsEvent != NULL);
		DNSetEvent(pWorkQueue->hExpectedThreadsEvent);	// ignore error
	}
	else
	{
		DPFX(DPFPREP, 9, "Number of threads expected to start is now %u.", dwResult);
	}


	//
	// Perform the work loop.
	//
	DPTPWorkerLoop(pWorkQueue);


	//
	// The user (if any) is about to be told about the thread's destruction.
	//
	WorkerThread.fThreadIndicated = FALSE;

	//
	// If there was a user message handler, call it now with thread shutdown
	// information.
	//
	if (pfnMsgHandler != NULL)
	{
		DPNMSG_DESTROY_THREAD	MsgDestroyThread;


		//
		// Call the user's message handler with a DESTROY_THREAD message.
		//

		MsgDestroyThread.dwSize				= sizeof(MsgDestroyThread);
#ifdef DPNBUILD_ONLYONEPROCESSOR
		MsgDestroyThread.dwProcessorNum		= 0;
#else // ! DPNBUILD_ONLYONEPROCESSOR
		MsgDestroyThread.dwProcessorNum		= pWorkQueue->dwCPUNum;
#endif // ! DPNBUILD_ONLYONEPROCESSOR
		MsgDestroyThread.pvUserContext		= pvUserThreadContext;

		hr = pfnMsgHandler(pvMsgHandlerContext,
							DPN_MSGID_DESTROY_THREAD,
							&MsgDestroyThread);
#ifdef DBG
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "User returned error 0x%08x from DESTROY_THREAD indication!",
				1, hr);
		}
#endif // DBG

		pfnMsgHandler = NULL;
		pvMsgHandlerContext = NULL;
		pvUserThreadContext = NULL;
	}

#ifdef DBG
	DNEnterCriticalSection(&pWorkQueue->csListLock);
	WorkerThread.blList.RemoveFromList();
	DNLeaveCriticalSection(&pWorkQueue->csListLock);

	DNASSERT(WorkerThread.dwRecursionCount == 0);
	DNASSERT(TlsGetValue(pWorkQueue->dwWorkerThreadTlsIndex) == &WorkerThread);
#endif // DBG

	DNASSERT(pWorkQueue->dwNumRunningThreads > 0);
	dwResult = DNInterlockedDecrement((LPLONG) (&pWorkQueue->dwNumRunningThreads));
	DPFX(DPFPREP, 7, "Thread %u/0x%x from queue 0x%p done, num running threads is now %u.",
		GetCurrentThreadId(), GetCurrentThreadId(), pWorkQueue, dwResult);

#ifndef WINCE
	CancelIoForThisThread(pWorkQueue);
#endif // ! WINCE

	if (fUninitializeCOM)
	{
		CoUninitialize();
		fUninitializeCOM = FALSE;
	}


	DNASSERT(pWorkQueue->dwNumThreadsExpected > 0);
	dwResult = DNInterlockedDecrement((LPLONG) (&pWorkQueue->dwNumThreadsExpected));
	if (dwResult == 0)
	{
		DPFX(DPFPREP, 9, "All threads expected to stop have, setting event.");
		DNASSERT(pWorkQueue->hExpectedThreadsEvent != NULL);
		DNSetEvent(pWorkQueue->hExpectedThreadsEvent);	// ignore error
	}
	else
	{
		DPFX(DPFPREP, 9, "Number of threads expected to stop is now %u.", dwResult);
	}

	//
	// Since we have decremented dwNumRunningThreads and possibly set the
	// event, any other threads waiting on that will think we are gone.
	// Therefore, we cannot use pWorkQueue after this as it may have been
	// deallocated.  We must also endeavor to do as little work as possible
	// because there is a race condition where the module in which this code
	// resides could be unloaded.
	//

	DPFX(DPFPREP, 6, "Leave");

	return 0;
} // DPTPWorkerThreadProc




#ifdef DPNBUILD_MANDATORYTHREADS

#undef DPF_MODNAME
#define DPF_MODNAME "DPTPMandatoryThreadProc"
//=============================================================================
// DPTPMandatoryThreadProc
//-----------------------------------------------------------------------------
//
// Description:    The standard worker thread function for executing work
//				items.
//
// Arguments:
//	PVOID pvParameter	- Pointer to thread parameter data.
//
// Returns: DWORD
//=============================================================================
DWORD WINAPI DPTPMandatoryThreadProc(PVOID pvParameter)
{
	DPTPMANDATORYTHREAD *	pMandatoryThread = (DPTPMANDATORYTHREAD*) pvParameter;
	DPTHREADPOOLOBJECT *	pDPTPObject;
	PFNDPNMESSAGEHANDLER	pfnMsgHandler;
	PVOID					pvMsgHandlerContext;
	PVOID					pvUserThreadContext;
	HRESULT					hr;
	DWORD					dwResult;


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pvParameter);


	//
	// Save a copy of the local object.
	//
	pDPTPObject = pMandatoryThread->pDPTPObject;

#ifdef DBG
	//
	// Store the thread ID.
	//
	pMandatoryThread->dwThreadID = GetCurrentThreadId();
#endif // DBG


	//
	// Take the lock, and then ensure we aren't in DoWork mode.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);

	if (pDPTPObject->dwTotalUserThreadCount == 0)
	{
		//
		// Bail out of this function.  The thread starting us still owns the
		// pMandatoryThread memory and will handle this failure correctly.
		//
		DNLeaveCriticalSection(&pDPTPObject->csLock);
		return DPNERR_NOTALLOWED;
	}

	//
	// Increment the thread count.  We use interlocked increment because we can
	// touch the counter outside of the lock below.
	//
	DNASSERT(pDPTPObject->dwMandatoryThreadCount != -1);
	DNInterlockedIncrement((LPLONG) (&pDPTPObject->dwMandatoryThreadCount));

#ifdef DBG
	//
	// Add this thread to the list of tracked threads.
	//
	pMandatoryThread->blList.InsertBefore(&pDPTPObject->blMandatoryThreads);
#endif // DBG

	DNLeaveCriticalSection(&pDPTPObject->csLock);


	//
	// Save the current user message handler.  If there is one, call it now
	// with thread initialization information.
	//
	pfnMsgHandler = pMandatoryThread->pfnMsgHandler;
	if (pfnMsgHandler != NULL)
	{
		DPNMSG_CREATE_THREAD	MsgCreateThread;


		//
		// Save the message handler context.
		//
		pvMsgHandlerContext = pMandatoryThread->pvMsgHandlerContext;


		//
		// Call the user's message handler with a CREATE_THREAD message.
		//

		MsgCreateThread.dwSize			= sizeof(MsgCreateThread);
		MsgCreateThread.dwFlags			= DPNTHREAD_MANDATORY;
		MsgCreateThread.dwProcessorNum	= -1;
		MsgCreateThread.pvUserContext	= NULL;

		hr = pfnMsgHandler(pvMsgHandlerContext,
							DPN_MSGID_CREATE_THREAD,
							&MsgCreateThread);
#ifdef DBG
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "User returned error 0x%08x from CREATE_THREAD indication!",
				1, hr);
		}
#endif // DBG

		//
		// Save what the user returned for a thread context.
		//
		pvUserThreadContext = MsgCreateThread.pvUserContext;
	}


	//
	// Alert the creator thread.  After this call, we own the pMandatoryThread
	// memory.
	//

	DPFX(DPFPREP, 9, "Thread created successfully, setting event.");

	DNASSERT(pMandatoryThread->hStartedEvent != NULL);
	DNSetEvent(pMandatoryThread->hStartedEvent);	// ignore error


	//
	// Call the user's thread proc function.
	//

	DPFX(DPFPREP, 2, "Calling user thread function 0x%p with parameter 0x%p.",
		pMandatoryThread->lpStartAddress, pMandatoryThread->lpParameter);

	dwResult = pMandatoryThread->lpStartAddress(pMandatoryThread->lpParameter);

	DPFX(DPFPREP, 2, "Returning from user thread with result %u/0x%x.",
		dwResult, dwResult);


	//
	// If there was a user message handler, call it now with thread shutdown
	// information.
	//
	if (pfnMsgHandler != NULL)
	{
		DPNMSG_DESTROY_THREAD	MsgDestroyThread;


		//
		// Call the user's message handler with a DESTROY_THREAD message.
		//

		MsgDestroyThread.dwSize				= sizeof(MsgDestroyThread);
		MsgDestroyThread.dwProcessorNum		= -1;
		MsgDestroyThread.pvUserContext		= pvUserThreadContext;

		hr = pfnMsgHandler(pvMsgHandlerContext,
							DPN_MSGID_DESTROY_THREAD,
							&MsgDestroyThread);
#ifdef DBG
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "User returned error 0x%08x from DESTROY_THREAD indication!",
				1, hr);
		}
#endif // DBG

		pfnMsgHandler = NULL;
		pvMsgHandlerContext = NULL;
		pvUserThreadContext = NULL;
	}

	//
	// Assert that the thread pool object is still valid.
	//
	DNASSERT((pDPTPObject->Sig[0] == 'D') && (pDPTPObject->Sig[1] == 'P') && (pDPTPObject->Sig[2] == 'T') && (pDPTPObject->Sig[3] == 'P'));

#ifdef DBG
	//
	// Remove this thread from the list of tracked threads.
	//
	DNEnterCriticalSection(&pDPTPObject->csLock);
	pMandatoryThread->blList.RemoveFromList();
	DNLeaveCriticalSection(&pDPTPObject->csLock);
#endif // DBG

	//
	// Release the object resources.
	//
	DNFree(pMandatoryThread);
	pMandatoryThread = NULL;


	DPFX(DPFPREP, 6, "Leave (mandatory thread count was approximately %u)",
		pDPTPObject->dwMandatoryThreadCount);

	//
	// Signal to the object that this thread is gone.  There is a race
	// condition because we've set the counter, but there are a non-zero number
	// of instructions we still have to execute before this thread is truly
	// gone.  COM has a similar race condition, and if the live with it, so can
	// we.  Because we want to minimize the number of instructions afterward,
	// note that we use interlocked decrement outside of the critical section.
	//
	DNASSERT(pDPTPObject->dwMandatoryThreadCount > 0);
	DNInterlockedDecrement((LPLONG) (&pDPTPObject->dwMandatoryThreadCount));

	return dwResult;
} // DPTPMandatoryThreadProc

#endif // DPNBUILD_MANDATORYTHREADS


#undef DPF_MODNAME
#define DPF_MODNAME "DPTPWorkerLoop"
//=============================================================================
// DPTPWorkerLoop
//-----------------------------------------------------------------------------
//
// Description:    The worker thread looping function for executing work items.
//
// Arguments:
//	DPTPWORKQUEUE * pWorkQueue	- Pointer to work queue object to use.
//
// Returns: None.
//=============================================================================
void DPTPWorkerLoop(DPTPWORKQUEUE * const pWorkQueue)
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
{
	BOOL			fShouldRun = TRUE;
	BOOL			fRunningAsTimerThread = FALSE;
	DWORD			dwBytesTransferred;
	DWORD			dwCompletionKey;
	OVERLAPPED *	pOverlapped;
	CWorkItem *		pWorkItem;
	DWORD			dwNumBusyThreads;
	DWORD			dwNumRunningThreads;
	BOOL			fResult;
	UINT			uiOriginalUniqueID;
#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
	DWORD			dwStartTime;
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pWorkQueue);


	//
	// Keep looping until we're told to exit.
	//
	while (fShouldRun)
	{
		//
		// If we're not already running as a timer thread, atomically see if
		// there is currently a timer thread, and become it if not.
		// There can be only one.
		//
		if (! fRunningAsTimerThread)
		{
			fRunningAsTimerThread = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
														(LONG) FALSE);
#ifdef DBG
			if (fRunningAsTimerThread)
			{
				DPFX(DPFPREP, 9, "Becoming timer thread.");
			}
#endif // DBG
		}


		//
		// If we're the timer thread, wake up periodically to service timers by
		// waiting on a waitable timer object.  Otherwise, wait for a queue
		// item.
		//
		if (fRunningAsTimerThread)
		{
			DWORD	dwResult;


			//DPFX(DPFPREP, 9, "Waiting on timer handle 0x%p.", pWorkQueue->hTimer);
			dwResult = DNWaitForSingleObject(pWorkQueue->hTimer, INFINITE);
			DNASSERT(dwResult == WAIT_OBJECT_0);


			//
			// Handle any expired or cancelled timer entries.
			//
			ProcessTimers(pWorkQueue);

			//
			// Increase the number of busy threads.
			//
			dwNumBusyThreads = DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwNumBusyThreads));

			//
			// Grab the current total thread count.
			//
			dwNumRunningThreads = *((volatile DWORD *) (&pWorkQueue->dwNumRunningThreads));

			//
			// If there are other threads, we won't attempt to process work
			// unless they're all busy.
			//
			if ((dwNumRunningThreads == 1) || (dwNumBusyThreads == dwNumRunningThreads))
			{
#ifdef DBG
				if (dwNumRunningThreads > 1)	// reduce spew when only running 1 thread
				{
					DPFX(DPFPREP, 9, "No idle threads (busy = %u), may become worker thread.",
						dwNumBusyThreads);
				}
#endif // DBG

#pragma TODO(vanceo, "Optimize single thread case (right now we only process one item per timer bucket)")

				//
				// See if there's any work to do at the moment.
				//
				fResult = GetQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
													&dwBytesTransferred,
													&dwCompletionKey,
													&pOverlapped,
													0);
				if ((fResult) || (pOverlapped != NULL))
				{
					pWorkItem = CONTAINING_OBJECT(pOverlapped, CWorkItem, m_Overlapped);
					DNASSERT(pWorkItem->IsValid());


					DPFX(DPFPREP, 8, "Abdicating timer thread responsibilities.");

#ifdef DPNBUILD_THREADPOOLSTATISTICS
					//
					// Update the debugging/tuning statistics.
					//
					pWorkQueue->dwTotalNumTimerThreadAbdications++;
#endif // DPNBUILD_THREADPOOLSTATISTICS

					DNASSERT(! pWorkQueue->fTimerThreadNeeded);
#pragma TODO(vanceo, "Does this truly need to be interlocked?")
					fRunningAsTimerThread = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
																(LONG) TRUE);
					DNASSERT(! fRunningAsTimerThread); // there had better not be more than one timer thread


					//
					// Call the user's function or note that we may need to
					// stop running.
					//
					if (pWorkItem->m_pfnWorkCallback != NULL)
					{
						//
						// Save the uniqueness ID to determine if this item was
						// a timer that got rescheduled.
						//
						uiOriginalUniqueID = pWorkItem->m_uiUniqueID;

						DPFX(DPFPREP, 8, "Begin executing work item 0x%p (fn = 0x%p, context = 0x%p, unique = %u, queue = 0x%p) as previous timer thread.",
							pWorkItem, pWorkItem->m_pfnWorkCallback,
							pWorkItem->m_pvCallbackContext, uiOriginalUniqueID,
							pWorkQueue);

						ThreadpoolStatsBeginExecuting(pWorkItem);
						pWorkItem->m_pfnWorkCallback(pWorkItem->m_pvCallbackContext,
													pWorkItem,
													uiOriginalUniqueID);

						//
						// Return the item to the pool unless it got
						// rescheduled.  This assumes that the actual pWorkItem
						// memory remains valid even though it may have been
						// rescheduled and then completed/cancelled by the time
						// we perform this test.  See CancelTimer.
						//
						if (uiOriginalUniqueID == pWorkItem->m_uiUniqueID)
						{
							ThreadpoolStatsEndExecuting(pWorkItem);
							DPFX(DPFPREP, 8, "Done executing work item 0x%p, returning to pool.", pWorkItem);
							pWorkQueue->pWorkItemPool->Release(pWorkItem);
						}
						else
						{
							ThreadpoolStatsEndExecutingRescheduled(pWorkItem);
							DPFX(DPFPREP, 8, "Done executing work item 0x%p, it was rescheduled.", pWorkItem);
						}
					}
					else
					{
						//
						// If there are any other threads, requeue the kill
						// thread work item, otherwise, quit.
						//
						if (dwNumRunningThreads > 1)
						{
							DPFX(DPFPREP, 3, "Requeuing exit thread work item 0x%p for other threads.",
								pWorkItem);

							fResult = PostQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
																0,
																0,
																&pWorkItem->m_Overlapped);
							DNASSERT(fResult);
						}
						else
						{
							DPFX(DPFPREP, 3, "Recognized exit thread work item 0x%p as previous timer thread.",
								pWorkItem);

							//
							// Return the item to the pool.
							//
							pWorkQueue->pWorkItemPool->Release(pWorkItem);

							//
							// Bail out of the 'while' loop.
							//
							fShouldRun = FALSE;
						}
					}
				}
				else
				{
					//
					// No queued work at the moment.
					//
				}
			}
			else
			{
				//DPFX(DPFPREP, 9, "Other non-busy threads exist, staying as timer thread (busy = %u, total = %u).", dwNumBusyThreads, dwNumRunningThreads);
			}
		}
		else
		{
#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			dwStartTime = GETTIMESTAMP();
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE

			//DPFX(DPFPREP, 9, "Getting queued packet on completion port 0x%p.", pWorkQueue->hIoCompletionPort);
			fResult = GetQueuedCompletionStatus(HANDLE_FROM_DNHANDLE(pWorkQueue->hIoCompletionPort),
												&dwBytesTransferred,
												&dwCompletionKey,
												&pOverlapped,
												INFINITE);

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwTotalTimeSpentUnsignalled),
									(GETTIMESTAMP() - dwStartTime));
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE

			DNASSERT(pOverlapped != NULL);

			pWorkItem = CONTAINING_OBJECT(pOverlapped, CWorkItem, m_Overlapped);
			DNASSERT(pWorkItem->IsValid());

			//
			// Increase the number of busy threads.
			//
			dwNumBusyThreads = DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwNumBusyThreads));

			//
			// Call the user's function or note that we need to stop running.
			//
			if (pWorkItem->m_pfnWorkCallback != NULL)
			{
				//
				// Save the uniqueness ID to determine if this item was a timer
				// that got rescheduled.
				//
				uiOriginalUniqueID = pWorkItem->m_uiUniqueID;

				DPFX(DPFPREP, 8, "Begin executing work item 0x%p (fn = 0x%p, context = 0x%p, unique = %u, queue = 0x%p) as worker thread.",
					pWorkItem, pWorkItem->m_pfnWorkCallback,
					pWorkItem->m_pvCallbackContext, uiOriginalUniqueID,
					pWorkQueue);

				ThreadpoolStatsBeginExecuting(pWorkItem);
				pWorkItem->m_pfnWorkCallback(pWorkItem->m_pvCallbackContext,
											pWorkItem,
											uiOriginalUniqueID);

				//
				// Return the item to the pool unless it got rescheduled.  This
				// assumes that the actual pWorkItem memory remains valid even
				// though it may have been rescheduled and then completed/
				// cancelled by the time we perform this test.  See
				// CancelTimer.
				//
				if (uiOriginalUniqueID == pWorkItem->m_uiUniqueID)
				{
					ThreadpoolStatsEndExecuting(pWorkItem);
					DPFX(DPFPREP, 8, "Done executing work item 0x%p, returning to pool.", pWorkItem);
					pWorkQueue->pWorkItemPool->Release(pWorkItem);
				}
				else
				{
					ThreadpoolStatsEndExecutingRescheduled(pWorkItem);
					DPFX(DPFPREP, 8, "Done executing work item 0x%p, it was rescheduled.", pWorkItem);
				}
			}
			else
			{
				DPFX(DPFPREP, 3, "Recognized exit thread work item 0x%p as worker thread.",
					pWorkItem);

				//
				// Return the item to the pool.
				//
				pWorkQueue->pWorkItemPool->Release(pWorkItem);

				//
				// Bail out of the 'while' loop.
				//
				fShouldRun = FALSE;
			}
		}

		//
		// Revert the busy count.
		//
		DNInterlockedDecrement((LPLONG) (&pWorkQueue->dwNumBusyThreads));
	} // end while (should keep running)

	DPFX(DPFPREP, 6, "Leave");
} // DPTPWorkerLoop
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
{
	BOOL				fShouldRun = TRUE;
	BOOL				fRunningAsTimerThread = FALSE;
	BOOL				fSetAndWait = FALSE;
	DNSLIST_ENTRY *		pSlistEntryHead;
	DNSLIST_ENTRY *		pSlistEntryTail;
	USHORT				usCount;
	DWORD				dwNumBusyThreads;
	DWORD				dwNumRunningThreads;
	CWorkItem *			pWorkItem;
	DWORD				dwResult;
	DWORD				dwWaitTimeout;
	DNHANDLE			hWaitObject;
	UINT				uiOriginalUniqueID;
#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
	DWORD				dwStartTime;
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", pWorkQueue);


	//
	// When we can't use waitable timers, we always wait on the same object,
	// but the timeout can differ.  If we can use waitable timers, the timeout
	// is always INFINITE.
	//
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
	dwWaitTimeout = INFINITE;
#else // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
	hWaitObject = pWorkQueue->hAlertEvent;
#endif // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)


	//
	// Keep looping until we're told to exit.
	//
	while (fShouldRun)
	{
		//
		// We also have an additional optimization technique that attempts to
		// minimize the amount that the timer responsibility passes from thread
		// to thread.  It only truly works on NT, because of the atomic
		// SignalObjectAndWait function.  Having separate SetEvent and Wait
		// operations could mean an extra context switch: SetEvent causes a
		// waiting thread to take over, then when the timer thread is activated
		// again, it just goes back to waiting.
		//
		// But we'll still execute the code on 9x (when we can use waitable
		// timers).  The real problem is on CE, where the event to set and the
		// event on which the timer thread waits are the same, so it would
		// almost certainly just be waking itself up.  So if we're not using
		// waitable timers, we set the event at a different location in an
		// attempt to reduce this possibility.
		//
		// You'll probably need to understand the rest of this function for
		// this "optimization" to make much sense.
		//
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
		if (fSetAndWait)
		{
			DNASSERT(fRunningAsTimerThread);

			DPFX(DPFPREP, 8, "Signalling event 0x%p and waiting on timer 0x%p.",
				pWorkQueue->hAlertEvent, pWorkQueue->hTimer);

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			dwStartTime = GETTIMESTAMP();
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE

			dwResult = DNSignalObjectAndWait(pWorkQueue->hAlertEvent,
											pWorkQueue->hTimer,
											INFINITE,
											FALSE);

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwTotalTimeSpentUnsignalled),
									(GETTIMESTAMP() - dwStartTime));
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE

			//
			// Clear the flag.
			//
			fSetAndWait = FALSE;
		}
		else
#endif // WINNT or (WIN95 and ! DPNBUILD_NOWAITABLETIMERSON9X)
		{
			//
			// If we're not already running as a timer thread, atomically see
			// if there is currently a timer thread, and become it if not.
			// There can be only one.
			//
			if (! fRunningAsTimerThread)
			{
				fRunningAsTimerThread = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
															(LONG) FALSE);
#ifdef DBG
				if (fRunningAsTimerThread)
				{
					DPFX(DPFPREP, 9, "Becoming timer thread.");
				}
#endif // DBG
			}

			//
			// Normally we wait for a work item.  If we're the timer thread, we
			// need to wake up at regular intervals to service any timer
			// entries. On CE, that is done by using a timeout value for our
			// Wait operation.  On desktop, we use a waitable timer object.
			//
			if (fRunningAsTimerThread)
			{
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
				hWaitObject = pWorkQueue->hTimer;
#else // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
				dwWaitTimeout = TIMER_BUCKET_GRANULARITY(pWorkQueue);
#endif // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
			}
			else
			{
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
				hWaitObject = pWorkQueue->hAlertEvent;
#else // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
				dwWaitTimeout = INFINITE;
#endif // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
			}

			//DPFX(DPFPREP, 9, "Waiting on handle 0x%p for %i ms.", hWaitObject, (int) dwWaitTimeout);

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			dwStartTime = GETTIMESTAMP();
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE

			dwResult = DNWaitForSingleObject(hWaitObject, dwWaitTimeout);

#if ((defined(DPNBUILD_THREADPOOLSTATISTICS)) && (! defined(WINCE)))
			DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwTotalTimeSpentUnsignalled),
									(GETTIMESTAMP() - dwStartTime));
#endif // DPNBUILD_THREADPOOLSTATISTICS and ! WINCE
		}
		DNASSERT((dwResult == WAIT_OBJECT_0) || (dwResult == WAIT_TIMEOUT));


		//
		// Prepare to collect some work items that need to be queued.
		//
		pSlistEntryHead = NULL;
		usCount = 0;


#ifndef WINCE
		//
		// Handle any I/O completions.
		//
		ProcessIo(pWorkQueue, &pSlistEntryHead, &pSlistEntryTail, &usCount);
#endif // ! WINCE


		//
		// If we're acting as the timer thread, retrieve any expired or
		// cancelled timer entries.
		//
		if (fRunningAsTimerThread)
		{
			ProcessTimers(pWorkQueue, &pSlistEntryHead, &pSlistEntryTail, &usCount);
		}


		//
		// Queue any work items we accumulated in one fell swoop.
		//
		if (pSlistEntryHead != NULL)
		{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
			if (usCount > 1)
			{
				DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumSimultaneousQueues));
			}
#ifdef WINCE
			LONG	lCount;

			lCount = usCount;
			while (lCount > 0)
			{
				DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumWorkItems));
				lCount--;
			}
#else // ! WINCE
			DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwTotalNumWorkItems), usCount);
#endif // ! WINCE
#endif // DPNBUILD_THREADPOOLSTATISTICS

			DNAppendListNBQueue(pWorkQueue->pvNBQueueWorkItems,
								pSlistEntryHead,
								OFFSETOF(CWorkItem, m_SlistEntry));
		}


		//
		// Increase the number of busy threads.
		//
		dwNumBusyThreads = DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwNumBusyThreads));

		//
		// We may be able to optimize context switching for the timer thread,
		// so treat it differently.  Worker threads should just go straight to
		// running through the queue (if possible).
		//
		if (fRunningAsTimerThread)
		{
			//
			// Grab the current total thread count.
			//
			dwNumRunningThreads = *((volatile DWORD *) (&pWorkQueue->dwNumRunningThreads));

			//
			// If we didn't add any work items, there's no point in this timer
			// thread looking for jobs to execute.  If we found one, we'd have
			// to wake another thread so it could become the timer thread while
			// we processed the item, and thus incur a context switch.
			// Besides, if someone other than us added any work, they would
			// have set the alert event already.
			//
			// There are two exceptions to that rule.  One is if there is only
			// this one thread, in which case we must process any work items
			// because there's no one else who can.  The other is on platforms
			// without waitable timers.  In that case, we may have dropped
			// through not because the time elapsed, but rather because the
			// event was set.  So to prevent us from eating these alerts, we
			// will check for any work to do.
			//
			if ((usCount == 0) && (dwNumRunningThreads > 1))
			{
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
				//DPFX(DPFPREP, 9, "No work items added, staying as timer thread (busy = %u, total = %u).", dwNumBusyThreads, dwNumRunningThreads);

				//
				// Don't execute any work.
				//
				pWorkItem = NULL;
#else // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
				//
				// See the comments above and below.  If we find something to
				// do, we need to try to make another thread the timer thread
				// while we work on this item.
				//
				pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
				if (pWorkItem != NULL)
				{
					DPFX(DPFPREP, 9, "No work items added, but there's some in the queue, becoming worker thread (busy = %u, total = %u).",
						dwNumBusyThreads, dwNumRunningThreads);
					fSetAndWait = TRUE;
				}
				else
				{
					//DPFX(DPFPREP, 9, "No work items, staying as timer thread (busy = %u, total = %u).", dwNumBusyThreads, dwNumRunningThreads);
				}
#endif // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
			}
			else
			{
				//
				// We added work, so we may need to notify other threads.
				//
				// If it appears that there are enough idle threads to handle
				// the work that we added, don't bother executing any work in
				// this timer thread.  We will need to alert other threads
				// about the work, but as stated above, we would need to wake
				// another thread anyway even if we did execute it in this
				// thread.  On NT, we get a nice optimization that allows us to
				// alert a thread and go to sleep atomically (see above), so
				// it's not too painful.
				//
				// Otherwise, all other threads are busy, so we should just
				// execute the work in this thread.  The first thread to
				// complete the work will become the new timer thread.
				//
				if (dwNumBusyThreads < dwNumRunningThreads)
				{
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
					DPFX(DPFPREP, 9, "Other non-busy threads exist, staying as timer thread (busy = %u, total = %u, added %u items).",
						dwNumBusyThreads,
						dwNumRunningThreads,
						usCount);

					//
					// Don't execute any work, and set the event up top.
					//
					pWorkItem = NULL;
					fSetAndWait = TRUE;
#else // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
					//
					// Because CE sets and waits on the same event, we opt to
					// make this timer thread a worker thread anyway, and set
					// the alert event sooner.  See comments at the top and
					// down below for more details.
					//
					// So attempt to pop the next work item off the stack.
					// Note that theoretically all of the work we added could
					// have been processed already, so we might still end up
					// with nothing to do.  Don't enable fSetAndWait if that's
					// the case.
					//
					DPFX(DPFPREP, 9, "Trying to become worker thread (busy = %u, total = %u, added %u items).",
						dwNumBusyThreads,
						dwNumRunningThreads,
						usCount);
					pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
					if (pWorkItem != NULL)
					{
						fSetAndWait = TRUE;
					}
#endif // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
				}
				else
				{
#ifdef DBG
					if (dwNumRunningThreads > 1)	// reduce spew when only running 1 thread
					{
						DPFX(DPFPREP, 9, "No idle threads (busy = %u) after adding %u items, may become worker thread.",
							dwNumBusyThreads, usCount);
					}
#endif // DBG

					//
					// Attempt to pop the next work item off the stack.
					// Note that theoretically all of the work we added could
					// have been processed already, so we could end up with
					// nothing to do.
					//
					pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
				}
			} // end else (added work from timers or I/O)
		}
		else
		{
			//
			// Not a timer thread.  Attempt to pop the next work item off the
			// stack, if any.
			//
			pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
#ifdef DPNBUILD_THREADPOOLSTATISTICS
			if (pWorkItem == NULL)
			{
				DPFX(DPFPREP, 7, "No items for worker thread (busy = %u, had added %u items to queue 0x%p).",
					dwNumBusyThreads, usCount, pWorkQueue);
				DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumWakesWithoutWork));
			}
#endif // DPNBUILD_THREADPOOLSTATISTICS
		}

		//
		// Execute as many work items in a row as possible.
		//
		while (pWorkItem != NULL)
		{
			//
			// If we were acting as the timer thread, we need another thread to
			// take over that responsibility while we're busy processing what
			// could be a long work item.
			//
			if (fRunningAsTimerThread)
			{
				DPFX(DPFPREP, 8, "Abdicating timer thread responsibilities.");
	
#ifdef DPNBUILD_THREADPOOLSTATISTICS
				//
				// Update the debugging/tuning statistics.
				//
				pWorkQueue->dwTotalNumTimerThreadAbdications++;
#endif // DPNBUILD_THREADPOOLSTATISTICS

				DNASSERT(! pWorkQueue->fTimerThreadNeeded);
#pragma TODO(vanceo, "Does this truly need to be interlocked?")
				fRunningAsTimerThread = DNInterlockedExchange((LPLONG) (&pWorkQueue->fTimerThreadNeeded),
															(LONG) TRUE);
				DNASSERT(! fRunningAsTimerThread); // there had better not be more than one timer thread

				//
				// On CE (or 9x, if we're not using waitable timers), we may
				// also need to kick other threads so that they notice there's
				// no timer thread any more.  We endure SetEvent's unfortunate
				// context switch because if this turned out to be a really
				// long job, and no I/O or newly queued work items jolt the
				// other threads out of their Waits, timers could go unserviced
				// until this thread finishes.  We choose to have more accurate
				// timers.
				//
				// We do this now because it's more efficient to switch to
				// another thread now than run the risk of just alerting
				// ourselves (see the comments at the top of this function).
				//
				// On desktop, we should only get in here if we couldn't alert
				// any other threads, so it wouldn't make sense to SetEvent.
				//
#pragma TODO(vanceo, "We may be able to live with some possible loss of timer response, if we could assume we'll get I/O or queued work items")
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
				DNASSERT(! fSetAndWait);
#else // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
				if (fSetAndWait)
				{
					DNSetEvent(pWorkQueue->hAlertEvent); // ignore potential failure, there's nothing we could do
					fSetAndWait = FALSE;
				}
#endif // ! WINNT and (! WIN95 or DPNBUILD_NOWAITABLETIMERSON9X)
			}

			//
			// Call the user's function or note that we need to stop running.
			//
			if (pWorkItem->m_pfnWorkCallback != NULL)
			{
				//
				// Save the uniqueness ID to determine if this item was a timer
				// that got rescheduled.
				//
				uiOriginalUniqueID = pWorkItem->m_uiUniqueID;

				DPFX(DPFPREP, 8, "Begin executing work item 0x%p (fn = 0x%p, context = 0x%p, unique = %u, queue = 0x%p).",
					pWorkItem, pWorkItem->m_pfnWorkCallback,
					pWorkItem->m_pvCallbackContext, uiOriginalUniqueID,
					pWorkQueue);

				ThreadpoolStatsBeginExecuting(pWorkItem);
				pWorkItem->m_pfnWorkCallback(pWorkItem->m_pvCallbackContext,
											pWorkItem,
											uiOriginalUniqueID);

				//
				// Return the item to the pool unless it got rescheduled.  This
				// assumes that the actual pWorkItem memory remains valid even
				// though it may have been rescheduled and then completed/
				// cancelled by the time we perform this test.  See
				// CancelTimer.
				//
				if (uiOriginalUniqueID == pWorkItem->m_uiUniqueID)
				{
					ThreadpoolStatsEndExecuting(pWorkItem);
					DPFX(DPFPREP, 8, "Done executing work item 0x%p, returning to pool.", pWorkItem);
					pWorkQueue->pWorkItemPool->Release(pWorkItem);
				}
				else
				{
					ThreadpoolStatsEndExecutingRescheduled(pWorkItem);
					DPFX(DPFPREP, 8, "Done executing work item 0x%p, it was rescheduled.", pWorkItem);
				}
			}
			else
			{
				DPFX(DPFPREP, 3, "Recognized exit thread work item 0x%p.",
					pWorkItem);

				//
				// Return the item to the pool.
				//
				pWorkQueue->pWorkItemPool->Release(pWorkItem);

				//
				// We're about to bail out of the processing loop, so we need
				// other threads to notice.  It's possible that all threads
				// were busy so that the alert event was set twice before any
				// thread noticed it, and only this thread was released.  In
				// that case, we need the other threads to start processing.
				//
				if (! DNIsNBQueueEmpty(pWorkQueue->pvNBQueueWorkItems))
				{
					DNSetEvent(pWorkQueue->hAlertEvent); // ignore potential failure, there's nothing we could do
				}

				//
				// Bail out of both 'while' loops.
				//
				fShouldRun = FALSE;
				break;
			}


#ifndef WINCE
			//
			// Handle any I/O completions that came in while we were working.
			//
			pSlistEntryHead = NULL;
			usCount = 0;
			ProcessIo(pWorkQueue, &pSlistEntryHead, &pSlistEntryTail, &usCount);


			//
			// Queue any I/O operations that completed.
			//
			if (pSlistEntryHead != NULL)
			{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
				if (usCount > 1)
				{
					DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumSimultaneousQueues));
				}
				DNInterlockedExchangeAdd((LPLONG) (&pWorkQueue->dwTotalNumWorkItems), usCount);
#endif // DPNBUILD_THREADPOOLSTATISTICS

				DNAppendListNBQueue(pWorkQueue->pvNBQueueWorkItems,
									pSlistEntryHead,
									OFFSETOF(CWorkItem, m_SlistEntry));
			}
#endif // ! WINCE


			//
			// Look for another work item.
			//
			pWorkItem = (CWorkItem*) DNRemoveHeadNBQueue(pWorkQueue->pvNBQueueWorkItems);
#ifdef DPNBUILD_THREADPOOLSTATISTICS
			if (pWorkItem != NULL)
			{
				DNInterlockedIncrement((LPLONG) (&pWorkQueue->dwTotalNumContinuousWork));
			}
#endif // DPNBUILD_THREADPOOLSTATISTICS
		} // end while (more work items)

		//
		// Revert the busy count.
		//
		DNInterlockedDecrement((LPLONG) (&pWorkQueue->dwNumBusyThreads));
	} // end while (should keep running)


	DPFX(DPFPREP, 6, "Leave");
} // DPTPWorkerLoop
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

#endif // ! DPNBUILD_ONLYONETHREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\timers.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       timers.h
 *
 *  Content:	DirectPlay Thread Pool timer functions header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __TIMERS_H__
#define __TIMERS_H__





//=============================================================================
// Defines
//=============================================================================
#define DEFAULT_TIMER_BUCKET_GRANULARITY	4		// each timer bucket represents 4 ms of time, it must be a power of 2
#define DEFAULT_NUM_TIMER_BUCKETS			1024	// store 1024 buckets (at 4 ms a pop, we track a total of 4096 ms of time)


#ifdef DPNBUILD_DYNAMICTIMERSETTINGS

#define TIMER_BUCKET_GRANULARITY(pWorkQueue)				(pWorkQueue)->dwTimerBucketGranularity
#define TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue)		(pWorkQueue)->dwTimerBucketGranularityCeiling
#define TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue)		(pWorkQueue)->dwTimerBucketGranularityFloorMask
#define TIMER_BUCKET_GRANULARITY_DIVISOR(pWorkQueue)		(pWorkQueue)->dwTimerBucketGranularityDivisor
#define NUM_TIMER_BUCKETS(pWorkQueue)						(pWorkQueue)->dwNumTimerBuckets
#define NUM_TIMER_BUCKETS_MOD_MASK(pWorkQueue)				(pWorkQueue)->dwNumTimerBucketsModMask

#else // ! DPNBUILD_DYNAMICTIMERSETTINGS

//
// The granularity must be a power of 2 in order for our ceiling, mask and
// divisor optimizations to work.
//
#define TIMER_BUCKET_GRANULARITY(pWorkQueue)				DEFAULT_TIMER_BUCKET_GRANULARITY
#if	((DEFAULT_TIMER_BUCKET_GRANULARITY - 1) & DEFAULT_TIMER_BUCKET_GRANULARITY)
This Will Not Compile -- DEFAULT_TIMER_BUCKET_GRANULARITY must be a power of 2!
#endif
#define TIMER_BUCKET_GRANULARITY_CEILING(pWorkQueue)		(DEFAULT_TIMER_BUCKET_GRANULARITY - 1)
#define TIMER_BUCKET_GRANULARITY_FLOOR_MASK(pWorkQueue)		(~(DEFAULT_TIMER_BUCKET_GRANULARITY - 1))	// negating the ceiling round factor (which happens to also be the modulo mask) gives us the floor mask
#define TIMER_BUCKET_GRANULARITY_DIVISOR(pWorkQueue)		(DEFAULT_TIMER_BUCKET_GRANULARITY >> 1)

//
// The bucket count must be a power of 2 in order for our mask optimizations to
// work.
//
#define NUM_TIMER_BUCKETS(pWorkQueue)						DEFAULT_NUM_TIMER_BUCKETS
#if	((DEFAULT_NUM_TIMER_BUCKETS - 1) & DEFAULT_NUM_TIMER_BUCKETS)
This Will Not Compile -- DEFAULT_NUM_TIMER_BUCKETS must be a power of 2!
#endif
#define NUM_TIMER_BUCKETS_MOD_MASK(pWorkQueue)				(DEFAULT_NUM_TIMER_BUCKETS - 1)

#endif // ! DPNBUILD_DYNAMICTIMERSETTINGS





//=============================================================================
// Function prototypes
//=============================================================================
HRESULT InitializeWorkQueueTimerInfo(DPTPWORKQUEUE * const pWorkQueue);

void DeinitializeWorkQueueTimerInfo(DPTPWORKQUEUE * const pWorkQueue);

BOOL ScheduleTimer(DPTPWORKQUEUE * const pWorkQueue,
					const DWORD dwDelay,
					const PFNDPTNWORKCALLBACK pfnWorkCallback,
					PVOID const pvCallbackContext,
					void ** const ppvTimerData,
					UINT * const puiTimerUnique);

HRESULT CancelTimer(void * const pvTimerData,
					const UINT uiTimerUnique);

void ResetCompletingTimer(void * const pvTimerData,
						const DWORD dwNewDelay,
						const PFNDPTNWORKCALLBACK pfnNewWorkCallback,
						PVOID const pvNewCallbackContext,
						UINT * const puiNewTimerUnique);

#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
void ProcessTimers(DPTPWORKQUEUE * const pWorkQueue);
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
void ProcessTimers(DPTPWORKQUEUE * const pWorkQueue,
					DNSLIST_ENTRY ** const ppHead,
					DNSLIST_ENTRY ** const ppTail,
					USHORT * const pusCount);
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS




#endif // __TIMERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\work.h ===
/******************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       work.h
 *
 *  Content:	DirectPlay Thread Pool work processing functions header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/

#ifndef __WORK_H__
#define __WORK_H__




//=============================================================================
// Defines
//=============================================================================
#ifdef DPNBUILD_THREADPOOLSTATISTICS
#define MAX_TRACKED_CALLBACKSTATS	15	// maximum number of unique work callback functions to track
#endif // DPNBUILD_THREADPOOLSTATISTICS



//=============================================================================
// Forward declarations
//=============================================================================
typedef struct _DPTHREADPOOLOBJECT	DPTHREADPOOLOBJECT;





//=============================================================================
// Structures
//=============================================================================
#ifdef DPNBUILD_THREADPOOLSTATISTICS
typedef struct _CALLBACKSTATS
{
	PFNDPTNWORKCALLBACK		pfnWorkCallback;		// pointer to work callback function whose stats are being tracked
	DWORD					dwNumCreates;			// number of times a work item with this callback was created
	DWORD					dwTotalCompletionTime;	// total time from creation to completion for all I/O operations using this callback, total time from setting to firing for all timers using this callback
	DWORD					dwNumQueues;			// number of times a work item with this callback was queued for completion
	DWORD					dwTotalQueueTime;		// total time from queuing to callback execution for all work items using this callback
	DWORD					dwNumCalls;				// number of times the callback was invoked
	DWORD					dwTotalCallbackTime;	// total time spent in the callback for all work items using this callback that did not reschedule
	DWORD					dwNumNotRescheduled;	// number of times the callback returned without rescheduling
} CALLBACKSTATS, * PCALLBACKSTATS;
#endif // DPNBUILD_THREADPOOLSTATISTICS



typedef struct _DPTPWORKQUEUE
{
	//
	// NOTE: NBQueueBlockInitial must be heap aligned, so it is first in the
	// structure.
	//
#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
	DNNBQUEUE_BLOCK			NBQueueBlockInitial;						// initial tracking info for the work queue or free node list (cast as DNSLIST_ENTRY for the latter) required by NB Queue implementation
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

	BYTE					Sig[4];										// debugging signature ('WRKQ')

	//
	// Volatile data that can get tweaked simultaneously by multiple threads
	//
	CFixedPool *			pWorkItemPool;								// (work) pool of currently unused work items
#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
	DNSLIST_HEADER			SlistFreeQueueNodes;						// (work) pool of nodes used to track work items in non-blocking queue (because of Slist implementation, it can only hold sizeof(WORD) == 65,535 entries)
	PVOID					pvNBQueueWorkItems;							// (work) header for list of work items needing execution (because of Slist implementation, it can only hold sizeof(WORD) == 65,535 entries)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#ifndef DPNBUILD_ONLYONETHREAD
	BOOL					fTimerThreadNeeded;							// (work) boolean indicated whether a worker thread is currently needed as a timer thread (there can be only one)
	DWORD					dwNumThreadsExpected;						// (work) number of threads threads currently starting up/shutting down
	DWORD					dwNumBusyThreads;							// (work) number of threads that are currently processing work items
	DWORD					dwNumRunningThreads;						// (work) number of threads that are currently running
#endif // ! DPNBUILD_ONLYONETHREAD
	DNSLIST_HEADER *		paSlistTimerBuckets;						// (timer) pointer to array of list headers for the timer buckets (because of Slist implementation, each bucket can only hold sizeof(WORD) == 65,535 entries, but that should be plenty)
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	DWORD					dwPossibleMissedTimerWindow;				// (timer) cumulative hint to timer thread about short timers that were possibly missed
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT
	DNSLIST_HEADER			SlistOutstandingIO;							// (I/O) header for list of outstanding I/O waiting for completion (because of Slist implementation, it can only hold sizeof(WORD) == 65,535 entries)

	//
	// Regularly updated data, but it should only get modified by the one timer
	// thread.
	//
	DWORD					dwLastTimerProcessTime;						// (timer) when we last handled timer entries

	//
	// "Constant" data that is read-only for all threads
	//
#if ((! defined(DPNBUILD_ONLYONETHREAD)) && ((! defined(WINCE)) || (defined(DBG))))
	DNCRITICAL_SECTION		csListLock;									// (work) lock protecting list of tracked handles (and list of threads owned by this work queue in debug)
#endif // ! DPNBUILD_ONLYONETHREAD and (! WINCE or DBG)
#ifndef DPNBUILD_ONLYONEPROCESSOR
	DWORD					dwCPUNum;									// (work) the CPU number this queue represents
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#ifdef DPNBUILD_USEIOCOMPLETIONPORTS
	DNHANDLE				hIoCompletionPort;							// (work) I/O completion port used to track I/O and queue work items
#else // ! DPNBUILD_USEIOCOMPLETIONPORTS
	DNHANDLE				hAlertEvent;								// (work) handle to the event used to wake up idle worker threads
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
#ifndef DPNBUILD_ONLYONETHREAD
	DNHANDLE				hExpectedThreadsEvent;						// (work) temporary handle to the event to be set when the desired number of threads are started/stopped
	PFNDPNMESSAGEHANDLER	pfnMsgHandler;								// (work) user's message handler function, or NULL if none.
	PVOID					pvMsgHandlerContext;						// (work) user's context for message handler function
	DWORD					dwWorkerThreadTlsIndex;						// (work) Thread Local Storage index for storing the worker thread data
#endif // ! DPNBUILD_ONLYONETHREAD
	CBilink					blTrackedFiles;								// (I/O) doubly linked list holding all files tracked by this CPU, protected by this work queue's list lock
#ifdef DPNBUILD_DYNAMICTIMERSETTINGS
	DWORD					dwTimerBucketGranularity;					// (timer) the granularity in ms for each timer bucket
	DWORD					dwTimerBucketGranularityCeiling;			// (timer) precalculated addend used when rounding time stamps up to the appropriate granularity, it also happens to be the module mask, but its currently never used that way
	DWORD					dwTimerBucketGranularityFloorMask;			// (timer) precalculated pseudo-modulo bit mask for rounding down time stamps to the appropriate granularity
	DWORD					dwTimerBucketGranularityDivisor;			// (timer) precalculated pseudo-divisor bit shift for converting time into buckets
	DWORD					dwNumTimerBuckets;							// (timer) the number of timer buckets in the array
	DWORD					dwNumTimerBucketsModMask;					// (timer) precalculated pseudo-modulo bit mask for wrapping around the array
#endif // DPNBUILD_DYNAMICTIMERSETTINGS
#if ((defined(WINNT)) || ((defined(WIN95)) && (! defined(DPNBUILD_NOWAITABLETIMERSON9X))))
	DNHANDLE				hTimer;										// (timer) handle to the waitable timer object used to wake up a worker thread periodically
#endif // WINNT or (WIN95 AND ! DPNBUILD_NOWAITABLETIMERSON9X)

#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Debugging/tuning statistics.
	//
	DWORD					dwTotalNumWorkItems;						// (work) total number of work items placed in this queue
#ifndef WINCE
	DWORD					dwTotalTimeSpentUnsignalled;				// (work) total number of milliseconds spent waiting for the alert event to be fired
	DWORD					dwTotalTimeSpentInWorkCallbacks;			// (work) total number of milliseconds spent in work item callbacks
#endif // ! WINCE
#ifndef DPNBUILD_ONLYONETHREAD
	DWORD					dwTotalNumTimerThreadAbdications;			// (work) total number of times the existing timer thread allowed another thread to become the timer thread
#endif // ! DPNBUILD_ONLYONETHREAD
	DWORD					dwTotalNumWakesWithoutWork;					// (work) total number of times a worker thread woke up but found nothing to do
	DWORD					dwTotalNumContinuousWork;					// (work) total number of times a thread found another work item after completing a previous one
	DWORD					dwTotalNumDoWorks;							// (work) total number of times DoWork was called
	DWORD					dwTotalNumDoWorksTimeLimit;					// (work) total number of times DoWork stopped looping due to the time limit
	DWORD					dwTotalNumSimultaneousQueues;				// (work) total number of times more than one work item was queued at the same time
	CALLBACKSTATS			aCallbackStats[MAX_TRACKED_CALLBACKSTATS];	// (work) array of stats for tracked callbacks
	DWORD					dwTotalNumTimerChecks;						// (timer) total number of times any expired timer buckets have been handled
	DWORD					dwTotalNumBucketsProcessed;					// (timer) total number of timer buckets that have been checked
	DWORD					dwTotalNumTimersScheduled;					// (timer) total number of timers that were scheduled
	DWORD					dwTotalNumLongTimersRescheduled;			// (timer) total number of long timers that were rescheduled back into a bucket
	DWORD					dwTotalNumSuccessfulCancels;				// (timer) total number of CancelTimer calls that succeeded
	DWORD					dwTotalNumFailedCancels;					// (timer) total number of CancelTimer calls that failed
#if ((! defined(DPNBUILD_DONTCHECKFORMISSEDTIMERS)) && (! defined(DPNBUILD_NOMISSEDTIMERSHINT)))
	DWORD					dwTotalPossibleMissedTimerWindows;			// (timer) total of all hints to timer thread about possibly missed short timers
#endif // ! DPNBUILD_DONTCHECKFORMISSEDTIMERS and ! DPNBUILD_NOMISSEDTIMERSHINT
#endif // DPNBUILD_THREADPOOLSTATISTICS

#ifdef DBG
#ifndef DPNBUILD_ONLYONETHREAD
	//
	// Structures helpful for debugging.
	//
	CBilink					blThreadList;								// (work) list of all threads owned by this work queue, protected by this work queue's list lock
#endif // ! DPNBUILD_ONLYONETHREAD
#endif // DBG
} DPTPWORKQUEUE, * PDPTPWORKQUEUE;


#ifndef DPNBUILD_ONLYONETHREAD

typedef struct _DPTPWORKERTHREAD
{
	BYTE					Sig[4];					// debugging signature ('WKTD')
	DPTPWORKQUEUE *			pWorkQueue;				// owning work queue
	DWORD					dwRecursionCount;		// recursion count
	BOOL					fThreadIndicated;		// whether CREATE_THREAD has returned and DESTROY_THREAD has not been started yet
#ifdef DBG
	DWORD					dwThreadID;				// ID of thread
	DWORD					dwMaxRecursionCount;	// maximum recursion count over life of thread
	CBilink					blList;					// entry in work queue list of threads
#endif // DBG
} DPTPWORKERTHREAD, * PDPTPWORKERTHREAD;

#ifdef DPNBUILD_MANDATORYTHREADS
typedef struct _DPTPMANDATORYTHREAD
{
	BYTE					Sig[4];					// debugging signature ('MNDT')
	DPTHREADPOOLOBJECT *	pDPTPObject;			// owning thread pool object
	DNHANDLE				hStartedEvent;			// handle of event to set when thread has successfully started
	PFNDPNMESSAGEHANDLER	pfnMsgHandler;			// user's message handler function, or NULL if none.
	PVOID					pvMsgHandlerContext;	// user's context for message handler function
	LPTHREAD_START_ROUTINE	lpStartAddress;			// user start address for thread
	LPVOID					lpParameter;			// user parameter for thread
#ifdef DBG
	DWORD					dwThreadID;				// ID of thread
	CBilink					blList;					// entry in work queue list of threads
#endif // DBG
} DPTPMANDATORYTHREAD, * PDPTPMANDATORYTHREAD;
#endif // DPNBUILD_MANDATORYTHREADS

#endif // ! DPNBUILD_ONLYONETHREAD





//=============================================================================
// Classes
//=============================================================================

//
// It is critical to keep in mind that parts of this class must remain as valid
// memory, even when the item is returned to the pool.  Particularly, the NB
// Queue code will use m_NBQueueBlock to track work item objects other than
// the one whose member is used.  Also, late timers use m_uiUniqueID to detect
// that they are late.
//
// Basically this means the code needs to be revisited if pooling of CWorkItems
// is turned off, or if the pool code is modified to be able to shrink the pool
// (unlike the growth-only mechanism used now).
//

class CWorkItem
{
	public:

#undef DPF_MODNAME
#define DPF_MODNAME "CWorkItem::FPM_Alloc"
		static BOOL FPM_Alloc(void * pvItem, void * pvContext)
		{
			CWorkItem *			pWorkItem = (CWorkItem*) pvItem;


			pWorkItem->m_Sig[0] = 'W';
			pWorkItem->m_Sig[1] = 'O';
			pWorkItem->m_Sig[2] = 'R';
			pWorkItem->m_Sig[3] = 'K';

			//
			// Remember the owning work queue.
			//
			pWorkItem->m_pWorkQueue = (DPTPWORKQUEUE*) pvContext;

#ifdef DBG
			memset(&pWorkItem->m_Overlapped, 0x10, sizeof(pWorkItem->m_Overlapped));
#endif // DBG

			//
			// We will start the unique ID sequence at 0, but it really doesn't
			// matter.  It's technically safe for it to be stack garbage since
			// we only use it for comparison.
			//
			pWorkItem->m_uiUniqueID = 0;

#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
			//
			// Throw the embedded DNNBQUEUE_BLOCK structure into the free list
			// for the queue.  Remember that it may be used to track work items
			// other than this object.
			//
			DNInterlockedPushEntrySList(&((DPTPWORKQUEUE*) pvContext)->SlistFreeQueueNodes,
										(DNSLIST_ENTRY*) (&pWorkItem->m_NBQueueBlock));
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS

			return TRUE;
		}

#undef DPF_MODNAME
#define DPF_MODNAME "CWorkItem::FPM_Get"
		static void FPM_Get(void * pvItem, void * pvContext)
		{
			CWorkItem *			pWorkItem = (CWorkItem*) pvItem;


#ifdef DBG
			memset(&pWorkItem->m_Overlapped, 0, sizeof(pWorkItem->m_Overlapped));
			DNASSERT(pWorkItem->m_pWorkQueue == (DPTPWORKQUEUE*) pvContext);
#endif // DBG

			//
			// Make sure the object is ready to be cancelled.  Really really
			// late cancel attempts on a previous instance should have hit the
			// m_dwUniqueID check.
			//
			pWorkItem->m_fCancelledOrCompleting = FALSE;
		}

#undef DPF_MODNAME
#define DPF_MODNAME "CWorkItem::FPM_Release"
		static void FPM_Release(void * pvItem)
		{
			CWorkItem *		pWorkItem = (CWorkItem*) pvItem;


			//
			// Change the unique ID so that future late cancellation attempts
			// don't bother us.  If the late attempt occurred before we do
			// this, it should have hit the m_fCancelledOrCompleting check.
			// And for non-timer work items, in debug builds we set
			// m_fCancelledOrCompleting to TRUE before queueing so that this
			// assert succeeds as well.
			//
			DNASSERT(pWorkItem->m_fCancelledOrCompleting);
			pWorkItem->m_uiUniqueID++;

#ifdef DBG
			memset(&pWorkItem->m_Overlapped, 0x10, sizeof(pWorkItem->m_Overlapped));
#endif // DBG
		}

		/*
#undef DPF_MODNAME
#define DPF_MODNAME "CWorkItem::FPM_Dealloc"
		static void FPM_Dealloc(void * pvItem)
		{
			CWorkItem *		pWorkItem = (CWorkItem*) pvItem;
		}
		*/

#ifdef DBG
		BOOL IsValid(void)
		{
			if ((m_Sig[0] == 'W') &&
				(m_Sig[1] == 'O') &&
				(m_Sig[2] == 'R') &&
				(m_Sig[3] == 'K'))
			{
				return TRUE;
			}

			return FALSE;
		}
#endif // DBG


		//
		// Generic work item information.
		//
		// NOTE: m_SlistEntry and m_NBQueueBlock must be heap aligned.
		//
		union
		{
			DNSLIST_ENTRY		m_SlistEntry;				// tracking info for the timer bucket list
#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
			BYTE				Alignment[16];				// alignment padding
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
		};
#ifndef DPNBUILD_USEIOCOMPLETIONPORTS
		DNNBQUEUE_BLOCK			m_NBQueueBlock;				// tracking info for the work queue or free node list (cast as DNSLIST_ENTRY for the latter)
#endif // ! DPNBUILD_USEIOCOMPLETIONPORTS
		BYTE					m_Sig[4];					// debugging signature ('WORK')
		DPTPWORKQUEUE *			m_pWorkQueue;				// pointer to owning work queue
		PFNDPTNWORKCALLBACK		m_pfnWorkCallback;			// pointer to function that should be called to perform the work
		PVOID					m_pvCallbackContext;		// pointer to context for performing the work

		//
		// I/O specific information.
		//
		OVERLAPPED				m_Overlapped;				// overlapped structure use to identify I/O operation to the OS

		//
		// Timer specific information.
		//
		DWORD					m_dwDueTime;				// expiration time for the work item
		BOOL					m_fCancelledOrCompleting;	// boolean set to TRUE if timer should be cancelled or it's queued to be processed
		UINT					m_uiUniqueID;				// continually incrementing identifier so the user can cancel the intended timer

#ifdef DPNBUILD_THREADPOOLSTATISTICS
		DWORD					m_dwCreationTime;			// time when work item was retrieved from the pool
		DWORD					m_dwQueueTime;				// time when work item was queued to be completed
		DWORD					m_dwCallbackTime;			// time when work item callback function began executing
		CALLBACKSTATS *			m_pCallbackStats;			// pointer to callback stats slot, or NULL if none
#endif // DPNBUILD_THREADPOOLSTATISTICS
};





//=============================================================================
// Inline thread pool statistics helper function implementations
//=============================================================================
inline void ThreadpoolStatsCreate(CWorkItem * const pWorkItem)
{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
	CALLBACKSTATS *			pCallbackStats;
	PFNDPTNWORKCALLBACK		pfnWorkCallback;


	//
	// Loop through all callback stats slots looking for the first one that
	// matches our callback or is NULL.  If we don't find one, m_pCallbackStats
	// will remain NULL.
	//
	pWorkItem->m_pCallbackStats = NULL;
	pCallbackStats = pWorkItem->m_pWorkQueue->aCallbackStats;
	while (pCallbackStats < &pWorkItem->m_pWorkQueue->aCallbackStats[MAX_TRACKED_CALLBACKSTATS])
	{
		//
		// Retrieve this slot's current callback pointer.  If it was NULL,
		// we'll fill it with our callback pointer in the process.
		//
		pfnWorkCallback = (PFNDPTNWORKCALLBACK) DNInterlockedCompareExchangePointer((PVOID*) (&pCallbackStats->pfnWorkCallback),
																					pWorkItem->m_pfnWorkCallback,
																					NULL);

		//
		// If the callback was already ours, or it was NULL (and thus got set
		// to ours), we've got a slot.
		//
		if ((pfnWorkCallback == pWorkItem->m_pfnWorkCallback) ||
			(pfnWorkCallback == NULL))
		{
			pWorkItem->m_pCallbackStats = pCallbackStats;
			DNInterlockedIncrement((LPLONG) (&pCallbackStats->dwNumCreates));
			break;
		}

		//
		// Move to next slot.
		//
		pCallbackStats++;
	}

	//
	// Remember the creation time.
	//
	pWorkItem->m_dwCreationTime = GETTIMESTAMP();
#endif // DPNBUILD_THREADPOOLSTATISTICS
}

inline void ThreadpoolStatsQueue(CWorkItem * const pWorkItem)
{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Remember the queue time.
	//
	pWorkItem->m_dwQueueTime = GETTIMESTAMP();

	//
	// If we have a callback stats slot, update the additional info.
	//
	if (pWorkItem->m_pCallbackStats != NULL)
	{
		DNInterlockedIncrement((LPLONG) (&pWorkItem->m_pCallbackStats->dwNumQueues));
#ifndef WINCE
		DNInterlockedExchangeAdd((LPLONG) (&pWorkItem->m_pCallbackStats->dwTotalCompletionTime),
								(pWorkItem->m_dwQueueTime - pWorkItem->m_dwCreationTime));
#endif // ! WINCE
	}
#endif // DPNBUILD_THREADPOOLSTATISTICS
}

inline void ThreadpoolStatsBeginExecuting(CWorkItem * const pWorkItem)
{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
	//
	// Remember when the callback began executing.
	//
	pWorkItem->m_dwCallbackTime = GETTIMESTAMP();

	//
	// If we have a callback stats slot, update the additional info.
	//
	if (pWorkItem->m_pCallbackStats != NULL)
	{
		DNInterlockedIncrement((LPLONG) (&pWorkItem->m_pCallbackStats->dwNumCalls));
#ifndef WINCE
		DNInterlockedExchangeAdd((LPLONG) (&pWorkItem->m_pCallbackStats->dwTotalQueueTime),
								(pWorkItem->m_dwCallbackTime - pWorkItem->m_dwQueueTime));
#endif // ! WINCE
	}
#endif // DPNBUILD_THREADPOOLSTATISTICS
}

inline void ThreadpoolStatsEndExecuting(CWorkItem * const pWorkItem)
{
#ifdef DPNBUILD_THREADPOOLSTATISTICS
#ifndef WINCE
	DWORD	dwCallbackTime;


	dwCallbackTime = GETTIMESTAMP() - pWorkItem->m_dwCallbackTime;

	//
	// Track global stats on how long callbacks take.
	//
	DNInterlockedExchangeAdd((LPLONG) (&pWorkItem->m_pWorkQueue->dwTotalTimeSpentInWorkCallbacks),
							dwCallbackTime);
#endif // WINCE

	//
	// If we have a callback stats slot, update the additional info.
	//
	if (pWorkItem->m_pCallbackStats != NULL)
	{
		DNInterlockedIncrement((LPLONG) (&pWorkItem->m_pCallbackStats->dwNumNotRescheduled));
#ifndef WINCE
		DNInterlockedExchangeAdd((LPLONG) (&pWorkItem->m_pCallbackStats->dwTotalCallbackTime),
								dwCallbackTime);
#endif // ! WINCE
	}
#endif // DPNBUILD_THREADPOOLSTATISTICS
}

inline void ThreadpoolStatsEndExecutingRescheduled(CWorkItem * const pWorkItem)
{
	//
	// Right now, we can't update any stats because we lost the work item pointer.
	//
}






//=============================================================================
// Function prototypes
//=============================================================================
#ifdef DPNBUILD_ONLYONETHREAD
#ifdef DPNBUILD_ONLYONEPROCESSOR
HRESULT InitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue);
#else // ! DPNBUILD_ONLYONEPROCESSOR
HRESULT InitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue,
							const DWORD dwCPUNum);
#endif // ! DPNBUILD_ONLYONEPROCESSOR
#else // ! DPNBUILD_ONLYONETHREAD
HRESULT InitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue,
#ifndef DPNBUILD_ONLYONEPROCESSOR
							const DWORD dwCPUNum,
#endif // ! DPNBUILD_ONLYONEPROCESSOR
							const PFNDPNMESSAGEHANDLER pfnMsgHandler,
							PVOID const pvMsgHandlerContext,
							const DWORD dwWorkerThreadTlsIndex);
#endif // ! DPNBUILD_ONLYONETHREAD

void DeinitializeWorkQueue(DPTPWORKQUEUE * const pWorkQueue);

BOOL QueueWorkItem(DPTPWORKQUEUE * const pWorkQueue,
					const PFNDPTNWORKCALLBACK pfnWorkCallback,
					PVOID const pvCallbackContext);

#ifndef DPNBUILD_ONLYONETHREAD
HRESULT StartThreads(DPTPWORKQUEUE * const pWorkQueue,
					const DWORD dwNumThreads);

HRESULT StopThreads(DPTPWORKQUEUE * const pWorkQueue,
					const DWORD dwNumThreads);
#endif // ! DPNBUILD_ONLYONETHREAD

void DoWork(DPTPWORKQUEUE * const pWorkQueue,
			const DWORD dwMaxDoWorkTime);


#ifndef DPNBUILD_ONLYONETHREAD
DWORD WINAPI DPTPWorkerThreadProc(PVOID pvParameter);

#ifdef DPNBUILD_MANDATORYTHREADS
DWORD WINAPI DPTPMandatoryThreadProc(PVOID pvParameter);
#endif // DPNBUILD_MANDATORYTHREADS

void DPTPWorkerLoop(DPTPWORKQUEUE * const pWorkQueue);
#endif // ! DPNBUILD_ONLYONETHREAD





#endif // __WORK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8log\dp8log.cpp ===
// DP8Log.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <stdio.h>
#include "memlog.h"

int _cdecl main(int argc, char* argv[])
{
	HANDLE hFile = 0;
	HANDLE hMutex = 0;
	UINT timebase = 0;
	UINT i = 0;
	UINT nTotalEntries = 1;
	UINT time = 0;
	DWORD lcid;

#ifdef TEST_MAX_SIZE
	UINT nMaxSize = 0;
	UINT nCurrentSize = 0;
#endif

	PSHARED_LOG_FILE	pLogFile	= NULL;
	PMEMLOG_ENTRY 		pLog		= NULL;
    	PMEMLOG_ENTRY       	pReadEntry	= NULL;

	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx (&osvi);
	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		hFile = CreateFileMappingA (INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(SHARED_LOG_FILE), "Global\\" BASE_LOG_MEMFILENAME);
	}
	else
	{
		hFile = CreateFileMappingA (INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(SHARED_LOG_FILE), BASE_LOG_MEMFILENAME);
	}
	if (!hFile)
	{
		goto exit;
	}
	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		hMutex = CreateMutexA (NULL, FALSE, "Global\\" BASE_LOG_MUTEXNAME); 
	}
	else
	{
		hMutex = CreateMutexA (NULL, FALSE, BASE_LOG_MUTEXNAME); 
	}
	if (!hMutex)
	{
		goto exit;
	}
	pLogFile = (PSHARED_LOG_FILE) MapViewOfFile(hFile, FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, 0);
	if(!pLogFile)
	{
		goto exit;
	}

	pLog = (PMEMLOG_ENTRY)(pLogFile + 1);

	// The user has asked us to clear the buffer, do that and return
	lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
	if (argc != 1 && CSTR_EQUAL == CompareString(lcid, NORM_IGNORECASE, argv[1], -1, TEXT("clearbuffer"), -1))
	{
		WaitForSingleObject(hMutex,INFINITE);

		ZeroMemory(pLog, pLogFile->nEntries * (sizeof(MEMLOG_ENTRY) + pLogFile->cbLine));
		pLogFile->iWrite = 0;

		ReleaseMutex(hMutex);
		goto exit;
	}

	if (argc == 1 || CSTR_EQUAL != CompareString(lcid, NORM_IGNORECASE, argv[1], -1, TEXT("nomutex"), -1))
	{
		WaitForSingleObject(hMutex,INFINITE);
	}

	// dump last half of buffer
	for(i = pLogFile->iWrite; i < pLogFile->nEntries; i++)
	{
		pReadEntry = (PMEMLOG_ENTRY)((PBYTE)&pLog[i] + pLogFile->cbLine * i);
		if (pReadEntry->str[0] != 0)
		{
			if (nTotalEntries == 1)
				timebase = pReadEntry->tLogged;

			if (pReadEntry->tLogged > timebase)
				time = pReadEntry->tLogged - timebase;
			else
				time = 0;

#ifdef TEST_MAX_SIZE
			nCurrentSize = strlen(pReadEntry->str);
			if (nCurrentSize > nMaxSize)
				nMaxSize = nCurrentSize;
#endif

			if (pReadEntry->str[1] == 0)
			{
				// str is Unicode
				wprintf(L"%5d: %8d %6d %s", nTotalEntries, pReadEntry->tLogged, time, (WCHAR*)pReadEntry->str);
			}
			else
			{
				// str is Ansi
				printf("%5d: %8d %6d %s", nTotalEntries, pReadEntry->tLogged, time, pReadEntry->str);
			}

			nTotalEntries++;
			timebase = pReadEntry->tLogged;
		}
		else
		{
			break;
		}
	}

	// dump first part of buffer
	for(i = 0; i<pLogFile->iWrite; i++)
	{
		pReadEntry = (PMEMLOG_ENTRY)((PBYTE)&pLog[i] + pLogFile->cbLine * i);

		if (nTotalEntries == 1)
			timebase = pReadEntry->tLogged;

		time = pReadEntry->tLogged - timebase;

#ifdef TEST_MAX_SIZE
		nCurrentSize = strlen(pReadEntry->str);
		if (nCurrentSize > nMaxSize)
			nMaxSize = nCurrentSize;
#endif

		if (pReadEntry->str[1] == 0)
		{
			// str is Unicode
			wprintf(L"%5d: %8d %6i %s", nTotalEntries, pReadEntry->tLogged, time, (WCHAR*)pReadEntry->str);
		}
		else
		{
			// str is Ansi
			printf("%5d: %8d %6i %s", nTotalEntries, pReadEntry->tLogged, time, pReadEntry->str);
		}

		nTotalEntries++;
		timebase = pReadEntry->tLogged;
	}

#ifdef TEST_MAX_SIZE
	printf("Max Text Size was: %d\n", nMaxSize);
#endif

	if (argc == 1 || CSTR_EQUAL != CompareString(lcid, NORM_IGNORECASE, argv[1], -1, TEXT("nomutex"), -1))
	{
		ReleaseMutex(hMutex);
	}

exit:
	if (pLogFile)
	{
		UnmapViewOfFile(pLogFile);
	}
	if(hFile)
	{
		CloseHandle(hFile);
	}
	if(hMutex)
	{
		CloseHandle(hMutex);
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\threadpool\threadpoolparamval.cpp ===
/******************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		threadpoolparamval.cpp
 *
 *  Content:	DirectPlay Thread Pool parameter validation functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  10/31/01  VanceO    Created.
 *
 ******************************************************************************/



#include "dpnthreadpooli.h"



#ifndef	DPNBUILD_NOPARAMVAL



#if ((! defined(DPNBUILD_ONLYONETHREAD)) || (! defined(DPNBUILD_LIBINTERFACE)))

#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlay8ThreadPoolObject"
//=============================================================================
// IsValidDirectPlay8ThreadPoolObject
//-----------------------------------------------------------------------------
//
// Description:    Ensures the given pointer is a valid IDirectPlay8ThreadPool
//				interface and object.
//
// Arguments:
//	PVOID pvObject	- Pointer to interface to validate.
//
// Returns: BOOL
//	TRUE	- The object is valid.
//	FALSE	- The object is not valid.
//=============================================================================
BOOL IsValidDirectPlay8ThreadPoolObject(PVOID pvObject)
{
	INTERFACE_LIST *		pIntList = (INTERFACE_LIST*) pvObject;
	DPTHREADPOOLOBJECT *	pDPTPObject;

	
	if (!DNVALID_READPTR(pvObject, sizeof(INTERFACE_LIST)))
	{
		DPFX(DPFPREP,  0, "Invalid object pointer!");
		return FALSE;
	}

	if (pIntList->lpVtbl != &DPTP_Vtbl)
	{
		DPFX(DPFPREP, 0, "Invalid object - bad vtable!");
		return FALSE;
	}

	if (pIntList->iid != IID_IDirectPlay8ThreadPool)
	{
		DPFX(DPFPREP, 0, "Invalid object - bad iid!");
		return FALSE;
	}

	if ((pIntList->pObject == NULL) ||
	   (! DNVALID_READPTR(pIntList->pObject, sizeof(OBJECT_DATA))))
	{
		DPFX(DPFPREP, 0, "Invalid object data!");
		return FALSE;
	}

	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pvObject);

	if ((pDPTPObject == NULL) ||
	   (! DNVALID_READPTR(pDPTPObject, sizeof(DPTHREADPOOLOBJECT))))
	{
		DPFX(DPFPREP, 0, "Invalid object!");
		return FALSE;
	}

	return TRUE;
} // IsValidDirectPlay8ThreadPoolObject





#undef DPF_MODNAME
#define DPF_MODNAME "DPTPValidateInitialize"
//=============================================================================
// DPTPValidateInitialize
//-----------------------------------------------------------------------------
//
// Description:	Validation for IDirectPlay8ThreadPool::Initialize.
//
// Arguments: See DPTP_Initialize.
//
// Returns: HRESULT
//=============================================================================
HRESULT DPTPValidateInitialize(IDirectPlay8ThreadPool * pInterface,
							PVOID const pvUserContext,
							const PFNDPNMESSAGEHANDLER pfn,
							const DWORD dwFlags)
{
	HRESULT		hr;


	if (! IsValidDirectPlay8ThreadPoolObject(pInterface))
	{
		DPFX(DPFPREP, 0, "Invalid object specified!");
		hr = DPNERR_INVALIDOBJECT;
		goto Exit;
	}

	if (pfn == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid message handler function!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}

	if (dwFlags & ~(DPNINITIALIZE_DISABLEPARAMVAL))
	{
		DPFX(DPFPREP, 0, "Invalid flags!");
		hr = DPNERR_INVALIDFLAGS;
		goto Exit;
	}

	hr = DPN_OK;

Exit:

	return hr;
} // DPTPValidateInitialize



#undef DPF_MODNAME
#define DPF_MODNAME "DPTPValidateClose"
//=============================================================================
// DPTPValidateClose
//-----------------------------------------------------------------------------
//
// Description:	Validation for IDirectPlay8ThreadPool::Close.
//
// Arguments: See DPTP_Close.
//
// Returns: HRESULT
//=============================================================================
HRESULT DPTPValidateClose(IDirectPlay8ThreadPool * pInterface,
						const DWORD dwFlags)
{
	HRESULT		hr;


	if (! IsValidDirectPlay8ThreadPoolObject(pInterface))
	{
		DPFX(DPFPREP, 0, "Invalid object specified!");
		hr = DPNERR_INVALIDOBJECT;
		goto Exit;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags!");
		hr = DPNERR_INVALIDFLAGS;
		goto Exit;
	}

	hr = DPN_OK;

Exit:

	return hr;
} // DPTPValidateClose




#undef DPF_MODNAME
#define DPF_MODNAME "DPTPValidateGetThreadCount"
//=============================================================================
// DPTPValidateGetThreadCount
//-----------------------------------------------------------------------------
//
// Description:	Validation for IDirectPlay8ThreadPool::GetThreadCount.
//
// Arguments: See DPTP_GetThreadCount.
//
// Returns: HRESULT
//=============================================================================
HRESULT DPTPValidateGetThreadCount(IDirectPlay8ThreadPool * pInterface,
									const DWORD dwProcessorNum,
									DWORD * const pdwNumThreads,
									const DWORD dwFlags)
{
	HRESULT			hr;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	SYSTEM_INFO		SystemInfo;
#endif // ! DPNBUILD_ONLYONEPROCESSOR


	if (! IsValidDirectPlay8ThreadPoolObject(pInterface))
	{
		DPFX(DPFPREP, 0, "Invalid object specified!");
		hr = DPNERR_INVALIDOBJECT;
		goto Exit;
	}

#ifdef DPNBUILD_ONLYONEPROCESSOR
	if ((dwProcessorNum != 0) && (dwProcessorNum != -1))
	{
		DPFX(DPFPREP, 0, "Invalid processor number!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}
#else // ! DPNBUILD_ONLYONEPROCESSOR
	GetSystemInfo(&SystemInfo);
	if ((dwProcessorNum > SystemInfo.dwNumberOfProcessors) && (dwProcessorNum != -1))
	{
		DPFX(DPFPREP, 0, "Invalid processor number!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

	if ((pdwNumThreads == NULL) ||
		(! DNVALID_WRITEPTR(pdwNumThreads, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer specified for storing number of threads!");
		hr = DPNERR_INVALIDPOINTER;
		goto Exit;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags!");
		hr = DPNERR_INVALIDFLAGS;
		goto Exit;
	}

	hr = DPN_OK;

Exit:

	return hr;
} // DPTPValidateGetThreadCount



#undef DPF_MODNAME
#define DPF_MODNAME "DPTPValidateSetThreadCount"
//=============================================================================
// DPTPValidateSetThreadCount
//-----------------------------------------------------------------------------
//
// Description:	Validation for IDirectPlay8ThreadPool::SetThreadCount.
//
// Arguments: See DPTP_SetThreadCount.
//
// Returns: HRESULT
//=============================================================================
HRESULT DPTPValidateSetThreadCount(IDirectPlay8ThreadPool * pInterface,
									const DWORD dwProcessorNum,
									const DWORD dwNumThreads,
									const DWORD dwFlags)
{
	HRESULT			hr;
#ifndef DPNBUILD_ONLYONEPROCESSOR
	SYSTEM_INFO		SystemInfo;
#endif // ! DPNBUILD_ONLYONEPROCESSOR


	if (! IsValidDirectPlay8ThreadPoolObject(pInterface))
	{
		DPFX(DPFPREP, 0, "Invalid object specified!");
		hr = DPNERR_INVALIDOBJECT;
		goto Exit;
	}

#ifdef DPNBUILD_ONLYONEPROCESSOR
	if ((dwProcessorNum != 0) && (dwProcessorNum != -1))
	{
		DPFX(DPFPREP, 0, "Invalid processor number!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}
#else // ! DPNBUILD_ONLYONEPROCESSOR
	GetSystemInfo(&SystemInfo);
	if ((dwProcessorNum > SystemInfo.dwNumberOfProcessors) && (dwProcessorNum != -1))
	{
		DPFX(DPFPREP, 0, "Invalid processor number!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}
#endif // ! DPNBUILD_ONLYONEPROCESSOR

	//
	// It doesn't make sense given current (or foreseeable) hardware, OSes, and
	// DPlay behavior for anyone to start more than a handful of threads per
	// processor, so we should prevent the user from hurting him/herself.
	// We'll be generous and allow the user to request up to 5,000, but I
	// imagine the system will be brought to its knees long before that.
	//
	// The only true requirement is that it not be the special -1 value, and
	// that the total number of threads for all processors doesn't equal -1 or
	// overflow the DWORD counter.
	//
	// The value of 0 is acceptable, it means the user wants to run in DoWork
	// mode (or reset some parameters that require that no threads be running).
	//
	if ((dwNumThreads == -1) || (dwNumThreads > 5000))
	{
		DPFX(DPFPREP, 0, "Invalid number of threads!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags!");
		hr = DPNERR_INVALIDFLAGS;
		goto Exit;
	}

	hr = DPN_OK;

Exit:

	return hr;
} // DPTPValidateSetThreadCount

#endif // ! DPNBUILD_ONLYONETHREAD or ! DPNBUILD_LIBINTERFACE



#undef DPF_MODNAME
#define DPF_MODNAME "DPTPValidateDoWork"
//=============================================================================
// DPTPValidateDoWork
//-----------------------------------------------------------------------------
//
// Description:	Validation for IDirectPlay8ThreadPool::DoWork.
//
// Arguments: See DPTP_DoWork.
//
// Returns: HRESULT
//=============================================================================
#ifdef DPNBUILD_LIBINTERFACE
HRESULT DPTPValidateDoWork(const DWORD dwAllowedTimeSlice,
							const DWORD dwFlags)
#else // ! DPNBUILD_LIBINTERFACE
HRESULT DPTPValidateDoWork(IDirectPlay8ThreadPool * pInterface,
							const DWORD dwAllowedTimeSlice,
							const DWORD dwFlags)
#endif // ! DPNBUILD_LIBINTERFACE
{
	HRESULT		hr;


#ifndef DPNBUILD_LIBINTERFACE
	if (! IsValidDirectPlay8ThreadPoolObject(pInterface))
	{
		DPFX(DPFPREP, 0, "Invalid object specified!");
		hr = DPNERR_INVALIDOBJECT;
		goto Exit;
	}
#endif // ! DPNBUILD_LIBINTERFACE

	if ((dwAllowedTimeSlice != INFINITE) && (dwAllowedTimeSlice > 60000))
	{
		DPFX(DPFPREP, 0, "Allowed time slice is too large!");
		hr = DPNERR_INVALIDPARAM;
		goto Exit;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags!");
		hr = DPNERR_INVALIDFLAGS;
		goto Exit;
	}

	hr = DPN_OK;

Exit:

	return hr;
} // DPTPValidateDoWork




/*
#undef DPF_MODNAME
#define DPF_MODNAME "IsValidDirectPlay8ThreadPoolWorkObject"
//=============================================================================
// IsValidDirectPlay8ThreadPoolWorkObject
//-----------------------------------------------------------------------------
//
// Description:    Ensures the given pointer is a valid
//				IDirectPlay8ThreadPoolWork interface and object.
//
// Arguments:
//	PVOID pvObject	- Pointer to interface to validate.
//
// Returns: BOOL
//	TRUE	- The object is valid.
//	FALSE	- The object is not valid.
//=============================================================================
BOOL IsValidDirectPlay8ThreadPoolWorkObject(PVOID pvObject)
#ifdef DPNBUILD_LIBINTERFACE
{
	DPTHREADPOOLOBJECT *	pDPTPObject;


	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pvObject);

	if ((pDPTPObject == NULL) ||
	   (! DNVALID_READPTR(pDPTPObject, sizeof(DPTHREADPOOLOBJECT))))
	{
		DPFX(DPFPREP, 0, "Invalid object!");
		return FALSE;
	}

	if (pDPTPObject->lpVtbl != &DPTPW_Vtbl)
	{
		DPFX(DPFPREP, 0, "Invalid object - bad vtable!");
		return FALSE;
	}

	return TRUE;
}
#else // ! DPNBUILD_LIBINTERFACE
{
	INTERFACE_LIST *		pIntList = (INTERFACE_LIST*) pvObject;
	DPTHREADPOOLOBJECT *	pDPTPObject;

	
	if (!DNVALID_READPTR(pvObject, sizeof(INTERFACE_LIST)))
	{
		DPFX(DPFPREP,  0, "Invalid object pointer!");
		return FALSE;
	}

	if (pIntList->lpVtbl != &DPTPW_Vtbl)
	{
		DPFX(DPFPREP, 0, "Invalid object - bad vtable!");
		return FALSE;
	}

	if (pIntList->iid != IID_IDirectPlay8ThreadPoolWork)
	{
		DPFX(DPFPREP, 0, "Invalid object - bad iid!");
		return FALSE;
	}

	if ((pIntList->pObject == NULL) ||
	   (! DNVALID_READPTR(pIntList->pObject, sizeof(OBJECT_DATA))))
	{
		DPFX(DPFPREP, 0, "Invalid object data!");
		return FALSE;
	}

	pDPTPObject = (DPTHREADPOOLOBJECT*) GET_OBJECT_FROM_INTERFACE(pvObject);

	if ((pDPTPObject == NULL) ||
	   (! DNVALID_READPTR(pDPTPObject, sizeof(DPTHREADPOOLOBJECT))))
	{
		DPFX(DPFPREP, 0, "Invalid object!");
		return FALSE;
	}

	return TRUE;
} // IsValidDirectPlay8ThreadPoolWorkObject
#endif // ! DPNBUILD_LIBINTERFACE
*/



#endif // ! DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\guids\guids.cpp ===
#include "dpnbuild.h"
#include <initguid.h>
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"
#include "dp8sim.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\guids\sources.inc ===
TARGETNAME=guids
TARGETTYPE=LIBRARY

INCLUDES=..\..\inc;..\..\..\..\inc;$(DXROOT)\inc

SOURCES=guids.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8log\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Lloyd Johnson (a-LloydJ) 16-Feb-98

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

UMTYPE=windows

!if "$(NTDEBUG)"!="" && "$(NTDEBUG)"!="ntsdnodbg"
C_DEFINES = $(C_DEFINES) -DDEBUG
!endif

#PLAT_DIR           = win9x
#ALT_PROJECT_TARGET = win9x

TARGETNAME=dp8log
TARGETTYPE=PROGRAM
TARGETPATH=obj

UMTYPE=console
UMENTRY=main

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
    	$(BASEDIR)\public\sdk\lib\*\user32.lib \
	$(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	$(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	$(BASEDIR)\public\sdk\lib\*\user32.lib \
	$(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	$(BASEDIR)\public\sdk\lib\*\version.lib \
	$(BASEDIR)\public\sdk\lib\*\shell32.lib \
	$(BASEDIR)\public\sdk\lib\*\comctl32.lib \
	$(BASEDIR)\public\sdk\lib\*\ole32.lib \
	$(BASEDIR)\public\sdk\lib\*\shlwapi.lib \
	$(BASEDIR)\public\sdk\lib\*\msvcrt.lib

INCLUDES=..\..\..\common;$(DXROOT)\inc;$(DXROOT)\setup\public\sdk\inc

SOURCES=..\dp8log.cpp \
	..\dp8log.rc

MISCFILES=..\dp8log.txt

# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_CONSOLE /DWIN32 /D_MT /D_DLL

USE_NOLIBS=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\inc\dp8sim.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8sim.h
 *
 *  Content:	Header for using DP8Sim.
//@@BEGIN_MSINTERNAL
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
//@@END_MSINTERNAL
 *
 ***************************************************************************/



#ifndef __DP8SIM_H__
#define __DP8SIM_H__



#include <ole2.h>	// for DECLARE_INTERFACE and HRESULT




#ifdef __cplusplus
extern "C" {
#endif





/****************************************************************************
 *
 * DP8Sim simulated service providers
 *
 ****************************************************************************/

// {8D3F9E5E-A3BD-475b-9E49-B0E77139143C}
DEFINE_GUID(CLSID_NETWORKSIMULATOR_DP8SP_TCPIP, 
0x8d3f9e5e, 0xa3bd, 0x475b, 0x9e, 0x49, 0xb0, 0xe7, 0x71, 0x39, 0x14, 0x3c);





/****************************************************************************
 *
 * DP8Sim control object class ID
 *
 ****************************************************************************/

// {40530071-1A80-4420-9B74-6A73171B0876}
DEFINE_GUID(CLSID_DP8SimControl, 
0x40530071, 0x1a80, 0x4420, 0x9b, 0x74, 0x6a, 0x73, 0x17, 0x1b, 0x8, 0x76);





/****************************************************************************
 *
 * DP8Sim Control interface ID
 *
 ****************************************************************************/

// {9CC03740-A510-4bcc-A014-776304B6E0D9}
DEFINE_GUID(IID_IDP8SimControl, 
0x9cc03740, 0xa510, 0x4bcc, 0xa0, 0x14, 0x77, 0x63, 0x4, 0xb6, 0xe0, 0xd9);




/****************************************************************************
 *
 * DP8Sim Control suggested packet header sizes
 *
 ****************************************************************************/

#define DP8SIMPACKETHEADERSIZE_IP		20
#define DP8SIMPACKETHEADERSIZE_UDP		8
#define DP8SIMPACKETHEADERSIZE_IP_UDP	(DP8SIMPACKETHEADERSIZE_IP + DP8SIMPACKETHEADERSIZE_UDP)





/****************************************************************************
 *
 * DP8Sim Control structures
 *
 ****************************************************************************/

typedef struct _DP8SIM_PARAMETERS
{
	DWORD	dwSize;					// size of this structure, must be filled in prior to calling GetAllParameters or SetAllParameters
	DWORD	dwFlags;				// flags for this structure
	DWORD	dwPacketHeaderSize;		// fixed underlying transport packet header size to add into calculations, or 0 to calculate based only on DirectPlay headers and payload
	DWORD	dwBandwidthBPS;			// bandwidth in bytes per second, or 0 for no limit
	FLOAT	fPacketLossPercent;		// percentage of packets to drop, between 0.0 and 100.0
	DWORD	dwMinLatencyMS;			// minimum artificial latency, in milliseconds (on top of any caused by bandwidth settings)
	DWORD	dwMaxLatencyMS;			// maximum artificial latency, in milliseconds (on top of any caused by bandwidth settings)
} DP8SIM_PARAMETERS, * PDP8SIM_PARAMETERS;

typedef struct _DP8SIM_STATISTICS
{
	DWORD	dwSize;					// size of this structure, must be filled in prior to calling GetAllStatistics
	DWORD	dwFlags;				// flags for this structure
	DWORD	dwTransmittedPackets;	// number of packets sent/received
	DWORD	dwTransmittedBytes;		// number of bytes sent/received
	DWORD	dwDroppedPackets;		// number of packets intentionally dropped
	DWORD	dwDroppedBytes;			// number of bytes intentionally dropped
	DWORD	dwTotalDelayMS;			// total number of milliseconds delay added because of bandwidth limitations or random latency settings
} DP8SIM_STATISTICS, * PDP8SIM_STATISTICS;





/****************************************************************************
 *
 * DP8Sim Control application interfaces
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDP8SimControl
DECLARE_INTERFACE_(IDP8SimControl, IUnknown)
{
	/*** IUnknown methods ***/
	STDMETHOD(QueryInterface)				(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
	STDMETHOD_(ULONG,AddRef)				(THIS) PURE;
	STDMETHOD_(ULONG,Release)				(THIS) PURE;

	/*** IDP8SimControl methods ***/
	STDMETHOD(Initialize)					(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(Close)						(THIS_ const DWORD dwFlags) PURE;
	STDMETHOD(GetAllParameters)				(THIS_ DP8SIM_PARAMETERS * const pdp8spSend, DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags) PURE;
	STDMETHOD(SetAllParameters)				(THIS_ const DP8SIM_PARAMETERS * const pdp8spSend, const DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags) PURE;
	STDMETHOD(GetAllStatistics)				(THIS_ DP8SIM_STATISTICS * const pdp8ssSend, DP8SIM_STATISTICS * const pdp8ssReceive, const DWORD dwFlags) PURE;
	STDMETHOD(ClearAllStatistics)			(THIS_ const DWORD dwFlags) PURE;
};




/****************************************************************************
 *
 * DP8Sim Control application interface macros
 *
 ****************************************************************************/

#if (! defined(__cplusplus) || defined(CINTERFACE))

#define IDP8SimControl_QueryInterface(p,a,b)			(p)->lpVtbl->QueryInterface(p,a,b)
#define IDP8SimControl_AddRef(p)						(p)->lpVtbl->AddRef(p)
#define IDP8SimControl_Release(p)						(p)->lpVtbl->Release(p)
#define IDP8SimControl_Initialize(p,a)					(p)->lpVtbl->Initialize(p,a)
#define IDP8SimControl_Close(p,a)						(p)->lpVtbl->Close(p,a)
#define IDP8SimControl_GetAllParameters(p,a,b,c)		(p)->lpVtbl->GetAllParameters(p,a,b,c)
#define IDP8SimControl_SetAllParameters(p,a,b,c)		(p)->lpVtbl->SetAllParameters(p,a,b,c)
#define IDP8SimControl_GetAllStatistics(p,a,b,c)		(p)->lpVtbl->GetAllStatistics(p,a,b,c)
#define IDP8SimControl_ClearAllStatistics(p,a)			(p)->lpVtbl->ClearAllStatistics(p,a)

#else // C++

#define IDP8SimControl_QueryInterface(p,a,b)			(p)->QueryInterface(a,b)
#define IDP8SimControl_AddRef(p)						(p)->AddRef()
#define IDP8SimControl_Release(p)						(p)->Release()
#define IDP8SimControl_Initialize(p,a)					(p)->Initialize(a)
#define IDP8SimControl_Close(p,a)						(p)->Close(a)
#define IDP8SimControl_GetAllParameters(p,a,b,c)		(p)->GetAllParameters(p,a,b,c)
#define IDP8SimControl_SetAllParameters(p,a,b,c)		(p)->SetAllParameters(p,a,b,c)
#define IDP8SimControl_GetAllStatistics(p,a,b,c)		(p)->GetAllStatistics(p,a,b,c)
#define IDP8SimControl_ClearAllStatistics(p,a)			(p)->ClearAllStatistics(p,a)

#endif



/****************************************************************************
 *
 * DP8Sim Control return codes
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/

#define _DP8SIMH_FACILITY_CODE				0x015
#define _DP8SIMH_HRESULT_BASE				0xE000

#define MAKE_DP8SIMSUCCESS(code)			MAKE_HRESULT(0, _DP8SIMH_FACILITY_CODE, (code + _DP8SIMH_HRESULT_BASE))
#define MAKE_DP8SIMFAILURE(code)			MAKE_HRESULT(1, _DP8SIMH_FACILITY_CODE, (code + _DP8SIMH_HRESULT_BASE))



#define DP8SIM_OK							S_OK

#define DP8SIMERR_ALREADYINITIALIZED		MAKE_DP8SIMFAILURE(0x10)
#define DP8SIMERR_GENERIC					E_FAIL
#define DP8SIMERR_INVALIDFLAGS				MAKE_DP8SIMFAILURE(0x20)
#define DP8SIMERR_INVALIDOBJECT				MAKE_DP8SIMFAILURE(0x30)
#define DP8SIMERR_INVALIDPARAM				E_INVALIDARG
#define DP8SIMERR_INVALIDPOINTER			E_POINTER
#define DP8SIMERR_MISMATCHEDVERSION			MAKE_DP8SIMFAILURE(0x40)
#define DP8SIMERR_NOTINITIALIZED			MAKE_DP8SIMFAILURE(0x50)
#define DP8SIMERR_OUTOFMEMORY				E_OUTOFMEMORY





#ifdef __cplusplus
}
#endif

#endif // __DP8SIM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\controlobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		controlobj.cpp
 *
 *  Content:	DP8SIM control interface wrapper object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/24/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::CDP8SimControl"
//=============================================================================
// CDP8SimControl constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimControl object.
//
// Arguments: None.
//
// Returns: None (the object).
//=============================================================================
CDP8SimControl::CDP8SimControl(void)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'D';
	this->m_Sig[1]	= 'P';
	this->m_Sig[2]	= '8';
	this->m_Sig[3]	= 'S';

	this->m_lRefCount	= 1; // someone must have a pointer to this object
	this->m_dwFlags		= 0;
} // CDP8SimControl::CDP8SimControl






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::~CDP8SimControl"
//=============================================================================
// CDP8SimControl destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimControl object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimControl::~CDP8SimControl(void)
{
	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT(this->m_dwFlags == 0);

	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 's';
} // CDP8SimControl::~CDP8SimControl




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::QueryInterface"
//=============================================================================
// CDP8SimControl::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CDP8SimControl object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CDP8SimControl::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPN_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8SimControl object!");
		hr = DPNERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8SimControl)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CDP8SimControl inherits
	// from the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimControl::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::AddRef"
//=============================================================================
// CDP8SimControl::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CDP8SimControl object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimControl::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CDP8SimControl::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::Release"
//=============================================================================
// CDP8SimControl::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CDP8SimControl object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimControl::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DP8SimControl object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close(0);
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CDP8SimControl::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::Initialize"
//=============================================================================
// CDP8SimControl::Initialize
//-----------------------------------------------------------------------------
//
// Description: Initializes this DP8Sim Control interface.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DP8SIM_OK						- The DP8Sim control object was
//										successfully initialized.
//	DP8SIMERR_ALREADYINITIALIZED	- The DP8Sim control object has already
//										been initialized.
//	DP8SIMERR_INVALIDFLAGS			- Invalid flags were specified.
//	DP8SIMERR_INVALIDOBJECT			- The DP8Sim control object is invalid.
//	DP8SIMERR_MISMATCHEDVERSION		- A different version of DP8Sim is already
//										in use on this system.
//=============================================================================
STDMETHODIMP CDP8SimControl::Initialize(const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;
	BOOL		fInitializedIPCObject = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%x)", this, dwFlags);


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim control object!");
		hr = DP8SIMERR_INVALIDOBJECT;
		goto Failure;
	}

	//
	// Validate the parameters.
	//
	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DP8SIMERR_INVALIDFLAGS;
		goto Failure;
	}
#endif // ! DPNBUILD_NOPARAMVAL


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Validate the object state.
	//
	if (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED)
	{
		DPFX(DPFPREP, 0, "Control object already initialized!");
		hr = DP8SIMERR_ALREADYINITIALIZED;
		goto Failure;
	}


	//
	// Connect the shared memory.
	//
	hr = this->m_DP8SimIPC.Initialize();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize IPC object!");
		goto Failure;
	}

	fInitializedIPCObject = TRUE;


	//
	// We're now initialized.
	//
	this->m_dwFlags |= DP8SIMCONTROLOBJ_INITIALIZED;



Exit:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fInitializedIPCObject)
	{
		this->m_DP8SimIPC.Close();
		fInitializedIPCObject = FALSE;
	}

	goto Exit;
} // CDP8SimControl::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::Close"
//=============================================================================
// CDP8SimControl::Close
//-----------------------------------------------------------------------------
//
// Description: Closes this DP8Sim Control interface.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DP8SIM_OK					- The DP8Sim control object was successfully
//									closed.
//	DP8SIMERR_INVALIDFLAGS		- Invalid flags were specified.
//	DP8SIMERR_INVALIDOBJECT		- The DP8Sim control object is invalid.
//	DP8SIMERR_NOTINITIALIZED	- The DP8Sim control object has not been
//									initialized.
//=============================================================================
STDMETHODIMP CDP8SimControl::Close(const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%x)", this, dwFlags);


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim control object!");
		hr = DP8SIMERR_INVALIDOBJECT;
		goto Failure;
	}

	//
	// Validate the parameters.
	//
	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DP8SIMERR_INVALIDFLAGS;
		goto Failure;
	}
#endif // ! DPNBUILD_NOPARAMVAL


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Validate the object state.
	//
	if (! (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Control object not initialized!");
		hr = DP8SIMERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Disconnect the shared memory.
	//
	this->m_DP8SimIPC.Close();



	//
	// Turn off the initialized flags.
	//
	this->m_dwFlags &= ~DP8SIMCONTROLOBJ_INITIALIZED;
	DNASSERT(this->m_dwFlags == 0);


	//
	// Drop the lock, nobody should be touching this object now.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimControl::Close






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::GetAllParameters"
//=============================================================================
// CDP8SimControl::GetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves all of the current DP8Sim settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store current send
//											parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store current receive
//											parameters.
//	DWORD dwFlags						- Unused, must be zero.
//
// Returns: HRESULT
//	DP8SIM_OK					- The parameters were successfully retrieved.
//	DP8SIMERR_INVALIDFLAGS		- Invalid flags were specified.
//	DP8SIMERR_INVALIDOBJECT		- The DP8Sim control object is invalid.
//	DP8SIMERR_INVALIDPARAM		- An invalid structure was specified.
//	DP8SIMERR_INVALIDPOINTER	- An invalid structure pointer was specified.
//	DP8SIMERR_NOTINITIALIZED	- The DP8Sim control object has not been
//									initialized.
//=============================================================================
STDMETHODIMP CDP8SimControl::GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend,
											DP8SIM_PARAMETERS * const pdp8spReceive,
											const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pdp8spSend, pdp8spReceive, dwFlags);


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim control object!");
		hr = DP8SIMERR_INVALIDOBJECT;
		goto Failure;
	}

	//
	// Validate the parameters.
	//

	if ((pdp8spSend == NULL) ||
		(IsBadWritePtr(pdp8spSend, sizeof(DP8SIM_PARAMETERS))))
	{
		DPFX(DPFPREP, 0, "Invalid send parameters pointer!");
		hr = DP8SIMERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdp8spSend->dwSize != sizeof(DP8SIM_PARAMETERS))
	{
		DPFX(DPFPREP, 0, "Send parameters structure size is invalid!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if ((pdp8spReceive == NULL) ||
		(IsBadWritePtr(pdp8spReceive, sizeof(DP8SIM_PARAMETERS))))
	{
		DPFX(DPFPREP, 0, "Invalid receive parameters pointer!");
		hr = DP8SIMERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdp8spReceive->dwSize != sizeof(DP8SIM_PARAMETERS))
	{
		DPFX(DPFPREP, 0, "Receive parameters structure size is invalid!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DP8SIMERR_INVALIDFLAGS;
		goto Failure;
	}
#endif // ! DPNBUILD_NOPARAMVAL


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Validate the object state.
	//
	if (! (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Control object not initialized!");
		hr = DP8SIMERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Retrieve the settings from the IPC object.
	//
	this->m_DP8SimIPC.GetAllParameters(pdp8spSend, pdp8spReceive);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimControl::GetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::SetAllParameters"
//=============================================================================
// CDP8SimControl::SetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Modifies the current DP8Sim settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Structure containing desired send
//											parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Structure containing desired
//											receive parameters.
//	DWORD dwFlags						- Unused, must be zero.
//
// Returns: HRESULT
//	DP8SIM_OK					- The parameters were successfully changed.
//	DP8SIMERR_INVALIDFLAGS		- Invalid flags were specified.
//	DP8SIMERR_INVALIDOBJECT		- The DP8Sim control object is invalid.
//	DP8SIMERR_INVALIDPARAM		- An invalid structure was specified.
//	DP8SIMERR_INVALIDPOINTER	- An invalid structure pointer was specified.
//	DP8SIMERR_NOTINITIALIZED	- The DP8Sim control object has not been
//									initialized.
//=============================================================================
STDMETHODIMP CDP8SimControl::SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
											const DP8SIM_PARAMETERS * const pdp8spReceive,
											const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pdp8spSend, pdp8spReceive, dwFlags);


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim control object!");
		hr = DP8SIMERR_INVALIDOBJECT;
		goto Failure;
	}

	//
	// Validate the parameters.
	//

	if ((pdp8spSend == NULL) ||
		(IsBadReadPtr(pdp8spSend, sizeof(DP8SIM_PARAMETERS))))
	{
		DPFX(DPFPREP, 0, "Invalid send parameters pointer!");
		hr = DP8SIMERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdp8spSend->dwSize != sizeof(DP8SIM_PARAMETERS))
	{
		DPFX(DPFPREP, 0, "Send parameters structure size is invalid!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (pdp8spSend->dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Send parameters structure flags must be 0!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if ((pdp8spSend->fPacketLossPercent < 0.0) ||
		(pdp8spSend->fPacketLossPercent > 100.0))
	{
		DPFX(DPFPREP, 0, "Send packet loss must be between 0.0 and 100.0!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (pdp8spSend->dwMinLatencyMS > pdp8spSend->dwMaxLatencyMS)
	{
		DPFX(DPFPREP, 0, "Minimum send latency must be less than or equal to the maximum send latency!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if ((pdp8spReceive == NULL) ||
		(IsBadReadPtr(pdp8spReceive, sizeof(DP8SIM_PARAMETERS))))
	{
		DPFX(DPFPREP, 0, "Invalid receive parameters pointer!");
		hr = DP8SIMERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdp8spReceive->dwSize != sizeof(DP8SIM_PARAMETERS))
	{
		DPFX(DPFPREP, 0, "Receive parameters structure size is invalid!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (pdp8spReceive->dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Receive parameters structure flags must be 0!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if ((pdp8spReceive->fPacketLossPercent < 0.0) ||
		(pdp8spReceive->fPacketLossPercent > 100.0))
	{
		DPFX(DPFPREP, 0, "Receive packet loss must be between 0.0 and 100.0!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (pdp8spReceive->dwMinLatencyMS > pdp8spReceive->dwMaxLatencyMS)
	{
		DPFX(DPFPREP, 0, "Minimum receive latency must be less than or equal to the receive send latency!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DP8SIMERR_INVALIDFLAGS;
		goto Failure;
	}
#endif // ! DPNBUILD_NOPARAMVAL


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Validate the object state.
	//
	if (! (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Control object not initialized!");
		hr = DP8SIMERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Store the settings with the IPC object.
	//
	this->m_DP8SimIPC.SetAllParameters(pdp8spSend, pdp8spReceive);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimControl::SetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::GetAllStatistics"
//=============================================================================
// CDP8SimControl::GetAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Retrieves all of the current DP8Sim statistics.
//
// Arguments:
//	DP8SIM_STATISTICS * pdp8ssSend		- Place to store current send
//											statistics.
//	DP8SIM_STATISTICS * pdp8ssReceive	- Place to store current receive
//											statistics.
//	DWORD dwFlags						- Unused, must be zero.
//
// Returns: HRESULT
//	DP8SIM_OK					- The statistics were successfully retrieved.
//	DP8SIMERR_INVALIDFLAGS		- Invalid flags were specified.
//	DP8SIMERR_INVALIDOBJECT		- The DP8Sim control object is invalid.
//	DP8SIMERR_INVALIDPARAM		- An invalid structure was specified.
//	DP8SIMERR_INVALIDPOINTER	- An invalid structure pointer was specified.
//	DP8SIMERR_NOTINITIALIZED	- The DP8Sim control object has not been
//									initialized.
//=============================================================================
STDMETHODIMP CDP8SimControl::GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend,
											DP8SIM_STATISTICS * const pdp8ssReceive,
											const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%x)",
		this, pdp8ssSend, pdp8ssReceive, dwFlags);


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim control object!");
		hr = DP8SIMERR_INVALIDOBJECT;
		goto Failure;
	}

	//
	// Validate the parameters.
	//

	if ((pdp8ssSend == NULL) ||
		(IsBadWritePtr(pdp8ssSend, sizeof(DP8SIM_STATISTICS))))
	{
		DPFX(DPFPREP, 0, "Invalid send statistics pointer!");
		hr = DP8SIMERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdp8ssSend->dwSize != sizeof(DP8SIM_STATISTICS))
	{
		DPFX(DPFPREP, 0, "Send statistics structure size is invalid!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if ((pdp8ssReceive == NULL) ||
		(IsBadWritePtr(pdp8ssReceive, sizeof(DP8SIM_STATISTICS))))
	{
		DPFX(DPFPREP, 0, "Invalid receive statistics pointer!");
		hr = DP8SIMERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdp8ssReceive->dwSize != sizeof(DP8SIM_STATISTICS))
	{
		DPFX(DPFPREP, 0, "Receive statistics structure size is invalid!");
		hr = DP8SIMERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DP8SIMERR_INVALIDFLAGS;
		goto Failure;
	}
#endif // ! DPNBUILD_NOPARAMVAL


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Validate the object state.
	//
	if (! (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Control object not initialized!");
		hr = DP8SIMERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Retrieve the stats from the IPC object.
	//
	this->m_DP8SimIPC.GetAllStatistics(pdp8ssSend, pdp8ssReceive);


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimControl::GetAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::ClearAllStatistics"
//=============================================================================
// CDP8SimControl::ClearAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Clears all of the current DP8Sim statistics.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DP8SIM_OK					- The statistics were successfully cleared.
//	DP8SIMERR_INVALIDFLAGS		- Invalid flags were specified.
//	DP8SIMERR_INVALIDOBJECT		- The DP8Sim control object is invalid.
//	DP8SIMERR_NOTINITIALIZED	- The DP8Sim control object has not been
//									initialized.
//=============================================================================
STDMETHODIMP CDP8SimControl::ClearAllStatistics(const DWORD dwFlags)
{
	HRESULT		hr = DP8SIM_OK;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%x)", this, dwFlags);


#ifndef DPNBUILD_NOPARAMVAL
	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim control object!");
		hr = DP8SIMERR_INVALIDOBJECT;
		goto Failure;
	}

	//
	// Validate the parameters.
	//
	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DP8SIMERR_INVALIDFLAGS;
		goto Failure;
	}
#endif // ! DPNBUILD_NOPARAMVAL


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Validate the object state.
	//
	if (! (this->m_dwFlags & DP8SIMCONTROLOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Control object not initialized!");
		hr = DP8SIMERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Have the IPC object clear the stats.
	//
	this->m_DP8SimIPC.ClearAllStatistics();


	//
	// Drop the lock.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimControl::ClearAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::InitializeObject"
//=============================================================================
// CDP8SimControl::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CDP8SimControl::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 
	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimControl::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimControl::UninitializeObject"
//=============================================================================
// CDP8SimControl::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimControl::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Returning", this);
} // CDP8SimControl::UninitializeObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\inc\makefile.inc ===
COPYRIGHT_STRING = Copyright (c) 1990-2002  Microsoft Corporation

OUTPUT_HDRS=	$(O)\dp8sim.h
 

dp8sim : $(OUTPUT_HDRS)

clean : cleansrc

cleansrc : 
	del $(OUTPUT_HDRS)

#
# dp8sim.h
#

$(O)\dp8sim.h: dp8sim.h
    hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ dp8sim.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\controlobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       controlobj.h
 *
 *  Content:	Header for DP8SIM control interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/24/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Macros
//=============================================================================
#define DP8SIMCONTROL_FROM_BILINK(b)	(CONTAINING_OBJECT(b, CDP8SimControl, m_blList))



//=============================================================================
// Object flags
//=============================================================================
#define DP8SIMCONTROLOBJ_INITIALIZED	0x01	// object has been initialized




//=============================================================================
// Control interface object class
//=============================================================================
class CDP8SimControl : public IDP8SimControl
{
	public:
		CDP8SimControl(void);	// constructor
		~CDP8SimControl(void);	// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP Initialize(const DWORD dwFlags);

		STDMETHODIMP Close(const DWORD dwFlags);

		STDMETHODIMP GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend, DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags);

		STDMETHODIMP SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend, const DP8SIM_PARAMETERS * const pdp8spReceive, const DWORD dwFlags);

		STDMETHODIMP GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend, DP8SIM_STATISTICS * const pdp8ssReceive, const DWORD dwFlags);

		STDMETHODIMP ClearAllStatistics(const DWORD dwFlags);



		HRESULT InitializeObject(void);

		void UninitializeObject(void);



		CBilink					m_blList;	// list of all the DP8SimControl instances in existence


	private:
		BYTE					m_Sig[4];					// debugging signature ('DP8S')
		LONG					m_lRefCount;				// reference count for this object
		DWORD					m_dwFlags;					// flags for this object
		DNCRITICAL_SECTION		m_csLock;					// lock preventing simultaneous usage of globals
		CDP8SimIPC				m_DP8SimIPC;				// object that handles interprocess communication


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimControl))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x53385044)	// 0x53 0x38 0x50 0x44 = 'S8PD' = 'DP8S' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simi.h
 *
 *  Content:	DP8SIM master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/

#ifndef __DP8SIMI_H__
#define __DP8SIMI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

//
// Don't use the C interface style for COM, use C++
//
#undef CINTERFACE

// 
// Public includes
//
#include <windows.h>
#include <ole2.h>
#include <mmsystem.h>	// NT BUILD requires this for timeGetTime
#include <stdio.h>		// for swprintf
#include <math.h>		// for log and sqrt
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
#include "dpaddr.h"
#include "dpsp8.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "createin.h"
#include "comutil.h"
#include "dneterrors.h"
#include "strutils.h"
#include "fixedpool.h"


// 
// DP8Sim includes
//
#include "dp8sim.h"


// 
// DP8SimSP private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_TOOLS

#include "dp8simlocals.h"
#include "dp8simpools.h"
#include "dp8simipc.h"
#include "spcallbackobj.h"
#include "spwrapper.h"
#include "dp8simendpoint.h"
#include "dp8simcmd.h"
#include "dp8simworkerthread.h"
#include "dp8simsend.h"
#include "dp8simreceive.h"
#include "controlobj.h"
#include "dp8simjob.h"
#include "resource.h"




#endif // __DP8SIMI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simdllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simdllmain.cpp
 *
 *  Content:	DP8SIM DLL entry points.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// External globals
//=============================================================================
volatile LONG		g_lOutstandingInterfaceCount = 0;	// number of outstanding interfaces

HINSTANCE			g_hDLLInstance = NULL;				// handle to this DLL instance

DNCRITICAL_SECTION	g_csGlobalsLock;					// lock protecting all of the following globals
CBilink				g_blDP8SimSPObjs;					// bilink of all the DP8SimSP interface objects
CBilink				g_blDP8SimControlObjs;				// bilink of all the DP8SimControl interface objects

UINT				g_uiRandShr3 = 0;					// global holding value for Shr3 random number sequence generator
UINT				g_uiRandCong = 0;					// global holding value for congruential random number sequence generator






//=============================================================================
// Supported SPs table
//=============================================================================
typedef struct _SUPPORTEDSP
{
	const CLSID *	pclsidFakeSP;				// pointer to class ID for fake SP
	const CLSID *	pclsidRealSP;				// pointer to class ID for real SP
	const WCHAR *	pwszVerIndProgID;			// version independent prog ID for fake SP COM object, must match the sub key for pwszServiceProviderKey
	const WCHAR *	pwszProgID;					// prog ID for fake SP COM object
	const WCHAR *	pwszDesc;					// description for fake SP COM object
	const WCHAR *	pwszServiceProviderKey;		// service provider key string, sub key must match pwszVerIndProgID
	UINT			uiFriendlyNameResourceID;	// ID of fake SP's name string resource
} SUPPORTEDSP;

const SUPPORTEDSP	c_aSupportedSPs[] =
{
	{
		(&CLSID_NETWORKSIMULATOR_DP8SP_TCPIP),
		(&CLSID_DP8SP_TCPIP),
		L"DP8SimTCPIP",
		L"DP8SimTCPIP.1",
		L"DirectPlay8 Network Simulator TCP/IP Service Provider",
		DPN_REG_LOCAL_SP_SUBKEY L"\\DP8SimTCPIP",
		IDS_FRIENDLYNAME_TCPIP,
	},
};

#define NUM_SUPPORTED_SPS	(sizeof(c_aSupportedSPs) / sizeof(c_aSupportedSPs[0]))










//=============================================================================
// Defines
//=============================================================================
#define MAX_RESOURCE_STRING_LENGTH		_MAX_PATH





//=============================================================================
// Macros
//=============================================================================

// 3-shift register generator
//
// Original comments:
//	SHR3 is a 3-shift-register generator with period 2^32-1. It uses
//	y(n)=y(n-1)(I+L^17)(I+R^13)(I+L^5), with the y's viewed as binary vectors,
//	L the 32x32 binary matrix that shifts a vector left 1, and R its transpose.
//	SHR3 seems to pass all except those related to the binary rank test, since
//	32 successive values, as binary vectors, must be linearly independent,
//	while 32 successive truly random 32-bit integers, viewed as binary vectors,
//	will be linearly independent only about 29% of the time.
#define RANDALG_SHR3()		(g_uiRandShr3 = g_uiRandShr3 ^ (g_uiRandShr3 << 17), g_uiRandShr3 = g_uiRandShr3 ^ (g_uiRandShr3 >> 13), g_uiRandShr3 = g_uiRandShr3 ^ (g_uiRandShr3 << 5))

// Congruential generator
//
// Original comments:
//	CONG is a congruential generator with the widely used 69069 multiplier:
//	x(n)=69069x(n-1)+1234567.  It has period 2^32. The leading half of its 32
//	bits seem to pass tests, but bits in the last half are too regular.
#define RANDALG_CONG()		(g_uiRandCong = 69069UL * g_uiRandCong + 1234567UL)






//=============================================================================
// Local prototypes
//=============================================================================
BOOL InitializeProcessGlobals(void);
void CleanupProcessGlobals(void);
HRESULT LoadAndAllocString(UINT uiResourceID, WCHAR ** pwszString);










#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
//=============================================================================
// DllMain
//-----------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HINSTANCE hDllInst	- Handle to this DLL module.
//	DWORD dwReason		- Reason for calling this function.
//	LPVOID lpvReserved	- Reserved.
//
// Returns: TRUE if all goes well, FALSE otherwise.
//=============================================================================
BOOL WINAPI DllMain(HINSTANCE hDllInst,
					DWORD dwReason,
					LPVOID lpvReserved)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
		{
			DPFX(DPFPREP, 2, "====> ENTER: DLLMAIN(%p): Process Attach: %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());
			

			DNASSERT(g_hDLLInstance == NULL);
			g_hDLLInstance = hDllInst;

			
			//
			// Attempt to initialize the OS abstraction layer.
			//
			if (! DNOSIndirectionInit(0))
			{
				DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!");
				return FALSE;
			}

			//
			// Attempt to initialize COM.
			//
			if (FAILED(COM_Init()))
			{
				DPFX(DPFPREP, 0, "Failed to initialize COM indirection layer!");
				DNOSIndirectionDeinit();
				return FALSE;
			}

			//
			// Attempt to initialize process-global items.
			//
			if (! InitializeProcessGlobals())
			{
				DPFX(DPFPREP, 0, "Failed to initialize globals!");
				COM_Free();
				DNOSIndirectionDeinit();
				return FALSE;
			}

			//
			// We don't need thread attach/detach messages.
			//
			DisableThreadLibraryCalls(hDllInst);

			return TRUE;
			break;
		}

		case DLL_PROCESS_DETACH:
		{
			DPFX(DPFPREP, 2, "====> EXIT: DLLMAIN(%p): Process Detach %08lx, tid=%08lx",
				DllMain, GetCurrentProcessId(), GetCurrentThreadId());


			DNASSERT(g_hDLLInstance != NULL);
			g_hDLLInstance = NULL;


			CleanupProcessGlobals();
			COM_Free();
			DNOSIndirectionDeinit();

			return TRUE;
			break;
		}

		default:
		{
			DNASSERT(FALSE);
			break;
		}
	}

	return FALSE;
} // DllMain





#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
//=============================================================================
// DllRegisterServer
//-----------------------------------------------------------------------------
//
// Description: Registers the DP8Sim COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully registered DP8Sim.
//	E_FAIL	- Failed registering DP8Sim.
//=============================================================================
HRESULT WINAPI DllRegisterServer(void)
{
	HRESULT		hr;
	CRegistry	RegObject;
	DWORD		dwLength;
	DWORD		dwSimulatedSP;
	char		szLocalPath[_MAX_PATH + 1];
	WCHAR		wszLocalPath[_MAX_PATH + 1];
	WCHAR *		pwszFriendlyName = NULL;


	//
	// Retrieve the location of this DLL.
	//
	dwLength = GetModuleFileNameA(g_hDLLInstance, szLocalPath, _MAX_PATH);
	if (dwLength == 0)
	{
		DPFX(DPFPREP, 0, "Couldn't read local path!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Include NULL termination.
	//
	szLocalPath[dwLength] = '\0';
	dwLength++;


	//
	// Convert it to Unicode.
	//
	hr = STR_AnsiToWide(szLocalPath, dwLength, wszLocalPath, &dwLength);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Could not convert ANSI path to Unicode!");
		goto Failure;
	}


	//
	// Register the control COM object CLSID.
	//
	if (! RegObject.Register(L"DP8SimControl.1",
							L"DirectPlay8 Network Simulator Control Object",
							wszLocalPath,
							&CLSID_DP8SimControl,
							L"DP8SimControl"))
	{
		DPFX(DPFPREP, 0, "Could not register DP8SimControl object!");
		hr = E_FAIL;
		goto Failure;
	}

	//
	// Register all of the simulated SPs.
	//
	for(dwSimulatedSP = 0; dwSimulatedSP < NUM_SUPPORTED_SPS; dwSimulatedSP++)
	{
		if (! RegObject.Register(c_aSupportedSPs[dwSimulatedSP].pwszProgID,
								c_aSupportedSPs[dwSimulatedSP].pwszDesc,
								wszLocalPath,
								c_aSupportedSPs[dwSimulatedSP].pclsidFakeSP,
								c_aSupportedSPs[dwSimulatedSP].pwszVerIndProgID))
		{
			DPFX(DPFPREP, 0, "Could not register simulated SP %u object!",
				dwSimulatedSP);
			hr = E_FAIL;
			goto Failure;
		}

		hr = LoadAndAllocString(c_aSupportedSPs[dwSimulatedSP].uiFriendlyNameResourceID,
								&pwszFriendlyName);

		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Could not load friendly name string (err = 0x%lx)!", hr);
			goto Failure;
		}

		if (! RegObject.Open(HKEY_LOCAL_MACHINE, c_aSupportedSPs[dwSimulatedSP].pwszServiceProviderKey, FALSE, TRUE))
		{
			DPFX(DPFPREP, 0, "Could not open service provider key!");
			hr = E_FAIL;
			goto Failure;
		}

		RegObject.WriteString(DPN_REG_KEYNAME_FRIENDLY_NAME, pwszFriendlyName);
		RegObject.WriteGUID(DPN_REG_KEYNAME_GUID, *(c_aSupportedSPs[dwSimulatedSP].pclsidFakeSP));
		RegObject.Close();

		DNFree(pwszFriendlyName);
		pwszFriendlyName = NULL;
	}

	hr = S_OK;


Exit:

	return hr;

Failure:

	if (pwszFriendlyName != NULL)
	{
		DNFree(pwszFriendlyName);
		pwszFriendlyName = NULL;
	}

	goto Exit;
} // DllRegisterServer





#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
//=============================================================================
// DllUnregisterServer
//-----------------------------------------------------------------------------
//
// Description: Unregisters the DP8Sim COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DP8Sim.
//	E_FAIL	- Failed unregistering DP8Sim.
//=============================================================================
STDAPI DllUnregisterServer(void)
{
	HRESULT		hr;
	CRegistry	RegObject;
	DWORD		dwSimulatedSP;


	//
	// Unregister the control class.
	//
	if (! RegObject.UnRegister(&CLSID_DP8SimControl))
	{
		DPFX(DPFPREP, 0, "Failed to unregister DP8Sim control object!");
		hr = E_FAIL;
		goto Failure;
	}


	//
	// Unregister all of the simulated SPs.
	//

	if (! RegObject.Open(HKEY_LOCAL_MACHINE, DPN_REG_LOCAL_SP_SUBKEY, FALSE, FALSE, FALSE))
	{
		DPFX(DPFPREP, 0, "Could not open HKEY_LOCAL_MACHINE!");
		hr = E_FAIL;
		goto Failure;
	}

	for(dwSimulatedSP = 0; dwSimulatedSP < NUM_SUPPORTED_SPS; dwSimulatedSP++)
	{
		if (! RegObject.UnRegister(c_aSupportedSPs[dwSimulatedSP].pclsidFakeSP))
		{
			DPFX(DPFPREP, 0, "Could not unregister simulated SP %u object!",
				dwSimulatedSP);
			hr = E_FAIL;
			goto Failure;
		}

		if (! RegObject.DeleteSubKey(c_aSupportedSPs[dwSimulatedSP].pwszVerIndProgID))
		{
			DPFX(DPFPREP, 0, "Could not delete simulated SP %u's key!",
				dwSimulatedSP);
			hr = E_FAIL;
			goto Failure;
		}
	}

	RegObject.Close();
	hr = S_OK;


Exit:

	return hr;

Failure:

	//
	// Rely on RegObject destructure to close registry key.
	//

	goto Exit;
} // DllUnregisterServer






#undef DPF_MODNAME
#define DPF_MODNAME "InitializeProcessGlobals"
//=============================================================================
// InitializeProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Initialize global items needed for the DLL to operate.
//
// Arguments: None.
//
// Returns: TRUE if successful, FALSE if an error occurred.
//=============================================================================
BOOL InitializeProcessGlobals(void)
{
	BOOL	fReturn = TRUE;
	BOOL	fInittedGlobalLock = FALSE;


	if (! DNInitializeCriticalSection(&g_csGlobalsLock))
	{
		DPFX(DPFPREP, 0, "Failed to initialize global lock!");
		goto Failure;
	}

	fInittedGlobalLock = TRUE;

	
	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&g_csGlobalsLock, 0);


	if (!InitializePools())
	{
		DPFX(DPFPREP, 0, "Failed initializing pools!");
		goto Failure;
	}


	g_blDP8SimSPObjs.Initialize();
	g_blDP8SimControlObjs.Initialize();


	//
	// Seed the random number generator with the current time.
	//
	InitializeGlobalRand(GETTIMESTAMP());


Exit:

	return fReturn;


Failure:

	if (fInittedGlobalLock)
	{
		DNDeleteCriticalSection(&g_csGlobalsLock);
	}

	fReturn = FALSE;

	goto Exit;
} // InitializeProcessGlobals




#undef DPF_MODNAME
#define DPF_MODNAME "CleanupProcessGlobals"
//=============================================================================
// CleanupProcessGlobals
//-----------------------------------------------------------------------------
//
// Description: Releases global items used by DLL.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CleanupProcessGlobals(void)
{
	CBilink *			pBilink;
	CDP8SimSP *			pDP8SimSP;
	CDP8SimControl *	pDP8SimControl;


	if (! g_blDP8SimSPObjs.IsEmpty())
	{
		DNASSERT(! "DP8Sim DLL unloading without all SP objects having been released!");

		//
		// Force close all the objects still outstanding.
		//
		pBilink = g_blDP8SimSPObjs.GetNext();
		while (pBilink != &g_blDP8SimSPObjs)
		{
			pDP8SimSP = DP8SIMSP_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			DPFX(DPFPREP, 0, "Forcefully releasing SP object 0x%p!", pDP8SimSP);

			pDP8SimSP->Close(); // ignore error
			

			//
			// Forcefully remove it from the list and delete it instead of
			// using pDP8SimSP->Release().
			//
			pDP8SimSP->m_blList.RemoveFromList();
			pDP8SimSP->UninitializeObject();
			delete pDP8SimSP;
		}
	}


	if (! g_blDP8SimControlObjs.IsEmpty())
	{
		DNASSERT(! "DP8Sim DLL unloading without all Control objects having been released!");

		//
		// Force close all the objects still outstanding.
		//
		pBilink = g_blDP8SimControlObjs.GetNext();
		while (pBilink != &g_blDP8SimControlObjs)
		{
			pDP8SimControl = DP8SIMCONTROL_FROM_BILINK(pBilink);
			pBilink = pBilink->GetNext();


			DPFX(DPFPREP, 0, "Forcefully releasing Control object 0x%p!", pDP8SimControl);

			pDP8SimControl->Close(0); // ignore error
			

			//
			// Forcefully remove it from the list and delete it instead of
			// using pDP8SimControl->Release().
			//
			pDP8SimControl->m_blList.RemoveFromList();
			pDP8SimControl->UninitializeObject();
			delete pDP8SimControl;
		}
	}

	CleanupPools();

	DNDeleteCriticalSection(&g_csGlobalsLock);
} // CleanupProcessGlobals





#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"
//=============================================================================
// LoadAndAllocString
//-----------------------------------------------------------------------------
//
// Description: DNMallocs a wide character string from the given resource ID.
//
// Arguments:
//	UINT uiResourceID		- Resource ID to load.
//	WCHAR ** pwszString		- Place to store pointer to allocated string.
//
// Returns: HRESULT
//=============================================================================
HRESULT LoadAndAllocString(UINT uiResourceID, WCHAR ** pwszString)
{
	HRESULT		hr = DPN_OK;
	int			iLength;


	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		WCHAR	wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		

		iLength = LoadStringW(g_hDLLInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
			hr = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %d error 0x%x", uiResourceID, hr);
			(*pwszString) = NULL;

			goto Exit;
		}


		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		wcscpy((*pwszString), wszTmpBuffer);
	}
	else
	{
		char	szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
		

		iLength = LoadStringA(g_hDLLInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
			hr = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %u (err =0x%lx)!", uiResourceID, hr);
			(*pwszString) = NULL;

			goto Exit;
		}

		
		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		hr = STR_jkAnsiToWide((*pwszString), szTmpBuffer, (iLength + 1));
		if (hr == DPN_OK)
		{
			hr = GetLastError();
			
			DPFX(DPFPREP, 0, "Unable to convert from ANSI to Unicode (err =0x%lx)!", hr);

			goto Exit;
		}
	}


Exit:

	return hr;
} // LoadAndAllocString





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeGlobalRand"
//=============================================================================
// InitializeGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Initializes the global psuedo-random number generator, using
//				the given seed value.
//
//				  Based off algorithms posted to usenet by George Marsaglia.
//
// Arguments:
//	DWORD dwSeed	- Seed to use.
//
// Returns: None.
//=============================================================================
void InitializeGlobalRand(const DWORD dwSeed)
{
	//
	// We don't need to hold a lock, since this should only be done once,
	// during initialization time.
	//
	g_uiRandShr3 = dwSeed;
	g_uiRandCong = dwSeed;
} // InitializeGlobalRand





#undef DPF_MODNAME
#define DPF_MODNAME "GetGlobalRand"
//=============================================================================
// GetGlobalRand
//-----------------------------------------------------------------------------
//
// Description:   Generates a pseudo-random positive double between 0.0 and
//				1.0, inclusive.
//
//				  Based off algorithms posted to usenet by George Marsaglia.
//
// Arguments: None.
//
// Returns: Pseudo-random number.
//=============================================================================
double GetGlobalRand(void)
{
	double	dResult;


	DNEnterCriticalSection(&g_csGlobalsLock);

	dResult = (RANDALG_CONG() + RANDALG_SHR3()) * 2.328306e-10f;

	DNLeaveCriticalSection(&g_csGlobalsLock);

	return dResult;
} // GetGlobalRand







#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateInstance"
//=============================================================================
// DoCreateInstance
//-----------------------------------------------------------------------------
//
// Description: Creates an instance of an interface.  Required by the general
//				purpose class factory functions.
//
// Arguments:
//	LPCLASSFACTORY This		- Pointer to class factory.
//	LPUNKNOWN pUnkOuter		- Pointer to unknown interface.
//	REFCLSID rclsid			- Reference of GUID of desired interface.
//	REFIID riid				- Reference to another GUID?
//	LPVOID * ppvObj			- Pointer to pointer to interface.
//
// Returns: HRESULT
//=============================================================================
HRESULT DoCreateInstance(LPCLASSFACTORY This,
						LPUNKNOWN pUnkOuter,
						REFCLSID rclsid,
						REFIID riid,
						LPVOID * ppvObj)
{
	HRESULT				hr;
	CDP8SimSP *			pDP8SimSP = NULL;
	CDP8SimControl *	pDP8SimControl = NULL;
	DWORD				dwSimulatedSP;


	DNASSERT(ppvObj != NULL);


	//
	// See if it's the control object.
	//
	if (IsEqualCLSID(rclsid, CLSID_DP8SimControl))
	{
		//
		// Create the object instance.
		//
		pDP8SimControl = new CDP8SimControl;
		if (pDP8SimControl == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Failure;
		}


		//
		// Initialize the base object (which might fail).
		//
		hr = pDP8SimControl->InitializeObject();
		if (hr != S_OK)
		{
			delete pDP8SimControl;
			pDP8SimControl = NULL;
			goto Failure;
		}


		//
		// Add it to the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		pDP8SimControl->m_blList.InsertBefore(&g_blDP8SimControlObjs);
		
		g_lOutstandingInterfaceCount++;	// update count so DllCanUnloadNow works correctly

		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Get the right interface for the caller and bump the refcount.
		//
		hr = pDP8SimControl->QueryInterface(riid, ppvObj);
		if (hr != S_OK)
		{
			goto Failure;
		}
	}
	else
	{
		//
		// Look up the real SP we're replacing.
		//
		for(dwSimulatedSP = 0; dwSimulatedSP < NUM_SUPPORTED_SPS; dwSimulatedSP++)
		{
			if (IsEqualCLSID(rclsid, *(c_aSupportedSPs[dwSimulatedSP].pclsidFakeSP)))
			{
				break;
			}
		}

		//
		// If we didn't find it
		//
		if (dwSimulatedSP >= NUM_SUPPORTED_SPS)
		{
			DPFX(DPFPREP, 0, "Unrecognized service provider class ID!");
			hr = E_UNEXPECTED;
			goto Failure;
		}


		//
		// Create the object instance.
		//
		pDP8SimSP = new CDP8SimSP(c_aSupportedSPs[dwSimulatedSP].pclsidFakeSP,
								c_aSupportedSPs[dwSimulatedSP].pclsidRealSP);
		if (pDP8SimSP == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Initialize the base object (which might fail).
		//
		hr = pDP8SimSP->InitializeObject();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't initialize object!");
			delete pDP8SimSP;
			pDP8SimSP = NULL;
			goto Failure;
		}


		//
		// Add it to the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		pDP8SimSP->m_blList.InsertBefore(&g_blDP8SimSPObjs);
		
		g_lOutstandingInterfaceCount++;	// update count so DllCanUnloadNow works correctly

		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Get the right interface for the caller and bump the refcount.
		//
		hr = pDP8SimSP->QueryInterface(riid, ppvObj);
		if (hr != S_OK)
		{
			goto Failure;
		}
	}


Exit:

	//
	// Release the local reference to the objec(s)t.  If this function was
	// successful, there's still a reference in ppvObj.
	//

	if (pDP8SimSP != NULL)
	{
		pDP8SimSP->Release();
		pDP8SimSP = NULL;
	}

	if (pDP8SimControl != NULL)
	{
		pDP8SimControl->Release();
		pDP8SimControl = NULL;
	}

	return hr;


Failure:

	//
	// Make sure we don't hand back a pointer.
	//
	(*ppvObj) = NULL;

	goto Exit;
} // DoCreateInstance




#undef DPF_MODNAME
#define DPF_MODNAME "IsClassImplemented"
//=============================================================================
// IsClassImplemented
//-----------------------------------------------------------------------------
//
// Description: Determine if a class is implemented in this DLL.  Required by
//				the general purpose class factory functions.
//
// Arguments:
//	REFCLSID rclsid		- Reference to class GUID.
//
// Returns: BOOL
//	TRUE	 - This DLL implements the class.
//	FALSE	 - This DLL doesn't implement the class.
//=============================================================================
BOOL IsClassImplemented(REFCLSID rclsid)
{
	DWORD	dwSimulatedSP;


	if (IsEqualCLSID(rclsid, CLSID_DP8SimControl))
	{
		return TRUE;
	}

	//
	// Check if this is a valid simulated SP.
	//
	for(dwSimulatedSP = 0; dwSimulatedSP < NUM_SUPPORTED_SPS; dwSimulatedSP++)
	{
		if (IsEqualCLSID(rclsid, *(c_aSupportedSPs[dwSimulatedSP].pclsidFakeSP)))
		{
			return TRUE;
		}
	}

	return FALSE;
} // IsClassImplemented
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simclassfac.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simclassfac.cpp
 *
 *  Content:	a generic class factory.
 *
 *
 *	This is a generic C++ class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instance of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Copied from DPNHUPNP.
 *
 ***************************************************************************/


#include "dp8simi.h"



#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef class GPClassFactory:public IClassFactory
{
	public:
		GPClassFactory(const CLSID * pclsid)	{ m_dwRefCnt = 0; memcpy(&m_clsid, pclsid, sizeof(CLSID)); };
		~GPClassFactory(void)				{};


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		STDMETHODIMP LockServer(BOOL fLock);


	private:
		DWORD		m_dwRefCnt;
		CLSID		m_clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;


//
// function prototype for CoLockObjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces, defined in dpnathlpdllmain.cpp
//
extern volatile LONG	g_lOutstandingInterfaceCount;



//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GPClassFactory::QueryInterface
 */
STDMETHODIMP GPClassFactory::QueryInterface(
											REFIID riid,
											LPVOID *ppvObj )
{
	HRESULT hr;

    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        this->m_dwRefCnt++;
        *ppvObj = this;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GPClassFactory::QueryInterface */


/*
 * GPClassFactory::AddRef
 */
STDMETHODIMP_(ULONG) GPClassFactory::AddRef( void )
{
    this->m_dwRefCnt++;
    return this->m_dwRefCnt;
} /* GPClassFactory::AddRef */



/*
 * GPClassFactory::Release
 */
STDMETHODIMP_(ULONG) GPClassFactory::Release( void )
{
    this->m_dwRefCnt--;

    if( this->m_dwRefCnt != 0 )
    {
        return this->m_dwRefCnt;
    }

    delete this;
    return 0;

} /* GPClassFactory::Release */




/*
 * GPClassFactory::CreateInstance
 *
 * Creates an instance of the object
 */
STDMETHODIMP GPClassFactory::CreateInstance(
											LPUNKNOWN pUnkOuter,
											REFIID riid,
    										LPVOID *ppvObj
											)
{
    HRESULT					hr = S_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(this, pUnkOuter, this->m_clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GPClassFactory::CreateInstance */



/*
 * GPClassFactory::LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GPClassFactory::LockServer(
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;


    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibraryA( "OLE32.DLL" );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, "CoLockObjectExternal" ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GPClassFactory::LockServer */



/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = new GPClassFactory(&rclsid);
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

    hr = pcf->QueryInterface( riid, ppvObj );
    if( FAILED( hr ) )
    {
        delete pcf;
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simendpoint.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simendpoint.h
 *
 *  Content:	Header for endpoint object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  05/08/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define DP8SIMENDPOINTOBJ_DISCONNECTING		0x01	// the endpoint is disconnecting





//=============================================================================
// Endpoint object class
//=============================================================================
class CDP8SimEndpoint
{
	public:

		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimEndpoint))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x454d4953)	// 0x45 0x4d 0x49 0x53 = 'EMIS' = 'SIME' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		static BOOL FPMAlloc(void* pvItem, void* pvContext)
		{
			CDP8SimEndpoint *	pDP8SimEndpoint = (CDP8SimEndpoint*) pvItem;


			pDP8SimEndpoint->m_Sig[0] = 'S';
			pDP8SimEndpoint->m_Sig[1] = 'I';
			pDP8SimEndpoint->m_Sig[2] = 'M';
			pDP8SimEndpoint->m_Sig[3] = 'e';	// start with lower case so we can tell when it's in the pool or not

			pDP8SimEndpoint->m_lRefCount			= 0;

			if (! DNInitializeCriticalSection(&pDP8SimEndpoint->m_csLock))
			{
				return FALSE;
			}

			//
			// Don't allow critical section re-entry.
			//
			DebugSetCriticalSectionRecursionCount(&pDP8SimEndpoint->m_csLock, 0);

			pDP8SimEndpoint->m_dwFlags				= 0;
			pDP8SimEndpoint->m_hRealSPEndpoint		= NULL;
			pDP8SimEndpoint->m_pvUserContext		= NULL;

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::FPMInitialize"
		static void FPMInitialize(void* pvItem, void* pvContext)
		{
			CDP8SimEndpoint *	pDP8SimEndpoint = (CDP8SimEndpoint*) pvItem;


			pDP8SimEndpoint->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(pDP8SimEndpoint->m_lRefCount == 1);


			//
			// Reset the flags.
			//
			pDP8SimEndpoint->m_dwFlags = 0;


			//
			// Save the real SP's endpoint handle.
			//
			pDP8SimEndpoint->m_hRealSPEndpoint = (HANDLE) pvContext;


			//
			// Change the signature before handing it out.
			//
			pDP8SimEndpoint->m_Sig[3]	= 'E';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::FPMRelease"
		static void FPMRelease(void* pvItem)
		{
			CDP8SimEndpoint *	pDP8SimEndpoint = (CDP8SimEndpoint*) pvItem;


			DNASSERT(pDP8SimEndpoint->m_lRefCount == 0);


			//
			// Change the signature before putting the object back in the pool.
			//
			pDP8SimEndpoint->m_Sig[3]	= 'e';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::FPMDealloc"
		static void FPMDealloc(void* pvItem)
		{
			CDP8SimEndpoint *	pDP8SimEndpoint = (CDP8SimEndpoint*) pvItem;


			DNASSERT(pDP8SimEndpoint->m_lRefCount == 0);

			DNDeleteCriticalSection(&pDP8SimEndpoint->m_csLock);
		}




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_FPOOLEndpoint.Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Endpoint 0x%p refcount = %u.", this, lResult);
			}
		};


		inline void Lock(void)		{ DNEnterCriticalSection(&this->m_csLock); };
		inline void Unlock(void)	{ DNLeaveCriticalSection(&this->m_csLock); };


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::IsDisconnecting"
		inline BOOL IsDisconnecting(void)
		{
			AssertCriticalSectionIsTakenByThisThread(&this->m_csLock, TRUE);
			return ((this->m_dwFlags & DP8SIMENDPOINTOBJ_DISCONNECTING) ? TRUE: FALSE);
		};


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimEndpoint::NoteDisconnecting"
		inline void NoteDisconnecting(void)
		{
			AssertCriticalSectionIsTakenByThisThread(&this->m_csLock, TRUE);
#pragma TODO(vanceo, "Have separate upper/lower layer disconnect flags")
			//DNASSERT(! (this->m_dwFlags & DP8SIMENDPOINTOBJ_DISCONNECTING));
			this->m_dwFlags |= DP8SIMENDPOINTOBJ_DISCONNECTING;
		};


		inline HANDLE GetRealSPEndpoint(void)				{ return this->m_hRealSPEndpoint; };
		inline PVOID GetUserContext(void)					{ return this->m_pvUserContext; };

		inline void SetUserContext(PVOID pvUserContext)		{ this->m_pvUserContext = pvUserContext; };

	
	private:
		BYTE				m_Sig[4];				// debugging signature ('SIME')
		LONG				m_lRefCount;			// number of references for this object
		DNCRITICAL_SECTION	m_csLock;				// lock protecting the endpoint data
		DWORD				m_dwFlags;				// flags for this endpoint
		HANDLE				m_hRealSPEndpoint;		// real service provider's endpoint handle
		PVOID				m_pvUserContext;		// upper layer user context for endpoint
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simipc.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		spcallbackobj.cpp
 *
 *  Content:	Interprocess communication object object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/25/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// Defines
//=============================================================================
#define REGKEY_DP8SIM							L"Software\\Microsoft\\DirectPlay\\DP8Sim"
#define REGKEY_VALUE_DEFAULTSENDPARAMETERS		L"DefaultSendParameters"
#define REGKEY_VALUE_DEFAULTRECEIVEPARAMETERS	L"DefaultReceiveParameters"






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::CDP8SimIPC"
//=============================================================================
// CDP8SimIPC constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimIPC object.
//
// Arguments: None.
//
// Returns: None (the object).
//=============================================================================
CDP8SimIPC::CDP8SimIPC(void)
{
	this->m_Sig[0]	= 'S';
	this->m_Sig[1]	= 'I';
	this->m_Sig[2]	= 'M';
	this->m_Sig[3]	= 'I';

	this->m_hMutex			= NULL;
	this->m_hFileMapping	= NULL;
	this->m_pdp8ssm			= NULL;
} // CDP8SimIPC::CDP8SimIPC






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::~CDP8SimIPC"
//=============================================================================
// CDP8SimIPC destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimIPC object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimIPC::~CDP8SimIPC(void)
{
	DNASSERT(this->m_hMutex == NULL);
	DNASSERT(this->m_hFileMapping == NULL);
	DNASSERT(this->m_pdp8ssm == NULL);


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'c';
} // CDP8SimIPC::~CDP8SimIPC





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::Initialize"
//=============================================================================
// CDP8SimIPC::Initialize
//-----------------------------------------------------------------------------
//
// Description: Establishes the IPC connection.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
HRESULT CDP8SimIPC::Initialize(void)
{
	HRESULT				hr = DP8SIM_OK;
	DP8SIM_PARAMETERS	dp8spSend;
	DP8SIM_PARAMETERS	dp8spReceive;
	BOOL				fLockedSharedMemory = FALSE;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	DNASSERT(this->m_hMutex == NULL);
	DNASSERT(this->m_hFileMapping == NULL);


	//
	// This defaults to having every option turned off and setting the packet
	// header size to IP + UDP.
	//

	ZeroMemory(&dp8spSend, sizeof(dp8spSend));
	dp8spSend.dwSize				= sizeof(dp8spSend);
	//dp8spSend.dwFlags				= 0;
	dp8spSend.dwPacketHeaderSize	= DP8SIMPACKETHEADERSIZE_IP_UDP;
	//dp8spSend.dwBandwidthBPS		= 0;
	//dp8spSend.fPacketLossPercent	= 0.0;
	//dp8spSend.dwMinLatencyMS		= 0;
	//dp8spSend.dwMaxLatencyMS		= 0;

	ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
	dp8spReceive.dwSize					= sizeof(dp8spReceive);
	//dp8spReceive.dwFlags				= 0;
	dp8spReceive.dwPacketHeaderSize		= DP8SIMPACKETHEADERSIZE_IP_UDP;
	//dp8spReceive.dwBandwidthBPS		= 0;
	//dp8spReceive.fPacketLossPercent	= 0.0;
	//dp8spReceive.dwMinLatencyMS		= 0;
	//dp8spReceive.dwMaxLatencyMS		= 0;


	//
	// Try overriding with registry settings.
	//
	this->LoadDefaultParameters(&dp8spSend, &dp8spReceive);


	//
	// Create/open the IPC mutex.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		this->m_hMutex = CreateMutex(DNGetNullDacl(), FALSE, _T("Global\\") DP8SIM_IPC_MUTEXNAME);
	}
	else
	{
		this->m_hMutex = CreateMutex(DNGetNullDacl(), FALSE, DP8SIM_IPC_MUTEXNAME);
	}
	if (this->m_hMutex == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create shared memory mutex!");
		goto Failure;
	}


	//
	// Create/open the IPC memory mapped file.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		this->m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
												DNGetNullDacl(),
												PAGE_READWRITE,
												0,
												sizeof(DP8SIM_SHAREDMEMORY),
												_T("Global\\") DP8SIM_IPC_FILEMAPPINGNAME);
	}
	else
	{
		this->m_hFileMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
												DNGetNullDacl(),
												PAGE_READWRITE,
												0,
												sizeof(DP8SIM_SHAREDMEMORY),
												DP8SIM_IPC_FILEMAPPINGNAME);
	}
	if (this->m_hFileMapping == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't create shared memory mapped file!");
		goto Failure;
	}


	//
	// Create a view of the memory mapped file.
	//
	this->m_pdp8ssm = (DP8SIM_SHAREDMEMORY*) MapViewOfFile(this->m_hFileMapping,
															(FILE_MAP_READ | FILE_MAP_WRITE),
															0,
															0,
															0);
	if (this->m_pdp8ssm == NULL)
	{
		hr = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't map view of shared memory!");
		goto Failure;
	}



	this->LockSharedMemory();
	fLockedSharedMemory = TRUE;

	//
	// Determine whether we need to initialize the shared memory or not.
	//
	if (this->m_pdp8ssm->dwVersion == 0)
	{
		this->m_pdp8ssm->dwVersion = DP8SIM_IPC_VERSION;
		CopyMemory(&(this->m_pdp8ssm->dp8spSend), &dp8spSend, sizeof(dp8spSend));
		CopyMemory(&(this->m_pdp8ssm->dp8spReceive), &dp8spReceive, sizeof(dp8spReceive));

		//ZeroMemory(&(this->m_pdp8ssm->dp8ssSend), sizeof(this->m_pdp8ssm->dp8ssSend));
		this->m_pdp8ssm->dp8ssSend.dwSize = sizeof(this->m_pdp8ssm->dp8ssSend);
		//ZeroMemory(&(this->m_pdp8ssm->dp8ssReceive), sizeof(this->m_pdp8ssm->dp8ssReceive));
		this->m_pdp8ssm->dp8ssReceive.dwSize = sizeof(this->m_pdp8ssm->dp8ssReceive);
	}
	else
	{
		//
		// It's already initialized.  Make sure we know how to play with the
		// format given.
		//
		if (this->m_pdp8ssm->dwVersion != DP8SIM_IPC_VERSION)
		{
			DPFX(DPFPREP, 0, "Shared memory was initialized by a different version!");
			hr = DP8SIMERR_MISMATCHEDVERSION;
			goto Failure;
		}


		DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize = sizeof(DP8SIM_PARAMETERS));
		DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize = sizeof(DP8SIM_PARAMETERS));
		DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize = sizeof(DP8SIM_STATISTICS));
		DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize = sizeof(DP8SIM_STATISTICS));
	}

	this->UnlockSharedMemory();
	fLockedSharedMemory = FALSE;
	
	
Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fLockedSharedMemory)
	{
		this->UnlockSharedMemory();
		fLockedSharedMemory = FALSE;
	}

	if (this->m_pdp8ssm != NULL)
	{
		UnmapViewOfFile(this->m_pdp8ssm);
		this->m_pdp8ssm = NULL;
	}

	if (this->m_hFileMapping != NULL)
	{
		CloseHandle(this->m_hFileMapping);
		this->m_hFileMapping = NULL;
	}

	if (this->m_hMutex != NULL)
	{
		CloseHandle(this->m_hMutex);
		this->m_hMutex = NULL;
	}

	goto Exit;
} // CDP8SimIPC::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::Close"
//=============================================================================
// CDP8SimIPC::Close
//-----------------------------------------------------------------------------
//
// Description: Closes the IPC connection.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::Close(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	if (this->m_pdp8ssm != NULL)
	{
		//
		// Try overriding with registry settings.
		//
		this->SaveDefaultParameters(&(this->m_pdp8ssm->dp8spSend),
									&(this->m_pdp8ssm->dp8spReceive));


		UnmapViewOfFile(this->m_pdp8ssm);
		this->m_pdp8ssm = NULL;
	}

	if (this->m_hFileMapping != NULL)
	{
		CloseHandle(this->m_hFileMapping);
		this->m_hFileMapping = NULL;
	}

	if (this->m_hMutex != NULL)
	{
		CloseHandle(this->m_hMutex);
		this->m_hMutex = NULL;
	}


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimIPC::Close






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllParameters"
//=============================================================================
// CDP8SimIPC::GetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current send and receive settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store send parameters
//											retrieved.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store receive parameters
//											retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend,
								DP8SIM_PARAMETERS * const pdp8spReceive)
{
	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8spSend, &(this->m_pdp8ssm->dp8spSend), sizeof(DP8SIM_PARAMETERS));

	DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8spReceive, &(this->m_pdp8ssm->dp8spReceive), sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllSendParameters"
//=============================================================================
// CDP8SimIPC::GetAllSendParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current send settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8sp	- Place to store parameters retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllSendParameters(DP8SIM_PARAMETERS * const pdp8sp)
{
	DNASSERT(pdp8sp != NULL);
	DNASSERT(pdp8sp->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8sp, &(this->m_pdp8ssm->dp8spSend), sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllSendParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllReceiveParameters"
//=============================================================================
// CDP8SimIPC::GetAllReceiveParameters
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current receive settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8sp	- Place to store parameters retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllReceiveParameters(DP8SIM_PARAMETERS * const pdp8sp)
{
	DNASSERT(pdp8sp != NULL);
	DNASSERT(pdp8sp->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(pdp8sp, &(this->m_pdp8ssm->dp8spReceive), sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllReceiveParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::SetAllParameters"
//=============================================================================
// CDP8SimIPC::SetAllParameters
//-----------------------------------------------------------------------------
//
// Description: Stores the send and receive settings.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- New send parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- New receive parameters.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
								const DP8SIM_PARAMETERS * const pdp8spReceive)
{
	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(&(this->m_pdp8ssm->dp8spSend), pdp8spSend, sizeof(DP8SIM_PARAMETERS));

	DNASSERT(this->m_pdp8ssm->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));
	CopyMemory(&(this->m_pdp8ssm->dp8spReceive), pdp8spReceive, sizeof(DP8SIM_PARAMETERS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::SetAllParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::GetAllStatistics"
//=============================================================================
// CDP8SimIPC::GetAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current send and receive statistics.
//
// Arguments:
//	DP8SIM_STATISTICS * pdp8ssSend		- Place to store send statistics
//											retrieved.
//	DP8SIM_STATISTICS * pdp8ssReceive	- Place to store receive statistics
//											retrieved.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend,
								DP8SIM_STATISTICS * const pdp8ssReceive)
{
	DNASSERT(pdp8ssSend != NULL);
	DNASSERT(pdp8ssSend->dwSize == sizeof(DP8SIM_STATISTICS));
	DNASSERT(pdp8ssReceive != NULL);
	DNASSERT(pdp8ssReceive->dwSize == sizeof(DP8SIM_STATISTICS));
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	CopyMemory(pdp8ssSend, &(this->m_pdp8ssm->dp8ssSend), sizeof(DP8SIM_STATISTICS));

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	CopyMemory(pdp8ssReceive, &(this->m_pdp8ssm->dp8ssReceive), sizeof(DP8SIM_STATISTICS));

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::ClearAllStatistics"
//=============================================================================
// CDP8SimIPC::ClearAllStatistics
//-----------------------------------------------------------------------------
//
// Description: Clears the current send and receive statistics.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::ClearAllStatistics(void)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	ZeroMemory(&(this->m_pdp8ssm->dp8ssSend), sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssSend.dwSize = sizeof(DP8SIM_STATISTICS);

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	ZeroMemory(&(this->m_pdp8ssm->dp8ssReceive), sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssReceive.dwSize = sizeof(DP8SIM_STATISTICS);

	this->UnlockSharedMemory();
} // CDP8SimIPC::GetAllStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatsSendTransmitted"
//=============================================================================
// CDP8SimIPC::IncrementStatsSendTransmitted
//-----------------------------------------------------------------------------
//
// Description: Increments the sends transmitted counters.
//
// Arguments:
//	DWORD dwBytes	- Size of send, in bytes.
//	DWORD dwDelay	- Amount the send was delayed, in milliseconds.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatsSendTransmitted(DWORD dwBytes, DWORD dwDelay)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssSend.dwTransmittedPackets++;
	this->m_pdp8ssm->dp8ssSend.dwTransmittedBytes += dwBytes;
	this->m_pdp8ssm->dp8ssSend.dwTotalDelayMS += dwDelay;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatsSendTransmitted






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatsSendDropped"
//=============================================================================
// CDP8SimIPC::IncrementStatsSendDropped
//-----------------------------------------------------------------------------
//
// Description: Increments the sends dropped counters.
//
// Arguments:
//	DWORD dwBytes	- Size of send, in bytes.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatsSendDropped(DWORD dwBytes)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssSend.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssSend.dwDroppedPackets++;
	this->m_pdp8ssm->dp8ssSend.dwDroppedBytes += dwBytes;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatsSendDropped






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatsReceiveTransmitted"
//=============================================================================
// CDP8SimIPC::IncrementStatsReceiveTransmitted
//-----------------------------------------------------------------------------
//
// Description: Increments the receives indicated counters.
//
// Arguments:
//	DWORD dwBytes	- Size of receive, in bytes.
//	DWORD dwDelay	- Amount the receive was delayed, in milliseconds.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatsReceiveTransmitted(DWORD dwBytes, DWORD dwDelay)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssReceive.dwTransmittedPackets++;
	this->m_pdp8ssm->dp8ssReceive.dwTransmittedBytes += dwBytes;
	this->m_pdp8ssm->dp8ssReceive.dwTotalDelayMS += dwDelay;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatsReceiveTransmitted






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::IncrementStatsReceiveDropped"
//=============================================================================
// CDP8SimIPC::IncrementStatsReceiveDropped
//-----------------------------------------------------------------------------
//
// Description: Increments the receives dropped counters.
//
// Arguments:
//	DWORD dwBytes	- Size of receive, in bytes.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::IncrementStatsReceiveDropped(DWORD dwBytes)
{
	DNASSERT(this->m_pdp8ssm != NULL);


	this->LockSharedMemory();

	DNASSERT(this->m_pdp8ssm->dp8ssReceive.dwSize == sizeof(DP8SIM_STATISTICS));
	this->m_pdp8ssm->dp8ssReceive.dwDroppedPackets++;
	this->m_pdp8ssm->dp8ssReceive.dwDroppedBytes += dwBytes;

	this->UnlockSharedMemory();
} // CDP8SimIPC::IncrementStatsReceiveDropped






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::LoadDefaultParameters"
//=============================================================================
// CDP8SimIPC::LoadDefaultParameters
//-----------------------------------------------------------------------------
//
// Description: Loads the default send and receive parameters from the registry
//				if possible.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store default send
//											parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store default receive
//											parameters.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::LoadDefaultParameters(DP8SIM_PARAMETERS * const pdp8spSend,
										DP8SIM_PARAMETERS * const pdp8spReceive)
{
	CRegistry			RegObject;
	DP8SIM_PARAMETERS	dp8spTemp;
	DWORD				dwSize;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pdp8spSend, pdp8spReceive);


	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));


	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));


	if (RegObject.Open(HKEY_CURRENT_USER, REGKEY_DP8SIM, TRUE, FALSE))
	{
		//
		// Try to read the default send parameters
		//
		dwSize = sizeof(dp8spTemp);
		if (RegObject.ReadBlob(REGKEY_VALUE_DEFAULTSENDPARAMETERS, (BYTE*) (&dp8spTemp), &dwSize))
		{
			//
			// Successfully read the parameters.  Make sure they match the
			// expected values.
			//
			if ((dwSize == sizeof(dp8spTemp)) &&
				(dp8spTemp.dwSize == sizeof(dp8spTemp)))
			{
				DPFX(DPFPREP, 2, "Successfully read default send parameters from registry.");
				memcpy(pdp8spSend, &dp8spTemp, sizeof(dp8spTemp));
			}
			else
			{
				//
				// Default send parameters are unusable, leave the values set
				// as they are.
				//
				DPFX(DPFPREP, 0, "Default send parameters stored in registry are invalid!  Ignoring.");
			}
		}
		else
		{
			//
			// Couldn't read the default send parameters, leave the values set
			// as they are.
			//
			DPFX(DPFPREP, 2, "Couldn't read default send parameters from registry, ignoring.");
		}


		//
		// Try to read the default receive parameters
		//
		dwSize = sizeof(dp8spTemp);
		if (RegObject.ReadBlob(REGKEY_VALUE_DEFAULTRECEIVEPARAMETERS, (BYTE*) (&dp8spTemp), &dwSize))
		{
			//
			// Successfully read the parameters.  Make sure they match the
			// expected values.
			//
			if ((dwSize == sizeof(dp8spTemp)) &&
				(dp8spTemp.dwSize == sizeof(dp8spTemp)))
			{
				DPFX(DPFPREP, 2, "Successfully read default receive parameters from registry.");
				memcpy(pdp8spReceive, &dp8spTemp, sizeof(dp8spTemp));
			}
			else
			{
				//
				// Default receive parameters are unusable, leave the values set
				// as they are.
				//
				DPFX(DPFPREP, 0, "Default receive parameters stored in registry are invalid!  Ignoring.");
			}
		}
		else
		{
			//
			// Couldn't read the default send parameters, leave the values set
			// as they are.
			//
			DPFX(DPFPREP, 2, "Couldn't read default send parameters from registry, ignoring.");
		}
	}
	else
	{
		//
		// Couldn't open the registry key, leave the values set as they are.
		//
		DPFX(DPFPREP, 2, "Couldn't open DP8Sim registry key, ignoring.");
	}

	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimIPC::LoadDefaultParameters






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::SaveDefaultParameters"
//=============================================================================
// CDP8SimIPC::SaveDefaultParameters
//-----------------------------------------------------------------------------
//
// Description: Writes the given send and receive parameters as the default
//				values in the registry.
//
// Arguments:
//	DP8SIM_PARAMETERS * pdp8spSend		- New default send parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- New default receive parameters.
//
// Returns: None.
//=============================================================================
void CDP8SimIPC::SaveDefaultParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
										const DP8SIM_PARAMETERS * const pdp8spReceive)
{
	CRegistry	RegObject;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pdp8spSend, pdp8spReceive);


	DNASSERT(pdp8spSend != NULL);
	DNASSERT(pdp8spSend->dwSize == sizeof(DP8SIM_PARAMETERS));


	DNASSERT(pdp8spReceive != NULL);
	DNASSERT(pdp8spReceive->dwSize == sizeof(DP8SIM_PARAMETERS));


	if (RegObject.Open(HKEY_CURRENT_USER, REGKEY_DP8SIM, FALSE, TRUE))
	{
		//
		// Write the default send and receive parameters, ignoring failure.
		//

		RegObject.WriteBlob(REGKEY_VALUE_DEFAULTSENDPARAMETERS,
							(BYTE*) pdp8spSend,
							sizeof(*pdp8spSend));

		RegObject.WriteBlob(REGKEY_VALUE_DEFAULTRECEIVEPARAMETERS,
							(BYTE*) pdp8spReceive,
							sizeof(*pdp8spReceive));
	}
	else
	{
		DPFX(DPFPREP, 0, "Couldn't open DP8Sim registry key for writing!");
	}

	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimIPC::SaveDefaultParameters
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simcmd.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simcmd.h
 *
 *  Content:	Header for command object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define CMDTYPE_SENDDATA_IMMEDIATE	1	// command represents a send transmitted right away
#define CMDTYPE_SENDDATA_DELAYED	2	// command represents a send that was artificially delayed
#define CMDTYPE_CONNECT				3	// command represents a connect
#define CMDTYPE_DISCONNECT			4	// command represents a disconnect
#define CMDTYPE_LISTEN				5	// command represents a listen
#define CMDTYPE_ENUMQUERY			6	// command represents an enum query
#define CMDTYPE_ENUMRESPOND			7	// command represents an enum respond




//=============================================================================
// Structures
//=============================================================================
typedef struct _DP8SIMCOMMAND_FPMCONTEXT
{
	DWORD	dwType;			// type of command
	PVOID	pvUserContext;	// user context for command
} DP8SIMCOMMAND_FPMCONTEXT, * PDP8SIMCOMMAND_FPMCONTEXT;






//=============================================================================
// Send object class
//=============================================================================
class CDP8SimCommand
{
	public:

		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimCommand))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x434d4953)	// 0x43 0x4d 0x49 0x53 = 'CMIS' = 'SIMC' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		static BOOL FPMAlloc(void* pvItem, void* pvContext)
		{
			CDP8SimCommand *	pDP8SimCommand = (CDP8SimCommand*) pvItem;


			pDP8SimCommand->m_Sig[0] = 'S';
			pDP8SimCommand->m_Sig[1] = 'I';
			pDP8SimCommand->m_Sig[2] = 'M';
			pDP8SimCommand->m_Sig[3] = 'c';	// start with lower case so we can tell when it's in the pool or not

			pDP8SimCommand->m_lRefCount				= 0;
			pDP8SimCommand->m_dwType				= 0;
			pDP8SimCommand->m_pvUserContext			= NULL;
			pDP8SimCommand->m_hCommand				= NULL;
			pDP8SimCommand->m_dwCommandDescriptor	= 0;
			ZeroMemory(&pDP8SimCommand->m_CommandSpecificData, sizeof(pDP8SimCommand->m_CommandSpecificData));

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::FPMInitialize"
		static void FPMInitialize(void* pvItem, void* pvContext)
		{
			CDP8SimCommand *			pDP8SimCommand = (CDP8SimCommand*) pvItem;
			DP8SIMCOMMAND_FPMCONTEXT *	pContext = (DP8SIMCOMMAND_FPMCONTEXT*) pvContext;


			pDP8SimCommand->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(pDP8SimCommand->m_lRefCount == 1);


			pDP8SimCommand->m_dwType			= pContext->dwType;
			pDP8SimCommand->m_pvUserContext		= pContext->pvUserContext;

			
			//
			// Change the signature before handing it out.
			//
			pDP8SimCommand->m_Sig[3]	= 'C';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::FPMRelease"
		static void FPMRelease(void* pvItem)
		{
			CDP8SimCommand *	pDP8SimCommand = (CDP8SimCommand*) pvItem;


			DNASSERT(pDP8SimCommand->m_lRefCount == 0);
			DNASSERT(pDP8SimCommand->m_CommandSpecificData.m_pDP8SimEndpointListen == NULL);


			//
			// Change the signature before putting the object back in the pool.
			//
			pDP8SimCommand->m_Sig[3]	= 'c';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::FPMDealloc"
		static void FPMDealloc(void* pvItem)
		{
			const CDP8SimCommand *	pDP8SimCommand = (CDP8SimCommand*) pvItem;


			DNASSERT(pDP8SimCommand->m_lRefCount == 0);
			DNASSERT(pDP8SimCommand->m_CommandSpecificData.m_pDP8SimEndpointListen == NULL);
		}




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Command 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Command 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_FPOOLCommand.Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Command 0x%p refcount = %u.", this, lResult);
			}
		};


		inline DWORD GetType(void) const							{ return this->m_dwType; };
		inline PVOID GetUserContext(void)					{ return this->m_pvUserContext; };
		inline HANDLE GetRealSPCommand(void) const				{ return this->m_hCommand; };
		inline DWORD GetRealSPCommandDescriptor(void) const		{ return this->m_dwCommandDescriptor; };

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::GetListenEndpoint"
		inline CDP8SimEndpoint * GetListenEndpoint(void)
		{
			DNASSERT(this->m_dwType == CMDTYPE_LISTEN);
			return this->m_CommandSpecificData.m_pDP8SimEndpointListen;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::GetMessageSize"
		inline DWORD GetMessageSize(void)
		{
			DNASSERT(this->m_dwType == CMDTYPE_SENDDATA_IMMEDIATE);
			return this->m_CommandSpecificData.m_dwMessageSize;
		};



		inline void SetRealSPCommand(HANDLE hCommand, DWORD dwCommandDescriptor)
		{
			this->m_hCommand				= hCommand;
			this->m_dwCommandDescriptor		= dwCommandDescriptor;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::SetListenEndpoint"
		inline void SetListenEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint)
		{
			DNASSERT(this->m_dwType == CMDTYPE_LISTEN);
			DNASSERT((this->m_CommandSpecificData.m_pDP8SimEndpointListen == NULL) || (pDP8SimEndpoint == NULL));

			//
			// Note this only sets the pointer, it is the caller's
			// responsibility to add or remove the reference as necessary.
			//
			this->m_CommandSpecificData.m_pDP8SimEndpointListen = pDP8SimEndpoint;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCommand::SetMessageSize"
		inline void SetMessageSize(const DWORD dwMessageSize)
		{
			DNASSERT(this->m_dwType == CMDTYPE_SENDDATA_IMMEDIATE);
			DNASSERT((this->m_CommandSpecificData.m_dwMessageSize == 0) || (dwMessageSize == 0));
			this->m_CommandSpecificData.m_dwMessageSize = dwMessageSize;
		};


	
	private:
		BYTE				m_Sig[4];						// debugging signature ('SIMC')
		LONG				m_lRefCount;					// number of references for this object
		DWORD				m_dwType;						// type of command
		PVOID				m_pvUserContext;				// user's context for command
		HANDLE				m_hCommand;						// real SP command handle
		DWORD				m_dwCommandDescriptor;			// real SP descriptor for command
		union
		{
			CDP8SimEndpoint *	m_pDP8SimEndpointListen;		// pointer to listen endpoint, if this is a CMDTYPE_LISTEN command
			DWORD				m_dwMessageSize;				// size of message, if this is a CMDTYPE_SENDDATA_IMMEDIATE command
		} m_CommandSpecificData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simpools.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simpools.h
 *
 *  Content:	Header for DP8SIM pools.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  06/09/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Forward typedefs
//=============================================================================
class CDP8SimSend;
class CDP8SimReceive;
class CDP8SimCommand;
class CDP8SimJob;
class CDP8SimEndpoint;




///=============================================================================
// External variable references
//=============================================================================
extern CFixedPool	g_FPOOLSend;
extern CFixedPool	g_FPOOLReceive;
extern CFixedPool	g_FPOOLCommand;
extern CFixedPool	g_FPOOLJob;
extern CFixedPool	g_FPOOLEndpoint;




///=============================================================================
// External functions
//=============================================================================
BOOL InitializePools(void);
void CleanupPools(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simpools.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simpools.cpp
 *
 *  Content:	DP8SIM pool maintainence functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  06/09/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// External globals
//=============================================================================
CFixedPool g_FPOOLSend;
CFixedPool g_FPOOLReceive;
CFixedPool g_FPOOLCommand;
CFixedPool g_FPOOLJob;
CFixedPool g_FPOOLEndpoint;


#define SEND_POOL_INITED 	0x00000001
#define RECEIVE_POOL_INITED 	0x00000002
#define COMMAND_POOL_INITED 	0x00000004
#define JOB_POOL_INITED 	0x00000008
#define ENDPOINT_POOL_INITED 	0x00000010

DWORD g_dwDP8SimInitFlags = 0;


#undef DPF_MODNAME
#define DPF_MODNAME "InitializePools"
//=============================================================================
// InitializePools
//-----------------------------------------------------------------------------
//
// Description: Initialize pools for items used by the DLL.
//
// Arguments: None.
//
// Returns: TRUE if successful, FALSE if an error occurred.
//=============================================================================
BOOL InitializePools(void)
{
	//
	// Build send pool.
	//
	if (!g_FPOOLSend.Initialize(sizeof(CDP8SimSend),CDP8SimSend::FPMAlloc,
							CDP8SimSend::FPMInitialize,
							CDP8SimSend::FPMRelease,
							CDP8SimSend::FPMDealloc))
	{
		goto Failure;
	}
	g_dwDP8SimInitFlags |= SEND_POOL_INITED;


	//
	// Build receive pool.
	//
	if (!g_FPOOLReceive.Initialize(sizeof(CDP8SimReceive),	CDP8SimReceive::FPMAlloc,
								CDP8SimReceive::FPMInitialize,
								CDP8SimReceive::FPMRelease,
								CDP8SimReceive::FPMDealloc))
	{
		goto Failure;
	}
	g_dwDP8SimInitFlags |= RECEIVE_POOL_INITED;


	//
	// Build command pool.
	//
	if (!g_FPOOLCommand.Initialize(sizeof(CDP8SimCommand),	CDP8SimCommand::FPMAlloc,
								CDP8SimCommand::FPMInitialize,
								CDP8SimCommand::FPMRelease,
								CDP8SimCommand::FPMDealloc))
	{
		goto Failure;
	}
	g_dwDP8SimInitFlags |= COMMAND_POOL_INITED;


	//
	// Build job pool.
	//
	if (!g_FPOOLJob.Initialize(sizeof(CDP8SimJob),	CDP8SimJob::FPMAlloc,
							CDP8SimJob::FPMInitialize,
							CDP8SimJob::FPMRelease,
							CDP8SimJob::FPMDealloc))
	{
		goto Failure;
	}
	g_dwDP8SimInitFlags |= JOB_POOL_INITED;


	//
	// Build endpoint pool.
	//
	if (!g_FPOOLEndpoint.Initialize(sizeof(CDP8SimEndpoint),CDP8SimEndpoint::FPMAlloc,
								CDP8SimEndpoint::FPMInitialize,
								CDP8SimEndpoint::FPMRelease,
								CDP8SimEndpoint::FPMDealloc))
	{
		goto Failure;
	}
	g_dwDP8SimInitFlags |= ENDPOINT_POOL_INITED;


	return TRUE;

Failure:
	CleanupPools();
	return FALSE;

} // InitializePools




#undef DPF_MODNAME
#define DPF_MODNAME "CleanupPools"
//=============================================================================
// CleanupPools
//-----------------------------------------------------------------------------
//
// Description: Releases pooled items used by DLL.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CleanupPools(void)
{
	if (g_dwDP8SimInitFlags & ENDPOINT_POOL_INITED)
	{
		g_FPOOLEndpoint.DeInitialize();
	}
	if (g_dwDP8SimInitFlags & JOB_POOL_INITED)
	{
		g_FPOOLJob.DeInitialize();
	}
	if (g_dwDP8SimInitFlags & COMMAND_POOL_INITED)
	{
		g_FPOOLCommand.DeInitialize();
	}
	if (g_dwDP8SimInitFlags & RECEIVE_POOL_INITED)
	{
		g_FPOOLReceive.DeInitialize();
	}
	if (g_dwDP8SimInitFlags & SEND_POOL_INITED)
	{
		g_FPOOLSend.DeInitialize();
	}

	g_dwDP8SimInitFlags = 0;

} // CleanupPools
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simjob.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simjob.h
 *
 *  Content:	Header for job object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  06/09/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Macros
//=============================================================================
#define DP8SIMJOB_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CDP8SimJob, m_blList))



//=============================================================================
// Private job flags
//=============================================================================
#define DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE	0x80000000	// this job is in its blocking phase 




//=============================================================================
// Structures
//=============================================================================
typedef struct _DP8SIMJOB_FPMCONTEXT
{
	DWORD			dwTime;			// time for the job to fire
	DWORD			dwNextDelay;	// possible extra delay for the job after this first timer elapses
	DWORD			dwFlags;		// flags describing this job
	DP8SIMJOBTYPE	JobType;		// type of job
	PVOID			pvContext;		// context for job
	CDP8SimSP *		pDP8SimSP;		// owning SP object, if any
} DP8SIMJOB_FPMCONTEXT, * PDP8SIMJOB_FPMCONTEXT;






//=============================================================================
// Job object class
//=============================================================================
class CDP8SimJob
{
	public:

		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimJob))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x4a4d4953)	// 0x4a 0x4d 0x49 0x53 = 'JMIS' = 'SIMJ' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		static BOOL FPMAlloc(void* pvItem, void* pvContext)
		{
			CDP8SimJob *	pDP8SimJob = (CDP8SimJob*) pvItem;


			pDP8SimJob->m_Sig[0] = 'S';
			pDP8SimJob->m_Sig[1] = 'I';
			pDP8SimJob->m_Sig[2] = 'M';
			pDP8SimJob->m_Sig[3] = 'j';	// start with lower case so we can tell when it's in the pool or not

			pDP8SimJob->m_blList.Initialize();

			pDP8SimJob->m_dwTime		= 0;
			pDP8SimJob->m_dwNextDelay	= 0;
			pDP8SimJob->m_dwFlags		= 0;
			pDP8SimJob->m_JobType		= DP8SIMJOBTYPE_UNKNOWN;
			pDP8SimJob->m_pvContext		= NULL;
			pDP8SimJob->m_pDP8SimSP		= NULL;

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::FPMInitialize"
		static void FPMInitialize(void* pvItem, void* pvContext)
		{
			CDP8SimJob *			pDP8SimJob = (CDP8SimJob*) pvItem;
			DP8SIMJOB_FPMCONTEXT *	pContext = (DP8SIMJOB_FPMCONTEXT*) pvContext;


			pDP8SimJob->m_dwTime		= pContext->dwTime;
			pDP8SimJob->m_dwNextDelay	= pContext->dwNextDelay;
			pDP8SimJob->m_dwFlags		= pContext->dwFlags;
			pDP8SimJob->m_JobType		= pContext->JobType;
			pDP8SimJob->m_pvContext		= pContext->pvContext;

			if (pContext->pDP8SimSP != NULL)
			{
				pContext->pDP8SimSP->AddRef();
				pDP8SimJob->m_pDP8SimSP	= pContext->pDP8SimSP;
			}
			else
			{
				DNASSERT(pDP8SimJob->m_pDP8SimSP == NULL);
			}

			
			//
			// Change the signature before handing it out.
			//
			pDP8SimJob->m_Sig[3]	= 'J';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::FPMRelease"
		static void FPMRelease(void* pvItem)
		{
			CDP8SimJob *	pDP8SimJob = (CDP8SimJob*) pvItem;


			DNASSERT(pDP8SimJob->m_blList.IsEmpty());

			if (pDP8SimJob->m_pDP8SimSP != NULL)
			{
				pDP8SimJob->m_pDP8SimSP->Release();
				pDP8SimJob->m_pDP8SimSP = NULL;
			}


			//
			// Change the signature before putting the object back in the pool.
			//
			pDP8SimJob->m_Sig[3]	= 'j';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::FPMDealloc"
		static void FPMDealloc(void* pvItem)
		{
			const CDP8SimJob *	pDP8SimJob = (CDP8SimJob*) pvItem;


			DNASSERT(pDP8SimJob->m_blList.IsEmpty());
			DNASSERT(pDP8SimJob->m_pDP8SimSP == NULL);
		}


		inline DWORD GetTime(void) const						{ return this->m_dwTime; };
		inline DWORD GetNextDelay(void) const					{ return this->m_dwNextDelay; };

		inline BOOL HasAnotherPhase(void) const
		{
			if (this->m_dwFlags & DP8SIMJOBFLAG_PERFORMBLOCKINGPHASEFIRST)
			{
				if (this->m_dwFlags & DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE)
				{
					return TRUE;
				}
			}
			else if (this->m_dwFlags & DP8SIMJOBFLAG_PERFORMBLOCKINGPHASELAST)
			{
				if (! (this->m_dwFlags & DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE))
				{
					return TRUE;
				}
			}

			return FALSE;
		};

		//inline BOOL IsBlockedByAllJobs(void)			{ return ((this->m_dwFlags & DP8SIMJOBFLAG_BLOCKEDBYALLJOBS) ? TRUE : FALSE); };
		inline BOOL IsInBlockingPhase(void) const				{ return ((this->m_dwFlags & DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE) ? TRUE : FALSE); };
		inline DP8SIMJOBTYPE GetJobType(void) const			{ return this->m_JobType; };
		inline PVOID GetContext(void)					{ return this->m_pvContext; };
		inline CDP8SimSP * GetDP8SimSP(void)			{ return this->m_pDP8SimSP; };


		inline void SetNewTime(const DWORD dwTime)		{ this->m_dwTime = dwTime; };

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimJob::ToggleBlockingPhase"
		inline void ToggleBlockingPhase(void)
		{
			DNASSERT(this->m_dwFlags & (DP8SIMJOBFLAG_PERFORMBLOCKINGPHASEFIRST | DP8SIMJOBFLAG_PERFORMBLOCKINGPHASELAST));
			if (this->m_dwFlags & DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE)
			{
				this->m_dwFlags &= ~DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE;
			}
			else
			{
				this->m_dwFlags |= DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE;
			}
		};


		CBilink			m_blList;		// list of all the active jobs

	
	private:
		BYTE			m_Sig[4];		// debugging signature ('SIMJ')
		DWORD			m_dwTime;		// time the job must be performed
		DWORD			m_dwNextDelay;	// extra delay for the job after first time set
		DWORD			m_dwFlags;		// flags describing this job
		DP8SIMJOBTYPE	m_JobType;		/// ID of job to be performed
		PVOID			m_pvContext;	// context for job
		CDP8SimSP *		m_pDP8SimSP;	// pointer to DP8SimSP object submitting send, or NULL if none
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simipc.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simipc.h
 *
 *  Content:	Header for interprocess communication object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/25/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define DP8SIM_IPC_VERSION				2

#define DP8SIM_IPC_MUTEXNAME			_T("DP8Sim IPC Mutex")
#define DP8SIM_IPC_FILEMAPPINGNAME		_T("DP8Sim IPC File Mapping")




//=============================================================================
// Structures
//=============================================================================
typedef struct _DP8SIM_SHAREDMEMORY
{
	DWORD				dwVersion;		// shared memory version
	DP8SIM_PARAMETERS	dp8spSend;		// current send settings
	DP8SIM_PARAMETERS	dp8spReceive;	// current receive settings
	DP8SIM_STATISTICS	dp8ssSend;		// current send statistics
	DP8SIM_STATISTICS	dp8ssReceive;	// current receive statistics
} DP8SIM_SHAREDMEMORY, * PDP8SIM_SHAREDMEMORY;







//=============================================================================
// Send object class
//=============================================================================
class CDP8SimIPC
{
	public:
		CDP8SimIPC(void);	// constructor
		~CDP8SimIPC(void);	// destructor


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimIPC))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x494d4953)	// 0x49 0x4d 0x49 0x53 = 'IMIS' = 'SIMI' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};


		HRESULT Initialize(void);

		void Close(void);

		void GetAllParameters(DP8SIM_PARAMETERS * const pdp8spSend,
							DP8SIM_PARAMETERS * const pdp8spReceive);

		void GetAllSendParameters(DP8SIM_PARAMETERS * const pdp8sp);

		void GetAllReceiveParameters(DP8SIM_PARAMETERS * const pdp8sp);

		void SetAllParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
							const DP8SIM_PARAMETERS * const pdp8spReceive);

		void GetAllStatistics(DP8SIM_STATISTICS * const pdp8ssSend,
							DP8SIM_STATISTICS * const pdp8ssReceive);

		void ClearAllStatistics(void);

		void IncrementStatsSendTransmitted(DWORD dwBytes, DWORD dwDelay);

		void IncrementStatsSendDropped(DWORD dwBytes);

		void IncrementStatsReceiveTransmitted(DWORD dwBytes, DWORD dwDelay);

		void IncrementStatsReceiveDropped(DWORD dwBytes);



	
	private:
		BYTE					m_Sig[4];		// debugging signature ('SIMI')
		HANDLE					m_hMutex;		// handle to mutex protecting shared memory
		HANDLE					m_hFileMapping;	// handle to shared memory
		DP8SIM_SHAREDMEMORY *	m_pdp8ssm;		// pointer to mapped view of shared memory


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::LockSharedMemory"
		inline void LockSharedMemory(void)
		{
			DNASSERT(this->m_hMutex != NULL);
			WaitForSingleObject(this->m_hMutex, INFINITE);
		}

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimIPC::UnlockSharedMemory"
		inline void UnlockSharedMemory(void)
		{
			DNASSERT(this->m_hMutex != NULL);
			ReleaseMutex(this->m_hMutex);
		}

		void LoadDefaultParameters(DP8SIM_PARAMETERS * const pdp8spSend,
									DP8SIM_PARAMETERS * const pdp8spReceive);

		void SaveDefaultParameters(const DP8SIM_PARAMETERS * const pdp8spSend,
									const DP8SIM_PARAMETERS * const pdp8spReceive);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simreceive.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simreceive.h
 *
 *  Content:	Header for receive object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  05/05/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Receive object class
//=============================================================================
class CDP8SimReceive
{
	public:

		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimReceive))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x524d4953)	// 0x52 0x4d 0x49 0x53 = 'RMIS' = 'SIMR' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};




		static BOOL FPMAlloc(void* pvItem, void* pvContext)
		{
			CDP8SimReceive *	pDP8SimReceive = (CDP8SimReceive*) pvItem;


			pDP8SimReceive->m_Sig[0] = 'S';
			pDP8SimReceive->m_Sig[1] = 'I';
			pDP8SimReceive->m_Sig[2] = 'M';
			pDP8SimReceive->m_Sig[3] = 'r';	// start with lower case so we can tell when it's in the pool or not

			pDP8SimReceive->m_lRefCount			= 0;
			pDP8SimReceive->m_pDP8SimEndpoint	= NULL;
			ZeroMemory(&pDP8SimReceive->m_data, sizeof(pDP8SimReceive->m_data));
			pDP8SimReceive->m_dwLatencyAdded	= 0;

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::FPMInitialize"
		static void FPMInitialize(void* pvItem, void* pvContext)
		{
			CDP8SimReceive *	pDP8SimReceive = (CDP8SimReceive*) pvItem;
			SPIE_DATA *			pData = (SPIE_DATA*) pvContext;


			pDP8SimReceive->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(pDP8SimReceive->m_lRefCount == 1);


			//
			// Get an endpoint reference.
			//
			pDP8SimReceive->m_pDP8SimEndpoint = (CDP8SimEndpoint*) pData->pEndpointContext;
			DNASSERT(pDP8SimReceive->m_pDP8SimEndpoint->IsValidObject());
			pDP8SimReceive->m_pDP8SimEndpoint->AddRef();


			DNASSERT(pData->pReceivedData->pNext == NULL);


			//
			// Copy the receive data block.
			//
			pDP8SimReceive->m_data.hEndpoint			= (HANDLE) pDP8SimReceive->m_pDP8SimEndpoint;
			pDP8SimReceive->m_data.pEndpointContext		= pDP8SimReceive->m_pDP8SimEndpoint->GetUserContext();
			pDP8SimReceive->m_data.pReceivedData		= pData->pReceivedData;

			
			//
			// Change the signature before handing it out.
			//
			pDP8SimReceive->m_Sig[3]	= 'R';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::FPMRelease"
		static void FPMRelease(void* pvItem)
		{
			CDP8SimReceive *	pDP8SimReceive = (CDP8SimReceive*) pvItem;


			DNASSERT(pDP8SimReceive->m_lRefCount == 0);

			//
			// Release the endpoint reference.
			//
			DNASSERT(pDP8SimReceive->m_pDP8SimEndpoint != NULL);

			pDP8SimReceive->m_pDP8SimEndpoint->Release();
			pDP8SimReceive->m_pDP8SimEndpoint = NULL;


			//
			// Change the signature before putting the object back in the pool.
			//
			pDP8SimReceive->m_Sig[3]	= 'r';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::FPMDealloc"
		static void FPMDealloc(void* pvItem)
		{
			const CDP8SimReceive *	pDP8SimReceive = (CDP8SimReceive*) pvItem;


			DNASSERT(pDP8SimReceive->m_lRefCount == 0);
			DNASSERT(pDP8SimReceive->m_pDP8SimEndpoint == NULL);
		}




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Receive 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimReceive::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Receive 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_FPOOLReceive.Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Receive 0x%p refcount = %u.", this, lResult);
			}
		};


		inline CDP8SimEndpoint * GetEndpoint(void)			{ return this->m_pDP8SimEndpoint; };
		inline SPIE_DATA * GetReceiveDataBlockPtr(void)		{ return (&this->m_data); };
		inline HANDLE GetReceiveDataBlockEndpoint(void)		{ return this->m_data.hEndpoint; };
		inline DWORD GetLatencyAdded(void) const					{ return this->m_dwLatencyAdded; };

		inline void SetLatencyAdded(DWORD dwLatency)		{ this->m_dwLatencyAdded = dwLatency; };


	
	private:
		BYTE				m_Sig[4];			// debugging signature ('SIMR')
		LONG				m_lRefCount;		// number of references for this object
		CDP8SimEndpoint *	m_pDP8SimEndpoint;	// pointer to source endpoint
		SPIE_DATA			m_data;				// receive data block
		DWORD				m_dwLatencyAdded;	// the latency added, saved for incrementing statistics on receive indication
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simlocals.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simlocals.h
 *
 *  Content:	Header for DP8SIM global variables and functions found in
 *				dp8simdllmain.cpp.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Defines
//=============================================================================
#define DP8SIM_REG_REALSPDLL				L"DP8SimRealSPDLL"
#define DP8SIM_REG_REALSPFRIENDLYNAME		L"DP8SimRealSPFriendlyName"



//=============================================================================
// Forward typedefs
//=============================================================================
class CDP8SimCB;
class CDP8SimSP;
class CDP8SimControl;




///=============================================================================
// External variable references
//=============================================================================
extern volatile LONG		g_lOutstandingInterfaceCount;

extern HINSTANCE			g_hDLLInstance;

extern DNCRITICAL_SECTION	g_csGlobalsLock;
extern CBilink				g_blDP8SimSPObjs;
extern CBilink				g_blDP8SimControlObjs;




///=============================================================================
// External functions
//=============================================================================
void InitializeGlobalRand(const DWORD dwSeed);
double GetGlobalRand(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simsend.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simsend.h
 *
 *  Content:	Header for send object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Defines
//=============================================================================
#define MAX_DATA_SIZE		1472	// prevent individual messages larger than one Ethernet frame - UDP headers





//=============================================================================
// Send object class
//=============================================================================
class CDP8SimSend
{
	public:

		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimSend))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x534d4953)	// 0x53 0x4d 0x49 0x53 = 'SMIS' = 'SIMS' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};



		static BOOL FPMAlloc(void* pvItem, void * pvContext)
		{
			CDP8SimSend *	pDP8SimSend = (CDP8SimSend*) pvItem;


			pDP8SimSend->m_Sig[0] = 'S';
			pDP8SimSend->m_Sig[1] = 'I';
			pDP8SimSend->m_Sig[2] = 'M';
			pDP8SimSend->m_Sig[3] = 's';	// start with lower case so we can tell when it's in the pool or not

			pDP8SimSend->m_lRefCount			= 0;
			pDP8SimSend->m_pDP8SimEndpoint		= NULL;
			ZeroMemory(&pDP8SimSend->m_adpnbd, sizeof(pDP8SimSend->m_adpnbd));
			ZeroMemory(&pDP8SimSend->m_spsd, sizeof(pDP8SimSend->m_spsd));
			pDP8SimSend->m_dwLatencyAdded		= 0;
			ZeroMemory(pDP8SimSend->m_abData, sizeof(pDP8SimSend->m_abData));

			return TRUE;
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::FPMInitialize"
		static void FPMInitialize(void* pvItem, void * pvContext)
		{
			CDP8SimSend *	pDP8SimSend = (CDP8SimSend*) pvItem;
			SPSENDDATA *	pspsd = (SPSENDDATA*) pvContext;
			BYTE *			pCurrent;
			DWORD			dwTemp;


			pDP8SimSend->m_lRefCount++;	// somebody is getting a pointer to this object
			DNASSERT(pDP8SimSend->m_lRefCount == 1);


			//
			// Reset the buffer descriptor array.
			//
			ZeroMemory(&pDP8SimSend->m_adpnbd, sizeof(pDP8SimSend->m_adpnbd));
			//pDP8SimSend->m_adpnbd[0].pBufferData	= NULL;
			//pDP8SimSend->m_adpnbd[0].dwBufferSize	= 0;
			pDP8SimSend->m_adpnbd[1].pBufferData	= pDP8SimSend->m_abData;
			//pDP8SimSend->m_adpnbd[1].dwBufferSize	= 0;


			//
			// Get an endpoint reference.
			//
			pDP8SimSend->m_pDP8SimEndpoint = (CDP8SimEndpoint*) pspsd->hEndpoint;
			DNASSERT(pDP8SimSend->m_pDP8SimEndpoint->IsValidObject());
			pDP8SimSend->m_pDP8SimEndpoint->AddRef();


			//
			// Copy the send data parameter block, modifying as necessary.
			//
			pDP8SimSend->m_spsd.hEndpoint				= pDP8SimSend->m_pDP8SimEndpoint->GetRealSPEndpoint();
			pDP8SimSend->m_spsd.pBuffers				= &(pDP8SimSend->m_adpnbd[1]);	// leave the first buffer desc for the real SP to play with
			pDP8SimSend->m_spsd.dwBufferCount			= 1;
			pDP8SimSend->m_spsd.dwFlags					= pspsd->dwFlags;
			pDP8SimSend->m_spsd.pvContext				= NULL;	// this will be filled in later by SetSendDataBlockContext
			pDP8SimSend->m_spsd.hCommand				= NULL;	// this gets filled in by the real SP
			pDP8SimSend->m_spsd.dwCommandDescriptor		= 0;	// this gets filled in by the real SP

			
			//
			// Finally, copy the data into our contiguous local buffer.
			//

			pCurrent = pDP8SimSend->m_adpnbd[1].pBufferData;

			for(dwTemp = 0; dwTemp < pspsd->dwBufferCount; dwTemp++)
			{
				if ((pDP8SimSend->m_adpnbd[1].dwBufferSize + pspsd->pBuffers[dwTemp].dwBufferSize) > MAX_DATA_SIZE)
				{
					DPFX(DPFPREP, 0, "Data too large for single buffer!");
					DNASSERT(FALSE);
				}

				CopyMemory(pCurrent,
							pspsd->pBuffers[dwTemp].pBufferData,
							pspsd->pBuffers[dwTemp].dwBufferSize);

				pCurrent += pspsd->pBuffers[dwTemp].dwBufferSize;

				pDP8SimSend->m_adpnbd[1].dwBufferSize += pspsd->pBuffers[dwTemp].dwBufferSize;
			}

			//
			// Change the signature before handing it out.
			//
			pDP8SimSend->m_Sig[3]	= 'S';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::FPMRelease"
		static void FPMRelease(void* pvItem)
		{
			CDP8SimSend *	pDP8SimSend = (CDP8SimSend*) pvItem;

			DNASSERT(pDP8SimSend->m_lRefCount == 0);

			//
			// Release the endpoint reference.
			//
			DNASSERT(pDP8SimSend->m_pDP8SimEndpoint != NULL);

			pDP8SimSend->m_pDP8SimEndpoint->Release();
			pDP8SimSend->m_pDP8SimEndpoint = NULL;


			//
			// Change the signature before putting the object back in the pool.
			//
			pDP8SimSend->m_Sig[3]	= 's';
		}


#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::FPMDealloc"
		static void FPMDealloc(void* pvItem)
		{
			const CDP8SimSend *	pDP8SimSend = (CDP8SimSend*) pvItem;

			DNASSERT(pDP8SimSend->m_lRefCount == 0);
			DNASSERT(pDP8SimSend->m_pDP8SimEndpoint == NULL);
		}





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::AddRef"
		inline void AddRef(void)
		{
			LONG	lResult;


			lResult = InterlockedIncrement(&this->m_lRefCount);
			DNASSERT(lResult > 0);
			DPFX(DPFPREP, 9, "Send 0x%p refcount = %u.", this, lResult);
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSend::Release"
		inline void Release(void)
		{
			LONG	lResult;


			lResult = InterlockedDecrement(&this->m_lRefCount);
			DNASSERT(lResult >= 0);
			if (lResult == 0)
			{
				DPFX(DPFPREP, 9, "Send 0x%p refcount = 0, returning to pool.", this);

				//
				// Time to return this object to the pool.
				//
				g_FPOOLSend.Release(this);
			}
			else
			{
				DPFX(DPFPREP, 9, "Send 0x%p refcount = %u.", this, lResult);
			}
		};




		inline CDP8SimEndpoint * GetEndpoint(void)				{ return this->m_pDP8SimEndpoint; };
		inline DWORD GetMessageSize(void) const						{ return this->m_adpnbd[1].dwBufferSize; };
		inline SPSENDDATA * GetSendDataBlockPtr(void)			{ return (&this->m_spsd); };
		inline HANDLE GetSendDataBlockCommand(void)				{ return this->m_spsd.hCommand; };
		inline DWORD GetSendDataBlockCommandDescriptor(void) const	{ return this->m_spsd.dwCommandDescriptor; };
		inline DWORD GetLatencyAdded(void) const						{ return this->m_dwLatencyAdded; };

		inline void SetSendDataBlockContext(PVOID pvContext)	{ this->m_spsd.pvContext = pvContext; };
		inline void SetLatencyAdded(DWORD dwLatency)			{ this->m_dwLatencyAdded = dwLatency; };


	
	private:
		BYTE				m_Sig[4];					// debugging signature ('SIMS')
		LONG				m_lRefCount;				// number of references for this object
		CDP8SimEndpoint *	m_pDP8SimEndpoint;			// pointer to destination endpoint
		DPN_BUFFER_DESC		m_adpnbd[2];				// data buffer descriptor array, always leave an extra buffer for SP
		SPSENDDATA			m_spsd;						// send data parameter block
		DWORD				m_dwLatencyAdded;			// the latency added, saved for incrementing statistics on send completion
		BYTE				m_abData[MAX_DATA_SIZE];	// data buffer
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dp8sim.rc
//
#define IDS_FRIENDLYNAME_TCPIP		1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\spcallbackobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       spcallbackobj.h
 *
 *  Content:	Header for DP8SIM callback interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/




//=============================================================================
// Macros
//=============================================================================
#define ENUMQUERYEVENTWRAPPER_FROM_SPIEQUERY(p)		(CONTAINING_OBJECT(p, ENUMQUERYDATAWRAPPER, QueryForUser))



//=============================================================================
// Structures
//=============================================================================
typedef struct _ENUMQUERYEVENTWRAPPER
{
	BYTE			m_Sig[4];		// debugging signature ('EQEW')
	SPIE_QUERY		QueryForUser;	// new event indication structure to be passed up to user
	SPIE_QUERY *	pOriginalQuery;	// pointer to real SP's original event indication structure
} ENUMQUERYDATAWRAPPER, * PENUMQUERYDATAWRAPPER;




//=============================================================================
// Callback interface object class
//=============================================================================
class CDP8SimCB : public IDP8SPCallback
{
	public:
		CDP8SimCB(CDP8SimSP * pOwningDP8SimSP, IDP8SPCallback * pDP8SPCB);	// constructor
		~CDP8SimCB(void);													// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP IndicateEvent(SP_EVENT_TYPE EventType, PVOID pvMessage);

		STDMETHODIMP CommandComplete(HANDLE hCommand, HRESULT hrResult, PVOID pvContext);



		HRESULT InitializeObject(void);

		void UninitializeObject(void);


		inline IDP8SPCallback * GetRealCallbackInterface(void)	{ return this->m_pDP8SPCB; };


	private:
		BYTE				m_Sig[4];			// debugging signature ('SPCB')
		LONG				m_lRefCount;		// reference count for this object
		DNCRITICAL_SECTION	m_csLock;			// lock preventing simultaneous usage of globals
		CDP8SimSP *			m_pOwningDP8SimSP;	// pointer to owing DP8SimSP object
		IDP8SPCallback *	m_pDP8SPCB;			// pointer to real DPlay callback interface



		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimCB))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x42435053)	// 0x42 0x43 0x50 0x53 = 'BCPS' = 'SPCB' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\sources.inc ===
TARGETNAME=dp8sim
TARGETTYPE=DYNLINK

DLLDEF=..\dp8sim.def

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dp8simi.h
PRECOMPILED_PCH=dp8simi.pch
PRECOMPILED_OBJ=dp8simi.obj

TARGETLIBS=$(TARGETLIBS) \
	   ..\..\..\..\common\$(PLAT_DIR)\$(O)\common.lib \
	   ..\..\guids\$(PLAT_DIR)\$(O)\guids.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
	   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib

INCLUDES=$(DXROOT)\inc;..\..\..\..\inc;..\..\..\..\common;..\..\inc;..\

SOURCES= ..\dp8sim.rc \
	 ..\dp8simclassfac.cpp \
	 ..\dp8simdllmain.cpp \
	 ..\dp8simpools.cpp \
	 ..\controlobj.cpp \
	 ..\dp8simipc.cpp \
	 ..\dp8simworkerthread.cpp \
	 ..\spcallbackobj.cpp \
	 ..\spwrapper.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simworkerthread.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simworkerthread.cpp
 *
 *  Content:	DP8SIM worker thread functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// Globals
//=============================================================================
LONG				g_lWorkerThreadRefCount = 0;	// number of times worker thread has been started
DNCRITICAL_SECTION	g_csJobQueueLock;				// lock protecting the job queue
CBilink				g_blJobQueue;					// list of jobs to be performed
HANDLE				g_hWorkerThreadJobEvent = NULL;	// event to signal when worker thread has a new job
HANDLE				g_hWorkerThread = NULL;			// handle to worker thread







//=============================================================================
// Prototypes
//=============================================================================
void InsertWorkerJobIntoQueue(CDP8SimJob * const pDP8SimJob, const DWORD dwBlockedAdditionalDelay);

DWORD DP8SimWorkerThreadProc(PVOID pvParameter);






#undef DPF_MODNAME
#define DPF_MODNAME "StartGlobalWorkerThread"
//=============================================================================
// StartGlobalWorkerThread
//-----------------------------------------------------------------------------
//
// Description: Starts the global worker thread if it hasn't already been
//				started.  Each successful call to this function must be
//				balanced by a call to StopGlobalWorkerThread.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
HRESULT StartGlobalWorkerThread(void)
{
	HRESULT		hr = DPN_OK;
	DWORD		dwThreadID;
	BOOL		fInittedCriticalSection = FALSE;


	DPFX(DPFPREP, 5, "Enter");


	DNEnterCriticalSection(&g_csGlobalsLock);

	DNASSERT(g_lWorkerThreadRefCount >= 0);
	if (g_lWorkerThreadRefCount == 0)
	{
		//
		// This is the first worker thread user.
		//


		if (! DNInitializeCriticalSection(&g_csJobQueueLock))
		{
			DPFX(DPFPREP, 0, "Failed initializing job queue critical section!");
			hr = DPNERR_GENERIC;
			goto Failure;
		}

		//
		// Don't allow critical section re-entry.
		//
		DebugSetCriticalSectionRecursionCount(&g_csJobQueueLock, 0);


		fInittedCriticalSection = TRUE;

		g_blJobQueue.Initialize();


		//
		// Create the new job notification event.
		//
		g_hWorkerThreadJobEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (g_hWorkerThreadJobEvent == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Failed creating worker thread job event!");
			goto Failure;
		}

		//
		// Create the thread.
		//
		g_hWorkerThread = CreateThread(NULL,
										0,
										DP8SimWorkerThreadProc,
										NULL,
										0,
										&dwThreadID);
		if (g_hWorkerThread == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Failed creating worker thread!");
			goto Failure;
		}
	}

	//
	// Bump the refcount for this successful call.
	//
	g_lWorkerThreadRefCount++;



Exit:

	DNLeaveCriticalSection(&g_csGlobalsLock);


	DPFX(DPFPREP, 5, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	if (g_hWorkerThreadJobEvent != NULL)
	{
		CloseHandle(g_hWorkerThreadJobEvent);
		g_hWorkerThreadJobEvent = NULL;
	}

	if (fInittedCriticalSection)
	{
		DNDeleteCriticalSection(&g_csJobQueueLock);
		fInittedCriticalSection = FALSE;
	}

	goto Exit;
} // StartGlobalWorkerThread





#undef DPF_MODNAME
#define DPF_MODNAME "StopGlobalWorkerThread"
//=============================================================================
// StopGlobalWorkerThread
//-----------------------------------------------------------------------------
//
// Description: Stop the global worker thread.  This must balance a successful
//				call to StartGlobalWorkerThread.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void StopGlobalWorkerThread(void)
{
	DPFX(DPFPREP, 5, "Enter");


	DNEnterCriticalSection(&g_csGlobalsLock);


	DNASSERT(g_lWorkerThreadRefCount > 0);
	g_lWorkerThreadRefCount--;
	if (g_lWorkerThreadRefCount == 0)
	{
		//
		// Time to shut down the worker thread.
		//


		//
		// The job queue had better be empty.
		//
		DNASSERT(g_blJobQueue.IsEmpty());

		//
		// Submit a quit job.  Ignore error.
		//
		AddWorkerJob(DP8SIMJOBTYPE_QUIT, NULL, NULL, 0, 0, 0);


		//
		// Wait for the worker thread to close.
		//
		WaitForSingleObject(g_hWorkerThread, INFINITE);


		//
		// The job queue needs to be empty again.
		//
		DNASSERT(g_blJobQueue.IsEmpty());


		//
		// Close the thread handle.
		//
		CloseHandle(g_hWorkerThread);
		g_hWorkerThread = NULL;


		//
		// Close the event handle.
		//
		CloseHandle(g_hWorkerThreadJobEvent);
		g_hWorkerThreadJobEvent = NULL;


		//
		// Delete the critical section.
		//
		DNDeleteCriticalSection(&g_csJobQueueLock);
	}


	DNLeaveCriticalSection(&g_csGlobalsLock);


	DPFX(DPFPREP, 5, "Leave");
} // StopGlobalWorkerThread






#undef DPF_MODNAME
#define DPF_MODNAME "AddWorkerJob"
//=============================================================================
// AddWorkerJob
//-----------------------------------------------------------------------------
//
// Description:    Submits a new job of the given type to performed
//				dwBlockingDelay + dwNonBlockingDelay milliseconds from now.
//
//				   The flags describe how this job is blocked by previously
//				queued jobs, and how it will block subsequently queued jobs.
//
//				   NOTE: There can be only one BLOCKEDBYALLJOBS flagged job in
//				the queue at one time.
//
// Arguments:
//	DP8SIMJOBTYPE JobType		- ID indicating the type of job.
//	PVOID pvContext				- Context for the job.
//	CDP8SimSP * pDP8SimSP		- Pointer to interface submitting job, or NULL
//									for none.
//	DWORD dwBlockingDelay		- Part of how long to wait before performing
//									job, in milliseconds.  Future similar jobs
//									added with fDelayFromPreviousJob set to
//									TRUE before this expires will be blocked.
//	DWORD dwNonBlockingDelay	- Part of how long to wait before performing
//									job, in milliseconds.  This does not
//									affect future similar jobs.
//	DWORD dwFlags				- Flags describing how the job is to be
//									performed (see DP8SIMJOBFLAG_xxx).
//
// Returns: HRESULT
//=============================================================================
HRESULT AddWorkerJob(const DP8SIMJOBTYPE JobType,
					PVOID const pvContext,
					CDP8SimSP * const pDP8SimSP,
					const DWORD dwBlockingDelay,
					const DWORD dwNonBlockingDelay,
					const DWORD dwFlags)
{
	HRESULT					hr = DPN_OK;
	DP8SIMJOB_FPMCONTEXT	JobFPMContext;
	CDP8SimJob *			pDP8SimJob;
	CBilink *				pBilinkOriginalFirstItem;



	DPFX(DPFPREP, 5, "Parameters: (%u, 0x%p, 0x%p, %u, %u, 0x%x)",
		JobType, pvContext, pDP8SimSP, dwBlockingDelay, dwNonBlockingDelay, dwFlags);



	DNASSERT(g_hWorkerThreadJobEvent != NULL);
	DNASSERT(g_hWorkerThread != NULL);


	//
	// Get a job object from the pool, and set the initial delay as appropriate.
	// Keep in mind that we may end up adjusting the time if there's a similar
	// job blocking this one.
	//

	ZeroMemory(&JobFPMContext, sizeof(JobFPMContext));
	if (dwFlags & DP8SIMJOBFLAG_PERFORMBLOCKINGPHASEFIRST)
	{
		JobFPMContext.dwTime		= timeGetTime() + dwBlockingDelay;
		JobFPMContext.dwNextDelay	= dwNonBlockingDelay;
		JobFPMContext.dwFlags		= dwFlags | DP8SIMJOBFLAG_PRIVATE_INBLOCKINGPHASE;
	}
	else
	{
		JobFPMContext.dwTime		= timeGetTime() + dwNonBlockingDelay;
		JobFPMContext.dwNextDelay	= dwBlockingDelay;
		JobFPMContext.dwFlags		= dwFlags;
	}
	JobFPMContext.JobType			= JobType;
	JobFPMContext.pvContext			= pvContext;
	JobFPMContext.pDP8SimSP			= pDP8SimSP;

	pDP8SimJob = (CDP8SimJob*)g_FPOOLJob.Get(&JobFPMContext);
	if (pDP8SimJob == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "Retrieved job 0x%p from pool.", pDP8SimJob);


	//
	// Lock the job queue.
	//
	DNEnterCriticalSection(&g_csJobQueueLock);


	//
	// Remember the current first item.
	//
	pBilinkOriginalFirstItem = g_blJobQueue.GetNext();


	//
	// Insert the item as appropriate.  We'll pass in dwBlockingDelay as the
	// dwBlockedAdditionalDelay in all cases, but it will be ignored if no
	// flags were set or only DP8SIMJOBFLAG_PERFORMBLOCKINGPHASELAST was set
	// because those can never be blocked during this delay period.
	//
	InsertWorkerJobIntoQueue(pDP8SimJob, dwBlockingDelay);


	//
	// If the front of the queue changed, alert the worker thread.
	//
	if (g_blJobQueue.GetNext() != pBilinkOriginalFirstItem)
	{
		DPFX(DPFPREP, 9, "Front of job queue changed, alerting worker thread.");

		//
		// Ignore error, there's nothing we can do about it.
		//
		SetEvent(g_hWorkerThreadJobEvent);
	}
	else
	{
		DPFX(DPFPREP, 9, "Front of job queue did not change.");
	}


	//
	// Unlock the queue.
	//
	DNLeaveCriticalSection(&g_csJobQueueLock);


Exit:


	DPFX(DPFPREP, 5, "Returning: [0x%lx]", hr);

	return hr;


Failure:

	goto Exit;
} // AddWorkerJob





#undef DPF_MODNAME
#define DPF_MODNAME "FlushAllDelayedSendsToEndpoint"
//=============================================================================
// FlushAllDelayedSendsToEndpoint
//-----------------------------------------------------------------------------
//
// Description: Removes all delayed sends intended for the given endpoint that
//				are still queued.  If fDrop is TRUE, the messages are dropped.
//				If fDrop is FALSE, they are all submitted to the real SP.
//
// Arguments:
//	CDP8SimEndpoint * pDP8SimEndpoint	- Endpoint whose sends are to be
//											removed.
//	BOOL fDrop							- Whether to drop the sends or not.
//
// Returns: None.
//=============================================================================
void FlushAllDelayedSendsToEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
									BOOL fDrop)
{
	CBilink			blDelayedSendJobs;
	CBilink *		pBilinkOriginalFirstItem;
	CBilink *		pBilink;
	CDP8SimJob *	pDP8SimJob;
	CDP8SimSend *	pDP8SimSend;
	CDP8SimSP *		pDP8SimSP;


	DPFX(DPFPREP, 5, "Parameters: (0x%p, %i)", pDP8SimEndpoint, fDrop);


	DNASSERT(pDP8SimEndpoint->IsValidObject());


	blDelayedSendJobs.Initialize();


	DNEnterCriticalSection(&g_csJobQueueLock);

	pBilinkOriginalFirstItem = g_blJobQueue.GetNext();
	pBilink = pBilinkOriginalFirstItem;
	while (pBilink != &g_blJobQueue)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());

		pBilink = pBilink->GetNext();

		//
		// See if the job is a delayed send.
		//
		if (pDP8SimJob->GetJobType() == DP8SIMJOBTYPE_DELAYEDSEND)
		{
			pDP8SimSend = (CDP8SimSend*) pDP8SimJob->GetContext();
			DNASSERT(pDP8SimSend->IsValidObject());

			//
			// See if the delayed send is for the right endpoint.
			//
			if (pDP8SimSend->GetEndpoint() == pDP8SimEndpoint)
			{
				//
				// Pull the job out of the queue.
				//
				pDP8SimJob->m_blList.RemoveFromList();


				//
				// Place it on the temporary list.
				//
				pDP8SimJob->m_blList.InsertBefore(&blDelayedSendJobs);
			}
			else
			{
				//
				// Not intended for the given endpoint.
				//
			}
		}
		else
		{
			//
			// Not a delayed send.
			//
		}
	}


	//
	// If the front of the queue changed, alert the worker thread.
	//
	if (g_blJobQueue.GetNext() != pBilinkOriginalFirstItem)
	{
		DPFX(DPFPREP, 9, "Front of job queue changed, alerting worker thread.");
		SetEvent(g_hWorkerThreadJobEvent);
	}
	else
	{
		DPFX(DPFPREP, 9, "Front of job queue did not change.");
	}

	
	DNLeaveCriticalSection(&g_csJobQueueLock);


	//
	// Now actually drop or transmit those messages.
	//
	pBilink = blDelayedSendJobs.GetNext();
	while (pBilink != &blDelayedSendJobs)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());
		pBilink = pBilink->GetNext();


		//
		// Pull the job out of the temporary list.
		//
		pDP8SimJob->m_blList.RemoveFromList();


		pDP8SimSend = (CDP8SimSend*) pDP8SimJob->GetContext();
		pDP8SimSP = pDP8SimJob->GetDP8SimSP();
		DNASSERT(pDP8SimSP != NULL);

		//
		// Either drop the data on the floor or submit it.
		//
		if (fDrop)
		{
			//
			// Increment the stats to take notice of this dropped message.
			//
			pDP8SimSP->IncrementStatsSendDropped(pDP8SimSend->GetMessageSize());


			//
			// Remove the send counter.
			//
			pDP8SimSP->DecSendsPending();

			DPFX(DPFPREP, 7, "Releasing cancelled send 0x%p.", pDP8SimSend);
			pDP8SimSend->Release();
		}
		else
		{
			//
			// Transmit the message.  Note that the 'total delay' statistic
			// will be wrong because we're not waiting the full intended delay.
			// We could be smart and subtract out the time this job was
			// executed ahead of schedule, but we can live with this minor
			// shortcoming.
			//
			pDP8SimSP->PerformDelayedSend(pDP8SimSend);
		}


		//
		// Release the job object.
		//
		DPFX(DPFPREP, 7, "Returning job object 0x%p to pool.", pDP8SimJob);
		g_FPOOLJob.Release(pDP8SimJob);
	}


	DNASSERT(blDelayedSendJobs.IsEmpty());


	DPFX(DPFPREP, 5, "Leave");
} // FlushAllDelayedSendsToEndpoint





#undef DPF_MODNAME
#define DPF_MODNAME "FlushAllDelayedReceivesFromEndpoint"
//=============================================================================
// FlushAllDelayedReceivesFromEndpoint
//-----------------------------------------------------------------------------
//
// Description: Removes all data received from the given endpoint that has not
//				been indicated yet.  If fDrop is TRUE, the messages are
//				dropped. If fDrop is FALSE, they are all indicated to the
//				upper layer.
//
// Arguments:
//	CDP8SimEndpoint * pDP8SimEndpoint	- Endpoint whose receives are to be
//											removed.
//	BOOL fDrop							- Whether to drop the receives or not.
//
// Returns: None.
//=============================================================================
void FlushAllDelayedReceivesFromEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
										BOOL fDrop)
{
	HRESULT				hr;
	CBilink				blDelayedReceiveJobs;
	CBilink *			pBilinkOriginalFirstItem;
	CBilink *			pBilink;
	CDP8SimJob *		pDP8SimJob;
	CDP8SimReceive *	pDP8SimReceive;
	CDP8SimSP *			pDP8SimSP;
	SPIE_DATA *			pData;


	DPFX(DPFPREP, 5, "Parameters: (0x%p, %i)", pDP8SimEndpoint, fDrop);


	DNASSERT(pDP8SimEndpoint->IsValidObject());


	blDelayedReceiveJobs.Initialize();


	DNEnterCriticalSection(&g_csJobQueueLock);

	pBilinkOriginalFirstItem = g_blJobQueue.GetNext();
	pBilink = pBilinkOriginalFirstItem;
	while (pBilink != &g_blJobQueue)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());

		pBilink = pBilink->GetNext();

		//
		// See if the job is a delayed receive.
		//
		if (pDP8SimJob->GetJobType() == DP8SIMJOBTYPE_DELAYEDRECEIVE)
		{
			pDP8SimReceive = (CDP8SimReceive*) pDP8SimJob->GetContext();
			DNASSERT(pDP8SimReceive->IsValidObject());

			//
			// See if the delayed receive is for the right endpoint.
			//
			if (pDP8SimReceive->GetEndpoint() == pDP8SimEndpoint)
			{
				//
				// Pull the job out of the queue.
				//
				pDP8SimJob->m_blList.RemoveFromList();


				//
				// Place it on the temporary list.
				//
				pDP8SimJob->m_blList.InsertBefore(&blDelayedReceiveJobs);
			}
			else
			{
				//
				// Not intended for the given endpoint.
				//
			}
		}
		else
		{
			//
			// Not a delayed receive.
			//
		}
	}


	//
	// If the front of the queue changed, alert the worker thread.
	//
	if (g_blJobQueue.GetNext() != pBilinkOriginalFirstItem)
	{
		DPFX(DPFPREP, 9, "Front of job queue changed, alerting worker thread.");
		SetEvent(g_hWorkerThreadJobEvent);
	}
	else
	{
		DPFX(DPFPREP, 9, "Front of job queue did not change.");
	}

	
	DNLeaveCriticalSection(&g_csJobQueueLock);


	//
	// Now actually drop or transmit those messages.
	//
	pBilink = blDelayedReceiveJobs.GetNext();
	while (pBilink != &blDelayedReceiveJobs)
	{
		pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimJob->IsValidObject());
		pBilink = pBilink->GetNext();


		//
		// Pull the job out of the temporary list.
		//
		pDP8SimJob->m_blList.RemoveFromList();


		pDP8SimReceive = (CDP8SimReceive*) pDP8SimJob->GetContext();
		pDP8SimSP = pDP8SimJob->GetDP8SimSP();
		DNASSERT(pDP8SimSP != NULL);


		//
		// Either drop the data on the floor or submit it.
		//
		if (fDrop)
		{
			pData = pDP8SimReceive->GetReceiveDataBlockPtr();


			//
			// Increment the stats to take notice of this dropped message.
			//
			pDP8SimSP->IncrementStatsReceiveDropped(pData->pReceivedData->BufferDesc.dwBufferSize);


			DPFX(DPFPREP, 8, "Returning receive data 0x%p (wrapper object 0x%p).",
				pData->pReceivedData, pDP8SimSP);


			hr = pDP8SimSP->ReturnReceiveBuffers(pData->pReceivedData);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Failed returning receive buffers 0x%p (err = 0x%lx)!  Ignoring.",
					pData->pReceivedData, hr);

				//
				// Ignore failure.
				//
			}


			//
			// Remove the receive counter.
			//
			pDP8SimSP->DecReceivesPending();

			
			DPFX(DPFPREP, 7, "Releasing cancelled receive 0x%p.", pDP8SimReceive);
			pDP8SimReceive->Release();
		}
		else
		{
			//
			// Indicate the message.  Note that the 'total delay' statistic
			// will be wrong because we're not waiting the full intended delay.
			// We could be smart and subtract out the time this job was
			// executed ahead of schedule, but we can live with this minor
			// shortcoming.
			//
			pDP8SimSP->PerformDelayedReceive(pDP8SimReceive);
		}


		//
		// Release the job object.
		//
		DPFX(DPFPREP, 7, "Returning job object 0x%p to pool.", pDP8SimJob);
		g_FPOOLJob.Release(pDP8SimJob);
	}


	DNASSERT(blDelayedReceiveJobs.IsEmpty());


	DPFX(DPFPREP, 5, "Leave");
} // FlushAllDelayedReceivesFromEndpoint




#undef DPF_MODNAME
#define DPF_MODNAME "InsertWorkerJobIntoQueue"
//=============================================================================
// InsertWorkerJobIntoQueue
//-----------------------------------------------------------------------------
//
// Description:    Inserts the given job into the queue in the appropriate
//				location.
//
//				   If the job is blocked by an existing job (as determined by
//				the jobs' flags), then it is rescheduled for
//				dwBlockedAdditionalDelay milliseconds after the last blocking
//				job.
//
//				   The queue lock is assumed to be held!
//
// Arguments:
//	CDP8SimJob * pDP8SimJob			- ID indicating the type of job.
//	DWORD dwBlockedAdditionalDelay	- Delay to add in case the job was blocked
//										by an existing job, in milliseconds.
//
// Returns: None
//=============================================================================
void InsertWorkerJobIntoQueue(CDP8SimJob * const pDP8SimJob, const DWORD dwBlockedAdditionalDelay)
{
	CBilink *		pBilink;
	CDP8SimJob *	pDP8SimTempJob;


	//
	// See if we need to recalculate the delay because of a previously queued
	// blocking job.
	//
	//if ((pDP8SimJob->IsInBlockingPhase()) || (pDP8SimJob->IsBlockedByAllJobs()))
	if (pDP8SimJob->IsInBlockingPhase())
	{
		//
		// Work backward through the list until we either hit a blocking job
		// or the beginning of the queue.
		//
		pBilink = g_blJobQueue.GetPrev();
		while (pBilink != &g_blJobQueue)
		{
			pDP8SimTempJob = DP8SIMJOB_FROM_BILINK(pBilink);
			DNASSERT(pDP8SimTempJob->IsValidObject());


			/*
			//
			// There can be only one blocked-by-all job in the queue at a time.
			// Otherwise they'd fight to be the last one forever.
			//
			DNASSERT((! pDP8SimJob->IsBlockedByAllJobs()) || (! pDP8SimTempJob->IsBlockedByAllJobs()));


			if (((pDP8SimJob->GetJobType() == pDP8SimTempJob->GetJobType()) &&
				(pDP8SimTempJob->IsInBlockingPhase())) ||
				(pDP8SimJob->IsBlockedByAllJobs()))
			*/
			if ((pDP8SimJob->GetJobType() == pDP8SimTempJob->GetJobType()) &&
				(pDP8SimTempJob->IsInBlockingPhase()))
			{
				//
				// We found a similar job that's in it's blocking delay phase,
				// or we're being blocked by all jobs.
				//

				DPFX(DPFPREP, 9, "Found blocking job 0x%p (job time = %u, type = %u, context 0x%p, interface = 0x%p), using additionaly delay of %u ms.",
					pDP8SimTempJob, pDP8SimTempJob->GetTime(), pDP8SimTempJob->GetJobType(),
					pDP8SimTempJob->GetContext(), pDP8SimTempJob->GetDP8SimSP(),
					dwBlockedAdditionalDelay);


				//
				// Update the new job's time so that the delay is added on top
				// of the previous job.
				//
				pDP8SimJob->SetNewTime(pDP8SimTempJob->GetTime() + dwBlockedAdditionalDelay);


				//
				// Stop searching.
				//
				break;
			}

			pBilink = pBilink->GetPrev();
		}


		//
		// At this point, pBilink is either the root node or the last similar
		// job.  In either case, we will always be inserting at some point in
		// time after that location, so begin the search at the current node
		// plus one.
		//
		pBilink = pBilink->GetNext();
	}
	else
	{
		//
		// Start looking for a spot to insert at the beginning.
		//
		pBilink = g_blJobQueue.GetNext();
	}


	//
	// Find the first job that needs to be fired after this one and insert the
	// new job before it.
	//
	while (pBilink != &g_blJobQueue)
	{
		pDP8SimTempJob = DP8SIMJOB_FROM_BILINK(pBilink);
		DNASSERT(pDP8SimTempJob->IsValidObject());

		if ((int) (pDP8SimJob->GetTime() - pDP8SimTempJob->GetTime()) < 0)
		{
			//
			// Stop looping.
			//
			break;
		}

		pBilink = pBilink->GetNext();
	}


	//
	// If we didn't find a place to insert the job, pBilink will point to the
	// end/beginning of the list.
	//



	DPFX(DPFPREP, 8, "Adding job 0x%p (job time = %u, type = %u, context 0x%p, interface = 0x%p).",
		pDP8SimJob, pDP8SimJob->GetTime(), pDP8SimJob->GetJobType(),
		pDP8SimJob->GetContext(), pDP8SimJob->GetDP8SimSP());

	pDP8SimJob->m_blList.InsertBefore(pBilink);
} // InsertWorkerJobIntoQueue






#undef DPF_MODNAME
#define DPF_MODNAME "DP8SimWorkerThreadProc"
//=============================================================================
// DP8SimWorkerThreadProc
//-----------------------------------------------------------------------------
//
// Description: The global worker thread function.
//
// Arguments:
//	PVOID pvParameter	- Thread parameter.  Ignored.
//
// Returns: 0 if all goes well.
//=============================================================================
DWORD DP8SimWorkerThreadProc(PVOID pvParameter)
{
	DWORD			dwReturn;
	DWORD			dwWaitTimeout = INFINITE;
	BOOL			fRunning = TRUE;
	BOOL			fFoundJob;
	DWORD			dwCurrentTime;
	CBilink *		pBilink;
	CDP8SimJob *	pDP8SimJob;
	CDP8SimSP *		pDP8SimSP;


	DPFX(DPFPREP, 5, "Parameters: (0x%p)", pvParameter);


	//
	// Keep looping until we're told to quit.
	//
	do
	{
		//
		// Wait for the next job.
		//
		dwReturn = WaitForSingleObject(g_hWorkerThreadJobEvent, dwWaitTimeout);
		switch (dwReturn)
		{
			case WAIT_OBJECT_0:
			case WAIT_TIMEOUT:
			{
				//
				// There's a change in the job queue or a timer expired.  See
				// if it's time to execute something.
				//

				//
				// Keep looping while we have jobs to perform now.
				//
				do
				{
					fFoundJob = FALSE;


					//
					// Take the lock while we look at the list.
					//
					DNEnterCriticalSection(&g_csJobQueueLock);


RECHECK:

					pBilink = g_blJobQueue.GetNext();
					if (pBilink != &g_blJobQueue)
					{
						pDP8SimJob = DP8SIMJOB_FROM_BILINK(pBilink);
						DNASSERT(pDP8SimJob->IsValidObject());

						dwCurrentTime = timeGetTime();


						//
						// If the timer has expired, pull the job from the
						// list.
						//
						if ((int) (pDP8SimJob->GetTime() - dwCurrentTime) <= 0)
						{
							pDP8SimJob->m_blList.RemoveFromList();


							//
							// Although the timer may have expired, it's not
							// necessarily time to execute the job.  It may
							// have just switched to/from it's blocking phase.
							// If so, we need to requeue it with the new delay.
							//
							if (pDP8SimJob->HasAnotherPhase())
							{
								DPFX(DPFPREP, 8, "Job 0x%p still has another phase, requeuing with %u ms delay.",
									pDP8SimJob, pDP8SimJob->GetNextDelay());

								pDP8SimJob->ToggleBlockingPhase();

								pDP8SimJob->SetNewTime(dwCurrentTime + pDP8SimJob->GetNextDelay());

								InsertWorkerJobIntoQueue(pDP8SimJob,
														pDP8SimJob->GetNextDelay());


								//
								// Look at the beginning of the queue again.
								//
								goto RECHECK;
							}


							/*
							//
							// Likewise, if this job is blocked by all jobs,
							// and there are still more in the queue, we also
							// need to requeue it.
							//
							if ((pDP8SimJob->IsBlockedByAllJobs()) &&
								(! g_blJobQueue.IsEmpty()))
							if (! g_blJobQueue.IsEmpty())
							{
								DPFX(DPFPREP, 8, "Job 0x%p must wait for all jobs, requeuing.",
									pDP8SimJob);


								pDP8SimJob->SetNewTime(dwCurrentTime);

								InsertWorkerJobIntoQueue(pDP8SimJob, 0);

								//
								// Look at the beginning of the queue again.
								//
								goto RECHECK;
							}
							*/

							
							//
							// It's truly time to execute this job.  Drop the
							// list lock.
							//
							DNLeaveCriticalSection(&g_csJobQueueLock);
							

							pDP8SimSP = pDP8SimJob->GetDP8SimSP();


							DPFX(DPFPREP, 8, "Job 0x%p has expired (job time = %u, current time = %u, type = %u, context 0x%p, interface = 0x%p).",
								pDP8SimJob, pDP8SimJob->GetTime(), dwCurrentTime,
								pDP8SimJob->GetJobType(), pDP8SimJob->GetContext(),
								pDP8SimSP);


							//
							// Figure out what to do with the job.
							//
							switch (pDP8SimJob->GetJobType())
							{
								case DP8SIMJOBTYPE_DELAYEDSEND:
								{
									//
									// Finally submit the send.
									//
									DNASSERT(pDP8SimSP != NULL);
									pDP8SimSP->PerformDelayedSend(pDP8SimJob->GetContext());
									break;
								}

								case DP8SIMJOBTYPE_DELAYEDRECEIVE:
								{
									//
									// Finally indicate the receive.
									//
									DNASSERT(pDP8SimSP != NULL);
									pDP8SimSP->PerformDelayedReceive(pDP8SimJob->GetContext());
									break;
								}

								case DP8SIMJOBTYPE_QUIT:
								{
									//
									// Stop looping.
									//
									DNASSERT(pDP8SimSP == NULL);
									DPFX(DPFPREP, 2, "Quit job received.");
									fRunning = FALSE;
									break;
								}

								default:
								{
									DPFX(DPFPREP, 0, "Unexpected job type %u!",
										pDP8SimJob->GetJobType());
									DNASSERT(FALSE); 
									fRunning = FALSE;
									break;
								}
							}


							//
							// Release the job object.
							//
							DPFX(DPFPREP, 7, "Returning job object 0x%p to pool.", pDP8SimJob);
							g_FPOOLJob.Release(pDP8SimJob);


							//
							// Check out the next job (unless we're bailing).
							//
							fFoundJob = fRunning;
						}
						else
						{
							//
							// Not time for job yet.  Figure out when it will
							// be.
							//
							dwWaitTimeout = pDP8SimJob->GetTime() - dwCurrentTime;


							//
							// Drop the list lock.
							//
							DNLeaveCriticalSection(&g_csJobQueueLock);


							DPFX(DPFPREP, 8, "Next job in %u ms.", dwWaitTimeout);
						}
					}
					else
					{
						//
						// Nothing in the job queue.  Drop the list lock.
						//
						DNLeaveCriticalSection(&g_csJobQueueLock);

						//
						// Wait until something gets put into the queue.
						//
						dwWaitTimeout = INFINITE;


						DPFX(DPFPREP, 8, "No more jobs.");
					}
				}
				while (fFoundJob);


				//
				// Go back to waiting.
				//
				break;
			}

			default:
			{
				//
				// Something unusual happened.
				//
				DPFX(DPFPREP, 0, "Got unexpected return value from WaitForSingleObject (%u)!");
				DNASSERT(FALSE);
				fRunning = FALSE;
				break;
			}
		}
	}
	while (fRunning);



	DPFX(DPFPREP, 5, "Returning: [%u]", dwReturn);


	return dwReturn;
} // DP8SimWorkerThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\spwrapper.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		spwrapper.cpp
 *
 *  Content:	DP8SIM main SP interface wrapper object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"




//=============================================================================
// Dynamically loaded function prototypes
//=============================================================================
typedef HRESULT (WINAPI * PFN_DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID *);


 



#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::CDP8SimSP"
//=============================================================================
// CDP8SimSP constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimSP object.
//
// Arguments:
//	GUID * pguidFakeSP	- Pointer to guid of fake SP.
//	GUID * pguidRealSP	- Pointer to guid of real SP being wrapped.
//
// Returns: None (the object).
//=============================================================================
CDP8SimSP::CDP8SimSP(const GUID * const pguidFakeSP, const GUID * const pguidRealSP)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'S';
	this->m_Sig[1]	= 'P';
	this->m_Sig[2]	= 'W';
	this->m_Sig[3]	= 'P';

	this->m_lRefCount					= 1; // someone must have a pointer to this object
	this->m_dwFlags						= 0;
	CopyMemory(&this->m_guidFakeSP, pguidFakeSP, sizeof(GUID));
	CopyMemory(&this->m_guidRealSP, pguidRealSP, sizeof(GUID));
	this->m_pDP8SimCB					= NULL;
	this->m_pDP8SP						= NULL;
	this->m_dwSendsPending				= 0;
	this->m_hLastPendingSendEvent		= NULL;
	this->m_dwReceivesPending			= 0;
	//this->m_hLastPendingReceiveEvent	= NULL;
} // CDP8SimSP::CDP8SimSP






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::~CDP8SimSP"
//=============================================================================
// CDP8SimSP destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimSP object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimSP::~CDP8SimSP(void)
{
	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT(this->m_dwFlags == 0);
	DNASSERT(this->m_pDP8SimCB == NULL);
	DNASSERT(this->m_pDP8SP == NULL);
	DNASSERT(this->m_dwSendsPending == 0);
	DNASSERT(this->m_hLastPendingSendEvent == NULL);
	DNASSERT(this->m_dwReceivesPending == 0);
	//DNASSERT(this->m_hLastPendingReceiveEvent == NULL);

	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'p';
} // CDP8SimSP::~CDP8SimSP




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::QueryInterface"
//=============================================================================
// CDP8SimSP::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CDP8SimSP object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CDP8SimSP::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPN_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim object!");
		hr = DPNERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8ServiceProvider)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CDP8SimSP inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::AddRef"
//=============================================================================
// CDP8SimSP::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CDP8SimSP object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimSP::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CDP8SimSP::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Release"
//=============================================================================
// CDP8SimSP::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CDP8SimSP object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimSP::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DP8SimSP object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close();
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CDP8SimSP::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Initialize"
//=============================================================================
// CDP8SimSP::Initialize
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPINITIALIZEDATA pspid		- Pointer to parameter block to use when
//									initializing.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Initialize(PSPINITIALIZEDATA pspid)
{
	HRESULT				hr;
	BOOL				fHaveLock = FALSE;
	BOOL				fInitializedIPCObject = FALSE;
	SPINITIALIZEDATA	spidModified;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspid);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspid != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags == 0);


	//
	// Connect the shared memory.
	//
	hr = this->m_DP8SimIPC.Initialize();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize IPC object!");
		goto Failure;
	}

	fInitializedIPCObject = TRUE;


	//
	// Create a wrapper for the callback interface.
	//
	this->m_pDP8SimCB = new CDP8SimCB(this, pspid->pIDP);
	if (this->m_pDP8SimCB == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	//
	// Initialize the callback interface wrapper object.
	//
	hr = this->m_pDP8SimCB->InitializeObject();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize callback interface wrapper object!");

		delete this->m_pDP8SimCB;
		this->m_pDP8SimCB = NULL;

		goto Failure;
	}


	//
	// Instantiate the real SP.
	//
	hr = CoCreateInstance(this->m_guidRealSP,
						NULL,
						CLSCTX_INPROC_SERVER,
						IID_IDP8ServiceProvider,
						(PVOID*) (&this->m_pDP8SP));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't instantiate real SP object (pointer = 0x%p)!",
			this->m_pDP8SP);
		goto Failure;
	}


	DPFX(DPFPREP, 1, "Object 0x%p wrapping real SP 0x%p, inserting callback interface 0x%p before 0x%p.",
		this, this->m_pDP8SP, this->m_pDP8SimCB, pspid->pIDP);



	//
	// Initialize the real SP.
	//

	ZeroMemory(&spidModified, sizeof(spidModified));
	spidModified.pIDP		= this->m_pDP8SimCB;
	spidModified.dwFlags	= pspid->dwFlags;

	hr = this->m_pDP8SP->Initialize(&spidModified);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed initializing real SP object (0x%p)!",
			this->m_pDP8SP);
		goto Failure;
	}


	//
	// We're now initialized.
	//
	this->m_dwFlags |= DP8SIMSPOBJ_INITIALIZED;



Exit:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (this->m_pDP8SP != NULL)
	{
		this->m_pDP8SP->Release();
		this->m_pDP8SP = NULL;
	}

	if (this->m_pDP8SimCB != NULL)
	{
		this->m_pDP8SimCB->Release();
		this->m_pDP8SimCB = NULL;
	}

	if (fInitializedIPCObject)
	{
		this->m_DP8SimIPC.Close();
		fInitializedIPCObject = FALSE;
	}

	goto Exit;
} // CDP8SimSP::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Close"
//=============================================================================
// CDP8SimSP::Close
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Close(void)
{
	HRESULT		hr;
	//BOOL		fHaveLock = FALSE;
	BOOL		fWait = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Enter", this);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	DNEnterCriticalSection(&this->m_csLock);
	//fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);


	//
	// Figure out if we need to wait for all sends to complete.
	//
	if (this->m_dwSendsPending > 0)
	{
		DNASSERT(this->m_hLastPendingSendEvent == NULL);

		this->m_hLastPendingSendEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (this->m_hLastPendingSendEvent == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't create last send pending event (err = %u)!", hr);
		}
		else
		{
			fWait = TRUE;
		}
	}

	this->m_dwFlags |= DP8SIMSPOBJ_CLOSING;

	//
	// Drop the lock, nobody should be touching this object now.
	//
	DNLeaveCriticalSection(&this->m_csLock);
	//fHaveLock = FALSE;


	if (fWait)
	{
		DPFX(DPFPREP, 1, "Waiting for ~%u pending sends to complete.",
			this->m_dwSendsPending);


		//
		// Wait for all the sends to complete.  Nobody should touch
		// m_hLastPendingSendEvent except the thread triggering it, so
		// referring to it without the lock should be safe.
		// Ignore any errors.
		//
		WaitForSingleObject(this->m_hLastPendingSendEvent, INFINITE);


		//
		// Take the lock while removing the handle, to be paranoid.
		//
		DNEnterCriticalSection(&this->m_csLock);

		//
		// Remove the handle.
		//
		CloseHandle(this->m_hLastPendingSendEvent);
		this->m_hLastPendingSendEvent = NULL;


		//
		// Drop the lock again.
		//
		DNLeaveCriticalSection(&this->m_csLock);
	}


	//
	// Shutdown the global worker thread if we launched it.
	//
	if (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD)
	{
		StopGlobalWorkerThread();

		this->m_dwFlags &= ~DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}


	//
	// Close the real SP.
	//
	hr = this->m_pDP8SP->Close();
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed closing real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


	//
	// Release the real SP object.
	//
	this->m_pDP8SP->Release();
	this->m_pDP8SP = NULL;


	//
	// Release the callback interceptor object.
	//
	this->m_pDP8SimCB->Release();
	this->m_pDP8SimCB = NULL;


	//
	// Disconnect the shared memory.
	//
	this->m_DP8SimIPC.Close();


	//
	// Turn off the initialized and closing flags.
	//
	this->m_dwFlags &= ~(DP8SIMSPOBJ_INITIALIZED | DP8SIMSPOBJ_CLOSING);
	DNASSERT(this->m_dwFlags == 0);


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


/*
Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
*/
} // CDP8SimSP::Close




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Connect"
//=============================================================================
// CDP8SimSP::Connect
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPCONNECTDATA pspcd	- Pointer to parameter block to use when
//								connecting.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Connect(PSPCONNECTDATA pspcd)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	SPCONNECTDATA				spcdModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspcd);


	ZeroMemory(&spcdModified, sizeof(spcdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspcd != NULL);
	DNASSERT(pspcd->pAddressHost != NULL);
	DNASSERT(pspcd->pAddressDeviceInfo != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;

	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	//
	// Fire up the global worker thread, if it hasn't been already.
	//
	if (! (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD))
	{
		hr = StartGlobalWorkerThread();
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed starting global worker thread!");
			goto Failure;
		}

		this->m_dwFlags |= DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}

	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;

	
	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_CONNECT;
	CommandFPMContext.pvUserContext		= pspcd->pvContext;

	pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspcd->pAddressHost->Duplicate(&spcdModified.pAddressHost);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate host address!");
		goto Failure;
	}
	*/
	spcdModified.pAddressHost			= pspcd->pAddressHost;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spcdModified.pAddressHost->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change host address' SP!");
		goto Failure;
	}


	/*
	//
	// Duplicate the host address.
	//
	hr = pspcd->pAddressDeviceInfo->Duplicate(&spcdModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}
	*/
	spcdModified.pAddressDeviceInfo		= pspcd->pAddressDeviceInfo;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spcdModified.pAddressDeviceInfo->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}


	//
	// Add a reference for the connect command.
	//
	pDP8SimCommand->AddRef();

	DNASSERT(pspcd->dwReserved == 0);
	//spcdModified.dwReserved				= pspcd->dwReserved;
	spcdModified.dwFlags				= pspcd->dwFlags;
	spcdModified.pvContext				= pDP8SimCommand;
	//spcdModified.hCommand				= pspcd->hCommand;				// filled in by real SP
	//spcdModified.dwCommandDescriptor	= pspcd->dwCommandDescriptor;	// filled in by real SP



	//
	// Start connecting with the real service provider.
	//
	hr = this->m_pDP8SP->Connect(&spcdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed starting to connect with real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
#pragma BUGBUG(vanceo, "Handle DPN_OK and investigate command completing before this function returns")
	DNASSERT(spcdModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(spcdModified.hCommand,
									spcdModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	pspcd->hCommand				= (HANDLE) pDP8SimCommand;
	pspcd->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	/*
	if (spcdModified.pAddressDeviceInfo != NULL)
	{
		spcdModified.pAddressDeviceInfo->Release();
		spcdModified.pAddressDeviceInfo = NULL;
	}

	if (spcdModified.pAddressHost != NULL)
	{
		spcdModified.pAddressHost->Release();
		spcdModified.pAddressHost = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::Connect





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Disconnect"
//=============================================================================
// CDP8SimSP::Disconnect
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPDISCONNECTDATA pspdd	- Pointer to parameter block to use when
//								disconnecting.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Disconnect(PSPDISCONNECTDATA pspdd)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	CDP8SimEndpoint *			pDP8SimEndpoint;
	SPDISCONNECTDATA			spddModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspdd);


	ZeroMemory(&spddModified, sizeof(spddModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspdd != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;

	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;


	pDP8SimEndpoint = (CDP8SimEndpoint*) pspdd->hEndpoint;
	DNASSERT(pDP8SimEndpoint->IsValidObject());

	//
	// Mark the endpoint as disconnecting to prevent additional sends/receives.
	//
	pDP8SimEndpoint->Lock();
	pDP8SimEndpoint->NoteDisconnecting();
	pDP8SimEndpoint->Unlock();


	//
	// Flush any delayed sends that were already going to this endpoint to make
	// sure they hit the wire.
	//
	FlushAllDelayedSendsToEndpoint(pDP8SimEndpoint, FALSE);


	//
	// Drop any delayed receives from this endpoint, the upper layer doesn't
	// want to receive anything else after disconnecting.
	//
	FlushAllDelayedReceivesFromEndpoint(pDP8SimEndpoint, TRUE);


	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_DISCONNECT;
	CommandFPMContext.pvUserContext		= pspdd->pvContext;

	pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Add a reference for the disconnect command.
	//
	pDP8SimCommand->AddRef();


	//
	// Copy the parameter block, modifying as necessary.
	//
	spddModified.hEndpoint				= pDP8SimEndpoint->GetRealSPEndpoint();
	spddModified.dwFlags				= pspdd->dwFlags;
	spddModified.pvContext				= pDP8SimCommand;
	//spddModified.hCommand				= pspdd->hCommand;				// filled in by real SP
	//spddModified.dwCommandDescriptor	= pspdd->dwCommandDescriptor;	// filled in by real SP



	//
	// Tell the real service provider to disconnect.
	//
	hr = this->m_pDP8SP->Disconnect(&spddModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed having real SP object (0x%p) disconnect!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	if (hr == DPNSUCCESS_PENDING)
	{
		DNASSERT(spddModified.hCommand != NULL);


		//
		// Save the output parameters.
		//
		pDP8SimCommand->SetRealSPCommand(spddModified.hCommand,
										spddModified.dwCommandDescriptor);


		//
		// Generate the output parameters for the caller.
		//
		pspdd->hCommand				= (HANDLE) pDP8SimCommand;
		pspdd->dwCommandDescriptor	= 0;
	}
	else
	{
		DNASSERT(spddModified.hCommand == NULL);

		DPFX(DPFPREP, 7, "Releasing completed command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();
	}


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::Disconnect





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Listen"
//=============================================================================
// CDP8SimSP::Listen
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPLISTENDATA pspld		- Pointer to parameter block to use when listening.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Listen(PSPLISTENDATA pspld)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	SPLISTENDATA				spldModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspld);


	ZeroMemory(&spldModified, sizeof(spldModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspld != NULL);
	DNASSERT(pspld->pAddressDeviceInfo != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	//
	// Fire up the global worker thread, if it hasn't been already.
	//
	if (! (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD))
	{
		hr = StartGlobalWorkerThread();
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed starting global worker thread!");
			goto Failure;
		}

		this->m_dwFlags |= DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}

	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_LISTEN;
	CommandFPMContext.pvUserContext		= pspld->pvContext;

	pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspld->pAddressDeviceInfo->Duplicate(&spldModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}
	*/
	spldModified.pAddressDeviceInfo		= pspld->pAddressDeviceInfo;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spldModified.pAddressDeviceInfo->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}


	//
	// Add a reference for the listen command.
	//
	pDP8SimCommand->AddRef();


	spldModified.dwFlags				= pspld->dwFlags;
	spldModified.pvContext				= pDP8SimCommand;
	//spldModified.hCommand				= pspld->hCommand;				// filled in by real SP
	//spldModified.dwCommandDescriptor	= pspld->dwCommandDescriptor;	// filled in by real SP



	//
	// Start listening with the real service provider.
	//
	hr = this->m_pDP8SP->Listen(&spldModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed to start listening with the real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	DNASSERT(spldModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(spldModified.hCommand,
									spldModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	pspld->hCommand				= (HANDLE) pDP8SimCommand;
	pspld->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	/*
	if (spldModified.pAddressDeviceInfo != NULL)
	{
		spldModified.pAddressDeviceInfo->Release();
		spldModified.pAddressDeviceInfo = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::Listen





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::SendData"
//=============================================================================
// CDP8SimSP::SendData
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPSENDDATA pspsd	- Pointer to parameter block to use when sending.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::SendData(PSPSENDDATA pspsd)
{
	HRESULT						hr;
	DP8SIM_PARAMETERS			dp8sp;
	CDP8SimEndpoint *			pDP8SimEndpoint;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;
	SPSENDDATA					spsdModified;
	CDP8SimSend *				pDP8SimSend = NULL;
	IDP8SPCallback *			pDP8SPCB;
	DWORD						dwMsgSize;
	DWORD						dwTemp;
	DWORD						dwBandwidthDelay;
	DWORD						dwLatencyDelay;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspsd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspsd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Determine the total size of the message.
	//
	dwMsgSize = 0;
	for(dwTemp = 0; dwTemp < pspsd->dwBufferCount; dwTemp++)
	{
		DNASSERT((pspsd->pBuffers[dwTemp].pBufferData != NULL) && (pspsd->pBuffers[dwTemp].dwBufferSize > 0));
		dwMsgSize += pspsd->pBuffers[dwTemp].dwBufferSize;
	}


	//
	// Get the current send settings.
	//
	ZeroMemory(&dp8sp, sizeof(dp8sp));
	dp8sp.dwSize = sizeof(dp8sp);
	this->m_DP8SimIPC.GetAllSendParameters(&dp8sp);


	//
	// Determine if we need to drop this send.
	//
	if (this->ShouldDrop(dp8sp.fPacketLossPercent))
	{
		//
		// Update the statistics.
		//
		this->IncrementStatsSendDropped(dwMsgSize);


		//
		// Indicate send completion (with a bogus handle) immediately.
		//

		pDP8SPCB = this->m_pDP8SimCB->GetRealCallbackInterface();

		DPFX(DPFPREP, 2, "Indicating successful send completion (dropped, context = 0x%p) to interface 0x%p.",
			pspsd->pvContext, pDP8SPCB);

		hr = pDP8SPCB->CommandComplete(NULL, DPN_OK, pspsd->pvContext);

		DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


		//
		// Ignore any error and return DPNSUCCESS_PENDING, even though we've
		// completed the send already.
		//
		hr = DPNSUCCESS_PENDING;


		//
		// Return bogus output parameters for the caller, it's already complete
		// from their perspective.
		//
		pspsd->hCommand				= NULL;
		pspsd->dwCommandDescriptor	= 0;


		//
		// We're done here.
		//
		goto Exit;
	}


	//
	// Figure out how much latency needs to be added based on the bandwidth
	// and random latency settings.
	//
	// If we're not supposed to delay the sends, fire it off right away.
	// Otherwise submit a timed job to be performed later.
	//
	if (! this->GetDelay(dp8sp.dwBandwidthBPS,
						dp8sp.dwPacketHeaderSize,
						dwMsgSize,
						dp8sp.dwMinLatencyMS,
						dp8sp.dwMaxLatencyMS,
						&dwBandwidthDelay,
						&dwLatencyDelay))
	{
		pDP8SimEndpoint = (CDP8SimEndpoint*) pspsd->hEndpoint;
		DNASSERT(pDP8SimEndpoint->IsValidObject());


		//
		// If the endpoint is disconnecting, don't try to send.
		//
		pDP8SimEndpoint->Lock();
		if (pDP8SimEndpoint->IsDisconnecting())
		{
			pDP8SimEndpoint->Unlock();

			DPFX(DPFPREP, 0, "Endpoint 0x%p is disconnecting, can't send!",
				pDP8SimEndpoint);

			hr = DPNERR_NOCONNECTION;
			goto Failure;
		}
		pDP8SimEndpoint->Unlock();



		DPFX(DPFPREP, 6, "Sending %u bytes of data immmediately.", dwMsgSize);


		//
		// Prepare a command object.
		//

		ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
		CommandFPMContext.dwType			= CMDTYPE_SENDDATA_IMMEDIATE;
		CommandFPMContext.pvUserContext		= pspsd->pvContext;

		pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
		if (pDP8SimCommand == NULL)
		{
			hr = DPNERR_OUTOFMEMORY;
			goto Failure;
		}


		DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);


		//
		// Save the message's size for incrementing stats at send completion.
		//
		pDP8SimCommand->SetMessageSize(dwMsgSize);


		//
		// Copy the parameter block, modifying as necessary.
		//
		ZeroMemory(&spsdModified, sizeof(spsdModified));
		spsdModified.hEndpoint				= pDP8SimEndpoint->GetRealSPEndpoint();
		spsdModified.pBuffers				= pspsd->pBuffers;
		spsdModified.dwBufferCount			= pspsd->dwBufferCount;
		spsdModified.dwFlags				= pspsd->dwFlags;
		spsdModified.pvContext				= pDP8SimCommand;
		//spsdModified.hCommand				= NULL;	// filled in by real SP
		//spsdModified.dwCommandDescriptor	= 0;	// filled in by real SP


		//
		// Add a reference for the send command.
		//
		pDP8SimCommand->AddRef();


		//
		// Increase the pending sends counter.
		//
		this->IncSendsPending();

		

		//
		// Issue the send to the real SP.
		//
		hr = this->m_pDP8SP->SendData(&spsdModified);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Failed sending immediate data (err = 0x%lx)!", hr);


			//
			// Remove the send counter.
			//
			this->DecSendsPending();


			DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
			pDP8SimCommand->Release();


			//
			// Continue.
			//
		}
		else
		{
			if (hr != DPNSUCCESS_PENDING)
			{
				//
				// The command completed right away.
				//
				DNASSERT(hr == DPN_OK);

				hr = this->m_pDP8SimCB->CommandComplete(spsdModified.hCommand,
														hr,
														pDP8SimCommand);
				DNASSERT(hr == DPN_OK);

				//
				// Be sure to still return pending for the caller even though
				// we just completed it to him.
				//
				hr = DPNSUCCESS_PENDING;
			}
			else
			{
				//
				// Save the output parameters returned by the SP.
				//
				pDP8SimCommand->SetRealSPCommand(spsdModified.hCommand,
												spsdModified.dwCommandDescriptor);
			}
		}


		//
		// Give up local reference.
		//
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;


		//
		// We're done here.
		//
		goto Exit;
	}


	//
	// If we're here, we must be delaying the send.
	//
	
	DPFX(DPFPREP, 6, "Delaying %u byte send for %u + %u ms.",
		dwMsgSize, dwBandwidthDelay, dwLatencyDelay);


	//
	// Get a send object, duplicating the send data given to us by our caller
	// for submission some time in the future.
	//
	pDP8SimSend = (CDP8SimSend*)g_FPOOLSend.Get(pspsd);
	if (pDP8SimSend == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New send 0x%p.", pDP8SimSend);


	//
	// Store the latency that is about be added to this send.
	//
	pDP8SimSend->SetLatencyAdded(dwBandwidthDelay + dwLatencyDelay);


	//
	// Transfer local pDP8SimSend reference to the job queue.
	//


	//
	// Increment the send counter.
	//
	this->IncSendsPending();


	//
	// Queue it to be sent at a later time, depending on the latency value
	// requested.  If there's a bandwidth restriction, enforce the sending
	// order as well so that earlier sends that are still ongoing hold up later
	// ones.
	//
	hr = AddWorkerJob(DP8SIMJOBTYPE_DELAYEDSEND,
					pDP8SimSend,
					this,
					dwBandwidthDelay,
					dwLatencyDelay,
					DP8SIMJOBFLAG_PERFORMBLOCKINGPHASEFIRST);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't add delayed send worker job (0x%p)!", 
			pDP8SimSend);


		//
		// Remove the send counter.
		//
		this->DecSendsPending();


		goto Failure;
	}


	//
	// Indicate send completion (with a bogus handle) immediately.
	//

	pDP8SPCB = this->m_pDP8SimCB->GetRealCallbackInterface();

	DPFX(DPFPREP, 2, "Indicating successful send completion (delayed, context = 0x%p) to interface 0x%p.",
		pspsd->pvContext, pDP8SPCB);

	hr = pDP8SPCB->CommandComplete(NULL, DPN_OK, pspsd->pvContext);

	DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


	//
	// Ignore any error and return DPNSUCCESS_PENDING, even though we've
	// completed the send already.
	//
	hr = DPNSUCCESS_PENDING;


	//
	// Return bogus output parameters for the caller, it's already complete
	// from their perspective.
	//
	pspsd->hCommand				= NULL;
	pspsd->dwCommandDescriptor	= 0;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pDP8SimSend != NULL)
	{
		pDP8SimSend->Release();
		pDP8SimSend = NULL;
	}

	goto Exit;
} // CDP8SimSP::SendData





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumQuery"
//=============================================================================
// CDP8SimSP::EnumQuery
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMQUERYDATA pspeqd		- Pointer to parameter block to use when
//									enumerating.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumQuery(PSPENUMQUERYDATA pspeqd)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	SPENUMQUERYDATA				speqdModified;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspeqd);


	ZeroMemory(&speqdModified, sizeof(speqdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspeqd != NULL);
	DNASSERT(pspeqd->pAddressHost != NULL);
	DNASSERT(pspeqd->pAddressDeviceInfo != NULL);


	DNEnterCriticalSection(&this->m_csLock);
	fHaveLock = TRUE;


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	//
	// Fire up the global worker thread, if it hasn't been already.
	//
	if (! (this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD))
	{
		hr = StartGlobalWorkerThread();
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed starting global worker thread!");
			goto Failure;
		}

		this->m_dwFlags |= DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD;
	}

	DNLeaveCriticalSection(&this->m_csLock);
	fHaveLock = FALSE;



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_ENUMQUERY;
	CommandFPMContext.pvUserContext		= pspeqd->pvContext;

	pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspeqd->pAddressHost->Duplicate(&speqdModified.pAddressHost);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate host address!");
		goto Failure;
	}
	*/
	speqdModified.pAddressHost			= pspeqd->pAddressHost;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = speqdModified.pAddressHost->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change host address' SP!");
		goto Failure;
	}

	
	/*
	//
	// Duplicate the host address.
	//
	hr = pspeqd->pAddressDeviceInfo->Duplicate(&speqdModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}
	*/
	speqdModified.pAddressDeviceInfo	= pspeqd->pAddressDeviceInfo;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = speqdModified.pAddressDeviceInfo->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}


	//
	// Add a reference for the enum query command.
	//
	pDP8SimCommand->AddRef();


	speqdModified.pBuffers				= pspeqd->pBuffers;
	speqdModified.dwBufferCount			= pspeqd->dwBufferCount;
	speqdModified.dwTimeout				= pspeqd->dwTimeout;
	speqdModified.dwRetryCount			= pspeqd->dwRetryCount;
	speqdModified.dwRetryInterval		= pspeqd->dwRetryInterval;
	speqdModified.dwFlags				= pspeqd->dwFlags;
	speqdModified.pvContext				= pDP8SimCommand;
	//speqdModified.hCommand				= pspeqd->hCommand;				// filled in by real SP
	//speqdModified.dwCommandDescriptor	= pspeqd->dwCommandDescriptor;	// filled in by real SP


	//
	// Start the enumeration via the real service provider.
	//
	hr = this->m_pDP8SP->EnumQuery(&speqdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed starting the enumeration via the real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	DNASSERT(speqdModified.hCommand != NULL);


	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(speqdModified.hCommand,
									speqdModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	pspeqd->hCommand			= (HANDLE) pDP8SimCommand;
	pspeqd->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	/*
	if (speqdModified.pAddressDeviceInfo != NULL)
	{
		speqdModified.pAddressDeviceInfo->Release();
		speqdModified.pAddressDeviceInfo = NULL;
	}

	if (speqdModified.pAddressHost != NULL)
	{
		speqdModified.pAddressHost->Release();
		speqdModified.pAddressHost = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		DNLeaveCriticalSection(&this->m_csLock);
	}

	goto Exit;
} // CDP8SimSP::EnumQuery





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumRespond"
//=============================================================================
// CDP8SimSP::EnumRespond
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMRESPONDDATA psperd	- Pointer to parameter block to use when
//									responding.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumRespond(PSPENUMRESPONDDATA psperd)
{
	HRESULT						hr;
	SPENUMRESPONDDATA			sperdModified;
	ENUMQUERYDATAWRAPPER *		pEnumQueryDataWrapper;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psperd);


	ZeroMemory(&sperdModified, sizeof(sperdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psperd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_ENUMRESPOND;
	CommandFPMContext.pvUserContext		= psperd->pvContext;

	pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		hr = DPNERR_OUTOFMEMORY;
		goto Failure;
	}

	DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);



	//
	// Copy the parameter block, modifying as necessary.
	//

	//
	// We wrapped the enum query data structure, get the original object.
	//
	pEnumQueryDataWrapper = ENUMQUERYEVENTWRAPPER_FROM_SPIEQUERY(psperd->pQuery);

	DNASSERT(*((DWORD*) (&pEnumQueryDataWrapper->m_Sig)) == 0x57455145);	// 0x57 0x45 0x51 0x45 = 'WEQE' = 'EQEW' in Intel order

	sperdModified.pQuery = pEnumQueryDataWrapper->pOriginalQuery;


	//
	// Add a reference for the enum respond command.
	//
	pDP8SimCommand->AddRef();


	sperdModified.pBuffers				= psperd->pBuffers;
	sperdModified.dwBufferCount			= psperd->dwBufferCount;
	sperdModified.dwFlags				= psperd->dwFlags;
	sperdModified.pvContext				= pDP8SimCommand;
	//sperdModified.hCommand				= psperd->hCommand;				// filled in by real SP
	//sperdModified.dwCommandDescriptor	= psperd->dwCommandDescriptor;	// filled in by real SP


	//
	// Respond to the enumeration via the real service provider.
	//
	hr = this->m_pDP8SP->EnumRespond(&sperdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed responding to enumeration via the real SP object (0x%p)!",
			this->m_pDP8SP);


		DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
		pDP8SimCommand->Release();

		goto Failure;
	}

	
	//
	// Save the output parameters.
	//
	pDP8SimCommand->SetRealSPCommand(sperdModified.hCommand,
									sperdModified.dwCommandDescriptor);


	//
	// Generate the output parameters for the caller.
	//
	psperd->hCommand			= (HANDLE) pDP8SimCommand;
	psperd->dwCommandDescriptor	= 0;


Exit:

	//
	// Give up local reference.
	//
	if (pDP8SimCommand != NULL)
	{
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::EnumRespond





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::CancelCommand"
//=============================================================================
// CDP8SimSP::CancelCommand
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	HANDLE hCommand				- Handle to command to cancel.
//	DWORD dwCommandDescriptor	- Unique descriptor of command to cancel.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::CancelCommand(HANDLE hCommand, DWORD dwCommandDescriptor)
{
	HRESULT				hr;
	CDP8SimCommand *	pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u)",
		this, hCommand, dwCommandDescriptor);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(hCommand != NULL);
	DNASSERT(dwCommandDescriptor == 0);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	pDP8SimCommand = (CDP8SimCommand*) hCommand;
	DNASSERT(pDP8SimCommand->IsValidObject());


	//
	// Cancel the real service provider's command.
	//
	hr = this->m_pDP8SP->CancelCommand(pDP8SimCommand->GetRealSPCommand(),
										pDP8SimCommand->GetRealSPCommandDescriptor());
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed cancelling real SP object (0x%p)'s command!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::CancelCommand





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumMulticastScopes"
//=============================================================================
// CDP8SimSP::EnumMulticastScopes
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMMULTICASTSCOPESDATA pspemsd	- Pointer to parameter block to use
//											when enumerating scopes.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumMulticastScopes(PSPENUMMULTICASTSCOPESDATA pspemsd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspemsd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspemsd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Have the real service provider enumerate multicast scopes.
	//
	hr = this->m_pDP8SP->EnumMulticastScopes(pspemsd);
	if (hr != DPN_OK)
	{
		if (hr != DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 0, "Failed enumerating multicast scopes on real SP object (0x%p)!",
				this->m_pDP8SP);
		}

		//
		// Continue...
		//
	}



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::EnumMulticastScopes




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::ShareEndpointInfo"
//=============================================================================
// CDP8SimSP::ShareEndpointInfo
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPSHAREENDPOINTINFODATA pspseid	- Pointer to parameter block.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::ShareEndpointInfo(PSPSHAREENDPOINTINFODATA pspseid)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspseid);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspseid != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Have the real service provider share the endpoint info.
	//
	hr = this->m_pDP8SP->ShareEndpointInfo(pspseid);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed sharing endpoint info on real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::ShareEndpointInfo





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetEndpointByAddress"
//=============================================================================
// CDP8SimSP::GetEndpointByAddress
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPGETENDPOINTBYADDRESSDATA pspgebad	- Pointer to parameter block.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::GetEndpointByAddress(PSPGETENDPOINTBYADDRESSDATA pspgebad)
{
	HRESULT						hr;
#ifndef DPNBUILD_NOMULTICAST
	SPGETENDPOINTBYADDRESSDATA	spgebadModified;


	ZeroMemory(&spgebadModified, sizeof(spgebadModified));
#endif // ! DPNBUILD_NOMULTICAST


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspgebad);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspgebad != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


#ifdef DPNBUILD_NOMULTICAST
	hr = DPNERR_UNSUPPORTED;
	goto Failure;
#else // ! DPNBUILD_NOMULTICAST
	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = pspgebad->pAddressHost->Duplicate(&spgebadModified.pAddressHost);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate host address!");
		goto Failure;
	}
	*/
	spgebadModified.pAddressHost			= pspgebad->pAddressHost;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spgebadModified.pAddressHost->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change host address' SP!");
		goto Failure;
	}


	/*
	//
	// Duplicate the host address.
	//
	hr = pspgebad->pAddressDeviceInfo->Duplicate(&spgebadModified.pAddressDeviceInfo);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate device info address!");
		goto Failure;
	}
	*/
	spgebadModified.pAddressDeviceInfo		= pspgebad->pAddressDeviceInfo;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = spgebadModified.pAddressDeviceInfo->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change device info address' SP!");
		goto Failure;
	}


	//
	// Retrieve the real service provider's endpoint.
	//
	hr = this->m_pDP8SP->GetEndpointByAddress(&spgebadModified);
	if (hr == DPN_OK)
	{
		CDP8SimEndpoint *	pDP8SimEndpoint;


		//
		// Convert our user context into the real user's context, and
		// return the endpoint handle that our user should see.
		//
		pDP8SimEndpoint = (CDP8SimEndpoint*) spgebadModified.pvEndpointContext;
		pspgebad->hEndpoint = pDP8SimEndpoint;
		pspgebad->pvEndpointContext = pDP8SimEndpoint->GetUserContext();
	}
	else
	{
		DPFX(DPFPREP, 0, "Failed getting endpoint by address on real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}
#endif // ! DPNBUILD_NOMULTICAST



Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	/*
#ifndef DPNBUILD_NOMULTICAST
	if (spgebadModified.pAddressDeviceInfo != NULL)
	{
		spgebadModified.pAddressDeviceInfo->Release();
		spgebadModified.pAddressDeviceInfo = NULL;
	}

	if (spgebadModified.pAddressHost != NULL)
	{
		spgebadModified.pAddressHost->Release();
		spgebadModified.pAddressHost = NULL;
	}
#endif // ! DPNBUILD_NOMULTICAST
	*/

	goto Exit;
} // CDP8SimSP::GetEndpointByAddress





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::Update"
//=============================================================================
// CDP8SimSP::Update
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPUNUSEDDATA pspud		- Pointer to parameter block.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::Update(PSPUPDATEDATA pspud)
{
	HRESULT			hr;
	SPUPDATEDATA	spudModified;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspud);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspud != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Update the real service provider's as appropriate.
	//
	spudModified.UpdateType = pspud->UpdateType;
	switch (spudModified.UpdateType)
	{
		case SP_UPDATE_HOST_MIGRATE:
		case SP_UPDATE_ALLOW_ENUMS:
		case SP_UPDATE_DISALLOW_ENUMS:
		{
			CDP8SimEndpoint *	pDP8SimEndpoint;


			//
			// Convert our endpoint into the real SP's endpoint.
			//
			pDP8SimEndpoint = (CDP8SimEndpoint*) pspud->hEndpoint;
			spudModified.hEndpoint = pDP8SimEndpoint->GetRealSPEndpoint();

			hr = this->m_pDP8SP->Update(&spudModified);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Failed updating real SP object (0x%p)!",
					this->m_pDP8SP);

				//
				// Continue...
				//
			}
			break;
		}

		default:
		{
			DPFX(DPFPREP, 0, "Unrecognized update type %u!", spudModified.UpdateType);
			DNASSERT(! "Unrecognized update type!");
			hr = DPNERR_UNSUPPORTED;
			break;
		}
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::Update





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetCaps"
//=============================================================================
// CDP8SimSP::GetCaps
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPGETCAPSDATA pspgcd	- Pointer to parameter block to use when retrieving
//								the capabilities.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::GetCaps(PSPGETCAPSDATA pspgcd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspgcd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspgcd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Retrieve the capabilities of the real service provider.
	//
	hr = this->m_pDP8SP->GetCaps(pspgcd);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed getting caps on real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}
	else
	{
		//
		// Add in the network simulator flag.
		//
		pspgcd->dwFlags |= DPNSPCAPS_NETWORKSIMULATOR;
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::GetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::SetCaps"
//=============================================================================
// CDP8SimSP::SetCaps
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPSETCAPSDATA pspscd	- Pointer to parameter block to use when setting
//								the capabilities.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::SetCaps(PSPSETCAPSDATA pspscd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspscd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspscd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Store the capabilities of the real service provider.
	//
	hr = this->m_pDP8SP->SetCaps(pspscd);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed setting caps on real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::SetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::ReturnReceiveBuffers"
//=============================================================================
// CDP8SimSP::ReturnReceiveBuffers
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPRECEIVEDBUFFER psprb		- Array of receive buffers to return.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::ReturnReceiveBuffers(PSPRECEIVEDBUFFER psprb)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psprb);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psprb != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Return the receive buffers to the real service provider.
	//
	hr = this->m_pDP8SP->ReturnReceiveBuffers(psprb);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed returning receive buffers to real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}



//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::ReturnReceiveBuffers





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetAddressInfo"
//=============================================================================
// CDP8SimSP::GetAddressInfo
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPGETADDRESSINFODATA pspgaid	- Pointer to parameter block to use when
//										getting address info.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::GetAddressInfo(PSPGETADDRESSINFODATA pspgaid)
{
	HRESULT					hr;
	CDP8SimEndpoint *		pDP8SimEndpoint;
	SPGETADDRESSINFODATA	spgaidModified;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspgaid);


	ZeroMemory(&spgaidModified, sizeof(spgaidModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspgaid != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	pDP8SimEndpoint = (CDP8SimEndpoint*) pspgaid->hEndpoint;
	DNASSERT(pDP8SimEndpoint->IsValidObject());



	//
	// Initialize return value to NULL.
	//
	pspgaid->pAddress = NULL;


	//
	// If the endpoint is disconnecting, don't try to get the address info.
	//
	pDP8SimEndpoint->Lock();
	if (pDP8SimEndpoint->IsDisconnecting())
	{
		pDP8SimEndpoint->Unlock();

		DPFX(DPFPREP, 0, "Endpoint 0x%p is disconnecting, can't get address info!",
			pDP8SimEndpoint);

		hr = DPNERR_NOCONNECTION;
		goto Failure;
	}
	pDP8SimEndpoint->Unlock();



	//
	// Copy the parameter block, modifying as necessary.
	//
	spgaidModified.hEndpoint	= pDP8SimEndpoint->GetRealSPEndpoint();
	spgaidModified.pAddress		= NULL;										// filled in by real SP
	spgaidModified.Flags		= pspgaid->Flags;



	//
	// Get real service provider address info.
	//
	hr = this->m_pDP8SP->GetAddressInfo(&spgaidModified);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed getting real SP object (0x%p) address info!",
			this->m_pDP8SP);
		goto Failure;
	}


	//
	// Modify the address so that the SP uses our GUID, if there was an address
	// returned.
	//
	if (spgaidModified.pAddress != NULL)
	{
		hr = spgaidModified.pAddress->SetSP(&this->m_guidFakeSP);
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't change address' SP!");
			goto Failure;
		}
	}


	//
	// Return the modified address to the user.
	//
	pspgaid->pAddress = spgaidModified.pAddress;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (spgaidModified.pAddress != NULL)
	{
		spgaidModified.pAddress->Release();
		spgaidModified.pAddress = NULL;
	}

	goto Exit;
} // CDP8SimSP::GetAddressInfo





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::IsApplicationSupported"
//=============================================================================
// CDP8SimSP::IsApplicationSupported
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPISAPPLICATIONSUPPORTEDDATA pspiasd	- Pointer to parameter block to use
//												when checking application
//												support.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::IsApplicationSupported(PSPISAPPLICATIONSUPPORTEDDATA pspiasd)
{
	HRESULT		hr;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspiasd);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspiasd != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Check availability with the real service provider.
	//
	hr = this->m_pDP8SP->IsApplicationSupported(pspiasd);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Failed checking if application is supported by real SP object (0x%p)!",
			this->m_pDP8SP);

		//
		// Continue...
		//
	}


//Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


//Failure:

//	goto Exit;
} // CDP8SimSP::IsApplicationSupported





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::EnumAdapters"
//=============================================================================
// CDP8SimSP::EnumAdapters
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPENUMADAPTERSDATA pspead	- Pointer to parameter block to use when
//									enumerating the adapters.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::EnumAdapters(PSPENUMADAPTERSDATA pspead)
{
	HRESULT		hr;
	DWORD		dwTemp;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, pspead);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pspead != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	//
	// Enumerate the adapters available to the real service provider.
	//
	hr = this->m_pDP8SP->EnumAdapters(pspead);
	if (hr == DPN_OK)
	{
		//
		// Set the NETWORKSIMULATORDEVICE flag for all of the adapters.
		//
		for(dwTemp = 0; dwTemp < pspead->dwAdapterCount; dwTemp++)
		{
			pspead->pAdapterData[dwTemp].dwFlags |= DPNSPINFO_NETWORKSIMULATORDEVICE;
		}
	}
	else
	{
		if (hr != DPNERR_BUFFERTOOSMALL)
		{
			DPFX(DPFPREP, 0, "Failed enumerating adapters on real SP object (0x%p)!",
				this->m_pDP8SP);
		}

		//
		// Continue...
		//
	}


	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CDP8SimSP::EnumAdapters





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::ProxyEnumQuery"
//=============================================================================
// CDP8SimSP::ProxyEnumQuery
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	PSPPROXYENUMQUERYDATA psppeqd	- Pointer to parameter block to use when
//										proxying the enum query.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimSP::ProxyEnumQuery(PSPPROXYENUMQUERYDATA psppeqd)
{
	HRESULT					hr;
	SPPROXYENUMQUERYDATA	sppeqdModified;
	ENUMQUERYDATAWRAPPER *	pEnumQueryDataWrapper;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p)", this, psppeqd);


	ZeroMemory(&sppeqdModified, sizeof(sppeqdModified));


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(psppeqd != NULL);
	DNASSERT(psppeqd->pDestinationAdapter != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);
	DNASSERT(! (this->m_dwFlags & DP8SIMSPOBJ_CLOSING));


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG



	//
	// Copy the parameter block, modifying as necessary.
	//

	/*
	//
	// Duplicate the host address.
	//
	hr = psppeqd->pDestinationAdapter->Duplicate(&sppeqdModified.pDestinationAdapter);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't duplicate destination adapter address!");
		goto Failure;
	}
	*/
	sppeqdModified.pDestinationAdapter	= psppeqd->pDestinationAdapter;


	//
	// Change the service provider GUID so it matches the one we're
	// calling.
	//
	hr = sppeqdModified.pDestinationAdapter->SetSP(&this->m_guidRealSP);
	if (hr != DPN_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't change destination adapter address' SP!");
		goto Failure;
	}


	//
	// We wrapped the enum query data structure, get the original object.
	//
	pEnumQueryDataWrapper = ENUMQUERYEVENTWRAPPER_FROM_SPIEQUERY(psppeqd->pIncomingQueryData);

	DNASSERT(*((DWORD*) (&pEnumQueryDataWrapper->m_Sig)) == 0x57455145);	// 0x57 0x45 0x51 0x45 = 'WEQE' = 'EQEW' in Intel order

	sppeqdModified.pIncomingQueryData	= pEnumQueryDataWrapper->pOriginalQuery;


	sppeqdModified.dwFlags				= psppeqd->dwFlags;


	//
	// Proxy the enum query through the real service provider.
	//
	hr = this->m_pDP8SP->ProxyEnumQuery(&sppeqdModified);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Failed proxying enum query through real SP object (0x%p)!",
			this->m_pDP8SP);
		goto Failure;
	}



Exit:

	/*
	if (sppeqdModified.pDestinationAdapter != NULL)
	{
		sppeqdModified.pDestinationAdapter->Release();
		sppeqdModified.pDestinationAdapter = NULL;
	}
	*/

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::ProxyEnumQuery






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::InitializeObject"
//=============================================================================
// CDP8SimSP::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CDP8SimSP::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimSP::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::UninitializeObject"
//=============================================================================
// CDP8SimSP::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimSP::UninitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::PerformDelayedSend"
//=============================================================================
// CDP8SimSP::PerformDelayedSend
//-----------------------------------------------------------------------------
//
// Description: Performs a delayed send.
//
// Arguments:
//	PVOID pvContext		- Pointer to context to use when performing delayed
//							send.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::PerformDelayedSend(PVOID const pvContext)
{
	HRESULT						hr;
	CDP8SimSend *				pDP8SimSend = (CDP8SimSend*) pvContext;
	DP8SIMCOMMAND_FPMCONTEXT	CommandFPMContext;
	CDP8SimCommand *			pDP8SimCommand = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pvContext);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pvContext != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG



	//
	// Prepare a command object.
	//

	ZeroMemory(&CommandFPMContext, sizeof(CommandFPMContext));
	CommandFPMContext.dwType			= CMDTYPE_SENDDATA_DELAYED;
	CommandFPMContext.pvUserContext		= pDP8SimSend;

	pDP8SimCommand = (CDP8SimCommand*)g_FPOOLCommand.Get(&CommandFPMContext);
	if (pDP8SimCommand == NULL)
	{
		DPFX(DPFPREP, 0, "Couldn't allocate memory for new command object!");
	}
	else
	{
		DPFX(DPFPREP, 7, "New command 0x%p.", pDP8SimCommand);


		//
		// Add a reference for the send command.
		//
		pDP8SimCommand->AddRef();

		pDP8SimSend->SetSendDataBlockContext(pDP8SimCommand);


		//
		// Issue the send to the real SP.  Essentially ignore the return value
		// since we already indicated completion to the upper layer.
		//
		hr = this->m_pDP8SP->SendData(pDP8SimSend->GetSendDataBlockPtr());
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Failed sending delayed data (err = 0x%lx)!", hr);


			DPFX(DPFPREP, 7, "Releasing aborted command 0x%p.", pDP8SimCommand);
			pDP8SimCommand->Release();


			//
			// Remove the send counter.
			//
			this->DecSendsPending();


			DPFX(DPFPREP, 7, "Releasing aborted send 0x%p.", pDP8SimSend);
			pDP8SimSend->Release();


			//
			// Continue.
			//
		}
		else
		{
			if (hr != DPNSUCCESS_PENDING)
			{
				//
				// The command completed right away.
				//
				DNASSERT(hr == DPN_OK);

				hr = this->m_pDP8SimCB->CommandComplete(pDP8SimSend->GetSendDataBlockCommand(),
														hr,
														pDP8SimCommand);
				DNASSERT(hr == DPN_OK);
			}
			else
			{
				//
				// Save the output parameters returned by the SP.
				//
				pDP8SimCommand->SetRealSPCommand(pDP8SimSend->GetSendDataBlockCommand(),
												pDP8SimSend->GetSendDataBlockCommandDescriptor());
			}
		}


		//
		// Give up local reference.
		//
		DPFX(DPFPREP, 7, "Releasing command 0x%p local reference.", pDP8SimCommand);
		pDP8SimCommand->Release();
		pDP8SimCommand = NULL;
	}


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimSP::PerformDelayedSend






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::PerformDelayedReceive"
//=============================================================================
// CDP8SimSP::PerformDelayedReceive
//-----------------------------------------------------------------------------
//
// Description: Performs a delayed receive.
//
// Arguments:
//	PVOID pvContext		- Pointer to context to use when performing delayed
//							receive.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::PerformDelayedReceive(PVOID const pvContext)
{
	HRESULT				hr;
	CDP8SimReceive *	pDP8SimReceive = (CDP8SimReceive*) pvContext;
	IDP8SPCallback *	pDP8SPCallback;
	SPIE_DATA *			pData;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p)", this, pvContext);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pvContext != NULL);


#ifdef DEBUG
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);


	DNLeaveCriticalSection(&this->m_csLock);
#endif // DEBUG


	pDP8SPCallback = this->m_pDP8SimCB->GetRealCallbackInterface();
	pData = pDP8SimReceive->GetReceiveDataBlockPtr();


	//
	// Indicate the event to the real callback interface.
	//

	DPFX(DPFPREP, 2, "Indicating event SPEV_DATA (message = 0x%p) to interface 0x%p.",
		pData, pDP8SPCallback);

	hr = pDP8SPCallback->IndicateEvent(SPEV_DATA, pData);

	DPFX(DPFPREP, 2, "Returning from event SPEV_DATA [0x%lx].", hr);


	//
	// Update the statistics.
	//
	this->IncrementStatsReceiveTransmitted(pData->pReceivedData->BufferDesc.dwBufferSize,
											pDP8SimReceive->GetLatencyAdded());


	//
	// Return the buffers to the real SP unless the user wanted to keep them.
	//
	if (hr != DPNSUCCESS_PENDING)
	{
		DPFX(DPFPREP, 8, "Returning receive data 0x%p to real SP 0x%p.",
			pData->pReceivedData, this->m_pDP8SP);


		hr = this->m_pDP8SP->ReturnReceiveBuffers(pData->pReceivedData);
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Failed returning receive buffers 0x%p (err = 0x%lx)!  Ignoring.",
				pData->pReceivedData, hr);

			//
			// Ignore failure.
			//
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Callback interface 0x%p keeping receive data 0x%p.",
			pDP8SPCallback, pData->pReceivedData);

		//
		// Our user needs to return the buffers at some point.
		//
	}


	//
	// Remove the receive counter.
	//
	this->DecReceivesPending();


	//
	// Release the delayed receive reference.
	//
	DPFX(DPFPREP, 7, "Releasing receive 0x%p.", pDP8SimReceive);
	pDP8SimReceive->Release();
	pDP8SimReceive = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CDP8SimSP::PerformDelayedReceive





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::IncSendsPending"
//=============================================================================
// CDP8SimSP::IncSendsPending
//-----------------------------------------------------------------------------
//
// Description: Increments the counter tracking the number of sends pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::IncSendsPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Increment the counters.
	//
	this->m_dwSendsPending++;

	DPFX(DPFPREP, 5, "(0x%p) Sends now pending = %u.",
		this, this->m_dwSendsPending);


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::IncSendsPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::DecSendsPending"
//=============================================================================
// CDP8SimSP::DecSendsPending
//-----------------------------------------------------------------------------
//
// Description: Decrements the counter tracking the number of sends pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::DecSendsPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Decrement the counters.
	//
	DNASSERT(this->m_dwSendsPending > 0);
	this->m_dwSendsPending--;


	DPFX(DPFPREP, 5, "(0x%p) Sends now pending = %u.",
		this, this->m_dwSendsPending);

	//
	// If that was the last send pending and someone is waiting for all of them
	// to complete, notify him.
	//
	if ((this->m_dwSendsPending == 0) &&
		(this->m_hLastPendingSendEvent != NULL))
	{
		DPFX(DPFPREP, 1, "Last pending send, notifying waiting thread.");

		SetEvent(this->m_hLastPendingSendEvent);
	}


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::DecSendsPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::IncReceivesPending"
//=============================================================================
// CDP8SimSP::IncReceivesPending
//-----------------------------------------------------------------------------
//
// Description: Increments the counter tracking the number of receives pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::IncReceivesPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Increment the counters.
	//
	this->m_dwReceivesPending++;

	DPFX(DPFPREP, 5, "(0x%p) Receives now pending = %u.",
		this, this->m_dwReceivesPending);


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::IncReceivesPending





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::DecReceivesPending"
//=============================================================================
// CDP8SimSP::DecReceivesPending
//-----------------------------------------------------------------------------
//
// Description: Decrements the counter tracking the number of receives pending.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimSP::DecReceivesPending(void)
{
	DNEnterCriticalSection(&this->m_csLock);


	//
	// Assert the object state.
	//
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_INITIALIZED);
	DNASSERT(this->m_dwFlags & DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD);

	//
	// Decrement the counters.
	//
	DNASSERT(this->m_dwReceivesPending > 0);
	this->m_dwReceivesPending--;


	DPFX(DPFPREP, 5, "(0x%p) Receives now pending = %u.",
		this, this->m_dwReceivesPending);

	/*
	//
	// If that was the last receive pending and someone is waiting for all of
	// them to complete, notify him.
	//
	if ((this->m_dwReceivesPending == 0) &&
		(this->m_hLastPendingReceiveEvent != NULL))
	{
		DPFX(DPFPREP, 1, "Last pending receive, notifying waiting thread.");

		SetEvent(this->m_hLastPendingReceiveEvent);
	}
	*/


	DNLeaveCriticalSection(&this->m_csLock);
} // CDP8SimSP::DecReceivesPending




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::ShouldDrop"
//=============================================================================
// CDP8SimSP::ShouldDrop
//-----------------------------------------------------------------------------
//
// Description: Returns TRUE if it is determined that the packet should be
//				dropped, or FALSE if not.
//
// Arguments:
//	FLOAT fDropPercentage	- Percentage chance that the packet should be
//								dropped.
//
// Returns: BOOL
//=============================================================================
BOOL CDP8SimSP::ShouldDrop(const FLOAT fDropPercentage)
{
	double	dRand;


	if (fDropPercentage == 0.0)
	{
		return FALSE;
	}

	DNASSERT((fDropPercentage >= 0.0) && (fDropPercentage <= 100.0));
	dRand = GetGlobalRand() * 100.0;

	return ((dRand < fDropPercentage) ? TRUE: FALSE);
} // CDP8SimSP::ShouldDrop





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimSP::GetDelay"
//=============================================================================
// CDP8SimSP::GetDelay
//-----------------------------------------------------------------------------
//
// Description:    Determines a delay factors based on the given bandwidth,
//				data size, and random latency values.
//
//				   This function returns TRUE if some delay should be added,
//				FALSE if not.
//
// Arguments:
//	DWORD dwBandwidthBPS		- Bandwidth settings.
//	DWORD dwPacketHeaderSize	- Size of fixed transport header.
//	DWORD dwDataSize			- Size of packet being sent/received.
//	DWORD dwMinRandMS			- Minimum random latency value.
//	DWORD dwMaxRandMS			- Maximum random latency value.
//	DWORD * pdwBandwidthDelay	- Place to store delay caused by bandwidth.
//	DWORD * pdwLatencyDelay		- Place to store delay caused by latency.
//
// Returns: BOOL
//=============================================================================
BOOL CDP8SimSP::GetDelay(const DWORD dwBandwidthBPS,
						const DWORD dwPacketHeaderSize,
						const DWORD dwDataSize,
						const DWORD dwMinRandMS,
						const DWORD dwMaxRandMS,
						DWORD * const pdwBandwidthDelay,
						DWORD * const pdwLatencyDelay)
{
	BOOL	fResult = FALSE;
	double	dTransferTime;
	double	dHalfDistance;
	double	dRand1;
	double	dRand2;
	double	dTemp;


	//
	// If there's no bandwidth limit, there's no delay.
	//
	if (dwBandwidthBPS == 0)
	{
		(*pdwBandwidthDelay) = 0;
	}
	else
	{
		//
		// Otherwise, find out how many seconds it will take to transfer the
		// data and add it to the base random latency.
		//
		dTransferTime = dwPacketHeaderSize + dwDataSize;
		dTransferTime /= dwBandwidthBPS;
		dTransferTime *= 1000;


		//
		// Round the value down to an even number of milliseconds.
		//
		(*pdwBandwidthDelay) = (DWORD) dTransferTime;

		fResult = TRUE;
	}


	//
	// If the min and max are equal, we can use either as the latency.
	// If it's not zero, then we need to note the delay.
	//
	if (dwMinRandMS == dwMaxRandMS)
	{
		(*pdwLatencyDelay) = dwMinRandMS;
		if (dwMinRandMS > 0)
		{
			fResult = TRUE;
		}
	}
	else
	{
		//
		// First store half the distance between the min and max.
		//
		dHalfDistance = dwMaxRandMS - dwMinRandMS;
		dHalfDistance /= 2;


		//
		// Now pick a number using a normal (bell curve) distribution.
		// This requires two randomly generated numbers and some fancy math.
		//

		do
		{
			dRand1 = 2.0 * GetGlobalRand() - 1.0;
			dRand2 = 2.0 * GetGlobalRand() - 1.0;
			dTemp = (dRand1 * dRand1) + (dRand2 * dRand2);
		}
		while ((dTemp >= 1.0) || (dTemp == 0.0));

		dTemp = sqrt(-2.0 * log(dTemp) / dTemp);
		//dTemp = dHalfDistance + (dRand1 * dTemp) * (dHalfDistance * 0.25);
		dTemp = dHalfDistance + (dRand1 * dTemp) * (dHalfDistance * 0.36666);

		//
		// Cap the values, because our bell curve fattening factor (0.36666
		// instead of 0.25) causes the distribution to leak out past the edges.
		//
		if (dTemp < 0.0)
		{
			dTemp = 0.0;
		}
		else if (dTemp > (dwMaxRandMS - dwMinRandMS))
		{
			dTemp = dwMaxRandMS - dwMinRandMS;
		}


		//
		// Round the normally distributed value down to an even number of
		// milliseconds and add it to the minimum for the final base latency.
		//
		(*pdwLatencyDelay) = dwMinRandMS + (DWORD) dTemp;

		fResult = TRUE;
	}

	return fResult;
} // CDP8SimSP::GetDelay
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\spwrapper.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       spwrapper.h
 *
 *  Content:	Header for DP8SIM main SP interface wrapper object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



//=============================================================================
// Macros
//=============================================================================
#define DP8SIMSP_FROM_BILINK(b)			(CONTAINING_OBJECT(b, CDP8SimSP, m_blList))



//=============================================================================
// Object flags
//=============================================================================
#define DP8SIMSPOBJ_INITIALIZED					0x01	// object has been initialized
#define DP8SIMSPOBJ_STARTEDGLOBALWORKERTHREAD	0x02	// the global worker thread was started
#define DP8SIMSPOBJ_CLOSING						0x04	// close is in progress, no new functions are allowed




//=============================================================================
// Service provider interface object class
//=============================================================================
class CDP8SimSP : public IDP8ServiceProvider
{
	public:
		CDP8SimSP(const GUID * const pguidFakeSP, const GUID * const pguidRealSP);	// constructor
		~CDP8SimSP(void);							// destructor


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

		STDMETHODIMP_(ULONG) AddRef(void);

		STDMETHODIMP_(ULONG) Release(void);


		STDMETHODIMP Initialize(PSPINITIALIZEDATA pspid);

		STDMETHODIMP Close(void);

		STDMETHODIMP Connect(PSPCONNECTDATA pspcd);

		STDMETHODIMP Disconnect(PSPDISCONNECTDATA pspdd);

		STDMETHODIMP Listen(PSPLISTENDATA pspld);

		STDMETHODIMP SendData(PSPSENDDATA pspsd);

		STDMETHODIMP EnumQuery(PSPENUMQUERYDATA pspeqd);

		STDMETHODIMP EnumRespond(PSPENUMRESPONDDATA psperd);

		STDMETHODIMP CancelCommand(HANDLE hCommand, DWORD dwCommandDescriptor);

		STDMETHODIMP EnumMulticastScopes(PSPENUMMULTICASTSCOPESDATA pspemsd);

		STDMETHODIMP ShareEndpointInfo(PSPSHAREENDPOINTINFODATA pspseid);

		STDMETHODIMP GetEndpointByAddress(PSPGETENDPOINTBYADDRESSDATA pspgebad);

		STDMETHODIMP Update(PSPUPDATEDATA pspud);

		STDMETHODIMP GetCaps(PSPGETCAPSDATA pspgcd);

		STDMETHODIMP SetCaps(PSPSETCAPSDATA pspscd);

		STDMETHODIMP ReturnReceiveBuffers(PSPRECEIVEDBUFFER psprb);

		STDMETHODIMP GetAddressInfo(PSPGETADDRESSINFODATA pspgaid);

		STDMETHODIMP IsApplicationSupported(PSPISAPPLICATIONSUPPORTEDDATA pspiasd);

		STDMETHODIMP EnumAdapters(PSPENUMADAPTERSDATA pspead);

		STDMETHODIMP ProxyEnumQuery(PSPPROXYENUMQUERYDATA psppeqd);



		HRESULT InitializeObject(void);

		void UninitializeObject(void);

		void PerformDelayedSend(PVOID const pvContext);

		void PerformDelayedReceive(PVOID const pvContext);

		void IncSendsPending(void);

		void DecSendsPending(void);

		void IncReceivesPending(void);

		void DecReceivesPending(void);
		
		static BOOL ShouldDrop(const FLOAT fDropPercentage);

		static BOOL GetDelay(const DWORD dwBandwidthBPS,
							const DWORD dwPacketHeaderSize,
							const DWORD dwDataSize,
							const DWORD dwMinRandMS,
							const DWORD dwMaxRandMS,
							DWORD * const pdwBandwidthDelay,
							DWORD * const pdwLatencyDelay);


		inline void GetAllReceiveParameters(DP8SIM_PARAMETERS * const pdp8sp)		{ this->m_DP8SimIPC.GetAllReceiveParameters(pdp8sp); };
		inline void IncrementStatsSendTransmitted(DWORD dwBytes, DWORD dwDelay)		{ this->m_DP8SimIPC.IncrementStatsSendTransmitted(dwBytes, dwDelay); };
		inline void IncrementStatsSendDropped(DWORD dwBytes)						{ this->m_DP8SimIPC.IncrementStatsSendDropped(dwBytes); };
		inline void IncrementStatsReceiveTransmitted(DWORD dwBytes, DWORD dwDelay)	{ this->m_DP8SimIPC.IncrementStatsReceiveTransmitted(dwBytes, dwDelay); };
		inline void IncrementStatsReceiveDropped(DWORD dwBytes)						{ this->m_DP8SimIPC.IncrementStatsReceiveDropped(dwBytes); };
		inline GUID * GetFakeSP(void)												{ return (&this->m_guidFakeSP); };



		CBilink					m_blList;	// list of all the DP8SimSP instances in existence


	private:
		BYTE					m_Sig[4];					// debugging signature ('SPWP')
		LONG					m_lRefCount;				// reference count for this object
		DWORD					m_dwFlags;					// flags for this object
		DNCRITICAL_SECTION		m_csLock;					// lock preventing simultaneous usage of globals
		GUID					m_guidFakeSP;				// GUID of fake SP object
		GUID					m_guidRealSP;				// GUID of real SP object
		CDP8SimCB *				m_pDP8SimCB;				// pointer to callback interface wrapper object in use
		IDP8ServiceProvider *	m_pDP8SP;					// pointer to real service provider interface
		DWORD					m_dwSendsPending;			// number of outstanding sends
		HANDLE					m_hLastPendingSendEvent;	// handle to event to set when last send completes
		DWORD					m_dwReceivesPending;		// number of outstanding sends
		//HANDLE					m_hLastPendingReceiveEvent;	// handle to event to set when last send completes
		CDP8SimIPC				m_DP8SimIPC;				// object that handles interprocess communication


		inline BOOL IsValidObject(void)
		{
			if ((this == NULL) || (IsBadWritePtr(this, sizeof(CDP8SimSP))))
			{
				return FALSE;
			}

			if (*((DWORD*) (&this->m_Sig)) != 0x50575053)	// 0x50 0x57 0x50 0x53 = 'PWPS' = 'SPWP' in Intel order
			{
				return FALSE;
			}

			return TRUE;
		};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\dp8simworkerthread.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simworkerthread.h
 *
 *  Content:	Header for DP8SIM worker thread functions.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/


//=============================================================================
// Job types
//=============================================================================
typedef enum _DP8SIMJOBTYPE
{
	DP8SIMJOBTYPE_UNKNOWN =				0,	// should never be used
	DP8SIMJOBTYPE_DELAYEDSEND =			1,	// submits a send
	DP8SIMJOBTYPE_DELAYEDRECEIVE =		2,	// indicates a receive
	DP8SIMJOBTYPE_QUIT =				3,	// stops the worker thread
} DP8SIMJOBTYPE, * PDP8SIMJOBTYPE;




//=============================================================================
// Job flags
//=============================================================================
#define DP8SIMJOBFLAG_PERFORMBLOCKINGPHASEFIRST				0x01	// this job should start in it's blocking delay phase, and then be delayed an additional amount
#define DP8SIMJOBFLAG_PERFORMBLOCKINGPHASELAST				0x02	// this job should be delayed an initial amount, then enter it's blocking delay phase
//#define DP8SIMJOBFLAG_BLOCKEDBYALLJOBS						0x04	// this job should be blocked by all other jobs in the queue, regardless of whether they are explicitly blocking




//=============================================================================
// Functions
//=============================================================================
HRESULT StartGlobalWorkerThread(void);

void StopGlobalWorkerThread(void);


HRESULT AddWorkerJob(const DP8SIMJOBTYPE JobType,
					PVOID const pvContext,
					CDP8SimSP * const pDP8SimSP,
					const DWORD dwBlockingDelay,
					const DWORD dwNonBlockingDelay,
					const DWORD dwFlags);


void FlushAllDelayedSendsToEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
									BOOL fDrop);

void FlushAllDelayedReceivesFromEndpoint(CDP8SimEndpoint * const pDP8SimEndpoint,
										BOOL fDrop);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\sp_ctrl\spcallbackobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		spcallbackobj.cpp
 *
 *  Content:	DP8SIM callback interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simi.h"





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::CDP8SimCB"
//=============================================================================
// CDP8SimCB constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CDP8SimCB object.
//
// Arguments:
//	CDP8SimSP * pOwningDP8SimSP		- Pointer to owning CDP8SimSP object.
//	IDP8SPCallback * pDP8SPCB		- Pointer to real DPlay callback interface
//										being intercepted.
//
// Returns: None (the object).
//=============================================================================
CDP8SimCB::CDP8SimCB(CDP8SimSP * pOwningDP8SimSP, IDP8SPCallback * pDP8SPCB)
{
	this->m_Sig[0]	= 'S';
	this->m_Sig[1]	= 'P';
	this->m_Sig[2]	= 'C';
	this->m_Sig[3]	= 'B';

	this->m_lRefCount			= 1; // someone must have a pointer to this object

	pOwningDP8SimSP->AddRef();
	this->m_pOwningDP8SimSP		= pOwningDP8SimSP;

	pDP8SPCB->AddRef();
	this->m_pDP8SPCB			= pDP8SPCB;
} // CDP8SimCB::CDP8SimCB






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::~CDP8SimCB"
//=============================================================================
// CDP8SimCB destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CDP8SimCB object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CDP8SimCB::~CDP8SimCB(void)
{
	DNASSERT(this->m_lRefCount == 0);


	this->m_pOwningDP8SimSP->Release();
	this->m_pOwningDP8SimSP = NULL;

	this->m_pDP8SPCB->Release();
	this->m_pDP8SPCB = NULL;


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'b';
} // CDP8SimCB::~CDP8SimCB




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::QueryInterface"
//=============================================================================
// CDP8SimCB::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CDP8SimCB object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CDP8SimCB::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPN_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DP8Sim object!");
		hr = DPNERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDP8SPCallback)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CDP8SimCB inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimCB::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::AddRef"
//=============================================================================
// CDP8SimCB::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CDP8SimCB object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimCB::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CDP8SimCB::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::Release"
//=============================================================================
// CDP8SimCB::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CDP8SimCB object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CDP8SimCB::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);


		//
		// Uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CDP8SimCB::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::IndicateEvent"
//=============================================================================
// CDP8SimCB::IndicateEvent
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	SP_EVENT_TYPE EventType		- Event being indicated.
//	PVOID pvMessage				- Event specific message.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimCB::IndicateEvent(SP_EVENT_TYPE EventType, PVOID pvMessage)
{
	HRESULT				hr;
	CDP8SimEndpoint *	pDP8SimEndpoint;
	CDP8SimCommand *	pDP8SimCommand;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (%u, 0x%p)", this, EventType, pvMessage);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Switch on the type of event being indicated.
	//
	switch (EventType)
	{
		case SPEV_DATA:
		{
			SPIE_DATA *			pData;
			DP8SIM_PARAMETERS	dp8sp;
			SPIE_DATA			DataModified;
			CDP8SimReceive *	pDP8SimReceive;
			DWORD				dwBandwidthDelay;
			DWORD				dwLatencyDelay;


			pData = (SPIE_DATA*) pvMessage;


			DNASSERT(pData->pReceivedData->pNext == NULL);


			pDP8SimEndpoint = (CDP8SimEndpoint*) pData->pEndpointContext;
			DNASSERT(pDP8SimEndpoint->IsValidObject());


			//
			// If the endpoint is disconnecting, drop the receive.
			//
			pDP8SimEndpoint->Lock();
			if (pDP8SimEndpoint->IsDisconnecting())
			{
				pDP8SimEndpoint->Unlock();

				DPFX(DPFPREP, 1, "Endpoint 0x%p is disconnecting, dropping receive.",
					pDP8SimEndpoint);

				hr = DPN_OK;
			}
			else
			{
				pDP8SimEndpoint->Unlock();


				//
				// Get the current receive settings.
				//
				ZeroMemory(&dp8sp, sizeof(dp8sp));
				dp8sp.dwSize = sizeof(dp8sp);
				this->m_pOwningDP8SimSP->GetAllReceiveParameters(&dp8sp);


				//
				// Determine if we need to drop this receive.
				//
				if (this->m_pOwningDP8SimSP->ShouldDrop(dp8sp.fPacketLossPercent))
				{
					DPFX(DPFPREP, 2, "Dropping %u bytes of data from endpoint 0x%p.",
						pData->pReceivedData->BufferDesc.dwBufferSize, pDP8SimEndpoint);


					//
					// Update the statistics.
					//
					this->m_pOwningDP8SimSP->IncrementStatsReceiveDropped(pData->pReceivedData->BufferDesc.dwBufferSize);


					//
					// Let the SP reclaim the buffer.
					//
					hr = DPN_OK;
				}
				else
				{
					//
					// Figure out how much latency needs to be added based on
					// the bandwidth and random latency settings.
					//
					// If we're not supposed to delay the receives, indicate it
					// now.  Otherwise submit a timed job to be performed
					// later.
					//
					if (! this->m_pOwningDP8SimSP->GetDelay(dp8sp.dwBandwidthBPS,
															dp8sp.dwPacketHeaderSize,
															pData->pReceivedData->BufferDesc.dwBufferSize,
															dp8sp.dwMinLatencyMS,
															dp8sp.dwMaxLatencyMS,
															&dwBandwidthDelay,
															&dwLatencyDelay))
					{
						//
						// Modify the message before indicating to the caller.
						//

						ZeroMemory(&DataModified, sizeof(DataModified));
						DataModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;
						DataModified.pEndpointContext	= pDP8SimEndpoint->GetUserContext();
						DataModified.pReceivedData		= pData->pReceivedData;


						//
						// Indicate the event to the real callback interface.
						//

						DPFX(DPFPREP, 2, "Indicating event SPEV_DATA (message = 0x%p, data size = %u) to interface 0x%p.",
							pData, pData->pReceivedData->BufferDesc.dwBufferSize,
							this->m_pDP8SPCB);

						hr = this->m_pDP8SPCB->IndicateEvent(SPEV_DATA, &DataModified);

						DPFX(DPFPREP, 2, "Returning from event SPEV_DATA [0x%lx].", hr);


						//
						// Update the statistics.
						//
						this->m_pOwningDP8SimSP->IncrementStatsReceiveTransmitted(pData->pReceivedData->BufferDesc.dwBufferSize,
																				0);
					}
					else
					{
						DPFX(DPFPREP, 6, "Delaying %u byte receive for %u + %u ms.",
							pData->pReceivedData->BufferDesc.dwBufferSize,
							dwBandwidthDelay, dwLatencyDelay);


						//
						// Get a receive object, duplicating the received data
						// structure given to us by our caller for indication
						// some time in the future.
						//
						pDP8SimReceive = (CDP8SimReceive*)g_FPOOLReceive.Get(pData);
						if (pDP8SimReceive == NULL)
						{
							hr = DPNERR_OUTOFMEMORY;
						}
						else
						{
							DPFX(DPFPREP, 7, "New delayed receive 0x%p.", pDP8SimReceive);

							//
							// Store the latency that is about be added to this
							// receive.
							//
							pDP8SimReceive->SetLatencyAdded(dwBandwidthDelay + dwLatencyDelay);

							
							//
							// Transfer local pDP8SimReceive reference to the
							// job queue.
							//


							//
							// Increment the receive counter.
							//
							this->m_pOwningDP8SimSP->IncReceivesPending();


							//
							// Queue it to be indicated at a later time,
							// depending on the latency value requested.  If
							// there's a bandwidth restriction, enforce the
							// receiving order as well so that earlier messages
							// that are still pending hold up later ones.
							//
							hr = AddWorkerJob(DP8SIMJOBTYPE_DELAYEDRECEIVE,
											pDP8SimReceive,
											this->m_pOwningDP8SimSP,
											dwBandwidthDelay,
											dwLatencyDelay,
											DP8SIMJOBFLAG_PERFORMBLOCKINGPHASELAST);
							if (hr != DPN_OK)
							{
								DPFX(DPFPREP, 0, "Couldn't add delayed receive worker job (0x%p)!", 
									pDP8SimReceive);


								//
								// Remove the receive counter.
								//
								this->m_pOwningDP8SimSP->DecReceivesPending();


								//
								// Release the delayed receive reference.
								//
								DPFX(DPFPREP, 7, "Releasing aborted delayed receive 0x%p.", pDP8SimReceive);
								pDP8SimReceive->Release();
								pDP8SimReceive = NULL;
							}
							else
							{
								//
								// Let the real SP know that we're keeping the
								// buffer.
								//
								hr = DPNSUCCESS_PENDING;
							}
						} // end else (successfully got receive object)
					} // end else (delaying receives)
				} // end else (not dropping receive)
			} // end else (endpoint is not disconnecting yet)
			break;
		}

		case SPEV_CONNECT:
		{
			SPIE_CONNECT *	pConnect;
			SPIE_CONNECT	ConnectModified;


			pConnect = (SPIE_CONNECT*) pvMessage;


			pDP8SimCommand = (CDP8SimCommand*) pConnect->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT((pDP8SimCommand->GetType() == CMDTYPE_CONNECT) || (pDP8SimCommand->GetType() == CMDTYPE_LISTEN));


			//
			// Get a new endpoint object from the pool.
			//
			pDP8SimEndpoint = (CDP8SimEndpoint*)g_FPOOLEndpoint.Get(pConnect->hEndpoint);
			if (pDP8SimEndpoint == NULL)
			{
				hr = DPNERR_OUTOFMEMORY;
			}
			else
			{
				DPFX(DPFPREP, 7, "New %s endpoint 0x%p.",
					((pDP8SimCommand->GetType() == CMDTYPE_CONNECT) ? _T("outbound") : _T("inbound")),
					pDP8SimEndpoint);


				//
				// Modify the message before indicating to the caller.
				//

				ZeroMemory(&ConnectModified, sizeof(ConnectModified));
				ConnectModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;
				//ConnectModified.pEndpointContext	= NULL;									// the user fills this in
				ConnectModified.pCommandContext		= pDP8SimCommand->GetUserContext();


				//
				// Indicate the event to the real callback interface.
				//

				DPFX(DPFPREP, 2, "Indicating event SPEV_CONNECT (message = 0x%p) to interface 0x%p.",
					&ConnectModified, this->m_pDP8SPCB);

				hr = this->m_pDP8SPCB->IndicateEvent(SPEV_CONNECT, &ConnectModified);

				DPFX(DPFPREP, 2, "Returning from event SPEV_CONNECT [0x%lx].", hr);


				if (hr == DPN_OK)
				{
					//
					// Update the endpoint context with what the user returned.
					//
					pDP8SimEndpoint->SetUserContext(ConnectModified.pEndpointContext);

					//
					// Return our endpoint context.
					//
					pConnect->pEndpointContext = pDP8SimEndpoint;
				}
				else
				{
					//
					// Release the endpoint reference.
					//
					DPFX(DPFPREP, 7, "Releasing aborted endpoint 0x%p.", pDP8SimEndpoint);
					pDP8SimEndpoint->Release();
					pDP8SimEndpoint = NULL;
				}
			}

			break;
		}

		case SPEV_DISCONNECT:
		{
			SPIE_DISCONNECT *	pDisconnect;
			SPIE_DISCONNECT		DisconnectModified;


			pDisconnect = (SPIE_DISCONNECT*) pvMessage;


			pDP8SimEndpoint = (CDP8SimEndpoint*) pDisconnect->pEndpointContext;
			DNASSERT(pDP8SimEndpoint->IsValidObject());


			//
			// Mark the endpoint as disconnecting to prevent additional sends
			// or receives.
			//
			pDP8SimEndpoint->Lock();
			pDP8SimEndpoint->NoteDisconnecting();
			pDP8SimEndpoint->Unlock();


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&DisconnectModified, sizeof(DisconnectModified));
			DisconnectModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;
			DisconnectModified.pEndpointContext		= pDP8SimEndpoint->GetUserContext();

	
			//
			// Quickly indicate any delayed receives from this endpoint that
			// are still pending.
			//
			FlushAllDelayedReceivesFromEndpoint(pDP8SimEndpoint, FALSE);

			//
			// Kill off any delayed sends that would have gone to this
			// endpoint.
			//
			FlushAllDelayedSendsToEndpoint(pDP8SimEndpoint, TRUE);


			//
			// Indicate the event to the real callback interface.
			//

			DPFX(DPFPREP, 2, "Indicating event SPEV_DISCONNECT (message = 0x%p) to interface 0x%p.",
				&DisconnectModified, this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->IndicateEvent(SPEV_DISCONNECT, &DisconnectModified);

			DPFX(DPFPREP, 2, "Returning from event SPEV_DISCONNECT [0x%lx].", hr);


			//
			// Release the endpoint reference.
			//
			DPFX(DPFPREP, 7, "Releasing endpoint 0x%p.", pDP8SimEndpoint);
			pDP8SimEndpoint->Release();
			pDP8SimEndpoint = NULL;

			break;
		}


		case SPEV_LISTENSTATUS:
		{
			SPIE_LISTENSTATUS *		pListenStatus;
			SPIE_LISTENSTATUS		ListenStatusModified;


			pListenStatus = (SPIE_LISTENSTATUS*) pvMessage;


			pDP8SimCommand = (CDP8SimCommand*) pListenStatus->pUserContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Get a new endpoint object from the pool.
			//
			pDP8SimEndpoint = (CDP8SimEndpoint*)g_FPOOLEndpoint.Get(pListenStatus->hEndpoint);
			if (pDP8SimEndpoint == NULL)
			{
				hr = DPNERR_OUTOFMEMORY;
			}
			else
			{
				DPFX(DPFPREP, 7, "New listen endpoint 0x%p, adding reference for listen command.",
					pDP8SimEndpoint);

				//
				// Store an endpoint reference with the command.
				//
				pDP8SimEndpoint->AddRef();
				pDP8SimCommand->SetListenEndpoint(pDP8SimEndpoint);


				//
				// Modify the message before indicating to the caller.
				//

				ZeroMemory(&ListenStatusModified, sizeof(ListenStatusModified));
				ListenStatusModified.ListenAdapter		= pListenStatus->ListenAdapter;
				ListenStatusModified.hResult			= pListenStatus->hResult;
				ListenStatusModified.hCommand			= (HANDLE) pDP8SimCommand;
				ListenStatusModified.pUserContext		= pDP8SimCommand->GetUserContext();
				ListenStatusModified.hEndpoint			= (HANDLE) pDP8SimEndpoint;


				//
				// Indicate the event to the real callback interface.
				//

				DPFX(DPFPREP, 2, "Indicating event SPEV_LISTENSTATUS (message = 0x%p) to interface 0x%p.",
					&ListenStatusModified, this->m_pDP8SPCB);

				hr = this->m_pDP8SPCB->IndicateEvent(SPEV_LISTENSTATUS, &ListenStatusModified);

				DPFX(DPFPREP, 2, "Returning from event SPEV_LISTENSTATUS [0x%lx].", hr);


				//
				// Release the reference we got from new, since we only needed
				// it while we indicated the endpoint up to the user.  The
				// listen command object has the reference it needs.
				//
				DPFX(DPFPREP, 7, "Releasing local listen endpoint 0x%p reference.",
					pDP8SimEndpoint);
				pDP8SimEndpoint->Release();
				pDP8SimEndpoint = NULL;
			}

			break;
		}

		case SPEV_ENUMQUERY:
		{
			SPIE_QUERY *				pQuery;
			ENUMQUERYDATAWRAPPER		QueryWrapper;


			pQuery = (SPIE_QUERY*) pvMessage;

			DNASSERT(pQuery->pAddressSender != NULL);
			DNASSERT(pQuery->pAddressDevice != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pQuery->pUserContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Modify the message before indicating to the caller.  We need a
			// wrapper so that ProxyEnumQuery can parse back out the original
			// query data pointer.
			//

			ZeroMemory(&QueryWrapper, sizeof(QueryWrapper));
			QueryWrapper.m_Sig[0]	= 'E';
			QueryWrapper.m_Sig[1]	= 'Q';
			QueryWrapper.m_Sig[2]	= 'E';
			QueryWrapper.m_Sig[3]	= 'W';

			QueryWrapper.pOriginalQuery = pQuery;

			hr = pQuery->pAddressSender->Duplicate(&QueryWrapper.QueryForUser.pAddressSender);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate enum query sender's address!");
			}
			else
			{
				hr = QueryWrapper.QueryForUser.pAddressSender->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change enum query sender's address' SP!");
				}
				else
				{
					hr = pQuery->pAddressDevice->Duplicate(&QueryWrapper.QueryForUser.pAddressDevice);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate enum query device address!");
					}
					else
					{
						hr = QueryWrapper.QueryForUser.pAddressDevice->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change enum query device address' SP!");
						}
						else
						{
							QueryWrapper.QueryForUser.pReceivedData	= pQuery->pReceivedData;
							QueryWrapper.QueryForUser.pUserContext	= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_ENUMQUERY (message = 0x%p) to interface 0x%p.",
								&QueryWrapper.QueryForUser, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_ENUMQUERY, &QueryWrapper.QueryForUser);

							DPFX(DPFPREP, 2, "Returning from SPEV_ENUMQUERY [0x%lx].", hr);
						}

						QueryWrapper.QueryForUser.pAddressDevice->Release();
						QueryWrapper.QueryForUser.pAddressDevice = NULL;
					}
				}

				QueryWrapper.QueryForUser.pAddressSender->Release();
				QueryWrapper.QueryForUser.pAddressSender = NULL;
			}
			break;
		}

		case SPEV_QUERYRESPONSE:
		{
			SPIE_QUERYRESPONSE *	pQueryResponse;
			SPIE_QUERYRESPONSE		QueryResponseModified;


			pQueryResponse = (SPIE_QUERYRESPONSE*) pvMessage;

			DNASSERT(pQueryResponse->pAddressSender != NULL);
			DNASSERT(pQueryResponse->pAddressDevice != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pQueryResponse->pUserContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_ENUMQUERY);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&QueryResponseModified, sizeof(QueryResponseModified));

			hr = pQueryResponse->pAddressSender->Duplicate(&QueryResponseModified.pAddressSender);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate query response sender's address!");
			}
			else
			{
				hr = QueryResponseModified.pAddressSender->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change query response sender's address' SP!");
				}
				else
				{
					hr = pQueryResponse->pAddressDevice->Duplicate(&QueryResponseModified.pAddressDevice);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate query response device address!");
					}
					else
					{
						hr = QueryResponseModified.pAddressDevice->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change query response device address' SP!");
						}
						else
						{
							QueryResponseModified.pReceivedData		= pQueryResponse->pReceivedData;
							QueryResponseModified.dwRoundTripTime	= pQueryResponse->dwRoundTripTime;
							QueryResponseModified.pUserContext		= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_QUERYRESPONSE (message = 0x%p) to interface 0x%p.",
								&QueryResponseModified, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_QUERYRESPONSE, &QueryResponseModified);

							DPFX(DPFPREP, 2, "Returning from SPEV_QUERYRESPONSE [0x%lx].", hr);
						}

						QueryResponseModified.pAddressDevice->Release();
						QueryResponseModified.pAddressDevice = NULL;
					}
				}

				QueryResponseModified.pAddressSender->Release();
				QueryResponseModified.pAddressSender = NULL;
			}
			break;
		}

		case SPEV_LISTENADDRESSINFO:
		{
			SPIE_LISTENADDRESSINFO *	pListenAddressInfo;
			SPIE_LISTENADDRESSINFO		ListenAddressInfoModified;


			pListenAddressInfo = (SPIE_LISTENADDRESSINFO*) pvMessage;

			DNASSERT(pListenAddressInfo->pDeviceAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pListenAddressInfo->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&ListenAddressInfoModified, sizeof(ListenAddressInfoModified));

			hr = pListenAddressInfo->pDeviceAddress->Duplicate(&ListenAddressInfoModified.pDeviceAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate listen address info device address!");
			}
			else
			{
				hr = ListenAddressInfoModified.pDeviceAddress->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change listen address info device address' SP!");
				}
				else
				{
					ListenAddressInfoModified.hCommandStatus	= pListenAddressInfo->hCommandStatus;
					ListenAddressInfoModified.pCommandContext	= pDP8SimCommand->GetUserContext();


					//
					// Indicate the event to the real callback interface.
					//

					DPFX(DPFPREP, 2, "Indicating SPEV_LISTENADDRESSINFO (message = 0x%p) to interface 0x%p.",
						&ListenAddressInfoModified, this->m_pDP8SPCB);

					hr = this->m_pDP8SPCB->IndicateEvent(SPEV_LISTENADDRESSINFO, &ListenAddressInfoModified);

					DPFX(DPFPREP, 2, "Returning from SPEV_LISTENADDRESSINFO [0x%lx].", hr);
				}

				ListenAddressInfoModified.pDeviceAddress->Release();
				ListenAddressInfoModified.pDeviceAddress = NULL;
			}
			break;
		}

		case SPEV_ENUMADDRESSINFO:
		{
			SPIE_ENUMADDRESSINFO *	pEnumAddressInfo;
			SPIE_ENUMADDRESSINFO	EnumAddressInfoModified;


			pEnumAddressInfo = (SPIE_ENUMADDRESSINFO*) pvMessage;

			DNASSERT(pEnumAddressInfo->pHostAddress != NULL);
			DNASSERT(pEnumAddressInfo->pDeviceAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pEnumAddressInfo->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_ENUMQUERY);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&EnumAddressInfoModified, sizeof(EnumAddressInfoModified));

			hr = pEnumAddressInfo->pHostAddress->Duplicate(&EnumAddressInfoModified.pHostAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate enum address info host's address!");
			}
			else
			{
				hr = EnumAddressInfoModified.pHostAddress->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change enum address info host's address' SP!");
				}
				else
				{
					hr = pEnumAddressInfo->pDeviceAddress->Duplicate(&EnumAddressInfoModified.pDeviceAddress);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate enum address info device address!");
					}
					else
					{
						hr = EnumAddressInfoModified.pDeviceAddress->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change enum address info device address' SP!");
						}
						else
						{
							EnumAddressInfoModified.hCommandStatus	= pEnumAddressInfo->hCommandStatus;
							EnumAddressInfoModified.pCommandContext	= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_ENUMADDRESSINFO (message = 0x%p) to interface 0x%p.",
								&EnumAddressInfoModified, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_ENUMADDRESSINFO, &EnumAddressInfoModified);

							DPFX(DPFPREP, 2, "Returning from SPEV_ENUMADDRESSINFO [0x%lx].", hr);
						}

						EnumAddressInfoModified.pDeviceAddress->Release();
						EnumAddressInfoModified.pDeviceAddress = NULL;
					}
				}

				EnumAddressInfoModified.pHostAddress->Release();
				EnumAddressInfoModified.pHostAddress = NULL;
			}
			break;
		}

		case SPEV_CONNECTADDRESSINFO:
		{
			SPIE_CONNECTADDRESSINFO *	pConnectAddressInfo;
			SPIE_CONNECTADDRESSINFO		ConnectAddressInfoModified;


			pConnectAddressInfo = (SPIE_CONNECTADDRESSINFO*) pvMessage;

			DNASSERT(pConnectAddressInfo->pHostAddress != NULL);
			DNASSERT(pConnectAddressInfo->pDeviceAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pConnectAddressInfo->pCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_CONNECT);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&ConnectAddressInfoModified, sizeof(ConnectAddressInfoModified));

			hr = pConnectAddressInfo->pHostAddress->Duplicate(&ConnectAddressInfoModified.pHostAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate connect address info host's address!");
			}
			else
			{
				hr = ConnectAddressInfoModified.pHostAddress->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change connect address info host's address' SP!");
				}
				else
				{
					hr = pConnectAddressInfo->pDeviceAddress->Duplicate(&ConnectAddressInfoModified.pDeviceAddress);
					if (hr != DPN_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't duplicate connect address info device address!");
					}
					else
					{
						hr = ConnectAddressInfoModified.pDeviceAddress->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't change connect address info device address' SP!");
						}
						else
						{
							ConnectAddressInfoModified.hCommandStatus	= pConnectAddressInfo->hCommandStatus;
							ConnectAddressInfoModified.pCommandContext	= pDP8SimCommand->GetUserContext();


							//
							// Indicate the event to the real callback interface.
							//

							DPFX(DPFPREP, 2, "Indicating SPEV_CONNECTADDRESSINFO (message = 0x%p) to interface 0x%p.",
								&ConnectAddressInfoModified, this->m_pDP8SPCB);

							hr = this->m_pDP8SPCB->IndicateEvent(SPEV_CONNECTADDRESSINFO, &ConnectAddressInfoModified);

							DPFX(DPFPREP, 2, "Returning from SPEV_CONNECTADDRESSINFO [0x%lx].", hr);
						}

						ConnectAddressInfoModified.pDeviceAddress->Release();
						ConnectAddressInfoModified.pDeviceAddress = NULL;
					}
				}

				ConnectAddressInfoModified.pHostAddress->Release();
				ConnectAddressInfoModified.pHostAddress = NULL;
			}
			break;
		}

		case SPEV_DATA_UNCONNECTED:
		{
			SPIE_DATA_UNCONNECTED *	pDataUnconnected;
			SPIE_DATA_UNCONNECTED	DataUnconnectedModified;


			pDataUnconnected = (SPIE_DATA_UNCONNECTED*) pvMessage;
			DNASSERT(pDataUnconnected->pvReplyBuffer != NULL);
			DNASSERT(pDataUnconnected->dwReplyBufferSize > 0);


			pDP8SimCommand = (CDP8SimCommand*) pDataUnconnected->pvListenCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&DataUnconnectedModified, sizeof(DataUnconnectedModified));
			DataUnconnectedModified.pvListenCommandContext		= pDP8SimCommand->GetUserContext();
			DataUnconnectedModified.pReceivedData				= pDataUnconnected->pReceivedData;
			DataUnconnectedModified.dwSenderAddressHash			= pDataUnconnected->dwSenderAddressHash;
			DataUnconnectedModified.pvReplyBuffer				= pDataUnconnected->pvReplyBuffer;
			DataUnconnectedModified.dwReplyBufferSize			= pDataUnconnected->dwReplyBufferSize;


			//
			// Indicate the event to the real callback interface.
			//

			DPFX(DPFPREP, 2, "Indicating event SPEV_DATA_UNCONNECTED (message = 0x%p) to interface 0x%p.",
				&DataUnconnectedModified, this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->IndicateEvent(SPEV_DATA_UNCONNECTED, &DataUnconnectedModified);

			DPFX(DPFPREP, 2, "Returning from event SPEV_DATA_UNCONNECTED [0x%lx].", hr);

			if (hr == DPNSUCCESS_PENDING)
			{
				//
				// Update the reply buffer size with what the user returned.
				//
				DNASSERT(DataUnconnectedModified.dwReplyBufferSize > 0);
				DNASSERT(DataUnconnectedModified.dwReplyBufferSize <= pDataUnconnected->dwReplyBufferSize);
				pDataUnconnected->dwReplyBufferSize = DataUnconnectedModified.dwReplyBufferSize;
			}

			break;
		}

#ifndef DPNBUILD_NOMULTICAST
		case SPEV_DATA_UNKNOWNSENDER:
		{
			SPIE_DATA_UNKNOWNSENDER *	pDataUnknownSender;
			SPIE_DATA_UNKNOWNSENDER		DataUnknownSenderModified;


			pDataUnknownSender = (SPIE_DATA_UNKNOWNSENDER*) pvMessage;

			DNASSERT(pDataUnknownSender->pSenderAddress != NULL);


			pDP8SimCommand = (CDP8SimCommand*) pDataUnknownSender->pvListenCommandContext;
			DNASSERT(pDP8SimCommand->IsValidObject());
			DNASSERT(pDP8SimCommand->GetType() == CMDTYPE_LISTEN);


			//
			// Modify the message before indicating to the caller.
			//

			ZeroMemory(&DataUnknownSenderModified, sizeof(DataUnknownSenderModified));

			hr = pDataUnknownSender->pSenderAddress->Duplicate(&DataUnknownSenderModified.pSenderAddress);
			if (hr != DPN_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't duplicate listen address info device address!");
			}
			else
			{
				hr = DataUnknownSenderModified.pSenderAddress->SetSP(this->m_pOwningDP8SimSP->GetFakeSP());
				if (hr != DPN_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't change listen address info device address' SP!");
				}
				else
				{
					DataUnknownSenderModified.pvListenCommandContext	= pDP8SimCommand->GetUserContext();
					DataUnknownSenderModified.pReceivedData				= pDataUnknownSender->pReceivedData;


					//
					// Indicate the event to the real callback interface.
					//

					DPFX(DPFPREP, 2, "Indicating SPEV_DATA_UNKNOWNSENDER (message = 0x%p) to interface 0x%p.",
						&DataUnknownSenderModified, this->m_pDP8SPCB);

					hr = this->m_pDP8SPCB->IndicateEvent(SPEV_DATA_UNKNOWNSENDER, &DataUnknownSenderModified);

					DPFX(DPFPREP, 2, "Returning from SPEV_DATA_UNKNOWNSENDER [0x%lx].", hr);
				}

				DataUnknownSenderModified.pSenderAddress->Release();
				DataUnknownSenderModified.pSenderAddress = NULL;
			}
			break;
		}
#endif // ! DPNBUILD_NOMULTICAST

		default:
		{
			DPFX(DPFPREP, 0, "Unrecognized event type %u!", EventType);
			DNASSERT(FALSE);
			hr = E_NOTIMPL;
			break;
		}
	}


	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CDP8SimCB::IndicateEvent





#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::CommandComplete"
//=============================================================================
// CDP8SimCB::CommandComplete
//-----------------------------------------------------------------------------
//
// Description: ?
//
// Arguments:
//	HANDLE hCommand		- Handle of command that's completing.
//	HRESULT hrResult	- Result code for completing operation.
//	PVOID pvContext		- Pointer to user context for command.
//
// Returns: HRESULT
//=============================================================================
STDMETHODIMP CDP8SimCB::CommandComplete(HANDLE hCommand, HRESULT hrResult, PVOID pvContext)
{
	HRESULT				hr;
	CDP8SimCommand *	pDP8SimCommand = (CDP8SimCommand*) pvContext;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx, 0x%p)",
		this, hCommand, hrResult, pvContext);


	//
	// Validate (actually assert) the object.
	//
	DNASSERT(this->IsValidObject());


	//
	// Assert the parameters.
	//
	DNASSERT(pDP8SimCommand->IsValidObject());



	//
	// Switch on the command type.
	//
	switch (pDP8SimCommand->GetType())
	{
		case CMDTYPE_SENDDATA_IMMEDIATE:
		{
			//
			// Update the statistics.
			//
			if (hrResult == DPN_OK)
			{
				this->m_pOwningDP8SimSP->IncrementStatsSendTransmitted(pDP8SimCommand->GetMessageSize(),
																		0);
			}
			else
			{
				//
				// The send failed.  Currently we don't track this.
				//
			}
			pDP8SimCommand->SetMessageSize(0);


			//
			// Indicate the completion to the real callback interface.
			//
			DPFX(DPFPREP, 2, "Indicating immediate send command 0x%p complete (result = 0x%lx, context = 0x%p) to interface 0x%p.",
				pDP8SimCommand, hrResult,
				pDP8SimCommand->GetUserContext(),
				this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->CommandComplete(pDP8SimCommand,
													hrResult,
													pDP8SimCommand->GetUserContext());

			DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


			//
			// Remove the send counter.
			//
			this->m_pOwningDP8SimSP->DecSendsPending();

			break;
		}

		case CMDTYPE_SENDDATA_DELAYED:
		{
			CDP8SimSend *	pDP8SimSend;


			//
			// Handle the completion.  It never gets indicated to the user
			// though.
			//

			pDP8SimSend = (CDP8SimSend*) pDP8SimCommand->GetUserContext();
			DNASSERT(pDP8SimSend->IsValidObject());

			DPFX(DPFPREP, 5, "Send 0x%p (command 0x%p) completed.",
				pDP8SimSend, pDP8SimCommand);


			//
			// Update the statistics.
			//
			if (hrResult == DPN_OK)
			{
				this->m_pOwningDP8SimSP->IncrementStatsSendTransmitted(pDP8SimSend->GetMessageSize(),
																		pDP8SimSend->GetLatencyAdded());
			}
			else
			{
				//
				// The send failed.  We don't truly track this, but since we
				// already indicated a successful send to the user, we'll count
				// it as a drop.
				//
				this->m_pOwningDP8SimSP->IncrementStatsSendDropped(pDP8SimSend->GetMessageSize());
			}
			

			//
			// Remove the send counter.
			//
			this->m_pOwningDP8SimSP->DecSendsPending();


			pDP8SimSend->Release();
			pDP8SimSend = NULL;

			hr = DPN_OK;

			break;
		}

		case CMDTYPE_CONNECT:
		case CMDTYPE_DISCONNECT:
		case CMDTYPE_LISTEN:
		case CMDTYPE_ENUMQUERY:
		case CMDTYPE_ENUMRESPOND:
		{
			//
			// Indicate the completion to the real callback interface.
			//
			DPFX(DPFPREP, 2, "Indicating command 0x%p complete (type = %u, result = 0x%lx, context = 0x%p) to interface 0x%p.",
				pDP8SimCommand, pDP8SimCommand->GetType(), hrResult,
				pDP8SimCommand->GetUserContext(), this->m_pDP8SPCB);

			hr = this->m_pDP8SPCB->CommandComplete(pDP8SimCommand,
													hrResult,
													pDP8SimCommand->GetUserContext());

			DPFX(DPFPREP, 2, "Returning from command complete [0x%lx].", hr);


			//
			// If this was a listen, we need to kill the listen endpoint.
			//
			if (pDP8SimCommand->GetType() == CMDTYPE_LISTEN)
			{
				CDP8SimEndpoint *	pDP8SimEndpoint;


				pDP8SimEndpoint = pDP8SimCommand->GetListenEndpoint();
				DNASSERT(pDP8SimEndpoint != NULL);

				pDP8SimCommand->SetListenEndpoint(NULL);

				DPFX(DPFPREP, 7, "Releasing listen endpoint 0x%p.",
					pDP8SimEndpoint);

				pDP8SimEndpoint->Release();
				pDP8SimEndpoint = NULL;
			}
			break;
		}
		
		default:
		{
			DPFX(DPFPREP, 0, "Unrecognized command type %u!", pDP8SimCommand->GetType());
			DNASSERT(FALSE);
			hr = E_NOTIMPL;
			break;
		}
	}


	//
	// Destroy the object.
	//
	DPFX(DPFPREP, 7, "Releasing completed command 0x%p.", pDP8SimCommand);
	pDP8SimCommand->Release();
	pDP8SimCommand = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;
} // CDP8SimCB::CommandComplete






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::InitializeObject"
//=============================================================================
// CDP8SimCB::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CDP8SimCB::InitializeObject(void)
{
	HRESULT		hr;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CDP8SimCB::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CDP8SimCB::UninitializeObject"
//=============================================================================
// CDP8SimCB::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CDP8SimCB::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Returning", this);
} // CDP8SimCB::UninitializeObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\ui\sources.inc ===
TARGETNAME=dp8simui
TARGETTYPE=PROGRAM

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dp8simuii.h
PRECOMPILED_PCH=dp8simuii.pch
PRECOMPILED_OBJ=dp8simuii.obj

TARGETLIBS=$(TARGETLIBS) \
	   ..\..\..\..\common\$(PLAT_DIR)\$(O)\common.lib \
	   ..\..\guids\$(PLAT_DIR)\$(O)\guids.lib \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
	   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib

INCLUDES=$(DXROOT)\inc;..\..\..\..\inc;..\..\..\..\common;..\..\inc;..\

SOURCES= ..\dp8simui.rc \
	 ..\dp8simuimain.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\ui\dp8simuii.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dp8simuii.h
 *
 *  Content:	DP8SIMUI master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/25/01  VanceO    Created.
 *
 ***************************************************************************/

#ifndef __DP8SIMUII_H__
#define __DP8SIMUII_H__

//
// Build configuration include
//
#include "dpnbuild.h"

//
// Don't use the C interface style for COM, use C++
//
#undef CINTERFACE

// 
// Public includes
//
#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <mmsystem.h>	// NT BUILD requires this for timeGetTime
#include <tchar.h>
#ifndef _XBOX
#include <wincrypt.h>
#endif

// 
// DirectPlay public includes
//
#include "dplay8.h"
//#include "dpaddr.h"
//#include "dpsp8.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
//#include "classbilink.h"
//#include "creg.h"
//#include "createin.h"
#include "comutil.h"
//#include "dneterrors.h"
#include "strutils.h"


// 
// DP8Sim includes
//
#include "dp8sim.h"


// 
// DP8SimUI private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_TOOLS

#include "resource.h"




#endif // __DP8SIMUII_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\dplay8parser.cpp ===
#include "TransportParser.hpp"
#include "SPParser.hpp"
#include "VoiceParser.hpp"
#include "SessionParser.hpp"



// DESCRIPTION: Identifies the parser, or parsers that are located in the DLL.
//
// NOTE: ParserAutoInstallInfo should be implemented in all parser DLLs.
//
// ARGUMENTS: NONE
//
// RETURNS: Success:  PF_PARSERDLLINFO structure that describes the parsers in the DLL.
//			Failiure: NULL
//
DPLAYPARSER_API PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo( void )	// TODO: RIGHT NOW THIS SEEMS TO DO NOTHING!!!
{

	enum
	{
		nNUM_OF_PROTOCOLS = 4
	};

	// Allocate memory for the parser info
	// NetMon will free this with HeapFree
	PPF_PARSERDLLINFO pParserDllInfo =
		reinterpret_cast<PPF_PARSERDLLINFO>( HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                                       sizeof(PF_PARSERDLLINFO) + nNUM_OF_PROTOCOLS * sizeof(PF_PARSERINFO)) );
    if( pParserDllInfo == NULL)
    {
        return NULL;
    }


	// Number of parsers in the parser DLL. 
    pParserDllInfo->nParsers = nNUM_OF_PROTOCOLS;


	//=============================================//
	// DPlay Service Provider parser specific info //===============================================================
	//=============================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rSPInfo = pParserDllInfo->ParserInfo[0];

	// Name of the protocol that the parser detects
    strcpy(rSPInfo.szProtocolName, "DPLAYSP");

	// Brief description of the protocol
    strcpy(rSPInfo.szComment, "DPlay v.8.0 - Service Provider protocol");

	// Optional name of the protocol Help file
    strcpy(rSPInfo.szHelpFile, "\0");


	// Specify the preceding protocols 
	enum
	{
		  nNUM_OF_PARSERS_SP_FOLLOWS = 2
	};

	// NetMon will free this with HeapFree
	PPF_FOLLOWSET pSPPrecedeSet =
		  reinterpret_cast<PPF_FOLLOWSET>( HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
													 sizeof(PF_FOLLOWSET) + nNUM_OF_PARSERS_SP_FOLLOWS * sizeof(PF_FOLLOWENTRY)) );
	if( pSPPrecedeSet == NULL )
	{
		return pParserDllInfo;
	}

	// Fill in the follow set for preceding parsers
	pSPPrecedeSet->nEntries = nNUM_OF_PARSERS_SP_FOLLOWS;

	strcpy(pSPPrecedeSet->Entry[0].szProtocol, "UDP");
	strcpy(pSPPrecedeSet->Entry[1].szProtocol, "IPX");

	rSPInfo.pWhoCanPrecedeMe = pSPPrecedeSet;


	
	//==================================//
	// DPlay8 Transport parser specific info //==========================================================================
	//==================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rTransportInfo = pParserDllInfo->ParserInfo[1];

	// Name of the protocol that the parser detects
    strcpy(rTransportInfo.szProtocolName, "DPLAYTRANSPORT");

	// Brief description of the protocol
    strcpy(rTransportInfo.szComment, "DPlay v.8.0 - Transport protocol");

	// Optional name of the protocol Help file
    strcpy(rTransportInfo.szHelpFile, "\0");



	//==================================//
	// DPlay Voice parser specific info //==========================================================================
	//==================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rVoiceInfo = pParserDllInfo->ParserInfo[2];

	// Name of the protocol that the parser detects
    strcpy(rVoiceInfo.szProtocolName, "DPLAYVOICE");

	// Brief description of the protocol
    strcpy(rVoiceInfo.szComment, "DPlay v.8.0 - Voice protocol");

	// Optional name of the protocol Help file
    strcpy(rVoiceInfo.szHelpFile, "\0");



	//=================================//
	// DPlay Core parser specific info //===========================================================================
	//=================================//

	// Defining a synonym reference for simpler access
    PF_PARSERINFO& rCoreInfo = pParserDllInfo->ParserInfo[3];

	// Name of the protocol that the parser detects
    strcpy(rCoreInfo.szProtocolName, "DPLAYSESSION");

	// Brief description of the protocol
    strcpy(rCoreInfo.szComment, "DPlay v.8.0 - Session protocol");

	// Optional name of the protocol Help file
    strcpy(rCoreInfo.szHelpFile, "\0");
	

    return pParserDllInfo;

} // ParserAutoInstallInfo




// DESCRIPTION: (Called by the OS) Tell the kernel about our entry points.
//
// ARGUMENTS: i_hInstance - Handle to an instance of the parser.
//			  i_dwCommand - Indicator to determine why the function is called.
//			  i_pReserved - Not used now.
//
// RETURNS: Success = TRUE; Failure = FALSE
//
BOOL WINAPI DllMain( HANDLE i_hInstance, ULONG i_dwCommand, LPVOID i_pReserved )
{
	
	static DWORD dwAttached = 0;

    // Process according to the calling context
    switch( i_dwCommand )
    {
        case DLL_PROCESS_ATTACH:
            // Are we loading for the first time?
            if( dwAttached == 0 )
            {
				// TODO: TEMPORARY: THIS SEEMS TO ADD THE PROTOCOLS TO PARSER.INI
				CreateTransportProtocol();
				CreateSPProtocol();
				CreateVoiceProtocol();
				CreateSessionProtocol();
/*
				if ( !CreateTransportProtocol() || !CreateSPProtocol() || !CreateVoiceProtocol() || !CreateSessionProtocol() )
				{
					// TODO: ADD DEBUGING MESSAGE HERE
					MessageBox(NULL, "Failed to create protocols", "FAILED", MB_OK);
					
					//	return FALSE;	// (?BUG?) NetMon won't update the INI file if DllMain returns FALSE.
				}
*/
            }
			++dwAttached;
            break;

        case DLL_PROCESS_DETACH:
            // Are we detaching our last instance?
            if( --dwAttached == 0 )
            {
                // Last active instance of this parser needs to clean up
                DestroyTransportProtocol();
				DestroySPProtocol();
				DestroyVoiceProtocol();
				DestroySessionProtocol();
            }
            break;
    }

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\ui\dp8simuimain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dp8simuimain.cpp
 *
 *  Content:	DP8SIM UI executable entry point.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/23/01  VanceO    Created.
 *
 ***************************************************************************/



#include "dp8simuii.h"



//=============================================================================
// Defines
//=============================================================================
#define MAX_RESOURCE_STRING_LENGTH			_MAX_PATH
#define DISPLAY_PRECISION					4
#define AUTOREFRESH_TIMERID					1
#define AUTOREFRESH_INTERVAL				1000

#define REG_KEY_DP8SIMROOT					_T("Software\\Microsoft\\DirectPlay8\\DP8Sim")
#define REG_KEY_CUSTOMSETTINGS				REG_KEY_DP8SIMROOT _T("\\CustomSettings")




//=============================================================================
// Structures
//=============================================================================
typedef struct _SIMSETTINGS
{
	UINT				uiNameStringResourceID;	// resource ID of name string, or 0 if not built-in
	WCHAR *				pwszName;				// pointer to name string
	DP8SIM_PARAMETERS	dp8spSend;				// send DP8Sim settings
	DP8SIM_PARAMETERS	dp8spReceive;			// receive DP8Sim settings
} SIMSETTINGS, * PSIMSETTINGS;



//=============================================================================
// Dynamically loaded function prototypes
//=============================================================================
typedef HRESULT (WINAPI * PFN_DLLREGISTERSERVER)(void);




//=============================================================================
// Prototypes
//=============================================================================
HRESULT InitializeApplication(const HINSTANCE hInstance,
							const LPSTR lpszCmdLine,
							const int iShowCmd);

HRESULT CleanupApplication(const HINSTANCE hInstance);

HRESULT BuildSimSettingsTable(const HINSTANCE hInstance);

void FreeSimSettingsTable(void);

HRESULT AddSimSettingsToTable(const SIMSETTINGS * const pSimSettings);

HRESULT SaveSimSettings(HWND hWnd, SIMSETTINGS * const pSimSettings);

HRESULT InitializeUserInterface(const HINSTANCE hInstance,
								const int iShowCmd);

HRESULT CleanupUserInterface(void);

void DoErrorBox(const HINSTANCE hInstance,
				const HWND hWndParent,
				const UINT uiCaptionStringRsrcID,
				const UINT uiTextStringRsrcID);

void FloatToString(const FLOAT fValue,
					const int iPrecision,
					char * const szBuffer,
					const int iBufferLength);

void GetParametersFromWindow(HWND hWnd,
							DP8SIM_PARAMETERS * pdp8spSend,
							DP8SIM_PARAMETERS * pdp8spReceive);

void SetParametersInWindow(HWND hWnd,
							DP8SIM_PARAMETERS * pdp8spSend,
							DP8SIM_PARAMETERS * pdp8spReceive);

void DisplayCurrentStatistics(HWND hWnd);



INT_PTR CALLBACK MainWindowDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NameSettingsWindowDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


HRESULT LoadAndAllocString(HINSTANCE hInstance, UINT uiResourceID, WCHAR ** pwszString);




//=============================================================================
// Constants
//=============================================================================
const SIMSETTINGS		c_BuiltInSimSettings[] = 
{
	{ IDS_SETTING_NONE, NULL,					// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			0,									// dp8spSend.dwBandwidthBPS
			0.0,								// dp8spSend.fPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			0,									// dp8spReceive.dwBandwidthBPS
			0.0,								// dp8spReceive.fPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_336MODEM1, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			3500,								// dp8spSend.dwBandwidthBPS
			2.0,								// dp8spSend.fPacketLossPercent
			55,									// dp8spSend.dwMinLatencyMS
			75									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			3500,								// dp8spReceive.dwBandwidthBPS
			2.0,								// dp8spReceive.fPacketLossPercent
			55,									// dp8spReceive.dwMinLatencyMS
			75									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_336MODEM2, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			4000,								// dp8spSend.dwBandwidthBPS
			0.75,								// dp8spSend.fPacketLossPercent
			50,									// dp8spSend.dwMinLatencyMS
			70									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			4000,								// dp8spReceive.dwBandwidthBPS
			0.75,								// dp8spReceive.fPacketLossPercent
			50,									// dp8spReceive.dwMinLatencyMS
			70									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_56KMODEM1, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			3500,								// dp8spSend.dwBandwidthBPS
			2.0,								// dp8spSend.fPacketLossPercent
			55,									// dp8spSend.dwMinLatencyMS
			75									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			5000,								// dp8spReceive.dwBandwidthBPS
			2.0,								// dp8spReceive.fPacketLossPercent
			55,									// dp8spReceive.dwMinLatencyMS
			75									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_56KMODEM2, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			4000,								// dp8spSend.dwBandwidthBPS
			0.75,								// dp8spSend.fPacketLossPercent
			50,									// dp8spSend.dwMinLatencyMS
			70									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			7000,								// dp8spReceive.dwBandwidthBPS
			0.75,								// dp8spReceive.fPacketLossPercent
			50,									// dp8spReceive.dwMinLatencyMS
			70									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_256KBPSDSL, NULL,				// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			32000,								// dp8spSend.dwBandwidthBPS
			0.5,								// dp8spSend.fPacketLossPercent
			25,									// dp8spSend.dwMinLatencyMS
			30									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			32000,								// dp8spReceive.dwBandwidthBPS
			0.5,								// dp8spReceive.fPacketLossPercent
			25,									// dp8spReceive.dwMinLatencyMS
			30									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_DISCONNECTED, NULL,			// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			0,									// dp8spSend.dwBandwidthBPS
			100.0,								// dp8spSend.fPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			0,									// dp8spReceive.dwBandwidthBPS
			100.0,								// dp8spReceive.fPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_HIGHPACKETLOSS, NULL,			// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			0,									// dp8spSend.dwBandwidthBPS
			10.0,								// dp8spSend.fPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			0,									// dp8spReceive.dwBandwidthBPS
			10.0,								// dp8spReceive.fPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	},

	{ IDS_SETTING_HIGHLATENCYVARIANCE, NULL,	// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			0,									// dp8spSend.dwBandwidthBPS
			0.0,								// dp8spSend.fPacketLossPercent
			100,								// dp8spSend.dwMinLatencyMS
			400									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			0,									// dp8spReceive.dwBandwidthBPS
			0.0,								// dp8spReceive.fPacketLossPercent
			100,								// dp8spReceive.dwMinLatencyMS
			400									// dp8spReceive.dwMaxLatencyMS
		}
	},

	//
	// Custom must always be the last item.
	//
	{ IDS_SETTING_CUSTOM, NULL,					// resource ID and string initialization

		{										// dp8spSend
			sizeof(DP8SIM_PARAMETERS),			// dp8spSend.dwSize
			0,									// dp8spSend.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spSend.dwPacketHeaderSize
			0,									// dp8spSend.dwBandwidthBPS
			0.0,								// dp8spSend.fPacketLossPercent
			0,									// dp8spSend.dwMinLatencyMS
			0									// dp8spSend.dwMaxLatencyMS
		},
		{										// dp8spReceive
			sizeof(DP8SIM_PARAMETERS),			// dp8spReceive.dwSize
			0,									// dp8spReceive.dwFlags
			DP8SIMPACKETHEADERSIZE_IP_UDP,		// dp8spReceive.dwPacketHeaderSize
			0,									// dp8spReceive.dwBandwidthBPS
			0.0,								// dp8spReceive.fPacketLossPercent
			0,									// dp8spReceive.dwMinLatencyMS
			0									// dp8spReceive.dwMaxLatencyMS
		}
	}
};



//=============================================================================
// Globals
//=============================================================================
HWND				g_hWndMainWindow = NULL;
IDP8SimControl *	g_pDP8SimControl = NULL;
UINT_PTR			g_uiAutoRefreshTimer = 0;
SIMSETTINGS *		g_paSimSettings = NULL;
DWORD				g_dwNumSimSettings = 0;
DWORD				g_dwMaxNumSimSettings = 0;







#undef DPF_MODNAME
#define DPF_MODNAME "WinMain"
//=============================================================================
// WinMain
//-----------------------------------------------------------------------------
//
// Description: Executable entry point.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	HINSTANCE hPrevInstance	- Handle to previous application instance.
//	LPSTR lpszCmdLine		- Command line string for application.
//	int iShowCmd			- Show state of window.
//
// Returns: HRESULT
//=============================================================================
int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int iShowCmd)
{
	HRESULT		hr;
	HRESULT		hrTemp;
	MSG			msg;


	DPFX(DPFPREP, 2, "===> Parameters: (0x%p, 0x%p, \"%s\", %i)",
		hInstance, hPrevInstance, lpszCmdLine, iShowCmd);
	

	//
	// Initialize the application
	//
	hr = InitializeApplication(hInstance, lpszCmdLine, iShowCmd);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize the application!");
		goto Exit;
	}


	//
	// Do the Windows message loop until we're told to quit.
	//
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	//
	// Retrieve the result code for the window closing.
	//
	hr = (HRESULT) msg.wParam;
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Window closed with failure (err = 0x%lx)!", hr);
	} // end if (failure)



	//
	// Cleanup the application
	//
	hrTemp = CleanupApplication(hInstance);
	if (hrTemp != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed cleaning up the application (err = 0x%lx)!", hrTemp);

		if (hr == S_OK)
		{
			hr = hrTemp;
		}

		//
		// Continue.
		//
	}


Exit:


	DPFX(DPFPREP, 2, "<=== Returning [0x%lx]", hr);

	return hr;
} // WinMain





#undef DPF_MODNAME
#define DPF_MODNAME "InitializeApplication"
//=============================================================================
// InitializeApplication
//-----------------------------------------------------------------------------
//
// Description: Initializes the application.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	LPSTR lpszCmdLine		- Command line string for application.
//	int iShowCmd			- Show state of window.
//
// Returns: HRESULT
//=============================================================================
HRESULT InitializeApplication(const HINSTANCE hInstance,
							const LPSTR lpszCmdLine,
							const int iShowCmd)
{
	HRESULT					hr = S_OK;
	BOOL					fOSIndirectionInitted = FALSE;
	BOOL					fCOMInitted = FALSE;
	HMODULE					hDP8SIM = NULL;
	PFN_DLLREGISTERSERVER	pfnDllRegisterServer;
	WCHAR *					pwszFriendlyName = NULL;
	BOOL					fEnabledControlForSP = FALSE;
	BOOL					fBuiltSimSettingsTable = FALSE;


	DPFX(DPFPREP, 5, "Parameters: (0x%p, \"%s\", %i)",
		hInstance, lpszCmdLine, iShowCmd);
	

	//
	// Attempt to initialize the OS abstraction layer.
	//
	if (! DNOSIndirectionInit(0))
	{
		DPFX(DPFPREP, 0, "Failed to initialize OS indirection layer!");
		hr = E_FAIL;
		goto Failure;
	}

	fOSIndirectionInitted = TRUE;


	//
	// Attempt to initialize COM.
	//
	hr = CoInitialize(NULL);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed to initialize COM!");
		goto Failure;
	}

	fCOMInitted = TRUE;


	//
	// Attempt to create a DP8Sim control object.
	//
	hr = CoCreateInstance(CLSID_DP8SimControl,
						NULL,
						CLSCTX_INPROC_SERVER,
						IID_IDP8SimControl,
						(LPVOID*) (&g_pDP8SimControl));

	if (hr == REGDB_E_CLASSNOTREG)
	{
		//
		// The object wasn't registered.  Attempt to load the DLL and manually
		// register it.
		//

		hDP8SIM = LoadLibrary( _T("dp8sim.dll") );
		if (hDP8SIM == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load \"dp8sim.dll\"!");
			goto Failure;
		}


		pfnDllRegisterServer = (PFN_DLLREGISTERSERVER) GetProcAddress(hDP8SIM,
																	"DllRegisterServer");
		if (pfnDllRegisterServer == NULL)
		{
			hr = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't get \"DllRegisterServer\" function from DP8Sim DLL!");
			goto Failure;
		}


		//
		// Register the DLL.
		//
		hr = pfnDllRegisterServer();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't register DP8Sim DLL!");
			goto Failure;
		}


		FreeLibrary(hDP8SIM);
		hDP8SIM = NULL;


		//
		// Try to create the DP8Sim control object again.
		//
		hr = CoCreateInstance(CLSID_DP8SimControl,
							NULL,
							CLSCTX_INPROC_SERVER,
							IID_IDP8SimControl,
							(LPVOID*) (&g_pDP8SimControl));
	}

	if (hr != S_OK)
	{
		//
		// Some error prevented creation of the object.
		//
		DPFX(DPFPREP, 0, "Failed creating DP8Sim Control object (err = 0x%lx)!", hr);

		DoErrorBox(hInstance,
					NULL,
					IDS_ERROR_CAPTION_COULDNTCREATEDP8SIMCONTROL,
					IDS_ERROR_TEXT_COULDNTCREATEDP8SIMCONTROL);

		goto Failure;
	}


	//
	// If we're here, we successfully created the object.
	//
	DPFX(DPFPREP, 1, "Successfully created DP8Sim Control object 0x%p.",
		&g_pDP8SimControl);


	//
	// Initialize the control object.
	//
	hr = g_pDP8SimControl->Initialize(0);
	if (hr != DP8SIM_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't initialize DP8Sim Control object!");

		g_pDP8SimControl->Release();
		g_pDP8SimControl = NULL;

		goto Failure;
	}


	//
	// Load the list of settings.
	//
	hr = BuildSimSettingsTable(hInstance);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed building list of sim settings!");
		goto Failure;
	}

	fBuiltSimSettingsTable = TRUE;


	//
	// Initialize the user interface.
	//
	hr = InitializeUserInterface(hInstance, iShowCmd);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Failed initializing user interface!");
		goto Failure;
	}


Exit:

	DPFX(DPFPREP, 5, "Returning [0x%lx]", hr);

	return hr;


Failure:

	if (fBuiltSimSettingsTable)
	{
		FreeSimSettingsTable();
		fBuiltSimSettingsTable = FALSE;
	}

	if (hDP8SIM != NULL)
	{
		FreeLibrary(hDP8SIM);
		hDP8SIM = NULL;
	}

	if (pwszFriendlyName != NULL)
	{
		DNFree(pwszFriendlyName);
		pwszFriendlyName = NULL;
	}

	if (g_pDP8SimControl != NULL)
	{
		g_pDP8SimControl->Close(0);	// ignore error

		g_pDP8SimControl->Release();
		g_pDP8SimControl = NULL;
	}

	if (fCOMInitted)
	{
		CoUninitialize();
		fCOMInitted = FALSE;
	}

	if (fOSIndirectionInitted)
	{
		DNOSIndirectionDeinit();
		fOSIndirectionInitted = FALSE;
	}

	goto Exit;
} // InitializeApplication





#undef DPF_MODNAME
#define DPF_MODNAME "CleanupApplication"
//=============================================================================
// CleanupApplication
//-----------------------------------------------------------------------------
//
// Description: Cleans up the application.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//
// Returns: HRESULT
//=============================================================================
HRESULT CleanupApplication(const HINSTANCE hInstance)
{
	HRESULT		hr = S_OK;
	HRESULT		temphr;


	DPFX(DPFPREP, 5, "Enter");


	//
	// Free the control object interface.
	//
	temphr = g_pDP8SimControl->Close(0);
	if (temphr != DP8SIM_OK)
	{
		DPFX(DPFPREP, 0, "Failed closing DP8Sim Control object (err = 0x%lx)!",
			temphr);

		if (hr != S_OK)
		{
			hr = temphr;
		}

		//
		// Continue...
		//
	}

	g_pDP8SimControl->Release();
	g_pDP8SimControl = NULL;
	

	//
	// Cleanup the user interface.
	//
	temphr = CleanupUserInterface();
	if (temphr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't cleanup user interface (err = 0x%lx)!", temphr);

		if (hr != S_OK)
		{
			hr = temphr;
		}

		//
		// Continue...
		//
	}

	FreeSimSettingsTable();

	CoUninitialize();

	DNOSIndirectionDeinit();



	DPFX(DPFPREP, 5, "Returning [0x%lx]", hr);

	return hr;
} // CleanupApplication





#undef DPF_MODNAME
#define DPF_MODNAME "BuildSimSettingsTable()"
//=============================================================================
// BuildSimSettingsTable
//-----------------------------------------------------------------------------
//
// Description: Builds the table of sim settings.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//
// Returns: HRESULT
//=============================================================================
HRESULT BuildSimSettingsTable(HINSTANCE hInstance)
{
	HRESULT			hr = S_OK;
	DWORD			dwTemp;
	HKEY			hKey = NULL;
	DWORD			dwNumValues;
	DWORD			dwMaxValueNameLength;
	TCHAR *			ptszValue = NULL;
	DWORD			dwValueNameLength;
	DWORD			dwType;
	SIMSETTINGS		SimSettings;
	DWORD			dwDataSize;


	DPFX(DPFPREP, 6, "Parameters: (0x%p)", hInstance);


	//
	// Start with the built-in settings.
	//
	g_dwMaxNumSimSettings = sizeof(c_BuiltInSimSettings) / sizeof(SIMSETTINGS);
	g_dwNumSimSettings = g_dwMaxNumSimSettings;

	g_paSimSettings = (SIMSETTINGS*) DNMalloc(g_dwNumSimSettings * sizeof(SIMSETTINGS));
	if (g_paSimSettings == NULL)
	{
		hr = DP8SIMERR_OUTOFMEMORY;
		goto Failure;
	}

	memcpy(g_paSimSettings, c_BuiltInSimSettings, sizeof(c_BuiltInSimSettings));


	//
	// Load the names of all the built-in settings from a resource.
	//
	for(dwTemp = 0; dwTemp < g_dwNumSimSettings; dwTemp++)
	{
		hr = LoadAndAllocString(hInstance,
								g_paSimSettings[dwTemp].uiNameStringResourceID,
								&(g_paSimSettings[dwTemp].pwszName));
		if (hr != DP8SIM_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't load and allocate built-in setting name #%u!",
				dwTemp);
			goto Failure;
		}
	}


	//
	// Now walk the list of custom entries in the registry and add those.
	//
	hr = RegOpenKeyEx(HKEY_CURRENT_USER,
					REG_KEY_CUSTOMSETTINGS,
					0,
					KEY_READ,
					&hKey);
	if (hr == ERROR_SUCCESS)
	{
		//
		// Find out the number of values, and max value name length.
		//
		hr = RegQueryInfoKey(hKey,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							&dwNumValues,
							&dwMaxValueNameLength,
							NULL,
							NULL,
							NULL);
		if (hr == ERROR_SUCCESS)
		{
			dwMaxValueNameLength++; // include room for NULL termination

			ptszValue = (TCHAR*) DNMalloc(dwMaxValueNameLength * sizeof(TCHAR));
			if (ptszValue == NULL)
			{
				DPFX(DPFPREP, 0, "Couldn't allocate memory for custom settings key names!");
				hr = DP8SIMERR_OUTOFMEMORY;
				goto Failure;
			}

			//
			// Loop through each value.
			//
			for(dwTemp = 0; dwTemp < dwNumValues; dwTemp++)
			{
				dwValueNameLength = dwMaxValueNameLength;
				dwDataSize = sizeof(SIMSETTINGS);
				hr = RegEnumValue(hKey,
								dwTemp,
								ptszValue,
								&dwValueNameLength,
								NULL,
								&dwType,
								(BYTE*) (&SimSettings),
								&dwDataSize);
				if (hr == ERROR_SUCCESS)
				{
					dwValueNameLength++; // include room for NULL termination

					//
					// Validate the data that was read.
					//
					if ((dwType == REG_BINARY) &&
						(dwDataSize == sizeof(SIMSETTINGS)) &&
						(SimSettings.uiNameStringResourceID == 0) &&
						(SimSettings.dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS)) &&
						(SimSettings.dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS)))
					{
						SimSettings.pwszName = (WCHAR*) DNMalloc(dwValueNameLength * sizeof(WCHAR));
						if (SimSettings.pwszName == NULL)
						{
							DPFX(DPFPREP, 0, "Couldn't allocate memory for settings name!");
							hr = DP8SIMERR_OUTOFMEMORY;
							goto Failure;
						}
#ifdef UNICODE
						memcpy(SimSettings.pwszName, ptszValue, dwValueNameLength * sizeof(WCHAR));
#else // ! UNICODE
						hr = STR_jkAnsiToWide(SimSettings.pwszName, ptszValue, dwValueNameLength);
						if (hr != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Unable to convert from ANSI to Unicode (err = 0x%lx)!", hr);
							DNFree(SimSettings.pwszName);
							SimSettings.pwszName = NULL;
							goto Failure;
						}
#endif // ! UNICODE

						hr = AddSimSettingsToTable(&SimSettings);
						if (hr != DP8SIM_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't add sim settings to table!");
							hr = DP8SIMERR_OUTOFMEMORY;
							goto Failure;
						}
					}
					else
					{
						DPFX(DPFPREP, 0, "Registry value is not valid (type = %u, data size = %u, resource ID = %u, send size = %u, receive size = %u)!  Ignoring.",
							dwType,
							dwDataSize,
							SimSettings.uiNameStringResourceID,
							SimSettings.dp8spSend.dwSize,
							SimSettings.dp8spReceive.dwSize);
					}
				}
				else
				{
					DPFX(DPFPREP, 0, "Couldn't enumerate value %u (err = 0x%lx)!  Continuing.",
						dwTemp, hr);
				}
			}

			DNFree(ptszValue);
			ptszValue = NULL;
		}
		else
		{
			DPFX(DPFPREP, 0, "Couldn't get custom settings key info!  Continuing.");
		}

		RegCloseKey(hKey);
		hKey = NULL;
	}
	else
	{
		DPFX(DPFPREP, 2, "Couldn't open custom settings key, continuing.");
	}


	//
	// If we're here, everything is ready.
	//
	hr = DP8SIM_OK;


Exit:

	DPFX(DPFPREP, 6, "Returning [0x%lx]", hr);

	return hr;


Failure:

	if (ptszValue != NULL)
	{
		DNFree(ptszValue);
		ptszValue = NULL;
	}

	if (ptszValue != NULL)
	{
		RegCloseKey(hKey);
		hKey = NULL;
	}

	//
	// Free the names of all the settings that got loaded.
	//
	for(dwTemp = 0; dwTemp < g_dwNumSimSettings; dwTemp++)
	{
		if (g_paSimSettings[dwTemp].pwszName != NULL)
		{
			DNFree(g_paSimSettings[dwTemp].pwszName);
			g_paSimSettings[dwTemp].pwszName = NULL;
		}
	}

	goto Exit;
} // BuildSimSettingsTable





#undef DPF_MODNAME
#define DPF_MODNAME "FreeSimSettingsTable()"
//=============================================================================
// FreeSimSettingsTable
//-----------------------------------------------------------------------------
//
// Description: Releases resources allocated for the sim settings table.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
void FreeSimSettingsTable(void)
{
	DWORD	dwTemp;


	DPFX(DPFPREP, 6, "Enter");


	//
	// Free the names of all the settings.
	//
	for(dwTemp = 0; dwTemp < g_dwNumSimSettings; dwTemp++)
	{
		DNFree(g_paSimSettings[dwTemp].pwszName);
		g_paSimSettings[dwTemp].pwszName = NULL;
	}

	DNFree(g_paSimSettings);
	g_paSimSettings = NULL;


	DPFX(DPFPREP, 6, "Leave");
} // FreeSimSettingsTable





#undef DPF_MODNAME
#define DPF_MODNAME "AddSimSettingsToTable()"
//=============================================================================
// AddSimSettingsToTable
//-----------------------------------------------------------------------------
//
// Description: Adds a new sim settings entry to the table.
//
// Arguments:
//	SIMSETTINGS * pSimSettings	- Pointer to new sim settings to add.
//
// Returns: HRESULT
//=============================================================================
HRESULT AddSimSettingsToTable(const SIMSETTINGS * const pSimSettings)
{
	PVOID	pvTemp;
	DWORD	dwNewMaxNumSettings;


	DNASSERT(pSimSettings->pwszName != NULL);
	DPFX(DPFPREP, 4, "Adding settings \"%ls\".", pSimSettings->pwszName);

	//
	// If there's not enough room in the settings array, double it.
	//
	if (g_dwNumSimSettings >= g_dwMaxNumSimSettings)
	{
		dwNewMaxNumSettings = g_dwMaxNumSimSettings * 2;
		pvTemp = DNMalloc(dwNewMaxNumSettings * sizeof(SIMSETTINGS));
		if (pvTemp == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate memory for new settings table!");
			return DP8SIMERR_OUTOFMEMORY;
		}

		//
		// Copy the existing settings and free the old array.
		//
		memcpy(pvTemp, g_paSimSettings, (g_dwNumSimSettings * sizeof(SIMSETTINGS)));
		DNFree(g_paSimSettings);
		g_paSimSettings = (SIMSETTINGS*) pvTemp;
		pvTemp = NULL;
		g_dwMaxNumSimSettings = dwNewMaxNumSettings;
	}


	//
	// Now there's enough room to insert the new item.  Move "Custom" down one
	// slot and add the new settings.
	//

	memcpy(&g_paSimSettings[g_dwNumSimSettings],
			&g_paSimSettings[g_dwNumSimSettings - 1],
			sizeof(SIMSETTINGS));

	memcpy(&g_paSimSettings[g_dwNumSimSettings - 1],
			pSimSettings,
			sizeof(SIMSETTINGS));

	g_dwNumSimSettings++;

	return DP8SIM_OK;
} // AddSimSettingsToTable





#undef DPF_MODNAME
#define DPF_MODNAME "SaveSimSettings()"
//=============================================================================
// SaveSimSettings
//-----------------------------------------------------------------------------
//
// Description: Saves a sim settings entry to the window and registry.  If an
//				entry by that name already exists, it is replaced.
//
// Arguments:
//	SIMSETTINGS * pSimSettings	- Pointer to sim settings to save.
//
// Returns: HRESULT
//=============================================================================
HRESULT SaveSimSettings(HWND hWnd, SIMSETTINGS * const pSimSettings)
{
	HRESULT		hr;
	WCHAR *		pwszName = NULL;
	char *		pszName = NULL;
	HKEY		hKey = NULL;
	DWORD		dwTemp;
	DWORD		dwNameSize;


	//
	// Look for an existing item to replace.
	//
	for(dwTemp = 0; dwTemp < g_dwNumSimSettings; dwTemp++)
	{
		if (_wcsicmp(g_paSimSettings[dwTemp].pwszName, pSimSettings->pwszName) == 0)
		{
			DNASSERT(g_paSimSettings[dwTemp].uiNameStringResourceID == 0);

			//
			// Free the duplicate name string.
			//
			DNFree(pSimSettings->pwszName);

			//
			// Save the string pointer, copy the whole blob, then point to
			// the existing item.
			//
			pwszName = g_paSimSettings[dwTemp].pwszName;
			pSimSettings->pwszName = pwszName;
			memcpy(&g_paSimSettings[dwTemp], pSimSettings, sizeof(SIMSETTINGS));
			pSimSettings->pwszName = NULL;

			//
			// Select this item.
			//
			SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
						CB_SETCURSEL,
						(WPARAM) dwTemp,
						0);

			break;
		}
	}


	//
	// If we're not replacing, add the item to the table.
	//
	if (dwTemp >= g_dwNumSimSettings)
	{
		hr = AddSimSettingsToTable(pSimSettings);
		if (hr != DP8SIM_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't add sim settings to table!");
			goto Failure;
		}

		//
		// Make our caller forget about the string in case we fail since the
		// table owns the reference now.  Keep a local copy, though.
		//
		pwszName = pSimSettings->pwszName;
		pSimSettings->pwszName = NULL;


		//
		// Insert the string into the list.
		//
		if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
		{
			SendMessageW(GetDlgItem(hWnd, IDCB_SETTINGS),
						CB_INSERTSTRING,
						(WPARAM) (g_dwNumSimSettings - 2),
						(LPARAM) pwszName);
		}
		else
		{
			dwNameSize = wcslen(pwszName) + 1;

			pszName = (char*) DNMalloc(dwNameSize);
			if (pszName != NULL)
			{
				hr = STR_WideToAnsi(pwszName,
									-1,
									pszName,
									&dwNameSize);
				if (hr == DPN_OK)
				{
					SendMessageA(GetDlgItem(hWnd, IDCB_SETTINGS),
								CB_INSERTSTRING,
								(WPARAM) (g_dwNumSimSettings - 2),
								(LPARAM) pszName);
				}
				else
				{
					SendMessageA(GetDlgItem(hWnd, IDCB_SETTINGS),
								CB_INSERTSTRING,
								(WPARAM) (g_dwNumSimSettings - 2),
								(LPARAM) "???");
				}
			}
			else
			{
				SendMessageA(GetDlgItem(hWnd, IDCB_SETTINGS),
							CB_INSERTSTRING,
							(WPARAM) (g_dwNumSimSettings - 2),
							(LPARAM) "???");
			}
		}

		//
		// Select this new item.
		//
		SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
					CB_SETCURSEL,
					(WPARAM) (g_dwNumSimSettings - 2),
					0);


		//
		// Disable Save As, since we just did.
		//
		EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), FALSE);
	}


	//
	// Write this item to the registry (overwrites anything that existed).
	//

	hr = RegCreateKey(HKEY_CURRENT_USER, REG_KEY_CUSTOMSETTINGS, &hKey);
	if (hr != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, 0, "Couldn't create custom settings key!");
		goto Failure;
	}


#ifdef UNICODE
	hr = RegSetValueExW(hKey,
						pwszName,
						0,
						REG_BINARY,
						(BYTE*) pSimSettings,
						sizeof(SIMSETTINGS));
#else // ! UNICODE
	hr = RegSetValueExA(hKey,
						pszName,
						0,
						REG_BINARY,
						(BYTE*) pSimSettings,
						sizeof(SIMSETTINGS));
#endif // ! UNICODE
	if (hr != ERROR_SUCCESS)
	{
		DPFX(DPFPREP, 0, "Couldn't write value!");
		goto Failure;
	}

	RegCloseKey(hKey);
	hKey = NULL;

	hr = DP8SIM_OK;


Exit:

	if (pszName != NULL)
	{
		DNFree(pszName);
		pszName = NULL;
	}

	return hr;


Failure:

	if (hKey != NULL)
	{
		RegCloseKey(hKey);
		hKey = NULL;
	}

	goto Exit;
} // SaveSimSettings




#undef DPF_MODNAME
#define DPF_MODNAME "InitializeUserInterface()"
//=============================================================================
// InitializeUserInterface
//-----------------------------------------------------------------------------
//
// Description: Prepares the user interface.
//
// Arguments:
//	HINSTANCE hInstance		- Handle to current application instance.
//	int iShowCmd			- Show state of window.
//
// Returns: HRESULT
//=============================================================================
HRESULT InitializeUserInterface(HINSTANCE hInstance, int iShowCmd)
{
	HRESULT		hr = S_OK;
	WNDCLASSEX	wcex;


	DPFX(DPFPREP, 6, "Parameters: (0x%p, %i)", hInstance, iShowCmd);


	/*
	//
	// Setup common controls (we need the listview item).
	//
	InitCommonControls();
	*/


	//
	// Register the main window class
	//
	ZeroMemory(&wcex, sizeof (WNDCLASSEX));
	wcex.cbSize = sizeof(wcex);
	GetClassInfoEx(NULL, WC_DIALOG, &wcex);
	wcex.lpfnWndProc = MainWindowDlgProc;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = WINDOWCLASS_MAIN;
	wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	if (! RegisterClassEx(&wcex))
	{
		hr = GetLastError();

		DPFX(DPFPREP, 0, "Couldn't register main window class (err = 0x%lx)!", hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto Failure;
	}


	//
	// Register the Save As/Name Settings window class
	//
	ZeroMemory(&wcex, sizeof (WNDCLASSEX));
	wcex.cbSize = sizeof(wcex);
	GetClassInfoEx(NULL, WC_DIALOG, &wcex);
	wcex.lpfnWndProc = NameSettingsWindowDlgProc;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = WINDOWCLASS_NAMESETTINGS;
	wcex.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	if (! RegisterClassEx(&wcex))
	{
		hr = GetLastError();

		DPFX(DPFPREP, 0, "Couldn't register name settings window class (err = 0x%lx)!", hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto Failure;
	}


	//
	// Create the main window.
	//
	g_hWndMainWindow = CreateDialog(hInstance,
									MAKEINTRESOURCE(IDD_MAIN),
									NULL,
									MainWindowDlgProc);
	if (g_hWndMainWindow == NULL)
	{
		hr = GetLastError();

		DPFX(DPFPREP, 0, "Couldn't create window (err = 0x%lx)!", hr);

		if (hr == S_OK)
			hr = E_FAIL;

		goto Failure;
	}

	
	UpdateWindow(g_hWndMainWindow);
	ShowWindow(g_hWndMainWindow, iShowCmd);


Exit:

	DPFX(DPFPREP, 6, "Returning [0x%lx]", hr);

	return hr;


Failure:

	goto Exit;
} // InitializeUserInterface





#undef DPF_MODNAME
#define DPF_MODNAME "CleanupUserInterface()"
//=============================================================================
// CleanupUserInterface
//-----------------------------------------------------------------------------
//
// Description: Cleans up the user interface.
//
// Arguments: None.
//
// Returns: HRESULT
//=============================================================================
HRESULT CleanupUserInterface(void)
{
	DPFX(DPFPREP, 6, "Enter");

	DPFX(DPFPREP, 6, "Returning [S_OK]");

	return S_OK;
} // CleanupUserInterface





#undef DPF_MODNAME
#define DPF_MODNAME "DoErrorBox()"
//=============================================================================
// DoErrorBox
//-----------------------------------------------------------------------------
//
// Description: Loads error strings from the given resources, and displays an
//				error dialog with that text.
//
// Arguments:
//	HINSTANCE hInstance				- Handle to current application instance.
//	HWND hWndParent					- Parent window, or NULL if none.
//	UINT uiCaptionStringRsrcID		- ID of caption string resource.
//	UINT uiTextStringRsrcID			- ID of text string resource.
//
// Returns: None.
//=============================================================================
void DoErrorBox(const HINSTANCE hInstance,
				const HWND hWndParent,
				const UINT uiCaptionStringRsrcID,
				const UINT uiTextStringRsrcID)
{
	HRESULT		hr;
	WCHAR *		pwszCaption = NULL;
	WCHAR *		pwszText = NULL;
	DWORD		dwStringLength;
	char *		pszCaption = NULL;
	char *		pszText = NULL;
	int			iReturn;


	DPFX(DPFPREP, 6, "Parameters: (0x%p, 0x%p, %u, %u)",
		hInstance, hWndParent, uiCaptionStringRsrcID, uiTextStringRsrcID);


	//
	// Load the dialog caption string.
	//
	hr = LoadAndAllocString(hInstance, uiCaptionStringRsrcID, &pwszCaption);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't load caption string (err = 0x%lx)!", hr);
		goto Exit;
	}


	//
	// Load the dialog text string.
	//
	hr = LoadAndAllocString(hInstance, uiTextStringRsrcID, &pwszText);
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "Couldn't load text string (err = 0x%lx)!", hr);
		goto Exit;
	}


	//
	// Convert the text to ANSI, if required, otherwise display the Unicode
	// message box.
	//
	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		//
		// Convert caption string to ANSI.
		//

		dwStringLength = wcslen(pwszCaption) + 1;

		pszCaption = (char*) DNMalloc(dwStringLength);
		if (pszCaption == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate memory for caption string!");
			goto Exit;
		}

		hr = STR_WideToAnsi(pwszCaption, dwStringLength, pszCaption, &dwStringLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert wide string to ANSI (err = 0x%lx)!", hr);
			goto Exit;
		}


		//
		// Convert caption string to ANSI.
		//

		dwStringLength = wcslen(pwszText) + 1;

		pszText = (char*) DNMalloc(dwStringLength);
		if (pszText == NULL)
		{
			DPFX(DPFPREP, 0, "Couldn't allocate memory for text string!");
			goto Exit;
		}

		hr = STR_WideToAnsi(pwszText, dwStringLength, pszText, &dwStringLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert wide string to ANSI (err = 0x%lx)!", hr);
			goto Exit;
		}


		iReturn = MessageBoxA(hWndParent,
							pszText,
							pszCaption,
							(MB_OK | MB_ICONERROR | MB_APPLMODAL));

		DNFree(pszText);
		pszText = NULL;

		DNFree(pszCaption);
		pszCaption = NULL;
	}
	else
	{
		iReturn = MessageBoxW(hWndParent,
							pwszText,
							pwszCaption,
							(MB_OK | MB_ICONERROR | MB_APPLMODAL));
	}

	if (iReturn != IDOK)
	{
		//
		// Something bad happened.
		//

		hr = GetLastError();

		DPFX(DPFPREP, 0, "Got unexpected return value %i when displaying message box (err = 0x%lx)!",
			iReturn, hr);
	}
	

Exit:

	if (pszText != NULL)
	{
		DNFree(pszText);
		pszText = NULL;
	}

	if (pszCaption != NULL)
	{
		DNFree(pszCaption);
		pszCaption = NULL;
	}

	if (pwszText != NULL)
	{
		DNFree(pwszText);
		pwszText = NULL;
	}

	if (pwszCaption != NULL)
	{
		DNFree(pwszCaption);
		pwszCaption = NULL;
	}


	DPFX(DPFPREP, 6, "Leave");
} // DoErrorBox




#undef DPF_MODNAME
#define DPF_MODNAME "FloatToString"
//=============================================================================
// FloatToString
//-----------------------------------------------------------------------------
//
// Description: Converts a FLOAT into a string, using the buffer supplied.
//				The value must be non-negative, and the precision must be at
//				least 1.
//				In some cases, the value may get rounded down incorrectly, so
//				a reasonably large precision is recommended.
//
// Arguments:
//	FLOAT fValue			- Value to convert.
//	int iPrecision			- Number of digits to retain after the decimal
//								point.
//	char * szBuffer			- Buffer in which to store resulting string.
//	int iBufferLength		- Maximum number of characters in buffer, including
//								NULL termination.
//
// Returns: HRESULT
//=============================================================================
void FloatToString(const FLOAT fValue,
					const int iPrecision,
					char * const szBuffer,
					const int iBufferLength)
{
	char *		pszDigitString;
	int			iDecimal;
	int			iTemp;
	char *		pSource;
	char *		pDest;


	//
	// The value must be non-negative.
	//
	DNASSERT(fValue >= 0.0);

	//
	// The precision must be at least 1.
	//
	DNASSERT(iPrecision >= 1);

	//
	// The buffer needs to be large enough to hold "0.", plus room for the
	// precision requested, plus NULL termination.
	//
	DNASSERT(iBufferLength >= (2 + iPrecision + 1));



	pszDigitString = _ecvt(fValue, (iBufferLength - 2), &iDecimal, &iTemp);
	DNASSERT(iTemp == 0);

	//
	// Treat the number differently if it's 0.0, or between 0.0 and 1.0.
	//
	if (iDecimal <= 0)
	{
		pSource = pszDigitString;
		pDest = szBuffer;


		//
		// Get the absolute decimal point position.
		//
		iDecimal *= -1;


		//
		// Use a leading "0." followed by the digit string.
		//
		(*pDest) = '0';
		pDest++;
		(*pDest) = '.';
		pDest++;


		//
		// Make sure we can even display this number.  If not, round the value
		// down to 0.0.
		//
		if (iDecimal >= iPrecision)
		{
			(*pDest) = '0';
			pDest++;
		}
		else
		{
			//
			// Fill in the appropriate number of 0s
			//
			for(iTemp = 0; iTemp < iDecimal; iTemp++)
			{
				(*pDest) = '0';
				pDest++;
			}
			
			//
			// Copy the non-zero digits indicated by _ecvt.
			// Note that this truncates down, which may cause rounding errors.
			//
			do
			{
				(*pDest) = (*pSource);
				pSource++;
				pDest++;
				iTemp++;
			}
			while (iTemp < iPrecision);
		}
	}
	else
	{
		//
		// Make sure the value isn't too large to display properly.
		//
		DNASSERT(iDecimal < (iBufferLength - 2));


		pSource = pszDigitString;
		pDest = szBuffer;


		//
		// Copy the digits to the left of the decimal.
		//
		memcpy(pDest, pSource, (iDecimal * sizeof(char)));
		pSource += iDecimal;
		pDest += iDecimal;


		//
		// Add the decimal.
		//
		(*pDest) = '.';
		pDest++;


		//
		// Copy the digits to the right of the decimal up to the precision.
		// Note that this truncates down, which may cause rounding errors.
		//
		memcpy(pDest, pSource, (iPrecision * sizeof(char)));
		pDest += iPrecision;
	}


	//
	// Remove all trailing '0' characters, unless there's nothing to the
	// right of the decimal point, in which case leave a single '0'.
	//

	do
	{
		pDest--;
	}
	while ((*pDest) == '0');

	if ((*pDest) == '.')
	{
		*(pDest + 2) = 0;	// NULL terminate after a '0'
	}
	else
	{
		*(pDest + 1) = 0;	// NULL terminate after this character
	}
} // FloatToString





#undef DPF_MODNAME
#define DPF_MODNAME "GetParametersFromWindow"
//=============================================================================
// GetParametersFromWindow
//-----------------------------------------------------------------------------
//
// Description: Reads in the DP8Sim parameters from the given window.
//
// Arguments:
//	HWND hWnd							- Window with parameters to read.
//	DP8SIM_PARAMETERS * pdp8spSend		- Place to store send parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Place to store receive parameters.
//
// Returns: HRESULT
//=============================================================================
void GetParametersFromWindow(HWND hWnd,
							DP8SIM_PARAMETERS * pdp8spSend,
							DP8SIM_PARAMETERS * pdp8spReceive)
{
	char	szNumber[32];


	//
	// Retrieve the send settings from the window.
	//

	ZeroMemory(pdp8spSend, sizeof(*pdp8spSend));
	pdp8spSend->dwSize					= sizeof(*pdp8spSend);
	//pdp8spSend->dwFlags				= 0;
	pdp8spSend->dwPacketHeaderSize		= DP8SIMPACKETHEADERSIZE_IP_UDP;


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber, 32);
	pdp8spSend->dwBandwidthBPS			= (DWORD) atoi(szNumber);


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber, 32);
	pdp8spSend->fPacketLossPercent		= (FLOAT) atof(szNumber);
	if (pdp8spSend->fPacketLossPercent > 100.0)
	{
		pdp8spSend->fPacketLossPercent	= 100.0;
	}
	else if (pdp8spSend->fPacketLossPercent < 0.0)
	{
		pdp8spSend->fPacketLossPercent	= 0.0;
	}


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber, 32);
	pdp8spSend->dwMinLatencyMS			= (DWORD) atoi(szNumber);


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber, 32);
	pdp8spSend->dwMaxLatencyMS			= (DWORD) atoi(szNumber);
	if (pdp8spSend->dwMaxLatencyMS < pdp8spSend->dwMinLatencyMS)
	{
		pdp8spSend->dwMaxLatencyMS		= pdp8spSend->dwMinLatencyMS;
	}



	//
	// Retrieve the receive settings from the window.
	//

	ZeroMemory(pdp8spReceive, sizeof(*pdp8spReceive));
	pdp8spReceive->dwSize					= sizeof(*pdp8spReceive);
	//pdp8spReceive->dwFlags				= 0;
	pdp8spReceive->dwPacketHeaderSize		= DP8SIMPACKETHEADERSIZE_IP_UDP;


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber, 32);
	pdp8spReceive->dwBandwidthBPS			= (DWORD) atoi(szNumber);


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber, 32);
	pdp8spReceive->fPacketLossPercent		= (FLOAT) atof(szNumber);
	if (pdp8spReceive->fPacketLossPercent > 100.0)
	{
		pdp8spReceive->fPacketLossPercent	= 100.0;
	}
	else if (pdp8spReceive->fPacketLossPercent < 0.0)
	{
		pdp8spReceive->fPacketLossPercent	= 0.0;
	}


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber, 32);
	pdp8spReceive->dwMinLatencyMS			= (DWORD) atoi(szNumber);


	GetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber, 32);
	pdp8spReceive->dwMaxLatencyMS			= (DWORD) atoi(szNumber);
	if (pdp8spReceive->dwMaxLatencyMS < pdp8spReceive->dwMinLatencyMS)
	{
		pdp8spReceive->dwMaxLatencyMS		= pdp8spReceive->dwMinLatencyMS;
	}
} // GetParametersFromWindow





#undef DPF_MODNAME
#define DPF_MODNAME "SetParametersInWindow"
//=============================================================================
// SetParametersInWindow
//-----------------------------------------------------------------------------
//
// Description: Writes the DP8Sim parameters to the given window.
//
// Arguments:
//	HWND hWnd							- Window in which to store parameters.
//	DP8SIM_PARAMETERS * pdp8spSend		- Pointer to new send parameters.
//	DP8SIM_PARAMETERS * pdp8spReceive	- Pointer to new receive parameters.
//
// Returns: HRESULT
//=============================================================================
void SetParametersInWindow(HWND hWnd,
							DP8SIM_PARAMETERS * pdp8spSend,
							DP8SIM_PARAMETERS * pdp8spReceive)
{
	char	szNumber[32];


	//
	// Write the values to the window.
	//

	wsprintfA(szNumber, "%u", pdp8spSend->dwBandwidthBPS);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_BANDWIDTH), szNumber);

	FloatToString(pdp8spSend->fPacketLossPercent, DISPLAY_PRECISION, szNumber, 32);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_DROP), szNumber);

	wsprintfA(szNumber, "%u", pdp8spSend->dwMinLatencyMS);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MINLATENCY), szNumber);

	wsprintfA(szNumber, "%u", pdp8spSend->dwMaxLatencyMS);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_SEND_MAXLATENCY), szNumber);


	wsprintfA(szNumber, "%u", pdp8spReceive->dwBandwidthBPS);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_BANDWIDTH), szNumber);

	FloatToString(pdp8spReceive->fPacketLossPercent, DISPLAY_PRECISION, szNumber, 32);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_DROP), szNumber);

	wsprintfA(szNumber, "%u", pdp8spReceive->dwMinLatencyMS);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MINLATENCY), szNumber);

	wsprintfA(szNumber, "%u", pdp8spReceive->dwMaxLatencyMS);
	SetWindowTextA(GetDlgItem(hWnd, IDE_SETTINGS_RECV_MAXLATENCY), szNumber);
} // SetParametersInWindow




#undef DPF_MODNAME
#define DPF_MODNAME "DisplayCurrentStatistics"
//=============================================================================
// DisplayCurrentStatistics
//-----------------------------------------------------------------------------
//
// Description: Retrieves the current DP8Sim statistics and displays them in
//				the given window.
//
// Arguments:
//	HWND hWnd	- Window in which to write statistics.
//
// Returns: HRESULT
//=============================================================================
void DisplayCurrentStatistics(HWND hWnd)
{
	HRESULT				hr;
	DP8SIM_STATISTICS	dp8ssSend;
	DP8SIM_STATISTICS	dp8ssReceive;
	char				szNumber[32];


	//
	// Retrieve the current statistics.
	//

	ZeroMemory(&dp8ssSend, sizeof(dp8ssSend));
	dp8ssSend.dwSize = sizeof(dp8ssSend);

	ZeroMemory(&dp8ssReceive, sizeof(dp8ssReceive));
	dp8ssReceive.dwSize = sizeof(dp8ssReceive);

	hr = g_pDP8SimControl->GetAllStatistics(&dp8ssSend, &dp8ssReceive, 0);
	if (hr != DP8SIM_OK)
	{
		DPFX(DPFPREP, 0, "Getting all statistics failed (err = 0x%lx)!", hr);
	}
	else
	{
		//
		// Write the values to the window.
		//

		wsprintfA(szNumber, "%u", dp8ssSend.dwTransmittedPackets);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_XMITPACKETS), szNumber);

		wsprintfA(szNumber, "%u", dp8ssSend.dwTransmittedBytes);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_XMITBYTES), szNumber);

		wsprintfA(szNumber, "%u", dp8ssSend.dwDroppedPackets);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_DROPPACKETS), szNumber);

		wsprintfA(szNumber, "%u", dp8ssSend.dwDroppedBytes);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_DROPBYTES), szNumber);

		wsprintfA(szNumber, "%u", dp8ssSend.dwTotalDelayMS);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_TOTALDELAY), szNumber);


		wsprintfA(szNumber, "%u", dp8ssReceive.dwTransmittedPackets);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_XMITPACKETS), szNumber);

		wsprintfA(szNumber, "%u", dp8ssReceive.dwTransmittedBytes);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_XMITBYTES), szNumber);

		wsprintfA(szNumber, "%u", dp8ssReceive.dwDroppedPackets);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_DROPPACKETS), szNumber);

		wsprintfA(szNumber, "%u", dp8ssReceive.dwDroppedBytes);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_DROPBYTES), szNumber);

		wsprintfA(szNumber, "%u", dp8ssReceive.dwTotalDelayMS);
		SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_TOTALDELAY), szNumber);
	}
} // DisplayCurrentStatistics






#undef DPF_MODNAME
#define DPF_MODNAME "MainWindowDlgProc()"
//=============================================================================
// MainWindowDlgProc
//-----------------------------------------------------------------------------
//
// Description: Main dialog window message handling.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//=============================================================================
INT_PTR CALLBACK MainWindowDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HRESULT				hr;
	//HMENU				hSysMenu;
	HWND				hWndSubItem;
	int					iIndex;
	DP8SIM_PARAMETERS	dp8spSend;
	DP8SIM_PARAMETERS	dp8spReceive;
	BOOL				fTemp;


	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			/*
			//
			// Disable 'maximize' and 'size' on the system menu.
			//
			hSysMenu = GetSystemMenu(hWnd, FALSE);
	
			EnableMenuItem(hSysMenu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
			EnableMenuItem(hSysMenu, SC_SIZE, MF_BYCOMMAND | MF_GRAYED);
			*/


			//
			// Fill in the list of built-in settings.
			//
			hWndSubItem = GetDlgItem(hWnd, IDCB_SETTINGS);
			for(iIndex = 0; iIndex < (int) g_dwNumSimSettings; iIndex++)
			{
				if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
				{
					SendMessageW(hWndSubItem,
								CB_INSERTSTRING,
								(WPARAM) -1,
								(LPARAM) g_paSimSettings[iIndex].pwszName);
				}
				else
				{
					char *	pszName;
					DWORD	dwNameSize;


					dwNameSize = wcslen(g_paSimSettings[iIndex].pwszName) + 1;

					pszName = (char*) DNMalloc(dwNameSize);
					if (pszName != NULL)
					{
						hr = STR_WideToAnsi(g_paSimSettings[iIndex].pwszName,
											-1,
											pszName,
											&dwNameSize);
						if (hr == DPN_OK)
						{
							SendMessageA(hWndSubItem,
										CB_INSERTSTRING,
										(WPARAM) -1,
										(LPARAM) pszName);
						}
						else
						{
							SendMessageA(hWndSubItem,
										CB_INSERTSTRING,
										(WPARAM) -1,
										(LPARAM) "???");
						}

						DNFree(pszName);
					}
					else
					{
						SendMessageA(hWndSubItem,
									CB_INSERTSTRING,
									(WPARAM) -1,
									(LPARAM) "???");
					}
				}
			}

			//
			// Select the last item.
			//
			SendMessage(hWndSubItem, CB_SETCURSEL, (WPARAM) (iIndex - 1), 0);


			//
			// Retrieve the current settings.
			//

			ZeroMemory(&dp8spSend, sizeof(dp8spSend));
			dp8spSend.dwSize = sizeof(dp8spSend);

			ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
			dp8spReceive.dwSize = sizeof(dp8spReceive);

			hr = g_pDP8SimControl->GetAllParameters(&dp8spSend, &dp8spReceive, 0);
			if (hr != DP8SIM_OK)
			{
				DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);
			}
			else
			{
				//
				// Write the values to the window.
				//
				SetParametersInWindow(hWnd, &dp8spSend, &dp8spReceive);


				//
				// SetParametersInWindow updated the edit boxes, and thus
				// caused the "Custom" settings item to get selected.
				// See if these settings match any of the presets, and if
				// so, politely reset the combo box back to the appropriate
				// item.
				//
				for(iIndex = 0; iIndex < (int) (g_dwNumSimSettings - 1); iIndex++)
				{
					if ((memcmp(&dp8spSend, &(g_paSimSettings[iIndex].dp8spSend), sizeof(dp8spSend)) == 0) &&
						(memcmp(&dp8spReceive, &(g_paSimSettings[iIndex].dp8spReceive), sizeof(dp8spReceive)) == 0))
					{
						SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
									CB_SETCURSEL,
									(WPARAM) iIndex,
									0);
						break;
					}
				}

				//
				// Enable "Save As" if on the Custom setting.
				//
				if (iIndex == (int) (g_dwNumSimSettings - 1))
				{
					EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), TRUE);
				}
				else
				{
					EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), FALSE);				
				}
			}


			//
			// Display the current statistics.
			//
			DisplayCurrentStatistics(hWnd);


			//
			// Turn on auto-refresh by default.
			//

			Button_SetCheck(GetDlgItem(hWnd, IDCHK_AUTOREFRESH), BST_CHECKED);

			g_uiAutoRefreshTimer = SetTimer(hWnd,
											AUTOREFRESH_TIMERID,
											AUTOREFRESH_INTERVAL,
											NULL);
			if (g_uiAutoRefreshTimer == 0)
			{
				DPFX(DPFPREP, 0, "Couldn't initially start auto-refresh timer!", 0);
				Button_SetCheck(GetDlgItem(hWnd, IDCHK_AUTOREFRESH),
								BST_UNCHECKED);
			}
			break;
		}

		case WM_SIZE:
		{
			/*
			//
			// Fix a bug in the windows dialog handler.
			//
			if ((wParam == SIZE_RESTORED) || (wParam == SIZE_MINIMIZED))
			{
				hSysMenu = GetSystemMenu(hWnd, FALSE);

				EnableMenuItem(hSysMenu, SC_MINIMIZE, MF_BYCOMMAND | (wParam == SIZE_RESTORED) ? MF_ENABLED : MF_GRAYED);
				EnableMenuItem(hSysMenu, SC_RESTORE, MF_BYCOMMAND | (wParam == SIZE_MINIMIZED) ? MF_ENABLED : MF_GRAYED);
			}
			*/
			break;
		}

		case WM_CLOSE:
		{
			//
			// Save the result code for how we quit.
			//
			hr = (HRESULT) wParam;


			//
			// Kill the auto-refresh timer, if it was running.
			//
			if (g_uiAutoRefreshTimer != 0)
			{
				KillTimer(hWnd, g_uiAutoRefreshTimer);
				g_uiAutoRefreshTimer = 0;
			}


			DPFX(DPFPREP, 1, "Closing main window (hresult = 0x%lx).", hr);

			PostQuitMessage(hr);
			break;
		}

		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDCB_SETTINGS:
				{
					DPFX(DPFPREP, 0, "IDCB_SETTINGS, selection = %i",
						SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS), CB_GETCURSEL, 0, 0));

					//
					// If the settings selection has been modified, update the
					// data with the new settings (if control is enabled).
					//
					if (HIWORD(wParam) == CBN_SELCHANGE)
					{
						//
						// Find out what is now selected.  Casting is okay,
						// there should not be more than an int's worth of
						// built-in items in 64-bit.
						//
						iIndex = (int) SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
													CB_GETCURSEL,
													0,
													0);

						//
						// Only use the index if it's valid.
						//
						if ((iIndex >= 0) && (iIndex < (int) g_dwNumSimSettings))
						{
							//
							// Copy in the item's settings.
							//
							memcpy(&dp8spSend, &g_paSimSettings[iIndex].dp8spSend, sizeof(dp8spSend));
							memcpy(&dp8spReceive, &g_paSimSettings[iIndex].dp8spReceive, sizeof(dp8spReceive));


							//
							// If it's the custom item, use the current
							// settings and enable the Save As button.
							//
							if (iIndex == (int) (g_dwNumSimSettings - 1))
							{
								//
								// Retrieve the current settings.
								//

								ZeroMemory(&dp8spSend, sizeof(dp8spSend));
								dp8spSend.dwSize = sizeof(dp8spSend);

								ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
								dp8spReceive.dwSize = sizeof(dp8spReceive);

								hr = g_pDP8SimControl->GetAllParameters(&dp8spSend,
																		&dp8spReceive,
																		0);
								if (hr != DP8SIM_OK)
								{
									DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);

									//
									// Oh well, just use whatever we have.
									//
								}
							}


							//
							// Write the values to the window.
							//
							SetParametersInWindow(hWnd, &dp8spSend, &dp8spReceive);


							//
							// The apply and revert buttons got enabled
							// automatically when SetParametersInWindow set the
							// edit boxes' values.
							//
							//EnableWindow(GetDlgItem(hWnd, IDB_APPLY), TRUE);
							//EnableWindow(GetDlgItem(hWnd, IDB_REVERT), TRUE);


							//
							// Reselect the item that got us here, since
							// setting the edit boxes' values automatically
							// selected the "Custom" item.
							//
							SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
										CB_SETCURSEL,
										(WPARAM) iIndex,
										0);

							//
							// Reset the Save As status depending on whether
							// we reselected the Custom or not.
							//
							EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS),
										((iIndex == (int) (g_dwNumSimSettings - 1)) ? TRUE : FALSE));
						}
						else
						{
							DPFX(DPFPREP, 0, "Settings selection is invalid (%i)!",
								iIndex);
						}
					}

					break;
				}

				case IDE_SETTINGS_SEND_BANDWIDTH:
				case IDE_SETTINGS_SEND_DROP:
				case IDE_SETTINGS_SEND_MINLATENCY:
				case IDE_SETTINGS_SEND_MAXLATENCY:

				case IDE_SETTINGS_RECV_BANDWIDTH:
				case IDE_SETTINGS_RECV_DROP:
				case IDE_SETTINGS_RECV_MINLATENCY:
				case IDE_SETTINGS_RECV_MAXLATENCY:
				{
					//
					// If the edit boxes have been modified, enable the Apply
					// and Revert buttons (if control is enabled and the data
					// actually changed).
					//
					if (HIWORD(wParam) == EN_UPDATE)
					{
						//
						// Retrieve the current settings.
						//

						ZeroMemory(&dp8spSend, sizeof(dp8spSend));
						dp8spSend.dwSize = sizeof(dp8spSend);

						ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
						dp8spReceive.dwSize = sizeof(dp8spReceive);

						hr = g_pDP8SimControl->GetAllParameters(&dp8spSend, &dp8spReceive, 0);
						if (hr != DP8SIM_OK)
						{
							DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);
						}
						else
						{
							DP8SIM_PARAMETERS	dp8spSendFromUI;
							DP8SIM_PARAMETERS	dp8spReceiveFromUI;
								
							
							GetParametersFromWindow(hWnd,
													&dp8spSendFromUI,
													&dp8spReceiveFromUI);


							//
							// Enable the buttons if any data is different from
							// what is currently applied.
							//

							fTemp = FALSE;
							if (memcmp(&dp8spSendFromUI, &dp8spSend, sizeof(dp8spSend)) != 0)
							{
								fTemp = TRUE;
							}
							if (memcmp(&dp8spReceiveFromUI, &dp8spReceive, sizeof(dp8spReceive)) != 0)
							{
								fTemp = TRUE;
							}

							EnableWindow(GetDlgItem(hWnd, IDB_APPLY), fTemp);
							EnableWindow(GetDlgItem(hWnd, IDB_REVERT), fTemp);
						}

						
						//
						// Select the "Custom" settings item, which must be the
						// last item.
						//
						SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
									CB_SETCURSEL,
									(WPARAM) (g_dwNumSimSettings - 1),
									0);

						//
						// Enable Save As, since Custom is now selected.
						//
						EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), TRUE);				
					}

					break;
				}

				case IDB_APPLY:
				{
					//
					// Retrieve the settings from the window.
					//
					GetParametersFromWindow(hWnd, &dp8spSend, &dp8spReceive);


					//
					// Parsing in the parameters may have corrected some errors
					// in user entry, so write the settings we're really using
					// back out to the window.
					//
					SetParametersInWindow(hWnd, &dp8spSend, &dp8spReceive);


					//
					// SetParametersInWindow updated the edit boxes, and thus
					// caused the "Custom" settings item to get selected.
					// See if these settings match any of the presets, and if
					// so, politely reset the combo box back to the appropriate
					// item.
					//
					for(iIndex = 0; iIndex < (int) (g_dwNumSimSettings - 1); iIndex++)
					{
						if ((memcmp(&dp8spSend, &(g_paSimSettings[iIndex].dp8spSend), sizeof(dp8spSend)) == 0) &&
							(memcmp(&dp8spReceive, &(g_paSimSettings[iIndex].dp8spReceive), sizeof(dp8spReceive)) == 0))
						{
							SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
										CB_SETCURSEL,
										(WPARAM) iIndex,
										0);
							break;
						}
					}


					//
					// If the custom item is selected, enable Save As,
					// otherwise, disable it.
					//
					if (iIndex >= (int) (g_dwNumSimSettings - 1))
					{
						EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), TRUE);
					}
					else
					{
						EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), FALSE);
					}


					//
					// Store those settings.
					//
					hr = g_pDP8SimControl->SetAllParameters(&dp8spSend, &dp8spReceive, 0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Setting all parameters failed (err = 0x%lx)!", hr);
					}


					//
					// Disable the Apply and Revert buttons
					//
					EnableWindow(GetDlgItem(hWnd, IDB_APPLY), FALSE);
					EnableWindow(GetDlgItem(hWnd, IDB_REVERT), FALSE);

					break;
				}

				case IDB_REVERT:
				{
					//
					// Retrieve the current settings.
					//

					ZeroMemory(&dp8spSend, sizeof(dp8spSend));
					dp8spSend.dwSize = sizeof(dp8spSend);

					ZeroMemory(&dp8spReceive, sizeof(dp8spReceive));
					dp8spReceive.dwSize = sizeof(dp8spReceive);

					hr = g_pDP8SimControl->GetAllParameters(&dp8spSend, &dp8spReceive, 0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Getting all parameters failed (err = 0x%lx)!", hr);
					}
					else
					{
						//
						// Write the values to the window.
						//
						SetParametersInWindow(hWnd, &dp8spSend, &dp8spReceive);


						//
						// SetParametersInWindow updated the edit boxes, and
						// thus caused the "Custom" settings item to get
						// selected.  See if these settings match any of the
						// presets, and if so, politely reset the combo box
						// back to the appropriate item.
						//
						for(iIndex = 0; iIndex < (int) (g_dwNumSimSettings - 1); iIndex++)
						{
							if ((memcmp(&dp8spSend, &(g_paSimSettings[iIndex].dp8spSend), sizeof(dp8spSend)) == 0) &&
								(memcmp(&dp8spReceive, &(g_paSimSettings[iIndex].dp8spReceive), sizeof(dp8spReceive)) == 0))
							{
								SendMessage(GetDlgItem(hWnd, IDCB_SETTINGS),
											CB_SETCURSEL,
											(WPARAM) iIndex,
											0);
								break;
							}
						}
					}


					//
					// If the custom item is selected, enable Save As,
					// otherwise, disable it.
					//
					if (iIndex >= (int) (g_dwNumSimSettings - 1))
					{
						EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), TRUE);
					}
					else
					{
						EnableWindow(GetDlgItem(hWnd, IDB_SAVEAS), FALSE);
					}


					//
					// Disable the Apply and Revert buttons
					//
					EnableWindow(GetDlgItem(hWnd, IDB_APPLY), FALSE);
					EnableWindow(GetDlgItem(hWnd, IDB_REVERT), FALSE);

					break;
				}

				case IDB_SAVEAS:
				{
					SIMSETTINGS		SimSettings;


					DPFX(DPFPREP, 2, "Saving current sim settings.");

					//
					// Retrieve the settings from the window.
					//
					memset(&SimSettings, 0, sizeof(SimSettings));
					GetParametersFromWindow(hWnd,
											&SimSettings.dp8spSend,
											&SimSettings.dp8spReceive);


					//
					// Prompt the user to name the current custom settings.
					//
					hr = (HRESULT) (INT_PTR) DialogBoxParam((HINSTANCE) GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
															MAKEINTRESOURCE(IDD_NAMESETTINGS),
															hWnd,
															NameSettingsWindowDlgProc,
															(LPARAM) (&SimSettings));
					if (hr != (HRESULT) -1)
					{
						//
						// If we got a name, insert it into the table.
						//
						if (SimSettings.pwszName != NULL)
						{
							hr = SaveSimSettings(hWnd, &SimSettings);
							if (hr != DP8SIM_OK)
							{
								DPFX(DPFPREP, 0, "Couldn't add sim settings to table (err = 0x%lx)!",
									hr);

								if (SimSettings.pwszName != NULL)
								{
									DNFree(SimSettings.pwszName);
									SimSettings.pwszName = NULL;
								}
							}
						}
					}
					else
					{
						hr = GetLastError();
						DPFX(DPFPREP, 0, "Displaying name settings dialog failed (err = %u)!",
							hr);
					}
					break;
				}

				case IDCHK_AUTOREFRESH:
				{
					if (Button_GetCheck(GetDlgItem(hWnd, IDCHK_AUTOREFRESH)) == BST_CHECKED)
					{
						//
						// Set the timer, if it wasn't already.
						//
						if (g_uiAutoRefreshTimer == 0)
						{
							g_uiAutoRefreshTimer = SetTimer(hWnd,
															AUTOREFRESH_TIMERID,
															AUTOREFRESH_INTERVAL,
															NULL);
							if (g_uiAutoRefreshTimer == 0)
							{
								DPFX(DPFPREP, 0, "Couldn't start auto-refresh timer!", 0);
								Button_SetCheck(GetDlgItem(hWnd, IDCHK_AUTOREFRESH),
												BST_UNCHECKED);
							}
						}
					}
					else
					{
						//
						// Kill the timer, if it was running.
						//
						if (g_uiAutoRefreshTimer != 0)
						{
							KillTimer(hWnd, g_uiAutoRefreshTimer);
							g_uiAutoRefreshTimer = 0;
						}
					}
					break;
				}

				case IDB_REFRESH:
				{
					//
					// Display the current statistics.
					//
					DisplayCurrentStatistics(hWnd);
					break;
				}

				case IDB_CLEAR:
				{
					//
					// Clear the statistics.
					//
					hr = g_pDP8SimControl->ClearAllStatistics(0);
					if (hr != DP8SIM_OK)
					{
						DPFX(DPFPREP, 0, "Clearing all statistics failed (err = 0x%lx)!", hr);
					}
					else
					{
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_XMITPACKETS), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_XMITBYTES), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_DROPPACKETS), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_DROPBYTES), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_SEND_TOTALDELAY), "0");

						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_XMITPACKETS), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_XMITBYTES), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_DROPPACKETS), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_DROPBYTES), "0");
						SetWindowTextA(GetDlgItem(hWnd, IDT_STATS_RECV_TOTALDELAY), "0");
					}
					break;
				}

				case IDOK:
				{
					PostMessage(hWnd, WM_CLOSE, 0, 0);
					break;
				}
			} // end switch (on the button pressed/control changed)

			break;
		}

		case WM_TIMER:
		{
			//
			// Display the current statistics.
			//
			DisplayCurrentStatistics(hWnd);


			//
			// Reset the timer to update again.
			//
			g_uiAutoRefreshTimer = SetTimer(hWnd,
											AUTOREFRESH_TIMERID,
											AUTOREFRESH_INTERVAL,
											NULL);
			if (g_uiAutoRefreshTimer == 0)
			{
				DPFX(DPFPREP, 0, "Couldn't reset auto-refresh timer!", 0);
				Button_SetCheck(GetDlgItem(hWnd, IDCHK_AUTOREFRESH),
								BST_UNCHECKED);
			}
			break;
		}
	} // end switch (on the type of window message)

	return DefWindowProc(hWnd, uMsg, wParam, lParam);
} // MainWindowDlgProc






#undef DPF_MODNAME
#define DPF_MODNAME "NameSettingsWindowDlgProc()"
//=============================================================================
// NameSettingsWindowDlgProc
//-----------------------------------------------------------------------------
//
// Description: Name settings dialog window message handling.
//
// Arguments:
//	HWND hWnd		Window handle.
//	UINT uMsg		Message identifier.
//	WPARAM wParam	Depends on message.
//	LPARAM lParam	Depends on message.
//
// Returns: Depends on message.
//=============================================================================
INT_PTR CALLBACK NameSettingsWindowDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	SIMSETTINGS *		pSimSettings;
	int					iTextLength;
	DWORD				dwTemp;
#ifndef UNICODE
	char *				pszName;
#endif // ! UNICODE


	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			//
			// Retrieve the settings to be saved.
			//
			pSimSettings = (SIMSETTINGS*) lParam;

			//
			// Store the pointer off the window.
			//
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) pSimSettings);

			//
			// Set focus on the name edit text box.
			//
			SetFocus(GetDlgItem(hWnd, IDE_NAME));
			break;
		}

		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDE_NAME:
				{
					//
					// If the edit box has text, enable the OK button.
					//
					if (HIWORD(wParam) == EN_UPDATE)
					{
						if (GetWindowTextLength(GetDlgItem(hWnd, IDE_NAME)) > 0)
						{
							EnableWindow(GetDlgItem(hWnd, IDOK), TRUE);
						}
						else
						{
							EnableWindow(GetDlgItem(hWnd, IDOK), FALSE);
						}
					}

					break;
				}

				case IDOK:
				{
					pSimSettings = (SIMSETTINGS*) GetWindowLongPtr(hWnd, DWLP_USER);
					DNASSERT(pSimSettings != NULL);
					DNASSERT(pSimSettings->dp8spSend.dwSize == sizeof(DP8SIM_PARAMETERS));
					DNASSERT(pSimSettings->dp8spReceive.dwSize == sizeof(DP8SIM_PARAMETERS));

					//
					// Save the name into the sim settings object.
					//
					iTextLength = GetWindowTextLength(GetDlgItem(hWnd, IDE_NAME)) + 1; // include NULL termination
					pSimSettings->pwszName = (WCHAR*) DNMalloc(iTextLength * sizeof(WCHAR));
					if (pSimSettings->pwszName != NULL)
					{
#ifdef UNICODE
						GetWindowTextW(GetDlgItem(hWnd, IDE_NAME),
									pSimSettings->pwszName,
									iTextLength);
#else // ! UNICODE
						pszName = (char*) DNMalloc(iTextLength * sizeof(char));
						if (pSimSettings->pwszName == NULL)
						{
							DPFX(DPFPREP, 0, "Couldn't allocate memory to hold ANSI name!");
							DNFree(pSimSettings->pwszName);
							pSimSettings->pwszName = NULL;
							break;
						}

						GetWindowTextA(GetDlgItem(hWnd, IDE_NAME),
									pszName,
									iTextLength);

						if (STR_jkAnsiToWide(pSimSettings->pwszName, pszName, iTextLength) != DPN_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't convert ANSI name to Unicode!");
							DNFree(pszName);
							pszName = NULL;
							DNFree(pSimSettings->pwszName);
							pSimSettings->pwszName = NULL;
							break;
						}

						DNFree(pszName);
						pszName = NULL;
#endif // ! UNICODE

						//
						// Look for a built-in item with that name.
						//
						for(dwTemp = 0; dwTemp < g_dwNumSimSettings; dwTemp++)
						{
							//
							// If we found it, display an error, free the
							// string.
							//
							if ((g_paSimSettings[dwTemp].uiNameStringResourceID != 0) &&
								(_wcsicmp(g_paSimSettings[dwTemp].pwszName, pSimSettings->pwszName) == 0))
							{
								DPFX(DPFPREP, 0, "Found existing built-in settings with name \"%ls\"!",
									pSimSettings->pwszName);

								DoErrorBox((HINSTANCE) GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
											hWnd,
											IDS_ERROR_CAPTION_BUILTINSETTINGSWITHSAMENAME,
											IDS_ERROR_TEXT_BUILTINSETTINGSWITHSAMENAME);

								DNFree(pSimSettings->pwszName);
								pSimSettings->pwszName = NULL;

								break;
							}
						}

						//
						// If we didn't find an existing item, close the
						// dialog.
						//
						if (dwTemp >= g_dwNumSimSettings)
						{
							EndDialog(hWnd, IDOK);
						}
					}
					else
					{
						DPFX(DPFPREP, 0, "Couldn't allocate memory to hold name!");
					}

					break;
				}

				case IDCANCEL:
				{
					//
					// Do nothing.
					//
					EndDialog(hWnd, IDCANCEL);
					break;
				}
			} // end switch (on the button pressed/control changed)

			break;
		}
	} // end switch (on the type of window message)

	return DefWindowProc(hWnd, uMsg, wParam, lParam);
} // NameSettingsWindowDlgProc






#undef DPF_MODNAME
#define DPF_MODNAME "LoadAndAllocString"
//=============================================================================
// LoadAndAllocString
//-----------------------------------------------------------------------------
//
// Description: DNMallocs a wide character string from the given resource ID.
//
// Arguments:
//	HINSTANCE hInstance		- Module instance handle.
//	UINT uiResourceID		- Resource ID to load.
//	WCHAR ** pwszString		- Place to store pointer to allocated string.
//
// Returns: HRESULT
//=============================================================================
HRESULT LoadAndAllocString(HINSTANCE hInstance, UINT uiResourceID, WCHAR ** pwszString)
{
	HRESULT		hr = DPN_OK;
	int			iLength;
#ifdef DEBUG
	DWORD		dwError;
#endif // DEBUG


	if (DNGetOSType() == VER_PLATFORM_WIN32_NT)
	{
		WCHAR	wszTmpBuffer[MAX_RESOURCE_STRING_LENGTH];	
		

		iLength = LoadStringW(hInstance, uiResourceID, wszTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
#ifdef DEBUG
			dwError = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %d (err = %u)", uiResourceID, dwError);
#endif // DEBUG

			(*pwszString) = NULL;
			hr = DPNERR_GENERIC;
			goto Exit;
		}


		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		wcscpy((*pwszString), wszTmpBuffer);
	}
	else
	{
		char	szTmpBuffer[MAX_RESOURCE_STRING_LENGTH];
		

		iLength = LoadStringA(hInstance, uiResourceID, szTmpBuffer, MAX_RESOURCE_STRING_LENGTH );
		if (iLength == 0)
		{
#ifdef DEBUG
			dwError = GetLastError();		
			
			DPFX(DPFPREP, 0, "Unable to load resource ID %u (err = %u)!", uiResourceID, dwError);
#endif // DEBUG

			(*pwszString) = NULL;
			hr = DPNERR_GENERIC;
			goto Exit;
		}

		
		(*pwszString) = (WCHAR*) DNMalloc((iLength + 1) * sizeof(WCHAR));
		if ((*pwszString) == NULL)
		{
			DPFX(DPFPREP, 0, "Memory allocation failure!");
			hr = DPNERR_OUTOFMEMORY;
			goto Exit;
		}


		hr = STR_jkAnsiToWide((*pwszString), szTmpBuffer, (iLength + 1));
		if (hr != DPN_OK)
		{
			DPFX(DPFPREP, 0, "Unable to convert from ANSI to Unicode (err = 0x%lx)!", hr);
			goto Exit;
		}
	}


Exit:

	return hr;
} // LoadAndAllocString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\sessionparser.hpp ===
#ifndef _SessionParser_H_
#define _SessionParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SessionRegister( HPROTOCOL i_hSessionProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SessionDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSessionFrame    - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSessionFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SessionRecognizeFrame( HFRAME        i_hFrame,
													ULPBYTE        i_upbMacFrame,	
													ULPBYTE        i_upbSessionFrame,
                                   					DWORD         i_dwMacType,        
                                   					DWORD         i_dwBytesLeft,      
                                   					HPROTOCOL     i_hPrevProtocol,  
                                   					DWORD         i_dwPrevProtOffset,
                                   					LPDWORD       o_pdwProtocolStatus,
                                   					LPHPROTOCOL   o_hNextProtocol,
												    PDWORD_PTR    io_pdwptrInstData );


// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Sessionecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSessionFrame   - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData       - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSessionFrame.
//
DPLAYPARSER_API LPBYTE BHAPI SessionAttachProperties( HFRAME      i_hFrame,
													  ULPBYTE      i_upbMacFrame,
													  ULPBYTE      i_upbSessionFrame,
													  DWORD       i_dwMacType,
													  DWORD       i_dwBytesLeft,
													  HPROTOCOL   i_hPrevProtocol,
													  DWORD       i_dwPrevProtOffset,
													  DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is diSessionlayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbSessionFrame	- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSessionFrame.
//
DPLAYPARSER_API DWORD BHAPI SessionFormatProperties( HFRAME          i_hFrame,
													 ULPBYTE          i_upbMacFrame,
													 ULPBYTE          i_upbSessionFrame,
													 DWORD           i_dwPropertyInsts,
													 LPPROPERTYINST  i_pPropInst );

bool CreateSessionProtocol( void );
void DestroySessionProtocol( void );


#endif // _SessionParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\dplay8parser.hpp ===
#ifndef _DPlayParser_H_
#define _DPlayParser_H_

#include <stdlib.h>	// itoa declaration

// NetMon API
#include "netmon.h"

// DPlay Debug library
#include "DnDBG.h"

// This is the standard way of creating macros which make exporting from a DLL simpler.
// All files within this DLL are compiled with the DPLAYPARSER_EXPORTS symbol defined on the command line.
// This symbol should NOT be defined on any other project that uses this DLL. This way any other project
// whose source files include this file see DPLAYPARSER_API functions as being imported from a DLL, whereas
// this DLL sees the symbols defined with this macro as being exported.
#if defined(DPLAYPARSER_EXPORTS)

	#define DPLAYPARSER_API __declspec(dllexport)

#else

	#define DPLAYPARSER_API __declspec(dllimport)

#endif


// DESCRIPTION: Identifies the parser, or parsers that are located in the DLL.
//
// NOTE: ParserAutoInstallInfo should be implemented in all parser DLLs.
//
// ARGUMENTS: NONE
//
// RETURNS: Success: PF_PARSERDLLINFO structure that describes the parsers in the DLL.
//			Failiure: NULL
//
DPLAYPARSER_API PPF_PARSERDLLINFO WINAPI ParserAutoInstallInfo( void );


#endif // _DPlayParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\sessionparser.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SessionParser.cpp
 *  Content:    DirectPlay Service Provider Parser
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *	08/08/00    micmil	Created
 *	08/11/00	rodtoll	Bug #42171 -- Build break
 *	01/26/01	minara	Removed unused structures
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


//==================//
// Standard headers //
//==================//
#pragma warning(push)
#pragma warning(disable : 4786)	// The identifier string exceeded the maximum allowable length and was truncated
#include <queue>
#pragma warning(pop)

#include <string>
#include <winsock2.h>
#include <wsipx.h>


//=====================//
// Proprietary headers //
//=====================//

// Prototypes
#include "SessionParser.hpp"

// Session protocol headers
#include "DPlay8.h"
#include "Message.h"	 // DN_INTERNAL_MESSAGE_XXX definitions
//#include "AppDesc.h"	 // DPN_APPLICATION_DESC_INFO definition


////////////////////////////////////////////////////////////////////////////////////
// TODO: SHOULD BE MOVED TO DPLAY CORE'S HEADER FILE
////////////////////////////////////////////////////////////////////////////////////
#define	NAMETABLE_ENTRY_FLAG_LOCAL				0x0001
#define	NAMETABLE_ENTRY_FLAG_HOST				0x0002
#define	NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP	0x0004
#define	NAMETABLE_ENTRY_FLAG_GROUP				0x0010
#define	NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST	0x0020
#define	NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT	0x0040
#define	NAMETABLE_ENTRY_FLAG_PEER				0x0100
#define NAMETABLE_ENTRY_FLAG_CLIENT				0x0200
#define	NAMETABLE_ENTRY_FLAG_SERVER				0x0400
#define	NAMETABLE_ENTRY_FLAG_AVAILABLE			0x1000
#define	NAMETABLE_ENTRY_FLAG_CONNECTING			0x2000
#define	NAMETABLE_ENTRY_FLAG_DISCONNECTING		0x4000


enum
{
	NAMETABLE_ENTRY_FLAG_ANY_GROUP = NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP | NAMETABLE_ENTRY_FLAG_GROUP  |
									 NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST   | NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
};


typedef struct _DN_NAMETABLE_INFO
{
	DPNID	dpnid;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwEntryCount;
	DWORD	dwMembershipCount;
} DN_NAMETABLE_INFO;

typedef struct _DN_NAMETABLE_ENTRY_INFO
{
	DPNID	dpnid;
	DPNID	dpnidOwner;
	DWORD	dwFlags;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
	DWORD	dwDNETVersion;
	DWORD	dwNameOffset;
	DWORD	dwNameSize;
	DWORD	dwDataOffset;
	DWORD	dwDataSize;
	DWORD	dwURLOffset;
	DWORD	dwURLSize;
} DN_NAMETABLE_ENTRY_INFO;


typedef struct _DN_NAMETABLE_MEMBERSHIP_INFO
{
	DPNID	dpnidPlayer;
	DPNID	dpnidGroup;
	DWORD	dwVersion;
	DWORD	dwVersionNotUsed;
} DN_NAMETABLE_MEMBERSHIP_INFO, *PDN_NAMETABLE_MEMBERSHIP_INFO;


struct DN_INTERNAL_MESSAGE_ALL
{
	union
	{
		DN_INTERNAL_MESSAGE_CONNECT_INFO					dnConnectInfo;
		DN_INTERNAL_MESSAGE_CONNECT_FAILED					dnConnectFailed;
		DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO				dnPlayerConnectInfo;
		DN_INTERNAL_MESSAGE_REQUEST_FAILED					dnRequestFailed;
		DN_INTERNAL_MESSAGE_SEND_PLAYER_DPNID				dnSendPlayerID;
		DN_INTERNAL_MESSAGE_INSTRUCT_CONNECT				dnInstructConnect;
		DN_INTERNAL_MESSAGE_INSTRUCTED_CONNECT_FAILED		dnInstructedConnectFailed;
		DN_INTERNAL_MESSAGE_DESTROY_PLAYER					dnDestroyPlayer;
		DN_INTERNAL_MESSAGE_CREATE_GROUP					dnCreateGroup;
		DN_INTERNAL_MESSAGE_DESTROY_GROUP					dnDestroyGroup;
		DN_INTERNAL_MESSAGE_ADD_PLAYER_TO_GROUP				dnAddPlayerToGroup;
		DN_INTERNAL_MESSAGE_DELETE_PLAYER_FROM_GROUP		dnDeletePlayerFromGroup;
		DN_INTERNAL_MESSAGE_UPDATE_INFO						dnUpdateInfo;
		DN_INTERNAL_MESSAGE_HOST_MIGRATE					dnHostMigrate;
		DN_INTERNAL_MESSAGE_NAMETABLE_VERSION				dnNametableVersion;
		DN_INTERNAL_MESSAGE_RESYNC_VERSION					dnResyncVersion;
		DN_INTERNAL_MESSAGE_REQ_NAMETABLE_OP				dnReqNametableOp;
		DN_INTERNAL_MESSAGE_ACK_NAMETABLE_OP				dnAckNametableOp;
		DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION			dnReqProcessCompletion;
		DN_INTERNAL_MESSAGE_PROCESS_COMPLETION				dnProcessCompletion;
		DN_INTERNAL_MESSAGE_TERMINATE_SESSION				dnTerminateSession;
		DN_INTERNAL_MESSAGE_INTEGRITY_CHECK					dnIntegrityCheck;
		DN_INTERNAL_MESSAGE_INTEGRITY_CHECK_RESPONSE		dnIntegrityCheckResponse;
	
		DPN_APPLICATION_DESC_INFO							dnUpdateAppDescInfo;
		DN_NAMETABLE_ENTRY_INFO								dnAddPlayer;

		struct
		{
			DN_INTERNAL_MESSAGE_REQ_PROCESS_COMPLETION dnReqProcessCompletionHeader;
			union
			{
				DN_INTERNAL_MESSAGE_REQ_CREATE_GROUP					dnReqCreateGroup;
				DN_INTERNAL_MESSAGE_REQ_DESTROY_GROUP					dnReqDestroyGroup;
				DN_INTERNAL_MESSAGE_REQ_ADD_PLAYER_TO_GROUP				dnReqAddPlayerToGroup;
				DN_INTERNAL_MESSAGE_REQ_DELETE_PLAYER_FROM_GROUP		dnReqDeletePlayerFromGroup;
				DN_INTERNAL_MESSAGE_REQ_UPDATE_INFO						dnReqUpdateInfo;
				DN_INTERNAL_MESSAGE_REQ_INTEGRITY_CHECK					dnReqIntegrityCheck;
			};
		};

		BYTE												bOffsetBase;	// used as a base for fields' offsets
	};
};


struct DN_INTERNAL_MESSAGE_FULLMSG
{
	DWORD 					  dwMsgType;
	DN_INTERNAL_MESSAGE_ALL  MsgBody;
};
////////////////////////////////////////////////////////////////////////////////////


namespace
{

	HPROTOCOL 	g_hSessionProtocol;
	ULPBYTE		g_upbyPastEndOfFrame;
	
	//====================//
	// Message Type field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_DWORD g_arr_MessageTypeDWordLabels[] =
		{ { DN_MSG_INTERNAL_PLAYER_CONNECT_INFO,			"Player connection information"									 },										
		  { DN_MSG_INTERNAL_SEND_CONNECT_INFO,				"Session information"											 },										
		  { DN_MSG_INTERNAL_ACK_CONNECT_INFO,				"Session information has been acknowledged"						 },										
		  { DN_MSG_INTERNAL_SEND_PLAYER_DNID,				"Player ID"														 },	
		  { DN_MSG_INTERNAL_CONNECT_FAILED,					"Connection failed"												 },										
		  { DN_MSG_INTERNAL_INSTRUCT_CONNECT,				"Instruction to connect"										 },										
		  { DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED,		"Instruction to connect failed"									 },										
		  { DN_MSG_INTERNAL_NAMETABLE_VERSION,				"Nametable version"												 },										
		  { DN_MSG_INTERNAL_RESYNC_VERSION,					"Resync the version"											 },										
		  { DN_MSG_INTERNAL_REQ_NAMETABLE_OP,				"Reqesting a nametable"											 },										
		  { DN_MSG_INTERNAL_ACK_NAMETABLE_OP,				"Nametable acknowledgement"										 },										
		  { DN_MSG_INTERNAL_HOST_MIGRATE,					"Host migration in process"										 },										
		  { DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE,			"Host migration has been completed"								 },										
		  { DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC,		"Update application description"								 },										
		  { DN_MSG_INTERNAL_ADD_PLAYER,						"Add a player"													 },										
		  { DN_MSG_INTERNAL_DESTROY_PLAYER,					"Destroy a player"												 },										
		  { DN_MSG_INTERNAL_REQ_CREATE_GROUP,				"Requesting a group creation"									 },										
		  { DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP,		"Requesting a player addition to the group"						 },										
		  { DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP,	"Requesting a player deletion from the group"					 },										
		  { DN_MSG_INTERNAL_REQ_DESTROY_GROUP,				"Requesting a group destruction "								 },										
		  { DN_MSG_INTERNAL_REQ_UPDATE_INFO,				"Requesting information update"									 },										
		  { DN_MSG_INTERNAL_CREATE_GROUP,					"Creating a group"												 },										
		  { DN_MSG_INTERNAL_DESTROY_GROUP,					"Destroying a group"											 },										
		  { DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP,			"Adding a player to the group"									 },										
		  { DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP,		"Deleting a player from the group"								 },										
		  { DN_MSG_INTERNAL_UPDATE_INFO,					"Information update"											 },										
		  { DN_MSG_INTERNAL_BUFFER_IN_USE,					"Buffer is in use"												 },										
		  { DN_MSG_INTERNAL_REQUEST_FAILED,					"Request has failed"											 },										
		  { DN_MSG_INTERNAL_TERMINATE_SESSION,				"Terminating session"											 },										
		  { DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION,			"Initiating reliably handled message transmission"				 },										
		  { DN_MSG_INTERNAL_PROCESS_COMPLETION,				"Message has been handled by the message handler"				 },
		  { DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK,			"Requesting a host to check whether another peer is still in the session" },
		  { DN_MSG_INTERNAL_INTEGRITY_CHECK,				"Querying a peer whether it's still in the session"		 		 },										
		  { DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE,    	"Acknowledgement of being still in the session"					 } };										   

	SET g_LabeledMessageTypeDWordSet = { sizeof(g_arr_MessageTypeDWordLabels) / sizeof(LABELED_DWORD), g_arr_MessageTypeDWordLabels };


	//===================//
	// Result Code field //----------------------------------------------------------------------------------------------
	//===================//
	LABELED_DWORD g_arr_ResultCodeDWordLabels[] = { { DPN_OK,							"Success"						},
												    { DPNSUCCESS_EQUAL,               	"Success (equal)"				},
												    { DPNSUCCESS_NOTEQUAL,            	"Success (not equal)"			},
												    { DPNERR_ABORTED,					"Aborted"						},
												    { DPNERR_ADDRESSING,				"Addressing"					},
												    { DPNERR_ALREADYCLOSING,			"Already closing"				},
												    { DPNERR_ALREADYCONNECTED,			"Already connected"				},
												    { DPNERR_ALREADYDISCONNECTING,		"Already disconnecting"			},
												    { DPNERR_ALREADYINITIALIZED,		"Already initialized"			},
												    { DPNERR_BUFFERTOOSMALL,			"Buffer is too small"			},
												    { DPNERR_CANNOTCANCEL,				"Could not cancel"				},
												    { DPNERR_CANTCREATEGROUP,			"Could not create a group"		},
												    { DPNERR_CANTCREATEPLAYER,			"Could not create a player"		},
												    { DPNERR_CANTLAUNCHAPPLICATION,		"Could not launch an application"   },
												    { DPNERR_CONNECTING,				"Connecting"					},
												    { DPNERR_CONNECTIONLOST,			"Connection has been lost"		},
												    { DPNERR_CONVERSION,				"Conversion"					},
												    { DPNERR_DOESNOTEXIST,				"Does not exist"				},
												    { DPNERR_DUPLICATECOMMAND,			"Duplicate command"				},
												    { DPNERR_ENDPOINTNOTRECEIVING,		"Endpoint is not receiving"		},
												    { DPNERR_ENUMQUERYTOOLARGE,			"Enumeration query is too large"    },
												    { DPNERR_ENUMRESPONSETOOLARGE,		"Enumeration response is too large" },
												    { DPNERR_EXCEPTION,					"Exception was thrown"			},
												    { DPNERR_GENERIC,					"Generic error"					},
												    { DPNERR_GROUPNOTEMPTY,				"Group is not empty"			},
												    { DPNERR_HOSTING,                  	"Hosting"						},
												    { DPNERR_HOSTREJECTEDCONNECTION,	"Host has rejected the connection"  },
												    { DPNERR_HOSTTERMINATEDSESSION,		"Host terminated the session"	},
												    { DPNERR_INCOMPLETEADDRESS,			"Incomplete address"			},
												    { DPNERR_INVALIDADDRESSFORMAT,		"Invalid address format"		},
												    { DPNERR_INVALIDAPPLICATION,		"Invalid application"			},
												    { DPNERR_INVALIDCOMMAND,			"Invalid command"				},
												    { DPNERR_INVALIDENDPOINT,			"Invalid endpoint"				},
												    { DPNERR_INVALIDFLAGS,				"Invalid flags"					},
												    { DPNERR_INVALIDGROUP,			 	"Invalid group"					},
												    { DPNERR_INVALIDHANDLE,				"Invalid handle"				},
												    { DPNERR_INVALIDINSTANCE,			"Invalid instance"				},
												    { DPNERR_INVALIDINTERFACE,			"Invalid interface"				},
												    { DPNERR_INVALIDDEVICEADDRESS,		"Invalid device address"		},
												    { DPNERR_INVALIDOBJECT,				"Invalid object"				},
												    { DPNERR_INVALIDPARAM,				"Invalid parameter"				},
												    { DPNERR_INVALIDPASSWORD,			"Invalid password"				},
												    { DPNERR_INVALIDPLAYER,				"Invalid player"				},
												    { DPNERR_INVALIDPOINTER,			"Invalid pointer"				},
												    { DPNERR_INVALIDPRIORITY,			"Invalid priority"				},
												    { DPNERR_INVALIDHOSTADDRESS,		"Invalid host address"			},
												    { DPNERR_INVALIDSTRING,				"Invalid string"				},
												    { DPNERR_INVALIDURL,				"Invalid URL"					},
												    { DPNERR_INVALIDVERSION,			"Invalid version"				},
												    { DPNERR_NOCAPS,					"No CAPs"						},
												    { DPNERR_NOCONNECTION,				"No connection"					},
												    { DPNERR_NOHOSTPLAYER,				"No host player is present"		},
												    { DPNERR_NOINTERFACE,				"No interface"					},
												    { DPNERR_NOMOREADDRESSCOMPONENTS,	"No more address components"	},
													{ DPNERR_NORESPONSE,				"No response"					},
													{ DPNERR_NOTALLOWED,				"Not allowed"					},
													{ DPNERR_NOTHOST,					"Not a host"					},
													{ DPNERR_NOTREADY,					"Not ready"						},
													{ DPNERR_OUTOFMEMORY,				"Out of memory"					},
													{ DPNERR_PENDING,					"Pending"						},
													{ DPNERR_PLAYERLOST,				"Player has been lost"			},
													{ DPNERR_PLAYERNOTREACHABLE,		"Player is not reachable"		},													
													{ DPNERR_SENDTOOLARGE,				"Sent data is too large"		},
													{ DPNERR_SESSIONFULL,				"Session is full"				},
													{ DPNERR_TABLEFULL,					"Table is full"					},
													{ DPNERR_TIMEDOUT,					"Timed out"						},
													{ DPNERR_UNINITIALIZED,				"Uninitialized"					},
													{ DPNERR_UNSUPPORTED,				"Unsupported"					},
													{ DPNERR_USERCANCEL,				"User has canceled"				} };
			
	SET g_LabeledResultCodeDWordSet = { sizeof(g_arr_ResultCodeDWordLabels) / sizeof(LABELED_DWORD), g_arr_ResultCodeDWordLabels };


	//====================//
	// Player Flags field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_FlagsBitLabels[] = { {  0, "Not local",					"Local"				 },		// NAMETABLE_ENTRY_FLAG_LOCAL			
										   {  1, "Not a host",					"Host"				 },		// NAMETABLE_ENTRY_FLAG_HOST			
										   {  2, "Not an All Players group",	"All Players group"     },	// NAMETABLE_ENTRY_FLAG_ALL_PLAYERS_GROUP
										   {  4, "Not a group",			 		"Group"				 },		// NAMETABLE_ENTRY_FLAG_GROUP			
										   {  5, "Not a Multicast group",		"Multicast group"	 },		// NAMETABLE_ENTRY_FLAG_GROUP_MULTICAST
										   {  6, "Not an Autodestruct group",	"Autodestruct group"    },	// NAMETABLE_ENTRY_FLAG_GROUP_AUTODESTRUCT
										   {  8, "Not a peer",					"Peer"				 },		// NAMETABLE_ENTRY_FLAG_PEER			
										   {  9, "Not a client",				"Client"			 },		// NAMETABLE_ENTRY_FLAG_CLIENT			
										   { 10, "Not a server",				"Server"			 },		// NAMETABLE_ENTRY_FLAG_SERVER			
										   { 12, "Not available",				"Available"			 },		// NAMETABLE_ENTRY_FLAG_AVAILABLE		
										   { 13, "Not connecting",				"Connecting"		 },		// NAMETABLE_ENTRY_FLAG_CONNECTING		
										   { 14, "Not disconnecting",			"Disconnecting"		 } };	// NAMETABLE_ENTRY_FLAG_DISCONNECTING	

	SET g_LabeledFlagsBitSet = { sizeof(g_arr_FlagsBitLabels) / sizeof(LABELED_BIT), g_arr_FlagsBitLabels };


	//===================//
	// Info Flags field  //---------------------------------------------------------------------------------------------
	//===================//
	LABELED_BIT g_arr_InfoFlagsBitLabels[] = { { 0, "No name is included",  "Name is included" },	// DPNINFO_NAME			
											   { 1, "No data is included",  "Data is included" } };	// DPNINFO_DATA


	SET g_LabeledInfoFlagsBitSet = { sizeof(g_arr_InfoFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_InfoFlagsBitLabels };


	//====================//
	// Group Flags field  //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_GroupFlagsBitLabels[]  = { { 0, "Not an autodestruct group",  "An autodestruct group" },	// DPNGROUP_AUTODESTRUCT			
											     { 5, "Not a multicast group",	    "A multicast group"	    } };	// DPNGROUP_MULTICAST


	SET g_LabeledGroupFlagsBitSet = { sizeof(g_arr_GroupFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_GroupFlagsBitLabels };


	//===========================//
	// Maximum Number of Players //--------------------------------------------------------------------------------------------
	//===========================//
	LABELED_DWORD g_arr_MaxNumOfPlayersDWordLabels[] = { { 0, "Unlimited" } };

	SET g_LabeledMaxNumOfPlayersDWordSet = { sizeof(g_arr_MaxNumOfPlayersDWordLabels) / sizeof(LABELED_DWORD), g_arr_MaxNumOfPlayersDWordLabels };


	//=================================//
	// Player Destruction Reason field //---------------------------------------------------------------------------------------------
	//=================================//
	LABELED_DWORD g_arr_PlayerDestructionReasonDWordLabels[] = { { DPNDESTROYPLAYERREASON_NORMAL,				"Player self-destructed"	  },
													 			 { DPNDESTROYPLAYERREASON_CONNECTIONLOST,		"Connection lost"			  },
																 { DPNDESTROYPLAYERREASON_SESSIONTERMINATED,	"Session has been terminated" },
																 { DPNDESTROYPLAYERREASON_HOSTDESTROYEDPLAYER,	"Host destroyed the player"	  } };

	SET g_LabeledPlayerDestructionReasonDWordSet = { sizeof(g_arr_PlayerDestructionReasonDWordLabels) / sizeof(LABELED_DWORD), g_arr_PlayerDestructionReasonDWordLabels };
	

	////////////////////////////////
	// Custom Property Formatters   //=====================================================================================
	////////////////////////////////

	// DESCRIPTION: Custom description formatter for the Session packet summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SessionSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary;
		char arr_cBuffer[10];
		
		// Check what Session frame we are dealing with
		DN_INTERNAL_MESSAGE_FULLMSG& rBase = *reinterpret_cast<DN_INTERNAL_MESSAGE_FULLMSG*>(io_pPropertyInstance->lpData);
		
		// Message title
		switch ( rBase.dwMsgType )
		{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				if ( rBase.MsgBody.dnPlayerConnectInfo.dwNameSize )
				{
					strSummary = "Player ";
					
					enum { nMAX_PLAYER_NAME = 64 };
					char arr_cPlayerName[nMAX_PLAYER_NAME];

					WideCharToMultiByte(CP_ACP, 0,
										reinterpret_cast<WCHAR*>( &rBase.MsgBody.bOffsetBase + rBase.MsgBody.dnPlayerConnectInfo.dwNameOffset ),
										rBase.MsgBody.dnPlayerConnectInfo.dwNameSize, arr_cPlayerName, sizeof(arr_cPlayerName), NULL, NULL);

					strSummary += arr_cPlayerName;
				}
				else
				{
					strSummary = "Unnamed player";
				}

				strSummary += " is attempting to connect to the session";

				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{

				DPN_APPLICATION_DESC_INFO&	 rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(&rBase.MsgBody.dnConnectInfo + 1);

				if ( rApplicationDescInfo.dwSessionNameSize )
				{
					strSummary = "Session ";
					
					enum { nMAX_SESSION_NAME = 64 };
					char arr_cSessionName[nMAX_SESSION_NAME];

					WideCharToMultiByte(CP_ACP, 0,
										reinterpret_cast<WCHAR*>( &rBase.MsgBody.bOffsetBase + rApplicationDescInfo.dwSessionNameOffset ),
										rApplicationDescInfo.dwSessionNameSize, arr_cSessionName, sizeof(arr_cSessionName), NULL, NULL);

					strSummary += arr_cSessionName;
				}
				else
				{
					strSummary = "Unnamed session";
				}

				strSummary += " is sending its information";

				break;
			}


		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				strSummary  = "Player ID is 0x";
				strSummary += _itoa(rBase.MsgBody.dnSendPlayerID.dpnid, arr_cBuffer, 16);
				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				strSummary  = "Initiating reliably handled message transmission (SyncID=0x";
				strSummary += _itoa(rBase.MsgBody.dnReqProcessCompletion.hCompletionOp, arr_cBuffer, 16);
				strSummary += ")";
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION:
			{
				strSummary  = "Message has been handled by the message handler (SyncID=0x";
				strSummary += _itoa(rBase.MsgBody.dnProcessCompletion.hCompletionOp, arr_cBuffer, 16);
				strSummary += ")";
				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				strSummary += "Player 0x";
				strSummary += _itoa(rBase.MsgBody.dnDestroyPlayer.dpnidLeaving, arr_cBuffer, 16);
				strSummary += " is leaving the session";
				break;
			}

		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:
			{
				strSummary  = "Player 0x";
				strSummary += _itoa(rBase.MsgBody.dnDeletePlayerFromGroup.dpnidRequesting, arr_cBuffer, 16);
				strSummary += " is requesting to delete player 0x";
				strSummary += _itoa(rBase.MsgBody.dnDeletePlayerFromGroup.dpnidPlayer, arr_cBuffer, 16);
				strSummary += " from group 0x";
				strSummary += _itoa(rBase.MsgBody.dnDeletePlayerFromGroup.dpnidGroup, arr_cBuffer, 16);
				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				strSummary += "Nametable version is ";
				strSummary += _itoa(rBase.MsgBody.dnNametableVersion.dwVersion, arr_cBuffer, 10);
				break;
			}

		default:
			{
				for ( int n = 0; n < sizeof(g_arr_MessageTypeDWordLabels)/sizeof(LABELED_DWORD); ++n )
				{
					if ( g_arr_MessageTypeDWordLabels[n].Value == rBase.dwMsgType )
					{
						strSummary = g_arr_MessageTypeDWordLabels[n].Label;
						break;
					}
				}
				break;
			}
		}

		// Message highlights
		switch ( rBase.dwMsgType )
		{
		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				strSummary += " (0x";
				strSummary += _itoa(rBase.MsgBody.dnHostMigrate.dpnidOldHost, arr_cBuffer, 16);
				strSummary += " => 0x";
				strSummary += _itoa(rBase.MsgBody.dnHostMigrate.dpnidNewHost, arr_cBuffer, 16);
				strSummary += ")";
				break;
			}

		}

		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SessionSummary


	// DESCRIPTION: Custom description formatter for the Application Description summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_AppDescSummary( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary;
		char arr_cBuffer[10];

		DPN_APPLICATION_DESC_INFO&	rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(io_pProperyInstance->lpData);

		if ( rApplicationDescInfo.dwSessionNameSize )
		{
			strSummary = "Session ";
			
			enum { nMAX_SESSION_NAME = 64 };
			char arr_cSessionName[nMAX_SESSION_NAME];

			// TODO: Once NetMon supports passage of pointer types via PROPERTYINSTEX,
			// TODO: remove the less generic reference to size of DN_INTERNAL_MESSAGE_CONNECT_INFO
			WideCharToMultiByte(CP_ACP, 0,
								reinterpret_cast<WCHAR*>( reinterpret_cast<char*>(&rApplicationDescInfo) -
														sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO) +
														rApplicationDescInfo.dwSessionNameOffset ),
								rApplicationDescInfo.dwSessionNameSize, arr_cSessionName, sizeof(arr_cSessionName), NULL, NULL);

			strSummary += arr_cSessionName;
		}
		else
		{
			strSummary = "Unnamed session";
		}

		strSummary += " is hosting ";
		strSummary += _itoa(rApplicationDescInfo.dwCurrentPlayers, arr_cBuffer, 10);
		strSummary += " out of ";
		strSummary += ( rApplicationDescInfo.dwMaxPlayers == 0 ? "unlimited number of" : _itoa(rApplicationDescInfo.dwMaxPlayers, arr_cBuffer, 10) );
		strSummary += " players";

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_AppDescSummary



	// DESCRIPTION: Custom description formatter for the Name Table's summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NameTableSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		DN_NAMETABLE_INFO& rNameTableInfo = *reinterpret_cast<DN_NAMETABLE_INFO*>(io_pPropertyInstance->lpData);

		sprintf(io_pPropertyInstance->szPropertyText, "NameTable (ver=%d)", rNameTableInfo.dwVersion);

	} // FormatPropertyInstance_NameTableSummary



	// DESCRIPTION: Custom description formatter for the Application GUID field
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_ApplicationGUID( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Application GUID = ";

		REFGUID rguid = *reinterpret_cast<GUID*>(io_pPropertyInstance->lpData);

		enum
		{
			nMAX_GUID_STRING = 50	// more than enough characters for a symbolic representation of a GUID
		};

		OLECHAR arr_wcGUID[nMAX_GUID_STRING];
		StringFromGUID2(rguid, arr_wcGUID, nMAX_GUID_STRING);

		char arr_cGUID[nMAX_GUID_STRING];
		WideCharToMultiByte(CP_ACP, 0, arr_wcGUID, -1, arr_cGUID, sizeof(arr_cGUID), NULL, NULL);
		strSummary += arr_cGUID;


		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_ApplicationGUID


	
	// DESCRIPTION: Custom description formatter for the Instance GUID field
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_InstanceGUID( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Instance GUID = ";

		REFGUID rguid = *reinterpret_cast<GUID*>(io_pPropertyInstance->lpData);

		enum
		{
			nMAX_GUID_STRING = 50	// more than enough characters for a symbolic representation of a GUID
		};

		OLECHAR arr_wcGUID[nMAX_GUID_STRING];
		StringFromGUID2(rguid, arr_wcGUID, nMAX_GUID_STRING);

		char arr_cGUID[nMAX_GUID_STRING];
		WideCharToMultiByte(CP_ACP, 0, arr_wcGUID, -1, arr_cGUID, sizeof(arr_cGUID), NULL, NULL);
		strSummary += arr_cGUID;


		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_InstanceGUID


	namespace
	{
		std::string MapSetFlagsToLabels( LABELED_BIT const i_arr_FlagsBitLabels[], int i_nNumOfFlags, DWORD i_dwFlags )
		{
			std::string strString;
			int			nBit	   = 0;
			bool		bNotFirst = false;

			for ( DWORD dwBitMask = 1; dwBitMask != 0x80000000; dwBitMask <<= 1, ++nBit )
			{
				if ( (i_dwFlags & dwBitMask)  ==  dwBitMask )
				{
					for ( int n = 0; n < i_nNumOfFlags; ++n )
					{
						if ( i_arr_FlagsBitLabels[n].BitNumber == nBit)
						{
							if ( bNotFirst )
							{
								strString += ", ";
							}
							bNotFirst = true;

							strString += i_arr_FlagsBitLabels[n].LabelOn;
							break;
						}
					}
				}
			}

			return strString;

		} // MapSetFlagsToLabels

	} // Anonymous namespace



	// DESCRIPTION: Custom description formatter for the Flags summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_FlagsSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Flags: ";

		DWORD dwFlags = *reinterpret_cast<DWORD*>(io_pPropertyInstance->lpData);

		if ( dwFlags == 0 )
		{
			strSummary += "Must be zero";
		}
		else
		{
			strSummary += MapSetFlagsToLabels(g_arr_FlagsBitLabels, sizeof(g_arr_FlagsBitLabels)/sizeof(LABELED_BIT), dwFlags);
		}
		
		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_FlagsSummary


	// DESCRIPTION: Custom description formatter for the Information Flags summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_InfoFlagsSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Information Flags: ";

		DWORD dwInfoFlags = *reinterpret_cast<DWORD*>(io_pPropertyInstance->lpData);
		
		if ( dwInfoFlags == 0 )
		{
			strSummary += "Must be zero";
		}
		else
		{
			strSummary += MapSetFlagsToLabels(g_arr_InfoFlagsBitLabels, sizeof(g_arr_InfoFlagsBitLabels)/sizeof(LABELED_BIT), dwInfoFlags);
		}
		
		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_InfoFlagsSummary


	// DESCRIPTION: Custom description formatter for the Group Flags summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_GroupFlagsSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		std::string strSummary = "Group Flags: ";

		DWORD dwGroupFlags = *reinterpret_cast<DWORD*>(io_pPropertyInstance->lpData);
		
		if ( dwGroupFlags == 0 )
		{
			strSummary += "Must be zero";
		}
		else
		{
			strSummary += MapSetFlagsToLabels(g_arr_GroupFlagsBitLabels, sizeof(g_arr_GroupFlagsBitLabels)/sizeof(LABELED_BIT), dwGroupFlags);
		}
		
		strcpy(io_pPropertyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_GroupFlagsSummary



	// DESCRIPTION: Custom description formatter for the Version summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_VersionSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		sprintf(io_pPropertyInstance->szPropertyText, "Version: 0x%08X", *((DWORD*)(io_pPropertyInstance->lpByte)));

	} // FormatPropertyInstance_VersionSummary



	// DESCRIPTION: Custom description formatter for the Player ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayerID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "Player ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_PlayerID



	// DESCRIPTION: Custom description formatter for the Old Host ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_OldHostID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "Old Host ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_OldHostID

	
	
	// DESCRIPTION: Custom description formatter for the New Host ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NewHostID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "New Host ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_NewHostID


	// DESCRIPTION: Custom description formatter for the Group ID property
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_GroupID( LPPROPERTYINST io_pPropertyInstance )
	{
		
		sprintf(io_pPropertyInstance->szPropertyText, "Group ID = 0x%X", *io_pPropertyInstance->lpDword);

	} // FormatPropertyInstance_GroupID

	

	struct NAMETABLEENTRY_INSTDATA
	{
		DN_INTERNAL_MESSAGE_ALL* pBase;
		DWORD dwEntry;	// if -1, then not printed
	};


	// DESCRIPTION: Custom description formatter for the NameTable Entry summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NameTableEntrySummary( LPPROPERTYINST io_pPropertyInstance )
	{

		DN_NAMETABLE_ENTRY_INFO& rNameTableEntry = *reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(io_pPropertyInstance->lpPropertyInstEx->lpData);
		
		NAMETABLEENTRY_INSTDATA& rInstData = *reinterpret_cast<NAMETABLEENTRY_INSTDATA*>(io_pPropertyInstance->lpPropertyInstEx->Byte);
		
		enum { nMAX_PLAYER_NAME = 64 };
		char arr_cPlayerName[nMAX_PLAYER_NAME];

		if ( rNameTableEntry.dwNameSize )
		{
			// Convert the UNICODE name into its ANSI equivalent
			WideCharToMultiByte(CP_ACP, 0, reinterpret_cast<WCHAR*>(&rInstData.pBase->bOffsetBase + rNameTableEntry.dwNameOffset),
								rNameTableEntry.dwNameSize, arr_cPlayerName, sizeof(arr_cPlayerName), NULL, NULL);
		}
		else
		{
			strcpy(arr_cPlayerName, "No name");
		}

		if ( rInstData.dwEntry == -1 )
		{
			sprintf(io_pPropertyInstance->szPropertyText, "%s (ID=0x%X) (%s)", arr_cPlayerName, rNameTableEntry.dpnid,
					MapSetFlagsToLabels(g_arr_FlagsBitLabels, sizeof(g_arr_FlagsBitLabels)/sizeof(LABELED_BIT), rNameTableEntry.dwFlags).c_str());
		}
		else
		{
			sprintf(io_pPropertyInstance->szPropertyText, "%d.  %s (ID=0x%X) (%s)", rInstData.dwEntry, arr_cPlayerName, rNameTableEntry.dpnid,
					MapSetFlagsToLabels(g_arr_FlagsBitLabels, sizeof(g_arr_FlagsBitLabels)/sizeof(LABELED_BIT), rNameTableEntry.dwFlags).c_str());
		}
		
	} // FormatPropertyInstance_NameTableEntrySummary


	// DESCRIPTION: Custom description formatter for the NameTable Entry summary
	//
	// ARGUMENTS: io_pPropertyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_NameTableMembershipSummary( LPPROPERTYINST io_pPropertyInstance )
	{

		DN_NAMETABLE_MEMBERSHIP_INFO& rNameTableMembershipInfo = *reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(io_pPropertyInstance->lpPropertyInstEx->lpData);

		sprintf(io_pPropertyInstance->szPropertyText, "%d. Player 0x%X is in group 0x%X (ver=%d)", io_pPropertyInstance->lpPropertyInstEx->Dword[0],
				rNameTableMembershipInfo.dpnidPlayer, rNameTableMembershipInfo.dpnidGroup, rNameTableMembershipInfo.dwVersion);

	} // FormatPropertyInstance_NameTableMembershipSummary



	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_SessionProperties[] = 
	{

		// Session packet summary property (SESSION_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "DPlay Session packet",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_SessionSummary		// generic formatter
		},

		// Message Type property (SESSION_UNPARSABLEFRAGMENT)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "This is a non-initial part of the fragmented Transport layer message and can not be parsed", // label
		    "Unparsable fragment summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Message Type property (SESSION_INCOMPLETEMESSAGE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "The rest of the data needed to parse this message has been sent in a separate fragment and can not be parsed",  // label
		    "Incomplete message summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property (SESSION_INCOMPLETEFIELD)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "The rest of the data needed to parse this field is in a separate fragment. Field value may look corrupted!",  // label
		    "Incomplete field summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    150,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property (SESSION_MESSAGETYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message Type",								// label
		    "Message Type field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledMessageTypeDWordSet,				// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's ID property (SESSION_PLAYERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player ID",								// label
		    "Player ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayerID				// generic formatter
		},

		// Result Code property (SESSION_RESULTCODE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Result Code",								// label
		    "Result Code field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type (HRESULT)
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledResultCodeDWordSet,				// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  DPlay Version property (SESSION_DPLAYVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "DPlay's version",							// label
		    "DPlay's version field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_VersionSummary		// generic formatter
		},

		//  Build Day property (SESSION_BUILDDAY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build's Day",								// label
		    "Build's Day field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		//  Build Month property (SESSION_BUILDMONTH)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build's Month",							// label
		    "Build's Month field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Build Year property (SESSION_BUILDYEAR)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build's Year (starting from 2000)",		// label
		    "Build's Year field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Flags summary property (SESSION_FLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Flags summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_FlagsSummary			// generic formatter
		},

		//  Flags property (SESSION_FLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Flags",									// label
		    "Flags field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledFlagsBitSet,						// labeled bit set 
		    2048,										// description's maximum length
		    FormatPropertyInstance      				// generic formatter
		},

		//  Flags summary property (SESSION_INFOFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Information Flags summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_InfoFlagsSummary		// generic formatter
		},

		//  Flags property (SESSION_INFOFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Information Flags",						// label
		    "Information Flags field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledInfoFlagsBitSet,					// labeled bit set 
		    2048,										// description's maximum length
		    FormatPropertyInstance      				// generic formatter
		},

		//  Flags summary property (SESSION_GROUPFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Group Flags summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_GroupFlagsSummary	// generic formatter
		},

		//  Flags property (SESSION_GROUPFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Group Flags",								// label
		    "Group Flags field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledGroupFlagsBitSet,					// labeled bit set 
		    2048,										// description's maximum length
		    FormatPropertyInstance      				// generic formatter
		},

		//  Offset property (SESSION_FIELDOFFSET)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Offset",									// label
		    "Offset field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Size property (SESSION_FIELDSIZE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Size",										// label
		    "Size field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Session Name property (SESSION_SESSIONNAME)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session Name",								// label
		    "Session Name field",						// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Session Name summary property (SESSION_NOSESSIONNAME_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Session Name",							// label
		    "No Session Name summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player Name property (SESSION_PLAYERNAME)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player name",								// label
		    "Player name field",						// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Player Name summary property (SESSION_NOPLAYERNAME_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Player Name",							// label
		    "No Player Name summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Data property (SESSION_DATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Data",										// label
		    "Data field",								// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Data summary property (SESSION_NODATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Data",									// label
		    "No Data summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Data property (SESSION_REPLY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Reply",									// label
		    "Reply field",								// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Data summary property (SESSION_NOREPLY_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Reply",									// label
		    "No Reply summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Password property (SESSION_PASSWORD)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Password",									// label
		    "Password field",							// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Password summary property (SESSION_NOPASSWORD_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Password",								// label
		    "No Password summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance                		// generic formatter
		},
		
		// Connection Data property (SESSION_CONNECTIONDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Connection Data",							// label
		    "Connection Data field",					// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No Connection Data summary property (SESSION_NOCONNECTIONDATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Connection Data",						// label
		    "No Connection Data summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// URL property (SESSION_URL)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "URL",										// label
		    "URL field",								// status-bar comment
		    PROP_TYPE_STRING,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// No URL summary property (SESSION_NOURL_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No URL",									// label
		    "No URL summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Application GUID property (SESSION_APPGUID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Application GUID",							// label
		    "Application GUID field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_ApplicationGUID		// generic formatter
		},

		// Instance GUID property (SESSION_INSTGUID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Instance GUID",							// label
		    "Instance GUID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_InstanceGUID			// generic formatter
		},
	
		// Application Description summary property (SESSION_APPDESCINFO_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Application Description summary",			// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance_AppDescSummary		// generic formatter
		},

		// Application Description's Size property (SESSION_APPDESCINFOSIZE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Application Description's Size",			// label
		    "Application Description's Size field",		// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Maximum Number of Players property (SESSION_MAXPLAYERS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Maximum Number of Players",				// label
		    "Maximum Number of Players field",			// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledMaxNumOfPlayersDWordSet,			// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Current Number of Players property (SESSION_CURRENTPLAYERS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Current Number of Players",				// label
		    "Current Number of Players field",			// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Reserved Data property (SESSION_RESERVEDDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Reserved Data",							// label
		    "Reserved Data",							// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// No Reserved Data summary property (SESSION_NORESERVEDDATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Reserved Data",							// label
		    "No Reserved Data summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Application Reserved Data property (SESSION_APPRESERVEDDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Application Reserved Data",				// label
		    "Application Reserved Data",				// status-bar comment
		    PROP_TYPE_VOID,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		    
		// No Application Reserved Data summary property (SESSION_NOAPPRESERVEDDATA_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "No Application Reserved Data",				// label
		    "No Application Reserved Data summary",		// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable's summary property (SESSION_NAMETABLEINFO_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "NameTable's summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance_NameTableSummary		// generic formatter
		},

		//  Version property (SESSION_VERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Version",									// label
		    "Version field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  RESERVED property (SESSION_RESERVED)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "RESERVED",									// label
		    "RESERVED field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
	
		//  Number of Entries in the NameTable property (SESSION_NUMBEROFENTRIES)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Entries",						// label
		    "Number of Entries field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		//  Number of Memberships in the NameTable property (SESSION_NUMBEROFMEMBERSHIPS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Memberships",					// label
		    "Number of Memberships field",				// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable Entry summary property (SESSION_PLAYERS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Players",									// label
		    "NameTable player entries summary",			// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// NameTable Entry summary property (SESSION_GROUPS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Groups",									// label
		    "NameTable group entries summary",			// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable Entry summary property (SESSION_NAMETABLEENTRY_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "NameTable Entry summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    256,										// description's maximum length
		    FormatPropertyInstance_NameTableEntrySummary // generic formatter
		},

		// Owner's ID property (SESSION_OWNERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Owner ID",									// label
		    "Owner ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// NameTable Memberships summary property (SESSION_NAMETABLEMEMBERSHIPS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Memberships",					 			// label
		    "Memberships summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// NameTable Membership Entry summary property (SESSION_NAMETABLEMEMBERSHIPENTRY_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "", 										// label
		    "Membership Entry summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance_NameTableMembershipSummary // generic formatter
		},

		// Group's ID property (SESSION_GROUPID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Group ID",									// label
		    "Group ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_GroupID				// generic formatter
		},
		
		// Old Host ID property (SESSION_OLDHOSTID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Old Host ID",								// label
		    "Old Host ID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_OldHostID			// generic formatter
		},
		
		// New Host ID property (SESSION_NEWHOSTID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "New Host ID",								// label
		    "New Host ID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_NewHostID			// generic formatter
		},

		// New Host ID property (SESSION_SYNCID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Synchronization ID",						// label
		    "Synchronization ID field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's ID property (SESSION_REQUESTINGPLAYERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Requesting Player ID",						// label
		    "Requesting Player ID field",				// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		    
		// Player Destruction Reason property (SESSION_PLAYERDESTRUCTIONREASON)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Reason",									// label
		    "Reason field",								// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledPlayerDestructionReasonDWordSet,	// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Target Peer's ID property (SESSION_TARGETPEERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Target Peer ID",							// label
		    "Target Peer ID field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Requesting Peer's ID property (SESSION_REQUESTINGPEERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Requesting Peer ID",						// label
		    "Requesting Peer ID field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		}
		
	};

	enum
	{
		nNUM_OF_Session_PROPS = sizeof(g_arr_SessionProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		SESSION_SUMMARY = 0,
		SESSION_UNPARSABLEFRAGMENT,
		SESSION_INCOMPLETEMESSAGE,
		SESSION_INCOMPLETEFIELD,
			
		SESSION_MESSAGETYPE,
		SESSION_PLAYERID,
		SESSION_RESULTCODE,
	
		SESSION_DPLAYVERSION,
		SESSION_BUILDDAY,
		SESSION_BUILDMONTH,
		SESSION_BUILDYEAR,

		SESSION_FLAGS_SUMMARY,
		SESSION_FLAGS,

		SESSION_INFOFLAGS_SUMMARY,
		SESSION_INFOFLAGS,


		SESSION_GROUPFLAGS_SUMMARY,
		SESSION_GROUPFLAGS,

		SESSION_FIELDOFFSET,
		SESSION_FIELDSIZE,
		
		SESSION_SESSIONNAME,
		SESSION_NOSESSIONNAME_SUMMARY,
		
		SESSION_PLAYERNAME,
		SESSION_NOPLAYERNAME_SUMMARY,
		
		SESSION_DATA,
		SESSION_NODATA_SUMMARY,

		SESSION_REPLY,
		SESSION_NOREPLY_SUMMARY,
		
		SESSION_PASSWORD,
		SESSION_NOPASSWORD_SUMMARY,
		
		SESSION_CONNECTIONDATA,
		SESSION_NOCONNECTIONDATA_SUMMARY,
		
		SESSION_URL,
		SESSION_NOURL_SUMMARY,
		
		SESSION_APPGUID,
		SESSION_INSTGUID,

		SESSION_APPDESCINFO_SUMMARY,
		SESSION_APPDESCINFOSIZE,
		SESSION_MAXPLAYERS,
		SESSION_CURRENTPLAYERS,
		
		SESSION_RESERVEDDATA,
		SESSION_NORESERVEDDATA_SUMMARY,

		SESSION_APPRESERVEDDATA,
		SESSION_NOAPPRESERVEDDATA_SUMMARY,

		SESSION_NAMETABLEINFO_SUMMARY,

		SESSION_VERSION,
		SESSION_RESERVED,
		
		SESSION_NUMBEROFENTRIES,
		SESSION_NUMBEROFMEMBERSHIPS,

		SESSION_PLAYERS_SUMMARY,
		SESSION_GROUPS_SUMMARY,

		SESSION_NAMETABLEENTRY_SUMMARY,
		SESSION_OWNERID,

		SESSION_NAMETABLEMEMBERSHIPS_SUMMARY,
		SESSION_NAMETABLEMEMBERSHIPENTRY_SUMMARY,
		SESSION_GROUPID,

		SESSION_OLDHOSTID,
		SESSION_NEWHOSTID,

		SESSION_SYNCID,
		SESSION_REQUESTINGPLAYERID,
		
		SESSION_PLAYERDESTRUCTIONREASON,

		SESSION_TARGETPEERID,
		SESSION_REQUESTINGPEERID
	};

} // anonymous namespace








// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SessionRegister( HPROTOCOL i_hSessionProtocol ) 
{

	// TODO: PROCESS THE RETURN VALUE
	CreatePropertyDatabase(i_hSessionProtocol, nNUM_OF_Session_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_Session_PROPS; ++nProp )
	{
	   // TODO: PROCESS THE RETURN VALUE
	   AddProperty(i_hSessionProtocol, &g_arr_SessionProperties[nProp]);
	}

} // SessionRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSessionProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SessionDeregister( HPROTOCOL i_hProtocol )
{

	// TODO: PROCESS THE RETURN VALUE
	DestroyPropertyDatabase(i_hProtocol);

} // SessionDeregister



namespace
{

	// DESCRIPTION: Parses the Session frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbSessionFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//						    in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the Sessionecified Session frame (in bytes)
	//
	int SessionHeaderSize( LPBYTE i_pbSessionFrame )
	{
		DN_INTERNAL_MESSAGE_FULLMSG& rSessionFrame = *reinterpret_cast<DN_INTERNAL_MESSAGE_FULLMSG*>(i_pbSessionFrame);

		DN_INTERNAL_MESSAGE_ALL& rMsgBody = rSessionFrame.MsgBody;

		int nHeaderSize = sizeof(rSessionFrame.dwMsgType);

		switch ( rSessionFrame.dwMsgType )
		{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				nHeaderSize += sizeof(rMsgBody.dnPlayerConnectInfo) + rMsgBody.dnPlayerConnectInfo.dwNameSize + rMsgBody.dnPlayerConnectInfo.dwDataSize +
							   rMsgBody.dnPlayerConnectInfo.dwPasswordSize + rMsgBody.dnPlayerConnectInfo.dwConnectDataSize + rMsgBody.dnPlayerConnectInfo.dwURLSize;
				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{
				DPN_APPLICATION_DESC_INFO&  rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(&rMsgBody.dnConnectInfo + 1);
				DN_NAMETABLE_INFO&			 rNameTableInfo      = *reinterpret_cast<DN_NAMETABLE_INFO*>(&rApplicationDescInfo + 1);
				DN_NAMETABLE_ENTRY_INFO*	 pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

				nHeaderSize += sizeof(DN_INTERNAL_MESSAGE_CONNECT_INFO) + rApplicationDescInfo.dwSize + sizeof(DN_NAMETABLE_INFO) +
					   		   rNameTableInfo.dwEntryCount * sizeof(DN_NAMETABLE_ENTRY_INFO) +
					   		   rNameTableInfo.dwMembershipCount * sizeof(DN_NAMETABLE_MEMBERSHIP_INFO);

				for ( size_t sztEntry = 1; sztEntry <= rNameTableInfo.dwEntryCount; ++sztEntry, ++pNameTableEntryInfo )
				{
					nHeaderSize += pNameTableEntryInfo->dwNameSize + pNameTableEntryInfo->dwDataSize + pNameTableEntryInfo->dwURLSize;
				}

				break;
				
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				nHeaderSize += sizeof(rMsgBody.dnSendPlayerID);

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{
				nHeaderSize += sizeof(rMsgBody.dnConnectFailed);

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				nHeaderSize += sizeof(rMsgBody.dnInstructConnect);

				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				nHeaderSize += sizeof(rMsgBody.dnInstructedConnectFailed);

				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
			{
				nHeaderSize += sizeof(rMsgBody.dnNametableVersion);

				break;
			}

		case DN_MSG_INTERNAL_RESYNC_VERSION:
			{
				nHeaderSize += sizeof(rMsgBody.dnResyncVersion);

				break;
			}

		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqNametableOp);

				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				nHeaderSize += sizeof(rMsgBody.dnAckNametableOp);

				const DN_NAMETABLE_OP_INFO* pOpInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(&rMsgBody.dnAckNametableOp.dwNumEntries + 1);
				for ( size_t sztOp = 0; sztOp < rMsgBody.dnAckNametableOp.dwNumEntries; ++sztOp, ++pOpInfo )
				{
					nHeaderSize += sizeof(*pOpInfo) + pOpInfo->dwOpSize;
				}

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				nHeaderSize += sizeof(rMsgBody.dnHostMigrate);

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				nHeaderSize += rMsgBody.dnUpdateAppDescInfo.dwSize;
				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				nHeaderSize += sizeof(rMsgBody.dnAddPlayer) + rMsgBody.dnAddPlayer.dwDataSize +
							   rMsgBody.dnAddPlayer.dwNameSize + rMsgBody.dnAddPlayer.dwURLSize;
				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				nHeaderSize += sizeof(rMsgBody.dnDestroyPlayer);

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqCreateGroup) +
							   rMsgBody.dnReqCreateGroup.dwNameSize + rMsgBody.dnReqCreateGroup.dwDataSize;

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:	// same structure as in AddPlayerToGroup
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnAddPlayerToGroup);

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqDestroyGroup);

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqUpdateInfo) +
								rMsgBody.dnReqUpdateInfo.dwNameSize + rMsgBody.dnReqUpdateInfo.dwDataSize;

				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnCreateGroup);

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				nHeaderSize += sizeof(rMsgBody.dnDestroyGroup);

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:		// same structure as AddPlayerToGroup
			{
				nHeaderSize += sizeof(rMsgBody.dnAddPlayerToGroup);

				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				nHeaderSize += sizeof(rMsgBody.dnUpdateInfo) + rMsgBody.dnUpdateInfo.dwNameSize + rMsgBody.dnUpdateInfo.dwDataSize;

				break;
			}

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				nHeaderSize += sizeof(rMsgBody.dnRequestFailed);
				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				nHeaderSize += sizeof(rMsgBody.dnTerminateSession) + rMsgBody.dnTerminateSession.dwTerminateDataSize;
				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletion);

				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION	:
			{
				nHeaderSize += sizeof(rMsgBody.dnProcessCompletion);

				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				nHeaderSize += sizeof(rMsgBody.dnReqProcessCompletionHeader) + sizeof(rMsgBody.dnReqIntegrityCheck);

				break;
			}


		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				nHeaderSize += sizeof(rMsgBody.dnIntegrityCheck);

				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				nHeaderSize += sizeof(rMsgBody.dnIntegrityCheckResponse);

				break;
			}
		default:
			{
				return -1;	 // TODO:		DPF(0, "Unknown Session frame!");
			}
		}

		return nHeaderSize;

	} // SessionHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSessionFrame    - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSessionFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SessionRecognizeFrame( HFRAME        i_hFrame,
													ULPBYTE        i_upbMacFrame,	
													ULPBYTE        i_upbySessionFrame,
													DWORD         i_dwMacType,        
													DWORD         i_dwBytesLeft,      
													HPROTOCOL     i_hPrevProtocol,  
													DWORD         i_dwPrevProtOffset,
													LPDWORD       o_pdwProtocolStatus,
													LPHPROTOCOL   o_phNextProtocol,
													PDWORD_PTR    io_pdwptrInstData )
{

	// Validate the amount of unclaimed data
	enum
	{
		// TODO: CHANGE TO PROPER MIN SIZE
		nMIN_SessionHeaderSize  = sizeof(DWORD),
		nNUMBER_OF_MSG_TYPES = sizeof(g_arr_MessageTypeDWordLabels) / sizeof(LABELED_DWORD)
	};

	for ( int nTypeIndex = 0; nTypeIndex < nNUMBER_OF_MSG_TYPES; ++nTypeIndex )
	{
		if ( g_arr_MessageTypeDWordLabels[nTypeIndex].Value == *i_upbySessionFrame )
		{
			break;
		}
	}

	
	// Validate the packet as DPlay Session type
	if ( ((i_dwBytesLeft >= nMIN_SessionHeaderSize)  &&  (nTypeIndex < nNUMBER_OF_MSG_TYPES))  ||  (*io_pdwptrInstData == 0) )
	{
		// Claim the remaining data
	    *o_pdwProtocolStatus = PROTOCOL_STATUS_CLAIMED;
	    return ( g_upbyPastEndOfFrame = i_upbySessionFrame + SessionHeaderSize(i_upbySessionFrame) );
	}

	// Assume the unclaimed data is not recognizable
	*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
	return i_upbySessionFrame;

} // SessionRecognizeFrame


namespace
{

	// DESCRIPTION: 
	//
	// ARGUMENTS: i_hFrame        - Handle of the frame that is being parsed.
	//			   i_nProperty	   -
	//			   i_pSessionFrame  -
	//			   i_pdwOffset	   -
	//			   i_pdwSize	   -
	//			   i_dwFlags	   -
	//			   i_nLevel		   -
	//
	// RETURNS: NOTHING
	//
	void AttachValueOffsetSizeProperties( HFRAME i_hFrame, int i_nProperty, DN_INTERNAL_MESSAGE_ALL* i_pBase,
									  	  DWORD* i_pdwOffset, DWORD* i_pdwSize, DWORD i_dwFlags, int i_nLevel )
	{
	
		if ( *i_pdwSize )
		{
			// Value field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[i_nProperty].hProperty,
								   *i_pdwSize, &i_pBase->bOffsetBase + *i_pdwOffset, 0, i_nLevel, i_dwFlags);

			// If the field's value is outside the frame, let the user know it will show up incomplete or corrupted
			if ( &i_pBase->bOffsetBase + *i_pdwOffset + *i_pdwSize >= g_upbyPastEndOfFrame )
			{
		    	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INCOMPLETEFIELD].hProperty,
		    						*i_pdwSize, &i_pBase->bOffsetBase + *i_pdwOffset, 0, i_nLevel+1, 0);
			}
			
			// Value's Offset field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FIELDOFFSET].hProperty,
							  	   sizeof(*i_pdwOffset), i_pdwOffset, 0, i_nLevel + 1, 0);
			// Value's Size field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FIELDSIZE].hProperty,
								   sizeof(*i_pdwSize), i_pdwSize, 0, i_nLevel + 1, 0);
		}
		else
		{
			// No field summary
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[i_nProperty + 1].hProperty,
								   sizeof(*i_pdwOffset) + sizeof(*i_pdwSize), i_pdwOffset, 0, i_nLevel, 0);
		}
		
	}// AttachValueOffsetSizeProperties



	// DESCRIPTION: Attaches the properties to the nametable entry
	//
	// ARGUMENTS: i_hFrame 		        -  Handle of the frame that is being parsed
	//			   i_pNameTableEntryInfo  -  Pointer to the beginning of nametable's entry
	//			   i_dwEntry		    -  Ordinal number of the entry (if -1, then not printed)
	//			   i_pSessionFrame	    -  Pointer to the beginning of the protocol data in a frame.
	//
	// RETURNS: NOTHING
	//
	void AttachNameTableEntry(HFRAME i_hFrame, DN_NAMETABLE_ENTRY_INFO* i_pNameTableEntryInfo, DWORD i_dwEntry,
							DN_INTERNAL_MESSAGE_ALL* i_pBase )
	{

		NAMETABLEENTRY_INSTDATA  rInstData = { i_pBase, i_dwEntry };

		// NameTable entry summary
		AttachPropertyInstanceEx(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEENTRY_SUMMARY].hProperty,
								 sizeof(*i_pNameTableEntryInfo), i_pNameTableEntryInfo,
								 sizeof(rInstData), &rInstData, 0, 3, 0);

		if ( i_pNameTableEntryInfo->dwFlags & NAMETABLE_ENTRY_FLAG_ANY_GROUP )
		{

			// Player ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
								sizeof(i_pNameTableEntryInfo->dpnid), &i_pNameTableEntryInfo->dpnid, 0, 4, 0);
		}
		else
		{
			// Group ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
								sizeof(i_pNameTableEntryInfo->dpnid), &i_pNameTableEntryInfo->dpnid, 0, 4, 0);
		}

		
		// Owner ID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_OWNERID].hProperty,
							sizeof(i_pNameTableEntryInfo->dpnidOwner), &i_pNameTableEntryInfo->dpnidOwner, 0, 4, 0);

		// Flags summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS_SUMMARY].hProperty,
							sizeof(i_pNameTableEntryInfo->dwFlags), &i_pNameTableEntryInfo->dwFlags, 0, 4, 0);

		// Flags field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS].hProperty,
							sizeof(i_pNameTableEntryInfo->dwFlags), &i_pNameTableEntryInfo->dwFlags, 0, 5, 0);

		// Version field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
							sizeof(i_pNameTableEntryInfo->dwVersion), &i_pNameTableEntryInfo->dwVersion, 0, 4, 0);

		// RESERVED field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
							sizeof(i_pNameTableEntryInfo->dwVersionNotUsed), &i_pNameTableEntryInfo->dwVersionNotUsed, 0, 4, 0);
		
		// DPlay Version field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_DPLAYVERSION].hProperty,
							sizeof(i_pNameTableEntryInfo->dwDNETVersion), &i_pNameTableEntryInfo->dwDNETVersion, 0, 4, 0);


		// Player Name field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
								   &i_pNameTableEntryInfo->dwNameOffset, &i_pNameTableEntryInfo->dwNameSize, IFLAG_UNICODE, 4);

		// Data field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
								   &i_pNameTableEntryInfo->dwDataOffset, &i_pNameTableEntryInfo->dwDataSize, NULL, 4);

		// URL field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_URL, i_pBase,
								   &i_pNameTableEntryInfo->dwURLOffset, &i_pNameTableEntryInfo->dwURLSize, NULL, 4);

	} // AttachNameTableEntry


	
	// DESCRIPTION: Attaches the properties to the Application Description structure
	//
	// ARGUMENTS: i_hFrame 		   	   - Handle of the frame that is being parsed.
	//			   i_pbSessionFrame	   - Pointer to the beginning of the protocol data in a frame.
	//			   i_pApplicationDescInfo - Pointer to the beginning of the application description.
	//
	// RETURNS: NOTHING
	//
	void AttachApplicationDescriptionProperties( HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL* i_pBase,
										  DPN_APPLICATION_DESC_INFO* i_pApplicationDescInfo )
	{
	
		// Application Description summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPDESCINFO_SUMMARY].hProperty,
							sizeof(*i_pApplicationDescInfo), i_pApplicationDescInfo, 0, 1, 0);
		
		// Application Description's Size field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPDESCINFOSIZE].hProperty,
							sizeof(i_pApplicationDescInfo->dwSize), &i_pApplicationDescInfo->dwSize, 0, 2, 0);

		// Flags summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS_SUMMARY].hProperty,
							sizeof(i_pApplicationDescInfo->dwFlags), &i_pApplicationDescInfo->dwFlags, 0, 2, 0);
		// Flags field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS].hProperty,
							sizeof(i_pApplicationDescInfo->dwFlags), &i_pApplicationDescInfo->dwFlags, 0, 3, 0);

		// Maximum Number of Players field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_MAXPLAYERS].hProperty,
							sizeof(i_pApplicationDescInfo->dwMaxPlayers), &i_pApplicationDescInfo->dwMaxPlayers, 0, 2, 0);
		
		// Current Number of Players field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_CURRENTPLAYERS].hProperty,
							sizeof(i_pApplicationDescInfo->dwCurrentPlayers), &i_pApplicationDescInfo->dwCurrentPlayers, 0, 2, 0);

		
		// Session Name field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_SESSIONNAME, i_pBase,
								   &i_pApplicationDescInfo->dwSessionNameOffset, &i_pApplicationDescInfo->dwSessionNameSize, IFLAG_UNICODE, 2);

		// Password field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_PASSWORD, i_pBase,
								   &i_pApplicationDescInfo->dwPasswordOffset, &i_pApplicationDescInfo->dwPasswordSize, IFLAG_UNICODE, 2);

		// Reserved Data field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_RESERVEDDATA, i_pBase,
								   &i_pApplicationDescInfo->dwReservedDataOffset, &i_pApplicationDescInfo->dwReservedDataSize, NULL, 2);

		// Application Reserved Data field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_APPRESERVEDDATA, i_pBase,
								   &i_pApplicationDescInfo->dwApplicationReservedDataOffset, &i_pApplicationDescInfo->dwApplicationReservedDataSize, NULL, 2);


		// Instance GUID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INSTGUID].hProperty,
							sizeof(i_pApplicationDescInfo->guidInstance), &i_pApplicationDescInfo->guidInstance, 0, 2, 0);
		
		// Application GUID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPGUID].hProperty,
							sizeof(i_pApplicationDescInfo->guidApplication), &i_pApplicationDescInfo->guidApplication, 0, 2, 0);

	} // AttachApplicationDescriptionProperties

	
	
	// DESCRIPTION: Attaches the properties to the Session Information packet
	//
	// ARGUMENTS: i_hFrame 		   - Handle of the frame that is being parsed.
	//			  i_pbSessionFrame - Pointer to the beginning of the protocol data in a frame.
	//
	// RETURNS: NOTHING
	//
	void AttachSessionInformationProperties( HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL* i_pBase )
	{
	
		// Reply field
		AttachValueOffsetSizeProperties(i_hFrame, SESSION_REPLY, i_pBase,
								   &i_pBase->dnConnectInfo.dwReplyOffset, &i_pBase->dnConnectInfo.dwReplySize, NULL, 1);

		DPN_APPLICATION_DESC_INFO& rApplicationDescInfo = *reinterpret_cast<DPN_APPLICATION_DESC_INFO*>(&i_pBase->dnConnectInfo + 1);
		
		AttachApplicationDescriptionProperties(i_hFrame, i_pBase, &rApplicationDescInfo);
		
		DN_NAMETABLE_INFO& rNameTableInfo = *reinterpret_cast<DN_NAMETABLE_INFO*>(&rApplicationDescInfo + 1);
		DN_NAMETABLE_ENTRY_INFO*	pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

		// Calculating the size of the nametable
		size_t sztNameTableSize = sizeof(DN_NAMETABLE_INFO) + 
			   					  rNameTableInfo.dwEntryCount * sizeof(DN_NAMETABLE_ENTRY_INFO) +
			   					  rNameTableInfo.dwMembershipCount * sizeof(DN_NAMETABLE_MEMBERSHIP_INFO);
		//
		for ( size_t sztEntry = 1; sztEntry <= rNameTableInfo.dwEntryCount; ++sztEntry, ++pNameTableEntryInfo )
		{
			sztNameTableSize += pNameTableEntryInfo->dwNameSize + pNameTableEntryInfo->dwDataSize + pNameTableEntryInfo->dwURLSize;
		}

		// Nametable's summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEINFO_SUMMARY].hProperty,
							sztNameTableSize, &rNameTableInfo, 0, 1, 0);
		
		// Player ID field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
							sizeof(rNameTableInfo.dpnid), &rNameTableInfo.dpnid, 0, 2, 0);
		
		// Version field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
							sizeof(rNameTableInfo.dwVersion), &rNameTableInfo.dwVersion, 0, 2, 0);
		
		// RESERVED field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
							sizeof(rNameTableInfo.dwVersionNotUsed), &rNameTableInfo.dwVersionNotUsed, 0, 2, 0);

		// Number of NameTable Entries field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NUMBEROFENTRIES].hProperty,
							sizeof(rNameTableInfo.dwEntryCount), &rNameTableInfo.dwEntryCount, 0, 2, 0);

		// Number of NameTable Memberships field
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NUMBEROFMEMBERSHIPS].hProperty,
							sizeof(rNameTableInfo.dwMembershipCount), &rNameTableInfo.dwMembershipCount, 0, 2, 0);



		pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

		// NameTable Player entries summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERS_SUMMARY].hProperty,
							rNameTableInfo.dwEntryCount * sizeof(*pNameTableEntryInfo), pNameTableEntryInfo, 0, 2, 0);
		
		std::queue<DN_NAMETABLE_ENTRY_INFO*> queGroups;

		// Process player entries
		int nPlayerEntry = 1;
		for ( sztEntry = 1; sztEntry <= rNameTableInfo.dwEntryCount; ++sztEntry, ++pNameTableEntryInfo )
		{
			// If the entry contains group information, enqueue it for later processing
			if ( pNameTableEntryInfo->dwFlags & NAMETABLE_ENTRY_FLAG_ANY_GROUP )
			{
				queGroups.push(pNameTableEntryInfo);
			}
			else
			{
				AttachNameTableEntry(i_hFrame, pNameTableEntryInfo, nPlayerEntry, i_pBase);
				++nPlayerEntry;
			}
		}

		DN_NAMETABLE_MEMBERSHIP_INFO* pNameTableMembershipInfo = reinterpret_cast<DN_NAMETABLE_MEMBERSHIP_INFO*>(pNameTableEntryInfo);

		// Process group entries
		if ( !queGroups.empty() )
		{
			pNameTableEntryInfo = reinterpret_cast<DN_NAMETABLE_ENTRY_INFO*>(&rNameTableInfo + 1);

			// NameTable Group entries summary
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPS_SUMMARY].hProperty,
								   rNameTableInfo.dwEntryCount * sizeof(*pNameTableEntryInfo), pNameTableEntryInfo, 0, 2, 0);

			
			for ( nPlayerEntry = 1; !queGroups.empty(); queGroups.pop(), ++nPlayerEntry )
			{
				AttachNameTableEntry(i_hFrame, queGroups.front(), nPlayerEntry, i_pBase);
			}
		}


		// NameTable's Memberships summary
		AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEMEMBERSHIPS_SUMMARY].hProperty,
							   rNameTableInfo.dwMembershipCount * sizeof(*pNameTableMembershipInfo), pNameTableMembershipInfo, 0, 2, 0);
		
		for ( sztEntry = 1; sztEntry <= rNameTableInfo.dwMembershipCount; ++sztEntry, ++pNameTableMembershipInfo )
		{
			// NameTable's Membership Entry summary
			AttachPropertyInstanceEx(i_hFrame, g_arr_SessionProperties[SESSION_NAMETABLEMEMBERSHIPENTRY_SUMMARY].hProperty,
									 sizeof(*pNameTableMembershipInfo), pNameTableMembershipInfo,
									 sizeof(sztEntry), &sztEntry, 0, 3, 0);
			
			// Player ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
							   	   sizeof(pNameTableMembershipInfo->dpnidPlayer), &pNameTableMembershipInfo->dpnidPlayer, 0, 4, 0);
			// Group ID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
								   sizeof(pNameTableMembershipInfo->dpnidGroup), &pNameTableMembershipInfo->dpnidGroup, 0, 4, 0);
			
			// Version field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
								   sizeof(pNameTableMembershipInfo->dwVersion), &pNameTableMembershipInfo->dwVersion, 0, 4, 0);
			// RESERVED field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
								   sizeof(pNameTableMembershipInfo->dwVersionNotUsed), &pNameTableMembershipInfo->dwVersionNotUsed, 0, 4, 0);
		}
		
	} // AttachSessionInformationProperties



	// DESCRIPTION: Attaches the properties to the Session Information packet
	//
	// ARGUMENTS: i_hFrame 		       - Handle of the frame that is being parsed.
	//			   i_pPlayerConnectionInfo  - Pointer to the connecting player's information.
	//
	// RETURNS: NOTHING
	//
	void AttachPlayerInformationProperties( HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL* i_pBase )
	{

			// Synonym declaration (to make code more readable)
			DN_INTERNAL_MESSAGE_PLAYER_CONNECT_INFO& rPlayerConnectInfo = i_pBase->dnPlayerConnectInfo;
			
			// Flags summary
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS_SUMMARY].hProperty,
								   sizeof(rPlayerConnectInfo.dwFlags), &rPlayerConnectInfo.dwFlags, 0, 1, 0);
			// Flags field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_FLAGS].hProperty,
								   sizeof(rPlayerConnectInfo.dwFlags), &rPlayerConnectInfo.dwFlags, 0, 2, 0);

			
			// DPlay Version field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_DPLAYVERSION].hProperty,
								   sizeof(rPlayerConnectInfo.dwDNETVersion), &rPlayerConnectInfo.dwDNETVersion, 0, 1, 0);
			// DPlay Version Day subfield
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_BUILDDAY].hProperty,
								   sizeof(BYTE), reinterpret_cast<LPBYTE>(&rPlayerConnectInfo.dwDNETVersion) + 2, 0, 2, 0);
			// DPlay Version Month subfield
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_BUILDMONTH].hProperty,
								   sizeof(BYTE), reinterpret_cast<LPBYTE>(&rPlayerConnectInfo.dwDNETVersion) + 1, 0, 2, 0);
			// DPlay Version Year subfield
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_BUILDYEAR].hProperty,
								   sizeof(BYTE), &rPlayerConnectInfo.dwDNETVersion, 0, 2, 0);



			// Player Name field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
									      &rPlayerConnectInfo.dwNameOffset, &rPlayerConnectInfo.dwNameSize, IFLAG_UNICODE, 1);
			
			// Data field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
									      &rPlayerConnectInfo.dwDataOffset, &rPlayerConnectInfo.dwDataSize, NULL, 1);

			// Password field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_PASSWORD, i_pBase,
									      &rPlayerConnectInfo.dwPasswordOffset, &rPlayerConnectInfo.dwPasswordSize, IFLAG_UNICODE, 1);
		
			// Connection Data field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_CONNECTIONDATA, i_pBase,
									      &rPlayerConnectInfo.dwConnectDataOffset, &rPlayerConnectInfo.dwConnectDataSize, NULL, 1);

			// URL field
			AttachValueOffsetSizeProperties(i_hFrame, SESSION_URL, i_pBase,
									      &rPlayerConnectInfo.dwURLOffset, &rPlayerConnectInfo.dwURLSize, NULL, 1);

			
	
			// Instance GUID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INSTGUID].hProperty,
								   sizeof(rPlayerConnectInfo.guidInstance), &rPlayerConnectInfo.guidInstance, 0, 1, 0);

			
			// Application GUID field
			AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_APPGUID].hProperty,
								   sizeof(rPlayerConnectInfo.guidApplication), &rPlayerConnectInfo.guidApplication, 0, 1, 0);

	} // AttachPlayerInformationProperties



	// DESCRIPTION: Attaches the properties to a Session message packet or delegates to appropriate function
	//
	// ARGUMENTS: i_dwMsgType	   - Message ID
	//			   i_hFrame 	   - Handle of the frame that is being parsed.
	//			   i_pSessionFrame  - Pointer to the start of the recognized data.
	//
	// RETURNS: NOTHING
	//
	void AttachMessageProperties( const DWORD i_dwMsgType, const HFRAME i_hFrame, DN_INTERNAL_MESSAGE_ALL *const i_pBase )
	{
	
		switch ( i_dwMsgType )
		{
		case DN_MSG_INTERNAL_PLAYER_CONNECT_INFO:
			{
				AttachPlayerInformationProperties(i_hFrame, i_pBase);
				break;
			}

		case DN_MSG_INTERNAL_SEND_CONNECT_INFO:
			{

				AttachSessionInformationProperties(i_hFrame, i_pBase);
				break;
			}

		case DN_MSG_INTERNAL_ACK_CONNECT_INFO:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_SEND_PLAYER_DNID:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnSendPlayerID.dpnid), &i_pBase->dnSendPlayerID.dpnid, 0, 1, 0);

				break;
			}
		
		case DN_MSG_INTERNAL_INSTRUCT_CONNECT:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnInstructConnect.dpnid), &i_pBase->dnInstructConnect.dpnid, 0, 1, 0);

				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnInstructConnect.dwVersion), &i_pBase->dnInstructConnect.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnInstructConnect.dwVersionNotUsed), &i_pBase->dnInstructConnect.dwVersionNotUsed, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_CONNECT_FAILED:
			{

				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESULTCODE].hProperty,
									   sizeof(i_pBase->dnConnectFailed.hResultCode), &i_pBase->dnConnectFailed.hResultCode, 0, 1, 0);

				// Reply field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_REPLY, i_pBase,
										   &i_pBase->dnConnectFailed.dwReplyOffset, &i_pBase->dnConnectFailed.dwReplySize, NULL, 1);
				
				break;
			}

		case DN_MSG_INTERNAL_INSTRUCTED_CONNECT_FAILED:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnInstructedConnectFailed.dpnid), &i_pBase->dnInstructedConnectFailed.dpnid, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_ACK_NAMETABLE_OP:
			{
				// Number of Entries field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NUMBEROFENTRIES].hProperty,
									   sizeof(i_pBase->dnAckNametableOp.dwNumEntries), &i_pBase->dnAckNametableOp.dwNumEntries, 0, 1, 0);

				const DN_NAMETABLE_OP_INFO* pOpInfo = reinterpret_cast<DN_NAMETABLE_OP_INFO*>(&i_pBase->dnAckNametableOp.dwNumEntries + 1);
				for ( size_t sztOp = 0; sztOp < i_pBase->dnAckNametableOp.dwNumEntries; ++sztOp, ++pOpInfo )
				{
					AttachMessageProperties(pOpInfo->dwMsgId, i_hFrame, reinterpret_cast<DN_INTERNAL_MESSAGE_ALL*>(reinterpret_cast<BYTE*>(i_pBase) + pOpInfo->dwOpOffset));
				}

				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE:
			{
				// Old Host ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_OLDHOSTID].hProperty,
									sizeof(i_pBase->dnHostMigrate.dpnidOldHost), &i_pBase->dnHostMigrate.dpnidOldHost, 0, 1, 0);
				// New Host ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_NEWHOSTID].hProperty,
									sizeof(i_pBase->dnHostMigrate.dpnidNewHost), &i_pBase->dnHostMigrate.dpnidNewHost, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_NAMETABLE_VERSION:
		case DN_MSG_INTERNAL_REQ_NAMETABLE_OP:		// same structure as in NameTableVersion
		case DN_MSG_INTERNAL_RESYNC_VERSION:		// same structure as in NameTableVersion
			{
				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnNametableVersion.dwVersion), &i_pBase->dnNametableVersion.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnNametableVersion.dwVersionNotUsed), &i_pBase->dnNametableVersion.dwVersionNotUsed, 0, 1, 0);
				break;
			}

		case DN_MSG_INTERNAL_HOST_MIGRATE_COMPLETE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_APPLICATION_DESC:
			{
				AttachApplicationDescriptionProperties(i_hFrame, i_pBase, &i_pBase->dnUpdateAppDescInfo);

				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER:
			{
				AttachNameTableEntry(i_hFrame, &i_pBase->dnAddPlayer, -1, i_pBase);
				
				break;
			}

		case DN_MSG_INTERNAL_DESTROY_PLAYER:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dpnidLeaving), &i_pBase->dnDestroyPlayer.dpnidLeaving, 0, 1, 0);
				
				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dwVersion), &i_pBase->dnDestroyPlayer.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dwVersionNotUsed), &i_pBase->dnDestroyPlayer.dwVersionNotUsed, 0, 1, 0);

				// Player Destruction Reason field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERDESTRUCTIONREASON].hProperty,
									sizeof(i_pBase->dnDestroyPlayer.dwDestroyReason), &i_pBase->dnDestroyPlayer.dwDestroyReason, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_REQ_CREATE_GROUP:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Group flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwGroupFlags), &i_pBase->dnReqCreateGroup.dwGroupFlags, 0, 1, 0);
				// Group field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPFLAGS].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwGroupFlags), &i_pBase->dnReqCreateGroup.dwGroupFlags, 0, 2, 0);


				// Info flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwInfoFlags), &i_pBase->dnReqCreateGroup.dwInfoFlags, 0, 1, 0);
				// Info flags field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS].hProperty,
									sizeof(i_pBase->dnReqCreateGroup.dwInfoFlags), &i_pBase->dnReqCreateGroup.dwInfoFlags, 0, 2, 0);


				// Player Name field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
										   &i_pBase->dnReqCreateGroup.dwNameOffset, &i_pBase->dnReqCreateGroup.dwNameSize, IFLAG_UNICODE, 1);

				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnReqCreateGroup.dwDataOffset, &i_pBase->dnReqCreateGroup.dwDataSize, NULL, 1);

				break;
			}

		case DN_MSG_INTERNAL_REQ_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_REQ_DELETE_PLAYER_FROM_GROUP:	// same structure as in AddPlayerToGroup
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnReqAddPlayerToGroup.dpnidGroup), &i_pBase->dnReqAddPlayerToGroup.dpnidGroup, 0, 1, 0);

				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnReqAddPlayerToGroup.dpnidPlayer), &i_pBase->dnReqAddPlayerToGroup.dpnidPlayer, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_REQ_DESTROY_GROUP:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnReqDestroyGroup.dpnidGroup), &i_pBase->dnReqDestroyGroup.dpnidGroup, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_REQ_UPDATE_INFO:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);

				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnReqUpdateInfo.dpnid), &i_pBase->dnReqUpdateInfo.dpnid, 0, 1, 0);


				// Info flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnReqUpdateInfo.dwInfoFlags), &i_pBase->dnReqUpdateInfo.dwInfoFlags, 0, 1, 0);
				// Info flags field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS].hProperty,
									sizeof(i_pBase->dnReqUpdateInfo.dwInfoFlags), &i_pBase->dnReqUpdateInfo.dwInfoFlags, 0, 2, 0);


				// Player Name field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
										   &i_pBase->dnReqUpdateInfo.dwNameOffset, &i_pBase->dnReqUpdateInfo.dwNameSize, IFLAG_UNICODE, 1);

				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnReqUpdateInfo.dwDataOffset, &i_pBase->dnReqUpdateInfo.dwDataSize, NULL, 1);
				break;
			}

		case DN_MSG_INTERNAL_CREATE_GROUP:
			{
				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnCreateGroup.dpnidRequesting), &i_pBase->dnCreateGroup.dpnidRequesting, 0, 1, 0);
			
				// Synchronization ID
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnCreateGroup.hCompletionOp), &i_pBase->dnCreateGroup.hCompletionOp, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_DESTROY_GROUP:
			{
				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dpnidGroup), &i_pBase->dnDestroyGroup.dpnidGroup, 0, 1, 0);

				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dpnidRequesting), &i_pBase->dnDestroyGroup.dpnidRequesting, 0, 1, 0);

				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dwVersion), &i_pBase->dnDestroyGroup.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnDestroyGroup.dwVersionNotUsed), &i_pBase->dnDestroyGroup.dwVersionNotUsed, 0, 1, 0);

				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnDestroyGroup.hCompletionOp), &i_pBase->dnDestroyGroup.hCompletionOp, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_ADD_PLAYER_TO_GROUP:
		case DN_MSG_INTERNAL_DELETE_PLAYER_FROM_GROUP:	// same structure as AddPlayerToGroup
			{
				// Group ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_GROUPID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dpnidGroup), &i_pBase->dnAddPlayerToGroup.dpnidGroup, 0, 1, 0);

				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dpnidPlayer), &i_pBase->dnAddPlayerToGroup.dpnidPlayer, 0, 1, 0);

				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dwVersion), &i_pBase->dnAddPlayerToGroup.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dwVersionNotUsed), &i_pBase->dnAddPlayerToGroup.dwVersionNotUsed, 0, 1, 0);

				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.dpnidRequesting), &i_pBase->dnAddPlayerToGroup.dpnidRequesting, 0, 1, 0);

				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnAddPlayerToGroup.hCompletionOp), &i_pBase->dnAddPlayerToGroup.hCompletionOp, 0, 1, 0);
				break;
			}

		case DN_MSG_INTERNAL_UPDATE_INFO:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_PLAYERID].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dpnid), &i_pBase->dnUpdateInfo.dpnid, 0, 1, 0);
				
				// Version field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_VERSION].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwVersion), &i_pBase->dnUpdateInfo.dwVersion, 0, 1, 0);
				
				// RESERVED field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESERVED].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwVersionNotUsed), &i_pBase->dnUpdateInfo.dwVersionNotUsed, 0, 1, 0);


				// Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS_SUMMARY].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwInfoFlags), &i_pBase->dnUpdateInfo.dwInfoFlags, 0, 1, 0);
				// Flags field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INFOFLAGS].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dwInfoFlags), &i_pBase->dnUpdateInfo.dwInfoFlags, 0, 2, 0);


				// Player Name field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_PLAYERNAME, i_pBase,
										   &i_pBase->dnUpdateInfo.dwNameOffset, &i_pBase->dnUpdateInfo.dwNameSize, IFLAG_UNICODE, 1);

				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnUpdateInfo.dwDataOffset, &i_pBase->dnUpdateInfo.dwDataSize, NULL, 1);


				// Requesting Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_REQUESTINGPLAYERID].hProperty,
									sizeof(i_pBase->dnUpdateInfo.dpnidRequesting), &i_pBase->dnUpdateInfo.dpnidRequesting, 0, 1, 0);

				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnUpdateInfo.hCompletionOp), &i_pBase->dnUpdateInfo.hCompletionOp, 0, 1, 0);
			
				break;
			}

		case DN_MSG_INTERNAL_BUFFER_IN_USE:
			{
				// No fields
				break;
			}

		case DN_MSG_INTERNAL_REQUEST_FAILED:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnRequestFailed.hCompletionOp), &i_pBase->dnRequestFailed.hCompletionOp, 0, 1, 0);
				
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_RESULTCODE].hProperty,
									   sizeof(i_pBase->dnRequestFailed.hResultCode), &i_pBase->dnRequestFailed.hResultCode, 0, 1, 0);

				break;
			}

		case DN_MSG_INTERNAL_TERMINATE_SESSION:
			{
				// Data field
				AttachValueOffsetSizeProperties(i_hFrame, SESSION_DATA, i_pBase,
										   &i_pBase->dnTerminateSession.dwTerminateDataOffset, &i_pBase->dnTerminateSession.dwTerminateDataSize, NULL, 1);
				
				break;
			}

		case DN_MSG_INTERNAL_REQ_PROCESS_COMPLETION:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletion.hCompletionOp), &i_pBase->dnReqProcessCompletion.hCompletionOp, 0, 1, 0);

				// TODO: AttachPropertyInstance(REST OF THE FRAME IS USER DATA)
				break;
			}

		case DN_MSG_INTERNAL_PROCESS_COMPLETION	:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnProcessCompletion.hCompletionOp), &i_pBase->dnProcessCompletion.hCompletionOp, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_REQ_INTEGRITY_CHECK:
			{
				// Synchronization ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SYNCID].hProperty,
									sizeof(i_pBase->dnReqProcessCompletionHeader.hCompletionOp), &i_pBase->dnReqProcessCompletionHeader.hCompletionOp, 0, 1, 0);
				
				// Target Peer ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_TARGETPEERID].hProperty,
									sizeof(i_pBase->dnReqIntegrityCheck.dpnidTarget), &i_pBase->dnReqIntegrityCheck.dpnidTarget, 0, 1, 0);
				
				break;
			}


		case DN_MSG_INTERNAL_INTEGRITY_CHECK:
			{
				// Requesting Peer ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_TARGETPEERID].hProperty,
									sizeof(i_pBase->dnIntegrityCheck.dpnidRequesting), &i_pBase->dnIntegrityCheck.dpnidRequesting, 0, 1, 0);
				
				break;
			}

		case DN_MSG_INTERNAL_INTEGRITY_CHECK_RESPONSE:
			{
				// Requesting Peer ID field
				AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_TARGETPEERID].hProperty,
									sizeof(i_pBase->dnIntegrityCheckResponse.dpnidRequesting), &i_pBase->dnIntegrityCheckResponse.dpnidRequesting, 0, 1, 0);

				break;
			}
		

		default:
			{
				break; // TODO:		DPF(0, "Unknown Session frame!");
			}
		}
		
	} // AttachMessageProperties 

} // Anonymous namespace



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Sessionecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSessionFrame   - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API LPBYTE BHAPI SessionAttachProperties( HFRAME      i_hFrame,
													  ULPBYTE      i_upbMacFrame,
													  ULPBYTE      i_upbySessionFrame,
													  DWORD       i_dwMacType,
													  DWORD       i_dwBytesLeft,
													  HPROTOCOL   i_hPrevProtocol,
													  DWORD       i_dwPrevProtOffset,
													  DWORD_PTR   i_dwptrInstData )
{

    //===================//
    // Attach Properties //
    //===================//

    if ( i_dwptrInstData == 0 )
    {
    	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_UNPARSABLEFRAGMENT].hProperty,
    						i_dwBytesLeft, i_upbySessionFrame, 0, 0, 0);
    	return NULL;
    }
    
    // Summary line
    AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_SUMMARY].hProperty,
                           SessionHeaderSize(i_upbySessionFrame), i_upbySessionFrame, 0, 0, 0);

	// Check what Session frame we are dealing with
	DN_INTERNAL_MESSAGE_FULLMSG& rSessionFrame = *reinterpret_cast<DN_INTERNAL_MESSAGE_FULLMSG*>(i_upbySessionFrame);

	// Message type field
	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_MESSAGETYPE].hProperty,
						   sizeof(rSessionFrame.dwMsgType), &rSessionFrame.dwMsgType, 0, 1, 0);

	__try
	{
		// Attach the properties appropriate to the message type
		AttachMessageProperties(rSessionFrame.dwMsgType, i_hFrame, &rSessionFrame.MsgBody);
	}
	__except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
    	AttachPropertyInstance(i_hFrame, g_arr_SessionProperties[SESSION_INCOMPLETEMESSAGE].hProperty,
    						i_dwBytesLeft, i_upbySessionFrame, 0, 1, 0);
	}

	return NULL;

} // SessionAttachProperties





// DESCRIPTION: Formats the data that is diSessionlayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbSessionFrame	- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSessionFrame.
//
DPLAYPARSER_API DWORD BHAPI SessionFormatProperties( HFRAME          i_hFrame,
													 ULPBYTE          i_upbMacFrame,
													 ULPBYTE          i_upbySessionFrame,
													 DWORD           i_dwPropertyInsts,
													 LPPROPERTYINST  i_pPropInst )
{

    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
        reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

	// TODO: MAKE SURE THIS SHOULD NOT BE TRUE
    return NMERR_SUCCESS;

} // SessionFormatProperties




// DESCRIPTION: Notifies Network Monitor that DNET protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateSessionProtocol( void )
{

	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS SessionEntryPoints =
	{
		// SessionParser Entry Points
		SessionRegister,
		SessionDeregister,
		SessionRecognizeFrame,
		SessionAttachProperties,
		SessionFormatProperties
	};

    // The first active instance of this parser needs to register with the kernel
    g_hSessionProtocol = CreateProtocol("DPLAYSESSION", &SessionEntryPoints, ENTRYPOINTS_SIZE);
	
	return (g_hSessionProtocol ? TRUE : FALSE);

} // CreateSessionProtocol



// DESCRIPTION: Removes the DNET protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroySessionProtocol( void )
{

	DestroyProtocol(g_hSessionProtocol);

} // DestroySessionProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\sources.inc ===
#
# The MAJORCOMP and MINORCOMP variables are defined
# so that $(MAJORCOMP)$(MINORCOMP)filename can be used in
# cross compiling to provide unique filenames in a flat namespace.
#

MAJORCOMP=windows
MINORCOMP=media

#
# The TARGETNAME variable is defined by the developer.  It is the name of
# the target (component) that is being built by this makefile.  It
# should NOT include any path or file extension information.
#

TARGETNAME=dp8parse
DLLDEF=..\..\DPlay8Parser.def
UMTYPE=windows

#
# The TARGETPATH and TARGETTYPE variables are defined by the developer.
# The first specifies where the target is to be build.  The second specifies
# the type of target (either PROGRAM, DYNLINK, LIBRARY, DRIVER, etc
# UMAPPL_NOLIB is used when you're only building user-mode
# apps and don't need to build a library.
#

TARGETPATH=obj
TARGETTYPE=DYNLINK

#
# The TARGETLIBS specifies additional libraries to link with you target
# image.  Each library path specification should contain an asterisk (*)
# where the machine specific subdirectory name should go.
#


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#

TARGETLIBS=$(TARGETLIBS) \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib \
	   $(BASEDIR)\public\sdk\lib\*\gdi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\nmapi.lib \
	   $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\ole32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcrt.lib \
	   $(BASEDIR)\public\sdk\lib\*\msvcprt.lib


!if "$(NTDEBUG)" == "ntsd" || "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "sym"
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif

#
# The INCLUDES variable specifies any include paths that are specific to
# this source directory.  Separate multiple directory paths with single
# semicolons.  Relative path specifications are okay.
#

INCLUDES=$(DXROOT)\inc; \
	..\..; \
	..\..\..\..\inc; \
	..\..\..\..\common; \
	..\..\..\..\core; \
	..\..\..\..\sp\wsock; \
	..\..\..\..\protocol; \
	..\..\..\..\..\dvoice\dxvoice; \
	..\..\..\..\..\dvoice\inc; \
	$(BASEDIR)\public\sdk\inc\atl30


#
# The SOURCES variable is defined by the developer.  It is a list of all the
# source files for this component.  Each source file should be on a separate
# line using the line continuation character.  This will minimize merge
# conflicts if two developers adding source files to the same component.
#

SOURCES= DPlay8Parser.cpp\
         SessionParser.cpp\
         SPParser.cpp\
         TransportParser.cpp\
         VoiceParser.cpp\
	 dp8parse.rc

#
# Next specify options for the compiler.
#
# Note about CRT defines.  When linking with MSVCRT you must have both _MT and _DLL specified.
# Using the build environment's USE_MSVCRT=1 would do this for us, but because we define our
# own operator new this will cause a link error because the build environment will not properly
# pull in msvcrt.lib last as of 5/11/2001.  Therefore, we do it all manually specifying _DLL, _MT, 
# and msvcrt.lib and USE_NOLIBS=1 ourselves.  This also means that we must manually add msvcprt.lib 
# where STL is used.
#
C_DEFINES= $(C_DEFINES) /D_USRDLL /DWIN32 /D_MT /D_DLL /DDPLAYPARSER_EXPORTS

USE_NOLIBS=1

USE_NATIVE_EH=1

DLLENTRY=_DllMainCRTStartup

#
# Perform the file copy contained in makefile.inc to work around source file directory limitations.
#
NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\spparser.cpp ===
//=============================================================================
//  FILE: SPParser.cpp
//
//  Description: DirectPlay Service Provider Parser
//
//
//  Modification History:
//
//  Michael Milirud      08/Aug/2000    Created
//=============================================================================

//#define FRAME_NAMES
//#define FRAME_DROPS

//==================//
// Standard headers //
//==================//
#include <winsock2.h>
#include <wsipx.h>
#include <ws2tcpip.h>
#include <tchar.h>

//=====================//
// Proprietary headers //
//=====================//

#include "dpaddr.h"	// DPNA_DEFAULT_PORT definition

// Prototypes
#include "SPParser.hpp"

namespace DPlaySP
{

	// SP protocol header
	#include "MessageStructures.h"

} // DPlaySP namespace


namespace
{
	HPROTOCOL  g_hSPProtocol;


	//=============================//
	// Return Address Family field //-----------------------------------------------------------------------------------
	//=============================//
	LABELED_BYTE arr_RetAddrFamilyByteLabels[] = { { AF_IPX,  "IPX protocol" },
												   { AF_INET, "IPv4 protocol"	 },
												   { AF_INET6, "IPv6 protocol"	 } };

	SET LabeledRetAddrFamilyByteSet = { sizeof(arr_RetAddrFamilyByteLabels) / sizeof(LABELED_BYTE), arr_RetAddrFamilyByteLabels };


	
	//================//
	// Data Tag field //------------------------------------------------------------------------------------------------
	//================//
	LABELED_BYTE arr_CommandByteLabels[] = { { ENUM_DATA_KIND,			 "Enumeration Query"			   },
										     { ENUM_RESPONSE_DATA_KIND,  "Response to Enumeration Query"   },
											 { PROXIED_ENUM_DATA_KIND,	 "Proxied Enumeration Query"	   } };

	SET LabeledCommandByteSet = { sizeof(arr_CommandByteLabels) / sizeof(LABELED_BYTE), arr_CommandByteLabels };


	
	////////////////////////////////
	// Custom Property Formatters //=====================================================================================
	////////////////////////////////

	
	// DESCRIPTION: Custom description formatter for the Service Provider packet summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SPSummary( LPPROPERTYINST io_pProperyInstance )
	{
		using namespace DPlaySP;

		// Check what SP frame we are dealing with
		const PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(io_pProperyInstance->lpData);
		//
		switch ( rSPFrame.GenericHeader.bSPCommandByte )
		{
		case ENUM_DATA_KIND:			// Service Provider Query
			{
				strcpy(io_pProperyInstance->szPropertyText, "Enumeration Request");
				break;
			}

		case ENUM_RESPONSE_DATA_KIND:	// Service Provider Response
			{
				strcpy(io_pProperyInstance->szPropertyText, "Enumeration Response");
				break;
			}

		case PROXIED_ENUM_DATA_KIND:	// Service Provider Proxied Query
			{
				strcpy(io_pProperyInstance->szPropertyText, "Proxied Enumeration Request");
				break;
			}

		default:
			{
				strcpy(io_pProperyInstance->szPropertyText, "User Data");
				break;
			}
		}

	} // FormatPropertyInstance_SPSummary


	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_SPProperties[] = 
	{

		// SP packet summary property (SP_SUMMARY)
	    {
		    0,									// handle placeholder (MBZ)
		    0,									// reserved (MBZ)
		    "",									// label
		    "DPlay Service Provider packet",	// status-bar comment
		    PROP_TYPE_SUMMARY,					// data type
		    PROP_QUAL_NONE,						// data type qualifier
		    NULL,								// labeled bit set 
		    512,								// description's maximum length
		    FormatPropertyInstance_SPSummary	// generic formatter
		},

		// Leading Zero property (SP_LEADZERO)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Leading zero tag",					// label
			"Leading zero tag field",			// status-bar comment
			PROP_TYPE_BYTE,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Data Tag property (SP_COMMAND)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Command",							// label
			"Command field",					// status-bar comment
			PROP_TYPE_BYTE,						// data type
			PROP_QUAL_LABELED_SET,				// data type qualifier.
			&LabeledCommandByteSet,				// labeled byte set 
			512,								// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Key property (SP_ENUMPAYLOAD)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Enum Payload",						// label
			"Enumeration Payload field",		// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Key property (SP_ENUMKEY)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Enum Key",							// label
			"Enumeration Key field",			// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Response Key property (SP_ENUMRESPKEY)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Enum Response Key",				// label
			"Enumeration Response Key",			// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Enumeration Response Key property (SP_RTTINDEX)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"RTT Index",						// label
			"RTT Index field",					// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},
		
		// Size of the return address property (SP_RETADDRSIZE)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Return Address's Size",			// label
			"Size of the return address",		// status-bar comment
			PROP_TYPE_BYTE,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket Family property (SP_RETADDRFAMILY)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Socket Family",					// label
			"Socket Family field",				// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_LABELED_SET,				// data type qualifier.
			&LabeledRetAddrFamilyByteSet,		// labeled byte set 
			512,								// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket Family property (SP_RETADDR_IPX)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"IPX Address",						// label
			"IPX Address field",				// status-bar comment
			PROP_TYPE_IPX_ADDRESS,				// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket (SP_RETADDRSOCKET_IPX)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Socket",							// label
			"Socket field",						// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},
	
		// Return Address Socket Family property (SP_RETADDR_IP)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"IP Address",						// label
			"IP Address field",					// status-bar comment
			PROP_TYPE_IP_ADDRESS,				// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// Return Address Socket (SP_RETADDRPORT_IP)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"Port",								// label
			"Port field",						// status-bar comment
			PROP_TYPE_WORD,						// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},
	
		// Return Address Socket Family property (SP_RETADDR_IPV6)
	    {
			0,									// handle placeholder (MBZ)
			0,									// reserved (MBZ)
			"IPv6 Address",						// label
			"IPv6 Address field",				// status-bar comment
			PROP_TYPE_IP6_ADDRESS,				// data type
			PROP_QUAL_NONE,						// data type qualifier.
			NULL,								// labeled byte set 
			64,									// description's maximum length
			FormatPropertyInstance				// generic formatter
		},

		// User Data (SP_USERDATA)
	    {
		    0,									// handle placeholder (MBZ)
		    0,									// reserved (MBZ)
		    "User Data",						// label
		    "User Data",						// status-bar comment
		    PROP_TYPE_RAW_DATA,					// data type
		    PROP_QUAL_NONE,						// data type qualifier.
		    NULL,								// labeled bit set 
		    64,									// description's maximum length
		    FormatPropertyInstance				// generic formatter
		}

	};

	enum
	{
		nNUM_OF_SP_PROPS = sizeof(g_arr_SPProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		SP_SUMMARY = 0,
		SP_LEADZERO,
		SP_COMMAND,
		SP_ENUMPAYLOAD,
		SP_ENUMKEY,
		SP_ENUMRESPKEY,
		SP_RTTINDEX,
		SP_RETADDRSIZE,
		SP_RETADDRFAMILY,
		SP_RETADDR_IPX,
		SP_RETADDRSOCKET_IPX,
		SP_RETADDR_IP,
		SP_RETADDRPORT_IP,
		SP_RETADDR_IPV6,
		SP_USERDATA
	};





	// Platform independent memory accessor of big endian words
	inline WORD ReadBigEndianWord( BYTE* i_pbData )
	{
		return (*i_pbData << 8) | *(i_pbData+1);
	}


	// DESCRIPTION: DPlay packet validation predicate.
	//
	// ARGUMENTS: i_hFrame		  - The handle to the frame that contains the data.
	//			  i_hPrevProtocol - Handle of the previous protocol.
	//			  i_pbMacFrame	  - The pointer to the first byte of the frame; the pointer provides a way to view
	//						        the data that the other parsers recognize.
	//
	// RETURNS: DPlay packet = TRUE; NOT a DPlay packet = FALSE
	//
	bool IsDPlayPacket( HFRAME i_hFrame, HPROTOCOL i_hPrevProtocol, LPBYTE i_pbMacFrame )
	{

		const PROTOCOLINFO* pPrevProtocolInfo = GetProtocolInfo(i_hPrevProtocol);
		
		DWORD dwPrevProtocolOffset = GetProtocolStartOffsetHandle(i_hFrame, i_hPrevProtocol);

		WORD wSrcPort, wDstPort;

		if ( strncmp(reinterpret_cast<const char*>(pPrevProtocolInfo->ProtocolName), "UDP", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
		{
			// Extracting the source and destination ports of the packet from its UDP header
			wSrcPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset);
			wDstPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset + 2);
		}
		else if ( strncmp(reinterpret_cast<const char*>(pPrevProtocolInfo->ProtocolName), "IPX", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
		{
			// Extracting the source and destination ports of the packet from its IPX header
			wSrcPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset + 16);	// source address socket
			wDstPort = ReadBigEndianWord(i_pbMacFrame + dwPrevProtocolOffset + 28); // destination address socket
		}
		else
		{
			// Should never happen!
			return false;
		}

		
		//===========//
		// Constants //
		//===========//
		//
		static bool bTriedRetrievingUserPorts = false;
		static bool bRetrievedUserPorts = false;

		static DWORD dwMinUserPort, dwMaxUserPort;

		// Retrieval from the registry is attempted only once
		if ( !bTriedRetrievingUserPorts )
		{
			bTriedRetrievingUserPorts = true;
			
			HKEY hKey = NULL;
			if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Software\\Microsoft\\DirectPlay\\Parsers"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
			{
				DWORD dwType = NULL;
				DWORD dwCount = sizeof(DWORD);
				if (RegQueryValueEx(hKey, _T("MinUserPort"), NULL, &dwType, (LPBYTE)&dwMinUserPort, &dwCount) == ERROR_SUCCESS &&
					RegQueryValueEx(hKey, _T("MaxUserPort"), NULL, &dwType, (LPBYTE)&dwMaxUserPort, &dwCount) == ERROR_SUCCESS )
				{
					bRetrievedUserPorts = true;
				}
				RegCloseKey(hKey);
			}
		}

		if ( bRetrievedUserPorts &&
			((wSrcPort >= dwMinUserPort) && (wSrcPort <= dwMaxUserPort)) &&
		    ((wDstPort >= dwMinUserPort) && (wDstPort <= dwMaxUserPort)) )
		{
			// Is a valid DPlay packet
			return true;
		}


		// Make sure both endpoints are using the SP port range [2302, 2400], or the DPNServer port {6073}, or [MinUsePort, MaxUserPort] (if provided by the user)
		WORD wPort = wSrcPort;
		for ( int nPorts = 0; nPorts < 2; ++nPorts, wPort = wDstPort )
		{
			if (
				 (
				   !bRetrievedUserPorts    ||
				   (wPort < dwMinUserPort) ||
				   (wPort > dwMaxUserPort)
				 )
				 &&
				 (
				   (wPort < BASE_DPLAY8_PORT)  ||
				   (wPort > MAX_DPLAY8_PORT)
				 )
				 &&
				 (
				   wPort != DPNA_DPNSVR_PORT
				 )
			   )
			{
				// Not a valid DPlay packet
				return false;
			}
		}

		// Is a valid DPlay packet
		return true;

	} // IsDPlayPacket

} // anonymous namespace





// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SPRegister( HPROTOCOL i_hSPProtocol ) 
{

	CreatePropertyDatabase(i_hSPProtocol, nNUM_OF_SP_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_SP_PROPS; ++nProp )
	{
	   AddProperty(i_hSPProtocol, &g_arr_SPProperties[nProp]);
	}

} // SPRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SPDeregister( HPROTOCOL i_hProtocol )
{

	DestroyPropertyDatabase(i_hProtocol);

} // SPDeregister




namespace
{

	// DESCRIPTION: Parses the SP frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbSPFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//						    in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the specified SP frame (in bytes)
	//
	int SPHeaderSize( LPBYTE i_pbSPFrame )
	{
		using namespace DPlaySP;

		// Check what SP frame we are dealing with
		const PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(i_pbSPFrame);
		//
		switch ( rSPFrame.GenericHeader.bSPCommandByte )
		{
		case ENUM_DATA_KIND:			// Service Provider Query
			{
				return  sizeof(rSPFrame.EnumDataHeader);
			}
		case ENUM_RESPONSE_DATA_KIND:	// Service Provider Response
			{
				return  sizeof(rSPFrame.EnumResponseDataHeader);
			}

		case PROXIED_ENUM_DATA_KIND:	// Service Provider Proxied Query
			{
				return  sizeof(rSPFrame.ProxiedEnumDataHeader);
			}

		default:	// user data starting with a nonzero byte
			{
				return 0;	// no header
			}
		}

	} // SPHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSPFrame		  - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSPFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SPRecognizeFrame( HFRAME        i_hFrame,
											   ULPBYTE        i_upbMacFrame,	
											   ULPBYTE        i_upbSPFrame,
											   DWORD         i_dwMacType,        
											   DWORD         i_dwBytesLeft,      
											   HPROTOCOL     i_hPrevProtocol,  
											   DWORD         i_dwPrevProtOffset,
											   LPDWORD       o_pdwProtocolStatus,
											   LPHPROTOCOL   o_phNextProtocol,
											   PDWORD_PTR    io_pdwptrInstData )
{
	using namespace DPlaySP;

	// Validate the amount of unclaimed data
	enum
	{
		nMIN_SPHeaderSize = sizeof(PREPEND_BUFFER::_GENERIC_HEADER)
	};

	// Validate the packet as DPlay SP type
	if ( (i_dwBytesLeft < nMIN_SPHeaderSize)					 ||
		 !IsDPlayPacket(i_hFrame, i_hPrevProtocol, i_upbMacFrame) )
	{
		// Assume the unclaimed data is not recognizable
		*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return i_upbSPFrame;
	}


	//==========================//
	// Get the DPlay frame size //
	//==========================//
	const PROTOCOLINFO* pPrevProtocolInfo = GetProtocolInfo(i_hPrevProtocol);
	WORD wDPlayFrameSize = 0;

	if ( strncmp(reinterpret_cast<const char*>(pPrevProtocolInfo->ProtocolName), "UDP", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
	{
		// Extracting the UDP frame size
		WORD wUDPFrameSize = ReadBigEndianWord(i_upbMacFrame + i_dwPrevProtOffset + 4);

		enum { nUDP_HEADER_SIZE = 8 };
		wDPlayFrameSize = wUDPFrameSize - nUDP_HEADER_SIZE;
	}
	else if ( strncmp(reinterpret_cast<const char*>(pPrevProtocolInfo->ProtocolName), "IPX", sizeof(pPrevProtocolInfo->ProtocolName)) == 0 )
	{
		// Extracting the IPX frame size
		WORD wIPXFrameSize = ReadBigEndianWord(i_upbMacFrame + i_dwPrevProtOffset + 2);	// source address socket

		enum { nIPX_HEADER_SIZE = 30 };
		wDPlayFrameSize = wIPXFrameSize - nIPX_HEADER_SIZE;
	}
	else
	{
		; // TODO: ASSERT HERE
	}

	// Pass along the size of the Transport frame
	DWORD_PTR dwptrTransportFrameSize = wDPlayFrameSize - SPHeaderSize(i_upbSPFrame);
	*io_pdwptrInstData = dwptrTransportFrameSize;

	const PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(i_upbSPFrame);

	if ( rSPFrame.GenericHeader.bSPLeadByte  ==  SP_HEADER_LEAD_BYTE )	// SP packet
	{
	    *o_pdwProtocolStatus = PROTOCOL_STATUS_RECOGNIZED;
		*o_phNextProtocol	 = NULL;
	}
	else // user data (DPlay v8 Transport packet)
	{
		// Notify NetMon about the handoff protocol
		*o_pdwProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;
		*o_phNextProtocol	 = GetProtocolFromName("DPLAYTRANSPORT");

		return i_upbSPFrame;
	}
	
	// Claim the rest of the data
	return NULL;		

} // SPRecognizeFrame



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSPFrame		 - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API LPBYTE BHAPI SPAttachProperties( HFRAME      i_hFrame,
												 ULPBYTE      i_upbMacFrame,
												 ULPBYTE      i_upbSPFrame,
												 DWORD       i_dwMacType,
												 DWORD       i_dwBytesLeft,
												 HPROTOCOL   i_hPrevProtocol,
												 DWORD       i_dwPrevProtOffset,
												 DWORD_PTR   i_dwptrInstData )
{
	using namespace DPlaySP;

    //===================//
    // Attach Properties //
    //===================//

    // Summary line
    AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_SUMMARY].hProperty,
                           i_dwBytesLeft, i_upbSPFrame, 0, 0, 0);

	// Protection against NetMon
	if ( *i_upbSPFrame )
	{
		return NULL;
	}

    // Check what SP frame we are dealing with
	PREPEND_BUFFER&	rSPFrame = *reinterpret_cast<PREPEND_BUFFER*>(i_upbSPFrame);

	// Leading Zero tag field
    AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_LEADZERO].hProperty,
                           sizeof(rSPFrame.GenericHeader.bSPLeadByte), &rSPFrame.GenericHeader.bSPLeadByte, 0, 1, 0);

	// Command field
    AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_COMMAND].hProperty,
                           sizeof(rSPFrame.GenericHeader.bSPCommandByte), &rSPFrame.GenericHeader.bSPCommandByte, 0, 1, 0);
	    
	switch ( rSPFrame.GenericHeader.bSPCommandByte )
	{
	case ENUM_DATA_KIND:			// Service Provider's Enumeration Request
		{
			// Enum payload field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_ENUMPAYLOAD].hProperty,
								   sizeof(rSPFrame.EnumDataHeader.wEnumPayload), &rSPFrame.EnumDataHeader.wEnumPayload, 0, 1, 0);
			// Enum Key field
			DWORD dwEnumKey = rSPFrame.EnumDataHeader.wEnumPayload & ~ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_ENUMKEY].hProperty,
								   sizeof(rSPFrame.EnumDataHeader.wEnumPayload), &rSPFrame.EnumDataHeader.wEnumPayload,
								   sizeof(dwEnumKey), &dwEnumKey,
								   0, 2, 0);
			
			// RTT index field
			BYTE byRTTIndex = rSPFrame.EnumDataHeader.wEnumPayload & ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_RTTINDEX].hProperty,
								   sizeof(rSPFrame.EnumDataHeader.wEnumPayload), &rSPFrame.EnumDataHeader.wEnumPayload,
								   sizeof(byRTTIndex), &byRTTIndex,
								   0, 2, 0);
			break;
		}

	case ENUM_RESPONSE_DATA_KIND:	// Service Provider's Enumeration Response
		{
			// Enum payload field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_ENUMPAYLOAD].hProperty,
								   sizeof(rSPFrame.EnumResponseDataHeader.wEnumResponsePayload), &rSPFrame.EnumResponseDataHeader.wEnumResponsePayload, 0, 1, 0);
			
			// Enum Key field
			DWORD dwEnumKey = rSPFrame.EnumResponseDataHeader.wEnumResponsePayload & ~ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_ENUMRESPKEY].hProperty,
								   sizeof(rSPFrame.EnumResponseDataHeader.wEnumResponsePayload), &rSPFrame.EnumResponseDataHeader.wEnumResponsePayload,
								   sizeof(dwEnumKey), &dwEnumKey,
								   0, 2, 0);
			
			// RTT index field
			BYTE byRTTIndex = rSPFrame.EnumDataHeader.wEnumPayload & ENUM_RTT_MASK;
			AttachPropertyInstanceEx(i_hFrame, g_arr_SPProperties[SP_RTTINDEX].hProperty,
								   sizeof(rSPFrame.EnumResponseDataHeader.wEnumResponsePayload), &rSPFrame.EnumResponseDataHeader.wEnumResponsePayload,
								   sizeof(byRTTIndex), &byRTTIndex,
								   0, 2, 0);
			break;
		}

	case PROXIED_ENUM_DATA_KIND:	// Service Provider's Proxied Enumeration Query
		{
			// Return Address Size field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRSIZE].hProperty,
								   sizeof(rSPFrame.ProxiedEnumDataHeader.ReturnAddress), &rSPFrame.ProxiedEnumDataHeader.ReturnAddress, 0, 1, 0);
			
			// Enum Key field
			AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_ENUMKEY].hProperty,
								   sizeof(rSPFrame.ProxiedEnumDataHeader.wEnumKey), &rSPFrame.ProxiedEnumDataHeader.wEnumKey, 0, 1, 0);


			// Return Address Socket Address Family field
			//
			// Technically we don't know that this is not the smaller non-IPv6 capable version of
			// this message.  However, since PROXIED_ENUM_DATA_KIND is only ever sent locally, it
			// won't even show up in the parser, so it doesn't really matter.
			AttachPropertyInstance(i_hFrame,
								   g_arr_SPProperties[SP_RETADDRFAMILY].hProperty,
								   sizeof(rSPFrame.ProxiedEnumDataHeader.ReturnAddress.AddressGeneric.sa_family),
								   &rSPFrame.ProxiedEnumDataHeader.ReturnAddress.AddressGeneric.sa_family,
								   0, 1, 0);


			switch ( rSPFrame.ProxiedEnumDataHeader.ReturnAddress.AddressGeneric.sa_family )
			{				
			case AF_IPX:
				{
					SOCKADDR_IPX& rIPXAddress = rSPFrame.ProxiedEnumDataHeader.ReturnAddress.AddressIPX;

					// Return Address field (IPX Network Number + Node Number)
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDR_IPX].hProperty,
										   sizeof(rIPXAddress.sa_netnum) + sizeof(rIPXAddress.sa_nodenum), &rIPXAddress.sa_netnum, 0, 1, 0);

					// Return Address Socket Address IPX Socket Number field
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRSOCKET_IPX].hProperty,
										   sizeof(rIPXAddress.sa_socket), &rIPXAddress.sa_socket, 0, 1, 0);

					break;
				}

			case AF_INET:
				{
					SOCKADDR_IN& rIPAddress = rSPFrame.ProxiedEnumDataHeader.ReturnAddress.AddressIPv4;

					// Return Address field (IP Address)
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDR_IP].hProperty,
										   sizeof(rIPAddress.sin_addr), &rIPAddress.sin_addr, 0, 1, 0);

					// Return Address Port field
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRPORT_IP].hProperty,
										   sizeof(rIPAddress.sin_port), &rIPAddress.sin_port, 0, 1, 0);

					break;
				}

			case AF_INET6:
				{
					SOCKADDR_IN6& rIPv6Address = rSPFrame.ProxiedEnumDataHeader.ReturnAddress.AddressIPv6;

					// Return Address field (IP Address)
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDR_IPV6].hProperty,
										   sizeof(rIPv6Address.sin6_addr), &rIPv6Address.sin6_addr, 0, 1, 0);

					// Return Address Port field
					AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_RETADDRPORT_IP].hProperty,
										   sizeof(rIPv6Address.sin6_port), &rIPv6Address.sin6_port, 0, 1, 0);

					break;
				}

			default:
				{
					// TODO:	DPF(0, "Unknown socket type!");
					break;
				}
			}

			break;
		}
	}


	size_t sztSPHeaderSize = SPHeaderSize(i_upbSPFrame);
	
	if ( i_dwBytesLeft > sztSPHeaderSize )
	{
		size_t sztUserDataSize = i_dwBytesLeft - sztSPHeaderSize;

		// User data
		AttachPropertyInstance(i_hFrame, g_arr_SPProperties[SP_USERDATA].hProperty,
							   sztUserDataSize, i_upbSPFrame + sztSPHeaderSize, 0, 1, 0);
	}

	return NULL;

} // SPAttachProperties





// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSPFrame.
//
DPLAYPARSER_API DWORD BHAPI SPFormatProperties( HFRAME          i_hFrame,
												ULPBYTE          i_upbMacFrame,
												ULPBYTE          i_upbSPFrame,
												DWORD           i_dwPropertyInsts,
												LPPROPERTYINST  i_pPropInst )
{

    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
        reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

	// TODO: MAKE SURE THIS SHOULD NOT BE TRUE
    return NMERR_SUCCESS;

} // SPFormatProperties




// DESCRIPTION: Notifies Network Monitor that DPlay v8 Transport protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateSPProtocol( void )
{

	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS SPEntryPoints =
	{
		// SPParser Entry Points
		SPRegister,
		SPDeregister,
		SPRecognizeFrame,
		SPAttachProperties,
		SPFormatProperties
	};

    // The first active instance of this parser needs to register with the kernel
    g_hSPProtocol = CreateProtocol("DPLAYSP", &SPEntryPoints, ENTRYPOINTS_SIZE);
	
	return (g_hSPProtocol ? TRUE : FALSE);

} // CreateSPProtocol



// DESCRIPTION: Removes the DPlay v8 Transport protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroySPProtocol( void )
{

	DestroyProtocol(g_hSPProtocol);

} // DestroySPProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\spparser.hpp ===
#ifndef _SPParser_H_
#define _SPParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI SPRegister( HPROTOCOL i_hSPProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hSPProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI SPDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbSPFrame     - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbSPFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI SPRecognizeFrame( HFRAME        i_hFrame,
											   ULPBYTE        i_upbMacFrame,	
											   ULPBYTE        i_upbSPFrame,
                                   			   DWORD         i_dwMacType,        
                                   			   DWORD         i_dwBytesLeft,      
                                   			   HPROTOCOL     i_hPrevProtocol,  
                                   			   DWORD         i_dwPrevProtOffset,
                                   			   LPDWORD       o_pdwProtocolStatus,
                                   			   LPHPROTOCOL   o_hNextProtocol,
											   PDWORD_PTR    io_pdwptrInstData );


// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbSPFrame        - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSPFrame.
//
DPLAYPARSER_API LPBYTE BHAPI SPAttachProperties( HFRAME      i_hFrame,
												 ULPBYTE      i_upbMacFrame,
												 ULPBYTE      i_upbSPFrame,
												 DWORD       i_dwMacType,
												 DWORD       i_dwBytesLeft,
												 HPROTOCOL   i_hPrevProtocol,
												 DWORD       i_dwPrevProtOffset,
												 DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbSPFrame.
//
DPLAYPARSER_API DWORD BHAPI SPFormatProperties( HFRAME          i_hFrame,
												ULPBYTE          i_upbMacFrame,
												ULPBYTE          i_upbSPFrame,
												DWORD           i_dwPropertyInsts,
												LPPROPERTYINST  i_pPropInst );

bool CreateSPProtocol( void );
void DestroySPProtocol( void );


#endif // _SPParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\transportparser.cpp ===
//=============================================================================
//  FILE: TransportParser.cpp
//
//  Description: DPlay v8 Transport protocol parser
//
//
//  Modification History:
//
//  Michael Milirud      08/Aug/2000    Created
//=============================================================================

// uncomment to enable full parsing of DPlay Transport layer
//#define PARSE_DPLAY_TRANSPORT 

//==================//
// Standard headers //
//==================//
#include <string>


//=====================//
// Proprietary headers //
//=====================//

// Prototypes
#include "TransportParser.hpp"

// Transport protocol header
#include "Frames.h"

typedef	UNALIGNED struct dataframe_big		DFBIG, *PDFBIG;
typedef UNALIGNED struct sackframe_big8		SFBIG8, *PSFBIG8;

struct dataframe_big 
{
	BYTE	bCommand;
	BYTE	bControl;
	BYTE	bSeq;
	BYTE	bNRcv;
	ULONG	rgMask[4];
};

struct sackframe_big8
{
	BYTE		bCommand;				// As above
	BYTE		bExtOpcode;				// As above
	BYTE		bFlags;					// Additional flags for sack frame
	BYTE		bRetry;
	BYTE		bNSeq;					// Since this frame has no sequence number, this is the next Seq we
	BYTE		bNRcv;					// As above
	BYTE		bReserved1;				// We shipped DX8 with bad packing, so these were actually there
	BYTE		bReserved2;				// We shipped DX8 with bad packing, so these were actually there
	DWORD		tTimestamp;				// Local stamp when packet arrived
	ULONG		rgMask[4];
};


namespace
{
	HPROTOCOL		g_hTransportProtocol;

	typedef __int64 QWORD;


	//================//
	// DCommand field //-------------------------------------------------------------------------------------------------
	//================//
	LABELED_BIT g_arr_DCommandBitLabels[] =
		{ { 0, "INVALID",	          					"Dataframe"                     },		// PACKET_COMMAND_DATA
		  { 1, "Unreliable",         				    "Reliable"                      },		// PACKET_COMMAND_RELIABLE
		  { 2, "Nonsequenced",     					    "Sequenced"                     },		// PACKET_COMMAND_SEQUENTIAL
		  { 3, "ACK can be delayed",				    "ACK now"						},		// PACKET_COMMAND_POLL
		  { 4, "Not the first fragment of the message", "First fragment of the message" },		// PACKET_COMMAND_NEW_MSG
		  { 5, "Not the last fragment of the message",  "Last fragment of the message"  },		// PACKET_COMMAND_END_MSG
		  { 6, "User packet",							"DirectPlay packet"		        },		// PACKET_COMMAND_USER_1
		  { 7, "Data packet",							"Voice packet"			        } };	// PACKET_COMMAND_USER_2

	SET g_LabeledDCommandBitSet = { sizeof(g_arr_DCommandBitLabels) / sizeof(LABELED_BIT), g_arr_DCommandBitLabels };



	//===============//
	// Control field //--------------------------------------------------------------------------------------------------
	//===============//

	LABELED_BIT g_arr_ControlBitLabels[] =
		{ { 0, "Original (not a retry)",					"Retry"					       				   },	// PACKET_CONTROL_RETRY
		  { 1, "Don't correlate",							"Correlate"									   },	// PACKET_CONTROL_CORRELATE
		  { 2, "Not a correlation response",				"Correlation response"					       },	// PACKET_CONTROL_RESPONSE
		  { 3, "Not the last packet in the stream",			"Last packet in the stream"				       },	// PACKET_CONTROL_END_STREAM
		  { 4, "Low DWORD of the RCVD mask is zero",		"Low DWORD of the RCVD mask is nonzero"	       },	// PACKET_CONTROL_SACK_MASK1
		  { 5, "High DWORD of the RCVD mask is zero",		"High DWORD of the RCVD mask is nonzero"	   },	// PACKET_CONTROL_SACK_MASK2
		  { 6, "Low DWORD of the DON'T CARE mask is zero",	"Low DWORD of the DON'T CARE mask is nonzero"  },	// PACKET_CONTROL_SEND_MASK1
		  { 7, "High DWORD of the DON'T CARE mask is zero",	"High DWORD of the DON'T CARE mask is nonzero" } }; // PACKET_CONTROL_SEND_MASK2

	SET g_LabeledControlBitSet = { sizeof(g_arr_ControlBitLabels) / sizeof(LABELED_BIT), g_arr_ControlBitLabels };



	//================//
	// CCommand field //-------------------------------------------------------------------------------------------------
	//================//
	LABELED_BIT g_arr_CCommandBitLabels[] =
		{ { 0, "Command Frame (1/2)", "INVALID"				},	// PACKET_COMMAND_DATA
		  { 1, "Unreliable",		  "Reliable"			},	// PACKET_COMMAND_RELIABLE
		  { 2, "Nonsequenced",     	  "Sequenced"			},	// PACKET_COMMAND_SEQUENTIAL
		  { 3, "ACK can be delayed",  "ACK now" 			},  // PACKET_COMMAND_POLL
		  { 4, "RESERVED",			  "RESERVED"			},	
		  { 5, "RESERVED",			  "RESERVED"			},  	
		  { 6, "RESERVED",			  "RESERVED"			},  	
		  { 7, "INVALID",			  "Command Frame (2/2)"	} };

	SET g_LabeledCCommandBitSet = { sizeof(g_arr_CCommandBitLabels) / sizeof(LABELED_BIT), g_arr_CCommandBitLabels };



	//=======================//
	// Extended Opcode field //------------------------------------------------------------------------------------------
	//=======================//
	LABELED_BYTE g_arr_ExOpcodeByteLabels[] = { 
										        { FRAME_EXOPCODE_CONNECT,	   "Establish a connection"				  },
										        { FRAME_EXOPCODE_CONNECTED,	   "Connection request has been accepted" },
										        { FRAME_EXOPCODE_HARD_DISCONNECT, "Connection has been hard disconnected"     },
										        { FRAME_EXOPCODE_SACK,		   "Selective Acknowledgement"			  } };

	SET g_LabeledExOpcodeByteSet = { sizeof(g_arr_ExOpcodeByteLabels) / sizeof(LABELED_BYTE), g_arr_ExOpcodeByteLabels };


	
	//==================//
	// SACK flags field //-----------------------------------------------------------------------------------------------
	//==================//
	LABELED_BIT g_arr_SACKFlagsBitLabels[] =
		{ { 0, "Retry and/or Timestamp fields are invalid",		   "Retry and Timestamp fields are valid"	      },   // SACK_FLAGS_RESPONSE
		  { 1, "Low DWORD of the RCVD mask is not present",	   	   "Low DWORD of the RCVD mask is present"        },   // SACK_FLAGS_SACK_MASK1
		  { 2, "High DWORD of the RCVD mask is not present",	   "High DWORD of the RCVD mask is present"       },   // SACK_FLAGS_SACK_MASK2
		  { 3, "Low DWORD of the DON'T CARE mask is not present",  "Low DWORD of the DON'T CARE mask is present"  },   // SACK_FLAGS_SEND_MASK1
		  { 4, "High DWORD of the DON'T CARE mask is not present", "High DWORD of the DON'T CARE mask is present" } }; // SACK_FLAGS_SEND_MASK2

	SET g_LabeledSACKFlagsBitSet = { sizeof(g_arr_SACKFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_SACKFlagsBitLabels };


	
	//==================//
	// Helper functions //===========================================================================
	//==================//

	enum BitmaskPart { LOW = 0, HIGH, ENTIRE };
	enum BitmaskType { RCVD, DONTCARE };
	
	std::string InterpretRCVDBitmask( BitmaskPart i_Part, BYTE i_byBase, UNALIGNED DWORD* i_pdwBitmask )
	{
		std::string strSummary = "Received Seq=";

		// [i_bBase+1 .. i_bBase+1+LENGTH]
		// RCVD bitmask doesn't include the base value, since receiver can't claim it didn't receive the next dataframe to be received (NRcv);
		if ( i_Part == HIGH )
		{
			// NOTE: +1 is needed to cross from MSB of the first DWORD TO LSB of the second
			i_byBase += 8*sizeof(DWORD)+1; // shift to LSB of the second DWORD
		}
		else
		{
			++i_byBase;
		}

		QWORD qwBitMask = *i_pdwBitmask;
		if ( i_Part == ENTIRE )
		{
			qwBitMask |= *(i_pdwBitmask+1);
		}

		strSummary += "{";

		
		bool bFirst = true;
		// Processing from LSB to MSB
		for ( ; qwBitMask; qwBitMask >>= 1, ++i_byBase )
		{
			if ( qwBitMask & 1 )  
			{
				if ( bFirst )
				{
					bFirst = false;
				}
				else
				{
					strSummary += ", ";
				}
				
				char arr_cBuffer[10];
				strSummary += _itoa(i_byBase, arr_cBuffer, 16);
			}
		}
		
		strSummary += "}";
		
		return strSummary;
		
	}// InterpretRCVDBitmask


	std::string InterpretDONTCAREBitmask( BitmaskPart i_Part, BYTE i_byBase, UNALIGNED DWORD* i_pdwBitmask )
	{
		std::string strSummary = "Cancelling Seq=";

		// [i_bBase-1-LENGTH .. i_bBase-1]
		// DON'T CARE doesn't include the base value, since transmitter can't resend/refuse resending a dataframe which is about to be sent next (NSeq).
		if ( i_Part == LOW )
		{
			i_byBase -= 8*sizeof(DWORD); // shift to MSB of the first DWORD
		}
		else
		{
			i_byBase -= 8*sizeof(QWORD); // shift to MSB of the second DWORD
		}

		QWORD qwBitMask = *i_pdwBitmask;
		if ( i_Part == ENTIRE )
		{
			qwBitMask |= *(i_pdwBitmask+1);
		}
		else
		{
			// QWORD.High = QWORD.Low; QWORD.Low = 0;
			qwBitMask <<= 8*sizeof(DWORD);
		}

		strSummary += "{";
		
		bool bFirst = true;
		// Processing from MSB to LSB
		for ( ; qwBitMask; ++i_byBase, qwBitMask <<= 1 )
		{
			if ( qwBitMask & 0x8000000000000000 )  
			{
				if ( bFirst )
				{
					bFirst = false;
				}
				else
				{
					strSummary += ", ";
				}
				
				char arr_cBuffer[10];
				strSummary += _itoa(i_byBase, arr_cBuffer, 16);
			}
		}
		
		strSummary += "}";
		
		return strSummary;
		
	}// InterpretDONTCAREBitmask



	////////////////////////////////
	// Custom Property Formatters //======================================================================================
	////////////////////////////////

	// DESCRIPTION: Custom description formatter for the Transport packet summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_TransportSummary( LPPROPERTYINST io_pProperyInstance )
	{
		std::string strSummary;
		char arr_cBuffer[10];

		DFBIG&	rDBigFrame	= *reinterpret_cast<DFBIG*>(io_pProperyInstance->lpPropertyInstEx->lpData);

		if ( (rDBigFrame.bCommand & PACKET_COMMAND_DATA)  ==  PACKET_COMMAND_DATA )	// DFrame
		{
			if ( *reinterpret_cast<BOOL*>(io_pProperyInstance->lpPropertyInstEx->Dword) )
			{
				strSummary  = "KeepAlive";
			}
			else if ( (rDBigFrame.bCommand & PACKET_COMMAND_USER_2) == PACKET_COMMAND_USER_2 )
			{
				strSummary  = "Voice";
			}
			else
			{
				strSummary  = "User data";
			}


			#if defined(PARSE_DPLAY_TRANSPORT)
			
				strSummary += " : Seq=";
				strSummary += _itoa(rDBigFrame.bSeq, arr_cBuffer, 16);
				strSummary += ", NRcv=";
				strSummary += _itoa(rDBigFrame.bNRcv, arr_cBuffer, 16);
				
			#endif  // PARSE_DPLAY_TRANSPORT

			
			if ( (rDBigFrame.bCommand & PACKET_COMMAND_NEW_MSG) == PACKET_COMMAND_NEW_MSG )
			{
				if ( (rDBigFrame.bCommand & PACKET_COMMAND_END_MSG) != PACKET_COMMAND_END_MSG )
				{
					strSummary += ", First fragment";
				}
			}
			else if ( (rDBigFrame.bCommand & PACKET_COMMAND_END_MSG) == PACKET_COMMAND_END_MSG )
			{
				strSummary += ", Last fragment";
			}
		
			if ( (rDBigFrame.bControl & PACKET_CONTROL_END_STREAM)  ==  PACKET_CONTROL_END_STREAM )
			{
				strSummary += ", End of Stream";
			}

			if ( (rDBigFrame.bCommand & PACKET_COMMAND_POLL) == PACKET_COMMAND_POLL )
			{
				strSummary += ", ACK now";
			}

			if ( (rDBigFrame.bControl & PACKET_CONTROL_RETRY) == PACKET_CONTROL_RETRY )
			{
				strSummary += ", Retry";
			}	

			if ( (rDBigFrame.bControl & PACKET_CONTROL_CORRELATE) == PACKET_CONTROL_CORRELATE )
			{
				strSummary += ", Correlate / Keep Alive";
			}


			int nBitMaskIndex = 0;
			
			if ( (rDBigFrame.bControl & PACKET_CONTROL_SACK_MASK1)  ==  PACKET_CONTROL_SACK_MASK1 )
			{
				strSummary += ", ";
				if ( (rDBigFrame.bControl & PACKET_CONTROL_SACK_MASK2)  ==  PACKET_CONTROL_SACK_MASK2 )	 // Entire QWORD
 				{
 					strSummary += InterpretRCVDBitmask(ENTIRE, rDBigFrame.bNRcv, &rDBigFrame.rgMask[nBitMaskIndex]);
					nBitMaskIndex += 2;
				}
 				else // Low DWORD only
 				{
	 				strSummary += InterpretRCVDBitmask(LOW, rDBigFrame.bNRcv, &rDBigFrame.rgMask[nBitMaskIndex]);
					++nBitMaskIndex;
 				}
			}
			else if ( (rDBigFrame.bControl & PACKET_CONTROL_SACK_MASK2)  ==  PACKET_CONTROL_SACK_MASK2 )	 // High DWORD only
 			{
 				strSummary += ", " + InterpretRCVDBitmask(HIGH, rDBigFrame.bNRcv, &rDBigFrame.rgMask[nBitMaskIndex]);
				++nBitMaskIndex; 					
			}
				
			if ( (rDBigFrame.bControl & PACKET_CONTROL_SEND_MASK1)  ==  PACKET_CONTROL_SEND_MASK1 )
			{
				strSummary += ", ";
				if ( (rDBigFrame.bControl & PACKET_CONTROL_SEND_MASK2)  ==  PACKET_CONTROL_SEND_MASK2 ) // Entire QWORD
 				{
 					strSummary += InterpretDONTCAREBitmask(ENTIRE, rDBigFrame.bSeq, &rDBigFrame.rgMask[nBitMaskIndex]);
				}
 				else // Low DWORD only
 				{
	 				strSummary += InterpretDONTCAREBitmask(LOW, rDBigFrame.bSeq, &rDBigFrame.rgMask[nBitMaskIndex]);
 				}
			}
			else if ( (rDBigFrame.bControl & PACKET_CONTROL_SEND_MASK2)  ==  PACKET_CONTROL_SEND_MASK2 )	 // High DWORD only
 			{
 				strSummary += ", " + InterpretDONTCAREBitmask(HIGH, rDBigFrame.bSeq, &rDBigFrame.rgMask[nBitMaskIndex]);
			}

		}
		else
		{
			CFRAME& rCFrame	= *reinterpret_cast<CFRAME*>(io_pProperyInstance->lpPropertyInstEx->lpData);

			if ( rCFrame.bExtOpcode == FRAME_EXOPCODE_SACK )	// SACK CFrame
			{
				SFBIG8* pSBigFrame = reinterpret_cast<SFBIG8*>(&rCFrame);

				enum { SACK_FLAGS_ALL_MASKS = SACK_FLAGS_SACK_MASK1 | SACK_FLAGS_SACK_MASK2 |
											  SACK_FLAGS_SEND_MASK1 | SACK_FLAGS_SEND_MASK2 };
				
				if ( pSBigFrame->bFlags & SACK_FLAGS_ALL_MASKS ) // at least one bitmask field is present
				{
					strSummary = "Selective Acknowledgement";
				}
				else // if not a single bitmask is present
				{
					strSummary = "Acknowledgement";
				}


				#if defined(PARSE_DPLAY_TRANSPORT)

					strSummary += " : NSeq=";
					strSummary += _itoa(pSBigFrame->bNSeq, arr_cBuffer, 16);
					strSummary += ", NRcv=";
					strSummary += _itoa(pSBigFrame->bNRcv, arr_cBuffer, 16);

				#endif // PARSE_DPLAY_TRANSPORT
				

				if ( (pSBigFrame->bCommand & PACKET_COMMAND_POLL) == PACKET_COMMAND_POLL )
				{
					strSummary += ", ACK now";
				}

				if ( ((pSBigFrame->bFlags & SACK_FLAGS_RESPONSE) == SACK_FLAGS_RESPONSE)  &&  pSBigFrame->bRetry )
				{
					strSummary += ", Retry";
				}


				int nBitMaskIndex = 0;
				UNALIGNED ULONG* pulMasks = 0;

				// This is a Protocol version 1.0 frame
				pulMasks = pSBigFrame->rgMask;

				if ( (pSBigFrame->bFlags & SACK_FLAGS_SACK_MASK1)  ==  SACK_FLAGS_SACK_MASK1 )
				{
					strSummary += ", ";
 					if ( (pSBigFrame->bFlags & SACK_FLAGS_SACK_MASK2)  ==  SACK_FLAGS_SACK_MASK2 )	// Entire QWORD
 					{
 						strSummary += InterpretRCVDBitmask(ENTIRE, pSBigFrame->bNRcv, &pulMasks[nBitMaskIndex]);
						nBitMaskIndex += 2;
					}
 					else // Low DWORD only
 					{
	 					strSummary += InterpretRCVDBitmask(LOW, pSBigFrame->bNRcv, &pulMasks[nBitMaskIndex]);
						++nBitMaskIndex;
 					}
				}
				else if ( (pSBigFrame->bFlags & SACK_FLAGS_SACK_MASK2)  ==  SACK_FLAGS_SACK_MASK2 )	// High DWORD only
 				{
 					strSummary += ", " + InterpretRCVDBitmask(HIGH, pSBigFrame->bNRcv, &pulMasks[nBitMaskIndex]);
					++nBitMaskIndex; 					
				}

				if ( (pSBigFrame->bFlags & SACK_FLAGS_SEND_MASK1)  ==  SACK_FLAGS_SEND_MASK1 )
				{
					strSummary += ", ";
 					if ( (pSBigFrame->bFlags & SACK_FLAGS_SEND_MASK2)  ==  SACK_FLAGS_SEND_MASK2 ) // Entire QWORD
 					{
 						strSummary += InterpretDONTCAREBitmask(ENTIRE, pSBigFrame->bNSeq, &pulMasks[nBitMaskIndex]);
					}
 					else // Low DWORD only
 					{
	 					strSummary += InterpretDONTCAREBitmask(LOW, pSBigFrame->bNSeq, &pulMasks[nBitMaskIndex]);
 					}
				}
				else if ( (pSBigFrame->bFlags & SACK_FLAGS_SEND_MASK2)  ==  SACK_FLAGS_SEND_MASK2 ) // High DWORD only
 				{
					strSummary += ", " + InterpretDONTCAREBitmask(HIGH, pSBigFrame->bNSeq, &pulMasks[nBitMaskIndex]);
				}
				
			}
			else	// Connection Control CFrame
			{
				strSummary = "Connection Control - ";

				for ( int n = 0; n < sizeof(g_arr_ExOpcodeByteLabels) / sizeof(LABELED_BYTE); ++ n )
				{
					if ( g_arr_ExOpcodeByteLabels[n].Value == rCFrame.bExtOpcode )
					{
						strSummary += g_arr_ExOpcodeByteLabels[n].Label;
						break;
					}
				}

				if ( (rCFrame.bCommand & PACKET_COMMAND_POLL) == PACKET_COMMAND_POLL )
				{
					strSummary += " : ACK now";
				}
			}
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());
	
	} // FormatPropertyInstance_TransportSummary



	// DESCRIPTION: Custom description formatter for the dataframe's Command field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_DCommandSummary( LPPROPERTYINST io_pProperyInstance )
	{
		BYTE bCommand = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "Command: ";

		strSummary += ( (bCommand & PACKET_COMMAND_RELIABLE)   == PACKET_COMMAND_RELIABLE   ) ? "Reliable"					   : "Unreliable";
		strSummary += ( (bCommand & PACKET_COMMAND_SEQUENTIAL) == PACKET_COMMAND_SEQUENTIAL ) ? ", Sequenced"				   : ", Nonsequenced";
		strSummary += ( (bCommand & PACKET_COMMAND_POLL)	   == PACKET_COMMAND_POLL		) ? ", Must be ACK'ed immediately" : ", ACK can be delayed";

		if ( (bCommand & PACKET_COMMAND_NEW_MSG) == PACKET_COMMAND_NEW_MSG )
		{
			if ( (bCommand & PACKET_COMMAND_END_MSG) != PACKET_COMMAND_END_MSG )
			{
				strSummary += ", First fragment of the message";
			}
		}
		else if ( (bCommand & PACKET_COMMAND_END_MSG) == PACKET_COMMAND_END_MSG )
		{
			strSummary += ", Last fragment of the message";
		}

		strSummary += ( (bCommand & PACKET_COMMAND_USER_1) == PACKET_COMMAND_USER_1 ) ? ", DirectPlay packet" : ", User packet";
		strSummary += ( (bCommand & PACKET_COMMAND_USER_2) == PACKET_COMMAND_USER_2 ) ? ", Voice packet" : ", Data packet";

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_DCommandSummary



	// DESCRIPTION: Custom description formatter for the Command Frame's Command field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_CCommandSummary( LPPROPERTYINST io_pProperyInstance )
	{

		BYTE bCommand = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "Command: ";

		strSummary += ( (bCommand & PACKET_COMMAND_RELIABLE)   == PACKET_COMMAND_RELIABLE   ) ? "Reliable"					   : "Unreliable";
		strSummary += ( (bCommand & PACKET_COMMAND_SEQUENTIAL) == PACKET_COMMAND_SEQUENTIAL ) ? ", Sequenced"				   : ", Nonsequenced";
		strSummary += ( (bCommand & PACKET_COMMAND_POLL)	   == PACKET_COMMAND_POLL		) ? ", Must be ACK'ed immediately" : ", ACK can be delayed";
				
		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_CCommandSummary


	
	// DESCRIPTION: Custom description formatter for the dataframe's Control field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_ControlSummary( LPPROPERTYINST io_pProperyInstance )
	{

		BYTE bControl = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "Control: ";
		

		if ( (bControl & PACKET_CONTROL_RETRY) == PACKET_CONTROL_RETRY )
		{
			strSummary += "Retry";
		}
		else
		{
			strSummary += "Original";
		}


		if ( (bControl & PACKET_CONTROL_CORRELATE) == PACKET_CONTROL_CORRELATE )
		{
			strSummary += ", Correlate / KeepAlive";
		}
		

		if ( (bControl & PACKET_CONTROL_END_STREAM) == PACKET_CONTROL_END_STREAM )
		{
			strSummary += ", Last packet in the stream";
		}


		if ( ( (bControl & PACKET_CONTROL_SACK_MASK1) == PACKET_CONTROL_SACK_MASK1 ) ||
			 ( (bControl & PACKET_CONTROL_SACK_MASK2) == PACKET_CONTROL_SACK_MASK2 ) )
		{
			strSummary += "RCVD bitmask is nonzero";
		}


		if ( ( (bControl & PACKET_CONTROL_SEND_MASK1) == PACKET_CONTROL_SEND_MASK1 ) ||
			 ( (bControl & PACKET_CONTROL_SEND_MASK2) == PACKET_CONTROL_SEND_MASK2 ) )
		{
			strSummary += ", DON'T CARE bitmask is nonzero";
		}
		
		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_ControlSummary



	// DESCRIPTION: Custom description formatter for the Command Frame's SACK Flags field summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SACKFlagsSummary( LPPROPERTYINST io_pProperyInstance )
	{

		BYTE bSACKFlags = *reinterpret_cast<BYTE*>(io_pProperyInstance->lpData);

		std::string strSummary = "SACK Flags: ";
		
		strSummary += ( (bSACKFlags & SACK_FLAGS_RESPONSE) == SACK_FLAGS_RESPONSE ) ? "Retry and Timestamp fields are valid" :
																					  "Retry and/or Timestamp fields are invalid";

		if ( ( (bSACKFlags & SACK_FLAGS_SACK_MASK1) == SACK_FLAGS_SACK_MASK1 ) ||
			 ( (bSACKFlags & SACK_FLAGS_SACK_MASK2) == SACK_FLAGS_SACK_MASK2 ) )
		{
			strSummary += ", RCVD bitmask is nonzero";
		}
		else
		{
			strSummary += ", no RCVD bitmask";
		}

		if ( ( (bSACKFlags & SACK_FLAGS_SEND_MASK1) == SACK_FLAGS_SEND_MASK1 ) ||
			 ( (bSACKFlags & SACK_FLAGS_SEND_MASK2) == SACK_FLAGS_SEND_MASK2 ) )
		{
			strSummary += ", DON'T CARE bitmask is nonzero";
		}
		else
		{
			strSummary += ", no DON'T CARE bitmask";
		}


		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SACKFlagsSummary


	struct SSACKBitmaskContext
	{
		BYTE         byBase;
		BitmaskPart  Part;
		BitmaskType  Type;
		BYTE		byBit;
	};

	// DESCRIPTION: Custom description formatter for the Selective Acknowledgement Frame's RCVD bitmask's low/high DWORD summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SACKBitmaskDWORDSummary( LPPROPERTYINST io_pProperyInstance )
	{
	
		DWORD dwBitmask = *reinterpret_cast<DWORD*>(io_pProperyInstance->lpPropertyInstEx->lpData);

		SSACKBitmaskContext& rBitmaskContext = *reinterpret_cast<SSACKBitmaskContext*>(io_pProperyInstance->lpPropertyInstEx->Byte);

		std::string strSummary  = ( rBitmaskContext.Part == LOW ? "Low" : "High" );
		strSummary += " DWORD of ";
		strSummary += ( rBitmaskContext.Type == RCVD ? "RCVD" : "DON'T CARE" );
		strSummary += " bitmask: ";

		strSummary += ( ( rBitmaskContext.Type == RCVD ) ? InterpretRCVDBitmask(rBitmaskContext.Part, rBitmaskContext.byBase, &dwBitmask) :
 										    			   InterpretDONTCAREBitmask(rBitmaskContext.Part, rBitmaskContext.byBase, &dwBitmask) );

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SACKBitmaskDWORDSummary


	// DESCRIPTION: Custom description formatter for the bitmask's low/high DWORD summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_DWORDBitmaskEntry( LPPROPERTYINST io_pProperyInstance )
	{
	
		DWORD dwBitmask = *reinterpret_cast<DWORD*>(io_pProperyInstance->lpPropertyInstEx->lpData);

		SSACKBitmaskContext& rBitmaskContext = *reinterpret_cast<SSACKBitmaskContext*>(io_pProperyInstance->lpPropertyInstEx->Byte);

		BYTE byBase = rBitmaskContext.byBase;
		BYTE byBit = rBitmaskContext.byBit;
		switch ( rBitmaskContext.Type )
		{
		case RCVD:
			{
				// [i_bBase+1 .. i_bBase+1+LENGTH]
				// RCVD bitmask doesn't include the base value, since receiver can't claim it didn't receive the next dataframe to be received (NRcv);
				if ( rBitmaskContext.Part == HIGH )
				{
					// NOTE: +1 is needed to cross from MSB of the first DWORD TO LSB of the second
					byBase += 8*sizeof(DWORD)+1; // shift to LSB of the second DWORD
				}
				else
				{
					++byBase;
				}

				byBase += byBit;
				
				break;
			}

		case DONTCARE:
			{
				// [i_bBase-1-LENGTH .. i_bBase-1]
				// DON'T CARE doesn't include the base value, since transmitter can't resend/refuse resending a dataframe which is about to be sent next (NSeq).
				if ( rBitmaskContext.Part == HIGH )
				{
					byBase -= 8*sizeof(DWORD); // shift to MSB of the first DWORD
				}
				else
				{
					--byBase;
				}

				byBase -= byBit;
				
				break;
			}

		default:
			// TODO: ASSERT HERE (SHOULD NEVER HAPPEN)
			break;
		}


		static DWORD arr_dwFlags[] = { 0x00000001, 0x00000002, 0x00000004, 0x00000008,
									  0x00000010, 0x00000020, 0x00000040, 0x00000080,
									  0x00000100, 0x00000200, 0x00000400, 0x00000800,
									  0x00001000, 0x00002000, 0x00004000, 0x00008000,
									  0x00010000, 0x00020000, 0x00040000, 0x00080000,
									  0x00100000, 0x00200000, 0x00400000, 0x00800000,
									  0x01000000, 0x02000000, 0x04000000, 0x08000000,
									  0x10000000, 0x20000000, 0x40000000, 0x80000000 };
		char arr_cBuffer[100];
		char arr_cTemplate[] = "................................ = %s %d (%d%c%d)";

		arr_cTemplate[31-byBit] = ( (dwBitmask & arr_dwFlags[byBit]) ? '1' : '0' );
			
		switch ( rBitmaskContext.Type )
		{
		case RCVD:
			{
				sprintf(arr_cBuffer, arr_cTemplate, ((dwBitmask & arr_dwFlags[byBit]) ? "Received" : "Did not receive"), byBase, rBitmaskContext.byBase, '+', byBit+1);
				++byBase;
				break;
			}

		case DONTCARE:
			{
				sprintf(arr_cBuffer, arr_cTemplate, ((dwBitmask & arr_dwFlags[byBit]) ? "Cancelling" : "Successfully transmitted"), byBase, rBitmaskContext.byBase, '-', byBit+1);
				--byBase;
				break;
			}
		}

		strcpy(io_pProperyInstance->szPropertyText, arr_cBuffer);

	} // FormatPropertyInstance_DWORDBitmaskEntry

	
	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_TransportProperties[] = 
	{

		// Transport packet summary property (TRANSPORT_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "DPlay Direct Network packet",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_TransportSummary			// generic formatter
		},


		// DCommand field summary property (TRANSPORT_DCOMMAND_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Command field summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_DCommandSummary		// generic formatter
		},

		// DCommand field property (TRANSPORT_DCOMMAND)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Command field",							// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_FLAGS,							// data type qualifier.
		    &g_LabeledDCommandBitSet,					// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Control field summary property (TRANSPORT_CONTROL_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Control field summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_ControlSummary		// generic formatter
		},										

		// Control field property (TRANSPORT_CONTROL)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"Control",									// label
			"Control field",							// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledControlBitSet,					// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},

		// Packet sequence number property (TRANSPORT_SEQNUM)
		//
		// INFO: This number is incremented for each _new_ packet sent. If an endpoint retransmits
		//	     a packet, it uses the same sequence number it did the first time it sent it (base value for the DON'T CARE bitmask).
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Seq: Highest dataframe # sent (base value for the DON'T CARE bitmask)",	// label
		    "Highest dataframe # sent field",			// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Next receive number property (TRANSPORT_NEXTRECVNUM)
		//
		// INFO: Acknowledges every packet with a sequence number up to but not including this number (base value for the RCVD bitmask)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
			"NRcv: Next dataframe # to be received (base value for the RCVD bitmask)",	// label
		    "Next dataframe # to be received field",	// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

	    // CCommand field property (TRANSPORT_CCOMMAND_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Command field summary",					// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled bit set 
			512,										// description's maximum length
			FormatPropertyInstance_CCommandSummary		// generic formatter
		},

		// CCommand field property (TRANSPORT_CCOMMAND)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Command field",							// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledCCommandBitSet,					// labeled bit set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},												

	    // Extended opcode field property (TRANSPORT_EXOPCODE)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"Extended opcode",							// label
			"Extended opcode field",					// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledExOpcodeByteSet,					// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},

		// Message ID field property (TRANSPORT_MSGID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message ID",								// label
		    "Message ID field",							// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Response ID field propery (TRANSPORT_RSPID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Response ID",								// label
		    "Response ID field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Protocol version field property (TRANSPORT_VERSION)
		//
		// INFO: Makes sure both endpoints use the same version of the protocol.
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Version",									// label
		    "Version field",							// status-bar comment
		    PROP_TYPE_DWORD,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session ID field property (TRANSPORT_SESSIONID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session ID",								// label
		    "Session ID field",							// status-bar comment
		    PROP_TYPE_DWORD,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Time stamp field property (TRANSPORT_TIMESTAMP)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Time stamp",								// label
		    "Time stamp field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},


	    // SACK flags field property (TRANSPORT_SACKFIELDS_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"SACK flags summary",						// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKFlagsSummary		// generic formatter
		},

		// SACK flags field property (TRANSPORT_SACKFIELDS)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"SACK flags field",							// status-bar comment
			PROP_TYPE_BYTE,								// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledSACKFlagsBitSet,					// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance						// generic formatter
		},

		// Retry field property (TRANSPORT_RETRY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Retry",									// label
		    "Retry field",								// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Next sequence number field property (TRANSPORT_NEXTSEQNUM)
		//
		// INFO: Sequence number of the next DFrame to be sent (base value for the DON'T CARE bitmask)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "NSeq: Next dataframe # to be sent (base value for the DON'T CARE bitmask)",	// label
		    "Next dataframe # to be sent field",		// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// no data qualifiers
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

	    // Low DWORD of the Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK1_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Low DWORD of the RCVD mask summary",		// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// Low DWORD of the Selective-ACK RCVD Mask property (TRANSPORT_RCVDMASK1)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Low DWORD of the RCVD mask",				// label
		    "Low DWORD of the RCVD mask field",			// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},											

	    // High DWORD of the Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK2_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"High DWORD of the RCVD mask summary",		// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// High DWORD of Selective-ACK RCVD Mask property (TRANSPORT_RCVDMASK2)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "High DWORD of the RCVD mask",				// label
		    "High DWORD of the RCVD mask field",		// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},

	    // Low DWORD of the Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK1_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"Low DWORD of the DON'T CARE mask summary",		// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// Low DWORD of the Selective-ACK DON'T CARE Mask property (TRANSPORT_DONTCAREMASK1)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Low DWORD of the DON'T CARE mask",			// label
		    "Low DWORD of the DON'T CARE mask field",	// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},

	    // High DWORD of the Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK2_SUMMARY)
	    {
			0,											// handle placeholder (MBZ)
			0,											// reserved (MBZ)
			"",											// label
			"High DWORD of the DON'T CARE mask summary",	// status-bar comment
			PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
			512,										// description's maximum length
			FormatPropertyInstance_SACKBitmaskDWORDSummary	// generic formatter
		},

		// High DWORD of the Selective-ACK DON'T CARE Mask property (TRANSPORT_DONTCAREMASK2)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "High DWORD of the DON'T CARE mask",		// label
		    "High DWORD of the DON'T CARE mask field",   // status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    3072,										// description's maximum length
		    FormatPropertyInstance_DWORDBitmaskEntry		// generic formatter
		},

		// Compression Type property (VOICE_USERDATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "User Data",								// label
		    "User Data",								// status-bar comment
		    PROP_TYPE_RAW_DATA,							// data type (GUID)
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		}

	};

	enum
	{
		nNUM_OF_TRANSPORT_PROPS = sizeof(g_arr_TransportProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		TRANSPORT_SUMMARY = 0,
		TRANSPORT_DCOMMAND_SUMMARY,
		TRANSPORT_DCOMMAND,
		TRANSPORT_CONTROL_SUMMARY,
		TRANSPORT_CONTROL,
		TRANSPORT_SEQNUM,
		TRANSPORT_NEXTRECVNUM,
		TRANSPORT_CCOMMAND_SUMMARY,
		TRANSPORT_CCOMMAND,
		TRANSPORT_EXOPCODE,
		TRANSPORT_MSGID,
		TRANSPORT_RSPID,
		TRANSPORT_VERSION,
		TRANSPORT_SESSIONID,
		TRANSPORT_TIMESTAMP,
		TRANSPORT_SACKFIELDS_SUMMARY,
		TRANSPORT_SACKFIELDS,
		TRANSPORT_RETRY,
		TRANSPORT_NEXTSEQNUM,
		TRANSPORT_RCVDMASK1_SUMMARY,
		TRANSPORT_RCVDMASK1,
		TRANSPORT_RCVDMASK2_SUMMARY,
		TRANSPORT_RCVDMASK2,
		TRANSPORT_DONTCAREMASK1_SUMMARY,
		TRANSPORT_DONTCAREMASK1,
		TRANSPORT_DONTCAREMASK2_SUMMARY,
		TRANSPORT_DONTCAREMASK2,
		TRANSPORT_USERDATA
	};

} // anonymous namespace




// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI TransportRegister( HPROTOCOL i_hTransportProtocol ) 
{

	CreatePropertyDatabase(i_hTransportProtocol, nNUM_OF_TRANSPORT_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_TRANSPORT_PROPS; ++nProp )
	{
	   AddProperty(i_hTransportProtocol, &g_arr_TransportProperties[nProp]);
	}

} // TransportRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI TransportDeregister( HPROTOCOL i_hProtocol )
{

	DestroyPropertyDatabase(i_hProtocol);

} // TransportDeregister




namespace
{

	// DESCRIPTION: Parses the Transport frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbTransportFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//							  in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the specified Transport frame (in bytes)
	//
	int TransportHeaderSize( BYTE* i_pbTransportFrame )
	{

		int arr_nNumOfBits[] = { /*00 = 0x0000*/ 0, /*01 = 0x0001*/ 1, /*02 = 0x0010*/ 1, /*03 = 0x0011*/ 2,
								 /*04 = 0x0100*/ 1, /*05 = 0x0101*/ 2, /*06 = 0x0110*/ 2, /*07 = 0x0111*/ 3,
								 /*08 = 0x1000*/ 1, /*09 = 0x1001*/ 2, /*10 = 0x1010*/ 2, /*11 = 0x1011*/ 3,
								 /*12 = 0x1100*/ 2, /*13 = 0x1101*/ 3, /*14 = 0x1110*/ 3, /*15 = 0x1111*/ 4 };
		
		const DFRAME&	rDFrame	= *reinterpret_cast<DFRAME*>(i_pbTransportFrame);

		if ( (rDFrame.bCommand & PACKET_COMMAND_DATA)  ==  PACKET_COMMAND_DATA )	// DFrame
		{
			return  sizeof(rDFrame) + sizeof(DWORD)*arr_nNumOfBits[rDFrame.bControl >> 4];
		}
		else
		{
			const CFRAME&	rCFrame	= *reinterpret_cast<CFRAME*>(i_pbTransportFrame);

			if ( rCFrame.bExtOpcode == FRAME_EXOPCODE_SACK )	// SACK CFrame
			{
				const SFBIG8* pSFrame = reinterpret_cast<SFBIG8*>(i_pbTransportFrame);
				ULONG ulMaskSize = sizeof(DWORD)*arr_nNumOfBits[(pSFrame->bFlags >> 1) & 0x0F];

				// This is a Protocol version 1.0 frame
				return sizeof(SACKFRAME8) + ulMaskSize;
			}
			else	// Connection Control CFrame
			{
				return  sizeof(rCFrame);
			}
		}

	} // TransportHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbTransportFrame       - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbTransportFrame parameter.
//
DPLAYPARSER_API BYTE* BHAPI TransportRecognizeFrame( HFRAME        i_hFrame,
													  ULPBYTE        i_upbMacFrame,	
													  ULPBYTE        i_upbTransportFrame,
													  DWORD         i_dwMacType,        
													  DWORD         i_dwBytesLeft,      
													  HPROTOCOL     i_hPrevProtocol,  
													  DWORD         i_dwPrevProtOffset,
													  LPDWORD       o_pdwProtocolStatus,
													  LPHPROTOCOL   o_phNextProtocol,
												      PDWORD_PTR    io_pdwptrInstData )
{

	// Validate the amount of unclaimed data
	enum
	{
		nMIN_TransportHeaderSize = min(min(sizeof(DFRAME), sizeof(CFRAME)), sizeof(SACKFRAME8))
	};


	// Validate the packet as DPlay Transport type
	if ( i_dwBytesLeft < nMIN_TransportHeaderSize )
	{
		// Assume the unclaimed data is not recognizable
		*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
		return i_upbTransportFrame;
	}


	// Check if we are dealing with a DPlay Voice packet
	enum
	{
		PACKET_COMMAND_SESSION  = PACKET_COMMAND_DATA | PACKET_COMMAND_USER_1,
		PACKET_COMMAND_VOICE = PACKET_COMMAND_DATA | PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2
	};

	const DFRAME&	rDFrame	= *reinterpret_cast<DFRAME*>(i_upbTransportFrame);

	*o_pdwProtocolStatus = PROTOCOL_STATUS_NEXT_PROTOCOL;

	// Let upper protocol's parser know if the message is a non-initial fragment of a fragmented message
	*io_pdwptrInstData = ((rDFrame.bCommand & PACKET_COMMAND_NEW_MSG)  ==  PACKET_COMMAND_NEW_MSG);


	if ( (rDFrame.bCommand & PACKET_COMMAND_VOICE)  ==  PACKET_COMMAND_VOICE )
	{
		// Notify NetMon about the handoff protocol
		*o_phNextProtocol	 = GetProtocolFromName("DPLAYVOICE");
	}
	else if ( (rDFrame.bCommand & PACKET_COMMAND_SESSION)  ==  PACKET_COMMAND_SESSION )
	{
		// Notify NetMon about the handoff protocol
		*o_phNextProtocol	 = GetProtocolFromName("DPLAYSESSION");
	}
	else
	{
		*o_pdwProtocolStatus = PROTOCOL_STATUS_RECOGNIZED;
		*o_phNextProtocol	 = NULL;
	}

    return i_upbTransportFrame + TransportHeaderSize(i_upbTransportFrame);

} // TransportRecognizeFrame



//=======================================//
// Attaching properties helper functions //
//=======================================//
namespace
{



	// DESCRIPTION: Maps the DWORD bitmask properties on a per-bit basis.
	//
	// ARGUMENTS: i_hFrame     - Handle of the frame that is being parsed.
	//			  i_nPropertyIndex - Index of the property in the global properties table.
	//			  i_pdwBitmask - Pointer to the value to which the property is being attached.
	//			  i_byBase - Base value from which the entry value is calculated.
	//			  i_Part - LOW or HIGH part of the QWORD bitmask.
	//			  i_Type - RCVD or DONTCARE type of the bitmask.
	//			  i_byLevel - Level in the detail pane tree.
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV AttachBitmaskDWORDProperties( HFRAME i_hFrame, int i_nPropertyIndex, UNALIGNED DWORD* i_pdwBitmask, BYTE i_byBase,
											  BitmaskPart i_Part, BitmaskType i_Type, BYTE i_byLevel )
	{
		for ( BYTE byBit = 0; byBit < 32; ++byBit )
		{
			SSACKBitmaskContext  BitmaskContext = { i_byBase, i_Part, i_Type, byBit };

			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[i_nPropertyIndex].hProperty,
								   sizeof(*i_pdwBitmask), i_pdwBitmask,
								   sizeof(BitmaskContext), &BitmaskContext,
								   0, i_byLevel, 0);
		}
	
	} // AttachBitmaskDWORDProperties



	// DESCRIPTION: Maps the Data-Frame properties that exist in a piece of recognized data to specific locations.
	//
	// ARGUMENTS: i_hFrame     - Handle of the frame that is being parsed.
	//			  i_pbDFrame   - Pointer to the start of the recognized data.
	//
	// RETURNS: NOTHING
	//
	void AttachDFRAMEProperties( HFRAME  i_hFrame,
								 BYTE*  i_pbDFrame )
	{

		//=======================================//
		// Processing the core dataframe fields //
		//=======================================//
		//
		DFRAME&	 rDFrame = *reinterpret_cast<DFRAME*>(i_pbDFrame);
		
		// DCommand summary
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_DCOMMAND_SUMMARY].hProperty,
		                       sizeof(rDFrame.bCommand), &rDFrame.bCommand, 0, 1, 0);
	    
	    // DCommand field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_DCOMMAND].hProperty,
		                       sizeof(rDFrame.bCommand), &rDFrame.bCommand, 0, 2, 0);

		// Control summary
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CONTROL_SUMMARY].hProperty,
		                       sizeof(rDFrame.bControl), &rDFrame.bControl, 0, 1, 0);
	    // Control field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CONTROL].hProperty,
		                       sizeof(rDFrame.bControl), &rDFrame.bControl, 0, 2, 0);

	    // Sequence number field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SEQNUM].hProperty,
		                       sizeof(rDFrame.bSeq), &rDFrame.bSeq, 0, 1, 0);

		// Next receive number field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_NEXTRECVNUM].hProperty,
		                       sizeof(rDFrame.bNRcv), &rDFrame.bNRcv, 0, 1, 0);


		//==================================================//
		// Processing the optional dataframe bitmask fields //
		//==================================================//
		//
		UNALIGNED DFBIG&  rDBigFrame = *reinterpret_cast<UNALIGNED DFBIG *>(i_pbDFrame);
		int nBitMaskIndex = 0;

		if ( (rDFrame.bControl & PACKET_CONTROL_SACK_MASK1)  ==  PACKET_CONTROL_SACK_MASK1 )
		{
			SSACKBitmaskContext  LowRCVDContext = { rDBigFrame.bNRcv, LOW, RCVD, NULL };
			
			// Low DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK1_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK1_SUMMARY].hProperty,
								   sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								   sizeof(LowRCVDContext), &LowRCVDContext,
								   0, 1, 0);


			// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK1)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bNRcv, LOW, RCVD, 2);

			++nBitMaskIndex;
		}

		if ( (rDFrame.bControl & PACKET_CONTROL_SACK_MASK2)  ==  PACKET_CONTROL_SACK_MASK2 )
		{
			SSACKBitmaskContext  HighRCVDContext = { rDBigFrame.bNRcv, HIGH, RCVD, NULL };
			
			// High DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK2_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK2_SUMMARY].hProperty,
								  sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								  sizeof(HighRCVDContext), &HighRCVDContext,
								  0, 1, 0);

			// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK2)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bNRcv, HIGH, RCVD, 2);

			++nBitMaskIndex;
		}

		if ( (rDFrame.bControl & PACKET_CONTROL_SEND_MASK1)  ==  PACKET_CONTROL_SEND_MASK1 )
		{
			SSACKBitmaskContext  LowDONTCAREContext = { rDBigFrame.bSeq, LOW, DONTCARE, NULL };

			// Low DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK1_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK1_SUMMARY].hProperty,
								  sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								  sizeof(LowDONTCAREContext), &LowDONTCAREContext,
								  0, 1, 0);

			// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK1)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bSeq, LOW, DONTCARE, 2);

			++nBitMaskIndex;
		}

		if ( (rDFrame.bControl & PACKET_CONTROL_SEND_MASK2)  ==  PACKET_CONTROL_SEND_MASK2 )
		{
			SSACKBitmaskContext  HighDONTCAREContext = { rDBigFrame.bSeq, HIGH, DONTCARE, NULL };
			
			// High DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK2_SUMMARY)
			AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK2_SUMMARY].hProperty,
								   sizeof(rDBigFrame.rgMask[nBitMaskIndex]), &rDBigFrame.rgMask[nBitMaskIndex],
								   sizeof(HighDONTCAREContext), &HighDONTCAREContext,
								   0, 1, 0);

			// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK2)
			AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &rDBigFrame.rgMask[nBitMaskIndex], rDBigFrame.bSeq, HIGH, DONTCARE, 2);

		}

	} // AttachDFRAMEProperties



	// DESCRIPTION: Maps the Command-Frame properties that exist in a piece of recognized data to specific locations.
	//
	// ARGUMENTS: i_hFrame   - Handle of the frame that is being parsed.
	//			  i_pbCFrame - Pointer to the start of the recognized data.
	//
	// RETURNS: NOTHING
	//
	void AttachCFRAMEProperties( HFRAME  i_hFrame,
								 BYTE*  i_pbCFrame)
	{

		// Processing the core command frame fields
		//
		CFRAME&  rCFrame = *reinterpret_cast<CFRAME*>(i_pbCFrame);

	    // CCommand summary
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CCOMMAND_SUMMARY].hProperty,
		                       sizeof(rCFrame.bCommand), &rCFrame.bCommand, 0, 1, 0);
	    // CCommand field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_CCOMMAND].hProperty,
		                       sizeof(rCFrame.bCommand), &rCFrame.bCommand, 0, 2, 0);

		// ExtOpcode field
	    AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_EXOPCODE].hProperty,
		                       sizeof(rCFrame.bExtOpcode), &rCFrame.bExtOpcode, 0, 1, 0);

		if ( rCFrame.bExtOpcode == FRAME_EXOPCODE_SACK )
		{
			//=======================================================//
			// Processing the Selective Acknowledgement Command frame fields //
			//=======================================================//
			//
			SFBIG8*  pSFrame	= reinterpret_cast<SFBIG8*>(i_pbCFrame);

			// SACK flags summary
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SACKFIELDS_SUMMARY].hProperty,
								   sizeof(pSFrame->bFlags), &pSFrame->bFlags, 0, 1, 0);
			// SACK flags field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SACKFIELDS].hProperty,
								   sizeof(pSFrame->bFlags), &pSFrame->bFlags, 0, 2, 0);

			// Retry field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_RETRY].hProperty,
								   sizeof(pSFrame->bRetry), &pSFrame->bRetry, 0, 1, 0);

			// Next sequence number field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_NEXTSEQNUM].hProperty,
								   sizeof(pSFrame->bNSeq), &pSFrame->bNSeq, 0, 1, 0);
			
			// Next receive number field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_NEXTRECVNUM].hProperty,
								   sizeof(pSFrame->bNRcv), &pSFrame->bNRcv, 0, 1, 0);

			UNALIGNED ULONG* pulMasks = 0;

			// This is a Protocol version 1.0 frame

			// Timestamp field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_TIMESTAMP].hProperty,
						   sizeof(pSFrame->tTimestamp), &pSFrame->tTimestamp, 0, 1, 0);
			pulMasks = pSFrame->rgMask;

			//================================================================================//
			// Processing the optional Selective Acknowledgement Command frame bitmask fields //
			//================================================================================//
			//

			int nBitMaskIndex = 0;

			if ( (pSFrame->bFlags & SACK_FLAGS_SACK_MASK1)  ==  SACK_FLAGS_SACK_MASK1 )
			{
				SSACKBitmaskContext  LowRCVDContext = { pSFrame->bNRcv, LOW, RCVD, NULL };
				
				// Low DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK1_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK1_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
									   sizeof(LowRCVDContext), &LowRCVDContext,
									   0, 1, 0);

				// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK1)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &pulMasks[nBitMaskIndex], pSFrame->bNRcv, LOW, RCVD, 2);
				
				++nBitMaskIndex;
			}

			if ( (pSFrame->bFlags & SACK_FLAGS_SACK_MASK2)  ==  SACK_FLAGS_SACK_MASK2 )
			{
				SSACKBitmaskContext  HighRCVDContext = { pSFrame->bNRcv, HIGH, RCVD, NULL };
				
				// High DWORD of Selective-ACK RCVD Mask summary (TRANSPORT_RCVDMASK2_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_RCVDMASK2_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
									   sizeof(HighRCVDContext), &HighRCVDContext,
									   0, 1, 0);

				// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_RCVDMASK2)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &pulMasks[nBitMaskIndex], pSFrame->bNRcv, HIGH, RCVD, 2);

				++nBitMaskIndex;
			}

			if ( (pSFrame->bFlags & SACK_FLAGS_SEND_MASK1)  ==  SACK_FLAGS_SEND_MASK1 )
			{
				SSACKBitmaskContext  LowDONTCAREContext = { pSFrame->bNSeq, LOW, DONTCARE, NULL };
				
				// Low DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK1_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK1_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
	 								   sizeof(LowDONTCAREContext), &LowDONTCAREContext,
									   0, 1, 0);

				// Low DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK1)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK1, &pulMasks[nBitMaskIndex], pSFrame->bNSeq, LOW, DONTCARE, 2);
				
				++nBitMaskIndex;
			}

			if ( (pSFrame->bFlags & SACK_FLAGS_SEND_MASK2)  ==  SACK_FLAGS_SEND_MASK2 )
			{
				SSACKBitmaskContext  HighDONTCAREContext = { pSFrame->bNSeq, HIGH, DONTCARE, NULL };
				
				// High DWORD of Selective-ACK DON'T CARE Mask summary (TRANSPORT_DONTCAREMASK2_SUMMARY)
				AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_DONTCAREMASK2_SUMMARY].hProperty,
									   sizeof(pulMasks[nBitMaskIndex]), &pulMasks[nBitMaskIndex],
									   sizeof(HighDONTCAREContext), &HighDONTCAREContext,
									   0, 1, 0);

				// High DWORD of Selective-ACK RCVD Mask field (TRANSPORT_DONTCAREMASK2)
				AttachBitmaskDWORDProperties(i_hFrame, TRANSPORT_RCVDMASK2, &pulMasks[nBitMaskIndex], pSFrame->bNSeq, HIGH, DONTCARE, 2);
				
				++nBitMaskIndex;
			}
		}
		else
		{
			//========================================================//
			// Processing the Connection Control Command frame fields //
			//========================================================//

			// Message ID field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_MSGID].hProperty,
								   sizeof(rCFrame.bMsgID), &rCFrame.bMsgID, 0, 1, 0);

			// Response ID field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_RSPID].hProperty,
								   sizeof(rCFrame.bRspID), &rCFrame.bRspID, 0, 1, 0);

			// Version number field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_VERSION].hProperty,
								   sizeof(rCFrame.dwVersion), &rCFrame.dwVersion, 0, 1, 0);

			// Session ID field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_SESSIONID].hProperty,
								   sizeof(rCFrame.dwSessID), &rCFrame.dwSessID, 0, 1, 0);
		
			// Timestamp field
			AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_TIMESTAMP].hProperty,
								   sizeof(rCFrame.tTimestamp), &rCFrame.tTimestamp, 0, 1, 0);
		}

	} // AttachCFRAMEProperties


	// Platform independent memory accessor of big endian words
	inline WORD ReadBigEndianWord( BYTE* i_pbData )
	{
		return (*i_pbData << 8) | *(i_pbData+1);
	}

}	// Anonymous namespace



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbTransportFrame - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API BYTE* BHAPI TransportAttachProperties( HFRAME      i_hFrame,
														ULPBYTE      i_upbMacFrame,
														ULPBYTE      i_upbTransportFrame,
														DWORD       i_dwMacType,
														DWORD       i_dwBytesLeft,
														HPROTOCOL   i_hPrevProtocol,
														DWORD       i_dwPrevProtOffset,
														DWORD_PTR   i_dwptrInstData )
{
	// TODO: Use HelpID in AttachPropertyInstance

	// Check if the packet is a KeepAlive
	const size_t  sztTransportHeaderSize = TransportHeaderSize(i_upbTransportFrame);
	const DFRAME& rDFrame = *reinterpret_cast<DFRAME*>(i_upbTransportFrame);


	size_t sztTransportFrameSize = i_dwptrInstData;
	// If an empty dataframe and not the last packet in the stream, than it's a KeepAlive
	BOOL bKeepAlive = ( (sztTransportHeaderSize  ==  sztTransportFrameSize) &&
						((rDFrame.bControl & PACKET_CONTROL_END_STREAM)  !=  PACKET_CONTROL_END_STREAM) );


    //===================//
    // Attach Properties //
    //===================//
	//
    // Transport summary line
    AttachPropertyInstanceEx(i_hFrame, g_arr_TransportProperties[TRANSPORT_SUMMARY].hProperty,
							 sztTransportHeaderSize, i_upbTransportFrame,
							 sizeof(BOOL), &bKeepAlive,
							 0, 0, 0);

	#if defined(PARSE_DPLAY_TRANSPORT)
	
		if ( (rDFrame.bCommand & PACKET_COMMAND_DATA)  ==  PACKET_COMMAND_DATA )
		{
			AttachDFRAMEProperties(i_hFrame, i_upbTransportFrame);

			enum
			{
				USERDATA_BITMASK = ~(PACKET_COMMAND_USER_1 | PACKET_COMMAND_USER_2)
			};

			if ( (rDFrame.bCommand | USERDATA_BITMASK) == USERDATA_BITMASK )
			{
				// User data (TRANSPORT_USERDATA)
				AttachPropertyInstance(i_hFrame, g_arr_TransportProperties[TRANSPORT_USERDATA].hProperty,
									   sztTransportFrameSize - sztTransportHeaderSize, i_upbTransportFrame + sztTransportHeaderSize, 0, 1, 0);
			}
		}
		else
		{
			AttachCFRAMEProperties(i_hFrame, i_upbTransportFrame);
		}

	#endif // PARSE_DPLAY_TRANSPORT

	return NULL;

} // TransportAttachProperties





// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbTransportFrame.
//
DPLAYPARSER_API DWORD BHAPI TransportFormatProperties( HFRAME          i_hFrame,
													   ULPBYTE          i_upbMacFrame,
													   ULPBYTE          i_upbTransportFrame,
													   DWORD           i_dwPropertyInsts,
													   LPPROPERTYINST  i_pPropInst )
{
    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
		reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

    return NMERR_SUCCESS;
}




// DESCRIPTION: Notifies Network Monitor that Transport protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateTransportProtocol( void )
{
	
	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS TransportEntryPoints =
	{
		// TransportParser Entry Points
		TransportRegister,
		TransportDeregister,
		TransportRecognizeFrame,
		TransportAttachProperties,
		TransportFormatProperties
	};
	
	// The first active instance of this parser needs to register with the kernel
	g_hTransportProtocol = CreateProtocol("DPLAYTRANSPORT", &TransportEntryPoints, ENTRYPOINTS_SIZE);

	return (g_hTransportProtocol ? TRUE : FALSE);

} // CreateTransportProtocol



// DESCRIPTION: Removes the Transport protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroyTransportProtocol( void )
{

	DestroyProtocol(g_hTransportProtocol);

} // DestroyTransportProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\transportparser.hpp ===
#ifndef _TransportParser_H_
#define _TransportParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI TransportRegister( HPROTOCOL i_hTransportProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hTransportProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI TransportDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbTransportFrame  - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbTransportFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI TransportRecognizeFrame( HFRAME        i_hFrame,
													  ULPBYTE        i_upbMacFrame,	
													  ULPBYTE        i_upbTransportFrame,
                                   					  DWORD         i_dwMacType,        
                                   					  DWORD         i_dwBytesLeft,      
                                   					  HPROTOCOL     i_hPrevProtocol,  
                                   					  DWORD         i_dwPrevProtOffset,
                                   					  LPDWORD       o_pdwProtocolStatus,
                                   					  LPHPROTOCOL   o_hNextProtocol,
													  PDWORD_PTR    io_pdwptrInstData );

// DESCRIPTION: Maps the properties that exist in a piece of recognized data to specific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbTransportFrame - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbTransportFrame.
//
DPLAYPARSER_API LPBYTE BHAPI TransportAttachProperties( HFRAME      i_hFrame,
													    ULPBYTE      i_upbMacFrame,
														ULPBYTE      i_upbTransportFrame,
														DWORD       i_dwMacType,
														DWORD       i_dwBytesLeft,
														HPROTOCOL   i_hPrevProtocol,
														DWORD       i_dwPrevProtOffset,
													    DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is displayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbTransportFrame.
//
DPLAYPARSER_API DWORD BHAPI TransportFormatProperties( HFRAME          i_hFrame,
													   ULPBYTE          i_upbMacFrame,
													   ULPBYTE          i_upbTransportFrame,
												  	   DWORD           i_dwPropertyInsts,
													   LPPROPERTYINST  i_pPropInst );


bool CreateTransportProtocol( void );
void DestroyTransportProtocol( void );

#endif // _TransportParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\internal\daytona\makefile.inc ===
misc :
	copy ..\..\DPlay8Parser.cpp .
	copy ..\..\SessionParser.cpp .
	copy ..\..\SPParser.cpp .
	copy ..\..\TransportParser.cpp .
	copy ..\..\VoiceParser.cpp .
	copy ..\..\dp8parse.rc .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\voiceparser.cpp ===
//=============================================================================
//  FILE: VoiceParser.cpp
//
//  Description: DirectPlay Service Provider Parser
//
//
//  Modification History:
//
//  Michael Milirud      08/Aug/2000    Created
//=============================================================================


//==================//
// Standard headers //
//==================//
#include <string>
#include <winsock2.h>
#include <wsipx.h>

// DVoice.h, included by DVProt.h, will _define_ the Compression Type GUIDs.
#include <initguid.h>


//=====================//
// Proprietary headers //
//=====================//

// Prototypes
#include "VoiceParser.hpp"

// Voice protocol header
#include "DVoice.h"
#include "DVProt.h"


namespace
{
	HPROTOCOL  g_hVoiceProtocol;

	
	//====================//
	// Message Type field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BYTE g_arr_MessageTypeByteLabels[] = { { DVMSGID_CONNECTREQUEST,	  "Establishing connection"						   },
												   { DVMSGID_CONNECTREFUSE,		  "Connection request rejected"					   },
										           { DVMSGID_CONNECTACCEPT,		  "Connection request granted"					   },
										           { DVMSGID_SETTINGSCONFIRM,     "Confirming support for the connection settings" },
										           { DVMSGID_PLAYERLIST,		  "List of players in the session"				   },
										           { DVMSGID_SPEECH,			  "Audio data"									   },
										           { DVMSGID_SPEECHWITHTARGET,	  "Targeted audio data"							   },
										           { DVMSGID_SPEECHWITHFROM,	  "Proxied audio data"							   },
										           { DVMSGID_SETTARGETS,		  "Setting client's target"			 		       },
										           { DVMSGID_CREATEVOICEPLAYER,	  "New player joined the session"			       },
										           { DVMSGID_DELETEVOICEPLAYER,	  "Player left the session"						   },
										           { DVMSGID_SESSIONLOST,		  "Session is lost"								   },
										           { DVMSGID_DISCONNECTCONFIRM,	  "Disconnection notification acknowledged"	       },
										           { DVMSGID_DISCONNECT,		  "Disconnecting"								   },
												   { DVMSGID_PLAYERLIST,		  "Players list"								   } };

	SET g_LabeledMessageTypeByteSet = { sizeof(g_arr_MessageTypeByteLabels) / sizeof(LABELED_BYTE), g_arr_MessageTypeByteLabels };



	//===================//
	// Result Code field //----------------------------------------------------------------------------------------------
	//===================//
	LABELED_DWORD g_arr_ResultCodeDWordLabels[] = { { DVERR_BUFFERTOOSMALL,				"Buffer is too small"										},
												    { DVERR_EXCEPTION,					"Exception was thrown"										},
												    { DVERR_GENERIC,					"Generic error"												},
												    { DVERR_INVALIDFLAGS,				"Invalid flags"												},
												    { DVERR_INVALIDOBJECT,				"Invalid object"											},
												    { DVERR_INVALIDPARAM,				"Invalid parameter(s)"										},
												    { DVERR_INVALIDPLAYER,				"Invalid player"											},
												    { DVERR_INVALIDGROUP,				"Invalid group"												},
												    { DVERR_INVALIDHANDLE,				"Invalid handle"											},
												    { DVERR_INVALIDPOINTER,				"Invalid pointer"											},
												    { DVERR_OUTOFMEMORY,				"Out of memory"												},
												    { DVERR_CONNECTABORTING,			"Aborting connection"										},
												    { DVERR_CONNECTIONLOST,				"Connection lost"											},
												    { DVERR_CONNECTABORTED,				"Connection aborted"										},
												    { DVERR_CONNECTED,					"Connected"													},
												    { DVERR_NOTCONNECTED,				"Not connected"												},
												    { DVERR_NOTINITIALIZED,				"Not initialized"											},
												    { DVERR_NOVOICESESSION,				"No voice session"											},
												    { DVERR_NOTALLOWED,					"Not allowed"												},
												    { DVERR_NOTHOSTING,					"Not hosting"												},
												    { DVERR_NOTSUPPORTED,				"Not supported"												},
												    { DVERR_NOINTERFACE,				"No interface"												},
												    { DVERR_NOTBUFFERED,				"Not buffered"												},
												    { DVERR_NOTRANSPORT,				"No transport"												},
												    { DVERR_NOCALLBACK,					"No callback"												},
												    { DVERR_NO3DSOUND,					"No 3D sound"												},
												    { DVERR_NORECVOLAVAILABLE,			"No recording volume available"								},
												    { DVERR_SESSIONLOST,				"Session lost"												},
												    { DVERR_PENDING,					"Pending"													},
												    { DVERR_INVALIDTARGET,				"Invalid target"											},
												    { DVERR_TRANSPORTNOTHOST,			"Transport is not hosting"									},
												    { DVERR_COMPRESSIONNOTSUPPORTED,	"Compression is not supported"								},
												    { DVERR_ALREADYPENDING,				"Already pending"											},
												    { DVERR_SOUNDINITFAILURE,			"Sound initialization failed"								},
												    { DVERR_TIMEOUT,					"Timeout"													},
												    { DVERR_ALREADYBUFFERED,			"Already buffered"											},
												    { DVERR_HOSTING,					"Hosting"													},
												    { DVERR_INVALIDDEVICE,				"Invalid device"											},
												    { DVERR_RECORDSYSTEMERROR,			"Record system error"										},
												    { DVERR_PLAYBACKSYSTEMERROR,		"Playback system error"										},
												    { DVERR_SENDERROR,					"Send error"												},
												    { DVERR_USERCANCEL,					"Cancelled by user"											},
												    { DVERR_RUNSETUP,					"Run setup"													},
												    { DVERR_INCOMPATIBLEVERSION,		"Incompatible version"										},
												    { DVERR_INITIALIZED,				"Initialized"												},
												    { DVERR_TRANSPORTNOTINIT,			"Transport not initialized"									},
												    { DVERR_TRANSPORTNOSESSION,			"Transport is not hosting or connecting"					},
												    { DVERR_TRANSPORTNOPLAYER,			"Legacy DirectPlay local player has not yet been created"	},
												    { DVERR_USERBACK,					"Back button was used improperly in the wizard"				},
												    { DVERR_INVALIDBUFFER,				"Invalid buffer"											},
													{ DV_OK,							"Success"													} };

	SET g_LabeledResultCodeDWordSet = { sizeof(g_arr_ResultCodeDWordLabels) / sizeof(LABELED_DWORD), g_arr_ResultCodeDWordLabels };


	//====================//
	// Session Type field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_DWORD g_arr_SessionTypeDWordLabels[] = { { DVSESSIONTYPE_PEER,			"Peer to peer"	  },
													 { DVSESSIONTYPE_MIXING,		"Mixing server"	  },
													 { DVSESSIONTYPE_FORWARDING,  "Forwarding server" },
													 { DVSESSIONTYPE_ECHO,			"Loopback"		  } };

	SET g_LabeledSessionTypeDWordSet = { sizeof(g_arr_SessionTypeDWordLabels) / sizeof(LABELED_DWORD), g_arr_SessionTypeDWordLabels };


	//====================//
	// Session Flags field //--------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_SessionFlagsBitLabels[] = { { 1, "Host Migration enabled",	    "No Host Migration"		     },	    // DVSESSION_NOHOSTMIGRATION
												  { 2, "No Server Control Target mode", "Server Control Target mode" } };	// DVSESSION_SERVERCONTROLTARGET

	SET g_LabeledSessionFlagsBitSet = { sizeof(g_arr_SessionFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_SessionFlagsBitLabels };


	//====================//
	// Player Flags field //---------------------------------------------------------------------------------------------
	//====================//
	LABELED_BIT g_arr_PlayerFlagsBitLabels[] = { { 1, "Player supports full-duplex connection", "Player only supports half-duplex connection" } }; // DVPLAYERCAPS_HALFDUPLEX

	SET g_LabeledPlayerFlagsBitSet = { sizeof(g_arr_PlayerFlagsBitLabels) / sizeof(LABELED_BIT), g_arr_PlayerFlagsBitLabels };


	//=====================//
	// Host Order ID field //--------------------------------------------------------------------------------------------
	//=====================//
	LABELED_DWORD g_arr_HostOrderDWordLabels[] = { { -1, "Hasn't been assigned by the host yet"	} };

	SET g_LabeledHostOrderIDDWordSet = { sizeof(g_arr_HostOrderDWordLabels) / sizeof(LABELED_DWORD), g_arr_HostOrderDWordLabels };


	////////////////////////////////
	// Custom Property Formatters //=====================================================================================
	////////////////////////////////

	// DESCRIPTION: Custom description formatter for the Voice packet summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_VoiceSummary( LPPROPERTYINST io_pProperyInstance )
	{
		std::string strSummary;
		char arr_cBuffer[10];

		DVPROTOCOLMSG_FULLMESSAGE&	rVoiceFrame = *reinterpret_cast<DVPROTOCOLMSG_FULLMESSAGE*>(io_pProperyInstance->lpData);

		DWORD dwType = rVoiceFrame.dvGeneric.dwType;


		// Message classification
		switch ( dwType )
		{
		case DVMSGID_CONNECTREQUEST:
		case DVMSGID_CONNECTREFUSE:
		case DVMSGID_CONNECTACCEPT:
		case DVMSGID_DISCONNECT:
		case DVMSGID_DISCONNECTCONFIRM:
		case DVMSGID_SETTINGSCONFIRM:
			{
				strSummary = "Connection Control : ";
				break;
			}

		case DVMSGID_SPEECH:
		case DVMSGID_SPEECHWITHTARGET:
		case DVMSGID_SPEECHWITHFROM:
			{
				strSummary = "Speech : ";
				break;
			}

		case DVMSGID_PLAYERLIST:
		case DVMSGID_SETTARGETS:
		case DVMSGID_CREATEVOICEPLAYER:
		case DVMSGID_DELETEVOICEPLAYER:
		case DVMSGID_SESSIONLOST:
			{
				strSummary = "Session Control : ";
				break;
			}

		default:
			{
				strSummary = "INVALID";
				break;
			}
		}


		// Message title
		switch ( dwType )
		{
		case DVMSGID_CREATEVOICEPLAYER:
			{
				strSummary += "Player ";
				strSummary += _itoa(rVoiceFrame.dvPlayerJoin.dvidID, arr_cBuffer, 16);
				strSummary += " joined the session";
				break;
			}

		default:
			{
				for ( int n = 0; n < sizeof(g_arr_MessageTypeByteLabels) / sizeof(LABELED_BYTE); ++n )
				{
					if ( g_arr_MessageTypeByteLabels[n].Value == dwType )
					{
						strSummary += g_arr_MessageTypeByteLabels[n].Label;
						break;
					}
				}

				break;
			}
		}

		// Message highlights
		switch ( dwType )
		{
		case DVMSGID_PLAYERLIST:
			{
				strSummary += " (";
				strSummary += _itoa(rVoiceFrame.dvPlayerList.dwNumEntries, arr_cBuffer, 10);
				strSummary += " players)";
				break;
			}

		case DVMSGID_CONNECTACCEPT:
			{
				strSummary += " (";
				for ( int n = 0; n < sizeof(g_arr_SessionTypeDWordLabels)/sizeof(LABELED_DWORD); ++n )
				{
					if ( g_arr_SessionTypeDWordLabels[n].Value == rVoiceFrame.dvConnectAccept.dwSessionType )
					{
						strSummary += g_arr_SessionTypeDWordLabels[n].Label;
						break;
					}
				}
				strSummary += ")";
				break;
			}

		case DVMSGID_SPEECH:
		case DVMSGID_SPEECHWITHTARGET:
		case DVMSGID_SPEECHWITHFROM:
			{
				strSummary += " [";
				strSummary += _itoa(rVoiceFrame.dvSpeech.bMsgNum, arr_cBuffer, 10);
				strSummary += ".";
				strSummary += _itoa(rVoiceFrame.dvSpeech.bSeqNum, arr_cBuffer, 10);
				strSummary += "]";
				break;
			}
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_VoiceSummary



	// DESCRIPTION: Custom description formatter for the Compression Type field
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_CompressionType( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary = "Compression Type = ";

		// Check what Voice frame we are dealing with
		REFGUID rguidCompressionType = *reinterpret_cast<GUID*>(io_pProperyInstance->lpData);

		if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_TRUESPEECH) )
		{
			strSummary += "TrueSpeech(TM) (8.6kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_GSM) )
		{
			strSummary += "Microsoft GSM 6.10 (13kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_NONE) )
		{
			strSummary += "None ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_ADPCM) )
		{
			strSummary += "Microsoft ADPCM (32.8kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_SC03) )
		{
			strSummary += "Voxware SC03 (3.2kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_SC06) )
		{
			strSummary += "Voxware SC06 (6.4kbps) ";
		}
		else if ( IsEqualGUID(rguidCompressionType, DPVCTGUID_VR12) )
		{
			strSummary += "Voxware VR12 (1.4kbps) ";
		}
		else
		{
			strSummary += "Uknown";
		}


		enum
		{
			nMAX_GUID_STRING = 50	// more than enough characters for a symbolic representation of a GUID
		};

		OLECHAR arr_wcGUID[nMAX_GUID_STRING];
		StringFromGUID2(rguidCompressionType, arr_wcGUID, sizeof(arr_wcGUID)/sizeof(TCHAR));

		char arr_cGUID[nMAX_GUID_STRING];
		WideCharToMultiByte(CP_ACP, 0, arr_wcGUID, -1, arr_cGUID, sizeof(arr_cGUID), NULL, NULL);
		strSummary += arr_cGUID;


		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_CompressionType



	// DESCRIPTION: Custom description formatter for the Players List summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayersListSummary( LPPROPERTYINST io_pProperyInstance )
	{

		sprintf(io_pProperyInstance->szPropertyText, "List of %d players in the session", io_pProperyInstance->lpPropertyInstEx->Dword[0]);

	} // FormatPropertyInstance_PlayersListSummary



	// DESCRIPTION: Custom description formatter for the Player's Entry summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayerEntrySummary( LPPROPERTYINST io_pProperyInstance )
	{

		DWORD* pdwData = io_pProperyInstance->lpPropertyInstEx->Dword;
		sprintf(io_pProperyInstance->szPropertyText, "Player %d out of %d", pdwData[0], pdwData[1]);

	} // FormatPropertyInstance_PlayerEntrySummary



	// DESCRIPTION: Custom description formatter for the Session Flags summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_SessionFlagsSummary( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary;

		if ( (*io_pProperyInstance->lpDword & DVSESSION_NOHOSTMIGRATION) == DVSESSION_NOHOSTMIGRATION )
		{
			strSummary = g_arr_SessionFlagsBitLabels[0].LabelOn;
		}
		else
		{
			strSummary = g_arr_SessionFlagsBitLabels[0].LabelOff;
		}


		strSummary += ", ";

		if ( (*io_pProperyInstance->lpDword & DVSESSION_SERVERCONTROLTARGET) == DVSESSION_SERVERCONTROLTARGET )
		{
			strSummary += g_arr_SessionFlagsBitLabels[1].LabelOn;
		}
		else
		{
			strSummary += g_arr_SessionFlagsBitLabels[1].LabelOff;
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_SessionFlagsSummary


	// DESCRIPTION: Custom description formatter for the Player's Entry summary
	//
	// ARGUMENTS: io_pProperyInstance - Data of the property's instance
	//
	// RETURNS: NOTHING
	//
	VOID WINAPIV FormatPropertyInstance_PlayerFlagsSummary( LPPROPERTYINST io_pProperyInstance )
	{

		std::string strSummary;

		if ( (*io_pProperyInstance->lpDword & DVSESSION_NOHOSTMIGRATION) == DVSESSION_NOHOSTMIGRATION )
		{
			strSummary = g_arr_PlayerFlagsBitLabels[0].LabelOn;
		}
		else
		{
			strSummary = g_arr_PlayerFlagsBitLabels[0].LabelOff;
		}

		strcpy(io_pProperyInstance->szPropertyText, strSummary.c_str());

	} // FormatPropertyInstance_PlayerFlagsSummary

	
	//==================//
	// Properties table //-----------------------------------------------------------------------------------------------
	//==================//
	
	PROPERTYINFO g_arr_VoiceProperties[] = 
	{

		// VOICE packet summary property (VOICE_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "DPlay Voice packet",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier
		    NULL,										// labeled bit set 
		    512,										// description's maximum length
		    FormatPropertyInstance_VoiceSummary			// generic formatter
		},

		// Message Type property (VOICE_UNPARSABLEFRAGMENT)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "This is a non-initial part of the fragmented Transport layer message and can not be parsed", // label
		    "Unparsable fragment summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property ((VOICE_INCOMPLETEMESSAGE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "The rest of the data needed to parse this message has been sent in a separate fragment and can not be parsed",  // label
		    "Incomplete message summary",				// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    128,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},
		
		// Message Type property (VOICE_MESSAGETYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message Type",								// label
		    "Message Type field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledMessageTypeByteSet,				// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Major Version property (VOICE_MAJORVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Major Version",							// label
		    "Major Version field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Minor Version property (VOICE_MINORVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Minor Version",							// label
		    "Minor Version field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Build Version property (VOICE_BUILDVERSION)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Build Version",							// label
		    "Build Version field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Result Code property (VOICE_RESULTCODE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Result Code",								// label
		    "Result Code field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type (HRESULT)
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledResultCodeDWordSet,				// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session Type property (VOICE_SESSIONTYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session Type",								// label
		    "Session Type field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_LABELED_SET,						// data type qualifier.
			&g_LabeledSessionTypeDWordSet,				// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session Flags property (VOICE_SESSIONFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Session Flags summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance_SessionFlagsSummary	// generic formatter
		},

		// Session Flags property (VOICE_SESSIONFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Session Flags",							// label
		    "Session Flags field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledSessionFlagsBitSet,				// labeled byte set 
		    512,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Session Flags property (VOICE_PLAYERFLAGS_SUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Player Flags summary",						// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
			PROP_QUAL_NONE,								// data type qualifier.
			NULL,										// labeled byte set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayerFlagsSummary	// generic formatter
		},

		// Session Flags property (VOICE_PLAYERFLAGS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player Flags",								// label
		    "Player Flags field",						// status-bar comment
		    PROP_TYPE_DWORD,							// data type
			PROP_QUAL_FLAGS,							// data type qualifier.
			&g_LabeledPlayerFlagsBitSet,				// labeled byte set 
		    512,										// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Number of Targets property (VOICE_NUMBEROFTARGETS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Targets",						// label
		    "Number of Targets field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Compression Type property (VOICE_COMPRESSIONTYPE)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Compression Type",							// label
		    "Compression Type field",					// status-bar comment
		    PROP_TYPE_RAW_DATA,							// data type (GUID)
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_CompressionType		// generic formatter
		},

		// Host Migration Sequence Number property (VOICE_HOSTORDERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Host Migration Sequence Number",			// label
		    "Host Migration Sequence Number field",		// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_LABELED_SET,						// data type qualifier.
		    &g_LabeledHostOrderIDDWordSet,				// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Number of Players property (VOICE_NUMBEROFPLAYERS)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Number of Players",						// label
		    "Number of Players field",					// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's summary property (VOICE_PLAYERLISTSUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Player's list summary",					// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayersListSummary	// generic formatter
		},

		// Player's summary property (VOICE_PLAYERSUMMARY)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "",											// label
		    "Player's summary",							// status-bar comment
		    PROP_TYPE_SUMMARY,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance_PlayerEntrySummary	// generic formatter
		},

		// Player's ID property (VOICE_PLAYERID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Player ID",								// label
		    "Player ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Player's ID property (VOICE_TARGETID)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Target ID",								// label
		    "Target ID field",							// status-bar comment
		    PROP_TYPE_DWORD,							// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Message Number property (VOICE_MESSAGENUMBER)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Message #",							// label
		    "Message Number field",						// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Fragment Number property (VOICE_FRAGMENTNUMBER)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Fragment #",							// label
		    "Fragment Number field",					// status-bar comment
		    PROP_TYPE_BYTE,								// data type
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		},

		// Audio Data (VOICE_AUDIODATA)
	    {
		    0,											// handle placeholder (MBZ)
		    0,											// reserved (MBZ)
		    "Audio Data",								// label
		    "Audio Data",								// status-bar comment
		    PROP_TYPE_RAW_DATA,							// data type (GUID)
		    PROP_QUAL_NONE,								// data type qualifier.
		    NULL,										// labeled bit set 
		    64,											// description's maximum length
		    FormatPropertyInstance						// generic formatter
		}
	};

	enum
	{
		nNUM_OF_VOICE_PROPS = sizeof(g_arr_VoiceProperties) / sizeof(PROPERTYINFO)
	};


	// Properties' indices
	enum
	{
		VOICE_SUMMARY = 0,
		VOICE_UNPARSABLEFRAGMENT,
		VOICE_INCOMPLETEMESSAGE,

		VOICE_MESSAGETYPE,
		VOICE_MAJORVERSION,
		VOICE_MINORVERSION,
		VOICE_BUILDVERSION,
		
		VOICE_RESULTCODE,
		VOICE_SESSIONTYPE,
		
		VOICE_SESSIONFLAGS_SUMMARY,
		VOICE_SESSIONFLAGS,
		
		VOICE_PLAYERFLAGS_SUMMARY,
		VOICE_PLAYERFLAGS,
		
		VOICE_NUMBEROFTARGETS,
		VOICE_COMPRESSIONTYPE,
		VOICE_HOSTORDERID,
		VOICE_NUMBEROFPLAYERS,
		
		VOICE_PLAYERLIST_SUMMARY,
		VOICE_PLAYERSUMMARY,
		
		VOICE_PLAYERID,
		VOICE_TARGETID,
		
		VOICE_MESSAGENUMBER,
		VOICE_FRAGMENTNUMBER,
		
		VOICE_AUDIODATA
	};

} // anonymous namespace








// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI VoiceRegister( HPROTOCOL i_hVoiceProtocol ) 
{

	CreatePropertyDatabase(i_hVoiceProtocol, nNUM_OF_VOICE_PROPS);

	// Add the properties to the database
	for( int nProp=0; nProp < nNUM_OF_VOICE_PROPS; ++nProp )
	{
	   AddProperty(i_hVoiceProtocol, &g_arr_VoiceProperties[nProp]);
	}

} // VoiceRegister



// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI VoiceDeregister( HPROTOCOL i_hProtocol )
{

	DestroyPropertyDatabase(i_hProtocol);

} // VoiceDeregister




namespace
{

	// DESCRIPTION: Parses the Voice frame to find its size (in bytes) NOT including the user data
	//
	// ARGUMENTS: i_pbVoiceFrame - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
	//						    in the middle of a frame because a previous parser has claimed data before this parser.
	//
	// RETURNS: Size of the Voiceecified Voice frame (in bytes)
	//
	int VoiceHeaderSize( LPBYTE i_pbVoiceFrame )
	{

		// Check what Voice frame we are dealing with
		const DVPROTOCOLMSG_FULLMESSAGE&	rVoiceFrame = *reinterpret_cast<DVPROTOCOLMSG_FULLMESSAGE*>(i_pbVoiceFrame);

		switch ( rVoiceFrame.dvGeneric.dwType )
		{
		case DVMSGID_CONNECTREQUEST:
			{
				return sizeof(rVoiceFrame.dvConnectRequest);
			}

		case DVMSGID_CONNECTREFUSE:
			{
				return sizeof(rVoiceFrame.dvConnectRefuse);
			}

		case DVMSGID_CONNECTACCEPT:
			{
				return sizeof(rVoiceFrame.dvConnectAccept);
			}

		case DVMSGID_SETTINGSCONFIRM:
			{
				return sizeof(rVoiceFrame.dvSettingsConfirm);
			}

		case DVMSGID_PLAYERLIST:
			{
				return sizeof(rVoiceFrame.dvPlayerList);
			}

		case DVMSGID_SPEECH:
			{
				return sizeof(rVoiceFrame.dvSpeech);
			}

		case DVMSGID_SPEECHWITHTARGET:
			{
				return sizeof(rVoiceFrame.dvSpeechWithTarget);
			}

		case DVMSGID_SPEECHWITHFROM:
			{
				return sizeof(rVoiceFrame.dvSpeechWithFrom);
			}

		case DVMSGID_SETTARGETS:
			{
				return sizeof(rVoiceFrame.dvSetTarget);
			}

		case DVMSGID_CREATEVOICEPLAYER:
			{
				return sizeof(rVoiceFrame.dvPlayerJoin);
			}

		case DVMSGID_DELETEVOICEPLAYER:
			{
				return sizeof(rVoiceFrame.dvPlayerQuit);
			}

		case DVMSGID_SESSIONLOST:
			{
				return sizeof(rVoiceFrame.dvSessionLost);
			}

		case DVMSGID_DISCONNECTCONFIRM:
		case DVMSGID_DISCONNECT:
			{
				return sizeof(rVoiceFrame.dvDisconnect);
			}

		default:
			{
				return -1;	 // TODO:		DPF(0, "Unknown voice frame!");
			}
		}

	} // VoiceHeaderSize

} // Anonymous namespace



// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbVoiceFrame      - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbVoiceFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI VoiceRecognizeFrame( HFRAME        i_hFrame,
												  ULPBYTE        i_upbMacFrame,	
												  ULPBYTE        i_upbyVoiceFrame,
												  DWORD         i_dwMacType,        
												  DWORD         i_dwBytesLeft,      
												  HPROTOCOL     i_hPrevProtocol,  
												  DWORD         i_dwPrevProtOffset,
												  LPDWORD       o_pdwProtocolStatus,
												  LPHPROTOCOL   o_phNextProtocol,
												  PDWORD_PTR    io_pdwptrInstData )
{

	// Validate the amount of unclaimed data
	enum
	{
		// TODO: CHANGE TO PROPER MIN SIZE
		nMIN_VoiceHeaderSize = sizeof(_DVPROTOCOLMSG_GENERIC),
		nNUMBER_OF_MSG_TYPES = sizeof(g_arr_MessageTypeByteLabels) / sizeof(LABELED_BYTE)
	};

	for ( int nTypeIndex = 0; nTypeIndex < nNUMBER_OF_MSG_TYPES; ++nTypeIndex )
	{
		if ( g_arr_MessageTypeByteLabels[nTypeIndex].Value == *i_upbyVoiceFrame )
		{
			break;
		}
	}

	
	// Validate the packet as DPlay Session type
	if ( ((i_dwBytesLeft >= nMIN_VoiceHeaderSize)  &&  (nTypeIndex < nNUMBER_OF_MSG_TYPES))  ||  (*io_pdwptrInstData == 0) )
	{
		// Claim the remaining data
	    *o_pdwProtocolStatus = PROTOCOL_STATUS_CLAIMED;
	    return NULL;
	}

	// Assume the unclaimed data is not recognizable
	*o_pdwProtocolStatus = PROTOCOL_STATUS_NOT_RECOGNIZED;
	return i_upbyVoiceFrame;

} // VoiceRecognizeFrame



// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Voiceecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbVoiceFrame     - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: Must return NULL
//
DPLAYPARSER_API LPBYTE BHAPI VoiceAttachProperties( HFRAME      i_hFrame,
													ULPBYTE      i_upbyMacFrame,
													ULPBYTE      i_upbyVoiceFrame,
													DWORD       i_dwMacType,
													DWORD       i_dwBytesLeft,
													HPROTOCOL   i_hPrevProtocol,
													DWORD       i_dwPrevProtOffset,
												    DWORD_PTR   i_dwptrInstData )
{
    //===================//
    // Attach Properties //
    //===================//

    if ( i_dwptrInstData == 0 )
    {
    	AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_UNPARSABLEFRAGMENT].hProperty,
    						i_dwBytesLeft, i_upbyVoiceFrame, 0, 0, 0);
    	return NULL;
    }
    
    // Summary line
    AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SUMMARY].hProperty,
                           VoiceHeaderSize(i_upbyVoiceFrame), i_upbyVoiceFrame, 0, 0, 0);

    // Check what Voice frame we are dealing with
	DVPROTOCOLMSG_FULLMESSAGE&	rVoiceFrame = *reinterpret_cast<DVPROTOCOLMSG_FULLMESSAGE*>(i_upbyVoiceFrame);

	// Message type field
	AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGETYPE].hProperty,
						   sizeof(rVoiceFrame.dvGeneric.dwType), &rVoiceFrame.dvGeneric.dwType, 0, 1, 0);

	__try
	{

		switch ( rVoiceFrame.dvGeneric.dwType )
		{
		case DVMSGID_CONNECTREQUEST:
			{
				// Major Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MAJORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRequest.ucVersionMajor), &rVoiceFrame.dvConnectRequest.ucVersionMajor, 0, 1, 0);

				// Minor Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MINORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRequest.ucVersionMinor), &rVoiceFrame.dvConnectRequest.ucVersionMinor, 0, 1, 0);

				// Build Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_BUILDVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRequest.dwVersionBuild), &rVoiceFrame.dvConnectRequest.dwVersionBuild, 0, 1, 0);

				break;
			}

		case DVMSGID_CONNECTREFUSE:
			{
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_RESULTCODE].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.hresResult), &rVoiceFrame.dvConnectRefuse.hresResult, 0, 1, 0);

				// Major Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MAJORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.ucVersionMajor), &rVoiceFrame.dvConnectRefuse.ucVersionMajor, 0, 1, 0);

				// Minor Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MINORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.ucVersionMinor), &rVoiceFrame.dvConnectRefuse.ucVersionMinor, 0, 1, 0);

				// Build Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_BUILDVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectRefuse.dwVersionBuild), &rVoiceFrame.dvConnectRefuse.dwVersionBuild, 0, 1, 0);

				break;
			}

		case DVMSGID_CONNECTACCEPT:
			{
				// Session Type field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SESSIONTYPE].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwSessionType), &rVoiceFrame.dvConnectAccept.dwSessionType, 0, 1, 0);

				// Major Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MAJORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.ucVersionMajor), &rVoiceFrame.dvConnectAccept.ucVersionMajor, 0, 1, 0);

				// Minor Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MINORVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.ucVersionMinor), &rVoiceFrame.dvConnectAccept.ucVersionMinor, 0, 1, 0);

				// Build Version field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_BUILDVERSION].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwVersionBuild), &rVoiceFrame.dvConnectAccept.dwVersionBuild, 0, 1, 0);

				// Session Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SESSIONFLAGS_SUMMARY].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwSessionFlags), &rVoiceFrame.dvConnectAccept.dwSessionFlags, 0, 1, 0);

				// Session Flags field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_SESSIONFLAGS].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.dwSessionFlags), &rVoiceFrame.dvConnectAccept.dwSessionFlags, 0, 2, 0);

				// Compression Type field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_COMPRESSIONTYPE].hProperty,
									   sizeof(rVoiceFrame.dvConnectAccept.guidCT), &rVoiceFrame.dvConnectAccept.guidCT, 0, 1, 0);

				break;
			}

		case DVMSGID_SETTINGSCONFIRM:
			{
				// Player's Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS_SUMMARY].hProperty,
									   sizeof(rVoiceFrame.dvSettingsConfirm.dwFlags), &rVoiceFrame.dvSettingsConfirm.dwFlags, 0, 1, 0);

				// Client Flags field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS].hProperty,
									   sizeof(rVoiceFrame.dvSettingsConfirm.dwFlags), &rVoiceFrame.dvSettingsConfirm.dwFlags, 0, 2, 0);

				// Host Migration Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
									   sizeof(rVoiceFrame.dvSettingsConfirm.dwHostOrderID), &rVoiceFrame.dvSettingsConfirm.dwHostOrderID, 0, 1, 0);

				break;
			}

		case DVMSGID_PLAYERLIST:
			{
				// Host Order ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerList.dwHostOrderID), &rVoiceFrame.dvPlayerList.dwHostOrderID, 0, 1, 0);

				// Number of Players field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_NUMBEROFPLAYERS].hProperty,
									   sizeof(rVoiceFrame.dvPlayerList.dwNumEntries), &rVoiceFrame.dvPlayerList.dwNumEntries, 0, 1, 0);


				// Player entries are following after the header
				DVPROTOCOLMSG_PLAYERLIST_ENTRY* pPlayerEntry =
					reinterpret_cast<DVPROTOCOLMSG_PLAYERLIST_ENTRY*>(&rVoiceFrame.dvPlayerList + 1);

				// Make sure the list doesn't overflow the boundaries of the frame
				DWORD dwNumEntries = rVoiceFrame.dvPlayerList.dwNumEntries;
				if ( reinterpret_cast<LPBYTE>(pPlayerEntry + dwNumEntries) - i_upbyVoiceFrame  >  static_cast<int>(i_dwBytesLeft) )
				{
					break;
				}

				// Player list summary
				AttachPropertyInstanceEx(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERLIST_SUMMARY].hProperty,
									     dwNumEntries * sizeof(*pPlayerEntry), pPlayerEntry,
									     sizeof(DWORD), &dwNumEntries,
									     0, 1, 0);

				// For every player entry in the list
				for ( int nEntry = 1; nEntry <= dwNumEntries; ++nEntry, ++pPlayerEntry )
				{
					// Player's summary
					struct
					{
						DWORD dwPlayerNum;
						DWORD dwTotalPlayer;
					}
					PlayerEntryData = { nEntry, dwNumEntries };

					AttachPropertyInstanceEx(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERSUMMARY].hProperty,
											 sizeof(*pPlayerEntry), pPlayerEntry,
											 sizeof(PlayerEntryData), &PlayerEntryData,
											 0, 2, 0);

					// Player's ID field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
										   sizeof(pPlayerEntry->dvidID), &pPlayerEntry->dvidID, 0, 3, 0);

					// Player's Flags summary
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS_SUMMARY].hProperty,
										   sizeof(pPlayerEntry->dwPlayerFlags), &pPlayerEntry->dwPlayerFlags, 0, 3, 0);

					// Player's Flags field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS].hProperty,
										   sizeof(pPlayerEntry->dwPlayerFlags), &pPlayerEntry->dwPlayerFlags, 0, 4, 0);

					// Host Migration Sequence Number field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
										   sizeof(pPlayerEntry->dwHostOrderID), &pPlayerEntry->dwHostOrderID, 0, 3, 0);
				}

				break;
			}

		case DVMSGID_SPEECH:
			{
				// Message Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGENUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeech.bMsgNum), &rVoiceFrame.dvSpeech.bMsgNum, 0, 1, 0);

				// Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_FRAGMENTNUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeech.bSeqNum), &rVoiceFrame.dvSpeech.bSeqNum, 0, 1, 0);

				// Audio Data
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_AUDIODATA].hProperty,
									   i_dwBytesLeft-sizeof(rVoiceFrame.dvSpeech), &rVoiceFrame.dvSpeech + 1, 0, 1, 0);

				break;
			}

		case DVMSGID_SPEECHWITHTARGET:
			{
				// Message Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGENUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithTarget.dvHeader.bMsgNum), &rVoiceFrame.dvSpeechWithTarget.dvHeader.bMsgNum, 0, 1, 0);

				// Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_FRAGMENTNUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithTarget.dvHeader.bSeqNum), &rVoiceFrame.dvSpeechWithTarget.dvHeader.bSeqNum, 0, 1, 0);

				// Number of Targets field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_NUMBEROFTARGETS].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithTarget.dwNumTargets), &rVoiceFrame.dvSpeechWithTarget.dwNumTargets, 0, 1, 0);


				// Target ID entries are following after the header
				DVID* pTargetID = reinterpret_cast<DVID*>(&rVoiceFrame.dvSpeechWithTarget + 1);

				// Make sure the list doesn't overflow the boundaries of the frame
				int nNumTargets = rVoiceFrame.dvSpeechWithTarget.dwNumTargets;
				if ( reinterpret_cast<LPBYTE>(pTargetID + nNumTargets) - i_upbyVoiceFrame  >  static_cast<int>(i_dwBytesLeft) )
				{
					break;
				}

				// For every target ID entry in the list...
				for ( ; nNumTargets; --nNumTargets, ++pTargetID )
				{
					// Target's ID field
					AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_TARGETID].hProperty,
										   sizeof(*pTargetID), pTargetID, 0, 1, 0);
				}

				// Audio Data
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_AUDIODATA].hProperty,
									   i_dwBytesLeft-sizeof(rVoiceFrame.dvSpeechWithTarget), &rVoiceFrame.dvSpeechWithTarget + 1, 0, 1, 0);
				
				break;
			}

		case DVMSGID_SPEECHWITHFROM:
			{
				// Message Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_MESSAGENUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithFrom.dvHeader.bMsgNum), &rVoiceFrame.dvSpeechWithFrom.dvHeader.bMsgNum, 0, 1, 0);

				// Sequence Number field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_FRAGMENTNUMBER].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithFrom.dvHeader.bSeqNum), &rVoiceFrame.dvSpeechWithFrom.dvHeader.bSeqNum, 0, 1, 0);

				// Speaking Player's ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
									   sizeof(rVoiceFrame.dvSpeechWithFrom.dvidFrom), &rVoiceFrame.dvSpeechWithFrom.dvidFrom, 0, 1, 0);

				// Audio Data
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_AUDIODATA].hProperty,
									   i_dwBytesLeft-sizeof(rVoiceFrame.dvSpeechWithFrom),
									   &rVoiceFrame.dvSpeechWithFrom + 1, 0, 1, 0);
				
				break;
			}

		case DVMSGID_SETTARGETS:
			{
				// Number of Targets field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_NUMBEROFTARGETS].hProperty,
									   sizeof(rVoiceFrame.dvSetTarget.dwNumTargets), &rVoiceFrame.dvSetTarget.dwNumTargets, 0, 1, 0);

				break;
			}

		case DVMSGID_CREATEVOICEPLAYER:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dvidID), &rVoiceFrame.dvPlayerJoin.dvidID, 0, 1, 0);

				// Player's Flags summary
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS_SUMMARY].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dwFlags), &rVoiceFrame.dvPlayerJoin.dwFlags, 0, 1, 0);

				// Player's Flags field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERFLAGS].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dwFlags), &rVoiceFrame.dvPlayerJoin.dwFlags, 0, 2, 0);

				// Host Order ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_HOSTORDERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dwHostOrderID), &rVoiceFrame.dvPlayerJoin.dwHostOrderID, 0, 1, 0);

				break;
			}

		case DVMSGID_DELETEVOICEPLAYER:
			{
				// Player ID field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_PLAYERID].hProperty,
									   sizeof(rVoiceFrame.dvPlayerJoin.dvidID), &rVoiceFrame.dvPlayerJoin.dvidID, 0, 1, 0);

				break;
			}

		case DVMSGID_SESSIONLOST:
			{
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_RESULTCODE].hProperty,
									   sizeof(rVoiceFrame.dvSessionLost.hresReason), &rVoiceFrame.dvSessionLost.hresReason, 0, 1, 0);

				break;
			}

		case DVMSGID_DISCONNECTCONFIRM:
		case DVMSGID_DISCONNECT:
			{
				// Result Code field
				AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_RESULTCODE].hProperty,
									   sizeof(rVoiceFrame.dvDisconnect.hresDisconnect), &rVoiceFrame.dvDisconnect.hresDisconnect, 0, 1, 0);

				break;
			}

		default:
			{
				break; // TODO:		DPF(0, "Unknown voice frame!");
			}
		}

	}
	__except ( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
    	AttachPropertyInstance(i_hFrame, g_arr_VoiceProperties[VOICE_INCOMPLETEMESSAGE].hProperty,
    						i_dwBytesLeft, i_upbyVoiceFrame, 0, 1, 0);
	}
	

	return NULL;

} // VoiceAttachProperties





// DESCRIPTION: Formats the data that is diVoicelayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_upbyVoiceFrame.
//
DPLAYPARSER_API DWORD BHAPI VoiceFormatProperties( HFRAME          i_hFrame,
												   ULPBYTE          i_upbyMacFrame,
												   ULPBYTE          i_upbyVoiceFrame,
												   DWORD           i_dwPropertyInsts,
												   LPPROPERTYINST  i_pPropInst )
{

    // Loop through the property instances...
    while( i_dwPropertyInsts-- > 0)
    {
        // ...and call the formatter for each
        reinterpret_cast<FORMAT>(i_pPropInst->lpPropertyInfo->InstanceData)(i_pPropInst);
        ++i_pPropInst;
    }

	// TODO: MAKE SURE THIS SHOULD NOT BE TRUE
    return NMERR_SUCCESS;

} // VoiceFormatProperties




// DESCRIPTION: Notifies Network Monitor that DNET protocol parser exists.
//
// ARGUMENTS: NONE
//
// RETURNS: TRUE - success, FALSE - failure
//
bool CreateVoiceProtocol( void )
{

	// The entry points to the export functions that Network Monitor uses to operate the parser
	ENTRYPOINTS VoiceEntryPoints =
	{
		// VoiceParser Entry Points
		VoiceRegister,
		VoiceDeregister,
		VoiceRecognizeFrame,
		VoiceAttachProperties,
		VoiceFormatProperties
	};

    // The first active instance of this parser needs to register with the kernel
    g_hVoiceProtocol = CreateProtocol("DPLAYVOICE", &VoiceEntryPoints, ENTRYPOINTS_SIZE);
	
	return (g_hVoiceProtocol ? TRUE : FALSE);

} // CreateVoiceProtocol



// DESCRIPTION: Removes the DNET protocol parser from the Network Monitor's database of parsers
//
// ARGUMENTS: NONE
//
// RETURNS: NOTHING
//
void DestroyVoiceProtocol( void )
{

	DestroyProtocol(g_hVoiceProtocol);

} // DestroyVoiceProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\dp8sim\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dp8simui.rc
//

#define WINDOWCLASS_MAIN							_T("DP8Sim Main Window Class")
#define WINDOWCLASS_NAMESETTINGS					_T("DP8Sim Name Settings Window Class")

#define IDD_MAIN									100

#define IDX_SETTINGS								1000
#define IDCB_SETTINGS								1001

#define IDX_SETTINGS_SEND							1101
#define IDS_SETTINGS_SEND_BANDWIDTH					1102
#define IDE_SETTINGS_SEND_BANDWIDTH					1103
#define IDS_SETTINGS_SEND_DROP						1104
#define IDE_SETTINGS_SEND_DROP						1105
#define IDS_SETTINGS_SEND_MINLATENCY				1106
#define IDE_SETTINGS_SEND_MINLATENCY				1107
#define IDS_SETTINGS_SEND_MAXLATENCY				1108
#define IDE_SETTINGS_SEND_MAXLATENCY				1109

#define IDX_SETTINGS_RECV							1201
#define IDS_SETTINGS_RECV_BANDWIDTH					1202
#define IDE_SETTINGS_RECV_BANDWIDTH					1203
#define IDS_SETTINGS_RECV_DROP						1204
#define IDE_SETTINGS_RECV_DROP						1205
#define IDS_SETTINGS_RECV_MINLATENCY				1206
#define IDE_SETTINGS_RECV_MINLATENCY				1207
#define IDS_SETTINGS_RECV_MAXLATENCY				1208
#define IDE_SETTINGS_RECV_MAXLATENCY				1209

#define IDB_APPLY									1901
#define IDB_REVERT									1902
#define IDB_SAVEAS									1903


#define IDX_STATS									2000

#define IDX_STATS_SEND								2101
#define IDS_STATS_SEND_XMITPACKETS					2102
#define IDT_STATS_SEND_XMITPACKETS					2103
#define IDS_STATS_SEND_XMITBYTES					2104
#define IDT_STATS_SEND_XMITBYTES					2105
#define IDS_STATS_SEND_DROPPACKETS					2106
#define IDT_STATS_SEND_DROPPACKETS					2107
#define IDS_STATS_SEND_DROPBYTES					2108
#define IDT_STATS_SEND_DROPBYTES					2109
#define IDS_STATS_SEND_TOTALDELAY					2110
#define IDT_STATS_SEND_TOTALDELAY					2111

#define IDX_STATS_RECV								2201
#define IDS_STATS_RECV_XMITPACKETS					2202
#define IDT_STATS_RECV_XMITPACKETS					2203
#define IDS_STATS_RECV_XMITBYTES					2204
#define IDT_STATS_RECV_XMITBYTES					2205
#define IDS_STATS_RECV_DROPPACKETS					2206
#define IDT_STATS_RECV_DROPPACKETS					2207
#define IDS_STATS_RECV_DROPBYTES					2208
#define IDT_STATS_RECV_DROPBYTES					2209
#define IDS_STATS_RECV_TOTALDELAY					2210
#define IDT_STATS_RECV_TOTALDELAY					2211

#define IDCHK_AUTOREFRESH							2901
#define IDB_REFRESH									2902
#define IDB_CLEAR									2903


//#define IDOK										3001


#define IDD_NAMESETTINGS							101

#define IDS_NAME									4001
#define IDE_NAME									4002
//#define IDOK										4003
//#define IDCANCEL									4004


#define IDS_ERROR_CAPTION_COULDNTCREATEDP8SIMCONTROL	1
#define IDS_ERROR_TEXT_COULDNTCREATEDP8SIMCONTROL		2
#define IDS_ERROR_CAPTION_BUILTINSETTINGSWITHSAMENAME	3
#define IDS_ERROR_TEXT_BUILTINSETTINGSWITHSAMENAME		4

#define IDS_SETTING_NONE								5
#define IDS_SETTING_336MODEM1							6
#define IDS_SETTING_336MODEM2							7
#define IDS_SETTING_56KMODEM1							8
#define IDS_SETTING_56KMODEM2							9
#define IDS_SETTING_256KBPSDSL							10
#define IDS_SETTING_DISCONNECTED						11
#define IDS_SETTING_HIGHPACKETLOSS						12
#define IDS_SETTING_HIGHLATENCYVARIANCE					13
#define IDS_SETTING_CUSTOM								14





// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\callstack.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.h
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/13/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__CALLSTACK_H__
#define	__CALLSTACK_H__

#ifdef DBG

//**********************************************************************
// Constant definitions
//**********************************************************************

//
// Size of temp buffer to build strings into.
// If the call stack depth is increased, increase the size of the buffer
// to prevent stack corruption with long symbol names.
//
#define	CALLSTACK_BUFFER_SIZE	8192
#define CALLSTACK_DEPTH			12

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Class prototypes
//**********************************************************************

class	CCallStack
{
	public:
		CCallStack(){}
		~CCallStack(){}

		void	NoteCurrentCallStack( void );
		void	GetCallStackString( TCHAR *const pOutputString ) const;

	private:
		const void*		m_CallStack[CALLSTACK_DEPTH];
		const void		*GetStackTop( void ) const;
		const void		*GetStackBottom( void ) const;
};

#endif // DBG

#endif	// __CALLSTACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\createin.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       createin.h
 *  Content:	defines functions required by the generic class factory
 *
 *
 *	The generic class factory (classfac.c) requires these functions to be
 *	implemented by the COM object(s) its supposed to be generating
 *
 *	GP_ stands for "General Purpose"
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/13/98	jwo		Created it.
 ***************************************************************************/

#ifndef __CREATEINS__
#define __CREATEINS__


#ifndef DPNBUILD_LIBINTERFACE


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// you must implement this function to create an instance of your COM object
HRESULT	DoCreateInstance(LPCLASSFACTORY This, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid,
    						LPVOID *ppvObj);

// you must implement this function.  Given a class id, you must respond
//	whether or not your DLL implements it
BOOL	IsClassImplemented(REFCLSID rclsid);

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // ! DPNBUILD_LIBINTERFACE

#endif // __CREATEINS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\public\daytona\makefile.inc ===
misc :
	copy ..\..\DPlay8Parser.cpp .
	copy ..\..\SessionParser.cpp .
	copy ..\..\SPParser.cpp .
	copy ..\..\TransportParser.cpp .
	copy ..\..\VoiceParser.cpp .
	copy ..\..\dp8parse.rc .
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\creg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.h
 *  Content:	definition of the CRegistry class
 *		
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 *	04/05/2000	jtk		Changed GetVauleSize to GetValueLength and modified to return WCHAR lengths
 * 	04/21/2000   	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *      	        rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *		                to allow reads of REG_BINARY when expecting REG_DWORD 
 * 	07/09/2000	rodtoll	Added signature bytes 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer (removed CRegistry::CheckUnicodePlatform)
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 *
 ***************************************************************************/

#ifndef __CREGISTRY_H
#define __CREGISTRY_H


#ifndef DPNBUILD_NOREGISTRY


// Useful definition
#define MAX_REGISTRY_STRING_SIZE		_MAX_PATH+1

#define DPN_KEY_ALL_ACCESS				((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER)


#define VSIG_CREGISTRY			'GERV'
#define VSIG_CREGISTRY_FREE		'GER_'

#define ReadBOOL( keyname, boolptr ) ReadDWORD( (keyname), (DWORD*) (boolptr) )
#define WriteBOOL( keyname, boolval ) WriteDWORD( (keyname), (DWORD) (boolval) )


// CRegistry
//
// This class handles reading/writing to the windows registry.  Each instance
// of the CRegistry class is attached to a single registry handle, which is
// an open handle to a point in the registry tree.
//
class CRegistry
{

public:

	CRegistry();
	~CRegistry();

    BOOL        EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );
    BOOL        EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index = 0 );

	BOOL		Open( const HKEY branch, const LPCWSTR pathName, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Open( const HKEY branch, const GUID* lpguid, BOOL fReadOnly = TRUE, BOOL create = FALSE, BOOL fCustomSAM = FALSE, REGSAM samCustom = NULL);
	BOOL		Close();

	BOOL		IsOpen() const	{ return m_isOpen;	};

	BOOL		DeleteSubKey( LPCWSTR keyName );
	BOOL        	DeleteSubKey( const GUID *pGuidName );

	BOOL		DeleteValue( LPCWSTR valueName );

    BOOL        ReadGUID( LPCWSTR keyName, GUID* guid );
    BOOL        WriteGUID( LPCWSTR keyName, const GUID &guid );

	BOOL		WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue );
	BOOL		ReadString( LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength );

	BOOL		WriteDWORD( LPCWSTR keyName, DWORD value );
	BOOL		ReadDWORD( LPCWSTR keyName, DWORD* presult );

	BOOL		ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize );
	BOOL		WriteBlob( LPCWSTR keyName, const BYTE* const lpbBuffer, DWORD dwSize );

	BOOL		GetMaxKeyLen( DWORD* pdwMaxKeyLen );
	BOOL		GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength );

#ifdef WINNT
	BOOL		GrantAllAccessSecurityPermissions();
	BOOL		RemoveAllAccessSecurityPermissions();
#endif // WINNT

#ifndef DPNBUILD_NOCOMREGISTER
	static BOOL	Register( LPCWSTR lpszProgID, LPCWSTR lpszDesc, LPCWSTR lpszProgName, const GUID* pguidCLSID, LPCWSTR lpszVerIndProgID );
	static BOOL UnRegister( const GUID* pguidCLSID );
#endif // !DPNBUILD_NOCOMREGISTER

	// Data access functions
	operator	HKEY() const		{ return m_regHandle; };
	HKEY		GetBaseHandle() const { return m_baseHandle; };
	HKEY		GetHandle() const { return m_regHandle; };

protected:

	DWORD	m_dwSignature;	// Signature
	BOOL    m_fReadOnly;

	BOOL	m_isOpen;		// BOOL indicating if the object is open
	HKEY	m_regHandle;	// Handle to the registry which is represented by this object
	HKEY	m_baseHandle;	// Handle to the root of the part of the registry
							// this object is in.  E.g. HKEY_LOCAL_MACHINE
};


#endif // ! DPNBUILD_NOREGISTRY


#endif // __CREGISTRY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dplay8\tools\parsers\voiceparser.hpp ===
#ifndef _VoiceParser_H_
#define _VoiceParser_H_

#include "DPlay8Parser.hpp"


// DESCRIPTION: Creates and fills-in a properties database for the protocol.
//				Network Monitor uses this database to determine which properties the protocol supports.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID BHAPI VoiceRegister( HPROTOCOL i_hVoiceProtocol );


// DESCRIPTION: Frees the resources used to create the protocol property database.
//
// ARGUMENTS: i_hVoiceProtocol - The handle of the protocol provided by the Network Monitor.
//
// RETURNS: NOTHING
//
DPLAYPARSER_API VOID WINAPI VoiceDeregister( HPROTOCOL i_hProtocol );


// DESCRIPTION: Indicates whether a piece of data is recognized as the protocol that the parser detects.
//
// ARGUMENTS: i_hFrame	          - The handle to the frame that contains the data.
//			  i_pbMacFrame        - The pointer to the first byte of the frame; the pointer provides a way to view
//							        the data that the other parsers recognize.
//			  i_pbVoiceFrame      - Pointer to the start of the unclaimed data. Typically, the unclaimed data is located
//								    in the middle of a frame because a previous parser has claimed data before this parser.
//			  i_dwMacType         - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							        when the parser must identify the first protocol in the frame. Can be one of the following:
//							   	    MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft       - The remaining number of bytes from a location in the frame to the end of the frame.
//			  i_hPrevProtocol     - Handle of the previous protocol.
//			  i_dwPrevProtOffset  - Offset of the previous protocol (from the beginning of the frame).
//			  o_pdwProtocolStatus - Protocol status indicator. Must be one of the following: PROTOCOL_STATUS_RECOGNIZED,
//								    PROTOCOL_STATUS_NOT_RECOGNIZED, PROTOCOL_STATUS_CLAIMED, PROTOCOL_STATUS_NEXT_PROTOCOL.
//			  o_phNextProtocol    - Placeholder for the handle of the next protocol. This parameter is set when the parser identifies
//								    the protocol that follows its own protocol.
//			  io_pdwptrInstData   - On input, a pointer to the instance data from the previous protocol. 
//									On output, a pointer to the instance data for the current protocol. 
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized parser data.
//			If the parser claims all the remaining data, the return value is NULL. If the function is unsuccessful, the return
//		    value is the initial value of the i_pbVoiceFrame parameter.
//
DPLAYPARSER_API LPBYTE BHAPI VoiceRecognizeFrame( HFRAME        i_hFrame,
												  ULPBYTE        i_upbMacFrame,	
												  ULPBYTE        i_upbVoiceFrame,
                                   				  DWORD         i_dwMacType,        
                                   				  DWORD         i_dwBytesLeft,      
                                   				  HPROTOCOL     i_hPrevProtocol,  
                                   				  DWORD         i_dwPrevProtOffset,
                                   				  LPDWORD       o_pdwProtocolStatus,
                                   				  LPHPROTOCOL   o_hNextProtocol,
												  PDWORD_PTR    io_pdwptrInstData );


// DESCRIPTION: Maps the properties that exist in a piece of recognized data to Voiceecific locations.
//
// ARGUMENTS: i_hFrame           - Handle of the frame that is being parsed.
//			  i_pbMacFram        - Pointer to the first byte in the frame.
//			  i_pbVoiceFrame     - Pointer to the start of the recognized data.
//			  i_dwMacType        - MAC value of the first protocol in a frame. Typically, the i_dwMacType value is used
//							       when the parser must identify the first protocol in the frame. Can be one of the following:
//							       MAC_TYPE_ETHERNET = 802.3, MAC_TYPE_TOKENRING = 802.5, MAC_TYPE_FDDI ANSI = X3T9.5.
//			  i_dwBytesLeft      - The remaining number of bytes in a frame (starting from the beginning of the recognized data).
//			  i_hPrevProtocol    - Handle of the previous protocol.
//			  i_dwPrevProtOffset - Offset of the previous protocol (starting from the beginning of the frame).
//			  i_dwptrInstData    - Pointer to the instance data that the previous protocol provides.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbVoiceFrame.
//
DPLAYPARSER_API LPBYTE BHAPI VoiceAttachProperties( HFRAME      i_hFrame,
													ULPBYTE      i_upbMacFrame,
													ULPBYTE      i_upbVoiceFrame,
													DWORD       i_dwMacType,
													DWORD       i_dwBytesLeft,
													HPROTOCOL   i_hPrevProtocol,
													DWORD       i_dwPrevProtOffset,
												    DWORD_PTR   i_dwptrInstData );


// DESCRIPTION: Formats the data that is diVoicelayed in the details pane of the Network Monitor UI.
//
// ARGUMENTS: i_hFrame          - Handle of the frame that is being parsed.
//			  i_pbMacFrame		- Pointer to the first byte of a frame.
//			  i_pbCoreFrame		- Pointer to the beginning of the protocol data in a frame.
//            i_dwPropertyInsts - Number of PROPERTYINST structures provided by lpPropInst.
//			  i_pPropInst		- Pointer to an array of PROPERTYINST structures.
//
// RETURNS: If the function is successful, the return value is a pointer to the first byte after the recognized data in a frame,
//          or NULL if the recognized data is the last piece of data in a frame. If the function is unsuccessful, the return value
//			is the initial value of i_pbVoiceFrame.
//
DPLAYPARSER_API DWORD BHAPI VoiceFormatProperties( HFRAME          i_hFrame,
												   ULPBYTE          i_upbMacFrame,
												   ULPBYTE          i_upbVoiceFrame,
												   DWORD           i_dwPropertyInsts,
												   LPPROPERTYINST  i_pPropInst );

bool CreateVoiceProtocol( void );
void DestroyVoiceProtocol( void );


#endif // _VoiceParser_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\critsectracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CritsecTracking.h
 *  Content:	Debug critical section tracking for detecting leaks, nesting, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 	1/10/2002	masonb	Created
 *
 ***************************************************************************/

#ifndef	__CRITSECTRACKING_H__
#define	__CRITSECTRACKING_H__

#include "callstack.h"
#include "classbilink.h"

#ifdef DPNBUILD_ONLYONETHREAD

#define	DNEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )
#define DNInitializeCriticalSection( pCriticalSection )	TRUE
#define DNDeleteCriticalSection( pCriticalSection )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )

#else // !DPNBUILD_ONLYONETHREAD

#ifdef DBG

struct DNCRITICAL_SECTION
{
	CRITICAL_SECTION	CriticalSection;

	UINT_PTR		OwningThreadID;
	UINT_PTR		MaxLockCount;
	UINT_PTR		LockCount;
	CCallStack		CallStack;
	CCallStack		AllocCallStack;
	CBilink			blAllCritSecs;
	CBilink			blCritSecsHeld;
	CBilink *		pblCritSecsHeldGroup;
	DWORD			dwLockOrder;
};

BOOL DNCSTrackInitialize();
void DNCSTrackDeinitialize();
BOOL DNCSTrackDumpLeaks();

BOOL	DNCSTrackInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection );
void	DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount );
void	DNCSTrackSetCriticalSectionGroup( DNCRITICAL_SECTION *const pCriticalSection, CBilink * const pblGroup );
void	DNCSTrackSetCriticalSectionLockOrder( DNCRITICAL_SECTION *const pCriticalSection, const DWORD dwLockOrder );
void	DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag );
void	DNCSTrackNoCriticalSectionsTakenByThisThread( CBilink * pblGroup );

#define	DNInitializeCriticalSection( arg )				DNCSTrackInitializeCriticalSection( arg )
#define	DNDeleteCriticalSection( arg )					DNCSTrackDeleteCriticalSection( arg )
#define	DNEnterCriticalSection( arg )					DNCSTrackEnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )					DNCSTrackLeaveCriticalSection( arg )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )		DNCSTrackSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )			DNCSTrackSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )		DNCSTrackSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )		DNCSTrackCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()			DNCSTrackNoCriticalSectionsTakenByThisThread( NULL )
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )	DNCSTrackNoCriticalSectionsTakenByThisThread( pblGroup )

#else // !DBG

#define DNCRITICAL_SECTION CRITICAL_SECTION

#define	DNInitializeCriticalSection( arg )				DNOSInitializeCriticalSection( arg )
#define	DNDeleteCriticalSection( arg )					DeleteCriticalSection( arg )
#define	DNEnterCriticalSection( arg )					EnterCriticalSection( arg )
#define	DNLeaveCriticalSection( arg )					LeaveCriticalSection( arg )
#define	DebugSetCriticalSectionRecursionCount( pCS, Count )
#define	DebugSetCriticalSectionGroup( pCS, pblGroup )
#define	DebugSetCriticalSectionLockOrder( pCS, dwLockOrder )
#define	AssertCriticalSectionIsTakenByThisThread( pCS, Flag )
#define	AssertNoCriticalSectionsTakenByThisThread()
#define	AssertNoCriticalSectionsFromGroupTakenByThisThread( pblGroup )

#endif // DBG
#endif // DPNBUILD_ONLYONETHREAD

#endif	// __CRITSECTRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\callstack.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CallStack.cpp
 *  Content:	Call stack tracking class
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	08/13/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"

#ifdef DBG

#ifndef DPNBUILD_NOIMAGEHLP
#define	_IMAGEHLP_SOURCE_
#include	<Imagehlp.h>
#endif // !DPNBUILD_NOIMAGEHLP

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

#ifndef DPNBUILD_NOIMAGEHLP
//
// prototypes for ImageHlp.DLL functions we get from LoadLibrary().
//
typedef DWORD	(__stdcall * PIMAGEHELP_SYMGETOPTIONS)( void );
typedef DWORD	(__stdcall * PIMAGEHELP_SYMSETOPTIONS)( DWORD SymOptions );
typedef	BOOL	(__stdcall * PIMAGEHELP_SYMINITIALIZE)( HANDLE hProcess, PSTR pUserSearchPath, BOOL fInvadeProcess );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR)( HANDLE hProcess, DWORD dwAddress, PDWORD pdwDisplacement, PIMAGEHLP_SYMBOL pSymbol );
typedef BOOL	(__stdcall * PIMAGEHELP_SYMGETSYMFROMADDR64)( HANDLE hProcess, DWORD_PTR dwAddress, PDWORD_PTR pdwDisplacement, PIMAGEHLP_SYMBOL64 pSymbol );

#endif // !DPNBUILD_NOIMAGEHLP

//**********************************************************************
// Class function definitions
//**********************************************************************

void	CCallStack::NoteCurrentCallStack( void )
{
	void		**CallersEBP = NULL;
	void		*ReturnAddr;
	UINT_PTR	i,iCount;
	const void	*StackTop;
	const void	*StackBottom;
	static const void	*const min_dll_base = NULL;


	StackTop = GetStackTop();
	StackBottom = GetStackBottom();
	memset(	m_CallStack, 0x00, sizeof( m_CallStack ) );

#ifdef	_X86_
	_asm
	{
		mov eax,[ebp]
		mov CallersEBP,eax
	}
#endif	// _X86_

	_try
	{
		//
		// this code can generate exception if it steps back too far...
		//
 		for ( i = 0, iCount = 0; i < CALLSTACK_DEPTH; iCount++ )
		{
			if ( ( CallersEBP < StackBottom ) || ( CallersEBP >= StackTop ) )
				break;
			ReturnAddr = CallersEBP[ 1 ];
			if ( ( iCount > 0 ) || ( ReturnAddr >= min_dll_base ) ) // iCount check skips memory_alloc_debug
				m_CallStack[ i++ ] = ReturnAddr;
			CallersEBP = reinterpret_cast<void**>( *CallersEBP ); // get callers callers ebp
		}
	}
	_except(EXCEPTION_EXECUTE_HANDLER)  // went too far back on the stack, rest of array is filled with zeros
	{
//		DPFX(DPFPREP,  0, "Benign access violation creating return address stack." );
	}
}

const void* CCallStack::GetStackTop( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[4]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}

const void	*CCallStack::GetStackBottom( void ) const
{
	void	*pReturn = NULL;

#ifdef	_X86_
	_asm	mov eax,dword ptr fs:[8]
	_asm	mov pReturn, eax
#endif	// _X86_

	return	pReturn;
}

void CCallStack::GetCallStackString( TCHAR *const pOutputString ) const
{
	static const TCHAR	CallStackTitle[] = _T("\nCALL STACK:\n");
	static const TCHAR	CallStackTitleWithSymbols[] = _T("\nCALL STACK:\tFUNCTION DETAILS:\n");
	
#ifndef DPNBUILD_NOIMAGEHLP 
	static enum
	{
		IMAGEHELP_STATUS_UNKNOWN,
		IMAGEHELP_STATUS_LOADED,
		IMAGEHELP_STATUS_LOAD_FAILED
	} ImageHelpStatus = IMAGEHELP_STATUS_UNKNOWN;

	static HINSTANCE	hImageHelp = NULL;
	static PIMAGEHELP_SYMGETOPTIONS			pSymGetOptions = NULL;
	static PIMAGEHELP_SYMSETOPTIONS			pSymSetOptions = NULL;
	static PIMAGEHELP_SYMINITIALIZE			pSymInitialize = NULL;

#ifndef	_WIN64	
	static PIMAGEHELP_SYMGETSYMFROMADDR		pSymGetSymFromAddr = NULL;
#else
	static PIMAGEHELP_SYMGETSYMFROMADDR64	pSymGetSymFromAddr = NULL;
#endif	// _WIN64

	//
	// if ImageHelp isn't loaded attempt to load it
	//
	if ( ImageHelpStatus == IMAGEHELP_STATUS_UNKNOWN )
	{
		ImageHelpStatus = IMAGEHELP_STATUS_LOAD_FAILED;

		hImageHelp = LoadLibrary( _T("ImageHLP.DLL") );
		if ( hImageHelp == NULL )
		{
			goto FailedImageHelpLoad;
		}

		pSymGetOptions = reinterpret_cast<PIMAGEHELP_SYMGETOPTIONS>( GetProcAddress( hImageHelp, "SymGetOptions" ) );
		pSymSetOptions = reinterpret_cast<PIMAGEHELP_SYMSETOPTIONS>( GetProcAddress( hImageHelp, "SymSetOptions" ) );
		pSymInitialize = reinterpret_cast<PIMAGEHELP_SYMINITIALIZE>( GetProcAddress( hImageHelp, "SymInitialize" ) );

#ifndef	_WIN64		
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR>( GetProcAddress( hImageHelp, "SymGetSymFromAddr" ) );
#else	// _WIN64
		pSymGetSymFromAddr = reinterpret_cast<PIMAGEHELP_SYMGETSYMFROMADDR64>( GetProcAddress( hImageHelp, "SymGetSymFromAddr64" ) );
#endif	// _WIN64

		if ( ( pSymGetOptions == NULL ) ||
			 ( pSymSetOptions == NULL ) ||
			 ( pSymInitialize == NULL ) ||
			 ( pSymGetSymFromAddr == NULL ) )
		{
			goto FailedImageHelpLoad;
		}

		pSymSetOptions( SYMOPT_DEFERRED_LOADS | pSymGetOptions() );

		if ( pSymInitialize( GetCurrentProcess(), NULL, TRUE ) == FALSE )
		{
			if ( pSymInitialize( GetCurrentProcess(), NULL, FALSE ) == FALSE )
			{
				goto FailedImageHelpLoad;
			}
		}

		ImageHelpStatus = IMAGEHELP_STATUS_LOADED;
	}

FailedImageHelpLoad:
	if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
	{
		memcpy( pOutputString, CallStackTitleWithSymbols, sizeof( CallStackTitleWithSymbols ) );
	}
	else
#endif // !DPNBUILD_NOIMAGEHLP
	{
		memcpy( pOutputString, CallStackTitle, sizeof( CallStackTitle ) );
	}

	for ( DWORD dwIndex = 0; ( ( dwIndex < CALLSTACK_DEPTH ) && ( m_CallStack[ dwIndex ] != NULL ) ); dwIndex++ )
	{
		TCHAR	AddressBuffer[ CALLSTACK_BUFFER_SIZE ];


#ifndef DPNBUILD_NOIMAGEHLP
		if ( ImageHelpStatus == IMAGEHELP_STATUS_LOADED )
		{
			TCHAR	ImageBuffer[ CALLSTACK_BUFFER_SIZE + sizeof(IMAGEHLP_SYMBOL) ];
			DWORD_PTR	dwFunctionDisplacement;
#ifndef	_WIN64
			IMAGEHLP_SYMBOL	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL*>( ImageBuffer );
#else	// _WIN64
			IMAGEHLP_SYMBOL64	*const pImageHelpSymbol = reinterpret_cast<IMAGEHLP_SYMBOL64*>( ImageBuffer );
#endif	// _WIN64


			pImageHelpSymbol->SizeOfStruct = sizeof( *pImageHelpSymbol );
			pImageHelpSymbol->Flags = 0;
			pImageHelpSymbol->Address = reinterpret_cast<DWORD_PTR>( m_CallStack[ dwIndex ] );
            pImageHelpSymbol->MaxNameLength = sizeof( ImageBuffer ) - sizeof( *pImageHelpSymbol ) - 14;   // account for \t%s+0x00000000\n\0
            if ( pSymGetSymFromAddr( GetCurrentProcess(),
									 reinterpret_cast<DWORD_PTR>( m_CallStack[ dwIndex ] ),
									 &dwFunctionDisplacement,
									 pImageHelpSymbol
									 ) != FALSE )
            {
                if ( dwFunctionDisplacement != 0 )
				{
#ifdef _X86_
					wsprintf( AddressBuffer, _T("0x%x\t%hs+0x%x\n"), (DWORD)m_CallStack[ dwIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#else
					wsprintf( AddressBuffer, _T("0x%p\t%hs+0x%x\n"), m_CallStack[ dwIndex ], pImageHelpSymbol->Name, dwFunctionDisplacement );
#endif // _X86_
				}
                else
				{
#ifdef _X86_
                    wsprintf( AddressBuffer, _T("0x%x\t%hs\n"), (DWORD)m_CallStack[ dwIndex ], pImageHelpSymbol->Name );
#else
                    wsprintf( AddressBuffer, _T("0x%p\t%hs\n"), m_CallStack[ dwIndex ], pImageHelpSymbol->Name );
#endif // _X86_
				}

				_tcscat( pOutputString, AddressBuffer );

				//
				// continue FOR loop
				//
				continue;
            }
		}	
#endif // !DPNBUILD_NOIMAGEHLP

#ifdef _X86_
		wsprintf( AddressBuffer, _T("0x%08x\n"), (DWORD)m_CallStack[ dwIndex ] );
#else
		wsprintf( AddressBuffer, _T("0x%p\n"), m_CallStack[ dwIndex ] );
#endif // _X86_
		_tcscat( pOutputString, AddressBuffer );
	}

	return;
}
//**********************************************************************

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\dndbg.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.h
 *  Content:	debug support functions for DirectNet
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *	07-16-99	johnkan	Added DEBUG_ONLY, DBG_CASSERT, fixed DPFERR to take an argument
 *  02-17-00	rodtoll	Added Memory / String validation routines
 *  05-23-00	RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-27-00	masonb	Rewrite to make sub-component stuff work, improve perf
 *  08/28/2000	masonb	Voice Merge: Part of header guard was missing (#define _DNDBG_H_)
 *  10/25/2001	vanceo	Use NT build friendly BUGBUG, TODO, plus add PRINTVALUE.
 *
 ***************************************************************************/

#ifndef _DNDBG_H_
#define _DNDBG_H_

#ifdef __cplusplus
	extern "C" {
#endif // __cplusplus

// DEBUG_BREAK()
#if defined(DBG) || defined(DPINST)
	#define DEBUG_BREAK() DebugBreak()
#endif // defined(DBG) || defined(DPINST)


//==================================================================================
// Useful macros based on some DNet code (which was taken from code by ToddLa)
//==================================================================================
//
// Macros that generate compile time messages.  Use these with #pragma:
//
//	#pragma TODO(vanceo, "Fix this later")
//	#pragma BUGBUG(vanceo, "Busted!")
//	#pragma PRINTVALUE(DPERR_SOMETHING)
//
// To turn them off, define TODO_OFF, BUGBUG_OFF, PRINTVALUE_OFF in your project
// preprocessor defines.
//
//
// If we're building under VC, (as denoted by the preprocessor define
// DPNBUILD_ENV_NT), these expand to look like:
//
//	D:\directory\file.cpp(101) : BUGBUG: vanceo: Busted!
//
// in your output window, and you should be able to double click on it to jump
// directly to that location (line 101 of D:\directory\file.cpp).
//
// If we're building under the NT build environment, these expand to look like:
//
//	BUGBUG: vanceo: D:\directory\file.cpp(101) : Busted!
//
// because (at least right now) the build process thinks that a failure occurred if
// a message beginning with a filename and line number is printed.  It used to work
// just fine, but who knows.
//

#ifdef DPNBUILD_ENV_NT
#define __TODO(user, msgstr, n)								message("TODO: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __BUGBUG(user, msgstr, n)							message("BUGBUG: " #user ": " __FILE__ "(" #n ") : " msgstr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message("PRINTVALUE: " __FILE__ "(" #n ") : " itemnamestr " = " itemvaluestr)
#else // ! DPNBUILD_ENV_NT
#define __TODO(user, msgstr, n)								message(__FILE__ "(" #n ") : TODO: " #user ": " msgstr)
#define __BUGBUG(user, msgstr, n)							message(__FILE__ "(" #n ") : BUGBUG: " #user ": " msgstr)
#define __PRINTVALUE(itemnamestr, itemvaluestr, n)			message(__FILE__ "(" #n ") : PRINTVALUE: " itemnamestr " = " itemvaluestr)
#endif // ! DPNBUILD_ENV_NT


#define _TODO(user, msgstr, n)								__TODO(user, msgstr, n)
#define _BUGBUG(user, msgstr, n)							__BUGBUG(user, msgstr, n)
#define _PRINTVALUE(itemstr, item, n)						__PRINTVALUE(itemstr, #item, n)


#ifdef TODO_OFF
#define TODO(user, msgstr)
#else
#define TODO(user, msgstr)									_TODO(user, msgstr, __LINE__)
#endif // TODO_OFF

#ifdef BUGBUG_OFF
#define BUGBUG(user, msgstr)
#else
#define BUGBUG(user, msgstr)								_BUGBUG(user, msgstr, __LINE__)
#endif // BUGBUG_OFF

#ifdef PRINTVALUE_OFF
#define PRINTVALUE(item)
#else
#define PRINTVALUE(item)									_PRINTVALUE(#item, item, __LINE__)
#endif // PRINTVALUE_OFF



//========================
// Debug Logging support
//========================

/*=============================================================================
 Usage:

 In code, you can use DPF to print to the log or the debug windows of the
 running application.  The format of DPF (debug printf) is as follows:

	DPFX(DPFPREP,level, string *fmt, arg1, arg2, ...);

 level specifies how important this debug printf is.  The standard convention
 for debug levels is as follows.  This is no way strictly enforced for
 personal use, but by the time the code is checked in, it should be as close
 to this as possible...

  DPF_ERRORLEVEL:		Error useful for application developers.
  DPF_WARNINGLEVEL:		Warning useful for application developers.
  DPF_ENTRYLEVEL:		API Entered
  DPF_APIPARAM:			API parameters, API return values
  DPF_LOCKS:			Driver conversation
  DPF_INFOLEVEL:		Deeper program flow notifications
  DPF_STRUCTUREDUMP:	Dump structures
  DPF_TRACELEVEL:		Trace messages

 When printing a critical error, you can use:
	
	  DPERR( "String" );

 which will print a string at debug level zero.

 In order to cause the code to stop and break in.  You can use ASSERT() or
 DEBUG_BREAK().  In order for ASSERT to break in, you must have
 BreakOnAssert set in the win.ini file section (see osindep.cpp).

=============================================================================*/

#define DPF_ERRORLEVEL			0
#define DPF_WARNINGLEVEL		1
#define DPF_ENTRYLEVEL			2
#define DPF_APIPARAM			3
#define DPF_LOCKS				4
#define DPF_INFOLEVEL			5
#define DPF_STRUCTUREDUMP		6
#define DPF_TRACELEVEL			9

// For Voice
#define DVF_ERRORLEVEL			0
#define DVF_WARNINGLEVEL		1
#define DVF_ENTRYLEVEL			2
#define DVF_APIPARAM			3
#define DVF_LOCKS				4
#define DVF_INFOLEVEL			5
#define DVF_STRUCTUREDUMP		6
#define DVF_TRACELEVEL			9

/*
 * List of all possible sub-components. If you add additional
 * components you also need to update the g_rgszSubCompName 
 * variable defined in dndbg.cpp
 */

#define DN_SUBCOMP_GLOBAL		0
#define DN_SUBCOMP_CORE			1
#define DN_SUBCOMP_ADDR			2
#define DN_SUBCOMP_LOBBY		3
#define DN_SUBCOMP_PROTOCOL		4
#define DN_SUBCOMP_VOICE		5
#define DN_SUBCOMP_DPNSVR		6
#define DN_SUBCOMP_WSOCK		7
#define DN_SUBCOMP_MODEM		8
#define DN_SUBCOMP_COMMON		9
#define DN_SUBCOMP_NATHELP		10
#define DN_SUBCOMP_TOOLS		11
#define DN_SUBCOMP_THREADPOOL	12
#define DN_SUBCOMP_BLUETOOTH	13

#ifdef DBG

extern void DebugPrintfX(LPCTSTR szFile, DWORD dwLineNumber,LPCTSTR szFnName, DWORD dwSubComp, DWORD dwDetail, ...);
extern void _DNAssert(LPCTSTR szFile, DWORD dwLineNumber, LPCTSTR szFnName, DWORD dwSubComp, LPCTSTR szCondition, DWORD dwLevel);

#define DPFX						DebugPrintfX

#define DPFPREP						_T(__FILE__),__LINE__,_T(DPF_MODNAME), DPF_SUBCOMP

#define DPFERR(a) 					DebugPrintfX(DPFPREP, DPF_ERRORLEVEL, a )
#ifdef DPNBUILD_USEASSUME
#define DNASSERT(condition)			__assume(condition)
#define DNASSERTX(condition, level)	DBG_CASSERT(level > 1); if (!(condition)) _DNAssert(DPFPREP, _T(#condition), level)
#else // ! DPNBUILD_USEASSUME
#define DNASSERT(condition) 		if (!(condition)) _DNAssert(DPFPREP, _T(#condition), 1)
#define DNASSERTX(condition, level)	if (!(condition)) _DNAssert(DPFPREP, _T(#condition), level)
#endif // ! DPNBUILD_USEASSUME

#define DBG_CASSERT(exp)			switch (0) case 0: case exp:
#define DEBUG_ONLY(arg)				arg
#define DPF_RETURN(a) 				DPFX(DPFPREP,DPF_APIPARAM,"Returning: 0x%lx",a);    return a;
#define DPF_ENTER() 				DPFX(DPFPREP,DPF_TRACELEVEL, "Enter");
#define DPF_EXIT() 					DPFX(DPFPREP,DPF_TRACELEVEL, "Exit");


#else // NOT DBG

	// C4002: too many actual parameters for macro 'identifier'
	#pragma warning(disable:4002)
	#define DPFX()
	#define DPFERR(a)
#ifdef DPNBUILD_USEASSUME
	#define DNASSERT(condition)			__assume(condition)
	#define DNASSERTX(condition, level)
#else // ! DPNBUILD_USEASSUME
	#define DNASSERT(condition)
	#define DNASSERTX(condition, level)
#endif // ! DPNBUILD_USEASSUME
	#define DBG_CASSERT(exp)
#ifndef DEBUG_ONLY
	#define DEBUG_ONLY(arg)
#endif
	#define DPF_RETURN(a)				return a;	
	#define DPF_ENTER()
	#define DPF_EXIT()

#endif // DBG

#ifdef __cplusplus
	}	//extern "C"
#endif // __cplusplus

#endif // _DNDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\handletracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTracking.h
 *  Content:    Handle Tracking Header File
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/31/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef __HANDLETRACKING_H__
#define __HANDLETRACKING_H__

#ifdef DBG

BOOL DNHandleTrackInitialize();
VOID DNHandleTrackDeinitialize();
BOOL DNHandleTrackDumpLeaks();

enum HandleType
{
	TypeEvent,
	TypeMutex,
	TypeSemaphore,
	TypeFile,
	TypeFileMap,		// not used when DPNBUILD_SINGLEPROCESS defined
	TypeThread,
	TypeProcess,		// not used when DPNBUILD_SINGLEPROCESS defined
	TypeSpecial
};

struct TRACKED_HANDLE
{
	HANDLE handle;
	HandleType type;
	CBilink blHandle;
	CCallStack AllocCallStack;
};

typedef TRACKED_HANDLE* DNHANDLE;
#define DNINVALID_HANDLE_VALUE ((DNHANDLE)INVALID_HANDLE_VALUE)

#ifndef DPNBUILD_SINGLEPROCESS
struct DNPROCESS_INFORMATION
{
	DNHANDLE hProcess; 
    DNHANDLE hThread; 
    DWORD dwProcessId; 
    DWORD dwThreadId; 
};
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackMakeDNHANDLE(HANDLE h);
VOID	 DNHandleTrackRemoveDNHANDLE(DNHANDLE dnh);
HANDLE 	 DNHandleTrackHandleFromDNHANDLE(DNHANDLE h);

#ifndef DPNBUILD_SINGLEPROCESS
BOOL	 DNHandleTrackCreateProcess(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, DNPROCESS_INFORMATION* lpProcessInformation);
DNHANDLE DNHandleTrackOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);

DNHANDLE DNHandleTrackCreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
BOOL	 DNHandleTrackSetEvent(DNHANDLE hHandle);
BOOL	 DNHandleTrackResetEvent(DNHANDLE hHandle);

DNHANDLE DNHandleTrackCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenMutex(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);
BOOL	 DNHandleTrackReleaseMutex(DNHANDLE hHandle);

DNHANDLE DNHandleTrackCreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName);
BOOL	 DNHandleTrackReleaseSemaphore(DNHANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);

DNHANDLE DNHandleTrackCreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
#ifndef DPNBUILD_SINGLEPROCESS
DNHANDLE DNHandleTrackCreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName);
DNHANDLE DNHandleTrackOpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName);

BOOL DNHandleTrackGetExitCodeProcess(DNHANDLE hHandle, LPDWORD lpExitCode);
#endif // ! DPNBUILD_SINGLEPROCESS

DWORD	 DNHandleTrackWaitForSingleObject(DNHANDLE hHandle, DWORD dwMilliseconds);
DWORD	 DNHandleTrackWaitForSingleObjectEx(DNHANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);
DWORD	 DNHandleTrackWaitForMultipleObjects(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds);
DWORD	 DNHandleTrackWaitForMultipleObjectsEx(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable);
DWORD	 DNHandleTrackSignalObjectAndWait(DNHANDLE hObjectToSignal, DNHANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);

BOOL	 DNHandleTrackCloseHandle(DNHANDLE hHandle);


#define MAKE_DNHANDLE(x) DNHandleTrackMakeDNHANDLE(x)
#define REMOVE_DNHANDLE(x) DNHandleTrackRemoveDNHANDLE(x)
#define HANDLE_FROM_DNHANDLE(x) DNHandleTrackHandleFromDNHANDLE(x)

#define DNCreateProcess DNHandleTrackCreateProcess
#define DNOpenProcess DNHandleTrackOpenProcess

#define DNCreateThread DNHandleTrackCreateThread

#define DNCreateEvent DNHandleTrackCreateEvent
#define DNOpenEvent DNHandleTrackOpenEvent
#define DNSetEvent DNHandleTrackSetEvent
#define DNResetEvent DNHandleTrackResetEvent

#define DNCreateMutex DNHandleTrackCreateMutex
#define DNOpenMutex DNHandleTrackOpenMutex
#define DNReleaseMutex DNHandleTrackReleaseMutex

#define DNCreateSemaphore DNHandleTrackCreateSemaphore
#define DNReleaseSemaphore DNHandleTrackReleaseSemaphore

#define DNGetExitCodeProcess DNHandleTrackGetExitCodeProcess

#define DNCreateFile DNHandleTrackCreateFile
#define DNCreateFileMapping DNHandleTrackCreateFileMapping
#define DNOpenFileMapping DNHandleTrackOpenFileMapping

#define DNWaitForSingleObject DNHandleTrackWaitForSingleObject
#define DNWaitForSingleObjectEx DNHandleTrackWaitForSingleObjectEx
#define DNWaitForMultipleObjects DNHandleTrackWaitForMultipleObjects
#define DNWaitForMultipleObjectsEx DNHandleTrackWaitForMultipleObjectsEx
#define DNSignalObjectAndWait DNHandleTrackSignalObjectAndWait

#define DNCloseHandle DNHandleTrackCloseHandle

#else // !DBG

#define DNInitializeHandleTracking() TRUE
#define DNDeinitializeHandleTracking()
#define DNDumpLeakedHandles() FALSE

#define DNHANDLE HANDLE
#define DNINVALID_HANDLE_VALUE INVALID_HANDLE_VALUE
#define MAKE_DNHANDLE(x) x
#define REMOVE_DNHANDLE(x) 
#define HANDLE_FROM_DNHANDLE(x) x

#ifndef DPNBUILD_SINGLEPROCESS
#define DNPROCESS_INFORMATION PROCESS_INFORMATION
#define DNCreateProcess CreateProcess
#define DNOpenProcess OpenProcess
#endif // ! DPNBUILD_SINGLEPROCESS

#define DNCreateThread CreateThread

#define DNCreateEvent CreateEvent
#define DNOpenEvent OpenEvent
#define DNSetEvent SetEvent
#define DNResetEvent ResetEvent

#define DNCreateMutex CreateMutex
#define DNOpenMutex OpenMutex
#define DNReleaseMutex ReleaseMutex

#define DNCreateSemaphore CreateSemaphore
#define DNReleaseSemaphore ReleaseSemaphore

#define DNCreateFile CreateFile
#ifndef DPNBUILD_SINGLEPROCESS
#define DNCreateFileMapping CreateFileMapping
#define DNOpenFileMapping OpenFileMapping

#define DNGetExitCodeProcess GetExitCodeProcess
#endif // ! DPNBUILD_SINGLEPROCESS

#define DNWaitForSingleObject WaitForSingleObject

#define DNWaitForSingleObjectEx WaitForSingleObjectEx
#define DNWaitForMultipleObjects WaitForMultipleObjects
#define DNWaitForMultipleObjectsEx WaitForMultipleObjectsEx
#ifdef WINNT
#define DNSignalObjectAndWait SignalObjectAndWait
#else // ! WINNT
#define DNSignalObjectAndWait(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable) SetEvent(hObjectToSignal),WaitForSingleObjectEx(hObjectToWaitOn, dwMilliseconds, bAlertable)
#endif // ! WINNT

#define DNCloseHandle CloseHandle

#endif // DBG

#endif // __HANDLETRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\memlog.h ===
/*==========================================================================
 *
 *  Copyright (C) 2000 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memlog.h
 *  Content:	format of the memory log for DPlay debugging
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  08-24-00		masonb		Created
 *
 ***************************************************************************/

#ifndef _DPLAY_SHARED_MEMLOG_
#define _DPLAY_SHARED_MEMLOG_

	// Max string length (in bytes) for MEM logging
#define DPLOG_MAX_STRING (512 * sizeof(TCHAR))	
	// Default number of entries for mem log. Adjustable from win.ini
#define DPLOG_DEFAULT_ENTRIES	40000		

#define DPLOG_HEADERSIZE (sizeof(SHARED_LOG_FILE))
#define DPLOG_ENTRYSIZE (sizeof(MEMLOG_ENTRY) + DPLOG_MAX_STRING)

#define BASE_LOG_MEMFILENAME  	"DPLAY8MEMLOG-0"
#define BASE_LOG_MUTEXNAME 	"DPLAY8MEMLOGMUTEX-0"

#pragma warning(disable:4200) // 0 length array
typedef struct _MEM_LOG_ENTRY 
{
	DWORD	tLogged;
	TCHAR	str[0];
} MEMLOG_ENTRY, *PMEMLOG_ENTRY;

typedef struct _SHARED_LOG_FILE
{
	DWORD   	nEntries;
	DWORD		cbLine;
	DWORD 		iWrite;
} SHARED_LOG_FILE, *PSHARED_LOG_FILE;
#pragma warning(default:4200)


#ifdef DPNBUILD_LIBINTERFACE
extern PSHARED_LOG_FILE		g_pMemLog;
#endif // DPNBUILD_LIBINTERFACE


#endif // _DPLAY_SHARED_MEMLOG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\memorytracking.h ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.h
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/14/2001	masonb	Created
 *
 ***************************************************************************/

#ifndef	__MEMORYTRACKING_H__
#define	__MEMORYTRACKING_H__



#ifdef DBG

BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage);
void DNMemoryTrackDeinitialize();

BOOL DNMemoryTrackDumpLeaks();


void* DNMemoryTrackHeapAlloc(DWORD_PTR MemorySize);
void DNMemoryTrackHeapFree(void* pMemory);
void DNMemoryTrackValidateMemory();

#define DNMalloc( size )							DNMemoryTrackHeapAlloc( size )
#define DNFree( pData )								DNMemoryTrackHeapFree( pData )
#define DNValidateMemory()							DNMemoryTrackValidateMemory()

#else // !DBG

#ifdef DPNBUILD_FIXEDMEMORYMODEL

BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage);
void DNMemoryTrackDeinitialize();
extern HANDLE		g_hMemoryHeap;
#define DNMemoryTrackGetHeap()						(g_hMemoryHeap)

#else // ! DPNBUILD_FIXEDMEMORYMODEL

#define DNMemoryTrackInitialize(dwMaxMemUsage)		(TRUE)
#define DNMemoryTrackDeinitialize()
#define DNMemoryTrackGetHeap						GetProcessHeap

#endif // ! DPNBUILD_FIXEDMEMORYMODEL

#define DNMalloc( size )							HeapAlloc( DNMemoryTrackGetHeap(), 0, size )
#define DNFree( pData )								HeapFree( DNMemoryTrackGetHeap(), 0, pData )
#define DNValidateMemory()

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

void DNMemoryTrackAllowAllocations(BOOL fAllow);
extern BOOL		g_fAllocationsAllowed;
#define DNMemoryTrackAreAllocationsAllowed()		(g_fAllocationsAllowed)

#else // ! DPNBUILD_PREALLOCATEDMEMORYMODEL

#define DNMemoryTrackAllowAllocations( fAllow )
#define DNMemoryTrackAreAllocationsAllowed()		(TRUE)

#endif // ! DPNBUILD_PREALLOCATEDMEMORYMODEL



#endif	// __MEMORYTRACKING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\dncmni.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DNCOMMONi.h
 *  Content:    DirectPlay Common master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/28/01    masonb  Created.
 *
 ***************************************************************************/

#ifndef __DNCOMMONI_H__
#define __DNCOMMONI_H__

//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
#include <xtl.h>
#else // ! _XBOX or XBOX_ON_DESKTOP
#include <windows.h>
#include <mmsystem.h>
#ifndef WINCE
#include <inetmsg.h>
#endif // ! WINCE
#include <tapi.h>
#include <stdio.h> // swscanf being used by guidutil.cpp
#ifdef WINNT
#include <accctrl.h>
#include <aclapi.h>
#endif // WINNT
#include <winsock.h>
#endif // ! _XBOX or XBOX_ON_DESKTOP
#include <tchar.h>


// 
// Common private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "strutils.h"
#include "CallStack.h"
#include "CritsecTracking.h"
#include "HandleTracking.h"
#include "MemoryTracking.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON


#endif // __DNCOMMONI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\critsectracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.cpp
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	1/10/2002	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"

#ifndef DPNBUILD_ONLYONETHREAD
#ifdef DBG


//
// Uncomment this line to turn critical section internal structure validation on.
//
//#define DNCS_VALIDATE



#define	DN_INVALID_THREAD_ID			-1

CBilink				g_blAllCritSecs;
CBilink				g_blGlobalCritSecsHeldGroup;
CRITICAL_SECTION	g_CSLock;
DWORD				g_dwNumCritSecsAllocated = 0;
DWORD				g_dwNumCritSecsEntered = 0;


#ifdef DNCS_VALIDATE
void DNCSTrackInternalValidate();
#else // ! DNCS_VALIDATE
#define DNCSTrackInternalValidate()
#endif // DNCS_VALIDATE


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitialize"
BOOL DNCSTrackInitialize()
{
	g_blAllCritSecs.Initialize();
	g_blGlobalCritSecsHeldGroup.Initialize();

	if ( DNOSInitializeCriticalSection(&g_CSLock) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critical section tracking code!" );
		DNASSERT( FALSE );
		return FALSE;
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDeinitialize"
void DNCSTrackDeinitialize()
{
	DeleteCriticalSection(&g_CSLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDumpLeaks"
BOOL DNCSTrackDumpLeaks()
{
	DNCRITICAL_SECTION* pCS;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];
	BOOL fLeaked = FALSE;

	EnterCriticalSection(&g_CSLock);
	while (!g_blAllCritSecs.IsEmpty())
	{
		pCS = CONTAINING_OBJECT(g_blAllCritSecs.GetNext(), DNCRITICAL_SECTION, blAllCritSecs);
		
		pCS->AllocCallStack.GetCallStackString(CallStackBuffer);

		DPFX(DPFPREP,  0, "Critical Section leaked at address 0x%p\n%s", pCS, CallStackBuffer );

		pCS->blAllCritSecs.RemoveFromList();

		DeleteCriticalSection(&pCS->CriticalSection);

		fLeaked = TRUE;
	}
	LeaveCriticalSection(&g_CSLock);

	return fLeaked;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInitializeCriticalSection"
BOOL DNCSTrackInitializeCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	BOOL fReturn;

	DNASSERT( pCriticalSection != NULL );
	memset( pCriticalSection, 0x00, sizeof( *pCriticalSection ) );

	pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;
	pCriticalSection->MaxLockCount = -1;
	pCriticalSection->blCritSecsHeld.Initialize();
	pCriticalSection->blAllCritSecs.Initialize();
	pCriticalSection->pblCritSecsHeldGroup = &g_blGlobalCritSecsHeldGroup;

	fReturn = DNOSInitializeCriticalSection(&pCriticalSection->CriticalSection);
	if ( fReturn != FALSE )
	{
		pCriticalSection->AllocCallStack.NoteCurrentCallStack();

		EnterCriticalSection(&g_CSLock);
		pCriticalSection->blAllCritSecs.InsertBefore(&g_blAllCritSecs);
		g_dwNumCritSecsAllocated++;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}

	return	fReturn;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackDeleteCriticalSection"
void DNCSTrackDeleteCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pCriticalSection->LockCount == 0 );

	EnterCriticalSection(&g_CSLock);

	pCriticalSection->blAllCritSecs.RemoveFromList();
	g_dwNumCritSecsAllocated--;

	// NOTE: If they delete the CS without leaving it, still remove it from the held list.
	// If asserts are on, this will have asserted above at LockCount == 0.
	// Calling this is safe whether it is on the list or not.
	pCriticalSection->blCritSecsHeld.RemoveFromList();

	DNCSTrackInternalValidate();
	
	LeaveCriticalSection(&g_CSLock);

	DeleteCriticalSection( &pCriticalSection->CriticalSection );
	memset( &pCriticalSection->CriticalSection, 0x00, sizeof( pCriticalSection->CriticalSection ) );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalRecursionCount"
void DNCSTrackSetCriticalSectionRecursionCount( DNCRITICAL_SECTION *const pCriticalSection, const UINT_PTR RecursionCount )
{
	DNASSERT( pCriticalSection != NULL );

	pCriticalSection->MaxLockCount = RecursionCount + 1;

	DNASSERT( pCriticalSection->MaxLockCount != 0 );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalSectionGroup"
void DNCSTrackSetCriticalSectionGroup( DNCRITICAL_SECTION *const pCriticalSection, CBilink * const pblGroup )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pblGroup != NULL );

	pCriticalSection->pblCritSecsHeldGroup = pblGroup;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackSetCriticalSectionLockOrder"
void DNCSTrackSetCriticalSectionLockOrder( DNCRITICAL_SECTION *const pCriticalSection, const DWORD dwLockOrder )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( dwLockOrder > 0 );

	pCriticalSection->dwLockOrder = dwLockOrder;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackEnterCriticalSection"
void DNCSTrackEnterCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	UINT_PTR	ThisThreadID;

	DNASSERT( pCriticalSection != NULL );

	EnterCriticalSection( &pCriticalSection->CriticalSection );

	ThisThreadID = GetCurrentThreadId();
	if ( pCriticalSection->OwningThreadID != ThisThreadID )
	{
		DNASSERT( pCriticalSection->OwningThreadID == DN_INVALID_THREAD_ID );
		DNASSERT( pCriticalSection->LockCount == 0 );
		
		pCriticalSection->OwningThreadID = ThisThreadID;
	}
	else
	{
		DNASSERT( pCriticalSection->LockCount != 0 );
	}

	if ( pCriticalSection->LockCount == 0 )
	{
		pCriticalSection->CallStack.NoteCurrentCallStack();

		// Track this critical section that was just entered for the first time.

		EnterCriticalSection(&g_CSLock);

		pCriticalSection->LockCount++;

		//
		// If this critical section has a lock order, assert that we're not
		// violating it.
		//
		if (pCriticalSection->dwLockOrder != 0)
		{
			CBilink *				pBilink;
			DNCRITICAL_SECTION *	pCS;

			pBilink = pCriticalSection->pblCritSecsHeldGroup->GetNext();
			while (pBilink != pCriticalSection->pblCritSecsHeldGroup)
			{
				pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blCritSecsHeld);
				if (pCS->dwLockOrder != 0)
				{
					DNASSERT( pCS->dwLockOrder <= pCriticalSection->dwLockOrder );
				}
				pBilink = pBilink->GetNext();
			}
		}
		
		pCriticalSection->blCritSecsHeld.InsertBefore(pCriticalSection->pblCritSecsHeldGroup);
		DNASSERT(g_dwNumCritSecsEntered < g_dwNumCritSecsAllocated);
		g_dwNumCritSecsEntered++;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}
	else
	{
		pCriticalSection->LockCount++;
	}

	if ( pCriticalSection->LockCount > pCriticalSection->MaxLockCount )
	{
		if ( pCriticalSection->MaxLockCount == 1 )
		{
			TCHAR	CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];

			//
			// Exceeded recursion depth of 1, display stack of call originally
			// holding the lock.
			//
			pCriticalSection->CallStack.GetCallStackString( CallStackBuffer );

			DPFX(DPFPREP, 0, "Critical section 0x%p has been reentered!\nOriginal Holder's Stack:\n%s", pCriticalSection, CallStackBuffer);

			DNASSERT(FALSE);
		}
		else
		{
			//
			// exceeded recursion depth, check your code!!
			//
			DNASSERT(FALSE);
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackLeaveCriticalSection"
void DNCSTrackLeaveCriticalSection( DNCRITICAL_SECTION *const pCriticalSection )
{
	DNASSERT( pCriticalSection != NULL );
	DNASSERT( pCriticalSection->OwningThreadID == GetCurrentThreadId() );
	DNASSERT( pCriticalSection->LockCount <= pCriticalSection->MaxLockCount );
	DNASSERT( pCriticalSection->LockCount != 0 );

	if ( pCriticalSection->LockCount == 1 )
	{
		memset( &pCriticalSection->CallStack, 0x00, sizeof( pCriticalSection->CallStack ) );
		pCriticalSection->OwningThreadID = DN_INVALID_THREAD_ID;

		// Track this critical section being left for the last time.
		EnterCriticalSection(&g_CSLock);
		pCriticalSection->LockCount--;
		pCriticalSection->blCritSecsHeld.RemoveFromList();
		DNASSERT(g_dwNumCritSecsEntered > 0);
		g_dwNumCritSecsEntered--;
		DNCSTrackInternalValidate();
		LeaveCriticalSection(&g_CSLock);
	}
	else
	{
		pCriticalSection->LockCount--;
	}

	LeaveCriticalSection( &pCriticalSection->CriticalSection );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackCriticalSectionIsTakenByThisThread"
void DNCSTrackCriticalSectionIsTakenByThisThread( const DNCRITICAL_SECTION *const pCriticalSection, const BOOL fFlag )
{
	DNASSERT( fFlag == ( pCriticalSection->OwningThreadID == GetCurrentThreadId() ) );
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackNoCriticalSectionsTakenByThisThread"
void DNCSTrackNoCriticalSectionsTakenByThisThread( CBilink * pblGroup )
{
	CBilink* pBilink;
	DNCRITICAL_SECTION* pCS;

	if (pblGroup == NULL)
	{
		pblGroup = &g_blGlobalCritSecsHeldGroup;
	}

	EnterCriticalSection(&g_CSLock);

	pBilink = pblGroup->GetNext();
	while (pBilink != pblGroup)
	{
		pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blCritSecsHeld);
		DNASSERT( pCS->OwningThreadID != GetCurrentThreadId() );
		pBilink = pBilink->GetNext();
	}

	DNCSTrackInternalValidate();

	LeaveCriticalSection(&g_CSLock);
}



#ifdef DNCS_VALIDATE

#undef DPF_MODNAME
#define DPF_MODNAME "DNCSTrackInternalValidate"
void DNCSTrackInternalValidate()
{
	CBilink* pBilink;
	DNCRITICAL_SECTION* pCS;
	DWORD dwNumAllocated = 0;
	DWORD dwNumEntered = 0;

	//
	// The global critical section lock must be held!
	//

	DNASSERT(g_dwNumCritSecsEntered <= g_dwNumCritSecsAllocated);
	
	pBilink = g_blAllCritSecs.GetNext();
	while (pBilink != &g_blAllCritSecs)
	{
		DNASSERT(pBilink->GetNext() != pBilink);
		DNASSERT(pBilink->GetPrev() != pBilink);
		DNASSERT(pBilink->IsListMember(&g_blAllCritSecs));
		
		pCS = CONTAINING_OBJECT(pBilink, DNCRITICAL_SECTION, blAllCritSecs);

		dwNumAllocated++;
		if (pCS->blCritSecsHeld.IsEmpty())
		{
			DNASSERT(pCS->LockCount == 0);
		}
		else
		{
			DNASSERT(pCS->LockCount > 0);
			dwNumEntered++;
		}

		pBilink = pBilink->GetNext();		
	}
	
	DNASSERT(dwNumAllocated == g_dwNumCritSecsAllocated);
	DNASSERT(dwNumEntered == g_dwNumCritSecsEntered);
}

#endif // DNCS_VALIDATE


#endif // DBG
#endif // !DPNBUILD_ONLYONETHREAD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\dndbg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dndbg.c
 *  Content:	debug support for DirectPlay8
 *				
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  05-20-99	aarono	Created
 *  07-16-99	johnkan	Fixed include of OSInd.h, defined WSPRINTF macro
 *  07-19-99	vanceo	Explicitly declared OutStr as returning void for NT
 *						Build environment.
 *	07-22-99	a-evsch	Check for multiple Inits,  and release CritSec when DebugPrintf
 *						returns early.
 *	08-02-99	a-evsch	Added LOGPF support. LW entries only go into shared-file log
 *	08-31-99	johnkan	Removed include of <OSIND.H>
 *  02-17-00  	rodtoll	Added Memory / String validation routines
 *  05-23-00    RichGr  IA64: Changed some DWORDs to DWORD_PTRs to make va_arg work OK.
 *  07-16-00    jchauvin IA64:  Added %p parsing to change back to %x for Win9x machines in DebugPrintf, DebugPrintfNoLock, LogPrintf
 *  07-24-00    RichGr  IA64: As there's no separate build for Win9x, added code to detect Win9x for the %p parse-and-replace.
 *	07-29-00	masonb	Rewrite to add logging by subcomponent, perf improvements, process ID
 *	08/28/2000	masonb	Voice Merge: Modified asm in DebugPrintf to preserve registers that may have affected Voice
 *  03/29/2001  RichGr  If DPINST is defined for Performance Instrumentation, allow free build to pick up the code.
 *	
 *  Notes:
 *	
 *  Use /Oi compiler option for strlen()
 *
 ***************************************************************************/

#include "dncmni.h"
#include "memlog.h"

#if defined(DBG) || defined(DPINST)

void DebugPrintfInit(void);
void DebugPrintfFini(void);

// The constructor of this will be called prior to DllMain and the destructor
// after DllMain, so we can be assured of having the logging code properly
// initialized and deinitialized for the life of the module.
struct _InitDbg
{
	_InitDbg() { DebugPrintfInit(); }
	~_InitDbg() { DebugPrintfFini(); }
} DbgInited;

//===============
// Debug  support
//===============

/*******************************************************************************
	This file contains support for the following types of logging:
		1. Logging to a VXD (Win9x only)
		2. Logging to a shared memory region
		3. Logging to the Debug Output
		4. Logging to a message box
		5. FUTURE: Logging to a file

	General:
	========

	Debug Logging and playback is designed to operate on both Win9x and
	Windows NT (Windows 2000).  A shared file is used to capture information
	and can be played back using dp8log.exe.

	Under NT you can use the 'dt' command of NTSD to dump structures.  For
	example:

		dt DIRECTPLAYOBJECT <some memory address>

	will show all of the members of the DIRECTPLAYOBJECT structure at the
	specified address.  Some features are available only in post-Win2k
	versions of NTSD which can be obtained at http://dbg.

	Logging:
	========

	Debug Logging is controlled by settings in the WIN.INI file, under
	the section heading [DirectPlay8].  There are several settings:

	debug=9

	controls the default debug level.  All messages, at or below that debug level
	are printed.  You can control logging by each component specified in the
	g_rgszSubCompName member by adding its name to the end of the 'debug' setting:

	debug.addr=9

	sets the logging level for the addressing subcomponent to 9, leaving all
	others at either their specified level or the level specified by 'debug'
	if there is no specific level specified.

	The second setting controls where the log is seen.  If not specified, all
	debug logs are sent through the standard DebugPrint and will appear in a
	debugger if it is attached.

	log=0 {no debug output}
	log=1 {spew to console only}
	log=2 {spew to shared memory log only}
	log=3 {spew to console and shared memory log}
	log=4 {spew to message box}

	This setting can also be divided by subcomponent, so:

	log=3
	log.protocol=2

	sends logs for the 'protocol' subcomponent to the shared memory log only, and
	all other logs to both locations.

	example win.ini...

	[DirectPlay8]
	Debug=7		; lots of spew
	log=2		; don't spew to debug window

	[DirectPlay8]
	Debug=0		; only fatal errors spewed to debug window

	Asserts:
	========
	Asserts are used to validate assumptions in the code.  For example
	if you know that the variable jojo should be > 700 and are depending
	on it in subsequent code, you SHOULD put an assert before the code
	that acts on that assumption.  The assert would look like:

	DNASSERT(jojo>700);

	Asserts generally will produce 3 lines of debug spew to highlight the
	breaking of the assumption.  You can add text to your asserts by ANDing:
	
	  DNASSERT(jojo>700 && "Jojo was too low");
	
	Will show the specified text when the assert occurs. For testing, you might
	want to set the system to break in on asserts.  This is done in the
	[DirectPlay8] section of WIN.INI by setting BreakOnAssert=TRUE:

	[DirectPlay8]
	Debug=0
	BreakOnAssert=1
	Verbose=1

	The Verbose setting enables logging of file, function, and line information.

	Debug Breaks:
	=============
	When something really severe happens and you want the system to break in
	so that you can debug it later, you should put a debug break in the code
	path.  Some people use the philosophy that all code paths must be
	verified by hand tracing each one in the debugger.  If you abide by this
	you should place a DEBUG_BREAK() in every code path and remove them
	from the source as you trace each.  When you have good coverage but
	some unhit paths (error conditions) you should force those paths in
	the debugger.

	Debug Logging to Shared Memory Region:
	======================================

	All processes will share the same memory region, and will log the specified amount
	of activity.  The log can be viewed with the DPLOG.EXE utility.

	Debug Logging to Debug Output:
	==============================
	This option uses OutputDebugString to log the specified amount of activity.

	Debug Logging to Message Box:
	==============================
	This option uses MessageBox to log the specified amount of activity.

==============================================================================*/

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

#define ASSERT_BUFFER_SIZE   8192
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_MESSAGE_LEVEL 0

#define PROF_SECT		_T("DirectPlay8")

DWORD g_dwMemLogNumEntries = DPLOG_DEFAULT_ENTRIES;		// Default Num entries for MEM log, settable in win.ini
DWORD g_dwMemLogLineSize = DPLOG_MAX_STRING;	// Default number of bytes per log entry

//
// Globals for shared memory based logging
//
#ifndef DPNBUILD_SINGLEPROCESS
HANDLE g_hMemLogFile = 0; // NOTE: This is 0 because CreateFileMapping returns 0 on failure
HANDLE g_hMemLogMutex = 0; // NOTE: This is 0 because CreateMutex returns 0 on failure
#endif // ! DPNBUILD_SINGLEPROCESS
PSHARED_LOG_FILE g_pMemLog = 0;

BOOL g_fMemLogInited = FALSE;

#ifndef DPNBUILD_SINGLEPROCESS
DWORD g_fAssertGrabMutex = FALSE;
#endif // ! DPNBUILD_SINGLEPROCESS

// Values for g_rgDestination
#define LOG_TO_DEBUG    1
#define LOG_TO_MEM      2
#define LOG_TO_MSGBOX   4

LPTSTR g_rgszSubCompName[] =
{
	_T("UNK"),			// DN_SUBCOMP_GLOBAL		0
	_T("CORE"),			// DN_SUBCOMP_CORE			1
	_T("ADDR"),			// DN_SUBCOMP_ADDR			2
	_T("LOBBY"),		// DN_SUBCOMP_LOBBY			3
	_T("PROTOCOL"),		// DN_SUBCOMP_PROTOCOL		4
	_T("VOICE"),		// DN_SUBCOMP_VOICE			5
	_T("DPNSVR"),		// DN_SUBCOMP_DPNSVR		6
	_T("WSOCK"),		// DN_SUBCOMP_WSOCK			7
	_T("MODEM"),		// DN_SUBCOMP_MODEM			8
	_T("COMMON"),		// DN_SUBCOMP_COMMON		9
	_T("NATHELP"),		// DN_SUBCOMP_NATHELP		10
	_T("TOOLS"),		// DN_SUBCOMP_TOOLS			11
	_T("THREADPOOL"),	// DN_SUBCOMP_THREADPOOL	12
	_T("BLUETOOTH"),	// DN_SUBCOMP_BLUETOOTH		13
	_T("MAX"),			// DN_SUBCOMP_MAX			14	// NOTE: this should never get used, but
														// is needed due to the way DebugPrintfInit
														// is written, since it reads one past the end.
};

#define MAX_SUBCOMPS (sizeof(g_rgszSubCompName)/sizeof(g_rgszSubCompName[0]) - 1)

UINT	g_rgLevel[MAX_SUBCOMPS]			= {0};
UINT	g_rgDestination[MAX_SUBCOMPS]	= {LOG_TO_DEBUG | LOG_TO_MEM};
UINT	g_rgBreakOnAssert[MAX_SUBCOMPS]	= {1};// if non-zero, causes DEBUG_BREAK on false asserts.

// if TRUE, file/line/module information is printed and logged.
DWORD	g_fLogFileAndLine = FALSE;	



// Create a shared file for logging information on the fly
// This support allows the current log to be dumped from the
// user mode DP8LOG.EXE application.  This is useful when debugging
// in MSSTUDIO or in NTSD.  When DP8LOG.EXE is invoked, note that
// the application will get halted until the log is completely dumped
// so it is best to dump the log to a file.

#undef DPF_MODNAME
#define DPF_MODNAME "InitMemLogString"
static BOOL InitMemLogString(VOID)
{
	if(!g_fMemLogInited)
	{
		BOOL fInitLogFile = TRUE;

#ifdef DPNBUILD_SINGLEPROCESS
		g_pMemLog = (PSHARED_LOG_FILE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)));
		if (!g_pMemLog)
		{
			return FALSE;
		}
#else // ! DPNBUILD_SINGLEPROCESS
		g_hMemLogFile = CreateFileMapping(INVALID_HANDLE_VALUE, DNGetNullDacl(), PAGE_READWRITE, 0, (DPLOG_HEADERSIZE + (DPLOG_ENTRYSIZE*g_dwMemLogNumEntries)), GLOBALIZE_STR _T(BASE_LOG_MEMFILENAME));
		if (!g_hMemLogFile)
		{
			return FALSE;
		}
		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			fInitLogFile = FALSE;
		}

		g_hMemLogMutex = CreateMutex(DNGetNullDacl(), FALSE, GLOBALIZE_STR _T(BASE_LOG_MUTEXNAME));
		if (!g_hMemLogMutex)
		{
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
		g_pMemLog = (PSHARED_LOG_FILE)MapViewOfFile(g_hMemLogFile, FILE_MAP_ALL_ACCESS,0,0,0);
		if (!g_pMemLog)
		{
			CloseHandle(g_hMemLogMutex);
			g_hMemLogMutex = 0;
			CloseHandle(g_hMemLogFile);
			g_hMemLogFile = 0;
			return FALSE;
		}
#endif // ! DPNBUILD_SINGLEPROCESS

		// NOTE: The above 3 functions do return NULL in the case of a failure,
		// not INVALID_HANDLE_VALUE
		if (fInitLogFile)
		{
			g_pMemLog->nEntries = g_dwMemLogNumEntries;
			g_pMemLog->cbLine   = g_dwMemLogLineSize;
			g_pMemLog->iWrite   = 0;
		}
		else
		{
			// This happens when someone before us has already created the mem log.  Could be a previous DPlay instance or TestNet.
			g_dwMemLogNumEntries = g_pMemLog->nEntries;
			g_dwMemLogLineSize = g_pMemLog->cbLine;
		}

		if (g_dwMemLogNumEntries && g_dwMemLogLineSize)
		{
			g_fMemLogInited = TRUE;
		}
	}
	return g_fMemLogInited;
}

// Log a string to a shared file.  This file can be dumped using the
// DPLOG.EXE utility.
//
// dwLength is in bytes and does not include the '\0'
//
void MemLogString(LPCTSTR str, size_t dwLength)
{
	PMEMLOG_ENTRY pEntry;
	size_t cbCopy;


	// If this isn't inited, InitMemLogString failed earlier
	if(!g_fMemLogInited)
	{
		return;
	}

#ifndef DPNBUILD_SINGLEPROCESS
	WaitForSingleObject(g_hMemLogMutex, INFINITE);
#endif // ! DPNBUILD_SINGLEPROCESS

	pEntry = (PMEMLOG_ENTRY)(((PUCHAR)(g_pMemLog + 1)) + (g_pMemLog->iWrite * (sizeof(MEMLOG_ENTRY) + g_dwMemLogLineSize)));
	g_pMemLog->iWrite = (g_pMemLog->iWrite + 1) % g_dwMemLogNumEntries;

#ifndef DPNBUILD_SINGLEPROCESS
	ReleaseMutex(g_hMemLogMutex);
#endif // ! DPNBUILD_SINGLEPROCESS

	pEntry->tLogged = GETTIMESTAMP();

	cbCopy = dwLength + sizeof(TCHAR);		// Add the terminating NULL
	if(cbCopy > g_dwMemLogLineSize)
	{
		cbCopy = g_dwMemLogLineSize;
	}
	memcpy(pEntry->str, str, cbCopy);
	pEntry->str[(cbCopy / sizeof(TCHAR)) - 2] = _T('\n');		// Ensure we always end with a return
	pEntry->str[(cbCopy / sizeof(TCHAR)) - 1] = _T('\0');		// Ensure we always NULL terminate
}

// DebugPrintfInit() - initialize DPF support.
void DebugPrintfInit()
{
	BOOL fUsingMemLog = FALSE;

	TCHAR szLevel[32] = {0};
	_tcscpy(szLevel, _T("debug"));

	TCHAR szDest[32] = {0};
	_tcscpy(szDest, _T("log"));

	TCHAR szBreak[32] = {0};
	_tcscpy(szBreak, _T("breakonassert"));

	// Loop through all the subcomps, and get the level and destination for each
	for (int iSubComp = 0; iSubComp < MAX_SUBCOMPS; iSubComp++)
	{
		// NOTE: The setting under "debug" sets the default and will be used if you
		// don't specify settings for each subcomp
		g_rgLevel[iSubComp] = DNGetProfileInt(PROF_SECT, szLevel, g_rgLevel[0]);
		g_rgDestination[iSubComp] = DNGetProfileInt(PROF_SECT, szDest, g_rgDestination[0]);
		g_rgBreakOnAssert[iSubComp] = DNGetProfileInt( PROF_SECT, szBreak, g_rgBreakOnAssert[0]);

		if (g_rgDestination[iSubComp] & LOG_TO_MEM)
		{
			fUsingMemLog = TRUE;
		}

		// Set up for the next subcomp
		_tcscpy(szLevel + 5, _T(".")); // 5 is strlen of "debug", we are building debug.addr, etc.
		_tcscpy(szLevel + 6, g_rgszSubCompName[iSubComp + 1]);

		_tcscpy(szDest + 3, _T(".")); // 3 is strlen of "log", we are building log.addr, etc.
		_tcscpy(szDest + 4, g_rgszSubCompName[iSubComp + 1]);

		_tcscpy(szBreak + 13, _T(".")); // 13 is strlen of "breakonassert", we are building breakonassert.addr, etc.
		_tcscpy(szBreak + 14, g_rgszSubCompName[iSubComp + 1]);
	}

	g_dwMemLogNumEntries = DNGetProfileInt( PROF_SECT, _T("MemLogEntries"), DPLOG_DEFAULT_ENTRIES);
	g_fLogFileAndLine = DNGetProfileInt( PROF_SECT, _T("Verbose"), 0);
#ifndef DPNBUILD_SINGLEPROCESS
	g_fAssertGrabMutex = DNGetProfileInt( PROF_SECT, _T("AssertGrabMutex"), 0);
#endif // ! DPNBUILD_SINGLEPROCESS

	if (fUsingMemLog)
	{
		// Open the shared log file
		InitMemLogString();	
	}
}

// DebugPrintfFini() - release resources used by DPF support.
void DebugPrintfFini()
{
	if(g_pMemLog)
	{
#ifdef DPNBUILD_SINGLEPROCESS
		HeapFree(GetProcessHeap(), 0, g_pMemLog);
#else // ! DPNBUILD_SINGLEPROCESS
		UnmapViewOfFile(g_pMemLog);
#endif // ! DPNBUILD_SINGLEPROCESS
		g_pMemLog = NULL;
	}
#ifndef DPNBUILD_SINGLEPROCESS
	if(g_hMemLogMutex)
	{
		CloseHandle(g_hMemLogMutex);
		g_hMemLogMutex = 0;
	}
	if(g_hMemLogFile)
	{
		CloseHandle(g_hMemLogFile);
		g_hMemLogFile = 0;
	}
#endif // ! DPNBUILD_SINGLEPROCESS
	g_fMemLogInited = FALSE;
}

void DebugPrintfX(LPCTSTR szFile, DWORD dwLine, LPCTSTR szModName, DWORD dwSubComp, DWORD dwDetail, ...)
{
	DNASSERT(dwSubComp < MAX_SUBCOMPS);

	if(g_rgLevel[dwSubComp] < dwDetail)
	{
		return;
	}
	
	TCHAR  cMsg[ ASSERT_BUFFER_SIZE ];
	va_list argptr;
	LPTSTR pszCursor = cMsg;

	va_start(argptr, dwDetail);


#ifdef UNICODE
	WCHAR szFormat[ASSERT_BUFFER_SIZE];
	LPSTR szaFormat;
	szaFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
	STR_jkAnsiToWide(szFormat, szaFormat, ASSERT_BUFFER_SIZE);
#else
	LPSTR szFormat;
	szFormat = (LPSTR) va_arg(argptr, DWORD_PTR);
#endif // UNICODE


	cMsg[0] = 0;

#ifdef WIN95
    TCHAR  *psz = NULL;
	CHAR  cTemp[ ASSERT_BUFFER_SIZE ];
		
    strcpy(cTemp, szFormat);                // Copy to a local string that we can modify.
	szFormat = cTemp;					    // Point szFormat at the local string

    while (psz = strstr(szFormat, "%p"))    // Look for each "%p".
       *(psz+1) = 'x';                      // Substitute 'x' for 'p'.  Don't try to expand
#endif // WIN95

	// Prints out / logs as:
	// 1. Verbose
	// subcomp:dwDetail:ProcessId:ThreadId:File:Function:Line:DebugString
	// e.g.
	// ADDR:2:0450:0378:(c:\somefile.cpp)BuildURLA(L25)Can you believe it?
	//
	// 2. Regular
	// subcomp:dwDetail:ProcessId:ThreadId:Function:DebugString

#ifndef DPNBUILD_SINGLEPROCESS
	pszCursor += wsprintf(pszCursor,_T("%s:%1d:%04x:%04x:"),g_rgszSubCompName[dwSubComp],dwDetail,GetCurrentProcessId(),GetCurrentThreadId());
#else
	pszCursor += wsprintf(pszCursor,_T("%s:%1d:%04x:"),g_rgszSubCompName[dwSubComp],dwDetail,GetCurrentThreadId());
#endif // ! DPNBUILD_SINGLEPROCESS

	if (g_fLogFileAndLine)
	{
		LPCTSTR c;

		int i = _tcslen(szFile);
		if (i < 25)
		{
			c = szFile;
		}
		else
		{
			c = szFile + i - 25;
		}

		pszCursor += wsprintf(pszCursor, _T("(%s)(L%d)"), c, dwLine);
	}

	pszCursor += wsprintf(pszCursor, _T("%s: "), szModName);

	pszCursor += wvsprintf(pszCursor, szFormat, argptr);

	_tcscpy(pszCursor, _T("\n"));
	pszCursor += _tcslen(pszCursor);

	if(g_rgDestination[dwSubComp] & LOG_TO_DEBUG)
	{
		// log to debugger output
		OutputDebugString(cMsg);
	}

	if(g_rgDestination[dwSubComp] & LOG_TO_MEM)
	{
		// log to shared file, pass length not including '\0'
		MemLogString(cMsg, ((PBYTE)pszCursor - (PBYTE)cMsg));
	}	

#ifndef _XBOX
	if(g_rgDestination[dwSubComp] & LOG_TO_MSGBOX)
	{
		// log to Message Box
		MessageBox(NULL, cMsg, _T("DirectPlay Log"), MB_OK);
	}
#endif // ! _XBOX

	va_end(argptr);

	return;
}


//
// NOTE: I don't want to get into error checking for buffer overflows when
// trying to issue an assertion failure message. So instead I just allocate
// a buffer that is "bug enough" (I know, I know...)
//

void _DNAssert( LPCTSTR szFile, DWORD dwLine, LPCTSTR szFnName, DWORD dwSubComp, LPCTSTR szCondition, DWORD dwLevel )
{
    TCHAR buffer[ASSERT_BUFFER_SIZE];


	// For level 1 we always print the message to the log, but we may not actually break.  For other levels
	// we either print and break or do neither.
	if (dwLevel <= g_rgBreakOnAssert[dwSubComp] || dwLevel == 1)
	{
		// Build the debug stream message
		wsprintf( buffer, _T("ASSERTION FAILED! File: %s Line: %d: %s"), szFile, dwLine, szCondition);

		// Actually issue the message. These messages are considered error level
		// so they all go out at error level priority.

		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, "%s", buffer );
		DebugPrintfX(szFile, dwLine, szFnName, dwSubComp, ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

		// Should we drop into the debugger?
		if(g_rgBreakOnAssert[dwSubComp])
		{
#ifndef DPNBUILD_SINGLEPROCESS
			// Don't let dpnsvr keep writing to the log
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				WaitForSingleObject(g_hMemLogMutex, INFINITE);
			}
#endif // ! DPNBUILD_SINGLEPROCESS

			// Into the debugger we go...
			DEBUG_BREAK();

#ifndef DPNBUILD_SINGLEPROCESS
			if (g_hMemLogMutex && g_fAssertGrabMutex)
			{
				ReleaseMutex(g_hMemLogMutex);
			}
#endif // ! DPNBUILD_SINGLEPROCESS
		}
	}
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\classbilink.h ===
/*==========================================================================
 *
 *  Copyright (C) 1998-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ClassBilink.h
 *  Content:	Class-based bilink
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	09/17/99	jtk		Derived from bilink.c
 *	08/15/00	masonb		Changed assert to DNASSERT and added DNASSERT(this)
 *
 ***************************************************************************/

#ifndef __CLASS_BILINK_H__
#define __CLASS_BILINK_H__

#include "dndbg.h"

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_COMMON

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	CONTAINING_OBJECT
#define CONTAINING_OBJECT(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (UINT_PTR)(&((type *)0)->field)))
#endif // CONTAINING_OBJECT

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function Prototypes
//**********************************************************************

//**********************************************************************
// Class definitions
//**********************************************************************

class	CBilink
{
public:
	CBilink(){};
	~CBilink(){};

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::Initialize"
	void	Initialize( void )
	{
		DNASSERT( this != NULL );

		m_pNext = this;
		m_pPrev = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::GetNext"
	CBilink	*GetNext( void ) const 
	{ 
		DNASSERT( this != NULL );

		return m_pNext; 
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::GetPrev"
	CBilink *GetPrev( void ) const 
	{ 
		DNASSERT( this != NULL );

		return m_pPrev; 
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::IsEmpty"
	BOOL	IsEmpty( void ) const
	{
		DNASSERT( this != NULL );
		DNASSERT( m_pNext != NULL );

		if ( ( m_pNext == m_pPrev ) &&
			 ( m_pNext == this ) )
		{
			return	TRUE;
		}

		return	FALSE;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::IsListMember"
	BOOL	IsListMember( const CBilink *const pList ) const
	{
		CBilink *	pTemp;


		DNASSERT( this != NULL );
		DNASSERT( pList != NULL );

		pTemp = pList->GetNext();
		while ( pTemp != pList )
		{
			if ( pTemp == this )
			{
				return	TRUE;
			}
			pTemp = pTemp->GetNext();
		}

		return	FALSE;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::InsertAfter"
	void	InsertAfter( CBilink* const pList )
	{
		DNASSERT( this != NULL );
		DNASSERT( pList->m_pNext != NULL );
		DNASSERT( pList->m_pPrev != NULL );
		DNASSERT( !IsListMember( pList ) );
		DNASSERT( IsEmpty() );

		m_pNext = pList->m_pNext;
		m_pPrev = pList;
		pList->m_pNext->m_pPrev = this;
		pList->m_pNext = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::InsertBefore"
	void	InsertBefore( CBilink* const pList )
	{
		DNASSERT( this != NULL );
		DNASSERT( pList->m_pNext != NULL );
		DNASSERT( pList->m_pPrev != NULL );
		DNASSERT( !IsListMember( pList ) );
		DNASSERT( IsEmpty() );

		m_pNext = pList;
		m_pPrev = pList->m_pPrev;
		pList->m_pPrev->m_pNext = this;
		pList->m_pPrev = this;
	}

	#undef DPF_MODNAME
	#define DPF_MODNAME "CBilink::RemoveFromList"
	void	RemoveFromList( void )
	{
		DNASSERT( this != NULL );
		DNASSERT( m_pNext != NULL );
		DNASSERT( m_pPrev != NULL );
		DNASSERT( m_pNext->m_pPrev == this );
		DNASSERT( m_pPrev->m_pNext == this );

		m_pNext->m_pPrev = m_pPrev;
		m_pPrev->m_pNext = m_pNext;
		Initialize();
	}

private:
	CBilink	*m_pNext;
	CBilink	*m_pPrev;
};

#undef DPF_MODNAME
#undef DPF_SUBCOMP

#endif	// __CLASS_BILINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\creg.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		creg.cpp
 *  Content:	
 *			This module contains the implementation of the CRegistry class.
 *			For a class description, see creg.h
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/16/99	rodtoll	Created
 *	08/18/99	rodtoll	Added Register/UnRegister that can be used to
 *						allow COM objects to register themselves.
 *	08/25/99	rodtoll	Updated to provide read/write of binary (blob) data
 *	10/05/99	rodtoll	Added DPF_MODNAMEs
 *	10/07/99	rodtoll	Updated to work in Unicode
 *	10/08/99	rodtoll	Fixes to DeleteKey / Reg/UnReg for Win9X
 *	10/15/99	rodtoll	Plugged some memory leaks
 *	10/27/99	pnewson	added Open() call that takes a GUID
 *	01/18/00	mjn		Added GetMaxKeyLen function
 *	01/24/00	mjn		Added GetValueSize function
 * 	01/24/00	rodtoll	Fixed error handling for ReadString (Unicode version)
 * 	04/21/2000 	rodtoll Bug #32889 - Does not run on Win2k on non-admin account 
 *             	rodtoll Bug #32952 - Does not run on Win95 GOLD w/o IE4 -- modified
 *                     	to allow reads of REG_BINARY when expecting REG_DWORD
 *	05/02/00	mjn		Changed CRegistry::Open() to use KEY_READ when Create set to FALSE
 *  06/08/00    rmt     Updated to use common string utils
 *  07/06/00	rmt		Modified to allow seperate read/write parameter
 * 	07/09/2000	rodtoll	Added signature bytes 
 *  07/21/00	rmt		Fixed a memory leak
 *  08/08/2000	rmt		Bug #41736 - AV in call to lstrcpy by COM_GetDllName 
 *	08/28/2000	masonb	Voice Merge: Modified platform checks to use osind.cpp layer
 *  08/30/2000	rodtoll	Bug #171822 - PREFIX Bug
 *  04/13/2001	VanceO	Moved granting registry permissions into common, and
 *						added DeleteValue and EnumValues.
 *  06/19/2001  RichGr  DX8.0 added special security rights for "everyone" - remove them if
 *                      they exist with new RemoveAllAccessSecurityPermissions() method.
 ***************************************************************************/

#include "dncmni.h"


#ifndef DPNBUILD_NOREGISTRY


#ifdef WINNT

// Security function prototypes

typedef BOOL (*PALLOCATEANDINITIALIZESID)(
  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, // authority
  BYTE nSubAuthorityCount,                        // count of subauthorities
  DWORD dwSubAuthority0,                          // subauthority 0
  DWORD dwSubAuthority1,                          // subauthority 1
  DWORD dwSubAuthority2,                          // subauthority 2
  DWORD dwSubAuthority3,                          // subauthority 3
  DWORD dwSubAuthority4,                          // subauthority 4
  DWORD dwSubAuthority5,                          // subauthority 5
  DWORD dwSubAuthority6,                          // subauthority 6
  DWORD dwSubAuthority7,                          // subauthority 7
  PSID *pSid                                      // SID
);

typedef VOID (*PBUILDTRUSTEEWITHSID)(
  PTRUSTEE pTrustee,  // structure
  PSID pSid           // trustee name
);

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

typedef DWORD (*PSETSECURITYINFO)(
  HANDLE handle,                     // handle to object
  SE_OBJECT_TYPE ObjectType,         // object type
  SECURITY_INFORMATION SecurityInfo, // buffer
  PSID psidOwner,                    // new owner SID
  PSID psidGroup,                    // new primary group SID
  PACL pDacl,                        // new DACL
  PACL pSacl                         // new SACL
);

typedef PVOID (*PFREESID)(
  PSID pSid   // SID to free
);

#endif // WINNT


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::CRegistry"
// CRegistry Constructor
//
// This is the default constructor for the registry class.  It
// is used to construct a registry object which has not yet
// opened a handle to the registry.  Open must be called before
// this object can be used.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::CRegistry( ): m_isOpen(FALSE), m_dwSignature(VSIG_CREGISTRY)
{
}

// CRegistry Destructor
//
// This is the destructor for the class, and will close the connection
// to the registry if this object has one open.
//
// Parameters:
// N/A
//
// Returns:
// N/A
//
CRegistry::~CRegistry() 
{
	if( m_isOpen ) 
	{
		Close();
	}

	m_dwSignature = VSIG_CREGISTRY_FREE;
}

// DeleteSubKey
//
// This function causes the key specified by the string equivalent of
// the pGuidName parameter to be deleted from the point in the registry
// this object is rooted at, if the key exists.  If the object does not
// have an open connection to the registry, or the keyName is not specified
//
// Parmaters:
// const GUID *pGuidName - GUID whose equivalent string needs to be deleted
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const GUID *pGuidName )
{

   	WCHAR wszGuidString[GUID_STRING_LEN];
	
	DNASSERT( pGuidName != NULL );

	// convert the guid to a string
	if(!StringFromGUID2(*pGuidName, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	return DeleteSubKey(wszGuidString);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteSubKey"
// DeleteSubKey
//
// This function causes the key specified by the keyName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the key exists.  If the object does not have an open connection
// to the registry, or the keyName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteSubKey( const LPCWSTR keyName ) 
{

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG	retValue;
	
#ifdef UNICODE
	retValue = RegDeleteKeyW( m_regHandle, keyName );
#else
	LPSTR lpstrKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
	else
	{
		retValue = RegDeleteKeyA( m_regHandle, lpstrKeyName );

		DNFree(lpstrKeyName);
	}
#endif // UNICODE
	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::DeleteValue"
// DeleteValue
//
// This function causes the value specified by the valueName parameter
// to be deleted from the point in the registry this object is rooted
// at, if the value exists.  If the object does not have an open connection
// to the registry, or the valueName is not specified, FALSE is returned
//
// Parmaters:
// const TCHAR *keyName - key name to delete
//
// Returns:
// BOOL - returns TRUE on success, FALSE on failure
//
BOOL CRegistry::DeleteValue( const LPCWSTR valueName ) 
{

	if( valueName == NULL || !IsOpen() ) return FALSE;

	LONG	retValue;
	
#ifdef UNICODE
	retValue = RegDeleteValueW( m_regHandle, valueName );
#else
	LPSTR lpstrValueName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrValueName, valueName ) ) )
	{
		return FALSE;
	}
	else
	{
		retValue = RegDeleteValueA( m_regHandle, lpstrValueName );

		DNFree(lpstrValueName);
	}
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const TCHAR *path - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const LPCWSTR pathName, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) 
{

	DWORD	dwResult;	// Temp used in call to RegXXXX
	LONG	result;		// used to store results

	if( pathName == NULL )
		return FALSE;

	// If there is an open connection, close it.
	if( m_isOpen ) 
	{
		Close();
	}

	m_fReadOnly = fReadOnly;

#ifdef UNICODE
	// Create or open the key based on create parameter
	if( create ) 
	{
		result = RegCreateKeyExW( branch, pathName, 0, NULL, REG_OPTION_NON_VOLATILE, (fCustomSAM) ? samCustom : KEY_ALL_ACCESS,
				                 NULL, &m_regHandle, &dwResult );
	} 
	else 
	{
		result = RegOpenKeyExW( branch, pathName, 0, (fReadOnly) ? KEY_READ : ((fCustomSAM) ? samCustom : KEY_ALL_ACCESS), &m_regHandle );
	}
#else
	LPSTR lpszKeyName;

	if( STR_AllocAndConvertToANSI( &lpszKeyName, pathName ) == S_OK && pathName )
	{
		if( create ) 
		{
			result = RegCreateKeyExA( branch, lpszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
					                 NULL, &m_regHandle, &dwResult );
		} 
		else 
		{
			result = RegOpenKeyExA( branch, lpszKeyName, 0, (fReadOnly) ? KEY_READ : KEY_ALL_ACCESS, &m_regHandle );
		}

		DNFree(lpszKeyName);
	}
	else
	{
		return FALSE;
	}
#endif // UNICODE

	// If succesful, initialize object, otherwise set it to
	// not open state.
	if( result == ERROR_SUCCESS ) 
	{
		m_isOpen	 = TRUE;
		m_baseHandle = branch;
		return TRUE;

	} 
	else 
	{
		m_isOpen = FALSE;
		return FALSE;
	}

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Open"
// Open
//
// This function opens a connection to the registry in the branch
// specified by branch with the path specified by pathName.  If
// the path doesn't exist in the registry it will be created if
// the create parameters is set to true, otherwise the call will
// fail.
//
// In this version of the function, the path is specified as
// a guid instead of a string. The function will attempt to open
// a key with a name in the form "{CB4961DB-D2FA-43f3-942A-991D9294DDBB}"
// that corresponds to the guid as you would expect.
//
// If this object already has an open connection to the registry
// the previous connection will be closed before this one is
// attempted.
//
// Parameters:
// HKEY branch - A handle to a registry location where the open
//               will be rooted.  E.g. HKEY_LOCAL_MACHINE
// const LPGUID lpguid - The path relative to the root specified by
//                    branch where the registry connection will
//                    be opened. See comment above.
// BOOL create - Settings this parameter conrols how this function
//               handles opens on paths which don't exists.  If set
//               to TRUE the path will be created, if set to FALSE
//               the function will fail if the path doesn't exist.
//
// Returns:
// BOOL - TRUE on success, FALSE on failure.
//
BOOL CRegistry::Open( HKEY branch, const GUID* lpguid, BOOL fReadOnly, BOOL create, BOOL fCustomSAM, REGSAM samCustom ) 
{
	WCHAR wszGuidString[GUID_STRING_LEN];
	
	DNASSERT( lpguid != NULL );

	// convert the guid to a string
	if (!StringFromGUID2(*lpguid, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	return Open(branch, wszGuidString, fReadOnly, create, fCustomSAM, samCustom);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Close"
// Close
//
// This function will close an open connection to the registry
// if this object has one.  Otherwise it does nothing.
//
// Parameters:
// N/A
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.  If the object
//        is not open it will return TRUE.
//
BOOL CRegistry::Close() 
{

	LONG retValue;

	if( m_isOpen ) 
	{
		retValue = RegCloseKey( m_regHandle );
        if( retValue == ERROR_SUCCESS )
        {
            m_isOpen = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
	} 
	else 
	{
		return TRUE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumKeys"
// EnumKeys
//
// This function can be used to enumerate the keys at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the keys you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current key in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumKeys( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
#ifdef UNICODE
	wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	FILETIME tmpTime;

	if( RegEnumKeyExW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen  )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    lstrcpyW( lpwStrName, buffer );

		*lpdwStringLen = bufferSize+1;
	    
	    return TRUE;
	}	
#else
	char buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;
	FILETIME tmpTime;

	if( RegEnumKeyExA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, &tmpTime ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    {
	    	return FALSE;
	    }
	    else
	    {
			*lpdwStringLen = bufferSize+1;
	    	return TRUE;
	    }
	}	
#endif // UNICODE
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::EnumValues"
// EnumValues
//
// This function can be used to enumerate the values at the point
// in the registry rooted at the root this object was opened
// with, at the path specified when opening the object.
//
// To properly enumerate the values you should pass 0 as the index on
// the first call, and increment the index parameter by one on each
// call.  You can stop enumerating when the function returns FALSE.
//
// Parameters:
// LPWSTR lpwStrName - The current value in the enumeration will be returned
//                 in this string.  Unless the enumeration fails or
//                 ended at which case this parameter won't be touched.
//
// LPDWORD lpdwStringLen - pointer to length of string buffer, or place to
//						to store size required.
//
// DWORD index - The current enum index.  See above for details.
//
// Returns:
// BOOL - FALSE when enumeration is done or on error, TRUE otherwise.
//
BOOL CRegistry::EnumValues( LPWSTR lpwStrName, LPDWORD lpdwStringLen, DWORD index )
{
#ifdef UNICODE
	wchar_t buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	if( RegEnumValueW( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen  )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    lstrcpyW( lpwStrName, buffer );

		*lpdwStringLen = bufferSize+1;
	    
	    return TRUE;
	}	
#else
	char buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD   bufferSize = MAX_REGISTRY_STRING_SIZE;

	if( RegEnumValueA( m_regHandle, index, buffer, &bufferSize, NULL, NULL, NULL, NULL ) != ERROR_SUCCESS )
	{
	    return FALSE;
	}
	else
	{
	    if( bufferSize+1 > *lpdwStringLen )
	    {
	    	*lpdwStringLen = bufferSize+1;
	    	return FALSE;
	    }

	    if( FAILED( STR_jkAnsiToWide( lpwStrName, buffer, *lpdwStringLen ) ) )
	    {
	    	return FALSE;
	    }
	    else
	    {
			*lpdwStringLen = bufferSize+1;
	    	return TRUE;
	    }
	}	
#endif // UNICODE
}


// This comment documents ALL of the Read<Data Type> functions which
// follow.
//
// CRegistry Read<Data Type> Functions
//
// The set of ReadXXXXX functions for the CRegistry class are
// responsible for reading <data type> type data from the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to read
// <datatype> & - A reference to the specific data type where
//				  the data will be placed on a succesful read.
//                This parameter will be unaffected if the read
//                fails.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//


// This comment documents ALL of the Write<Data Type> functions which
// follow.
//
// CRegistry Write<Data Type> Functions
//
// The set of Write<Data Type> functions for the CRegistry class are
// responsible for writing <data type> type data to the registry.
// The object must have an open connection to the registry before
// any of these functions may be used.  A connection to the registry
// can be made with the Open call or the constructors.
//
// Parameters:
// const TCHAR *keyName - The keyname of the data you wish to write
// <datatype> & - A reference to the specific data type which
//                contains the data to be written to the registry.
//
// Returns:
// BOOL - Returns TRUE on success, FALSE on failure.
//
#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteString"
// WriteString
//
// Writes Strings's to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteString( LPCWSTR keyName, const LPCWSTR lpwstrValue )
{

	LONG		retValue;
	
	if( keyName == NULL || !IsOpen() || lpwstrValue == NULL ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) lpwstrValue, (lstrlenW( lpwstrValue )+1)*sizeof(wchar_t) );	
#else
	LPSTR lpstrKeyName;
	LPSTR lpstrValue;
	
	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrValue, lpwstrValue ) ) )
	{
		DNFree(lpstrKeyName);
		return FALSE;
	}
	
	retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrValue, lstrlenA( lpstrValue )+1 );

	DNFree(lpstrKeyName);
	DNFree(lpstrValue);
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);

}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadString"
// ReadString
//
// Reads CString's from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadString( const LPCWSTR keyName, LPWSTR lpwstrValue, LPDWORD lpdwLength )
{
	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG		retValue;
	DWORD		tmpSize;
	DWORD		tmpType;	

#ifdef UNICODE
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	tmpSize = MAX_REGISTRY_STRING_SIZE*sizeof(wchar_t);
	
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}

	if( (tmpSize/2) > *lpdwLength || !lpwstrValue )
	{
		*lpdwLength = (tmpSize/2);
		return FALSE;
	}

	lstrcpyW( lpwstrValue, buffer );

	*lpdwLength = (tmpSize/2);

	return TRUE;
#else
	LPSTR lpstrKeyName;
	char buffer[MAX_REGISTRY_STRING_SIZE];
	tmpSize = MAX_REGISTRY_STRING_SIZE;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
		
	retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, &tmpType, (unsigned char *) &buffer[0], &tmpSize );
	if (retValue != ERROR_SUCCESS)
	{
		DNFree(lpstrKeyName);
		return FALSE;
	}

	DNFree(lpstrKeyName);

	if( tmpSize > *lpdwLength || !lpwstrValue )
	{
		*lpdwLength = tmpSize;
		return FALSE;
	}

	if( FAILED( STR_jkAnsiToWide( lpwstrValue, buffer, *lpdwLength ) ) )
	{
		return FALSE;
	}

	*lpdwLength = tmpSize;	

	if( retValue == ERROR_SUCCESS && tmpType == REG_SZ ) 
	{
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
#endif // UNICODE
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteGUID"
// WriteGUID
//
// Writes GUID's to the registry, see block comment above
// for details.  The GUID is written in the format it is usually
// displayed.  (But without the '{''s).
//
BOOL CRegistry::WriteGUID( LPCWSTR keyName, const GUID &guid )
{
	LONG retValue;
	WCHAR wszGuidString[GUID_STRING_LEN];

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

	if (!StringFromGUID2(guid, wszGuidString, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_SZ, (const unsigned char *) wszGuidString, (lstrlenW( wszGuidString )+1)*sizeof(wchar_t) );
#else
	HRESULT hr;
	LPSTR lpstrKeyName;
	LPSTR lpstrKeyValue;

	hr = STR_AllocAndConvertToANSI( &lpstrKeyName, keyName );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "STR_AllocAndConvertToANSI failed, code: 0x%08x", hr);
		return FALSE;
	}
	
	hr = STR_AllocAndConvertToANSI( &lpstrKeyValue, wszGuidString );
	if (FAILED(hr))
	{
		DPFX(DPFPREP, 0, "STR_AllocAndConvertToANSI failed, code: 0x%08x", hr);
		DNFree(lpstrKeyName);
		return FALSE;
	}

	retValue = RegSetValueExA( m_regHandle, lpstrKeyName, 0, REG_SZ, (const unsigned char *) lpstrKeyValue, lstrlenA( lpstrKeyValue )+1);

	DNFree(lpstrKeyName);
	DNFree(lpstrKeyValue);
#endif // UNICODE
	
	if( retValue == ERROR_SUCCESS )
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadGUID"
// ReadGUID
//
// Reads GUID's from the registry, see block comment above
// for details.  The GUID must be stored in the format written by
// the WriteGUID function or it will not be read correctly.
//
BOOL CRegistry::ReadGUID( LPCWSTR keyName, GUID* pguid )
{
	wchar_t		buffer[MAX_REGISTRY_STRING_SIZE];
	DWORD		dwLength = MAX_REGISTRY_STRING_SIZE;
    HRESULT hr;

    if( !ReadString( keyName, buffer, &dwLength ) )
    {
        return FALSE;
    }
    else
    {
    	hr = CLSIDFromString(buffer, pguid);
    	if (FAILED(hr))
    	{
    		DPFX(DPFPREP, 0, "CLSIDFromString failed, code: 0x%08x", hr);
    		return FALSE;
    	}
    	return TRUE;
    }
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteDWORD"
// WriteDWORD
//
// Writes DWORDS to the registry, see block comment above
// for details.
//
BOOL CRegistry::WriteDWORD( LPCWSTR keyName, DWORD value ) 
{

	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );		
#else
	LPSTR lpszKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_DWORD, (const unsigned char *) &value, sizeof( DWORD ) );

	DNFree(lpszKeyName);
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}



#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadDWORD"
// ReadDWORD
//
// Reads DWORDS from the registry, see block comment above
// for details.
//
BOOL CRegistry::ReadDWORD( LPCWSTR keyName, DWORD* presult ) 
{

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	LONG		retValue;
	DWORD		tmpValue;
	DWORD		tmpType;
	DWORD		tmpSize;

	tmpSize = sizeof( DWORD );

#ifdef UNICODE
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
#else
	LPSTR lpszKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, (unsigned char *) &tmpValue, &tmpSize );
	
	DNFree(lpszKeyName);
#endif // UNICODE

	if( retValue == ERROR_SUCCESS && (tmpType == REG_DWORD || tmpType == REG_BINARY) && tmpSize == sizeof(DWORD) ) 
	{
		*presult = tmpValue;
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}

#ifndef DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::Register"
BOOL CRegistry::Register( LPCWSTR lpszProgID, const LPCWSTR lpszDesc, const LPCWSTR lpszProgName, const GUID* pguidCLSID, LPCWSTR lpszVerIndProgID )
{
	CRegistry core;

	DNASSERT( lpszDesc != NULL );
	DNASSERT( lpszProgID != NULL );

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[GUID_STRING_LEN];
    wchar_t lpszKeyName[_MAX_PATH];

	// convert the guid to a string
	if (!StringFromGUID2(*pguidCLSID, lpszGUID, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
		DPFX(DPFPREP,  0, "Unable to open/create registry key \"%ls\"", lpszKeyName );
		return FALSE;
    }

    core.WriteString( L"", lpszDesc );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\InProcServer32 section
    swprintf( lpszKeyName, L"CLSID\\%s\\InProcServer32", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create registry key \"%ls\"", lpszKeyName );
    	return FALSE;
    }
    core.WriteString( L"", lpszProgName );
    core.WriteString( L"ThreadingModel", L"Both" );
    core.Close();

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\VersionIndependentProgID section
    if( lpszVerIndProgID != NULL )
    {
	    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	    {
	    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%ls\"", lpszKeyName );
	    	return FALSE;
	    }
    
	    core.WriteString( L"", lpszVerIndProgID );
	    core.Close();
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID}\ProgID section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

    if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
    {
    	DPFX(DPFPREP,  0, "Unable to open/create verind registry key \"%ls\"", lpszKeyName );
    	return FALSE;
    }

    core.WriteString( L"", lpszProgID );
    core.Close();

	// Write The VersionIND ProgID
	
	if( lpszVerIndProgID != NULL )
	{
		if( !core.Open( HKEY_CLASSES_ROOT, lpszVerIndProgID, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszVerIndProgID );
		}
		else
		{
			core.WriteString( L"", lpszDesc );
			core.Close();			
		}

		swprintf( lpszKeyName, L"%s\\CLSID", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszGUID );
			core.Close();
		}

		swprintf( lpszKeyName, L"%s\\CurVer", lpszVerIndProgID );

		if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
		{
			DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
		}
		else
		{
			core.WriteString( L"", lpszProgID );
			core.Close();
		}		
	}

	if( !core.Open( HKEY_CLASSES_ROOT, lpszProgID, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszDesc );
		core.Close();
	}
	
	swprintf( lpszKeyName, L"%s\\CLSID", lpszProgID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, TRUE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open/create reg key \"%ls\"", lpszKeyName );
	}
	else
	{
		core.WriteString( L"", lpszGUID );
		core.Close();
	}

	return TRUE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::UnRegister"
BOOL CRegistry::UnRegister( const GUID* pguidCLSID )
{
	CRegistry core, cregClasses, cregSub;

	// Build a string representation of the GUID from the GUID
    wchar_t lpszGUID[GUID_STRING_LEN];
    wchar_t lpszKeyName[_MAX_PATH];
    wchar_t szProgID[MAX_REGISTRY_STRING_SIZE];
    wchar_t szVerIndProgID[MAX_REGISTRY_STRING_SIZE];
    DWORD dwSize = MAX_REGISTRY_STRING_SIZE;

	// convert the guid to a string
	if (!StringFromGUID2(*pguidCLSID, lpszGUID, GUID_STRING_LEN))
	{
		DPFX(DPFPREP, 0, "StringFromGUID2 failed");
		return FALSE;
	}

	if( !cregClasses.Open( HKEY_CLASSES_ROOT, L"", FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open HKEY_CLASSES_ROOT" );
		return FALSE;
	}

	// Write the HKEY_CLASSES_ROOT\CLSID\{GUID} section
    swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%ls\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;	

    if( core.ReadString( L"", szProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szProgID );
    	
    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	if( !cregClasses.DeleteSubKey( szProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete HKEY_CLASSES_ROOT/ProgID" );

    		return FALSE;
    	}
    }

	core.Close();

    swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !core.Open( HKEY_CLASSES_ROOT, lpszKeyName, FALSE, FALSE ) )
	{
		DPFX(DPFPREP,  0, "Unable to open \"%ls\"", lpszKeyName );
		return FALSE;
	}

	dwSize = MAX_REGISTRY_STRING_SIZE;
	
    if( core.ReadString( L"", szVerIndProgID, &dwSize ) )
    {
    	swprintf( lpszKeyName, L"%s\\CLSID", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}

    	swprintf( lpszKeyName, L"%s\\CurVer", szVerIndProgID );

    	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
    		return FALSE;
    	}
    	
    	
    	if( !cregClasses.DeleteSubKey( szVerIndProgID ) )
    	{
    		DPFX(DPFPREP,  0, "Unable to delete \"HKEY_CLASSES_ROOT/%ls\"", szVerIndProgID);

    		return FALSE;
    	}
    }

    core.Close();

	swprintf( lpszKeyName, L"CLSID\\%s\\InprocServer32", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\ProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	
	
	swprintf( lpszKeyName, L"CLSID\\%s\\VersionIndependentProgID", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}	

	swprintf( lpszKeyName, L"CLSID\\%s", lpszGUID );

	if( !cregClasses.DeleteSubKey( lpszKeyName ) )
	{
		DPFX(DPFPREP,  0, "Unable to delete \"%ls\"", lpszKeyName );
		return FALSE;	
	}

    return TRUE;
}

#endif // !DPNBUILD_NOCOMREGISTER

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::ReadBlob"
BOOL CRegistry::ReadBlob( LPCWSTR keyName, LPBYTE lpbBuffer, LPDWORD lpdwSize )
{
	if( keyName == NULL || !IsOpen() ) return FALSE;

	LONG		retValue;
	DWORD		tmpType;

#ifdef UNICODE
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &tmpType, lpbBuffer, lpdwSize );	
#else
	LPSTR lpszKeyName;
		
	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
	{
		return FALSE;
	}

	retValue = RegQueryValueExA( m_regHandle, lpszKeyName, 0, &tmpType, lpbBuffer, lpdwSize );

	DNFree(lpszKeyName);
#endif // UNICODE
	
	if( retValue == ERROR_SUCCESS && tmpType == REG_BINARY ) 
	{
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::WriteBlob"
BOOL CRegistry::WriteBlob( LPCWSTR keyName, const BYTE* const lpbBuffer, DWORD dwSize )
{
	LONG		retValue;

	if( keyName == NULL || !IsOpen() ) 
	{
		return FALSE;
	}

	if( m_fReadOnly )
	{
	    DPFX(DPFPREP, 0, "Attempt to Write to read-only CRegistry key");
	    return FALSE;
	}

#ifdef UNICODE
	retValue = RegSetValueExW( m_regHandle, keyName, 0, REG_BINARY, lpbBuffer, dwSize );
#else
	LPSTR lpszKeyName;
	
	if( FAILED( STR_AllocAndConvertToANSI( &lpszKeyName, keyName ) ) )
		return FALSE;

	retValue = RegSetValueExA( m_regHandle, lpszKeyName, 0, REG_BINARY, lpbBuffer, dwSize );
	
	DNFree(lpszKeyName);	
#endif // UNICODE

	return (retValue == ERROR_SUCCESS);
}

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetMaxKeyLen"
BOOL CRegistry::GetMaxKeyLen( DWORD* pdwMaxKeyLen )
{
	LONG	retVal;

#ifdef UNICODE
	retVal = RegQueryInfoKeyW( m_regHandle,NULL,NULL,NULL,NULL,pdwMaxKeyLen,
			NULL,NULL,NULL,NULL,NULL,NULL);
#else
	retVal = RegQueryInfoKeyA( m_regHandle,NULL,NULL,NULL,NULL,pdwMaxKeyLen,
			NULL,NULL,NULL,NULL,NULL,NULL);
#endif // UNICODE

	return (retVal == ERROR_SUCCESS);
}


#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GetValueLength"
// GetValueLength
//
// Determines the length of a particular key value
//
BOOL CRegistry::GetValueLength( const LPCWSTR keyName, DWORD *const pdwValueLength )
{
	LONG		retValue;
	DWORD		tmpLength;

	if ( keyName == NULL || pdwValueLength == NULL || !IsOpen() )
	{
		return FALSE;
	}

#ifdef UNICODE
	DWORD	dwType;
		
	retValue = RegQueryValueExW( m_regHandle, keyName, 0, &dwType, NULL, &tmpLength );
	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}

	//
	// if this is a string, we need to compensate for WCHAR characters being
	// returned
	//
	if ( dwType == REG_SZ )
	{
		tmpLength /= sizeof( WCHAR );
	}
#else
	LPSTR lpstrKeyName;

	if( FAILED( STR_AllocAndConvertToANSI( &lpstrKeyName, keyName ) ) )
	{
		return FALSE;
	}
		
	retValue = RegQueryValueExA( m_regHandle, lpstrKeyName, 0, NULL, NULL, &tmpLength );

	DNFree(lpstrKeyName);	

	if (retValue != ERROR_SUCCESS)
	{
		return FALSE;
	}
#endif // UNICODE

	*pdwValueLength = tmpLength;

	return TRUE;
}


#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::GrantAllAccessSecurityPermissions"
// GrantAllAccessSecurityPermissions
//
// Gives the given key all access for everyone rights
//
// Taken from hresMumbleKeyEx in diregutl.c in the dinput tree.
//
BOOL CRegistry::GrantAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibrary( _T("advapi32.dll") );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    // Describe the access we want to create the key with
    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
    ExplicitAccess.grfAccessPermissions = ((KEY_ALL_ACCESS & ~WRITE_DAC) & ~WRITE_OWNER);
    									/*KEY_QUERY_VALUE | KEY_SET_VALUE 
                                        | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS
                                        | KEY_NOTIFY | KEY_CREATE_LINK
                                        | DELETE | READ_CONTROL; */
    ExplicitAccess.grfAccessMode = SET_ACCESS;      // discard any existing AC info
    ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}


#endif // WINNT

#ifdef WINNT

#undef DPF_MODNAME
#define DPF_MODNAME "CRegistry::RemoveAllAccessSecurityPermissions"
// RemoveAllAccessSecurityPermissions
//
// Removes "all access for everyone" rights from the specified key.
// This is identical to GrantAllAccessSecurityPermissions(), except that
// now we REVOKE_ACCESS instead of SET_ACCESS, and we don't have to fill
// out the rest of the EXPLICIT_ACCESS struct.
//
//
BOOL CRegistry::RemoveAllAccessSecurityPermissions()
{
	BOOL						fResult = FALSE;
	HRESULT						hr;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibrary( _T("advapi32.dll") );

	if( !hModuleADVAPI32 )
	{
		DPFX(DPFPREP,  0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = reinterpret_cast<PFREESID>( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = reinterpret_cast<PSETSECURITYINFO>( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = reinterpret_cast<PBUILDTRUSTEEWITHSID>( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = reinterpret_cast<PALLOCATEANDINITIALIZESID>( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPFX(DPFPREP,  0, "Failed loading entry points" );
		goto EXIT;
	}

    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
	ExplicitAccess.grfAccessMode = REVOKE_ACCESS;		//Remove any existing ACEs for the specified trustee

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,	// trustee is "Everyone"
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( m_regHandle, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPFX(DPFPREP,  0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
			else
			{
				fResult = TRUE;
			}
		} 
		else
		{
			DPFX(DPFPREP,  0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPFX(DPFPREP,  0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return fResult;
}

#endif // WINNT


#endif // ! DPNBUILD_NOREGISTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\handletracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       HandleTracking.cpp
 *  Content:    Handle Tracking debug logic
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/31/2001	masonb	Created
 *
 *
 ***************************************************************************/

#include "dncmni.h"


#ifdef DBG

CBilink g_blHandles;
#ifndef DPNBUILD_ONLYONETHREAD
DNCRITICAL_SECTION g_HandleLock;
#endif // !DPNBUILD_ONLYONETHREAD

#define IsValidHandle(x) \
	(x != NULL && x != INVALID_HANDLE_VALUE && \
	(x->type == TypeEvent || \
	 x->type == TypeMutex || \
	 x->type == TypeSemaphore || \
	 x->type == TypeFile || \
	 x->type == TypeFileMap || \
	 x->type == TypeThread || \
	 x->type == TypeProcess || \
	 x->type == TypeSpecial))

BOOL DNHandleTrackInitialize()
{
	g_blHandles.Initialize();
	return DNInitializeCriticalSection(&g_HandleLock);
}

VOID DNHandleTrackDeinitialize()
{
	DNDeleteCriticalSection(&g_HandleLock);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNHandleTrackDumpLeaks"
BOOL DNHandleTrackDumpLeaks()
{
	BOOL fLeaked = FALSE;

	DNEnterCriticalSection(&g_HandleLock);
	while(!g_blHandles.IsEmpty())
	{
		DNHANDLE dnh = CONTAINING_RECORD(g_blHandles.GetNext(), TRACKED_HANDLE, blHandle);
		dnh->blHandle.RemoveFromList();

		fLeaked = TRUE;

		// Dump dnh details
		switch(dnh->type)
		{
		case TypeEvent:
			DPFX(DPFPREP, 0, "Event leaked %p", dnh->handle);
			break;
		case TypeMutex:
			DPFX(DPFPREP, 0, "Mutex leaked %p", dnh->handle);
			break;
		case TypeSemaphore:
			DPFX(DPFPREP, 0, "Semaphore leaked %p", dnh->handle);
			break;
		case TypeFile:
			DPFX(DPFPREP, 0, "File leaked %p", dnh->handle);
			break;
#ifndef DPNBUILD_SINGLEPROCESS
		case TypeFileMap:
			DPFX(DPFPREP, 0, "FileMapping leaked %p", dnh->handle);
			break;
#endif // ! DPNBUILD_SINGLEPROCESS
		case TypeThread:
			DPFX(DPFPREP, 0, "Thread leaked %p", dnh->handle);
			break;
#ifndef DPNBUILD_SINGLEPROCESS
		case TypeProcess:
			DPFX(DPFPREP, 0, "Process leaked %p", dnh->handle);
			break;
#endif // ! DPNBUILD_SINGLEPROCESS
		case TypeSpecial:
			DPFX(DPFPREP, 0, "Special handle leaked %p", dnh->handle);
			break;

		default:
			DPFX(DPFPREP, 0, "Unknown handle leaked %p", dnh->handle);
			DNASSERT(0);
			break;
		}

		// Show the callstack of the place the handle was allocated.
		TCHAR		CallStackBuffer[ CALLSTACK_BUFFER_SIZE ];
		dnh->AllocCallStack.GetCallStackString( CallStackBuffer );
		DPFX(DPFPREP,  0, "%s\n", CallStackBuffer );

		DNFree(dnh);		
	}
	DNLeaveCriticalSection(&g_HandleLock);

	return fLeaked;
}

DNHANDLE DNHandleTrackMakeDNHANDLE(HANDLE h)
{
	if (h == 0 || h == INVALID_HANDLE_VALUE)
	{
		return (DNHANDLE)h;
	}

	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeSpecial;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	return dnh;
}

VOID DNHandleTrackRemoveDNHANDLE(DNHANDLE dnh)
{
	DNASSERT(IsValidHandle(dnh));

	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.RemoveFromList();
	DNLeaveCriticalSection(&g_HandleLock);

	DNFree(dnh);
}

HANDLE 	 DNHandleTrackHandleFromDNHANDLE(DNHANDLE h)
{
	if (h == 0 || h == INVALID_HANDLE_VALUE)
	{
		return (HANDLE)h;
	}

	DNASSERT(IsValidHandle(h));
	return h->handle;
}

#ifndef DPNBUILD_SINGLEPROCESS
// NOTE: pCurrentDirectory is const on the desktop, but non-const on WinCE
BOOL DNHandleTrackCreateProcess(LPCTSTR lpApplicationName, LPTSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCTSTR lpCurrentDirectory, LPSTARTUPINFO lpStartupInfo, DNPROCESS_INFORMATION* lpProcessInformation)
{
	PROCESS_INFORMATION pi;
	DWORD dwLastError;

	DNHANDLE dnhProcess = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnhProcess)
	{
		return FALSE;
	}

	DNHANDLE dnhThread = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnhThread)
	{
		DNFree(dnhProcess);
		return FALSE;
	}

	// NOTE: On CE only the current directory is declared non-const so cast it off
#ifdef WINCE
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, (LPTSTR)lpCurrentDirectory, lpStartupInfo, &pi))
#else // !WINCE
	if (!CreateProcess(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, &pi))
#endif // WINCE
	{
		dwLastError = GetLastError();
		DNFree(dnhProcess);
		DNFree(dnhThread);
		SetLastError(dwLastError);
		return FALSE;
	}
	dwLastError = GetLastError();
	
	dnhProcess->AllocCallStack.NoteCurrentCallStack();
	dnhProcess->handle = pi.hProcess;
	dnhProcess->type = TypeProcess;
	dnhProcess->blHandle.Initialize();
	
	dnhThread->AllocCallStack.NoteCurrentCallStack();
	dnhThread->handle = pi.hThread;
	dnhThread->type = TypeThread;
	dnhThread->blHandle.Initialize();

	DNEnterCriticalSection(&g_HandleLock);
	dnhProcess->blHandle.InsertBefore(&g_blHandles);
	dnhThread->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	lpProcessInformation->hProcess = dnhProcess;
	lpProcessInformation->hThread = dnhThread;
	lpProcessInformation->dwProcessId = pi.dwProcessId;
	lpProcessInformation->dwThreadId = pi.dwThreadId;

	SetLastError(dwLastError);
	return TRUE;
}

DNHANDLE DNHandleTrackOpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
{
	DWORD dwLastError;

	HANDLE h = OpenProcess(dwDesiredAccess, bInheritHandle, dwProcessId);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeProcess;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}
#endif // ! DPNBUILD_SINGLEPROCESS

DNHANDLE DNHandleTrackCreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, DWORD dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
{
	DWORD dwLastError;

	HANDLE h = CreateThread(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeThread;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackCreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeEvent;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenEvent(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenEvent(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeEvent;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackSetEvent(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeEvent);
	return SetEvent(hHandle->handle);
}

BOOL DNHandleTrackResetEvent(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeEvent);
	return ResetEvent(hHandle->handle);
}

DNHANDLE DNHandleTrackCreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateMutex(lpMutexAttributes, bInitialOwner, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeMutex;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenMutex(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenMutex(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeMutex;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackReleaseMutex(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeMutex);
	return ReleaseMutex(hHandle->handle);
}

DNHANDLE DNHandleTrackCreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = CreateSemaphore(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeSemaphore;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackReleaseSemaphore(DNHANDLE hHandle, LONG lReleaseCount, LPLONG lpPreviousCount)
{
	DNASSERT(IsValidHandle(hHandle));
	DNASSERT(hHandle->type == TypeSemaphore);
	return ReleaseSemaphore(hHandle->handle, lReleaseCount, lpPreviousCount);
}

DNHANDLE DNHandleTrackCreateFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	DWORD dwLastError;

	HANDLE h = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
	if (h == INVALID_HANDLE_VALUE)
	{
		return DNINVALID_HANDLE_VALUE;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFile;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

#ifndef DPNBUILD_SINGLEPROCESS
DNHANDLE DNHandleTrackCreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCTSTR lpName)
{
	DWORD dwLastError;

	// If someone wants to actually map a file, we need to make param 1 a DNHANDLE and do the appropriate work here.
	DNASSERT(hFile == INVALID_HANDLE_VALUE);

	HANDLE h = CreateFileMapping(hFile, lpAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFileMap;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

DNHANDLE DNHandleTrackOpenFileMapping(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName)
{
	DWORD dwLastError;

	HANDLE h = OpenFileMapping(dwDesiredAccess, bInheritHandle, lpName);
	if (!h)
	{
		return 0;
	}
	dwLastError = GetLastError();
	
	DNHANDLE dnh = (DNHANDLE)DNMalloc(sizeof(TRACKED_HANDLE));
	if (!dnh)
	{
		CloseHandle(h);
		SetLastError(dwLastError);
		return 0;
	}

	dnh->AllocCallStack.NoteCurrentCallStack();
	dnh->handle = h;
	dnh->type = TypeFileMap;
	dnh->blHandle.Initialize();
	
	DNEnterCriticalSection(&g_HandleLock);
	dnh->blHandle.InsertBefore(&g_blHandles);
	DNLeaveCriticalSection(&g_HandleLock);

	SetLastError(dwLastError);
	return dnh;
}

BOOL DNHandleTrackGetExitCodeProcess(DNHANDLE hHandle, LPDWORD lpExitCode)
{
	DNASSERT(IsValidHandle(hHandle));
	return GetExitCodeProcess(hHandle->handle, lpExitCode);
}
#endif // ! DPNBUILD_SINGLEPROCESS

DWORD DNHandleTrackWaitForSingleObject(DNHANDLE hHandle, DWORD dwMilliseconds)
{
	DNASSERT(IsValidHandle(hHandle));
	return WaitForSingleObject(hHandle->handle, dwMilliseconds);
}

DWORD DNHandleTrackWaitForSingleObjectEx(DNHANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(IsValidHandle(hHandle));
	return WaitForSingleObjectEx(hHandle->handle, dwMilliseconds, bAlertable);
}

DWORD DNHandleTrackWaitForMultipleObjects(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds)
{
	DNASSERT(nCount <= MAXIMUM_WAIT_OBJECTS);
	HANDLE rgh[MAXIMUM_WAIT_OBJECTS];
	DWORD iHandle;

	for (iHandle = 0; iHandle < nCount; iHandle++)
	{
		DNASSERT(IsValidHandle(lpHandles[iHandle]));
		rgh[iHandle] = lpHandles[iHandle]->handle;
	}
	for (;iHandle < MAXIMUM_WAIT_OBJECTS; iHandle++)
	{
		rgh[iHandle] = 0;
	}
	return WaitForMultipleObjects(nCount, rgh, fWaitAll, dwMilliseconds);
}

DWORD DNHandleTrackWaitForMultipleObjectsEx(DWORD nCount, CONST DNHANDLE *lpHandles, BOOL fWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(nCount <= MAXIMUM_WAIT_OBJECTS);
	HANDLE rgh[MAXIMUM_WAIT_OBJECTS];
	DWORD iHandle;

	for (iHandle = 0; iHandle < nCount; iHandle++)
	{
		DNASSERT(IsValidHandle(lpHandles[iHandle]));
		rgh[iHandle] = lpHandles[iHandle]->handle;
	}
	for (;iHandle < MAXIMUM_WAIT_OBJECTS; iHandle++)
	{
		rgh[iHandle] = 0;
	}
	return WaitForMultipleObjectsEx(nCount, rgh, fWaitAll, dwMilliseconds, bAlertable);
}

DWORD DNHandleTrackSignalObjectAndWait(DNHANDLE hObjectToSignal, DNHANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
{
	DNASSERT(IsValidHandle(hObjectToSignal));
	DNASSERT(IsValidHandle(hObjectToWaitOn));
	DNASSERT(hObjectToSignal->handle != hObjectToWaitOn->handle);

#ifdef WINNT
	return SignalObjectAndWait(hObjectToSignal->handle, hObjectToWaitOn->handle, dwMilliseconds, bAlertable);
#else // ! WINNT
	BOOL	fResult;

	fResult = SetEvent(hObjectToSignal->handle);
	DNASSERT(fResult);
	return WaitForSingleObjectEx(hObjectToWaitOn->handle, dwMilliseconds, bAlertable);
#endif // ! WINNT
}

BOOL DNHandleTrackCloseHandle(DNHANDLE hHandle)
{
	DNASSERT(IsValidHandle(hHandle));

	DNEnterCriticalSection(&g_HandleLock);
	hHandle->blHandle.RemoveFromList();
	DNLeaveCriticalSection(&g_HandleLock);

	HANDLE h = hHandle->handle;

	DNFree(hHandle);

	return CloseHandle(h);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\strutils.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.h
 *  Content:    Defines the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __STRUTILS_H
#define __STRUTILS_H

HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr);
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr);

#ifndef WINCE

HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide);

HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength );

HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength );

#endif // !WINCE

#endif // __STRUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\memorytracking.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       MemoryTracking.cpp
 *  Content:	Debug memory tracking for detecting leaks, overruns, etc.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	11/14/2001	masonb	Created
 *
 ***************************************************************************/

#include "dncmni.h"



#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL
BOOL				g_fAllocationsAllowed = TRUE;
#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL

#ifdef DBG

#ifdef _WIN64
#define	GUARD_SIGNATURE	0xABABABABABABABAB
#else // !_WIN64
#define	GUARD_SIGNATURE	0xABABABAB
#endif // _WIN64

// Structure prepended to memory allocations to check for leaks.
struct MEMORY_HEADER
{
	CBilink			blLinkage;				 // size = two pointers
	DWORD_PTR		dwpSize;				 // size = pointer
	CCallStack		AllocCallStack;			 // size = 12 pointers
	DWORD_PTR		dwpPreGuard;			 // size = pointer
	// We want what follows to always be 16-byte aligned and #pragma pack doesn't seem to ensure that
};

CRITICAL_SECTION	g_AllocatedMemoryLock;
CBilink				g_blAllocatedMemory;
DWORD_PTR			g_dwpCurrentNumMemAllocations = 0;
DWORD_PTR			g_dwpCurrentMemAllocated = 0;
DWORD_PTR			g_dwpTotalNumMemAllocations = 0;
DWORD_PTR			g_dwpTotalMemAllocated = 0;
DWORD_PTR			g_dwpPeakNumMemAllocations = 0;
DWORD_PTR			g_dwpPeakMemAllocated = 0;

#endif // DBG



#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))

HANDLE				g_hMemoryHeap = NULL;




#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackInitialize"
BOOL DNMemoryTrackInitialize(DWORD_PTR dwpMaxMemUsage)
{
	// Ensure that we stay heap aligned for SLISTs
#ifdef _WIN64
	DBG_CASSERT(sizeof(MEMORY_HEADER) % 16 == 0);
#else // !_WIN64
	DBG_CASSERT(sizeof(MEMORY_HEADER) % 8 == 0);
#endif // _WIN64

	// Check for double init
	DNASSERT(g_hMemoryHeap == NULL);
#ifndef DPNBUILD_FIXEDMEMORYMODEL
	DNASSERT(dwpMaxMemUsage == 0);
#endif // ! DPNBUILD_FIXEDMEMORYMODEL

	DPFX(DPFPREP, 5, "Initializing Memory Tracking");

	// In debug we always maintain a separate heap and track allocations.  In retail, 
	// we don't track allocations, and will use the process heap except for
	// DPNBUILD_FIXEDMEMORYMODEL builds, where we use a separate heap so we
	// can cap the total allocation size.
#ifdef DPNBUILD_ONLYONETHREAD
	g_hMemoryHeap = HeapCreate(HEAP_NO_SERIALIZE,	// flags
#else // ! DPNBUILD_ONLYONETHREAD
	g_hMemoryHeap = HeapCreate(0,					// flags
#endif // ! DPNBUILD_ONLYONETHREAD
								dwpMaxMemUsage,		// initial size
								dwpMaxMemUsage		// maximum heap size (if 0, it can grow)
								);

	if (g_hMemoryHeap == NULL)
	{
		DPFX(DPFPREP,  0, "Failed to create memory heap!");
		return FALSE;
	}

#ifdef DBG
#pragma TODO(masonb, "Handle possibility of failure")
	InitializeCriticalSection(&g_AllocatedMemoryLock);

	g_blAllocatedMemory.Initialize();

	g_dwpCurrentNumMemAllocations = 0;
	g_dwpCurrentMemAllocated = 0;
	g_dwpTotalNumMemAllocations = 0;
	g_dwpTotalMemAllocated = 0;
	g_dwpPeakNumMemAllocations = 0;
	g_dwpPeakMemAllocated = 0;
#endif // DBG

	return TRUE;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDeinitialize"
void DNMemoryTrackDeinitialize()
{
	// Validate the heap if we're on NT and a debug build, and then destroy the heap.
	if (g_hMemoryHeap != NULL)
	{
		BOOL	fResult;
#ifdef DBG
		DWORD	dwError;


		DPFX(DPFPREP, 5, "Deinitializing Memory Tracking");
		DPFX(DPFPREP, 5, "Total num mem allocations = %u", g_dwpTotalNumMemAllocations);
		DPFX(DPFPREP, 5, "Total mem allocated       = %u", g_dwpTotalMemAllocated);
		DPFX(DPFPREP, 5, "Peak num mem allocations  = %u", g_dwpPeakNumMemAllocations);
		DPFX(DPFPREP, 5, "Peak mem allocated        = %u", g_dwpPeakMemAllocated);

		DeleteCriticalSection(&g_AllocatedMemoryLock);

#ifdef WINNT
		// Validate heap contents before shutdown.  This code only works on NT.
		fResult = HeapValidate(g_hMemoryHeap, 0, NULL);
		if (! fResult)
		{
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem validating heap on destroy %d!", dwError );
			DNASSERT(! "Problem validating heap on destroy!");
		}
#endif // WINNT
#endif // DBG

		fResult = HeapDestroy(g_hMemoryHeap);
		if (! fResult)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP,  0, "Problem destroying heap %d!", dwError );
			DNASSERT(! "Problem destroying heap!");
#endif // DBG
		}

		g_hMemoryHeap = NULL;
	}
}

#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL



#ifdef DBG

#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapAlloc"
void* DNMemoryTrackHeapAlloc(DWORD_PTR dwpSize)
{
	MEMORY_HEADER* pMemory;
	void* pReturn;

	DNASSERT(g_hMemoryHeap != NULL);

	// Voice and lobby currently try allocating 0 byte buffers, can't enable this check yet.
	//DNASSERT( Size > 0 );

	DNMemoryTrackValidateMemory();

	if (DNMemoryTrackAreAllocationsAllowed())
	{
		// We need enough room for our header plus what the user wants plus the guard signature at the end
		pMemory = (MEMORY_HEADER*)HeapAlloc(g_hMemoryHeap, 0, sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR));
#if ((! defined(WINCE)) && (! defined(WIN95)))
		if (pMemory == NULL)
		{
			DWORD_PTR	dwpLargestFreeBlock;


			// Compact the heap to see how much size is available, and possibly try allocating again.
			dwpLargestFreeBlock = HeapCompact(g_hMemoryHeap, 0);
			if (dwpLargestFreeBlock >= (sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR)))
			{
				DPFX(DPFPREP, 1, "Largest free block after compacting is %u bytes, allocating %u bytes again.", dwpLargestFreeBlock, dwpSize);
				pMemory = (MEMORY_HEADER*)HeapAlloc(g_hMemoryHeap, 0, sizeof(MEMORY_HEADER) + dwpSize + sizeof(DWORD_PTR));
			}
			else
			{
				DPFX(DPFPREP, 1, "Largest free block after compacting is %u bytes, cannot allocate %u bytes.", dwpLargestFreeBlock, dwpSize);
			}
		}
#endif // ! WINCE and ! WIN95
		if (pMemory != NULL)
		{
			pMemory->blLinkage.Initialize();
			pMemory->dwpSize = dwpSize;
			pMemory->AllocCallStack.NoteCurrentCallStack();
			pMemory->dwpPreGuard = GUARD_SIGNATURE;
			*(DWORD_PTR UNALIGNED *)((BYTE*)(pMemory + 1) + dwpSize) = GUARD_SIGNATURE;

			EnterCriticalSection(&g_AllocatedMemoryLock);
			pMemory->blLinkage.InsertAfter(&g_blAllocatedMemory);
			g_dwpCurrentNumMemAllocations++;
			g_dwpCurrentMemAllocated += dwpSize;
			g_dwpTotalNumMemAllocations++;
			g_dwpTotalMemAllocated += dwpSize;
			if (g_dwpCurrentNumMemAllocations > g_dwpPeakNumMemAllocations)
			{
				g_dwpPeakNumMemAllocations = g_dwpCurrentNumMemAllocations;
			}
			if (g_dwpCurrentMemAllocated > g_dwpPeakMemAllocated)
			{
				g_dwpPeakMemAllocated = g_dwpCurrentMemAllocated;
			}
			LeaveCriticalSection(&g_AllocatedMemoryLock);

			pReturn = pMemory + 1;

			// We require that the pointers we pass back are heap aligned
			DNASSERT(((DWORD_PTR)pReturn & 0xF) == 0 || // IA64
				     (((DWORD_PTR)pReturn & 0x7) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0x8) || // NT32
					 (((DWORD_PTR)pReturn & 0x3) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0x4) || // WIN9X
					 (((DWORD_PTR)pReturn & 0x3) == 0 && ((DWORD_PTR)pMemory & 0xF) == 0xC) // WIN9X
					 );

			DPFX(DPFPREP, 5, "Memory Allocated, pData[%p], Size[%d]", pReturn, dwpSize);
		}
		else
		{
			DPFX(DPFPREP, 0, "Failed allocating %u bytes of memory.", dwpSize);
			pReturn = NULL;
		}
	}
	else
	{
		DPFX(DPFPREP, 0, "Memory allocations are not currently allowed!");
		DNASSERT(! "Memory allocations are not currently allowed!");
		pReturn = NULL;
	}

	return pReturn;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackHeapFree"
void DNMemoryTrackHeapFree(void* pvData)
{
	CBilink* pbl;
	MEMORY_HEADER* pMemory;

	DNASSERT(g_hMemoryHeap != NULL);

	DNMemoryTrackValidateMemory();

	if (pvData == NULL)
	{
		return;
	}

	EnterCriticalSection( &g_AllocatedMemoryLock );

	// Verify that we know of this pointer
	pbl = g_blAllocatedMemory.GetNext();
	while (pbl != &g_blAllocatedMemory)
	{
		pMemory = CONTAINING_RECORD(pbl, MEMORY_HEADER, blLinkage);
		if ((pMemory + 1) == pvData)
		{
			break;
		}
		pbl = pbl->GetNext();
	}
	DNASSERT(pbl != &g_blAllocatedMemory);

	pMemory->blLinkage.RemoveFromList();
	g_dwpCurrentNumMemAllocations--;
	g_dwpCurrentMemAllocated -= pMemory->dwpSize;

	LeaveCriticalSection(&g_AllocatedMemoryLock);

	DPFX(DPFPREP, 5, "Memory Freed, pData[%p], Size[%d]", pMemory + 1, pMemory->dwpSize);

	// Zero it in case someone is still trying to use it
	memset(pMemory, 0, sizeof(MEMORY_HEADER) + pMemory->dwpSize + sizeof(DWORD_PTR));

	HeapFree(g_hMemoryHeap, 0, pMemory);
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackValidateMemory"
void DNMemoryTrackValidateMemory()
{
	CBilink* pbl;
	MEMORY_HEADER* pMemory;
	LPCTSTR pszCause;
	DWORD_PTR dwpNumAllocations = 0;
	DWORD_PTR dwpTotalAllocated = 0;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];

	DNASSERT(g_hMemoryHeap != NULL);

	// validate all of the allocated memory
	EnterCriticalSection( &g_AllocatedMemoryLock );

	pbl = g_blAllocatedMemory.GetNext();
	while (pbl != &g_blAllocatedMemory)
	{
		pMemory = CONTAINING_RECORD(pbl, MEMORY_HEADER, blLinkage);

		if (pMemory->dwpPreGuard != GUARD_SIGNATURE)
		{
			pszCause = _T("UNDERRUN DETECTED");
		}
		else if (*(DWORD_PTR UNALIGNED *)((BYTE*)(pMemory + 1) + pMemory->dwpSize) != GUARD_SIGNATURE)
		{
			pszCause = _T("OVERRUN DETECTED");
		}
		else
		{
			pszCause = NULL;
			dwpNumAllocations++;
			dwpTotalAllocated += pMemory->dwpSize;
		}

		if (pszCause)
		{
			pMemory->AllocCallStack.GetCallStackString(CallStackBuffer);

			DPFX(DPFPREP, 0, "Memory corruption[%s], pData[%p], Size[%d]\n%s", pszCause, pMemory + 1, pMemory->dwpSize, CallStackBuffer);

			DNASSERT(FALSE);
		}

		pbl = pbl->GetNext();
	}

	DNASSERT(dwpNumAllocations == g_dwpCurrentNumMemAllocations);
	DNASSERT(dwpTotalAllocated == g_dwpCurrentMemAllocated);

	LeaveCriticalSection(&g_AllocatedMemoryLock);

#ifdef WINNT
	// Ask the OS to validate the heap
	if (HeapValidate(g_hMemoryHeap, 0, NULL) == FALSE)
	{
		DNASSERT(FALSE);
	}
#endif // WINNT
}


#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackDumpLeaks"
BOOL DNMemoryTrackDumpLeaks()
{
	MEMORY_HEADER* pMemory;
	TCHAR CallStackBuffer[CALLSTACK_BUFFER_SIZE];
	BOOL fLeaked = FALSE;

	DNASSERT(g_hMemoryHeap != NULL);

	EnterCriticalSection( &g_AllocatedMemoryLock );

	while (!g_blAllocatedMemory.IsEmpty())
	{
		pMemory = CONTAINING_RECORD(g_blAllocatedMemory.GetNext(), MEMORY_HEADER, blLinkage);

		pMemory->AllocCallStack.GetCallStackString(CallStackBuffer);

		DPFX(DPFPREP, 0, "Memory leaked, pData[%p], Size[%d]\n%s", pMemory + 1, pMemory->dwpSize, CallStackBuffer);

		pMemory->blLinkage.RemoveFromList();

		HeapFree(g_hMemoryHeap, 0, pMemory);

		fLeaked = TRUE;
	}

	LeaveCriticalSection(&g_AllocatedMemoryLock);

	return fLeaked;
}

#endif // DBG


#ifdef DPNBUILD_PREALLOCATEDMEMORYMODEL

#undef DPF_MODNAME
#define DPF_MODNAME "DNMemoryTrackAllowAllocations"
void DNMemoryTrackAllowAllocations(BOOL fAllow)
{
	DPFX(DPFPREP, 1, "Memory allocations allowed = %i.", fAllow);
	DNInterlockedExchange((LONG*) (&g_fAllocationsAllowed), fAllow);
}

#endif // DPNBUILD_PREALLOCATEDMEMORYMODEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\sources.inc ===
TARGETNAME=common
TARGETTYPE=LIBRARY

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dncmni.h
PRECOMPILED_PCH=dncmni.pch
PRECOMPILED_OBJ=dncmni.obj

INCLUDES=..\;..\..\inc;$(DXROOT)\inc;$(SDK_INC_PATH)

SOURCES= \
	CallStack.cpp \
        creg.cpp \
	CritsecTracking.cpp \
	dndbg.cpp \
	HandleTracking.cpp \
	MemoryTracking.cpp \
	osind.cpp \
	strutils.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\sources.inc ===
PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\dpnhpasti.h
PRECOMPILED_PCH=dpnhpasti.pch
PRECOMPILED_OBJ=dpnhpasti.obj

TARGETNAME=dpnhpast
TARGETTYPE=DYNLINK

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

DLLDEF=..\dpnhpast.def

INCLUDES=$(DXROOT)\inc; \
	$(NET_INC_PATH); \
	..\..\common; \
	..\..\inc; \
	..\

SOURCES=..\dpnhpast.rc \
	..\dpnhpastdllmain.cpp

TARGETLIBS=$(TARGETLIBS) \
	..\..\common\$(PLAT_DIR)\$(O)\common.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpastdllmain.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhpastdllmain.cpp
 *
 *  Content:	DPNHPAST DLL entry points.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



#include "dpnhpasti.h"





#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"
//=============================================================================
// DllMain
//-----------------------------------------------------------------------------
//
// Description: DLL entry point.
//
// Arguments:
//	HANDLE hDllInst		- Handle to this DLL module.
//	DWORD dwReason		- Reason for calling this function.
//	LPVOID lpvReserved	- Reserved.
//
// Returns: TRUE if all goes well, FALSE otherwise.
//=============================================================================
BOOL WINAPI DllMain(HANDLE hDllInst,
					DWORD dwReason,
					LPVOID lpvReserved)
{
	DPFX(DPFPREP, 0, "DllMain(0x%px, %u, 0x%p), ignored.", hDllInst, dwReason, lpvReserved);
	return TRUE;
} // DllMain




#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
//=============================================================================
// DllRegisterServer
//-----------------------------------------------------------------------------
//
// Description: Registers the DirectPlay NAT Helper PAST COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DirectPlay NAT Helper PAST.
//	E_FAIL	- Failed unregistering DirectPlay NAT Helper PAST.
//=============================================================================
HRESULT WINAPI DllRegisterServer(void)
{
	DPFX(DPFPREP, 0, "DllRegisterServer, ignored.");
	return S_OK;
} // DllRegisterServer





#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
//=============================================================================
// DllUnregisterServer
//-----------------------------------------------------------------------------
//
// Description: Unregisters the DirectPlay NAT Helper PAST COM object.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK	- Successfully unregistered DirectPlay NAT Helper PAST.
//	E_FAIL	- Failed unregistering DirectPlay NAT Helper PAST.
//=============================================================================
STDAPI DllUnregisterServer(void)
{
	DPFX(DPFPREP, 0, "DllUnregisterServer, ignored.");
	return S_OK;
} // DllUnregisterServer



/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
	DPFX(DPFPREP, 0, "DllGetClassObject (0x%p, 0x%p, 0x%p), ignored.",
		&rclsid, &riid, ppvObj);
	return CLASS_E_CLASSNOTAVAILABLE;
} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
STDAPI DllCanUnloadNow(void)
{
	DPFX(DPFPREP, 0, "DllCanUnloadNow, ignored.");
    return S_OK;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhpast\dpnhpasti.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhpasti.h
 *
 *  Content:	DPNHPAST master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/

#ifndef __DPNHPASTI_H__
#define __DPNHPASTI_H__


//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//

#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>	// for random numbers
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#include <iphlpapi.h>
#include <tchar.h>

// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "createin.h"
#include "strutils.h"


#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_NATHELP




#endif // __DPNHPASTI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\strutils.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       StrUtils.cpp
 *  Content:    Implements the string utils
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   02/12/2000	rmt		Created
 *   08/28/2000	masonb	Voice Merge: Added check of return code of MultiByteToWideChar in STR_jkAnsiToWide
 *   09/16/2000 aarono  fix STR_AllocAndConvertToANSI, ANSI doesn't mean 1 byte per DBCS character so we
 *                       must allow up to 2 bytes per char when allocating buffer (B#43286)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "dncmni.h"

/*
 ** WideToAnsi
 *
 *  CALLED BY:	everywhere
 *
 *  PARAMETERS: lpStr - destination string
 *				lpWStr - string to convert
 *				cchStr - size of dest buffer
 *
 *  DESCRIPTION:
 *				converts unicode lpWStr to ansi lpStr.
 *				fills in unconvertable chars w/ DPLAY_DEFAULT_CHAR "-"
 *				
 *
 *  RETURNS:  if cchStr is 0, returns the size required to hold the string
 *				otherwise, returns the number of chars converted
 *
 */
#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkWideToAnsi"
HRESULT STR_jkWideToAnsi(LPSTR lpStr,LPCWSTR lpWStr,int cchStr)
{
	int rval;
	BOOL fDefault = FALSE;

	// can't call us w/ null pointer & non-zero cch
	DNASSERT(lpWStr || !cchStr);

	// use the default code page (CP_ACP)
	// -1 indicates WStr must be null terminated
	rval = WideCharToMultiByte(CP_ACP,0,lpWStr,-1,lpStr,cchStr,NULL,&fDefault);

	DNASSERT(!fDefault);
	
	if(rval == 0)
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

} // WideToAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "STR_jkAnsiToWide"
/*
 ** AnsiToWide
 *
 *  CALLED BY: everywhere
 *
 *  PARAMETERS: lpWStr - dest string
 *				lpStr  - string to convert
 *				cchWstr - size of dest buffer
 *
 *  DESCRIPTION: converts Ansi lpStr to Unicode lpWstr
 *
 */
HRESULT STR_jkAnsiToWide(LPWSTR lpWStr,LPCSTR lpStr,int cchWStr)
{
	int rval;

	DNASSERT(lpStr);
	DNASSERT(lpWStr);

	rval =  MultiByteToWideChar(CP_ACP,0,lpStr,-1,lpWStr,cchWStr);
	if (!rval)
	{
		DPFX(DPFPREP,0,"MultiByteToWideChar failed in STR_jkAnsiToWide");
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}  // AnsiToWide

#ifndef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "STR_WideToAnsi"

//**********************************************************************
// ------------------------------
// WideToANSI - convert a wide string to an ANSI string
//
// Entry:		Pointer to source wide string
//				Size of source string (in WCHAR units, -1 implies NULL-terminated)
//				Pointer to ANSI string destination
//				Pointer to size of ANSI destination
//
// Exit:		Error code:
//				E_FAIL = operation failed
//				S_OK = operation succeded
//				E_OUTOFMEMORY = destination buffer too small
// ------------------------------
HRESULT	STR_WideToAnsi( const WCHAR *const pWCHARString,
						const DWORD dwWCHARStringLength,
						char *const pString,
						DWORD *const pdwStringLength )
{
	HRESULT	hr;
	int		iReturn;
	BOOL	fDefault;
	char	cMilleniumHackBuffer;	
	char	*pMilleniumHackBuffer;


	DNASSERT( pWCHARString != NULL );
	DNASSERT( pdwStringLength != NULL );
	DNASSERT( ( pString != NULL ) || ( *pdwStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = S_OK;

	if ( *pdwStringLength == 0 )
	{
		pMilleniumHackBuffer = &cMilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pString;
	}

	fDefault = FALSE;
	iReturn = WideCharToMultiByte( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pWCHARString,			// pointer to WCHAR string
								   dwWCHARStringLength,		// size of WCHAR string
								   pMilleniumHackBuffer,	// pointer to destination ANSI string
								   *pdwStringLength,		// size of destination string
								   NULL,					// pointer to default for unmappable characters (none)
								   &fDefault				// pointer to flag indicating that default was used
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX( DPFPREP, 0, "Failed to convert WCHAR to multi-byte! %d", dwError );
		hr = E_FAIL;
	}
	else
	{
		if ( *pdwStringLength == 0 )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DNASSERT( hr == S_OK );
		}

		*pdwStringLength = iReturn;
	}

	//
	// if you hit this ASSERT it's because you've probably got ASCII text as your
	// input WCHAR string.  Double-check your input!!
	//
	DNASSERT( fDefault == FALSE );

	return	hr;
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// ANSIToWide - convert an ANSI string to a wide string
//
// Entry:		Pointer to source multi-byte (ANSI) string
//				Size of source string (-1 imples NULL-terminated)
//				Pointer to multi-byte string destination
//				Pointer to size of multi-byte destination (in WCHAR units)
//
// Exit:		Error code:
//				E_FAIL = operation failed
//				S_OK = operation succeded
//				E_OUTOFMEMORY = destination buffer too small
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AnsiToWide"
HRESULT	STR_AnsiToWide( const char *const pString,
						const DWORD dwStringLength,
						WCHAR *const pWCHARString,
						DWORD *const pdwWCHARStringLength )
{
	HRESULT	hr;
	int		iReturn;
	WCHAR	MilleniumHackBuffer;
	WCHAR	*pMilleniumHackBuffer;


	DNASSERT( pString != NULL );
	DNASSERT( pdwWCHARStringLength != NULL );
	DNASSERT( ( pWCHARString != NULL ) || ( *pdwWCHARStringLength == 0 ) );

	//
	// Initialize.  A hack needs to be implemented for WinME parameter
	// validation, because when you pass zero for a destination size, you
	// MUST have a valid pointer.  Works on Win95, 98, NT4, Win2K, etc.....
	//
	hr = S_OK;

	if ( *pdwWCHARStringLength == 0 )
	{
		pMilleniumHackBuffer = &MilleniumHackBuffer;
	}
	else
	{
		pMilleniumHackBuffer = pWCHARString;
	}
	
	iReturn = MultiByteToWideChar( CP_ACP,					// code page (default ANSI)
								   0,						// flags (none)
								   pString,					// pointer to multi-byte string			
								   dwStringLength,			// size of string (assume null-terminated)
								   pMilleniumHackBuffer,	// pointer to destination wide-char string
								   *pdwWCHARStringLength	// size of destination in WCHARs
								   );
	if ( iReturn == 0 )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Failed to convert multi-byte to WCHAR! %d", dwError );
		hr = E_FAIL;
	}
	else
	{
		if ( *pdwWCHARStringLength == 0 )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			DNASSERT( hr == S_OK );
		}

		*pdwWCHARStringLength = iReturn;
	}

	return	hr;
}
//**********************************************************************




//	WideToAnsi
//
//	Convert a WCHAR (Wide) string to a CHAR (ANSI) string
//
//	CHAR	*pStr		CHAR string
//	WCHAR	*pWStr		WCHAR string
//	int		iStrSize	size (in bytes) of buffer pointed to by lpStr
#undef DPF_MODNAME
#define DPF_MODNAME "STR_AllocAndConvertToANSI"
/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT STR_AllocAndConvertToANSI(LPSTR * ppszAnsi,LPCWSTR lpszWide)
{
	int iStrLen;
	BOOL bDefault;
	
	DNASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return S_OK;
	}

	*ppszAnsi = (char*) DNMalloc((wcslen(lpszWide)*2+1)*sizeof(char));
	if (!*ppszAnsi)	
	{
		DPFX(DPFPREP,0, "could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}

	iStrLen = WideCharToMultiByte(CP_ACP,0,lpszWide,-1,*ppszAnsi,wcslen(lpszWide)*2+1,
			NULL,&bDefault);

	return S_OK;
} // OSAL_AllocAndConvertToANSI



#endif // !WINCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\osind.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.cpp
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	07/12/99	jtk		Created
 *	09/21/99	rodtoll	Fixed for retail builds
 *	09/22/99	jtk		Added callstacks to memory allocations
 *	08/28/2000	masonb	Voice Merge: Allow new and delete with size of 0
 *  11/28/2000  rodtoll	WinBug #206257 - Retail DPNET.DLL links to DebugBreak()
 *  12/22/2000  aarono	ManBug # 190380 use process heap for retail
 *  10/16/2001  vanceo	Add AssertNoCriticalSectionsTakenByThisThread capability
 ***************************************************************************/

#include "dncmni.h"


#define PROF_SECT		_T("DirectPlay8")

//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// debug variable to make sure we're initialized before having any functions
// called
//
DEBUG_ONLY( static	BOOL		g_fOSIndirectionLayerInitialized = FALSE );

//
// OS items
//
#if ((! defined(WINCE)) && (! defined(_XBOX)))
static OSVERSIONINFO g_OSVersionInfo;
#endif // ! WINCE and ! _XBOX

#ifndef DPNBUILD_NOSERIALSP
static HINSTANCE g_hApplicationInstance;
#endif // ! DPNBUILD_NOSERIALSP

//
// Global Pools
//
#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
CFixedPool g_fpClassFactories;
CFixedPool g_fpObjectDatas;
CFixedPool g_fpInterfaceLists;
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

#ifdef WINNT
PSECURITY_ATTRIBUTES g_psa = NULL;
SECURITY_ATTRIBUTES g_sa;
BYTE g_pSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
BOOL g_fDaclInited = FALSE;
PACL g_pEveryoneACL = NULL;
#endif // WINNT

#ifndef DPNBUILD_LIBINTERFACE
#define CLASSFAC_POOL_INITED 	0x00000001
#define OBJDATA_POOL_INITED 	0x00000002
#define INTLIST_POOL_INITED 	0x00000004
#endif // ! DPNBUILD_LIBINTERFACE
#ifdef DBG
#define HANDLE_TRACKING_INITED	0x00000008
#endif // DBG
#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
#define MEMORY_TRACKING_INITED	0x00000010
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL
#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
#define CRITSEC_TRACKING_INITED	0x00000020
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if !defined(DPNBUILD_LIBINTERFACE) || defined(DBG) || defined(DPNBUILD_FIXEDMEMORYMODEL)
DWORD g_dwCommonInitFlags = 0;
#endif // !defined(DPNBUILD_LIBINTERFACE) || defined(DBG) || defined(DPNBUILD_FIXEDMEMORYMODEL)

//**********************************************************************
// Function prototypes
//**********************************************************************

//**********************************************************************
// Function definitions
//**********************************************************************

//**********************************************************************
// ------------------------------
// DNOSIndirectionInit - initialize the OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Boolean indicating success
//				TRUE = initialization successful
//				FALSE = initialization unsuccessful
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionInit"

BOOL	DNOSIndirectionInit( DWORD_PTR dwpMaxMemUsage )
{
	BOOL			fReturn;

#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized == FALSE );
#endif // DBG

	//
	// initialize
	//
	fReturn = TRUE;

#if ((! defined(WINCE)) && (! defined(_XBOX)))
	//
	// note OS version
	//
	memset( &g_OSVersionInfo, 0x00, sizeof( g_OSVersionInfo ) );
	g_OSVersionInfo.dwOSVersionInfoSize = sizeof( g_OSVersionInfo );
	if ( GetVersionEx( &g_OSVersionInfo ) == FALSE )
	{
		goto Failure;
	}
#endif // ! WINCE and ! _XBOX

#ifndef DPNBUILD_NOSERIALSP
	//
	// note application instance
	//
	g_hApplicationInstance = GetModuleHandle( NULL );
	if ( g_hApplicationInstance == NULL )
	{
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP,  0, "Failed to GetModuleHandle: 0x%x", dwError );
		goto Failure;
	}
#endif // ! DPNBUILD_NOSERIALSP

#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
	//
	// initialize critical section tracking code before anything else!
	//
	if ( DNCSTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize critsec tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= CRITSEC_TRACKING_INITED;
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
	//
	// initialize memory tracking before creating new memory heap
	//
	if ( DNMemoryTrackInitialize(dwpMaxMemUsage) == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize memory tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= MEMORY_TRACKING_INITED;
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL

#ifdef DBG
	//
	// initialize handle tracking
	//
	if ( DNHandleTrackInitialize() == FALSE )
	{
		DPFX(DPFPREP,  0, "Failed to initialize handle tracking code!" );
		DNASSERT( FALSE );
		goto Failure;
	}
	g_dwCommonInitFlags |= HANDLE_TRACKING_INITED;
#endif // DBG

#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
	//
	// Initialize global pools
	//
	if (!g_fpClassFactories.Initialize( sizeof( _IDirectPlayClassFactory ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize class factory pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= CLASSFAC_POOL_INITED;

	if (!g_fpObjectDatas.Initialize( sizeof( _OBJECT_DATA ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize object data pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= OBJDATA_POOL_INITED;

	if (!g_fpInterfaceLists.Initialize( sizeof( _INTERFACE_LIST ), NULL, NULL, NULL, NULL))
	{
		DPFX(DPFPREP,  0, "Failed to initialize interface list pool!" );
		goto Failure;
	}
	g_dwCommonInitFlags |= INTLIST_POOL_INITED;
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

	srand(GETTIMESTAMP());

#if (((! defined(WINCE)) && (! defined(_XBOX))) || (! defined(DPNBUILD_NOSERIALSP)) || (defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)) || ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY))) )
Exit:
#endif // (! WINCE and ! _XBOX) or ! DPNBUILD_NOSERIALSP or DBG or DPNBUILD_FIXEDMEMORYMODEL or (! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY)
	if ( fReturn != FALSE )
	{
		DEBUG_ONLY( g_fOSIndirectionLayerInitialized = TRUE );
	}

	return fReturn;

#if (((! defined(WINCE)) && (! defined(_XBOX))) || (! defined(DPNBUILD_NOSERIALSP)) || (defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)) || ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY))) )
Failure:
	fReturn = FALSE;

	DNOSIndirectionDeinit();

	goto Exit;
#endif // (! WINCE and ! _XBOX) or ! DPNBUILD_NOSERIALSP or DBG or DPNBUILD_FIXEDMEMORYMODEL or (! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY)
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// DNOSIndirectionDeinit - deinitialize OS indirection layer
//
// Entry:		Nothing
//
// Exit:		Nothing
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIndirectionDeinit"

void	DNOSIndirectionDeinit( void )
{
#if ((! defined(DPNBUILD_LIBINTERFACE)) && (! defined(DPNBUILD_NOCLASSFACTORY)))
	//
	// DeInitialize global pools
	//
	if (g_dwCommonInitFlags & CLASSFAC_POOL_INITED)
	{
		g_fpClassFactories.DeInitialize();
	}
	if (g_dwCommonInitFlags & OBJDATA_POOL_INITED)
	{
		g_fpObjectDatas.DeInitialize();
	}
	if (g_dwCommonInitFlags & INTLIST_POOL_INITED)
	{
		g_fpInterfaceLists.DeInitialize();
	}
#endif // ! DPNBUILD_LIBINTERFACE and ! DPNBUILD_NOCLASSFACTORY

#ifdef DBG
	if (g_dwCommonInitFlags & HANDLE_TRACKING_INITED)
	{
		if (DNHandleTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
		DNHandleTrackDeinitialize();
	}
#endif // DBG

#if ((defined(DBG)) && (! defined(DPNBUILD_ONLYONETHREAD)))
	//
	// Display CritSec leaks before displaying memory leaks, because displaying memory leaks
	// may free the memory for the CritSec and corrupt the CritSec bilink
	//
	if (g_dwCommonInitFlags & CRITSEC_TRACKING_INITED)
	{
		if (DNCSTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
		DNCSTrackDeinitialize();
	}
#endif // DBG and ! DPNBUILD_ONLYONETHREAD

#if ((defined(DBG)) || (defined(DPNBUILD_FIXEDMEMORYMODEL)))
	if (g_dwCommonInitFlags & MEMORY_TRACKING_INITED)
	{
#ifdef DBG
		if (DNMemoryTrackDumpLeaks())
		{
			// There were leaks, break so we can look at the log
			DNASSERT(0);
		}
#endif // DBG
		DNMemoryTrackDeinitialize();
	}
#endif // DBG or DPNBUILD_FIXEDMEMORYMODEL

#ifdef WINNT
	// This should be done after functions that use a Dacl will no longer be
	// called (CreateMutex, CreateFile, etc).
	if (g_pEveryoneACL)
	{
		HeapFree(GetProcessHeap(), 0, g_pEveryoneACL);
		g_pEveryoneACL = NULL;
	}
#endif // WINNT

	DEBUG_ONLY( g_fOSIndirectionLayerInitialized = FALSE );

#if !defined(DPNBUILD_LIBINTERFACE) || defined(DBG)
	g_dwCommonInitFlags = 0;
#endif // !defined(DPNBUILD_LIBINTERFACE) || defined(DBG)
}
//**********************************************************************


#undef DPF_MODNAME
#define DPF_MODNAME "DNinet_ntow"
void DNinet_ntow( IN_ADDR in, WCHAR* pwsz )
{
	// NOTE: pwsz should be 16 characters (4 3-digit numbers + 3 '.' + \0)
	swprintf(pwsz, L"%d.%d.%d.%d", in.s_net, in.s_host, in.s_lh, in.s_impno);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetRandomNumber"
DWORD DNGetRandomNumber()
{
	return (rand() | (rand() << 16));
}

#if ((! defined(WINCE)) && (! defined(_XBOX)))
//**********************************************************************
// ------------------------------
// DNGetOSType - get OS type
//
// Entry:		Nothing
//
// Exit:		OS type
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetOSType"

UINT_PTR	DNGetOSType( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG
	return	g_OSVersionInfo.dwPlatformId;
}
#endif // ! WINCE and ! _XBOX


#ifdef WINNT

//**********************************************************************
// ------------------------------
// DNOSIsXPOrGreater - return TRUE if OS is WindowsXP or later or NT flavor
//
// Entry:		Nothing
//
// Exit:		BOOL
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSIsXPOrGreater"

BOOL DNOSIsXPOrGreater( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG

	return ((g_OSVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
		    ((g_OSVersionInfo.dwMajorVersion > 5) || ((g_OSVersionInfo.dwMajorVersion == 5) && (g_OSVersionInfo.dwMinorVersion >= 1))) 
		    );
}

//**********************************************************************

//**********************************************************************
// ------------------------------
// DNGetNullDacl - get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accesible by all users.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl()
{
	PSID                     psidEveryone      = NULL;
	SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_WORLD_SID_AUTHORITY;
	DWORD					 dwAclSize;

	// This is done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*)g_pSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize security descriptor" );
			goto Error;
		}

		// Create SID for the Everyone group.
		if (!AllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID, 0,
                                      0, 0, 0, 0, 0, 0, &psidEveryone))
		{
			DPFX(DPFPREP,  0, "Failed to allocate Everyone SID" );
			goto Error;
		}

		dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidEveryone) - sizeof(DWORD);

		// Allocate the ACL, this won't be a tracked allocation and we will let process cleanup destroy it
		g_pEveryoneACL = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if (g_pEveryoneACL == NULL)
		{
			DPFX(DPFPREP,  0, "Failed to allocate ACL buffer" );
			goto Error;
		}

		// Intialize the ACL.
		if (!InitializeAcl(g_pEveryoneACL, dwAclSize, ACL_REVISION))
		{
			DPFX(DPFPREP,  0, "Failed to initialize ACL" );
			goto Error;
		}

		// Add the ACE.
		if (!AddAccessAllowedAce(g_pEveryoneACL, ACL_REVISION, GENERIC_ALL, psidEveryone))
		{
			DPFX(DPFPREP,  0, "Failed to add ACE to ACL" );
			goto Error;
		}

		// We no longer need the SID that was allocated.
		FreeSid(psidEveryone);
		psidEveryone = NULL;

		// Add the ACL to the security descriptor..
		if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*)g_pSD, TRUE, g_pEveryoneACL, FALSE))
		{
			DPFX(DPFPREP,  0, "Failed to add ACL to security descriptor" );
			goto Error;
		}

		g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
		g_sa.lpSecurityDescriptor = g_pSD;
		g_sa.bInheritHandle = FALSE;

		g_psa = &g_sa;

		g_fDaclInited = TRUE;
	}
Error:
	if (psidEveryone)
	{
		FreeSid(psidEveryone);
		psidEveryone = NULL;
	}
	return g_psa;
}
//**********************************************************************
#endif // WINNT

#ifndef DPNBUILD_NOSERIALSP
//**********************************************************************
// ------------------------------
// DNGetApplicationInstance - application instance
//
// Entry:		Nothing
//
// Exit:		Application instance
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNGetApplicationInstance"

HINSTANCE	DNGetApplicationInstance( void )
{
#ifdef DBG
	DNASSERT( g_fOSIndirectionLayerInitialized != FALSE );
#endif // DBG
	return	g_hApplicationInstance;
}
//**********************************************************************
#endif // ! DPNBUILD_NOSERIALSP


#ifndef DPNBUILD_ONLYONETHREAD
//**********************************************************************
// ------------------------------
// DNOSInitializeCriticalSection - initialize a critical section
//
// Entry:		Pointer to critical section
//
// Exit:		Boolean indicating success
//				TRUE = success
//				FALSE = failue
// ------------------------------
#undef DPF_MODNAME
#define DPF_MODNAME "DNOSInitializeCriticalSection"

BOOL DNOSInitializeCriticalSection( CRITICAL_SECTION* pCriticalSection )
{
	BOOL	fReturn;

	DNASSERT( pCriticalSection != NULL );
	fReturn = TRUE;

	//
	// attempt to enter the critical section once
	//
	_try
	{
#ifdef WINNT
			// Pre-allocate the critsec event by setting the high bit of the spin count and set spin to 1000
			// NT converts the spin to 0 for single proc machines.
			fReturn = InitializeCriticalSectionAndSpinCount( pCriticalSection , 0x80000000 | 1000);
#else
			InitializeCriticalSection( pCriticalSection );
#endif // WINNT
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		fReturn = FALSE;
	}

	_try
	{
		if (fReturn)
		{
			EnterCriticalSection( pCriticalSection );
		}
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		DeleteCriticalSection(pCriticalSection);
		fReturn = FALSE;
	}

	//
	// if we didn't fail on entering the critical section, make sure
	// we release it
	//
	if ( fReturn != FALSE )
	{
		LeaveCriticalSection( pCriticalSection );
	}

	return	fReturn;
}
//**********************************************************************
#endif // !DPNBUILD_ONLYONETHREAD


#ifdef DBG

#ifdef WINCE

#undef DPF_MODNAME
#define DPF_MODNAME "DNGetProfileInt"

UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault)
{
	DWORD		dwResult;
	CRegistry	reg;


	DNASSERT(_tcscmp(lpszSection, _T("DirectPlay8")) == 0);

	if (!reg.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\DirectPlay8")))
	{
		// NOTE: This will occur during DllRegisterServer for the first time
		return nDefault;
	}

	if (!reg.ReadDWORD(lpszEntry, &dwResult))
	{
		return nDefault;
	}

	return dwResult;
}

#else // ! WINCE
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))


#undef DPF_MODNAME
#define DPF_MODNAME "DNGetProfileInt"

UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault)
{
	DWORD		dwResult;
	FILE *		pFile = NULL;
	TCHAR		tszLine[256];
	TCHAR *		ptszTrimStart;
	TCHAR *		ptszTrimEnd;
	BOOL		fInSection = FALSE;


	DNASSERT(_tcscmp(lpszSection, _T("DirectPlay8")) == 0);

	//
	// Populate the default return value.
	//
	dwResult = nDefault;

	//
	// Open a "win.ini" file in the root of the title's launch directory.
	//
	pFile = fopen(_T("D:\\win.ini"), "r");
	if (pFile == NULL)
	{
		goto Exit;
	}

	//
	// Look for the section and entry.
	//
	while (_fgetts(tszLine, (sizeof(tszLine) - sizeof(TCHAR)), pFile) != NULL)
	{
		//
		// Trim whitespace from the beginning of the line.
		//
		ptszTrimStart = tszLine;
		while (((*ptszTrimStart) == _T('\n')) ||
				((*ptszTrimStart) == _T('\r')) ||
				((*ptszTrimStart) == _T(' ')) ||
				((*ptszTrimStart) == _T('\t')))
		{
			if ((*ptszTrimStart) == 0)
			{
				break;
			}

			ptszTrimStart++;
		}

		//
		// Trim whitespace off the end of the line.
		//
		ptszTrimEnd = ptszTrimStart + _tcslen(ptszTrimStart) - 1;
		while (((*ptszTrimEnd) == _T('\n')) ||
				((*ptszTrimEnd) == _T('\r')) ||
				((*ptszTrimEnd) == _T(' ')) ||
				((*ptszTrimEnd) == _T('\t')))
		{
			if (ptszTrimEnd <= ptszTrimStart)
			{
				break;
			}

			ptszTrimEnd--;
		}


		//
		// Ignore commented lines (starts with semicolon).
		//
		if ((*ptszTrimStart) != _T(';'))
		{
			//
			// If it starts and ends with brackets, it's a section header.
			//
			if (((*ptszTrimStart) == _T('[')) && ((*ptszTrimEnd) == _T(']')))
			{
				//
				// If we were in the section, then we've left it and we're
				// done.
				//
				if (fInSection)
				{
					break;
				}


				//
				// Trim whitespace from inside the start of the brackets.
				//

				*ptszTrimEnd = 0;
				ptszTrimEnd--;
				ptszTrimStart++;

				while (((*ptszTrimStart) == _T('\n')) ||
						((*ptszTrimStart) == _T('\r')) ||
						((*ptszTrimStart) == _T(' ')) ||
						((*ptszTrimStart) == _T('\t')))
				{
					if ((*ptszTrimStart) == 0)
					{
						break;
					}

					ptszTrimStart++;
				}

				while (((*ptszTrimEnd) == _T('\n')) ||
						((*ptszTrimEnd) == _T('\r')) ||
						((*ptszTrimEnd) == _T(' ')) ||
						((*ptszTrimEnd) == _T('\t')))
				{
					if (ptszTrimEnd <= ptszTrimStart)
					{
						break;
					}

					ptszTrimEnd--;
				}

				*(ptszTrimEnd + 1) = 0;


				//
				// Is this the right section?
				//
				if (_tcsicmp(ptszTrimStart, lpszSection) == 0)
				{
					fInSection = TRUE;
				}
			}
			else
			{
				//
				// If we're in the section, determine the key
				// name.
				//
				if (fInSection)
				{
					TCHAR *		ptszKeyEnd;
					TCHAR *		ptszValue;


					*(ptszTrimEnd + 1) = 0;
					ptszKeyEnd = ptszTrimStart;
					while ((ptszKeyEnd < ptszTrimEnd) &&
							((*ptszKeyEnd) != _T('=')))
					{
						ptszKeyEnd++;
					}

					if ((*ptszKeyEnd) == _T('='))
					{
						ptszValue = ptszKeyEnd + 1;
						ptszKeyEnd--;
						while (((*ptszKeyEnd) == _T('\n')) ||
								((*ptszKeyEnd) == _T('\r')) ||
								((*ptszKeyEnd) == _T(' ')) ||
								((*ptszKeyEnd) == _T('\t')))
						{
							if (ptszKeyEnd <= ptszTrimStart)
							{
								break;
							}

							ptszKeyEnd--;
						}

						*(ptszKeyEnd + 1) = 0;

						//
						// If we matched the key name, convert the
						// value and bail.
						//
						if (_tcsicmp(ptszTrimStart, lpszEntry) == 0)
						{
							dwResult = _ttoi(ptszValue);
							goto Exit;
						}
					}
				}
				else
				{
					//
					// Not in section.
					//
				}
			}
		}
		else
		{
			//
			// Line is commented, ignore.
			//
		}
	}


Exit:

	if (pFile != NULL)
	{
		fclose(pFile);
		pFile = NULL;
	}

	return dwResult;
}

#endif // _XBOX and ! XBOX_ON_DESKTOP
#endif // ! WINCE

#endif // DBG



#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)

//**********************************************************************
//**
//** Begin CE layer.  Here we implement functions we need that aren't on CE.
//**
//**********************************************************************

#undef DPF_MODNAME
#define DPF_MODNAME "OpenEvent"

HANDLE WINAPI OpenEvent(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;

	h = CreateEvent(0, 1, 0, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OpenFileMapping"

HANDLE WINAPI OpenFileMapping(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;
	DWORD dwFlags = 0;

	if (dwDesiredAccess & FILE_MAP_WRITE)
	{
		// If they ask for FILE_MAP_ALL_ACCESS or FILE_MAP_WRITE, they get read and write
		dwFlags = PAGE_READWRITE;
	}
	else
	{
		// If they only ask for FILE_MAP_READ, they get read only
		dwFlags = PAGE_READONLY;
	}

	h = CreateFileMapping(INVALID_HANDLE_VALUE, 0, dwFlags, 0, 1, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

#undef DPF_MODNAME
#define DPF_MODNAME "OpenMutex"

HANDLE WINAPI OpenMutex(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName)
{
	HANDLE h;

	h = CreateMutex(0, 0, lpName);
	if (!h)
	{
		return NULL;
	}
	if (GetLastError() != ERROR_ALREADY_EXISTS)
	{
		CloseHandle(h);
		return NULL;
	}
	return h;
}

/*
#ifdef _X86_
__declspec(naked)
LONG WINAPI InterlockedExchangeAdd( LPLONG Addend, LONG Increment )
{
	__asm 
	{
		mov			ecx, [esp + 4]	; get addend address
		mov			eax, [esp + 8]	; get increment value
		lock xadd	[ecx], eax	; exchange add}
		ret
	}
}
#endif // _X86
*/
#endif // WINCE
//**********************************************************************
//**
//** End CE layer.  Here we implement functions we need that aren't on CE.
//**
//**********************************************************************


#if ((defined(WINCE)) || (defined(DPNBUILD_LIBINTERFACE)))

#undef DPF_MODNAME
#define DPF_MODNAME "DNCoCreateGuid"

HRESULT DNCoCreateGuid(GUID* pguid)
{
	pguid->Data1 = (rand() << 16) | rand();
	pguid->Data2 = (WORD)rand();
	pguid->Data3 = (WORD)rand();
	pguid->Data4[0] = (BYTE)rand();
	pguid->Data4[1] = (BYTE)rand();
	pguid->Data4[2] = (BYTE)rand();
	pguid->Data4[3] = (BYTE)rand();
	pguid->Data4[4] = (BYTE)rand();
	pguid->Data4[5] = (BYTE)rand();
	pguid->Data4[6] = (BYTE)rand();
	pguid->Data4[7] = (BYTE)rand();

	return S_OK;
}

#endif // WINCE or DPNBUILD_LIBINTERFACE



#ifndef DPNBUILD_NOPARAMVAL

BOOL IsValidStringA( const CHAR * const lpsz )
{
#ifndef WINCE
	return (!IsBadStringPtrA( lpsz, 0xFFFF ) );
#else
	const char* szTmpLoc = lpsz;

	//
	// If it is a NULL pointer just return FALSE, they are always bad
	//
	if (szTmpLoc == NULL) 
	{
		return FALSE;
	}

	_try 
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except(EXCEPTION_EXECUTE_HANDLER) 
	{
		return FALSE;
	}
    
	return TRUE;

#endif // WINCE
}

BOOL IsValidStringW( const WCHAR * const  lpwsz )
{
#ifdef WINNT
	//
	//	This function is only valid on NT.
	//	It exists for WIN9x, but only via the MS Layer for Unicode which requires us to jump through hoops when linking
	//
	return (!IsBadStringPtrW( lpwsz, 0xFFFF ) );
#else
	const wchar_t *szTmpLoc = lpwsz;
	
	//
	// If it is a NULL pointer just return FALSE, they are always bad
	//
	if( szTmpLoc == NULL )
	{
		return FALSE;
	}
	
	_try
	{
		for( ; *szTmpLoc ; szTmpLoc++ );
	}
	_except( EXCEPTION_EXECUTE_HANDLER )
	{
		return FALSE;
	}

	return TRUE;
#endif // WINNT
}

#endif // !DPNBUILD_NOPARAMVAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\common\osind.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       OSInd.h
 *  Content:	OS indirection functions to abstract OS specific items.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	07/12/1999	jtk		Created
 *	10/16/2001	vanceo		Added AssertNoCriticalSectionsTakenByThisThread capability
 *
 ***************************************************************************/

#ifndef	__OSIND_H__
#define	__OSIND_H__

#include "CallStack.h"
#include "ClassBilink.h"
#include "HandleTracking.h"
#include "CritsecTracking.h"
#include "MemoryTracking.h"


//**********************************************************************
// Constant definitions
//**********************************************************************

#define GUID_STRING_LEN 39

//**********************************************************************
// Macro definitions
//**********************************************************************

#ifndef	OFFSETOF
#define OFFSETOF(s,m)				( ( INT_PTR ) ( ( PVOID ) &( ( (s*) 0 )->m ) ) )
#endif // OFFSETOF

//returns a pointer to a container structure given an internal member
//con_type is the container type, mem_name is the member name and mem_ptr is the
//pointer to the member

#ifndef CONTAINEROF
#define CONTAINEROF(con_type,mem_name,mem_ptr)	((con_type * ) (((char * ) mem_ptr)-\
						( ( int ) ( ( void * ) &( ( (con_type*) 0 )->mem_name ) ) )));
#endif // CONTAINEROF

#ifndef	LENGTHOF
#define	LENGTHOF( arg )				( sizeof( arg ) / sizeof( arg[ 0 ] ) )
#endif // OFFSETOF

#ifndef _MIN
#define _MIN(a, b) ((a) < (b) ? (a) : (b))
#endif // _MIN

#ifndef _MAX
#define _MAX(a, b) ((a) > (b) ? (a) : (b))
#endif // _MAX

//**********************************************************************
// Structure definitions
//**********************************************************************

//**********************************************************************
// Variable definitions
//**********************************************************************

//**********************************************************************
// Function prototypes
//**********************************************************************

//
// initialization functions
//
BOOL	DNOSIndirectionInit( DWORD_PTR dwpMaxMemUsage );
void	DNOSIndirectionDeinit( void );

#ifndef DPNBUILD_NOPARAMVAL

extern BOOL IsValidStringA( const CHAR * const swzString );
#define DNVALID_STRING_A(a)		IsValidStringA(a)

extern BOOL IsValidStringW( const WCHAR * const szString );
#define DNVALID_STRING_W(a)		IsValidStringW(a)

#define DNVALID_WRITEPTR(a,b)	(!IsBadWritePtr(a,b))
#define DNVALID_READPTR(a,b)	(!IsBadReadPtr(a,b))

#endif // ! DPNBUILD_NOPARAMVAL

//
// Function to get OS version.  Supported returns:
//	VER_PLATFORM_WIN32_WINDOWS - Win9x
//	VER_PLATFORM_WIN32_NT - WinNT
//	VER_PLATFORM_WIN32s - Win32s on Win3.1
//	VER_PLATFORM_WIN32_CE - WinCE
//	
#if ((! defined(WINCE)) && (! defined(_XBOX)))
UINT_PTR	DNGetOSType( void );
#endif // ! WINCE and ! _XBOX

struct in_addr;
typedef struct in_addr IN_ADDR;
void DNinet_ntow( IN_ADDR sin, WCHAR* pwsz );

#ifdef WINNT
BOOL		DNOSIsXPOrGreater( void );
#endif // WINNT

#ifndef DPNBUILD_NOSERIALSP
// Used only by serial provider
HINSTANCE	DNGetApplicationInstance( void );
#endif // ! DPNBUILD_NOSERIALSP

#ifdef WINNT
PSECURITY_ATTRIBUTES DNGetNullDacl();
#else
#define DNGetNullDacl() 0
#endif // WINNT

#ifndef VER_PLATFORM_WIN32_CE
#define VER_PLATFORM_WIN32_CE           3
#endif // VER_PLATFORM_WIN32_CE

#if ((defined(WINCE)) || (defined(_XBOX)))
#define	IsUnicodePlatform TRUE
#else // ! WINCE and ! _XBOX
#define	IsUnicodePlatform (DNGetOSType() == VER_PLATFORM_WIN32_NT || DNGetOSType() == VER_PLATFORM_WIN32_CE)
#endif // ! WINCE and ! _XBOX


#ifdef WINCE
#define GETTIMESTAMP() GetTickCount()
#else
#define GETTIMESTAMP() timeGetTime()
#endif // WINCE

DWORD DNGetRandomNumber();

//
// Interlocked functions (not actually interlocked when DPNBUILD_ONLYONETHREAD)
//
#ifdef DPNBUILD_ONLYONETHREAD
inline LONG DNInterlockedIncrement( IN OUT LONG volatile *Addend )
{
	return ++(*Addend);
}
inline LONG DNInterlockedDecrement( IN OUT LONG volatile *Addend )
{
	return --(*Addend);
}
inline LONG DNInterlockedExchange( IN OUT LONG volatile *Target, IN LONG Value )
{
	LONG	Previous;


	Previous = *Target;
	*Target = Value;
	return Previous;
}
inline LONG DNInterlockedExchangeAdd( IN OUT LONG volatile *Addend, IN LONG Value )
{
	LONG	Previous;


	Previous = *Addend;
	*Addend = Previous + Value;
	return Previous;
}
inline LONG DNInterlockedCompareExchange( IN OUT LONG volatile *Destination, IN LONG Exchange, IN LONG Comperand )
{
	LONG	Previous;


	Previous = *Destination;
	if (Previous == Comperand)
	{
		*Destination = Exchange;
	}
	return Previous;
}
inline PVOID DNInterlockedCompareExchangePointer( IN OUT PVOID volatile *Destination, IN PVOID Exchange, IN PVOID Comperand )
{
	PVOID	Previous;


	Previous = *Destination;
	if (Previous == Comperand)
	{
		*Destination = Exchange;
	}
	return Previous;
}
inline PVOID DNInterlockedExchangePointer( IN OUT PVOID volatile *Target, IN PVOID Value )
{
	PVOID	Previous;


	Previous = *Target;
	*Target = Value;
	return Previous;
}
#else // ! DPNBUILD_ONLYONETHREAD
/*
#ifdef WINCE
#if defined(_ARM_)
#define InterlockedExchangeAdd \
        ((long (*)(long *target, long increment))(PUserKData+0x3C0))
#elif defined(_X86_)
LONG WINAPI InterlockedExchangeAdd( LPLONG Addend, LONG Increment );
#else
#error("Unknown platform")
#endif // Platform
#endif // WINCE
*/
#define DNInterlockedIncrement( Addend )											InterlockedIncrement( Addend )
#define DNInterlockedDecrement( Addend )											InterlockedDecrement( Addend )
#define DNInterlockedExchange( Target, Value )										InterlockedExchange( Target, Value )
#define DNInterlockedExchangeAdd( Target, Value )									InterlockedExchangeAdd( Target, Value )
#ifdef WINCE
// NOTE: InterlockedTestExchange params 2 and 3 reversed intentionally, CE is that way
#define DNInterlockedCompareExchange( Destination, Exchange, Comperand )			InterlockedTestExchange( Destination, Comperand, Exchange )
#define DNInterlockedCompareExchangePointer( Destination, Exchange, Comperand )		(PVOID) (DNInterlockedCompareExchange( (LPLONG) Destination, (LONG) Exchange, (LONG) Comperand ))
#define DNInterlockedExchangePointer( Target, Value )								(PVOID) (DNInterlockedExchange( (LPLONG) (Target), (LPLONG) (Value) ))
#else // ! WINCE
#define DNInterlockedCompareExchange( Destination, Exchange, Comperand )			InterlockedCompareExchange( Destination, Exchange, Comperand )
#define DNInterlockedCompareExchangePointer( Destination, Exchange, Comperand )		InterlockedCompareExchangePointer( Destination, Exchange, Comperand )
#define DNInterlockedExchangePointer( Target, Value )								InterlockedExchangePointer( Target, Value )
#endif // WINCE
#endif // ! DPNBUILD_ONLYONETHREAD

// Special initialize to set spin count, avoid out-of-memory exceptions at Enter/Leave
BOOL DNOSInitializeCriticalSection( CRITICAL_SECTION* pCriticalSection );

#ifdef WINNT
#define GLOBALIZE_STR _T("Global\\")
#else
#define GLOBALIZE_STR _T("")
#endif // WINNT

#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
#define _TWINCE(x) __T(x)
#else
#define _TWINCE(x) x
#endif // WINCE

//
// Memory functions
//

#ifdef DPNBUILD_LIBINTERFACE

#define new		__wont_compile_dont_use_new_operator__
#define delete	__wont_compile_dont_use_delete_operator__

#else // ! DPNBUILD_LIBINTERFACE

//**********************************************************************
// ------------------------------
// operator new - allocate memory for a C++ class
//
// Entry:		Size of memory to allocate
//
// Exit:		Pointer to memory
//				NULL = no memory available
//
// Notes:	This function is for classes only and will ASSERT on zero sized
//			allocations!  This function also doesn't do the whole proper class
//			thing of checking for replacement 'new handlers' and will not throw
//			an exception if allocation fails.
// ------------------------------
inline	void*	__cdecl operator new( size_t size )
{
	return DNMalloc( size );
}
//**********************************************************************


//**********************************************************************
// ------------------------------
// operator delete - deallocate memory for a C++ class
//
// Entry:		Pointer to memory
//
// Exit:		Nothing
//
// Notes:	This function is for classes only and will ASSERT on NULL frees!
// ------------------------------
inline	void	__cdecl operator delete( void *pData )
{
	//
	// Voice and lobby currently try allocating 0 byte buffers, can't disable this check yet.
	//
	if( pData == NULL )
		return;
	
	DNFree( pData );
}
//**********************************************************************

#endif // ! DPNBUILD_LIBINTERFACE


#ifdef WINCE
#ifdef DBG
UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
#endif // DBG

#ifndef WINCE_ON_DESKTOP
HANDLE WINAPI OpenEvent(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
HANDLE WINAPI OpenFileMapping(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
HANDLE WINAPI OpenMutex(IN DWORD dwDesiredAccess, IN BOOL bInheritHandle, IN LPCWSTR lpName);
#endif // !WINCE_ON_DESKTOP

#define WaitForSingleObjectEx(handle, time, fAlertable) WaitForSingleObject(handle, time)
#define WaitForMultipleObjectsEx(count, handles, waitall, time, fAlertable) WaitForMultipleObjects(count, handles, waitall, time)
#ifndef WINCE_ON_DESKTOP
#define GetWindowLongPtr(a, b) GetWindowLong(a, b)
#define GWLP_USERDATA GWL_USERDATA
#define SetWindowLongPtr(a, b, c) SetWindowLong(a, b, c)
#endif // WINCE_ON_DESKTOP
#define SleepEx(a, b) Sleep(a)

#ifndef MUTEX_ALL_ACCESS
#define MUTEX_ALL_ACCESS 0
#endif // MUTEX_ALL_ACCESS
#ifndef NORMAL_PRIORITY_CLASS
#define NORMAL_PRIORITY_CLASS 0
#endif // NORMAL_PRIORITY_CLASS

#else // ! WINCE
#ifdef DBG
#if ((defined(_XBOX)) && (! defined(XBOX_ON_DESKTOP)))
UINT DNGetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);
#else // ! _XBOX or XBOX_ON_DESKTOP
#define DNGetProfileInt(lpszSection, lpszEntry, nDefault)	GetProfileInt(lpszSection, lpszEntry, nDefault)
#endif// ! _XBOX or XBOX_ON_DESKTOP
#endif // DBG
#endif // ! WINCE

#if ((defined(WINCE)) || (defined(DPNBUILD_LIBINTERFACE)))
HRESULT DNCoCreateGuid(GUID* pguid);
#else // ! WINCE and ! DPNBUILD_LIBINTERFACE
#define DNCoCreateGuid CoCreateGuid
#endif // ! WINCE and ! DPNBUILD_LIBINTERFACE


#ifdef _XBOX

#define swprintf	wsprintfW

#else // ! _XBOX

#ifdef WINCE
static inline FARPROC DNGetProcAddress(HMODULE hModule, LPCSTR lpProcName)
	{	return GetProcAddressA(hModule, lpProcName);	};
#else
static inline FARPROC DNGetProcAddress(HMODULE hModule, LPCSTR lpProcName)
	{	return GetProcAddress(hModule, lpProcName);	};
#endif

#endif // _XBOX

#endif	// __OSIND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpclassfac.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhupnpclassfac.cpp
 *
 *  Content:	a generic class factory.
 *
 *
 *	This is a generic C++ class factory.  All you need to do is implement
 *	a function called DoCreateInstance that will create an instance of
 *	your object.
 *
 *	GP_ stands for "General Purpose"
 *
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *	10/13/98  jwo		Created it.
 *	04/08/01  vanceo	Converted to C++.
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/


#include "dpnhupnpi.h"



#ifdef __MWERKS__
	#define EXP __declspec(dllexport)
#else
	#define EXP
#endif


//**********************************************************************
// Constant definitions
//**********************************************************************

//**********************************************************************
// Macro definitions
//**********************************************************************

//**********************************************************************
// Structure definitions
//**********************************************************************

//
// class factory class definition
//
typedef class GPClassFactory:public IClassFactory
{
	public:
		GPClassFactory(const CLSID * pclsid)	{ m_dwRefCnt = 0; memcpy(&m_clsid, pclsid, sizeof(CLSID)); };
		~GPClassFactory(void)				{};


		STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
		STDMETHODIMP_(ULONG) AddRef(void);
		STDMETHODIMP_(ULONG) Release(void);
		STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void ** ppvObject);
		STDMETHODIMP LockServer(BOOL fLock);


	private:
		DWORD		m_dwRefCnt;
		CLSID		m_clsid;
} GPCLASSFACTORY, *LPGPCLASSFACTORY;


//
// function prototype for CoLockObjectExternal()
//
typedef	HRESULT (WINAPI * PCOLOCKOBJECTEXTERNAL)(LPUNKNOWN, BOOL, BOOL );

//**********************************************************************
// Variable definitions
//**********************************************************************

//
// count of outstanding COM interfaces, defined in dpnathlpdllmain.cpp
//
extern volatile LONG	g_lOutstandingInterfaceCount;



//**********************************************************************
// Function prototypes
//**********************************************************************


//**********************************************************************
// Function definitions
//**********************************************************************




/*
 * GPClassFactory::QueryInterface
 */
STDMETHODIMP GPClassFactory::QueryInterface(
											REFIID riid,
											LPVOID *ppvObj )
{
	HRESULT hr;

    *ppvObj = NULL;


    if( IsEqualIID(riid, IID_IClassFactory) ||
                    IsEqualIID(riid, IID_IUnknown))
    {
        this->m_dwRefCnt++;
        *ppvObj = this;
		hr = S_OK;
    }
    else
    {
		hr = E_NOINTERFACE;
    }


	return hr;

} /* GPClassFactory::QueryInterface */


/*
 * GPClassFactory::AddRef
 */
STDMETHODIMP_(ULONG) GPClassFactory::AddRef( void )
{
    this->m_dwRefCnt++;
    return this->m_dwRefCnt;
} /* GPClassFactory::AddRef */



/*
 * GPClassFactory::Release
 */
STDMETHODIMP_(ULONG) GPClassFactory::Release( void )
{
    this->m_dwRefCnt--;

    if( this->m_dwRefCnt != 0 )
    {
        return this->m_dwRefCnt;
    }

    delete this;
    return 0;

} /* GPClassFactory::Release */




/*
 * GPClassFactory::CreateInstance
 *
 * Creates an instance of the object
 */
STDMETHODIMP GPClassFactory::CreateInstance(
											LPUNKNOWN pUnkOuter,
											REFIID riid,
    										LPVOID *ppvObj
											)
{
    HRESULT					hr = S_OK;

    if( pUnkOuter != NULL )
    {
        return CLASS_E_NOAGGREGATION;
    }

	*ppvObj = NULL;


    /*
     * create the object by calling DoCreateInstance.  This function
     *	must be implemented specifically for your COM object
     */
	hr = DoCreateInstance(this, pUnkOuter, this->m_clsid, riid, ppvObj);
	if (FAILED(hr))
	{
		*ppvObj = NULL;
		return hr;
	}

    return S_OK;

} /* GPClassFactory::CreateInstance */



/*
 * GPClassFactory::LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP GPClassFactory::LockServer(
                BOOL fLock
				)
{
    HRESULT		hr;
    HINSTANCE	hdll;


    /*
     * call CoLockObjectExternal
     */
    hr = E_UNEXPECTED;
    hdll = LoadLibrary( _T("OLE32.DLL") );
    if( hdll != NULL )
    {
        PCOLOCKOBJECTEXTERNAL	lpCoLockObjectExternal;


		lpCoLockObjectExternal = reinterpret_cast<PCOLOCKOBJECTEXTERNAL>( GetProcAddress( hdll, _TWINCE("CoLockObjectExternal") ) );
        if( lpCoLockObjectExternal != NULL )
        {
            hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
        }
        else
        {
        }
    }
    else
    {
    }

	return hr;

} /* GPClassFactory::LockServer */



/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
EXP STDAPI  DllGetClassObject(
                REFCLSID rclsid,
                REFIID riid,
                LPVOID *ppvObj )
{
    LPGPCLASSFACTORY	pcf;
    HRESULT		hr;

    *ppvObj = NULL;

    /*
     * is this our class id?
     */
//	you must implement GetClassID() for your specific COM object
	if (!IsClassImplemented(rclsid))
    {
		return CLASS_E_CLASSNOTAVAILABLE;
	}

    /*
     * only allow IUnknown and IClassFactory
     */
    if( !IsEqualIID( riid, IID_IUnknown ) &&
	    !IsEqualIID( riid, IID_IClassFactory ) )
    {
        return E_NOINTERFACE;
    }

    /*
     * create a class factory object
     */
    pcf = new GPClassFactory(&rclsid);
    if( NULL == pcf)
    {
        return E_OUTOFMEMORY;
    }

    hr = pcf->QueryInterface( riid, ppvObj );
    if( FAILED( hr ) )
    {
        delete pcf;
        *ppvObj = NULL;
    }
    else
    {
    }

    return hr;

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
EXP STDAPI DllCanUnloadNow( void )
{
    HRESULT	hr = S_FALSE;

	
	if ( g_lOutstandingInterfaceCount == 0 )
	{
		hr = S_OK;
	}

    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpcachemap.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpcachemap.h
 *
 *  Content:	Header for cached mapping object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



//=============================================================================
// Object flags
//=============================================================================
#define CACHEMAPOBJ_TCP					DPNHQUERYADDRESS_TCP						// a TCP port instead of UDP
#define CACHEMAPOBJ_NOTFOUND			DPNHQUERYADDRESS_CACHENOTFOUND				// the address was actually not found
#define CACHEMAPOBJ_PRIVATEBUTUNMAPPED	DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED	// the address is private, but was not mapped on the Internet gateway



//=============================================================================
// Macros
//=============================================================================
#define CACHEMAP_FROM_BILINK(b)		(CONTAINING_OBJECT(b, CCacheMap, m_blList))

//
// TCP queries need to match TCP mappings, (and UDP needs to match UDP).
//
#define QUERYFLAGSMASK(dwFlags)		(dwFlags & DPNHQUERYADDRESS_TCP)



//=============================================================================
// Forward declarations
//=============================================================================
class CCacheMap;




//=============================================================================
// Main interface object class
//=============================================================================
class CCacheMap
{
	public:
#undef DPF_MODNAME
#define DPF_MODNAME "CCacheMap::CCacheMap"
		CCacheMap(const SOCKADDR_IN * const psaddrinQueryAddress,
				const DWORD dwExpirationTime,
				const DWORD dwFlags)
		{
			this->m_blList.Initialize();

			this->m_Sig[0] = 'C';
			this->m_Sig[1] = 'M';
			this->m_Sig[2] = 'A';
			this->m_Sig[3] = 'P';
			this->m_dwQueryAddressV4	= psaddrinQueryAddress->sin_addr.S_un.S_addr;
			this->m_wQueryPort			= psaddrinQueryAddress->sin_port;
			this->m_dwFlags				= dwFlags; // works because CACHEMAPOBJ_xxx == DPNHQUERYADDRESS_xxx.
			this->m_dwExpirationTime	= dwExpirationTime;
		};

#undef DPF_MODNAME
#define DPF_MODNAME "CCacheMap::~CCacheMap"
		~CCacheMap(void)
		{
			DNASSERT(this->m_blList.IsEmpty());
		};

		inline BOOL DoesMatchQuery(const SOCKADDR_IN * const psaddrinQueryAddress,
									const DWORD dwFlags) const
		{
			//
			// Is this even the right address?
			//
			if ((this->m_dwQueryAddressV4 != psaddrinQueryAddress->sin_addr.S_un.S_addr) ||
				(this->m_wQueryPort != psaddrinQueryAddress->sin_port))
			{
				return FALSE;
			}

			//
			// Of the ones that matter (QUERYFLAGSMASK), make sure all
			// required flags are present, and all flags that aren't
			// required are not present.
			// Remember CACHEMAPOBJ_xxx == DPNHQUERYADDRESS_xxx.
			//
			return ((QUERYFLAGSMASK(this->m_dwFlags) == QUERYFLAGSMASK(dwFlags)) ? TRUE : FALSE);
		};

		inline BOOL IsNotFound(void) const					{ return ((this->m_dwFlags & CACHEMAPOBJ_NOTFOUND) ? TRUE : FALSE); };
		inline BOOL IsPrivateButUnmapped(void) const			{ return ((this->m_dwFlags & CACHEMAPOBJ_PRIVATEBUTUNMAPPED) ? TRUE : FALSE); };

		inline void GetResponseAddressV4(SOCKADDR_IN * const psaddrinAddress) const
		{
			ZeroMemory(psaddrinAddress, sizeof(*psaddrinAddress));
			psaddrinAddress->sin_family				= AF_INET;
			psaddrinAddress->sin_addr.S_un.S_addr	= this->m_dwResponseAddressV4;
			psaddrinAddress->sin_port				= this->m_wResponsePort;
		};

		inline DWORD GetExpirationTime(void) const			{ return this->m_dwExpirationTime; };

		inline void SetResponseAddressV4(const DWORD dwAddressV4,
										const WORD wPort)
		{
			this->m_dwResponseAddressV4	= dwAddressV4;
			this->m_wResponsePort		= wPort;
		};


		CBilink		m_blList;		// list of all the mappings cached

	
	private:
		BYTE	m_Sig[4];				// debugging signature ('CMAP')
		DWORD	m_dwFlags;				// flags for this object

		DWORD	m_dwQueryAddressV4;		// IPv4 address searched
		WORD	m_wQueryPort;			// IPv4 port searched
		DWORD	m_dwResponseAddressV4;	// IPv4 address mapping corresponding to query
		WORD	m_wResponsePort;		// IPv4 port mapping corresponding to query
		DWORD	m_dwExpirationTime;		// time when this cached mapping expires
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpnhupnpi.h
 *
 *  Content:	DPNHUPNP master internal header file.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/

#ifndef __DPNHUPNPI_H__
#define __DPNHUPNPI_H__


//
// Build configuration include
//
#include "dpnbuild.h"

// 
// Public includes
//

#ifdef WINCE

#include <winsock.h>
#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>	// for random numbers
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#include <tchar.h>

#else // ! WINCE

#define INCL_WINSOCK_API_TYPEDEFS 1
#define _WIN32_DCOM // so we can use CoSetProxyBlanket and CoInitializeEx.  requires DCOM95 on Win95

#include <winsock2.h>
#include <ws2tcpip.h>

#include <windows.h>
#include <ole2.h>
#include <wincrypt.h>	// for random numbers
#include <mmsystem.h>   // NT BUILD requires this for timeGetTime
#include <tchar.h>

#include <iphlpapi.h>
#include <upnp.h>
#include <netcon.h>
#include <ras.h>

#ifndef DPNBUILD_NOHNETFWAPI
// 
// Net published includes
//
#include <hnetcfg.h>
#endif // ! DPNBUILD_NOHNETFWAPI

#endif // ! WINCE



// 
// DirectPlay public includes
//
#include "dpnathlp.h"


// 
// DirectPlay private includes
//
#include "dndbg.h"
#include "osind.h"
#include "classbilink.h"
#include "creg.h"
#include "createin.h"
#include "strutils.h"


// 
// DirectPlayNATHelp private includes
//

#undef DPF_SUBCOMP
#define DPF_SUBCOMP DN_SUBCOMP_NATHELP

#include "dpnhupnplocals.h"
#include "dpnhupnpdevice.h"
#include "dpnhupnpregport.h"
#include "dpnhupnpcachemap.h"
#include "upnpmsgs.h"
#include "upnpdevice.h"
#include "dpnhupnpintfobj.h"




#endif // __DPNHUPNPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dplay\dpnathlp\dpnhupnp\dpnhupnpintfobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001-2002 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:		dpnhupnpintfobj.cpp
 *
 *  Content:	DPNHUPNP main interface object class.
 *
 *  History:
 *   Date      By        Reason
 *  ========  ========  =========
 *  04/16/01  VanceO    Split DPNATHLP into DPNHUPNP and DPNHPAST.
 *
 ***************************************************************************/



#include "dpnhupnpi.h"





//=============================================================================
// Definitions
//=============================================================================
#define ACTIVE_MAPPING_VERSION							2					// version identifier for active mapping registry data

#define MAX_LONG_LOCK_WAITING_THREADS					0xFFFF				// that's a lot of simultaneous threads!

#define UPNP_SEARCH_MESSAGE_INTERVAL					499					// how often discovery multicast messages should be sent, in case of packet loss (note Win9x errata for values 500-1000ms)

#define UPNP_DGRAM_RECV_BUFFER_SIZE						1500
#define UPNP_STREAM_RECV_BUFFER_INITIAL_SIZE			(4 * 1024)			// 4 K, must be less than MAX_RECEIVE_BUFFER_SIZE

#define MAX_UPNP_HEADER_LENGTH							UPNP_STREAM_RECV_BUFFER_INITIAL_SIZE

#define LEASE_RENEW_TIME								120000				// renew if less than 2 minutes remaining

#define FAKE_PORT_LEASE_TIME							300000				// 5 minutes

#define IOCOMPLETE_WAIT_INTERVAL						100					// 100 ms between attempts
#define MAX_NUM_IOCOMPLETE_WAITS						10					// wait at most 1 second

#define MAX_NUM_HOMENETUNMAP_ATTEMPTS					3					// 3 tries
#define HOMENETUNMAP_SLEEP_FACTOR						10					// 10 ms, 20 ms, 30 ms


#define MAX_UPNP_MAPPING_DESCRIPTION_SIZE				256					// 255 characters + NULL termination

#define MAX_INSTANCENAMEDOBJECT_SIZE					64
#define INSTANCENAMEDOBJECT_FORMATSTRING				_T("DPNHUPnP Instance %u")

#define GUID_STRING_LENGTH								42					// maximum length of "{xxx...}" guid string, without NULL termination


#define PORTMAPPINGPROTOCOL_TCP							6
#define PORTMAPPINGPROTOCOL_UDP							17

#define MAX_RESERVED_PORT								1024

#define MAX_NUM_INSTANCE_EVENT_ATTEMPTS					5
#define MAX_NUM_RANDOM_PORT_TRIES						5
#define MAX_NUM_TIMEWAITCONNECT_RETRIES					20					// allow a decent number since these are detected quickly and without net traffic

#ifdef DBG
#define MAX_TRANSACTION_LOG_SIZE						(5 * 1024 * 1024)	// 5 MB
#endif // DBG





#ifndef DPNBUILD_NOWINSOCK2
//=============================================================================
// WinSock 1 version of IP options
//=============================================================================
#define IP_MULTICAST_IF_WINSOCK1	2
#define IP_MULTICAST_TTL_WINSOCK1	3
#define IP_TTL_WINSOCK1				7
#endif // ! DPNBUILD_NOWINSOCK2




//=============================================================================
// Macros
//=============================================================================
//#ifdef _X86
#define IS_CLASSD_IPV4_ADDRESS(dwAddr)	(( (*((BYTE*) &(dwAddr))) & 0xF0) == 0xE0)	// 1110 high bits or 224.0.0.0 - 239.255.255.255 multicast address, in network byte order
#define NTOHS(x)						( (((x) >> 8) & 0x00FF) | (((x) << 8) & 0xFF00) )
#define HTONS(x)						NTOHS(x)
//#endif _X86




//=============================================================================
// HTTP/SSDP/SOAP/UPnP header strings (from upnpmsgs.h)
//=============================================================================
const char *	c_szResponseHeaders[] =
{
	//
	// Headers used in discovery response
	//
	"CACHE-CONTROL",
	"DATE",
	"EXT",
	"LOCATION",
	"SERVER",
	"ST",
	"USN",

	//
	// Additional headers used in description response
	//
	"CONTENT-LANGUAGE",
	"CONTENT-LENGTH",
	"CONTENT-TYPE",
	"TRANSFER-ENCODING",

	//
	// Other known headers
	//
	"HOST",
	"NT",
	"NTS",
	"MAN",
	"MX",
	"AL",
	"CALLBACK",
	"TIMEOUT",
	"SCOPE",
	"SID",
	"SEQ",
};






//=============================================================================
// Pre-built UPnP message strings (from upnpmsgs.h)
//=============================================================================

const char		c_szUPnPMsg_Discover_Service_WANIPConnection[] = "M-SEARCH * " HTTP_VERSION EOL
																"HOST: " UPNP_DISCOVERY_MULTICAST_ADDRESS ":" UPNP_PORT_A EOL
																"MAN: \"ssdp:discover\"" EOL
																"MX: 2" EOL
																"ST: " URI_SERVICE_WANIPCONNECTION_A EOL
																EOL;

const char		c_szUPnPMsg_Discover_Service_WANPPPConnection[] = "M-SEARCH * " HTTP_VERSION EOL
																"HOST: " UPNP_DISCOVERY_MULTICAST_ADDRESS ":" UPNP_PORT_A EOL
																"MAN: \"ssdp:discover\"" EOL
																"MX: 2" EOL
																"ST: " URI_SERVICE_WANPPPCONNECTION_A EOL
																EOL;


//
// The disclaimer:
//
// A UPnP device may implement both the WANIPConnection and WANPPPConnection
// services.  We do not have any fancy logic to pick one, we just use the first
// device that responds to our discovery requests, and use the first matching
// service we encounter in the device description XML.
//
// Additionally, future UPnP devices may wish to present multiple device or
// service instances with the intention that one client gets control of the
// entire instance (additional clients would need to use a different instance).
// It's not clear to me what a UPnP device (or client, for that matter) would
// really gain by having such a setup.  I imagine a new error code would have
// to be returned whenever a client tried to control an instance that another
// client already owned (don't ask me how it would know that, by picking the
// first user or selectively responding to discovery requests, I guess).
// Regardless, we do not currently support that.  As noted above, we pick the
// first instance and run with it. 
//


//
// Topmost <?xml> tag is considered optional for all XML and is ignored.
//


//
// This solution assumes InternetGatewayDevice (not WANDevice or
// WANConnectionDevice) will be the topmost item in the response.  This is based
// on the following UPnP spec excerpt:
//
//	"Note that a single physical device may include multiple logical devices.
//	 Multiple logical devices can be modeled as a single root device with
//	 embedded devices (and services) or as multiple root devices (perhaps with
//	 no embedded devices). In the former case, there is one UPnP device
//	 description for the root device, and that device description contains a
//	 description for all embedded devices. In the latter case, there are
//	 multiple UPnP device descriptions, one for each root device."
//
const char *	c_szElementStack_service[] =
{
	"root",
	"device",		// InternetGatewayDevice
	"deviceList",
	"device",		// WANDevice
	"deviceList",
	"device",		// WANConnectionDevice
	"serviceList",
	"service"
};



/*
const char *	c_szElementStack_QueryStateVariableResponse[] =
{
	"Envelope",
	"Body",
	CONTROL_QUERYSTATEVARIABLE_A CONTROL_RESPONSESUFFIX_A
};
*/
const char *	c_szElementStack_GetExternalIPAddressResponse[] =
{
	"Envelope",
	"Body",
	ACTION_GETEXTERNALIPADDRESS_A CONTROL_RESPONSESUFFIX_A
};

const char *	c_szElementStack_AddPortMappingResponse[] =
{
	"Envelope",
	"Body",
	ACTION_ADDPORTMAPPING_A CONTROL_RESPONSESUFFIX_A
};

const char *	c_szElementStack_GetSpecificPortMappingEntryResponse[] =
{
	"Envelope",
	"Body",
	ACTION_GETSPECIFICPORTMAPPINGENTRY_A CONTROL_RESPONSESUFFIX_A
};

const char *	c_szElementStack_DeletePortMappingResponse[] =
{
	"Envelope",
	"Body",
	ACTION_DELETEPORTMAPPING_A CONTROL_RESPONSESUFFIX_A
};


const char *	c_szElementStack_ControlResponseFailure[] =
{
	"Envelope",
	"Body",
	"Fault",
	"detail",
	"UPnPError"
};




#ifdef WINNT
//=============================================================================
// Related UPnP services
//=============================================================================
TCHAR *		c_tszUPnPServices[] =
{
	_T("SSDPSRV"),	// SSDP Discovery Service
	_T("UPNPHOST"),	// Universal Plug and Play Device Host - we key off this even though it's for device hosts instead of control points
};
#endif // WINNT





//=============================================================================
// Local structures
//=============================================================================
typedef struct _CONTROLRESPONSEPARSECONTEXT
{
	CONTROLRESPONSETYPE			ControlResponseType;	// type of control response expected
	CUPnPDevice *				pUPnPDevice;			// pointer to UPnP device being used
	DWORD						dwHTTPResponseCode;		// HTTP response code for this message
	PUPNP_CONTROLRESPONSE_INFO	pControlResponseInfo;	// place to info returned in control response
} CONTROLRESPONSEPARSECONTEXT, * PCONTROLRESPONSEPARSECONTEXT;

typedef struct _DPNHACTIVEFIREWALLMAPPING
{
	DWORD	dwVersion;		// version identifier for this mapping
	DWORD	dwInstanceKey;	// key identifying DPNHUPNP instance that created this mapping
	DWORD	dwFlags;		// flags describing port being registered
	DWORD	dwAddressV4;	// address being mapped
	WORD	wPort;			// port being mapped
} DPNHACTIVEFIREWALLMAPPING, * PDPNHACTIVEFIREWALLMAPPING;

typedef struct _DPNHACTIVENATMAPPING
{
	DWORD	dwVersion;				// version identifier for this mapping
	DWORD	dwInstanceKey;			// key identifying DPNHUPNP instance that created this mapping
	DWORD	dwUPnPDeviceID;			// identifier for particular UPnP device corresponding to this mapping (meaningful only to owning instance)
	DWORD	dwFlags;				// flags describing port being registered
	DWORD	dwInternalAddressV4;	// internal client address being mapped
	WORD	wInternalPort;			// internal client port being mapped
	DWORD	dwExternalAddressV4;	// external public address that was mapped
	WORD	wExternalPort;			// external public port that was mapped
} DPNHACTIVENATMAPPING, * PDPNHACTIVENATMAPPING;






//=============================================================================
// Local functions
//=============================================================================
VOID strtrim(CHAR ** pszStr);

#ifdef WINCE
void GetExeName(WCHAR * wszPath);
#endif // WINCE





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CNATHelpUPnP"
//=============================================================================
// CNATHelpUPnP constructor
//-----------------------------------------------------------------------------
//
// Description: Initializes the new CNATHelpUPnP object.
//
// Arguments:
//	BOOL fNotCreatedWithCOM		- TRUE if this object is being instantiated
//									without COM, FALSE if it is through COM.
//
// Returns: None (the object).
//=============================================================================
CNATHelpUPnP::CNATHelpUPnP(const BOOL fNotCreatedWithCOM)
{
	this->m_blList.Initialize();


	this->m_Sig[0]	= 'N';
	this->m_Sig[1]	= 'A';
	this->m_Sig[2]	= 'T';
	this->m_Sig[3]	= 'H';

	this->m_lRefCount						= 1; // someone must have a pointer to this object

	if (fNotCreatedWithCOM)
	{
		this->m_dwFlags						= NATHELPUPNPOBJ_NOTCREATEDWITHCOM;
	}
	else
	{
		this->m_dwFlags						= 0;
	}

	this->m_hLongLockSemaphore				= NULL;
	this->m_lNumLongLockWaitingThreads		= 0;
	this->m_dwLockThreadID					= 0;
#ifndef DPNBUILD_NOWINSOCK2
	this->m_hAlertEvent						= NULL;
	this->m_hAlertIOCompletionPort			= NULL;
	this->m_dwAlertCompletionKey			= 0;
#endif // ! DPNBUILD_NOWINSOCK2

	this->m_blDevices.Initialize();
	this->m_blRegisteredPorts.Initialize();
	this->m_blUnownedPorts.Initialize();

	this->m_dwLastUpdateServerStatusTime	= 0;
	this->m_dwNextPollInterval				= 0;
	this->m_dwNumLeases						= 0;
	this->m_dwEarliestLeaseExpirationTime	= 0;

	this->m_blUPnPDevices.Initialize();
	this->m_dwInstanceKey					= 0;
	this->m_dwCurrentUPnPDeviceID			= 0;
	this->m_hMappingStillActiveNamedObject	= NULL;

#ifndef DPNBUILD_NOWINSOCK2
	this->m_hIpHlpApiDLL					= NULL;
	this->m_pfnGetAdaptersInfo				= NULL;
	this->m_pfnGetIpForwardTable			= NULL;
	this->m_pfnGetBestRoute					= NULL;

	this->m_hRasApi32DLL					= NULL;
	this->m_pfnRasGetEntryHrasconnW			= NULL;
	this->m_pfnRasGetProjectionInfo			= NULL;

	this->m_sIoctls							= INVALID_SOCKET;
	this->m_polAddressListChange			= NULL;
#endif // ! DPNBUILD_NOWINSOCK2

	this->m_hWinSockDLL						= NULL;
	this->m_pfnWSAStartup					= NULL;
	this->m_pfnWSACleanup					= NULL;
	this->m_pfnWSAGetLastError				= NULL;
	this->m_pfnsocket						= NULL;
	this->m_pfnclosesocket					= NULL;
	this->m_pfnbind							= NULL;
	this->m_pfnsetsockopt					= NULL;
	this->m_pfngetsockname					= NULL;
	this->m_pfnselect						= NULL;
	this->m_pfn__WSAFDIsSet					= NULL;
	this->m_pfnrecvfrom						= NULL;
	this->m_pfnsendto						= NULL;
	this->m_pfngethostname					= NULL;
	this->m_pfngethostbyname				= NULL;
	this->m_pfninet_addr					= NULL;
#ifndef DPNBUILD_NOWINSOCK2
	this->m_pfnWSASocketA					= NULL;
	this->m_pfnWSAIoctl						= NULL;
	this->m_pfnWSAGetOverlappedResult		= NULL;
#endif // ! DPNBUILD_NOWINSOCK2
	this->m_pfnioctlsocket					= NULL;
	this->m_pfnconnect						= NULL;
	this->m_pfnshutdown						= NULL;
	this->m_pfnsend							= NULL;
	this->m_pfnrecv							= NULL;
#ifdef DBG
	this->m_pfngetsockopt					= NULL;

	this->m_dwNumDeviceAdds					= 0;
	this->m_dwNumDeviceRemoves				= 0;
	this->m_dwNumServerFailures				= 0;
#endif // DBG
} // CNATHelpUPnP::CNATHelpUPnP






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::~CNATHelpUPnP"
//=============================================================================
// CNATHelpUPnP destructor
//-----------------------------------------------------------------------------
//
// Description: Frees the CNATHelpUPnP object.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
CNATHelpUPnP::~CNATHelpUPnP(void)
{
	DPFX(DPFPREP, 8, "(0x%p) NumDeviceAdds = %u, NumDeviceRemoves = %u, NumServerFailures = %u",
		this, this->m_dwNumDeviceAdds, this->m_dwNumDeviceRemoves,
		this->m_dwNumServerFailures);


	DNASSERT(this->m_blList.IsEmpty());


	DNASSERT(this->m_lRefCount == 0);
	DNASSERT((this->m_dwFlags & ~NATHELPUPNPOBJ_NOTCREATEDWITHCOM) == 0);

	DNASSERT(this->m_hLongLockSemaphore == NULL);
	DNASSERT(this->m_lNumLongLockWaitingThreads == 0);
	DNASSERT(this->m_dwLockThreadID == 0);
#ifndef DPNBUILD_NOWINSOCK2
	DNASSERT(this->m_hAlertEvent == NULL);
	DNASSERT(this->m_hAlertIOCompletionPort == NULL);
#endif // ! DPNBUILD_NOWINSOCK2

	DNASSERT(this->m_blDevices.IsEmpty());
	DNASSERT(this->m_blRegisteredPorts.IsEmpty());
	DNASSERT(this->m_blUnownedPorts.IsEmpty());

	DNASSERT(this->m_dwNumLeases == 0);

	DNASSERT(this->m_blUPnPDevices.IsEmpty());
	DNASSERT(this->m_hMappingStillActiveNamedObject == NULL);

#ifndef DPNBUILD_NOWINSOCK2
	DNASSERT(this->m_hIpHlpApiDLL == NULL);
	DNASSERT(this->m_hRasApi32DLL == NULL);
	DNASSERT(this->m_hWinSockDLL == NULL);

	DNASSERT(this->m_sIoctls == INVALID_SOCKET);
	DNASSERT(this->m_polAddressListChange == NULL);
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// For grins, change the signature before deleting the object.
	//
	this->m_Sig[3]	= 'h';
} // CNATHelpUPnP::~CNATHelpUPnP




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::QueryInterface"
//=============================================================================
// CNATHelpUPnP::QueryInterface
//-----------------------------------------------------------------------------
//
// Description: Retrieves a new reference for an interfaces supported by this
//				CNATHelpUPnP object.
//
// Arguments:
//	REFIID riid			- Reference to interface ID GUID.
//	LPVOID * ppvObj		- Place to store pointer to object.
//
// Returns: HRESULT
//	S_OK					- Returning a valid interface pointer.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPOINTER	- The destination pointer is invalid.
//	E_NOINTERFACE			- Invalid interface was specified.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	HRESULT		hr = DPNH_OK;


	DPFX(DPFPREP, 3, "(0x%p) Parameters: (REFIID, 0x%p)", this, ppvObj);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid NATHelper object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((! IsEqualIID(riid, IID_IUnknown)) &&
		(! IsEqualIID(riid, IID_IDirectPlayNATHelp)))
	{
		DPFX(DPFPREP, 0, "Unsupported interface!");
		hr = E_NOINTERFACE;
		goto Failure;
	}

	if ((ppvObj == NULL) ||
		(IsBadWritePtr(ppvObj, sizeof(void*))))
	{
		DPFX(DPFPREP, 0, "Invalid interface pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}


	//
	// Add a reference, and return the interface pointer (which is actually
	// just the object pointer, they line up because CNATHelpUPnP inherits from
	// the interface declaration).
	//
	this->AddRef();
	(*ppvObj) = this;


Exit:

	DPFX(DPFPREP, 3, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::QueryInterface




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::AddRef"
//=============================================================================
// CNATHelpUPnP::AddRef
//-----------------------------------------------------------------------------
//
// Description: Adds a reference to this CNATHelpUPnP object.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CNATHelpUPnP::AddRef(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());


	//
	// There must be at least 1 reference to this object, since someone is
	// calling AddRef.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedIncrement(&this->m_lRefCount);

	DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);

	return lRefCount;
} // CNATHelpUPnP::AddRef




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::Release"
//=============================================================================
// CNATHelpUPnP::Release
//-----------------------------------------------------------------------------
//
// Description: Removes a reference to this CNATHelpUPnP object.  When the
//				refcount reaches 0, this object is destroyed.
//				You must NULL out your pointer to this object after calling
//				this function.
//
// Arguments: None.
//
// Returns: New refcount.
//=============================================================================
STDMETHODIMP_(ULONG) CNATHelpUPnP::Release(void)
{
	LONG	lRefCount;


	DNASSERT(this->IsValidObject());

	//
	// There must be at least 1 reference to this object, since someone is
	// calling Release.
	//
	DNASSERT(this->m_lRefCount > 0);

	lRefCount = InterlockedDecrement(&this->m_lRefCount);

	//
	// Was that the last reference?  If so, we're going to destroy this object.
	//
	if (lRefCount == 0)
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount hit 0, destroying object.", this);

		//
		// First pull it off the global list.
		//
		DNEnterCriticalSection(&g_csGlobalsLock);

		this->m_blList.RemoveFromList();

		DNASSERT(g_lOutstandingInterfaceCount > 0);
		g_lOutstandingInterfaceCount--;	// update count so DLL can unload now works correctly
		
		DNLeaveCriticalSection(&g_csGlobalsLock);


		//
		// Make sure it's closed.
		//
		if (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED)
		{
			//
			// Assert so that the user can fix his/her broken code!
			//
			DNASSERT(! "DirectPlayNATHelpUPNP object being released without calling Close first!");

			//
			// Then go ahead and do the right thing.  Ignore error, we can't do
			// much about it.
			//
			this->Close(0);
		}


		//
		// Then uninitialize the object.
		//
		this->UninitializeObject();

		//
		// Finally delete this (!) object.
		//
		delete this;
	}
	else
	{
		DPFX(DPFPREP, 3, "[0x%p] RefCount [0x%lx]", this, lRefCount);
	}

	return lRefCount;
} // CNATHelpUPnP::Release




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::Initialize"
//=============================================================================
// CNATHelpUPnP::Initialize
//-----------------------------------------------------------------------------
//
// Description:    Prepares the object for use.  No attempt is made to contact
//				any Internet gateway servers at this time.  The user should
//				call GetCaps with the DPNHGETCAPS_UPDATESERVERSTATUS flag to
//				search for a server.
//
//				   Initialize must be called before using any other function,
//				and must be balanced with a call to Close.  Initialize can only
//				be called once unless Close returns it to the uninitialized
//				state.
//
//				   One of DPNHINITIALIZE_DISABLEREMOTENATSUPPORT or
//				DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT may be specified,
//				but not both.
//
// Arguments:
//	DWORD dwFlags	- Flags to use when initializing.
//
// Returns: HRESULT
//	DPNH_OK						- Initialization was successful.
//	DPNHERR_ALREADYINITIALIZED	- Initialize has already been called.
//	DPNHERR_GENERIC				- An error occurred while initializing.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to initialize.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::Initialize(const DWORD dwFlags)
{
	HRESULT						hr;
	BOOL						fHaveLock = FALSE;
	BOOL						fSetFlags = FALSE;
#ifndef WINCE
	OSVERSIONINFO				osvi;
#endif // ! WINCE
	BOOL						fWinSockStarted = FALSE;
	WSADATA						wsadata;
	int							iError;
#ifndef DPNBUILD_NOWINSOCK2
	SOCKADDR_IN					saddrinTemp;
#endif // ! DPNBUILD_NOWINSOCK2
	TCHAR						tszObjectName[MAX_INSTANCENAMEDOBJECT_SIZE];
	PSECURITY_ATTRIBUTES		pSecurityAttributes;
	DWORD						dwTry;
#ifdef WINNT
	SID_IDENTIFIER_AUTHORITY	SidIdentifierAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
	PSID						pSid = NULL;
	DWORD						dwAclLength;
	ACL *						pAcl = NULL;
	BYTE						abSecurityDescriptorBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
	SECURITY_ATTRIBUTES			SecurityAttributes;
#endif // WINNT
#ifdef DBG
	DWORD						dwError;
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%lx)", this, dwFlags);


#ifndef WINCE
	//
	// Print info about the current build. 
	//
#ifdef WINNT
	DPFX(DPFPREP, 7, "Build type = NT, platform = %s",
		((DNGetOSType() == VER_PLATFORM_WIN32_NT) ? _T("NT") : _T("9x")));
#else // ! WINNT
	DPFX(DPFPREP, 7, "Build type = 9x, platform = %s, filedate = %s",
		((DNGetOSType() == VER_PLATFORM_WIN32_NT) ? _T("NT") : _T("9x")));
#endif // ! WINNT
#endif // ! WINCE


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Validate the parameters.
	//

	if (dwFlags & ~(DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}

	//
	// Both flags cannot be specified at the same time.  If the caller doesn't
	// want any NAT functionality, why use this object all?
	//
	if ((dwFlags & (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)) == (DPNHINITIALIZE_DISABLEGATEWAYSUPPORT | DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT))
	{
		DPFX(DPFPREP, 0, "Either DISABLEGATEWAYSUPPORT flag or DISABLELOCALFIREWALLSUPPORT flag can be used, but not both!");
		hr = DPNHERR_INVALIDFLAGS;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if ((this->m_dwFlags & ~NATHELPUPNPOBJ_NOTCREATEDWITHCOM) != 0)
	{
		DPFX(DPFPREP, 0, "Object already initialized!");
		hr = DPNHERR_ALREADYINITIALIZED;

		//
		// Skip the failure cleanup code, we haven't set anything up.
		//
		goto Exit;
	}


	//
	// Read in the manual override settings from the registry
	//
	ReadRegistrySettings();


	//
	// We're not completely initialized yet, but set the flag(s) now.
	//
	this->m_dwFlags |= NATHELPUPNPOBJ_INITIALIZED;
	fSetFlags = TRUE;


	//
	// Store the user's settings.
	//

	if (dwFlags & DPNHINITIALIZE_DISABLEGATEWAYSUPPORT)
	{
		DPFX(DPFPREP, 1, "User requested that Internet gateways not be supported.");
	}
	else
	{
		this->m_dwFlags |= NATHELPUPNPOBJ_USEUPNP;
	}

#ifndef DPNBUILD_NOHNETFWAPI
	if (dwFlags & DPNHINITIALIZE_DISABLELOCALFIREWALLSUPPORT)
	{
		DPFX(DPFPREP, 1, "User requested that local firewalls not be supported.");
	}
	else
	{
		this->m_dwFlags |= NATHELPUPNPOBJ_USEHNETFWAPI;
	}
#endif // ! DPNBUILD_NOHNETFWAPI


	switch (g_dwUPnPMode)
	{
		case OVERRIDEMODE_FORCEON:
		{
			//
			// Force UPnP on.
			//
			DPFX(DPFPREP, 1, "Forcing UPnP support on.");
			this->m_dwFlags |= NATHELPUPNPOBJ_USEUPNP;
			break;
		}

		case OVERRIDEMODE_FORCEOFF:
		{
			//
			// Force UPnP off.
			//
			DPFX(DPFPREP, 1, "Forcing UPnP support off.");
			this->m_dwFlags &= ~NATHELPUPNPOBJ_USEUPNP;
			break;
		}

		default:
		{
			//
			// Leave UPnP settings as they were set by the application.
			//
#ifdef WINNT
			//
			// But if UPnP related service(s) are disabled, we'll take that as
			// our cue to not use UPnP NAT traversal even though we don't
			// actually use those services.  We assume the user wanted to
			// squelch all SSDP/UPnP activity.  It can still be forced back on
			// with a reg key, though, as indicated by the other switch cases.
			//
			if (this->IsUPnPServiceDisabled())
			{
				DPFX(DPFPREP, 1, "Not using UPnP because a related service was disabled.");
				this->m_dwFlags &= ~NATHELPUPNPOBJ_USEUPNP;
			}
#endif // WINNT
			break;
		}
	}

#ifndef DPNBUILD_NOHNETFWAPI
	switch (g_dwHNetFWAPIMode)
	{
		case OVERRIDEMODE_FORCEON:
		{
			//
			// Force HNet firewall API on.
			//
			DPFX(DPFPREP, 1, "Forcing HNet firewall API support on.");
			this->m_dwFlags |= NATHELPUPNPOBJ_USEHNETFWAPI;
			break;
		}

		case OVERRIDEMODE_FORCEOFF:
		{
			//
			// Force HNet firewall API off.
			//
			DPFX(DPFPREP, 1, "Forcing HNet firewall API support off.");
			this->m_dwFlags &= ~NATHELPUPNPOBJ_USEHNETFWAPI;
			break;
		}

		default:
		{
			//
			// Leave HNet firewall API settings alone.
			//
			break;
		}
	}
#endif // ! DPNBUILD_NOHNETFWAPI


#ifndef WINCE
	//
	// Determine whether we're on a Win2K or higher NT OS, and if so, use the
	// "Global\\" prefix for named kernel objects so we can have Terminal
	// Server and Fast User Switching support.
	//
	ZeroMemory(&osvi, sizeof(osvi));
	osvi.dwOSVersionInfoSize = sizeof(osvi);
	if (GetVersionEx(&osvi))
	{
		if ((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
			(osvi.dwMajorVersion >= 5))
		{
			DPFX(DPFPREP, 8, "Running Win2K or higher NT OS, using \"Global\\\" prefix.");
			this->m_dwFlags |= NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX;
		}
#ifdef DBG
		else
		{
			DPFX(DPFPREP, 8, "Not on NT, or its pre-Win2K, not using \"Global\\\" prefix.");
		}
#endif // DBG
	}
#ifdef DBG
else
	{
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't get OS version information (err = %u)!  Not using \"Global\\\" prefix.",
			dwError);
	}
#endif // DBG
#endif // ! WINCE


#ifdef DPNBUILD_NOWINSOCK2
#if defined(WINCE) && !defined(WINCE_ON_DESKTOP)
	this->m_hWinSockDLL = LoadLibrary( _T("winsock.dll") );
#else // ! WINCE
	this->m_hWinSockDLL = LoadLibrary( _T("wsock32.dll") );
#endif // ! WINCE
	if (this->m_hWinSockDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't load WinSock 1 DLL (err = 0x%lx)!.",
			dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}
#else // ! DPNBUILD_NOWINSOCK2
	//
	// Try loading the IP helper DLL.
	//
	this->m_hIpHlpApiDLL = LoadLibrary( _T("iphlpapi.dll") );
	if (this->m_hIpHlpApiDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Unable to load \"iphlpapi.dll\" (error = 0x%lx).",
			dwError);
#endif // DBG

		//
		// That's not fatal, we can still function.
		//
	}
	else
	{
		//
		// Load the functions we'll use.
		//

		this->m_pfnGetAdaptersInfo = (PFN_GETADAPTERSINFO) GetProcAddress(this->m_hIpHlpApiDLL,
																		_TWINCE("GetAdaptersInfo"));
		if (this->m_pfnGetAdaptersInfo == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetAdaptersInfo\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}

		this->m_pfnGetIpForwardTable = (PFN_GETIPFORWARDTABLE) GetProcAddress(this->m_hIpHlpApiDLL,
																			_TWINCE("GetIpForwardTable"));
		if (this->m_pfnGetIpForwardTable == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetIpForwardTable\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}

		this->m_pfnGetBestRoute = (PFN_GETBESTROUTE) GetProcAddress(this->m_hIpHlpApiDLL,
																	_TWINCE("GetBestRoute"));
		if (this->m_pfnGetBestRoute == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Unable to get \"GetBestRoute\" function (error = 0x%lx)!",
				dwError);
#endif // DBG
			goto Exit;
		}
	}



	//
	// Try loading the RAS API DLL.
	//
	this->m_hRasApi32DLL = LoadLibrary( _T("rasapi32.dll") );
	if (this->m_hRasApi32DLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Unable to load \"rasapi32.dll\" (error = 0x%lx).",
			dwError);
#endif // DBG

		//
		// That's not fatal, we can still function.
		//
	}
	else
	{
		//
		// Load the functions we'll use.
		//

		this->m_pfnRasGetEntryHrasconnW = (PFN_RASGETENTRYHRASCONNW) GetProcAddress(this->m_hRasApi32DLL,
																					_TWINCE("RasGetEntryHrasconnW"));
		if (this->m_pfnRasGetEntryHrasconnW == NULL)
		{
			//
			// This function does not exist on non-NT platforms.  That's fine,
			// just dump the DLL handle so we don't try to use it.
			//
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 1, "Unable to get \"RasGetEntryHrasconnW\" function (error = 0x%lx), forgetting RAS DLL.",
				dwError);
#endif // DBG

			FreeLibrary(this->m_hRasApi32DLL);
			this->m_hRasApi32DLL = NULL;
		}
		else
		{
			this->m_pfnRasGetProjectionInfo = (PFN_RASGETPROJECTIONINFO) GetProcAddress(this->m_hRasApi32DLL,
#ifdef UNICODE
																						_TWINCE("RasGetProjectionInfoW"));
#else // ! UNICODE
																						_TWINCE("RasGetProjectionInfoA"));
#endif // ! UNICODE
			if (this->m_pfnRasGetProjectionInfo == NULL)
			{
#ifdef DBG
				dwError = GetLastError();
				DPFX(DPFPREP, 0, "Unable to get \"RasGetProjectionInfoA/W\" function (error = 0x%lx)!",
					dwError);
#endif // DBG
				goto Exit;
			}
		}
	}


	//
	// Load WinSock because we may be using our private UPnP implementation, or
	// we just need to get the devices.
	//
	this->m_hWinSockDLL = LoadLibrary( _T("ws2_32.dll") );
	if (this->m_hWinSockDLL == NULL)
	{
#ifdef DBG
		dwError = GetLastError();
		DPFX(DPFPREP, 1, "Couldn't load \"ws2_32.dll\" (err = 0x%lx), resorting to WinSock 1 functionality.",
			dwError);
#endif // DBG

		this->m_hWinSockDLL = LoadLibrary( _T("wsock32.dll") );
		if (this->m_hWinSockDLL == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't load \"wsock32.dll\" either (err = 0x%lx)!.",
				dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// Remember that we had to resort to WinSock 1.
		//
		this->m_dwFlags |= NATHELPUPNPOBJ_WINSOCK1;
	}
	else
	{
		DPFX(DPFPREP, 1, "Loaded \"ws2_32.dll\", using WinSock 2 functionality.");
	}
#endif // DPNBUILD_NOWINSOCK2


	//
	// Load pointers to all the functions we use in WinSock.
	//
	hr = this->LoadWinSockFunctionPointers();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't load WinSock function pointers!");
		goto Failure;
	}


	//
	// Fire up WinSock.  Request 2.2 if we can.  For the most part we only use
	// version 1.1 capabilities and interfaces anyway.  The only exceptions are
	// using the event or I/O completion port handles for notification.
	//
	ZeroMemory(&wsadata, sizeof(wsadata));

#ifndef DPNBUILD_NOWINSOCK2
	if (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1)
	{
#endif // ! DPNBUILD_NOWINSOCK2
		iError = this->m_pfnWSAStartup(MAKEWORD(1, 1), &wsadata);
#ifndef DPNBUILD_NOWINSOCK2
	}
	else
	{
		iError = this->m_pfnWSAStartup(MAKEWORD(2, 2), &wsadata);
	}
#endif // ! DPNBUILD_NOWINSOCK2
	if (iError != 0)
	{
		DPFX(DPFPREP, 0, "Couldn't startup WinSock (error = %i)!", iError);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	fWinSockStarted = TRUE;

	DPFX(DPFPREP, 4, "Initialized WinSock version %u.%u.",
		LOBYTE(wsadata.wVersion), HIBYTE(wsadata.wVersion));



#ifndef DPNBUILD_NOWINSOCK2
	//
	// Try creating a UDP socket for use with WSAIoctl.  Do this even if we're
	// WinSock 1 and can't use WSAIoctl socket.  This allows us to make sure
	// TCP/IP is installed and working.
	//

	this->m_sIoctls = this->m_pfnsocket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	if (this->m_sIoctls == INVALID_SOCKET)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't create Ioctl socket, error = %u!", dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Try binding the socket.  This is a continuation of the validation.
	//
	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	//saddrinTemp.sin_addr.S_un.S_addr	= INADDR_ANY;
	//saddrinTemp.sin_port				= 0;

	if (this->m_pfnbind(this->m_sIoctls,
						(SOCKADDR *) (&saddrinTemp),
						sizeof(saddrinTemp)) != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't bind the Ioctl socket to arbitrary port on any interface, error = %u!",
			dwError);
#endif // DBG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// Build appropriate access control structures.  On NT, we want to allow
	// read access to everyone.  On other platforms, security is ignored.
	//
#ifdef WINNT
	if (! AllocateAndInitializeSid(&SidIdentifierAuthorityWorld,
									1,
									SECURITY_WORLD_RID,
									0,
									0,
									0,
									0,
									0,
									0,
									0,
									&pSid))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't allocate and initialize SID, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	dwAclLength = sizeof(ACL)
					+ sizeof(ACCESS_ALLOWED_ACE)
					- sizeof(DWORD)					// subtract out sizeof(ACCESS_ALLOWED_ACE.SidStart)
					+ GetLengthSid(pSid);

	pAcl = (ACL*) DNMalloc(dwAclLength);
	if (pAcl == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	if (! InitializeAcl(pAcl, dwAclLength, ACL_REVISION))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't initialize ACL, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (! AddAccessAllowedAce(pAcl, ACL_REVISION, SYNCHRONIZE, pSid))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't add access allowed ACE, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (! InitializeSecurityDescriptor((PSECURITY_DESCRIPTOR) abSecurityDescriptorBuffer,
										SECURITY_DESCRIPTOR_REVISION))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't initialize security descriptor, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if (! SetSecurityDescriptorDacl((PSECURITY_DESCRIPTOR) abSecurityDescriptorBuffer,
									TRUE,
									pAcl,
									FALSE))
	{
#ifdef DEBUG
		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't set security descriptor DACL, error = %u!",
			dwError);
#endif // DEBUG
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	SecurityAttributes.nLength					= sizeof(SecurityAttributes);
	SecurityAttributes.lpSecurityDescriptor		= abSecurityDescriptorBuffer;
	SecurityAttributes.bInheritHandle			= FALSE;

	pSecurityAttributes = &SecurityAttributes;
#else // ! WINNT
	pSecurityAttributes = NULL;
#endif // ! WINNT


	//
	// Use a random number for the instance key and event.  We use this to let
	// other instances know that we're alive to avoid the crash-cleanup code.
	// Try to create the named event a couple times before giving up.
	//
	dwTry = 0;
	do
	{
		this->m_dwInstanceKey = GetGlobalRand();
		DPFX(DPFPREP, 2, "Using crash cleanup key %u.", this->m_dwInstanceKey);

#ifndef WINCE
		if (this->m_dwFlags & NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX)
		{
			wsprintf(tszObjectName, _T("Global\\") INSTANCENAMEDOBJECT_FORMATSTRING, this->m_dwInstanceKey);
			this->m_hMappingStillActiveNamedObject = DNCreateEvent(pSecurityAttributes, FALSE, FALSE, tszObjectName);
		}
		else
#endif // ! WINCE
		{
			wsprintf(tszObjectName, INSTANCENAMEDOBJECT_FORMATSTRING, this->m_dwInstanceKey);
			this->m_hMappingStillActiveNamedObject = DNCreateEvent(pSecurityAttributes, FALSE, FALSE, tszObjectName);
		}

		if (this->m_hMappingStillActiveNamedObject == NULL)
		{
#ifdef DBG
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't create mapping-still-active named object, error = %u!", dwError);
#endif // DBG

			dwTry++;
			if (dwTry >= MAX_NUM_INSTANCE_EVENT_ATTEMPTS)
			{
				hr = DPNHERR_GENERIC;
				goto Failure;
			}

			//
			// Continue...
			//
		}
	}
	while (this->m_hMappingStillActiveNamedObject == NULL);

#ifdef WINNT
	DNFree(pAcl);
	pAcl = NULL;

	FreeSid(pSid);
	pSid = NULL;
#endif // WINNT


	//
	// Build the list of IP capable devices.
	//
	hr = this->CheckForNewDevices(NULL);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't build device list!");
		goto Failure;
	}


	//
	// We could technically try to contact UPnP devices right now, but we don't
	// because it's a slow blocking operation, and users have to call GetCaps
	// at least once anyway.
	//


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (this->m_hMappingStillActiveNamedObject != NULL)
	{
		DNCloseHandle(this->m_hMappingStillActiveNamedObject);
		this->m_hMappingStillActiveNamedObject = NULL;
	}

#ifdef WINNT
	if (pAcl != NULL)
	{
		DNFree(pAcl);
		pAcl = NULL;
	}

	if (pSid != NULL)
	{
		FreeSid(pSid);
		pSid = NULL;
	}
#endif // WINNT

	this->RemoveAllItems();

#ifndef DPNBUILD_NOWINSOCK2
	if (this->m_sIoctls != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(this->m_sIoctls);	// ignore error
		this->m_sIoctls = INVALID_SOCKET;
	}
#endif // ! DPNBUILD_NOWINSOCK2

	if (fWinSockStarted)
	{
		this->m_pfnWSACleanup(); // ignore error
	}

#ifndef DPNBUILD_NOWINSOCK2
	if (this->m_hWinSockDLL != NULL)
	{
		this->m_pfnWSAStartup				= NULL;
		this->m_pfnWSACleanup				= NULL;
		this->m_pfnWSAGetLastError			= NULL;
		this->m_pfnsocket					= NULL;
		this->m_pfnclosesocket				= NULL;
		this->m_pfnbind						= NULL;
		this->m_pfnsetsockopt				= NULL;
		this->m_pfngetsockname				= NULL;
		this->m_pfnselect					= NULL;
		this->m_pfn__WSAFDIsSet				= NULL;
		this->m_pfnrecvfrom					= NULL;
		this->m_pfnsendto					= NULL;
		this->m_pfngethostname				= NULL;
		this->m_pfngethostbyname			= NULL;
		this->m_pfninet_addr				= NULL;
		this->m_pfnWSASocketA				= NULL;
		this->m_pfnWSAIoctl					= NULL;
		this->m_pfnWSAGetOverlappedResult	= NULL;
		this->m_pfnioctlsocket				= NULL;
		this->m_pfnconnect					= NULL;
		this->m_pfnshutdown					= NULL;
		this->m_pfnsend						= NULL;
		this->m_pfnrecv						= NULL;
#ifdef DBG
		this->m_pfngetsockopt				= NULL;
#endif // DBG


		this->m_dwFlags &= ~NATHELPUPNPOBJ_WINSOCK1;

		FreeLibrary(this->m_hWinSockDLL);
		this->m_hWinSockDLL = NULL;
	}

	if (this->m_hRasApi32DLL != NULL)
	{
		this->m_pfnRasGetEntryHrasconnW		= NULL;
		this->m_pfnRasGetProjectionInfo		= NULL;

		FreeLibrary(this->m_hRasApi32DLL);
		this->m_hRasApi32DLL = NULL;
	}

	if (this->m_hIpHlpApiDLL != NULL)
	{
		this->m_pfnGetAdaptersInfo			= NULL;
		this->m_pfnGetIpForwardTable		= NULL;
		this->m_pfnGetBestRoute				= NULL;

		FreeLibrary(this->m_hIpHlpApiDLL);
		this->m_hIpHlpApiDLL = NULL;
	}
#endif // ! DPNBUILD_NOWINSOCK2

	if (fSetFlags)
	{
		this->m_dwFlags &= ~(NATHELPUPNPOBJ_INITIALIZED |
							NATHELPUPNPOBJ_USEUPNP |
#ifndef DPNBUILD_NOHNETFWAPI
							NATHELPUPNPOBJ_USEHNETFWAPI |
#endif // ! DPNBUILD_NOHNETFWAPI
#ifdef WINCE
							NATHELPUPNPOBJ_DEVICECHANGED);
#else // ! WINCE
							NATHELPUPNPOBJ_DEVICECHANGED |
							NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX);
#endif // ! WINCE
	}

	goto Exit;
} // CNATHelpUPnP::Initialize






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::Close"
//=============================================================================
// CNATHelpUPnP::Close
//-----------------------------------------------------------------------------
//
// Description:    Shuts down and de-registers this application with any
//				Internet gateway servers.  All port assignments are implicitly
//				freed as a result of this operation.
//
//				   This must balance a successful call to Initialize.
//
// Arguments:
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- Closing the helper API was successful.
//	DPNHERR_GENERIC			- An error occurred while closing.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to close.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::Close(const DWORD dwFlags)
{
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;
	int			iError;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%lx)", this, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// We need to actively deregister any devices which are registered with
	// Internet gateways.
	//
	this->RemoveAllItems();


	//
	// Close the named object since this process is going away.
	//
	if (this->m_hMappingStillActiveNamedObject != NULL)
	{
		DNCloseHandle(this->m_hMappingStillActiveNamedObject);
		this->m_hMappingStillActiveNamedObject = NULL;
	}


#ifndef DPNBUILD_NOWINSOCK2
	//
	// Close the Ioctl socket.
	//
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	this->m_pfnclosesocket(this->m_sIoctls);	// ignore error
	this->m_sIoctls = INVALID_SOCKET;



	//
	// If we submitted overlapped I/O, see if it got cancelled.
	//
	if (this->m_polAddressListChange != NULL)
	{
		OSVERSIONINFO		osvi;
		OSVERSIONINFOEX		osvix;
		BOOL				fCanWait;
		DWORD				dwAttempt;


		ZeroMemory(&osvi, sizeof(osvi));
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		if (GetVersionEx(&osvi))
		{
			//
			// Any platform but Win2K Gold, Win2K + SP1, or Win2K + SP2 can
			// just go ahead and wait for the I/O to complete.
			//
			if ((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) ||
				(osvi.dwMajorVersion > 5) ||
				(osvi.dwMinorVersion > 0))
			{
				DPFX(DPFPREP, 3, "Windows %s version %u.%u detected, waiting for address list change Ioctl to complete.",
					((osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) ? _T("9x") : _T("NT")),
					osvi.dwMajorVersion, osvi.dwMinorVersion);

				fCanWait = TRUE;
			}
			else
			{
				//
				// Win2K versions < SP3 have a bug where the I/O is not always
				// cancelled by closing the socket.  We can't wait for the
				// completion, sometimes it doesn't happen.
				//

				fCanWait = FALSE;

				ZeroMemory(&osvix, sizeof(osvix));
				osvix.dwOSVersionInfoSize = sizeof(osvix);

				if (GetVersionEx((LPOSVERSIONINFO) (&osvix)))
				{
					//
					// If SP3 or later is applied, we know it's fixed.
					//
					if (osvix.wServicePackMajor >= 3)
					{
						DPFX(DPFPREP, 3, "Windows 2000 Service Pack %u detected, waiting for address list change Ioctl to complete.",
							osvix.wServicePackMajor);
						fCanWait = TRUE;
					}
#ifdef DBG
					else
					{
						if (osvix.wServicePackMajor == 0)
						{
							DPFX(DPFPREP, 2, "Windows 2000 Gold detected, not waiting for address list change Ioctl to complete.");
						}
						else
						{
							DPFX(DPFPREP, 2, "Windows 2000 Service Pack %u detected, not waiting for address list change Ioctl to complete.",
								osvix.wServicePackMajor);
						}
					}
#endif // DBG
				}
#ifdef DBG
				else
				{
					dwError = GetLastError();
					DPFX(DPFPREP, 0, "Couldn't get extended OS version information (err = %u)!  Assuming not Win2K < SP3.",
						dwError);
				}
#endif // DBG
			}


			//
			// Wait, if we can.  Otherwise, leak the memory.
			//
			if (fCanWait)
			{
				//
				// Keep looping until I/O completes.  We will give up after a
				// while to prevent hangs.
				//
				dwAttempt = 0;
				while (! HasOverlappedIoCompleted(this->m_polAddressListChange))
				{
					DPFX(DPFPREP, 2, "Waiting %u ms for address list change Ioctl to complete.",
						IOCOMPLETE_WAIT_INTERVAL);

					//
					// Give the OS some time to complete it.
					//
					Sleep(IOCOMPLETE_WAIT_INTERVAL);

					dwAttempt++;

					if (dwAttempt >= MAX_NUM_IOCOMPLETE_WAITS)
					{
						break;
					}
				}
			}
			else
			{
				//
				// Just leak the memory.  See above notes and debug print
				// statements
				//
			}
		}
#ifdef DBG
		else
		{
			dwError = GetLastError();
			DPFX(DPFPREP, 0, "Couldn't get OS version information (err = %u)!  Assuming not Win2K < SP3.",
				dwError);
		}
#endif // DBG


		//
		// We've either freed the memory or committed to leaking the object.
		//
		if (HasOverlappedIoCompleted(this->m_polAddressListChange))
		{
			//
			// We didn't allocate it through DNMalloc, use the matching free
			// function.
			//
			HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		}
		else
		{
			DPFX(DPFPREP, 1, "Overlapped address list change Ioctl has not completed yet, leaking %u byte overlapped structure at 0x%p.",
				sizeof(WSAOVERLAPPED), this->m_polAddressListChange);
		}

		this->m_polAddressListChange = NULL;
	}
#endif // ! DPNBUILD_NOWINSOCK2



	//
	// Cleanup WinSock.
	//
	iError = this->m_pfnWSACleanup();
	if (iError != 0)
	{
#ifdef DBG
		dwError = this->m_pfnWSAGetLastError();
		DPFX(DPFPREP, 0, "Couldn't cleanup WinSock (error = %u)!", dwError);
#endif // DBG

		//
		// Continue anyway, so we can finish cleaning up the object.
		//
	}


	//
	// Unload the library.
	//

	this->m_pfnWSAStartup				= NULL;
	this->m_pfnWSACleanup				= NULL;
	this->m_pfnWSAGetLastError			= NULL;
	this->m_pfnsocket					= NULL;
	this->m_pfnclosesocket				= NULL;
	this->m_pfnbind						= NULL;
	this->m_pfnsetsockopt				= NULL;
	this->m_pfngetsockname				= NULL;
	this->m_pfnselect					= NULL;
	this->m_pfn__WSAFDIsSet				= NULL;
	this->m_pfnrecvfrom					= NULL;
	this->m_pfnsendto					= NULL;
	this->m_pfngethostname				= NULL;
	this->m_pfngethostbyname			= NULL;
	this->m_pfninet_addr				= NULL;
#ifndef DPNBUILD_NOWINSOCK2
	this->m_pfnWSASocketA				= NULL;
	this->m_pfnWSAIoctl					= NULL;
	this->m_pfnWSAGetOverlappedResult	= NULL;
#endif // ! DPNBUILD_NOWINSOCK2
	this->m_pfnioctlsocket				= NULL;
	this->m_pfnconnect					= NULL;
	this->m_pfnshutdown					= NULL;
	this->m_pfnsend						= NULL;
	this->m_pfnrecv						= NULL;
#ifdef DBG
	this->m_pfngetsockopt				= NULL;
#endif // DBG


	FreeLibrary(this->m_hWinSockDLL);
	this->m_hWinSockDLL = NULL;


#ifndef DPNBUILD_NOWINSOCK2
	//
	// If we loaded RASAPI32.DLL, unload it.
	//
	if (this->m_hRasApi32DLL != NULL)
	{
		this->m_pfnRasGetEntryHrasconnW		= NULL;
		this->m_pfnRasGetProjectionInfo		= NULL;

		FreeLibrary(this->m_hRasApi32DLL);
		this->m_hRasApi32DLL = NULL;
	}


	//
	// If we loaded IPHLPAPI.DLL, unload it.
	//
	if (this->m_hIpHlpApiDLL != NULL)
	{
		this->m_pfnGetAdaptersInfo			= NULL;
		this->m_pfnGetIpForwardTable		= NULL;
		this->m_pfnGetBestRoute				= NULL;

		FreeLibrary(this->m_hIpHlpApiDLL);
		this->m_hIpHlpApiDLL = NULL;
	}


	//
	// If there was an alert event, we're done with it.
	//
	if (this->m_hAlertEvent != NULL)
	{
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;
	}

	//
	// If there was an alert I/O completion port, we're done with it.
	//
	if (this->m_hAlertIOCompletionPort != NULL)
	{
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;
	}
#endif // ! DPNBUILD_NOWINSOCK2


	//
	// Turn off flags which should reset it back to 0 or just the
	// NOTCREATEDWITHCOM flag.
	//
	this->m_dwFlags &= ~(NATHELPUPNPOBJ_INITIALIZED |
						NATHELPUPNPOBJ_USEUPNP |
#ifndef DPNBUILD_NOHNETFWAPI
						NATHELPUPNPOBJ_USEHNETFWAPI |
#endif // ! DPNBUILD_NOHNETFWAPI
#ifndef DPNBUILD_NOWINSOCK2
						NATHELPUPNPOBJ_WINSOCK1 |
#endif // ! DPNBUILD_NOWINSOCK2
						NATHELPUPNPOBJ_DEVICECHANGED |
						NATHELPUPNPOBJ_ADDRESSESCHANGED |
#ifdef WINCE
						NATHELPUPNPOBJ_PORTREGISTERED);
#else // ! WINCE
						NATHELPUPNPOBJ_PORTREGISTERED |
						NATHELPUPNPOBJ_USEGLOBALNAMESPACEPREFIX);
#endif // ! WINCE
	DNASSERT((this->m_dwFlags & ~NATHELPUPNPOBJ_NOTCREATEDWITHCOM) == 0);


	this->DropLock();
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::Close





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetCaps"
//=============================================================================
// CNATHelpUPnP::GetCaps
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the capabilities of the Internet gateway server(s)
//				and information on leased ports.  This function should be
//				called periodically with the DPNHGETCAPS_UPDATESERVERSTATUS
//				flag to automatically extend port leases that are about to
//				expire (that are in last 2 minutes of their lease).
//
//				   The DPNHGETCAPS_UPDATESERVERSTATUS flag also causes
//				detection of changes in the servers' status since the last
//				similar call to GetCaps.  If a new server becomes available, an
//				existing one became unavailable, or a server's public address
//				changed in a way that affects an existing registered port
//				mapping, then DPNHSUCCESS_ADDRESSESCHANGED is returned instead
//				of DPNH_OK.  The user should then update its port binding
//				information via GetRegisteredAddresses.
//
//				   When DPNHGETCAPS_UPDATESERVERSTATUS is specified, this
//				function may block for a short period of time while attempts
//				are made to communicate with the server(s).
//
//				   GetCaps must be called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once prior to
//				using the GetRegisteredAddresses or QueryAddress methods.
//
// Arguments:
//	DPNHCAPS * pdpnhcaps	- Pointer to structure to be filled with the NAT
//								helper's current capabilities.  The dwSize
//								field of the structure must be filled in before
//								calling GetCaps.
//	DWORD dwFlags			- Flags to use when retrieving capabilities
//								(DPNHGETCAPS_xxx).
//
// Returns: HRESULT
//	DPNH_OK							- Determining capabilities was successful.
//										Address status has not changed.
//	DPNHSUCCESS_ADDRESSESCHANGED	- One or more of the registered port
//										mappings' addresses changed, retrieve
//										updated mappings with
//										GetRegisteredAddress.
//	DPNHERR_GENERIC					- An error occurred while determining
//										capabilities.
//	DPNHERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT			- The interface object is invalid.
//	DPNHERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER			- An invalid pointer was specified.
//	DPNHERR_NOTINITIALIZED			- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY				- There is not enough memory to get
//										capabilities.
//	DPNHERR_REENTRANT				- The interface has been re-entered on the
//										same thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::GetCaps(DPNHCAPS * const pdpnhcaps,
									const DWORD dwFlags)
{
	HRESULT				hr;
	BOOL				fHaveLock = FALSE;
	DWORD				dwCurrentTime;
	DWORD				dwLeaseTimeRemaining;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	CUPnPDevice *		pUPnPDevice = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)",
		this, pdpnhcaps, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if ((pdpnhcaps == NULL) ||
		(IsBadWritePtr(pdpnhcaps, sizeof(DPNHCAPS))))
	{
		DPFX(DPFPREP, 0, "Invalid caps structure pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pdpnhcaps->dwSize != sizeof(DPNHCAPS))
	{
		DPFX(DPFPREP, 0, "Invalid caps structure specified, dwSize must be %u!",
			sizeof(DPNHCAPS));
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags & ~DPNHGETCAPS_UPDATESERVERSTATUS)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// Fill in the base caps structure.
	//

	pdpnhcaps->dwFlags = 0;

	pdpnhcaps->dwNumRegisteredPorts = 0;

	pdpnhcaps->dwMinLeaseTimeRemaining = -1;

	//
	// pdpnhcaps->dwRecommendedGetCapsInterval is initialized below
	//


	if (dwFlags & DPNHGETCAPS_UPDATESERVERSTATUS)
	{
		//
		// Remove any cached mappings that have expired.
		//
		this->ExpireOldCachedMappings();


		//
		// Extend leases, if necessary.
		//
		hr = this->ExtendAllExpiringLeases();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Extending all expiring leases failed!");
			goto Failure;
		}


		//
		// Check for any new devices.
		//
		hr = this->CheckForNewDevices(NULL);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Checking for new devices failed!");
			goto Failure;
		}


		//
		// Check for possible changes in any server's status.  The
		// ADDRESSESCHANGED flag will be set on this object if there were
		// changes that affected existing port mappings.
		//
		hr = this->UpdateServerStatus();
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Updating servers' status failed!");
			goto Failure;
		}


		//
		// Okay, so if things are different, alert the caller.
		//
		if (this->m_dwFlags & NATHELPUPNPOBJ_ADDRESSESCHANGED)
		{
			hr = DPNHSUCCESS_ADDRESSESCHANGED;
			this->m_dwFlags &= ~NATHELPUPNPOBJ_ADDRESSESCHANGED;
		}


#ifdef DBG
		//
		// This flag should have been turned off by now if it ever got turned
		// on.
		//
		DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_DEVICECHANGED));


		//
		// Print the current device and mapping status for debugging purposes.
		//
		this->DebugPrintCurrentStatus();
#endif // DBG
	}
	else
	{
		//
		// Not extending expiring leases or updating server status.
		//
	}


	//
	// Loop through all the devices, getting their gateway capabilities.
	//
	pBilink = this->m_blDevices.GetNext();
	while (pBilink != (&this->m_blDevices))
	{
		DNASSERT(! pBilink->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilink);

#ifndef DPNBUILD_NOHNETFWAPI
		if (pDevice->IsHNetFirewalled())
		{
			//
			// The firewall does not actively notify you of it going down.
			//
			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_LOCALFIREWALLPRESENT | DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE | DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			DNASSERT(pUPnPDevice->IsReady());

			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_GATEWAYPRESENT;

			if (pUPnPDevice->IsLocal())
			{
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_GATEWAYISLOCAL;
			}

			if (pUPnPDevice->GetExternalIPAddressV4() != 0)
			{
				pdpnhcaps->dwFlags |= DPNHCAPSFLAG_PUBLICADDRESSAVAILABLE;
			}

			//
			// The custom UPnP stack currently does not support active
			// notification...
			//
			pdpnhcaps->dwFlags |= DPNHCAPSFLAG_NOTALLSUPPORTACTIVENOTIFY;
		}

		pBilink = pBilink->GetNext();
	}


	//
	// Loop through all registered ports, counting them.
	// We have the appropriate lock.
	//
	pBilink = this->m_blRegisteredPorts.GetNext();
	dwCurrentTime = GETTIMESTAMP();

	while (pBilink != (&this->m_blRegisteredPorts))
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		//
		// Count these registered addresses toward the total.
		//
		pdpnhcaps->dwNumRegisteredPorts += pRegisteredPort->GetNumAddresses();


		pDevice = pRegisteredPort->GetOwningDevice();
		if (pDevice != NULL)
		{
			DNASSERT(! (pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts)));

			//
			// If they're registered with any UPnP devices using a non-
			// permanent lease, calculate the minimum lease time remaining.
			//

			if ((pRegisteredPort->HasUPnPPublicAddresses()) &&
				(! pRegisteredPort->HasPermanentUPnPLease()))
			{
				dwLeaseTimeRemaining = pRegisteredPort->GetUPnPLeaseExpiration() - dwCurrentTime;
				if (dwLeaseTimeRemaining < pdpnhcaps->dwMinLeaseTimeRemaining)
				{
					//
					// Temporarily store how much time remains.
					//
					pdpnhcaps->dwMinLeaseTimeRemaining = dwLeaseTimeRemaining;
				}
			}
		}
		else
		{
			DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
		}

		pBilink = pBilink->GetNext();
	}


	//
	// There are different default recommended GetCaps intervals depending on
	// whether there's a server present, and whether it supports active address
	// change notification (that we can alert on) or not.
	//
	// If there are any leases which need to be renewed before that default
	// time, the recommendation will be shortened appropriately.
	//

	//
	// If GetCaps hasn't been called with UPDATESERVERSTATUS yet, recommend an
	// immediate check.
	//
	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 1, "Server status has not been updated yet, recommending immediate GetCaps.");

		//
		// Drop the lock, we're done here.
		//
		this->DropLock();
		fHaveLock = FALSE;

		goto Exit;
	}


	//
	// In an ideal world, we could get notified of changes and we would never
	// have to poll.  Unfortunately that isn't the case.  We need to recommend
	// a relatively short poll interval.
	//
	// Start by figuring out how long it's been since the last server update.
	// This calculation really should not go negative.  If it does, it means
	// the caller hasn't updated the server status in ages anyway, so we should
	// recommend immediate GetCaps.
	//
	// Otherwise if the 'port registered' flag is still set at this point, then
	// the user must have called GetCaps previously, then RegisterPorts, then
	// made this second GetCaps call before g_dwMinUpdateServerStatusInterval
	// elapsed.  Recommend that the user call us again as soon as the minimum
	// update interval does elapse.
	//
	// In all other cases, generate a recommendation based on the current
	// backed off poll interval.
	//
	dwCurrentTime = dwCurrentTime - this->m_dwLastUpdateServerStatusTime;

	if ((int) dwCurrentTime < 0)
	{
		DPFX(DPFPREP, 1, "Server status was last updated a really long time ago (%u ms), recommending immediate GetCaps.",
			dwCurrentTime);
		pdpnhcaps->dwRecommendedGetCapsInterval = 0;
	}
	else if (this->m_dwFlags & NATHELPUPNPOBJ_PORTREGISTERED)
	{
		DPFX(DPFPREP, 1, "Didn't handle new port registration because server was last updated %u ms ago, (poll interval staying at %u ms).",
			dwCurrentTime, this->m_dwNextPollInterval);

		pdpnhcaps->dwRecommendedGetCapsInterval = g_dwMinUpdateServerStatusInterval - dwCurrentTime;
		if ((int) pdpnhcaps->dwRecommendedGetCapsInterval < 0)
		{
			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
	}
	else
	{
		DPFX(DPFPREP, 7, "Server was last updated %u ms ago, current poll interval is %u ms.",
			dwCurrentTime, this->m_dwNextPollInterval);

		//
		// Calculate a new recommended interval based on the current value, and
		// backoff that interval if necessary.
		//
		pdpnhcaps->dwRecommendedGetCapsInterval = this->m_dwNextPollInterval - dwCurrentTime;
		this->m_dwNextPollInterval += GetGlobalRand() % g_dwPollIntervalBackoff;
		if (this->m_dwNextPollInterval > g_dwMaxPollInterval)
		{
			this->m_dwNextPollInterval = g_dwMaxPollInterval;
			DPFX(DPFPREP, 3, "Capping next poll interval at %u ms.",
				this->m_dwNextPollInterval);
		}
		else
		{
			DPFX(DPFPREP, 8, "Next poll interval will be %u ms.",
				this->m_dwNextPollInterval);
		}


		//
		// If that time went negative, then it implies that the interval has
		// already elapsed.  Recommend immediate GetCaps.
		//
		if (((int) pdpnhcaps->dwRecommendedGetCapsInterval) < 0)
		{
			DPFX(DPFPREP, 1, "Recommended interval already elapsed (%i ms), suggesting immediate GetCaps.",
				((int) pdpnhcaps->dwRecommendedGetCapsInterval));
			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
	}


	this->DropLock();
	fHaveLock = FALSE;


	//
	// If there is a non-INFINITE lease time remaining, see if that affects the
	// GetCaps interval.
	//
	if (pdpnhcaps->dwMinLeaseTimeRemaining != -1)
	{
		//
		// If there are leases that need to be refreshed before the default
		// recommendation, then use those instead.
		//
		if (pdpnhcaps->dwMinLeaseTimeRemaining < LEASE_RENEW_TIME)
		{
			DPFX(DPFPREP, 1, "Lease needs renewing right away (min %u < %u ms), recommending immediate GetCaps.",
				pdpnhcaps->dwMinLeaseTimeRemaining, LEASE_RENEW_TIME);

			pdpnhcaps->dwRecommendedGetCapsInterval = 0;
		}
		else
		{
			//
			// Either pick the time when the lease should be renewed or leave
			// it as the recommended time, whichever is shorter.
			//
			if ((pdpnhcaps->dwMinLeaseTimeRemaining - LEASE_RENEW_TIME) < pdpnhcaps->dwRecommendedGetCapsInterval)
			{
				pdpnhcaps->dwRecommendedGetCapsInterval = pdpnhcaps->dwMinLeaseTimeRemaining - LEASE_RENEW_TIME;
			}
		}
	}


	DPFX(DPFPREP, 7, "GetCaps flags = 0x%lx, num registered ports = %u, min lease time remaining = %i, recommended interval = %i.",
		pdpnhcaps->dwFlags,
		pdpnhcaps->dwNumRegisteredPorts,
		((int) pdpnhcaps->dwMinLeaseTimeRemaining),
		((int) pdpnhcaps->dwRecommendedGetCapsInterval));


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::GetCaps





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::RegisterPorts"
//=============================================================================
// CNATHelpUPnP::RegisterPorts
//-----------------------------------------------------------------------------
//
// Description:    Asks for public realm port(s) that are aliases for the local
//				port(s) on this private realm node.  If a server is available,
//				all traffic directed to the gateway on the public side at the
//				allocated public ports-- which the gateway provides and
//				specifies in the response-- will be directed to the specified
//				local ports.  If the DPNHREGISTERPORTS_FIXEDPORTS flag is not
//				specified, the ports assigned on the public interface are
//				arbitrary (i.e. may not be the same as those in awLocalPort).
//				The address and ports actually allocated can be retrieved by
//				calling GetRegisteredAddresses.
//
//				   The address component for every SOCKADDR structure in the
//				array must be the same.  A separate RegisterPorts call is
//				required to register multiple ports that are not using the same
//				interface.  The address can be INADDR_ANY, in which case the
//				"best" server will be used.  If multiple servers are available
//				via different adapters, an adapter with an Internet gateway is
//				selected.  If no adapters have Internet gateways, the first
//				adapter with a local firewall is selected.  If neither are
//				available, then the first one where either a gateway or a
//				firewall becomes available will be automatically selected.
//				Once one of the adapters has been assigned, it cannot be
//				changed.  Since the server chosen by this method may not be
//				optimal for a particular application, it is recommended that
//				individual addresses be registered instead of INADDR_ANY.
//
//				   If the address in aLocalAddresses is not one of those
//				available to the local machine, the registration will still
//				succeed.  If an adapter with that address becomes available,
//				the port mapping will automatically be applied, and it will
//				gain a public mapping with any server available to that
//				adapter.  If the address was originally available but the
//				network adapter is subsequently removed from the system, any
//				public address mapping is lost.  It will be automatically
//				regained if the local address becomes available again.  It is
//				recommended that the caller detect local address changes
//				independently and de-register/re-register mappings per adapter
//				as appropriate for maximum control.
//
//				   If the DPNHREGISTERPORTS_SHAREDPORTS flag is used, the
//				server will allow other NAT clients to register it as well.
//				Any UDP traffic received on the public interface will be
//				forwarded to all clients registered.  This requires the
//				DPNHREGISTERPORTS_FIXEDPORTS flag and cannot be used with
//				DPNHREGISTERPORTS_TCP.
//
//				   The user should specify a requested lease time that the
//				server will attempt to honor.  The actual time remaining can be
//				can be retrieved by calling GetRegisteredAddresses.
//
//				   Note that if a server is not available, this function will
//				still succeed. GetRegisteredAddresses will return
//				DPNHERR_NOMAPPING for the handle returned in phRegisteredPorts
//				in that case.  If the server arrives later during the session,
//				calling GetCaps periodically can detect this and automatically
//				map previously registered ports.  Use GetRegisteredAddresses to
//				retrieve the newly mapped address when that occurs.
//
//				   Only 16 ports may be registered at a time, but RegisterPorts
//				may be called as many times as desired.
//
//				   The same array of addresses may be registered more than
//				once.  Each DPNHHANDLE returned must be released with
//				DeregisterPorts or Close.  If an individual address was
//				previously registered but in a different array or a different
//				order in the array, then the DPNHERR_PORTALREADYREGISTERED
//				error code is returned.
//
// Arguments:
//	SOCKADDR * aLocalAddresses		- Array of local address and port tuples
//										for which remote ports are requested.
//	DWORD dwAddressesSize			- Size of entire local addresses array.
//	DWORD dwNumAddresses			- Number of SOCKADDR structures in local
//										addresses array.
//	DWORD dwLeaseTime				- Requested time, in milliseconds, to lease
//										the ports.  As long as GetCaps is
//										called before this time has expired,
//										the lease will automatically be
//										renewed.
//	DPNHHANDLE * phRegisteredPorts	- Place to store an identifier for this
//										binding which can later be used to
//										query or release the binding.
//	DWORD dwFlags					- Flags to use when registering the port
//										(DPNHREGISTERPORTS_xxx).
//
// Returns: HRESULT
//	DPNH_OK							- The ports were successfully registered
//										(although no public address may be
//										available yet).
//	DPNHERR_GENERIC					- An error occurred that prevented
//										registration of the requested ports.
//	DPNHERR_INVALIDFLAGS			- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT			- The interface object is invalid.
//	DPNHERR_INVALIDPARAM			- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER			- An invalid pointer was specified.
//	DPNHERR_NOTINITIALIZED			- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY				- There is not enough memory to register
//										the ports.
//	DPNHERR_PORTALREADYREGISTERED	- At least one of the ports has already
//										been registered in a different address
//										array or order.
//	DPNHERR_REENTRANT				- The interface has been re-entered on the
//										same thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::RegisterPorts(const SOCKADDR * const aLocalAddresses,
										const DWORD dwAddressesSize,
										const DWORD dwNumAddresses,
										const DWORD dwLeaseTime,
										DPNHHANDLE * const phRegisteredPorts,
										const DWORD dwFlags)
{
	HRESULT				hr;
	ULONG				ulFirstAddress;
	DWORD				dwTemp;
	DWORD				dwMatch;
	BOOL				fHaveLock = FALSE;
	CRegisteredPort *	pRegisteredPort = NULL;
	CDevice *			pDevice = NULL;
	CBilink *			pBilink;
	SOCKADDR_IN *		pasaddrinTemp;
	CUPnPDevice *		pUPnPDevice = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u, %u, %u, 0x%p, 0x%lx)",
		this, aLocalAddresses, dwAddressesSize, dwNumAddresses, dwLeaseTime,
		phRegisteredPorts, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (aLocalAddresses == NULL)
	{
		DPFX(DPFPREP, 0, "Local addresses array cannot be NULL!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwNumAddresses == 0)
	{
		DPFX(DPFPREP, 0, "Number of addresses cannot be 0!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwAddressesSize != (dwNumAddresses * sizeof(SOCKADDR)))
	{
		DPFX(DPFPREP, 0, "Addresses array size invalid!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (IsBadReadPtr(aLocalAddresses, dwAddressesSize))
	{
		DPFX(DPFPREP, 0, "Local addresses array buffer is invalid!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwNumAddresses > DPNH_MAX_SIMULTANEOUS_PORTS)
	{
		DPFX(DPFPREP, 0, "Only %u ports may be registered at a time!", DPNH_MAX_SIMULTANEOUS_PORTS);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_family != AF_INET)
	{
		DPFX(DPFPREP, 0, "First address in array is not AF_INET, only IPv4 addresses are supported!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_addr == INADDR_BROADCAST)
	{
		DPFX(DPFPREP, 0, "First address cannot be broadcast address!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) aLocalAddresses)->sin_port == 0)
	{
		DPFX(DPFPREP, 0, "First port in array is 0, a valid port must be specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	ulFirstAddress = ((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_addr;

	for(dwTemp = 1; dwTemp < dwNumAddresses; dwTemp++)
	{
		//
		// Make sure this address family type is supported.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_family != AF_INET)
		{
			DPFX(DPFPREP, 0, "Address at array index %u is not AF_INET, all items in the array must be the same IPv4 address!",
				dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}

		//
		// If this address doesn't match the first, then the caller broke the
		// rules.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr != ulFirstAddress)
		{
			//
			// Don't use inet_ntoa because we may not be initialized yet.
			//
			DPFX(DPFPREP, 0, "Address %u.%u.%u.%u at array index %u differs from the first, all addresses in the array must match!",
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b1,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b2,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b3,
				((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_un_b.s_b4,
				dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}

		//
		// Make sure this port isn't 0 either.
		//
		if (((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port == 0)
		{
			DPFX(DPFPREP, 0, "Port at array index %u is 0, valid ports must be specified!", dwTemp);
			hr = DPNHERR_INVALIDPARAM;
			goto Failure;
		}
	}

	if (dwLeaseTime == 0)
	{
		DPFX(DPFPREP, 0, "Invalid lease time specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if ((phRegisteredPorts == NULL) ||
		(IsBadWritePtr(phRegisteredPorts, sizeof(DPNHHANDLE))))
	{
		DPFX(DPFPREP, 0, "Invalid port mapping handle pointer specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwFlags & ~(DPNHREGISTERPORTS_TCP | DPNHREGISTERPORTS_FIXEDPORTS | DPNHREGISTERPORTS_SHAREDPORTS))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}

	if (dwFlags & DPNHREGISTERPORTS_SHAREDPORTS)
	{
		//
		// SHAREDPORTS cannot be used with TCP and requires a FIXEDPORTS.
		//
		if ((dwFlags & DPNHREGISTERPORTS_TCP) || (! (dwFlags & DPNHREGISTERPORTS_FIXEDPORTS)))
		{
			DPFX(DPFPREP, 0, "SHAREDPORTS flag requires FIXEDPORTS flag and cannot be used with TCP flag!");
			hr = DPNHERR_INVALIDFLAGS;
			goto Failure;
		}
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}



	//
	// Loop through all existing registered port mappings and look for this
	// array of ports.
	//
	pBilink = this->m_blRegisteredPorts.GetNext();
	while (pBilink != &this->m_blRegisteredPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

		//
		// Don't bother looking at addresses of the wrong type or at arrays of
		// the wrong size.
		//
		if (((pRegisteredPort->IsTCP() && (dwFlags & DPNHREGISTERPORTS_TCP)) ||
			((! pRegisteredPort->IsTCP()) && (! (dwFlags & DPNHREGISTERPORTS_TCP)))) &&
			(pRegisteredPort->GetNumAddresses() == dwNumAddresses))
		{
			pasaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				//
				// If the addresses don't match, stop looping.
				//
				if ((pasaddrinTemp[dwTemp].sin_port != ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port) ||
					(pasaddrinTemp[dwTemp].sin_addr.S_un.S_addr != ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr))
				{
					break;
				}
			}


			//
			// If all the addresses matched, then this item was already
			// registered.
			//
			if (dwTemp >= dwNumAddresses)
			{
				DPFX(DPFPREP, 1, "Array of %u addresses was already registered, returning existing mapping 0x%p.",
					dwNumAddresses, pRegisteredPort);
				goto ReturnUserHandle;
			}

			DPFX(DPFPREP, 7, "Existing mapping 0x%p does not match all %u addresses.",
				pRegisteredPort, dwNumAddresses);
		}
		else
		{
			//
			// Existing mapping isn't same type or doesn't have same number of
			// items in array.
			//
		}

		pBilink = pBilink->GetNext();
	}


	//
	// If we're here, none of the existing mappings match.  Loop through each
	// of the ports and make sure they aren't already registered inside some
	// other mapping.
	//
	for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
	{
		pBilink = this->m_blRegisteredPorts.GetNext();
		while (pBilink != &this->m_blRegisteredPorts)
		{
			DNASSERT(! pBilink->IsEmpty());
			pRegisteredPort = REGPORT_FROM_GLOBAL_BILINK(pBilink);

			pasaddrinTemp = pRegisteredPort->GetPrivateAddressesArray();
			for(dwMatch = 0; dwMatch < pRegisteredPort->GetNumAddresses(); dwMatch++)
			{
				//
				// If the addresses match, then we can't map these ports.
				//
				if ((pasaddrinTemp[dwMatch].sin_port == ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_port) &&
					(pasaddrinTemp[dwMatch].sin_addr.S_un.S_addr == ((SOCKADDR_IN*) (&aLocalAddresses[dwTemp]))->sin_addr.S_un.S_addr))
				{
					DPFX(DPFPREP, 0, "Existing mapping 0x%p already registered the address %u.%u.%u.%u:%u!",
						pRegisteredPort,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b1,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b2,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b3,
						pasaddrinTemp[dwMatch].sin_addr.S_un.S_un_b.s_b4,
						NTOHS(pasaddrinTemp[dwMatch].sin_port));

					//
					// Clear the pointer so we don't delete the object.
					//
					pRegisteredPort = NULL;

					hr = DPNHERR_PORTALREADYREGISTERED;
					goto Failure;
				}
			}

			pBilink = pBilink->GetNext();
		}
	}


	//
	// If we're here the ports are all unique.  Create a new mapping object
	// we'll use to refer to the binding.
	//
	pRegisteredPort = new CRegisteredPort(dwLeaseTime, dwFlags);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	hr = pRegisteredPort->SetPrivateAddresses((SOCKADDR_IN*) aLocalAddresses, dwNumAddresses);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't store private addresses array!");
		goto Failure;
	}


	//
	// Find the device that matches the given addresses.
	//
	// The first entry of aLocalAddresses is representative of all entries since
	// they should all share the same address.
	//
	// Since there won't be an existing registered port for this address, don't
	// bother looking through them for a matching address.
	//
	pDevice = this->FindMatchingDevice((SOCKADDR_IN*) (&aLocalAddresses[0]),
										FALSE);
	if (pDevice == NULL)
	{
		DPFX(DPFPREP, 1, "No device for given address (%u.%u.%u.%u), storing 0x%p in unowned list.",
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) aLocalAddresses)->sin_addr.S_un.S_un_b.s_b4,
			pRegisteredPort);

		pRegisteredPort->m_blDeviceList.InsertBefore(&this->m_blUnownedPorts);
	}
	else
	{
		pRegisteredPort->MakeDeviceOwner(pDevice);


#ifndef DPNBUILD_NOHNETFWAPI
		//
		// Start by mapping with the local firewall, if there is one.
		//
		if (pDevice->IsHNetFirewalled())
		{
			hr = this->CheckForLocalHNetFirewallAndMapPorts(pDevice,
															pRegisteredPort);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't check for local HNet firewall and map ports (err = 0x%lx)!  Continuing.",
					hr);
				DNASSERT(! pDevice->IsHNetFirewalled());
				hr = DPNH_OK;
			}
		}
		else
		{
			//
			// No local HomeNet firewall (last time we checked).
			//
		}
#endif // ! DPNBUILD_NOHNETFWAPI


		//
		// Map the ports on the UPnP device, if there is one.
		//
		pUPnPDevice = pDevice->GetUPnPDevice();
		if (pUPnPDevice != NULL)
		{
			//
			// GetUPnPDevice did not add a reference to pUPnPDevice for us.
			//
			pUPnPDevice->AddRef();


			DNASSERT(pUPnPDevice->IsReady());

			//
			// Actually map the ports.
			//
			hr = this->MapPortsOnUPnPDevice(pUPnPDevice, pRegisteredPort);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't map ports on UPnP device 0x%p (0x%lx)!  Ignoring.",
					pUPnPDevice, hr);

				//
				// It may have been cleared already, but doing it twice
				// shouldn't be harmful.
				//
				this->ClearDevicesUPnPDevice(pRegisteredPort->GetOwningDevice());

				hr = DPNH_OK;
			}

			pUPnPDevice->DecRef();
			pUPnPDevice = NULL;
		}
		else
		{
			//
			// No UPnP device.
			//
		}
	}


	//
	// Save the mapping in the global list (we have the lock).
	//
	pRegisteredPort->m_blGlobalList.InsertBefore(&this->m_blRegisteredPorts);


ReturnUserHandle:

	//
	// Remember that a port has been registered.
	//
	this->m_dwFlags |= NATHELPUPNPOBJ_PORTREGISTERED;

	//
	// We're about to give the port to the user.
	//
	pRegisteredPort->AddUserRef();

	//
	// We're going to give the user a direct pointer to the object (disguised
	// as an opaque DPNHHANDLE, of course).
	//
	(*phRegisteredPorts) = (DPNHHANDLE) pRegisteredPort;


	this->DropLock();
	fHaveLock = FALSE;


	DPFX(DPFPREP, 5, "Returning registered port 0x%p (first private address = %u.%u.%u.%u:%u).",
		pRegisteredPort,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b1,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b2,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b3,
		((SOCKADDR_IN*) aLocalAddresses)[0].sin_addr.S_un.S_un_b.s_b4,
		NTOHS(((SOCKADDR_IN*) aLocalAddresses)[0].sin_port));


	hr = DPNH_OK;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pUPnPDevice != NULL)
	{
		pUPnPDevice->DecRef();
	}

	if (pRegisteredPort != NULL)
	{
#ifndef DPNBUILD_NOHNETFWAPI
		if (pRegisteredPort->IsMappedOnHNetFirewall())
		{
			HRESULT		temphr;


			//
			// Unmap the port.
			//
			// Don't bother alerting user about address change.  It would have
			// already been taken care of if this was due to a fatal error, and
			// there would be no perceived changed if not.
			//
			temphr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort, TRUE, FALSE);
			if (temphr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Failed unmapping registered port 0x%p on local HomeNet firewall (err = 0x%lx)!  Ignoring.",
					pRegisteredPort, temphr);

				pRegisteredPort->NoteNotMappedOnHNetFirewall();
				pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
			}
		}
#endif // ! DPNBUILD_NOHNETFWAPI

		if (pDevice != NULL)
		{
			pRegisteredPort->ClearDeviceOwner();
		}

		pRegisteredPort->ClearPrivateAddresses();
		delete pRegisteredPort;
	}

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::RegisterPorts






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetRegisteredAddresses"
//=============================================================================
// CNATHelpUPnP::GetRegisteredAddresses
//-----------------------------------------------------------------------------
//
// Description:    Returns the current public address mappings for a given
//				registered port group.  If there are no servers currently
//				available, then DPNHERR_SERVERNOTAVAILABLE is returned.  If the
//				servers' public interfaces are not currently valid, then
//				DPNHERR_NOMAPPING is returned, but appropriate values will
//				still be placed in pdwAddressTypeFlags and
//				pdwLeaseTimeRemaining.
//
//				   If the mapping was registered with the
//				DPNHREGISTERPORTS_FIXEDPORTS flag, but at least one port is
//				already in use on the gateway, then DPNHERR_PORTUNAVAILABLE is
//				returned and appropriate flags will still be placed in
//				pdwAddressTypeFlags.
//
//				   If the local machine has a cooperative firewall installed,
//				the requested port is opened locally on the firewall before
//				being mapped on the Internet gateway.  Normally this function
//				returns the public address on the Internet gateway address when
//				both are present.  Since some firewalls remap the port number
//				when opening non-fixed ports, the
//				DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY allows the
//				caller to retrieve the locally remapped address, even if there
//				is a mapping on an Internet gateway.
//
//				   Some gateway devices do not natively support ports that are
//				not fixed, and may generate the DPNHERR_PORTUNAVAILABLE return
//				code even when the DPNHREGISTERPORTS_FIXEDPORTS flag was not
//				specified.  The caller should de-register the port mapping
//				handle, rebind the application to different ports, and call
//				RegisterPorts again.
//
//				   If the buffer indicated by paPublicAddresses is too small,
//				then the size required is returned in pdwPublicAddressesSize
//				and DPNHERR_BUFFERTOOSMALL is returned.  Otherwise the number of
//				bytes written is returned in pdwPublicAddressesSize.
//
//				   Even though the addresses are returned as individual
//				SOCKADDRs, all ports registered at the same time will share the
//				same public address.  Only the port components will vary.
//
//				   All buffers are optional and may be NULL, but if
//				paPublicAddresses is specified, it must be accompanied by an
//				appropriate size in pdwPublicAddressesSize.
//
//				   If GetCaps has not been previously called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once, then the
//				error code DPNHERR_UPDATESERVERSTATUS is returned.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	SOCKADDR * paPublicAddresses	- Buffer to return assigned public realm
//										address, or NULL if not desired.
//	DWORD * pdwPublicAddressesSize	- Pointer to size of paPublicAddresses
//										buffer, or place to store size
//										required/written.  Cannot be NULL if
//										paPublicAddresses is not NULL.
//	DWORD * pdwAddressTypeFlags		- Place to store flags describing the
//										address types returned, or NULL if not
//										desired.
//	DWORD * pdwLeaseTimeRemaining	- Place to store approximate number of
//										milliseconds remaining in the port
//										lease, or NULL if not desired.  Call
//										GetCaps to automatically extend leases
//										about to expire.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK						- Information on the port mapping was found and
//									the addresses were stored in
//									paPublicAddresses.
//	DPNHERR_BUFFERTOOSMALL		- There was not enough room in the buffer to
//									store the addresses. 
//	DPNHERR_GENERIC				- An error occurred while retrieving the
//									requested port mapping.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER		- An invalid pointer was specified.
//	DPNHERR_NOMAPPING			- The server(s) do not have valid public
//									interfaces.
//	DPNHERR_NOTINITIALIZED		- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to get the
//									addresses.
//	DPNHERR_PORTUNAVAILABLE		- At least one of the ports is not available on
//									the server.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//	DPNHERR_SERVERNOTAVAILABLE	- No servers are currently present.
//	DPNHERR_UPDATESERVERSTATUS	- GetCaps has not been called with the
//									DPNHGETCAPS_UPDATESERVERSTATUS flag yet.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::GetRegisteredAddresses(const DPNHHANDLE hRegisteredPorts,
												SOCKADDR * const paPublicAddresses,
												DWORD * const pdwPublicAddressesSize,
												DWORD * const pdwAddressTypeFlags,
												DWORD * const pdwLeaseTimeRemaining,
												const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	BOOL				fHaveLock = FALSE;
	BOOL				fRegisteredWithServer = FALSE;
	BOOL				fFoundValidMapping = FALSE;
	BOOL				fPortIsUnavailable = FALSE;
	DWORD				dwSizeRequired;
	DWORD				dwAddressTypeFlags;
	DWORD				dwCurrentTime;
	//DWORD				dwTempLeaseTimeRemaining;
	DWORD				dwLeaseTimeRemaining = -1;
	CDevice *			pDevice;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p, 0x%p, 0x%lx)",
		this, hRegisteredPorts, paPublicAddresses, pdwPublicAddressesSize,
		pdwAddressTypeFlags, pdwLeaseTimeRemaining, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (paPublicAddresses != NULL)
	{
		if ((pdwPublicAddressesSize == NULL) ||
			(IsBadWritePtr(pdwPublicAddressesSize, sizeof(DWORD))))
		{
			DPFX(DPFPREP, 0, "When specifying a public addresses buffer, a valid size must be given!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}

		if (IsBadWritePtr(paPublicAddresses, (*pdwPublicAddressesSize)))
		{
			DPFX(DPFPREP, 0, "The public addresses buffer is invalid!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}
	}
	else
	{
		if ((pdwPublicAddressesSize != NULL) &&
			(IsBadWritePtr(pdwPublicAddressesSize, sizeof(DWORD))))
		{
			DPFX(DPFPREP, 0, "Invalid pointer for size of public addresses buffer!");
			hr = DPNHERR_INVALIDPOINTER;
			goto Failure;
		}
	}

	if ((pdwAddressTypeFlags != NULL) &&
		(IsBadWritePtr(pdwAddressTypeFlags, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer for address type flags!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if ((pdwLeaseTimeRemaining != NULL) &&
		(IsBadWritePtr(pdwLeaseTimeRemaining, sizeof(DWORD))))
	{
		DPFX(DPFPREP, 0, "Invalid pointer for lease time remaining!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (dwFlags & ~DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}



	//
	// Start the flags off with the information regarding TCP vs. UDP.
	//
	if (pRegisteredPort->IsTCP())
	{
		dwAddressTypeFlags = DPNHADDRESSTYPE_TCP;
	}
	else
	{
		dwAddressTypeFlags = 0;
	}


	//
	// Add in other flags we know already.
	//

	if (pRegisteredPort->IsFixedPort())
	{
		dwAddressTypeFlags |= DPNHADDRESSTYPE_FIXEDPORTS;
	}

	if (pRegisteredPort->IsSharedPort())
	{
		dwAddressTypeFlags |= DPNHADDRESSTYPE_SHAREDPORTS;
	}




	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 0, "GetCaps has not been called with UPDATESERVERSTATUS flag yet!");
		hr = DPNHERR_UPDATESERVERSTATUS;
		goto Failure;
	}


	//
	// Get a shortcut pointer to the device (may not exist).
	//
	pDevice = pRegisteredPort->GetOwningDevice();


	//
	// Get the current time for both the remote and local lease
	// calculations.
	//
	dwCurrentTime = GETTIMESTAMP();


	if (! (dwFlags & DPNHGETREGISTEREDADDRESSES_LOCALFIREWALLREMAPONLY))
	{
		CUPnPDevice *	pUPnPDevice;


		//
		// First check for a mapping on the UPnP device.
		//
		if (pRegisteredPort->HasUPnPPublicAddresses())
		{
			DNASSERT(pDevice != NULL);

			pUPnPDevice = pDevice->GetUPnPDevice();
			DNASSERT(pUPnPDevice != NULL);

			fRegisteredWithServer = TRUE;

			//
			// Make sure the UPnP device currently has a valid external
			// address.  If so, hand the mapping out.
			//
			if (pUPnPDevice->GetExternalIPAddressV4() != 0)
			{
				if (pdwPublicAddressesSize != NULL)
				{
					dwSizeRequired = pRegisteredPort->GetAddressesSize();

					if ((paPublicAddresses == NULL) ||
						(dwSizeRequired > (*pdwPublicAddressesSize)))
					{
						//
						// Not enough room in buffer, return the size required
						// and the BUFFERTOOSMALL error code.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						hr = DPNHERR_BUFFERTOOSMALL;
					}
					else
					{
						//
						// Buffer was large enough, return the size written.
						//
						(*pdwPublicAddressesSize) = dwSizeRequired;
						pRegisteredPort->CopyUPnPPublicAddresses((SOCKADDR_IN*) paPublicAddresses);
					}
				}
				else
				{
					//
					// Not using address buffer.
					//
				}

				fFoundValidMapping = TRUE;
			}
			else
			{
				DPFX(DPFPREP, 8, "The UPnP Internet Gateway Device does not currently have a valid public address.");
			}

			//
			// Add in the flag indicating that there's a UPnP device.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY;

			//
			// See if the UPnP device is local.
			//
			if (pUPnPDevice->IsLocal())
			{
				dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAYISLOCAL;
			}

			//
			// Get the relative UPnP lease time remaining, if it's not
			// permanent.
			//
			if (! pRegisteredPort->HasPermanentUPnPLease())
			{
				dwLeaseTimeRemaining = pRegisteredPort->GetUPnPLeaseExpiration() - dwCurrentTime;

				if (((int) dwLeaseTimeRemaining) < 0)
				{
					DPFX(DPFPREP, 1, "Registered port mapping's UPnP lease has already expired, returning 0 for lease time remaining.");
					dwLeaseTimeRemaining = 0;
				}
			}
		}
		else if (pRegisteredPort->IsUPnPPortUnavailable())
		{
			DNASSERT(pDevice != NULL);

			pUPnPDevice = pDevice->GetUPnPDevice();
			DNASSERT(pUPnPDevice != NULL);

			fRegisteredWithServer = TRUE;
			fPortIsUnavailable = TRUE;

			DPFX(DPFPREP, 8, "The UPnP device indicates the port(s) are unavailable.");

			//
			// Add in the flag indicating that there's a UPnP device.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAY;

			//
			// See if the UPnP device is local.
			//
			if (pUPnPDevice->IsLocal())
			{
				dwAddressTypeFlags |= DPNHADDRESSTYPE_GATEWAYISLOCAL;
			}
		}
	}
	else
	{
		//
		// We're not allowed to return the UPnP mapping.
		//
		DPFX(DPFPREP, 8, "Ignoring any Internet gateway mappings, LOCALFIREWALLREMAPONLY was specified.");
	}


#ifndef DPNBUILD_NOHNETFWAPI
	//
	// Finally, check for a mapping on a local firewall.
	//
	if (pRegisteredPort->IsMappedOnHNetFirewall())
	{
		DNASSERT(pDevice != NULL);
		DNASSERT(pDevice->IsHNetFirewalled());


		fRegisteredWithServer = TRUE;


		//
		// If we didn't already get a remote mapping, return this local one.
		//
		if (! fFoundValidMapping)
		{
			if (pdwPublicAddressesSize != NULL)
			{
				dwSizeRequired = pRegisteredPort->GetAddressesSize();

				if ((paPublicAddresses == NULL) ||
					(dwSizeRequired > (*pdwPublicAddressesSize)))
				{
					//
					// Not enough room in buffer, return the size required
					// and the BUFFERTOOSMALL error code.
					//
					(*pdwPublicAddressesSize) = dwSizeRequired;
					hr = DPNHERR_BUFFERTOOSMALL;
				}
				else
				{
					SOCKADDR_IN *	pasaddrinPrivate;
					DWORD			dwTemp;


					//
					// Buffer was large enough, return the size written.
					//
					(*pdwPublicAddressesSize) = dwSizeRequired;

					//
					// Note that the addresses mapped on the firewall are the
					// same as the private addresses.
					//
					pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

					DNASSERT(pasaddrinPrivate != NULL);

					memcpy(paPublicAddresses, pasaddrinPrivate, dwSizeRequired);


					//
					// However, we don't want to ever return 0.0.0.0, so make
					// sure they get the device address.
					//
					if (pasaddrinPrivate[0].sin_addr.S_un.S_addr == INADDR_ANY)
					{
						for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
						{
							((SOCKADDR_IN*) paPublicAddresses)[dwTemp].sin_addr.S_un.S_addr = pDevice->GetLocalAddressV4();
						}

						DPFX(DPFPREP, 7, "Returning device address %u.%u.%u.%u instead of INADDR_ANY for firewalled port mapping 0x%p.",
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b1,
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b2,
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b3,
							((SOCKADDR_IN*) paPublicAddresses)[0].sin_addr.S_un.S_un_b.s_b4,
							pRegisteredPort);
					}
				}
			}
			else
			{
				//
				// Not using address buffer.
				//
			}

			fFoundValidMapping = TRUE;
		}
		else
		{
			DPFX(DPFPREP, 6, "Ignoring local HomeNet firewall mapping due to UPnP mapping.");
		}


		//
		// Add in the flag indicating the local firewall.
		//
		dwAddressTypeFlags |= DPNHADDRESSTYPE_LOCALFIREWALL;


		//
		// The firewall API does not allow for lease times.
		//
	}
	else
	{
		if (pRegisteredPort->IsHNetFirewallPortUnavailable())
		{
			DNASSERT(pDevice != NULL);
			DNASSERT(pDevice->IsHNetFirewalled());


			fRegisteredWithServer = TRUE;
			fPortIsUnavailable = TRUE;

			DPFX(DPFPREP, 8, "The local HomeNet firewall indicates the port(s) are unavailable.");


			//
			// Add in the flag indicating the local firewall.
			//
			dwAddressTypeFlags |= DPNHADDRESSTYPE_LOCALFIREWALL;
		}
#ifdef DBG
		else
		{
			//
			// No local firewall or it's an unowned port.
			//
			if (pDevice != NULL)
			{
				DNASSERT(! pDevice->IsHNetFirewalled());
			}
			else
			{
				DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
			}
		}
#endif // DBG
	}
#endif // ! DPNBUILD_NOHNETFWAPI
	

	this->DropLock();
	fHaveLock = FALSE;


	if (fRegisteredWithServer)
	{
		DNASSERT(dwAddressTypeFlags & (DPNHADDRESSTYPE_LOCALFIREWALL | DPNHADDRESSTYPE_GATEWAY));


		if (! fFoundValidMapping)
		{
			if (fPortIsUnavailable)
			{
				//
				// The servers indicated that the ports were already in use.
				// Return PORTUNAVAILABLE.
				//
				DPFX(DPFPREP, 1, "The Internet gateway(s) could not map the port, returning PORTUNAVAILABLE.");
				hr = DPNHERR_PORTUNAVAILABLE;
			}
			else
			{
				//
				// The servers didn't have public addresses.  Return NOMAPPING.
				//
				DPFX(DPFPREP, 1, "The Internet gateway(s) did not offer valid public addresses, returning NOMAPPING.");
				hr = DPNHERR_NOMAPPING;
			}
		}
		else
		{
			//
			// One of the servers had a public address.
			//
			DNASSERT((hr == DPNH_OK) || (hr == DPNHERR_BUFFERTOOSMALL));
		}
	}
	else
	{
		//
		// The ports aren't registered, because there aren't any gateways.
		// Return SERVERNOTAVAILABLE.
		//
		DPFX(DPFPREP, 1, "No Internet gateways, returning SERVERNOTAVAILABLE.");
		hr = DPNHERR_SERVERNOTAVAILABLE;
	}


	//
	// If the caller wants information on the type of these addresses, return
	// the flags we detected.
	//
	if (pdwAddressTypeFlags != NULL)
	{
		(*pdwAddressTypeFlags) = dwAddressTypeFlags;
	}


	//
	// Return the minimum lease time remaining that we already calculated, if
	// the caller wants it.
	//
	if (pdwLeaseTimeRemaining != NULL)
	{
		(*pdwLeaseTimeRemaining) = dwLeaseTimeRemaining;
	}


#ifdef DBG
	//
	// If the port is unavailable or there aren't any servers, we better not
	// have a lease time.
	//
	if ((hr == DPNHERR_PORTUNAVAILABLE) ||
		(hr == DPNHERR_SERVERNOTAVAILABLE))
	{
		DNASSERT(dwLeaseTimeRemaining == -1);
	}


	//
	// If there aren't any servers, we better not have server flags.
	//
	if (hr == DPNHERR_SERVERNOTAVAILABLE)
	{
		DNASSERT(! (dwAddressTypeFlags & (DPNHADDRESSTYPE_LOCALFIREWALL | DPNHADDRESSTYPE_GATEWAY)));
	}
#endif // DBG


	DPFX(DPFPREP, 5, "Registered port 0x%p addr type flags = 0x%lx, lease time remaining = %i.",
		pRegisteredPort, dwAddressTypeFlags, (int) dwLeaseTimeRemaining);


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::GetRegisteredAddresses





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DeregisterPorts"
//=============================================================================
// CNATHelpUPnP::DeregisterPorts
//-----------------------------------------------------------------------------
//
// Description:    Removes the lease record for the port group and informs the
//				Internet gateway server that the binding is no longer needed.
//				The port mapping handle must not be used after de-registering
//				it.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The binding was successfully released.
//	DPNHERR_GENERIC			- An error occurred that prevented the
//								de-registration of the ports.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to de-register.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::DeregisterPorts(const DPNHHANDLE hRegisteredPorts,
											const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	BOOL				fHaveLock = FALSE;
	LONG				lResult;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)",
		this, hRegisteredPorts, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// If this isn't the last user reference on the registered port, don't
	// unmap it yet.
	//
	lResult = pRegisteredPort->DecUserRef();
	if (lResult != 0)
	{
		DPFX(DPFPREP, 1, "Still %i references left on registered port 0x%p, not unmapping.",
			lResult, pRegisteredPort);
		goto Exit;
	}


	//
	// First unmap from UPnP device, if necessary.
	//
	if (pRegisteredPort->HasUPnPPublicAddresses())
	{
		hr = this->UnmapUPnPPort(pRegisteredPort,
								pRegisteredPort->GetNumAddresses(),	// free all ports
								TRUE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't delete port mapping with UPnP device (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the device.
			//
			this->ClearDevicesUPnPDevice(pRegisteredPort->GetOwningDevice());
			hr = DPNH_OK;
		}
	}


#ifndef DPNBUILD_NOHNETFWAPI
	//
	// Then unmap from the local firewall, if necessary.
	//
	if (pRegisteredPort->IsMappedOnHNetFirewall())
	{
		//
		// Unmap the port.
		//
		// Don't bother alerting user about address change, this is normal
		// operation.
		//
		hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort, TRUE, FALSE);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed unmapping registered port 0x%p on local HomeNet firewall (err = 0x%lx)!  Ignoring.",
				pRegisteredPort, hr);

			pRegisteredPort->NoteNotMappedOnHNetFirewall();
			pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

			hr = DPNH_OK;
		}
	}
#endif // ! DPNBUILD_NOHNETFWAPI


	//
	// Pull the item out of the lists.
	// We have the appropriate lock.
	//

	DNASSERT(pRegisteredPort->m_blGlobalList.IsListMember(&this->m_blRegisteredPorts));
	pRegisteredPort->m_blGlobalList.RemoveFromList();

	if (pRegisteredPort->GetOwningDevice() != NULL)
	{
		DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&((pRegisteredPort->GetOwningDevice())->m_blOwnedRegPorts)));
		pRegisteredPort->ClearDeviceOwner();
	}
	else
	{
		DNASSERT(pRegisteredPort->m_blDeviceList.IsListMember(&this->m_blUnownedPorts));
		pRegisteredPort->m_blDeviceList.RemoveFromList();
	}

	pRegisteredPort->ClearPrivateAddresses();
	delete pRegisteredPort;


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::DeregisterPorts





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::QueryAddress"
//=============================================================================
// CNATHelpUPnP::QueryAddress
//-----------------------------------------------------------------------------
//
// Description:    Some Internet gateways do not loopback if an attempt is made
//				to connect to an address behind (on the same private side of)
//				the public interface.  QueryAddress is used to determine a
//				possible private alias for a given public address.
//
//				   In most cases, this function is called prior to connecting
//				to a new address.  pSourceAddress should contain the address of
//				the socket that will perform the connect.  Similar to
//				RegisterPorts, the address may be INADDR_ANY, in which case the
//				"best" server will be used.  Since the server chosen may not be
//				optimal for a particular application, it is recommended that a
//				specific network interface be used instead of INADDR_ANY, when
//				possible.
//
//				   If no mapping for that address has been made by the gateway,
//				the error code DPNHERR_NOMAPPING is returned.  When the
//				DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED flag is used, an
//				extra effort is made to determine whether the address is behind
//				the same Internet gateway without being mapped on the gateway.
//				If that is the case, DPNHERR_NOMAPPINGBUTPRIVATE is returned.
//				DPNHERR_NOMAPPING is still returned for addresses that are
//				neither mapped nor private.
//
//				   pQueryAddress may not be INADDR_ANY or INADDR_BROADCAST.
//				The port component may be zero if and only if the
//				DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED flag is used.  If
//				the port is zero, a specific mapping cannot be verified, and
//				only the DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED aspect of
//				the address is tested.
//
//				   The resulting address (or lack thereof) can be cached for
//				quick future retrieval using the DPNHQUERYADDRESS_CACHEFOUND
//				and DPNHQUERYADDRESS_CACHENOTFOUND flags.  The cached mappings
//				will expire in 1 minute, or whenever the server's address
//				changes.
//
//				   If the given source address is not currently connected to an
//				Internet gateway, then the error DPNHERR_SERVERNOTAVAILABLE is
//				returned.
//
//				   If GetCaps has not been previously called with the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag at least once, then the
//				error code DPNHERR_UPDATESERVERSTATUS is returned.
//
// Arguments:
//	SOCKADDR * pSourceAddress	- Address for network interface that is using
//									the address in question.
//	SOCKADDR * pQueryAddress	- Address to look up.
//	SOCKADDR * pResponseAddress	- Place to store public address, if one exists.
//	int iAddressesSize			- Size of the SOCKADDR structure used for the
//									pSourceAddress, pQueryAddress and
//									pResponseAddress buffers.
//	DWORD dwFlags				- Flags to use when querying
//									(DPNHQUERYADDRESS_xxx).
//
// Returns: HRESULT
//	DPNH_OK						- The address was found and its mapping was
//									stored in pResponseAddress.
//	DPNHERR_GENERIC				- An error occurred that prevented mapping the
//									requested address.
//	DPNHERR_INVALIDFLAGS		- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT		- The interface object is invalid.
//	DPNHERR_INVALIDPARAM		- An invalid parameter was specified.
//	DPNHERR_INVALIDPOINTER		- An invalid pointer was specified.
//	DPNHERR_NOMAPPING			- The server indicated that no mapping for the
//									requested address was found.
//	DPNHERR_NOMAPPINGBUTPRIVATE	- The server indicated that no mapping was
//									found, but it is a private address.
//	DPNHERR_NOTINITIALIZED		- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY			- There is not enough memory to query.
//	DPNHERR_REENTRANT			- The interface has been re-entered on the same
//									thread.
//	DPNHERR_SERVERNOTAVAILABLE	- There are no servers to query.
//	DPNHERR_UPDATESERVERSTATUS	- GetCaps has not been called with the
//									DPNHGETCAPS_UPDATESERVERSTATUS flag yet.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::QueryAddress(const SOCKADDR * const pSourceAddress,
										const SOCKADDR * const pQueryAddress,
										SOCKADDR * const pResponseAddress,
										const int iAddressesSize,
										const DWORD dwFlags)
{
	HRESULT			hr;
	BOOL			fHaveLock = FALSE;
	CDevice *		pDevice;
	SOCKADDR_IN *	psaddrinNextServerQueryAddress = NULL;
	CUPnPDevice *	pUPnPDevice = NULL;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i, 0x%lx)",
		this, pSourceAddress, pQueryAddress, pResponseAddress, iAddressesSize,
		dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (pSourceAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid source address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pQueryAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid query address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (pResponseAddress == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid response address specified!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (iAddressesSize < sizeof(SOCKADDR_IN))
	{
		DPFX(DPFPREP, 0, "The address buffers must be at least %i bytes!",
			sizeof(SOCKADDR_IN));
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (IsBadReadPtr(pSourceAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid source address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (IsBadReadPtr(pQueryAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid query address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if (IsBadWritePtr(pResponseAddress, sizeof(SOCKADDR_IN)))
	{
		DPFX(DPFPREP, 0, "Invalid response address buffer used!");
		hr = DPNHERR_INVALIDPOINTER;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pSourceAddress)->sin_family != AF_INET) ||
		(((SOCKADDR_IN*) pQueryAddress)->sin_family != AF_INET))
	{
		DPFX(DPFPREP, 0, "Source or query address is not AF_INET, only IPv4 addresses are supported!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_addr == INADDR_BROADCAST)
	{
		DPFX(DPFPREP, 0, "Source address cannot be broadcast address!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_addr == INADDR_ANY) ||
		(((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_addr == INADDR_BROADCAST))
	{
		//
		// Don't use inet_ntoa because we may not be initialized yet.
		//
		DPFX(DPFPREP, 0, "Query address (%u.%u.%u.%u) is invalid, cannot be zero or broadcast!",
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b4);
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags & ~(DPNHQUERYADDRESS_TCP | DPNHQUERYADDRESS_CACHEFOUND | DPNHQUERYADDRESS_CACHENOTFOUND | DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED))
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}

	if ((((SOCKADDR_IN*) pQueryAddress)->sin_port == 0) &&
		(! (dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED)))
	{
		DPFX(DPFPREP, 0, "Query address port cannot be zero unless CHECKFORPRIVATEBUTUNMAPPED is specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwLastUpdateServerStatusTime == 0)
	{
		DPFX(DPFPREP, 0, "GetCaps has not been called with UPDATESERVERSTATUS flag yet!");
		hr = DPNHERR_UPDATESERVERSTATUS;
		goto Failure;
	}


	pDevice = this->FindMatchingDevice((SOCKADDR_IN*) pSourceAddress, TRUE);
	if (pDevice == NULL)
	{
		DPFX(DPFPREP, 1, "Couldn't determine owning device for source %u.%u.%u.%u, returning SERVERNOTAVAILABLE for query %u.%u.%u.%u:%u.",
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pSourceAddress)->sin_addr.S_un.S_un_b.s_b4,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b1,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b2,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b3,
			((SOCKADDR_IN*) pQueryAddress)->sin_addr.S_un.S_un_b.s_b4,
			NTOHS(((SOCKADDR_IN*) pQueryAddress)->sin_port));
		hr = DPNHERR_SERVERNOTAVAILABLE;
		goto Exit;
	}



	//
	// Assume no servers are available.  This will get overridden as
	// appropriate.
	//
	hr = DPNHERR_SERVERNOTAVAILABLE;


	//
	// Start by querying the address passed in.
	//
	psaddrinNextServerQueryAddress = (SOCKADDR_IN*) pQueryAddress;


	//
	// If the port is zero, then we can't actually lookup a mapping.  Just do
	// the address locality check.
	//
	if (psaddrinNextServerQueryAddress->sin_port == 0)
	{
		//
		// We should have caught this in parameter validation above, but I'm
		// being paranoid.
		//
		DNASSERT(dwFlags & DPNHQUERYADDRESS_CHECKFORPRIVATEBUTUNMAPPED);


		//
		// We don't cache these results, since there's no server (and thus, no
		// network traffic) associated with it.  No need to look anything up.
		//


		//
		// If there aren't any Internet gateways, then no need to check.
		//
#ifdef DPNBUILD_NOHNETFWAPI
		if (pDevice->GetUPnPDevice() == NULL)
#else // ! DPNBUILD_NOHNETFWAPI
		if ((pDevice->GetUPnPDevice() == NULL) &&
			(! pDevice->IsHNetFirewalled()))
#endif // ! DPNBUILD_NOHNETFWAPI
		{
			DPFX(DPFPREP, 5, "No port queried and there aren't any gateways, returning SERVERNOTAVAILABLE.");
			hr = DPNHERR_SERVERNOTAVAILABLE;
		}
		else
		{
			//
			// There is an Internet gateway of some kind, our locality check
			// would be meaningful.
			//
			if (this->IsAddressLocal(pDevice, psaddrinNextServerQueryAddress))
			{
				DPFX(DPFPREP, 5, "No port queried, but address appears to be local, returning NOMAPPINGBUTPRIVATE.");
				hr = DPNHERR_NOMAPPINGBUTPRIVATE;
			}
			else
			{
				DPFX(DPFPREP, 5, "No port queried and address does not appear to be local, returning NOMAPPING.");
				hr = DPNHERR_NOMAPPING;
			}
		}


		//
		// We've done all we can do.
		//
		goto Exit;
	}


	//
	// Query the UPnP gateway, if there is one.
	//
	pUPnPDevice = pDevice->GetUPnPDevice();
	if (pUPnPDevice != NULL)
	{
		//
		// GetUPnPDevice did not add a reference to pUPnPDevice for us.
		//
		pUPnPDevice->AddRef();


		DNASSERT(pUPnPDevice->IsReady());


		//
		// Actually query the device.
		//
		hr = this->InternalUPnPQueryAddress(pUPnPDevice,
											psaddrinNextServerQueryAddress,
											(SOCKADDR_IN*) pResponseAddress,
											dwFlags);
		switch (hr)
		{
			case DPNH_OK:
			{
				//
				// There was a mapping.
				//
				//psaddrinNextServerQueryAddress = (SOCKADDR_IN*) pResponseAddress;
				break;
			}

			case DPNHERR_NOMAPPING:
			{
				//
				// There's no mapping.
				//
				break;
			}

			case DPNHERR_NOMAPPINGBUTPRIVATE:
			{
				//
				// There's no mapping although the address is private.
				//
				break;
			}

			case DPNHERR_SERVERNOTRESPONDING:
			{
				//
				// The device stopped responding, so we should get rid of it.
				//

				DPFX(DPFPREP, 1, "UPnP device stopped responding while querying port mapping, removing it.");

				this->ClearDevicesUPnPDevice(pDevice);


				//
				// We also set the return code back to SERVERNOTAVAILABLE.
				//
				hr = DPNHERR_SERVERNOTAVAILABLE;

				//
				// Continue through to querying the HomeNet firewall.
				//
				break;
			}

			default:
			{
				DPFX(DPFPREP, 0, "Querying UPnP device for port mapping failed!");
				goto Failure;
				break;
			}
		}

		pUPnPDevice->DecRef();
		pUPnPDevice = NULL;
	}
	else
	{
		//
		// No UPnP device.
		//
	}


#ifndef DPNBUILD_NOHNETFWAPI
	//
	// If there's a HomeNet firewall and we didn't already get a UPnP result,
	// take the easy way out and return NOMAPPING instead of going through the
	// trouble of looking up the mapping and returning success only if it maps
	// to a local address.
	//
	// Note: we may want to look it up, but right now I'm not seeing any
	// benefit to implementing that code.
	//
	if ((pDevice->IsHNetFirewalled()) && (hr == DPNHERR_SERVERNOTAVAILABLE))
	{
		DPFX(DPFPREP, 7, "Device is HomeNet firewalled, and no UPnP result obtained, returning NOMAPPING.");
		hr = DPNHERR_NOMAPPING;
	}
#endif // ! DPNBUILD_NOHNETFWAPI


	//
	// If we got here with hr still set to SERVERNOTAVAILABLE, that means
	// there weren't any servers.  The error code is appropriate, leave it
	// alone.
	//
#ifdef DBG
	if (hr == DPNHERR_SERVERNOTAVAILABLE)
	{
		DPFX(DPFPREP, 1, "No Internet gateways, unable to query port mapping.");
	}
#endif // DBG
	



Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pUPnPDevice != NULL)
	{
		pUPnPDevice->DecRef();
	}

	goto Exit;
} // CNATHelpUPnP::QueryAddress





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SetAlertEvent"
//=============================================================================
// CNATHelpUPnP::SetAlertEvent
//-----------------------------------------------------------------------------
//
// Description:    This function allows the user to specify an event that will
//				be set when some maintenance needs to be performed.  The user
//				should call GetCaps using the DPNHGETCAPS_UPDATESERVERSTATUS
//				flag when the event is signalled.
//
//				   This function is not available on Windows 95 without WinSock
//				2, may only be called once, and cannot be used after
//				SetAlertIOCompletionPort is called.
//
//					Note that the event is used in addition to the regular
//				polling of GetCaps, it simply allows the polling to be less
//				frequent.
//
// Arguments:
//	HANDLE hEvent	- Handle to event to signal when GetCaps is to be called.
//	DWORD dwFlags	- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The event was successfully registered.
//	DPNHERR_GENERIC			- An error occurred that prevented registering the
//								event.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::SetAlertEvent(const HANDLE hEvent,
										const DWORD dwFlags)
{
#ifdef DPNBUILD_NOWINSOCK2
	DPFX(DPFPREP, 0, "Cannot set alert event (0x%p)!", hEvent);
	return E_NOTIMPL;
#else // ! DPNBUILD_NOWINSOCK2
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx)", this, hEvent, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (hEvent == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid event handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1)
	{
		DPFX(DPFPREP, 0, "Cannot use alert mechanism on WinSock 1!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if ((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL))
	{
		DPFX(DPFPREP, 0, "An alert event or I/O completion port has already been set!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Now save the event handle.
	//
	if (! DuplicateHandle(GetCurrentProcess(),
						hEvent,
						GetCurrentProcess(),
						&this->m_hAlertEvent,
						0,
						FALSE,
						DUPLICATE_SAME_ACCESS))
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't duplicate event (error = %u)!", dwError);
#endif // DBG

		DNASSERT(this->m_hAlertEvent == NULL);

		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}


	//
	// Create overlapped structure.  Don't allocate it through DNMalloc,
	// because we may have to leak it on purpose.  We don't want those memory
	// allocation asserts firing in that case.
	//
	this->m_polAddressListChange = (WSAOVERLAPPED*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															sizeof(WSAOVERLAPPED));
	if (this->m_polAddressListChange == NULL)
	{
		//
		// Close the alert handle we set.
		//
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;

		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Save the event in the address list change overlapped structure.
	//
	this->m_polAddressListChange->hEvent = this->m_hAlertEvent;


	//
	// Start getting notified of local address changes.
	//
	hr = this->RequestLocalAddressListChangeNotification();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");

		//
		// Free the memory we allocated.
		//
		HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		this->m_polAddressListChange = NULL;

		//
		// Close the alert handle we set.
		//
		CloseHandle(this->m_hAlertEvent);
		this->m_hAlertEvent = NULL;

		goto Failure;
	}


Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
#endif // ! DPNBUILD_NOWINSOCK2
} // CNATHelpUPnP::SetAlertEvent






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SetAlertIOCompletionPort"
//=============================================================================
// CNATHelpUPnP::SetAlertIOCompletionPort
//-----------------------------------------------------------------------------
//
// Description:    This function allows the user to specify an I/O completion
//				port that will receive notification when some maintenance needs
//				to be performed.  The user should call GetCaps using the
//				DPNHGETCAPS_UPDATESERVERSTATUS flag when the packet with the
//				given completion key is dequeued.
//
//				   This function is only available on Windows NT, may only be
//				called once, and cannot be used after SetAlertEvent is called.
//
//					Note that the completion port is used in addition to the
//				regular polling of GetCaps, it simply allows the polling to be
//				less frequent.
//
// Arguments:
//	HANDLE hIOCompletionPort		- Handle to I/O completion port which will
//										be used to signal when GetCaps is to be
//										called.
//	DWORD dwCompletionKey			- Key to use when indicating I/O
//										completion.
//	DWORD dwNumConcurrentThreads	- Number of concurrent threads allowed to
//										process, or zero for default.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The I/O completion port was successfully
//								registered.
//	DPNHERR_GENERIC			- An error occurred that prevented registering the
//								I/O completion port.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::SetAlertIOCompletionPort(const HANDLE hIOCompletionPort,
													const DWORD dwCompletionKey,
													const DWORD dwNumConcurrentThreads,
													const DWORD dwFlags)
{
#ifdef DPNBUILD_NOWINSOCK2
	DPFX(DPFPREP, 0, "Cannot set alert I/O completion port (0x%p, %u, %u)!",
		hIOCompletionPort, dwCompletionKey, dwNumConcurrentThreads);
	return E_NOTIMPL;
#else // ! DPNBUILD_NOWINSOCK2
	HRESULT		hr;
	BOOL		fHaveLock = FALSE;
	HANDLE		hIOCompletionPortResult;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, 0x%lx, %u, 0x%lx)",
		this, hIOCompletionPort, dwCompletionKey, dwNumConcurrentThreads, dwFlags);



	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	if (hIOCompletionPort == NULL)
	{
		DPFX(DPFPREP, 0, "Invalid I/O completion port handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED))
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}

	if (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1)
	{
		DPFX(DPFPREP, 0, "Cannot use alert mechanism on WinSock 1!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	if ((this->m_hAlertEvent != NULL) || (this->m_hAlertIOCompletionPort != NULL))
	{
		DPFX(DPFPREP, 0, "An alert event or I/O completion port has already been set!");
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Now save the I/O completion port handle.
	//
	if (! DuplicateHandle(GetCurrentProcess(),
						hIOCompletionPort,
						GetCurrentProcess(),
						&this->m_hAlertIOCompletionPort,
						0,
						FALSE,
						DUPLICATE_SAME_ACCESS))
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't duplicate I/O completion port (error = %u)!", dwError);
#endif // DBG

		DNASSERT(this->m_hAlertIOCompletionPort == NULL);

		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	this->m_dwAlertCompletionKey = dwCompletionKey;


	//
	// Associate our Ioctl socket with this IO completion port.
	//
	DNASSERT(this->m_sIoctls != INVALID_SOCKET);
	hIOCompletionPortResult = CreateIoCompletionPort((HANDLE) this->m_sIoctls,
													this->m_hAlertIOCompletionPort,
													dwCompletionKey,
													dwNumConcurrentThreads);
	if (hIOCompletionPortResult == NULL)
	{
#ifdef DBG
		DWORD	dwError;


		dwError = GetLastError();
		DPFX(DPFPREP, 0, "Couldn't associate I/O completion port with Ioctl socket (error = %u)!", dwError);
#endif // DBG

		hr = DPNHERR_GENERIC;
		goto Failure;
	}

	//
	// We should have just gotten the same I/O completion port back.
	//
	DNASSERT(hIOCompletionPortResult == this->m_hAlertIOCompletionPort);


	//
	// Create overlapped structure.  Don't allocate it through DNMalloc,
	// because we may have to leak it on purpose.  We don't want those memory
	// allocation asserts firing in that case.
	//
	this->m_polAddressListChange = (WSAOVERLAPPED*) HeapAlloc(GetProcessHeap(),
															HEAP_ZERO_MEMORY,
															sizeof(WSAOVERLAPPED));
	if (this->m_polAddressListChange == NULL)
	{
		//
		// Close the alert IOCP we set.
		//
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;

		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}


	//
	// Start getting notified of local address changes.
	//
	hr = this->RequestLocalAddressListChangeNotification();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");

		//
		// Free the memory we allocated.
		//
		HeapFree(GetProcessHeap(), 0, this->m_polAddressListChange);
		this->m_polAddressListChange = NULL;

		//
		// Close the alert IOCP we set.
		//
		CloseHandle(this->m_hAlertIOCompletionPort);
		this->m_hAlertIOCompletionPort = NULL;

		goto Failure;
	}



Exit:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
#endif // ! DPNBUILD_NOWINSOCK2
} // CNATHelpUPnP::SetAlertIOCompletionPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::ExtendRegisteredPortsLease"
//=============================================================================
// CNATHelpUPnP::ExtendRegisteredPortsLease
//-----------------------------------------------------------------------------
//
// Description:    Manually extends the lease of the given registered port
//				mapping by the requested time.  The periodic calling of GetCaps
//				can take care of this for the user, this function is only
//				necessary to change the lease extension time or for finer
//				control of individual mappings.
//
//				   The user should specify a requested lease extension time
//				that the server will attempt to honor.  It will be added to any
//				time remaining in the existing lease, and the new total can be
//				retrieved by calling GetRegisteredAddresses.
//
// Arguments:
//	DPNHHANDLE hRegisteredPorts		- Handle for a specific binding returned by
//										RegisterPorts.
//	DWORD dwLeaseTime				- Requested time, in milliseconds, to
//										extend the lease.  If 0, the previous
//										requested lease time is used.
//	DWORD dwFlags					- Unused, must be zero.
//
// Returns: HRESULT
//	DPNH_OK					- The lease was successfully extended.
//	DPNHERR_GENERIC			- An error occurred that prevented the extending
//								the lease.
//	DPNHERR_INVALIDFLAGS	- Invalid flags were specified.
//	DPNHERR_INVALIDOBJECT	- The interface object is invalid.
//	DPNHERR_INVALIDPARAM	- An invalid parameter was specified.
//	DPNHERR_NOTINITIALIZED	- Initialize has not been called.
//	DPNHERR_OUTOFMEMORY		- There is not enough memory to extend the lease.
//	DPNHERR_REENTRANT		- The interface has been re-entered on the same
//								thread.
//=============================================================================
STDMETHODIMP CNATHelpUPnP::ExtendRegisteredPortsLease(const DPNHHANDLE hRegisteredPorts,
													const DWORD dwLeaseTime,
													const DWORD dwFlags)
{
	HRESULT				hr;
	CRegisteredPort *	pRegisteredPort;
	CDevice *			pDevice;
	BOOL				fHaveLock = FALSE;


	DPFX(DPFPREP, 2, "(0x%p) Parameters: (0x%p, %u, 0x%lx)",
		this, hRegisteredPorts, dwLeaseTime, dwFlags);


	//
	// Validate the object.
	//
	if (! this->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid DirectPlay NAT Help object!");
		hr = DPNHERR_INVALIDOBJECT;
		goto Failure;
	}


	//
	// Validate the parameters.
	//

	pRegisteredPort = (CRegisteredPort*) hRegisteredPorts;
	if (! pRegisteredPort->IsValidObject())
	{
		DPFX(DPFPREP, 0, "Invalid registered port mapping handle specified!");
		hr = DPNHERR_INVALIDPARAM;
		goto Failure;
	}

	if (dwFlags != 0)
	{
		DPFX(DPFPREP, 0, "Invalid flags specified!");
		hr = DPNHERR_INVALIDFLAGS;
		goto Failure;
	}


	//
	// Attempt to take the lock, but be prepared for the re-entrancy error.
	//
	hr = this->TakeLock();
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Could not lock object!");
		goto Failure;
	}

	fHaveLock = TRUE;


	//
	// Make sure object is in right state.
	//

	if (! (this->m_dwFlags & NATHELPUPNPOBJ_INITIALIZED) )
	{
		DPFX(DPFPREP, 0, "Object not initialized!");
		hr = DPNHERR_NOTINITIALIZED;
		goto Failure;
	}


	//
	// If they wanted to change the lease time, update it.
	//
	if (dwLeaseTime != 0)
	{
		pRegisteredPort->UpdateRequestedLeaseTime(dwLeaseTime);
	}

	
	pDevice = pRegisteredPort->GetOwningDevice();


	//
	// If the port is registered with the UPnP device, extend that lease.
	//
	if (pRegisteredPort->HasUPnPPublicAddresses())
	{
		DNASSERT(pDevice != NULL);


		hr = this->ExtendUPnPLease(pRegisteredPort);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't extend port mapping lease on UPnP device (0x%lx)!  Ignoring.", hr);

			//
			// We'll treat this as non-fatal, but we have to dump the
			// server.  This may have already been done, but doing it
			// twice shouldn't be harmful.
			//
			this->ClearDevicesUPnPDevice(pDevice);
			hr = DPNH_OK;
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Port mapping not registered with UPnP gateway device.");
	}


	//
	// Firewall mappings never have lease times to extend.
	//


	this->DropLock();
	fHaveLock = FALSE;


Exit:

	DPFX(DPFPREP, 2, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fHaveLock)
	{
		this->DropLock();
		fHaveLock = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::ExtendRegisteredPortsLease






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::InitializeObject"
//=============================================================================
// CNATHelpUPnP::InitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Sets up the object for use like the constructor, but may
//				fail with OUTOFMEMORY.  Should only be called by class factory
//				creation routine.
//
// Arguments: None.
//
// Returns: HRESULT
//	S_OK			- Initialization was successful.
//	E_OUTOFMEMORY	- There is not enough memory to initialize.
//=============================================================================
HRESULT CNATHelpUPnP::InitializeObject(void)
{
	HRESULT		hr;
	BOOL		fInittedCriticalSection = FALSE;


	DPFX(DPFPREP, 5, "(0x%p) Enter", this);

	DNASSERT(this->IsValidObject());


	//
	// Create the lock.
	// 

	if (! DNInitializeCriticalSection(&this->m_csLock))
	{
		hr = E_OUTOFMEMORY;
		goto Failure;
	}

	fInittedCriticalSection = TRUE;


	//
	// Don't allow critical section reentry.
	//
	DebugSetCriticalSectionRecursionCount(&this->m_csLock, 0);


	this->m_hLongLockSemaphore = DNCreateSemaphore(NULL,
													0,
													MAX_LONG_LOCK_WAITING_THREADS,
													NULL);
	if (this->m_hLongLockSemaphore == NULL)
	{
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	hr = S_OK;

Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (fInittedCriticalSection)
	{
		DNDeleteCriticalSection(&this->m_csLock);
		fInittedCriticalSection = FALSE;
	}

	goto Exit;
} // CNATHelpUPnP::InitializeObject






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UninitializeObject"
//=============================================================================
// CNATHelpUPnP::UninitializeObject
//-----------------------------------------------------------------------------
//
// Description:    Cleans up the object like the destructor, mostly to balance
//				InitializeObject.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::UninitializeObject(void)
{
	DPFX(DPFPREP, 5, "(0x%p) Enter", this);


	DNASSERT(this->IsValidObject());


	DNCloseHandle(this->m_hLongLockSemaphore);
	this->m_hLongLockSemaphore = NULL;

	DNDeleteCriticalSection(&this->m_csLock);


	DPFX(DPFPREP, 5, "(0x%p) Leave", this);
} // CNATHelpUPnP::UninitializeObject





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::TakeLock"
//=============================================================================
// CNATHelpUPnP::TakeLock
//-----------------------------------------------------------------------------
//
// Description:    Takes the main object lock.  If some other thread is already
//				holding the long lock, we wait for that first.
//
// Arguments: None.
//
// Returns: DPNH_OK if lock was taken successfully, DPNHERR_REENTRANT if lock
//			was re-entered.
//=============================================================================
HRESULT CNATHelpUPnP::TakeLock(void)
{
	HRESULT		hr = DPNH_OK;
#ifdef DBG
	DWORD		dwStartTime;


	dwStartTime = GETTIMESTAMP();
#endif // DBG


	DNEnterCriticalSection(&this->m_csLock);


	//
	// If this same thread is already holding the lock, then bail.
	//
	if (this->m_dwLockThreadID == GetCurrentThreadId())
	{
		DPFX(DPFPREP, 0, "Thread re-entering!");
		goto Failure;
	}

	
	//
	// If someone is holding the long lock, we need to wait for that.  Of
	// course another thread could come in and take the long lock after the
	// first one drops it and before we can take the main one.  This algorithm
	// does not attempt to be fair in this case.  Theoretically we could wait
	// forever if this continued to occur.  That shouldn't happen in the real
	// world.
	// This whole mess of code is a huge... uh... workaround for stress hits
	// involving critical section timeouts.
	//
	while (this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK)
	{
		DNASSERT(this->m_lNumLongLockWaitingThreads >= 0);
		this->m_lNumLongLockWaitingThreads++;

		//
		// We need to keep looping until we do get the lock.
		//
		DNLeaveCriticalSection(&this->m_csLock);


		DPFX(DPFPREP, 3, "Waiting for long lock to be released.");

		DNWaitForSingleObject(this->m_hLongLockSemaphore, INFINITE);


		DNEnterCriticalSection(&this->m_csLock);


		//
		// If this same thread is already holding the lock, then bail.
		//
		if (this->m_dwLockThreadID == GetCurrentThreadId())
		{
			DPFX(DPFPREP, 0, "Thread re-entering after waiting for long lock!");
			goto Failure;
		}
	}


#ifdef DBG
	DPFX(DPFPREP, 8, "Took main object lock, elapsed time = %u ms.",
		(GETTIMESTAMP() - dwStartTime));
#endif // DBG

	//
	// Save this thread's ID so we know who's holding the lock.
	//
	this->m_dwLockThreadID = GetCurrentThreadId();


Exit:

	return hr;


Failure:

	//
	// We're reentering.  Drop the lock and return the failure.
	//
	DNLeaveCriticalSection(&this->m_csLock);

	hr = DPNHERR_REENTRANT;

	goto Exit;
} // CNATHelpUPnP::TakeLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DropLock"
//=============================================================================
// CNATHelpUPnP::DropLock
//-----------------------------------------------------------------------------
//
// Description:    Drops the main object lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::DropLock(void)
{
	DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK));
	DNASSERT(this->m_lNumLongLockWaitingThreads == 0);
	DNASSERT(this->m_dwLockThreadID == GetCurrentThreadId());

	this->m_dwLockThreadID = 0;
	DNLeaveCriticalSection(&this->m_csLock);

	DPFX(DPFPREP, 8, "Dropped main object lock.");
} // CNATHelpUPnP::DropLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SwitchToLongLock"
//=============================================================================
// CNATHelpUPnP::SwitchToLongLock
//-----------------------------------------------------------------------------
//
// Description:    Switches from holding the main object lock to holding the
//				long lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::SwitchToLongLock(void)
{
	AssertCriticalSectionIsTakenByThisThread(&this->m_csLock, TRUE);
	DNASSERT(! (this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK));
	DNASSERT(this->m_lNumLongLockWaitingThreads == 0);


	DPFX(DPFPREP, 8, "Switching to long lock.");


	this->m_dwFlags |= NATHELPUPNPOBJ_LONGLOCK;

	DNLeaveCriticalSection(&this->m_csLock);
} // CNATHelpUPnP::SwitchToLongLock




#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::SwitchFromLongLock"
//=============================================================================
// CNATHelpUPnP::SwitchFromLongLock
//-----------------------------------------------------------------------------
//
// Description:    Switches from holding the long lock back to holding the main
//				object lock.
//
// Arguments: None.
//
// Returns: None.
//=============================================================================
void CNATHelpUPnP::SwitchFromLongLock(void)
{
	DNEnterCriticalSection(&this->m_csLock);

	DNASSERT(this->m_dwFlags & NATHELPUPNPOBJ_LONGLOCK);
	this->m_dwFlags &= ~NATHELPUPNPOBJ_LONGLOCK;


	DPFX(DPFPREP, 8, "Switching from long lock, alerting %i threads.",
		this->m_lNumLongLockWaitingThreads);


	//
	// This is non-optimal in that we release the semaphore but the waiting
	// threads still won't actually be able to do anything since we now hold
	// the main lock.
	//
	DNASSERT(this->m_lNumLongLockWaitingThreads >= 0);
	DNReleaseSemaphore(this->m_hLongLockSemaphore,
						this->m_lNumLongLockWaitingThreads,
						NULL);

	this->m_lNumLongLockWaitingThreads = 0;
} // CNATHelpUPnP::SwitchFromLongLock






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::LoadWinSockFunctionPointers"
//=============================================================================
// CNATHelpUPnP::LoadWinSockFunctionPointers
//-----------------------------------------------------------------------------
//
// Description:    Loads pointers to all the functions that we use in WinSock.
//
//				   The object lock is assumed to be held.
//
// Arguments: None.
//
// Returns: HRESULT
//	DPNH_OK			- Loading was successful.
//	DPNHERR_GENERIC	- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::LoadWinSockFunctionPointers(void)
{
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#ifdef DBG

#define PRINTERRORIFDEBUG(name)						\
	{\
		dwError = GetLastError();\
		DPFX(DPFPREP, 0, "Couldn't get \"%hs\" function!  0x%lx", name, dwError);\
	}

#else // ! DBG

#define PRINTERRORIFDEBUG(name)

#endif // ! DBG


#define LOADWINSOCKFUNCTION(var, proctype, name)	\
	{\
		var = (##proctype) GetProcAddress(this->m_hWinSockDLL, _TWINCE(name));\
		if (var == NULL)\
		{\
			PRINTERRORIFDEBUG(name);\
			hr = DPNHERR_GENERIC;\
			goto Failure;\
		}\
	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	HRESULT		hr = DPNH_OK;
#ifdef DBG
	DWORD		dwError;
#endif // DBG


	LOADWINSOCKFUNCTION(this->m_pfnWSAStartup,				LPFN_WSASTARTUP,				"WSAStartup");
	LOADWINSOCKFUNCTION(this->m_pfnWSACleanup,				LPFN_WSACLEANUP,				"WSACleanup");
#ifdef WINCE
	this->m_pfnWSAGetLastError = (LPFN_WSAGETLASTERROR) GetLastError;
#else // ! WINCE
	LOADWINSOCKFUNCTION(this->m_pfnWSAGetLastError,			LPFN_WSAGETLASTERROR,			"WSAGetLastError");
#endif // ! WINCE
	LOADWINSOCKFUNCTION(this->m_pfnsocket,					LPFN_SOCKET,					"socket");
	LOADWINSOCKFUNCTION(this->m_pfnclosesocket,				LPFN_CLOSESOCKET,				"closesocket");
	LOADWINSOCKFUNCTION(this->m_pfnbind,					LPFN_BIND,						"bind");
	LOADWINSOCKFUNCTION(this->m_pfnsetsockopt,				LPFN_SETSOCKOPT,				"setsockopt");
	LOADWINSOCKFUNCTION(this->m_pfngetsockname,				LPFN_GETSOCKNAME,				"getsockname");
	LOADWINSOCKFUNCTION(this->m_pfnselect,					LPFN_SELECT,					"select");
	LOADWINSOCKFUNCTION(this->m_pfn__WSAFDIsSet,			LPFN___WSAFDISSET,				"__WSAFDIsSet");
	LOADWINSOCKFUNCTION(this->m_pfnrecvfrom,				LPFN_RECVFROM,					"recvfrom");
	LOADWINSOCKFUNCTION(this->m_pfnsendto,					LPFN_SENDTO,					"sendto");
	LOADWINSOCKFUNCTION(this->m_pfngethostname,				LPFN_GETHOSTNAME,				"gethostname");
	LOADWINSOCKFUNCTION(this->m_pfngethostbyname,			LPFN_GETHOSTBYNAME,				"gethostbyname");
	LOADWINSOCKFUNCTION(this->m_pfninet_addr,				LPFN_INET_ADDR,					"inet_addr");

#ifndef DPNBUILD_NOWINSOCK2
	if (! (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1))
	{
		LOADWINSOCKFUNCTION(this->m_pfnWSASocketA,				LPFN_WSASOCKETA,				"WSASocketA");
		LOADWINSOCKFUNCTION(this->m_pfnWSAIoctl,				LPFN_WSAIOCTL,					"WSAIoctl");
		LOADWINSOCKFUNCTION(this->m_pfnWSAGetOverlappedResult,	LPFN_WSAGETOVERLAPPEDRESULT,	"WSAGetOverlappedResult");
	}
#endif // ! DPNBUILD_NOWINSOCK2

	LOADWINSOCKFUNCTION(this->m_pfnioctlsocket,				LPFN_IOCTLSOCKET,				"ioctlsocket");
	LOADWINSOCKFUNCTION(this->m_pfnconnect,					LPFN_CONNECT,					"connect");
	LOADWINSOCKFUNCTION(this->m_pfnshutdown,				LPFN_SHUTDOWN,					"shutdown");
	LOADWINSOCKFUNCTION(this->m_pfnsend,					LPFN_SEND,						"send");
	LOADWINSOCKFUNCTION(this->m_pfnrecv,					LPFN_RECV,						"recv");

#ifdef DBG
	LOADWINSOCKFUNCTION(this->m_pfngetsockopt,				LPFN_GETSOCKOPT,				"getsockopt");
#endif // DBG


Exit:

	return hr;


Failure:

	hr = DPNHERR_GENERIC;

	goto Exit;
} // CNATHelpUPnP::LoadWinSockFunctionPointers






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForNewDevices"
//=============================================================================
// CNATHelpUPnP::CheckForNewDevices
//-----------------------------------------------------------------------------
//
// Description:    Detects new IP capable devices that have been added and
//				removes old ones no longer available.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	BOOL * pfFoundNewDevices	Pointer to boolean to set to TRUE if new
//								devices were added, or NULL if don't care.
//
// Returns: HRESULT
//	DPNH_OK				- The check was successful.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForNewDevices(BOOL * const pfFoundNewDevices)
{
	HRESULT				hr = DPNH_OK;
#if ((defined(DBG)) || (! defined(DPNBUILD_NOWINSOCK2)))
	DWORD				dwError;
#endif // DBG or ! DPNBUILD_NOWINSOCK2
#ifndef DPNBUILD_NOWINSOCK2
	int					iReturn;
#endif // ! DPNBUILD_NOWINSOCK2
	char				szName[1000];
	PHOSTENT			phostent;
	IN_ADDR **			ppinaddr;
	DWORD				dwAddressesSize = 0;
	DWORD				dwNumAddresses = 0;
	IN_ADDR *			painaddrAddresses = NULL;
	CBilink *			pBilinkDevice;
	CDevice *			pDevice = NULL; // NULL it for PREfix, even though fDeviceCreated guards it
	BOOL				fDeviceCreated = FALSE;
	BOOL				fFound;
	CBilink *			pBilinkRegPort;
	CRegisteredPort *	pRegisteredPort;
	SOCKET				sTemp = INVALID_SOCKET;
	SOCKADDR_IN			saddrinTemp;
	DWORD				dwTemp;
#ifndef DPNBUILD_NOWINSOCK2
	SOCKET_ADDRESS *	paSocketAddresses;
#endif // ! DPNBUILD_NOWINSOCK2



	DPFX(DPFPREP, 5, "(0x%p) Parameters (0x%p)", this, pfFoundNewDevices);


#ifndef DPNBUILD_NOWINSOCK2
	//
	// Handle any address list change Ioctl completions that may have gotten us
	// here.
	//
	if ((this->m_hAlertEvent != NULL) ||
		(this->m_hAlertIOCompletionPort != NULL))
	{
		DNASSERT(this->m_sIoctls != INVALID_SOCKET);
		DNASSERT(this->m_polAddressListChange != NULL);

		if (this->m_pfnWSAGetOverlappedResult(this->m_sIoctls,					//
												this->m_polAddressListChange,	//
												&dwTemp,						// ignore bytes transferred
												FALSE,							// don't wait
												&dwTemp))						// ignore flags
		{
			DPFX(DPFPREP, 1, "Received address list change notification.");
			

			//
			// Overlapped result completed.  Reissue it.
			//
			hr = this->RequestLocalAddressListChangeNotification();
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");
				goto Failure;
			}
		}
		else
		{
			//
			// Figure out what error it was.
			//
			dwError = this->m_pfnWSAGetLastError();
			switch (dwError)
			{
				case WSA_IO_INCOMPLETE:
				{
					//
					// It hasn't completed yet.
					//
					break;
				}

				case ERROR_OPERATION_ABORTED:
				{
					//
					// The thread that we originally submitted the Ioctl on
					// went away and so the OS kindly cancelled the operation
					// on us.  How nice.  Well, let's try resubmitting it.
					//

					DPFX(DPFPREP, 1, "Thread that submitted previous address list change notification went away, rerequesting.");
					
					hr = this->RequestLocalAddressListChangeNotification();
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't request local address list change notification!");
						goto Failure;
					}
					break;
				}
			
				default:
				{
					DPFX(DPFPREP, 0, "Couldn't get overlapped result, error = %u!  Ignoring.", dwError);
					break;
				}
			} // end switch (on error)
		}
	}


	//
	// If we're on WinSock 2, let's try getting the address list with
	// an Ioctl.
	//
	if (! (this->m_dwFlags & NATHELPUPNPOBJ_WINSOCK1))
	{
		DNASSERT(this->m_sIoctls != INVALID_SOCKET);
		DNASSERT(this->m_pfnWSAIoctl != NULL);

		//
		// Keep trying to get the address list until we have a large enough
		// buffer.  We use the IN_ADDR array pointer simply because it's
		// already there.  We know that IN_ADDRs are smaller than
		// SOCKET_ADDRESSes, so we can reuse the same buffer.
		//
		do
		{
			iReturn = this->m_pfnWSAIoctl(this->m_sIoctls,			// use the special Ioctl socket
										SIO_ADDRESS_LIST_QUERY,		//
										NULL,						// no input data
										0,							// no input data
										painaddrAddresses,			// output buffer
										dwAddressesSize,			// output buffer size
										&dwTemp,					// bytes needed
										NULL,						// no overlapped structure
										NULL);						// no completion routine

			if (iReturn != 0)
			{
				dwError = this->m_pfnWSAGetLastError();

				//
				// Free the previous buffer, no matter what error it was.
				//
				if (painaddrAddresses != NULL)
				{
					DNFree(painaddrAddresses);
					painaddrAddresses = NULL;
				}
				
				if (dwError != WSAEFAULT)
				{
					DPFX(DPFPREP, 1, "Retrieving address list failed (err = %u), trying WinSock 1 method.", dwError);

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}


				//
				// Be absolutely sure WinSock isn't causing us trouble.
				//
				if (dwTemp < sizeof(SOCKET_ADDRESS_LIST))
				{
					DPFX(DPFPREP, 0, "Received an invalid buffer size (%u < %u)!",
						dwTemp, sizeof(SOCKET_ADDRESS_LIST));

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}


				//
				// The buffer wasn't large enough.  Try again.
				//
				painaddrAddresses = (IN_ADDR*) DNMalloc(dwTemp);
				if (painaddrAddresses == NULL)
				{
					hr = DPNHERR_OUTOFMEMORY;
					goto Failure;
				}

				dwAddressesSize = dwTemp;
			}
			else
			{
				//
				// Success!  We're going to being sneaky and reuse the buffer.
				// We know that the SOCKET_ADDRESS_LIST returned will be larger
				// than an array of IN_ADDRs, so we can save a malloc.
				//
				// But first, be absolutely sure WinSock isn't causing us
				// trouble.
				//

				if (painaddrAddresses == NULL)
				{
					DPFX(DPFPREP, 0, "WinSock returned success with a NULL buffer!");

					//
					// We'll try the old-fashioned WinSock 1 way.
					//
					break;
				}

				dwNumAddresses = ((SOCKET_ADDRESS_LIST*) painaddrAddresses)->iAddressCount;
				dwAddressesSize = 0;


				//
				// Make sure there are addresses. 
				//
				if (dwNumAddresses > 0)
				{
					DPFX(DPFPREP, 7, "WinSock 2 Ioctl returned %u addresses:", dwNumAddresses);

					paSocketAddresses = ((SOCKET_ADDRESS_LIST*) painaddrAddresses)->Address;
					for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
					{
						DNASSERT(paSocketAddresses[dwTemp].iSockaddrLength == sizeof(SOCKADDR_IN));
						DNASSERT(paSocketAddresses[dwTemp].lpSockaddr != NULL);
						DNASSERT(paSocketAddresses[dwTemp].lpSockaddr->sa_family == AF_INET);

						//
						// Ignore 0.0.0.0 addresses.
						//
						if (((SOCKADDR_IN*) (paSocketAddresses[dwTemp].lpSockaddr))->sin_addr.S_un.S_addr != INADDR_NONE)
						{
							//
							// Move the IN_ADDR component of this address
							// toward the front of the buffer, into it's
							// correct place in the array.
							//
							painaddrAddresses[dwTemp].S_un.S_addr = ((SOCKADDR_IN*) (paSocketAddresses[dwTemp].lpSockaddr))->sin_addr.S_un.S_addr;

							DPFX(DPFPREP, 7, "\t%u- %u.%u.%u.%u",
								dwTemp,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
								painaddrAddresses[dwTemp].S_un.S_un_b.s_b4);
						}
						else
						{
							DPFX(DPFPREP, 1, "\t%u- Ignoring 0.0.0.0 address.", dwTemp);
							dwAddressesSize++;

							//
							// The code should handle this fine, but why is
							// WinSock doing this to us?
							//
							DNASSERT(FALSE);
						}
					}

					//
					// Subtract out any invalid addresses that we skipped.
					//
					dwNumAddresses -= dwAddressesSize;
					if (dwNumAddresses == 0)
					{
						DPFX(DPFPREP, 1, "WinSock 2 reported only invalid addresses, hoping WinSock 1 method picks up the loopback address.");

						DNFree(painaddrAddresses);
						painaddrAddresses = NULL;
					}
				}
				else
				{
					DPFX(DPFPREP, 1, "WinSock 2 Ioctl did not report any valid addresses, hoping WinSock 1 method picks up the loopback address.");

					DNFree(painaddrAddresses);
					painaddrAddresses = NULL;
				}

				//
				// Get out of the loop.
				//
				break;
			}
		}
		while (TRUE);
	}


	//
	// Get the list of all available addresses from the WinSock 1 API if we
	// don't already have them.
	//
	if (painaddrAddresses == NULL)
#endif // ! DPNBUILD_NOWINSOCK2
	{
		if (this->m_pfngethostname(szName, 1000) != 0)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't get host name, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		phostent = this->m_pfngethostbyname(szName);
		if (phostent == NULL)
		{
#ifdef DBG
			dwError = this->m_pfnWSAGetLastError();
			DPFX(DPFPREP, 0, "Couldn't retrieve addresses, error = %u!", dwError);
#endif // DBG
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		//
		// WinSock says that you need to copy this data before you make any
		// other API calls.  So first we count the number of entries we need to
		// copy.
		//
		ppinaddr = (IN_ADDR**) phostent->h_addr_list;
		while ((*ppinaddr) != NULL)
		{
			//
			// Ignore 0.0.0.0 addresses.
			//
			if ((*ppinaddr)->S_un.S_addr != INADDR_NONE)
			{
				dwNumAddresses++;
			}
			else
			{
				DPFX(DPFPREP, 1, "Ignoring 0.0.0.0 address.");

				//
				// The code should handle this fine, but why is WinSock doing
				// this to us?
				//
				DNASSERT(FALSE);
			}

			ppinaddr++;
		}


		//
		// If there aren't any addresses, we must fail.  WinSock 1 ought to
		// report the loopback address at least.
		//
		if (dwNumAddresses == 0)
		{
			DPFX(DPFPREP, 0, "WinSock 1 did not report any valid addresses!");
			hr = DPNHERR_GENERIC;
			goto Failure;
		}


		DPFX(DPFPREP, 7, "WinSock 1 method returned %u valid addresses:", dwNumAddresses);

		painaddrAddresses = (IN_ADDR*) DNMalloc(dwNumAddresses * sizeof(IN_ADDR));
		if (painaddrAddresses == NULL)
		{
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}

		//
		// Now copy all the addresses.
		//
		ppinaddr = (IN_ADDR**) phostent->h_addr_list;
		
		dwTemp = 0;
		while ((*ppinaddr) != NULL)
		{
			//
			// Ignore 0.0.0.0 addresses again.
			//
			if ((*ppinaddr)->S_un.S_addr != INADDR_NONE)
			{
				painaddrAddresses[dwTemp].S_un.S_addr = (*ppinaddr)->S_un.S_addr;
				
				DPFX(DPFPREP, 7, "\t%u- %u.%u.%u.%u",
					dwTemp,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
					painaddrAddresses[dwTemp].S_un.S_un_b.s_b4);

				dwTemp++;
			}

			ppinaddr++;
		}
				
		DNASSERT(dwTemp == dwNumAddresses);
	}
	/*
	else
	{
		//
		// Already have addresses array.
		//
	}
	*/


	//
	// Make sure that all of the devices we currently know about are still
	// around.
	//
	pBilinkDevice = this->m_blDevices.GetNext();
	while (pBilinkDevice != &this->m_blDevices)
	{
		DNASSERT(! pBilinkDevice->IsEmpty());
		pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
		pBilinkDevice = pBilinkDevice->GetNext();

		fFound = FALSE;
		for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
		{
			if (painaddrAddresses[dwTemp].S_un.S_addr == pDevice->GetLocalAddressV4())
			{
				fFound = TRUE;
				break;
			}
		}

		if (fFound)
		{
			//
			// It may be time for this device to use a different port...
			//
			dwTemp = pDevice->GetFirstUPnPDiscoveryTime();
			if ((dwTemp != 0) && ((GETTIMESTAMP() - dwTemp) > g_dwReusePortTime))
			{
				ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
				saddrinTemp.sin_family				= AF_INET;
				saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

				sTemp = this->CreateSocket(&saddrinTemp, SOCK_DGRAM, IPPROTO_UDP);
				if (sTemp != INVALID_SOCKET)
				{
					//
					// Sanity check that we didn't lose the device address.
					//
					DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4());

					DPFX(DPFPREP, 4, "Device 0x%p UPnP discovery socket 0x%p (%u.%u.%u.%u:%u) created to replace port %u.",
						pDevice,
						sTemp,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
						saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
						NTOHS(saddrinTemp.sin_port),
						NTOHS(pDevice->GetUPnPDiscoverySocketPort()));

#ifndef DPNBUILD_NOHNETFWAPI
					//
					// If we used the HomeNet firewall API to open a hole for UPnP
					// discovery multicasts, close it.
					//
					if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
					{
						hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, NULL);
						if (hr != DPNH_OK)
						{
							DPFX(DPFPREP, 0, "Couldn't close device 0x%p's previous UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
								pDevice, hr);

							//
							// Continue...
							//
							pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
							hr = DPNH_OK;
						}
					}
#endif // ! DPNBUILD_NOHNETFWAPI

					pDevice->SetUPnPDiscoverySocketPort(saddrinTemp.sin_port);
					pDevice->SetFirstUPnPDiscoveryTime(0);

					//
					// Close the existing socket.
					//
					this->m_pfnclosesocket(pDevice->GetUPnPDiscoverySocket());

					//
					// Transfer ownership of the new socket to the device.
					//
					pDevice->SetUPnPDiscoverySocket(sTemp);
					sTemp = INVALID_SOCKET;

					DPFX(DPFPREP, 8, "Device 0x%p got re-assigned UPnP socket 0x%p.",
						pDevice, pDevice->GetUPnPDiscoverySocket());

					//
					// We'll let the normal "check for firewall" code detect
					// the fact that the discovery socket is not mapped on the
					// firewall and try to do so there (if it even needs to be
					// mapped).  See UpdateServerStatus.
					//
				}
				else
				{
					DPFX(DPFPREP, 0, "Couldn't create a replacement UPnP discovery socket for device 0x%p!  Using existing port %u.",
						pDevice, NTOHS(pDevice->GetUPnPDiscoverySocketPort()));
				}
			}
		}
		else
		{
			//
			// Didn't find this device in the returned list, forget about
			// it.
			//
#ifdef DBG
			{
				IN_ADDR		inaddrTemp;


				inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
				DPFX(DPFPREP, 1, "Device 0x%p no longer exists, removing (address was %u.%u.%u.%u).",
					pDevice,
					inaddrTemp.S_un.S_un_b.s_b1,
					inaddrTemp.S_un.S_un_b.s_b2,
					inaddrTemp.S_un.S_un_b.s_b3,
					inaddrTemp.S_un.S_un_b.s_b4);
			}

			this->m_dwNumDeviceRemoves++;
#endif // DBG


			//
			// Override the minimum UpdateServerStatus interval so that we can
			// get information on any local public address changes due to the
			// possible loss of a server on this interface.
			//
			this->m_dwFlags |= NATHELPUPNPOBJ_DEVICECHANGED;

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			//
			// Forcefully mark the UPnP gateway device as disconnected.
			//
			if (pDevice->GetUPnPDevice() != NULL)
			{
				this->ClearDevicesUPnPDevice(pDevice);
			}
			

			//
			// Mark all ports that were registered to this device as unowned
			// by putting them into the wildcard list.  First unmap them from
			// the firewall.
			//
			pBilinkRegPort = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilinkRegPort != &pDevice->m_blOwnedRegPorts)
			{
				DNASSERT(! pBilinkRegPort->IsEmpty());
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilinkRegPort);
				pBilinkRegPort = pBilinkRegPort->GetNext();

				DPFX(DPFPREP, 1, "Registered port 0x%p's device went away, marking as unowned.",
					pRegisteredPort);


#ifndef DPNBUILD_NOHNETFWAPI
				//
				// Even though the device is gone, we can still remove the
				// firewall mapping.
				//
				if (pRegisteredPort->IsMappedOnHNetFirewall())
				{
					//
					// Unmap the port.
					//
					// Alert the user since this is unexpected.
					//
					hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort,
															TRUE,
															TRUE);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't unmap registered port 0x%p from device 0x%p's firewall (err = 0x%lx)!  Ignoring.",
							pRegisteredPort, pDevice, hr);

						pRegisteredPort->NoteNotMappedOnHNetFirewall();
						pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

						//
						// Continue anyway.
						//
						hr = DPNH_OK;
					}
				}
				
				pRegisteredPort->NoteNotHNetFirewallPortUnavailable();
#endif // ! DPNBUILD_NOHNETFWAPI

				DNASSERT(! pRegisteredPort->HasUPnPPublicAddresses());
				DNASSERT(! pRegisteredPort->IsUPnPPortUnavailable());

				pRegisteredPort->ClearDeviceOwner();
				pRegisteredPort->m_blDeviceList.RemoveFromList();
				pRegisteredPort->m_blDeviceList.InsertBefore(&this->m_blUnownedPorts);

				//
				// The user doesn't directly need to be informed.  If the ports
				// previously had public addresses, the ADDRESSESCHANGED flag
				// would have already been set by ClearDevicesUPnPDevice. If
				// they didn't have ports with public addresses, then the user
				// won't see any difference and thus ADDRESSESCHANGED wouldn't
				// need to be set.
				//
			}


#ifndef DPNBUILD_NOHNETFWAPI
			//
			// If we used the HomeNet firewall API to open a hole for UPnP
			// discovery multicasts, close it.
			//
			if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
			{
				hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, NULL);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't close device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
						pDevice, hr);

					//
					// Continue...
					//
					pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
					hr = DPNH_OK;
				}
			}
#endif // ! DPNBUILD_NOHNETFWAPI


			pDevice->m_blList.RemoveFromList();


			//
			// Close the socket, if we had one.
			//
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
			{
				this->m_pfnclosesocket(pDevice->GetUPnPDiscoverySocket());
				pDevice->SetUPnPDiscoverySocket(INVALID_SOCKET);
			}

			delete pDevice;
		}
	}


	//
	// Search for all returned devices in our existing list, and add new
	// entries for each one that we didn't already know about.
	//
	for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
	{
		fFound = FALSE;

		pBilinkDevice = this->m_blDevices.GetNext();
		while (pBilinkDevice != &this->m_blDevices)
		{
			DNASSERT(! pBilinkDevice->IsEmpty());
			pDevice = DEVICE_FROM_BILINK(pBilinkDevice);
			pBilinkDevice = pBilinkDevice->GetNext();

			if (pDevice->GetLocalAddressV4() == painaddrAddresses[dwTemp].S_un.S_addr)
			{
				fFound = TRUE;
				break;
			}
		}

		if (! fFound)
		{
			//
			// We didn't know about this device.  Create a new object.
			//
			pDevice = new CDevice(painaddrAddresses[dwTemp].S_un.S_addr);
			if (pDevice == NULL)
			{
				hr = DPNHERR_OUTOFMEMORY;
				goto Failure;
			}

			fDeviceCreated = TRUE;


#ifdef DBG
			DPFX(DPFPREP, 1, "Found new device %u.%u.%u.%u, (object = 0x%p).",
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b1,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b2,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b3,
				painaddrAddresses[dwTemp].S_un.S_un_b.s_b4,
				pDevice);

			this->m_dwNumDeviceAdds++;
#endif // DBG


			//
			// Override the minimum UpdateServerStatus interval so that we can
			// get information on this new device.
			//
			this->m_dwFlags |= NATHELPUPNPOBJ_DEVICECHANGED;

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			//
			// Create the UPnP discovery socket, if we're allowed.
			//
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP)
			{
				ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
				saddrinTemp.sin_family				= AF_INET;
				saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();

				sTemp = this->CreateSocket(&saddrinTemp, SOCK_DGRAM, IPPROTO_UDP);
				if (sTemp == INVALID_SOCKET)
				{
					DPFX(DPFPREP, 0, "Couldn't create a UPnP discovery socket!  Ignoring address (and destroying device 0x%p).",
						pDevice);

					//
					// Get rid of the device.
					//
					delete pDevice;
					pDevice = NULL;


					//
					// Forget about device in case of failure later.
					//
					fDeviceCreated = FALSE;


					//
					// Move to next address.
					//
					continue;
				}

				//
				// Sanity check that we didn't lose the device address.
				//
				DNASSERT(saddrinTemp.sin_addr.S_un.S_addr == pDevice->GetLocalAddressV4());

				DPFX(DPFPREP, 4, "Device 0x%p UPnP discovery socket 0x%p (%u.%u.%u.%u:%u) created.",
					pDevice,
					sTemp,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b1,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b2,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b3,
					saddrinTemp.sin_addr.S_un.S_un_b.s_b4,
					NTOHS(saddrinTemp.sin_port));

				pDevice->SetUPnPDiscoverySocketPort(saddrinTemp.sin_port);

				//
				// Transfer ownership of the socket to the device.
				//
				pDevice->SetUPnPDiscoverySocket(sTemp);
				sTemp = INVALID_SOCKET;

				DPFX(DPFPREP, 8, "Device 0x%p got assigned UPnP socket 0x%p.",
					pDevice, pDevice->GetUPnPDiscoverySocket());
			}


#ifndef DPNBUILD_NOHNETFWAPI
			if (this->m_dwFlags & NATHELPUPNPOBJ_USEHNETFWAPI)
			{
				//
				// Check if the local firewall is enabled.
				//
				hr = this->CheckForLocalHNetFirewallAndMapPorts(pDevice, NULL);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't check for local HNet firewall and map ports (err = 0x%lx)!  Continuing.",
						hr);
					DNASSERT(! pDevice->IsHNetFirewalled());
					hr = DPNH_OK;
				}
			}
			else
			{
				//
				// Not using firewall traversal.
				//
			}
#endif // ! DPNBUILD_NOHNETFWAPI


			//
			// Add the device to our known list.
			//
			pDevice->m_blList.InsertBefore(&this->m_blDevices);


			//
			// Inform the caller if they care.
			//
			if (pfFoundNewDevices != NULL)
			{
				(*pfFoundNewDevices) = TRUE;
			}


			//
			// Forget about device in case of failure later.
			//
			fDeviceCreated = FALSE;
		}
	}


	//
	// If we got some very weird failures and ended up here without any
	// devices, complain to management (or the caller of this function, that's
	// probably more convenient).
	//
	if (this->m_blDevices.IsEmpty())
	{
		DPFX(DPFPREP, 0, "No usable devices, cannot proceed!", 0);
		DNASSERTX(! "No usable devices!", 2);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


Exit:

	if (painaddrAddresses != NULL)
	{
		DNFree(painaddrAddresses);
		painaddrAddresses = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (sTemp != INVALID_SOCKET)
	{
		this->m_pfnclosesocket(sTemp);
		sTemp = INVALID_SOCKET;
	}

	if (fDeviceCreated)
	{
		delete pDevice;
	}

	goto Exit;
} // CNATHelpUPnP::CheckForNewDevices




#ifndef DPNBUILD_NOHNETFWAPI



#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts"
//=============================================================================
// CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts
//-----------------------------------------------------------------------------
//
// Description:    Looks for a local HomeNet API aware firewall, and ensures
//				there are mappings for each of the device's registered ports,
//				if a firewall is found.
//
//				   If any registered port (except pDontAlertRegisteredPort if
//				not NULL) gets mapped, then it will trigger an address update
//				alert the next time the user calls GetCaps.
//
//				   The main object lock is assumed to be held.  It will be
//				converted into the long lock for the duration of this function.
//
// Arguments:
//	CDevice * pDevice							- Pointer to device to check.
//	CRegisteredPort * pDontAlertRegisteredPort	- Pointer to registered port
//													that should not trigger an
//													address update alert, or
//													NULL.
//
// Returns: HRESULT
//	DPNH_OK				- Search completed successfully.  There may or may not
//							be a firewall.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts(CDevice * const pDevice,
														CRegisteredPort * const pDontAlertRegisteredPort)
{
	HRESULT				hr = DPNH_OK;
	BOOL				fSwitchedToLongLock = FALSE;
	BOOL				fUninitializeCOM = FALSE;
	IHNetCfgMgr *		pHNetCfgMgr = NULL;
	IHNetConnection *	pHNetConnection = NULL;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pDevice, pDontAlertRegisteredPort);


	//
	// If this is the loopback address, don't bother trying to map anything.
	//
	if (pDevice->GetLocalAddressV4() == NETWORKBYTEORDER_INADDR_LOOPBACK)
	{
		DPFX(DPFPREP, 7, "No firewall behavior necessary with loopback device 0x%p.",
			pDevice);
		goto Exit;
	}
	

	//
	// If we don't have IPHLPAPI or RASAPI32, we can't do anything (and
	// shouldn't need to).
	//
	if ((this->m_hIpHlpApiDLL == NULL) || (this->m_hRasApi32DLL == NULL))
	{
		DPFX(DPFPREP, 7, "Didn't load IPHLPAPI and/or RASAPI32, not getting HNet interfaces for device 0x%p.",
			pDevice);
		goto Exit;
	}


	//
	// Using the HomeNet API (particularly the out-of-proc COM calls) during
	// stress is really, really, painfully slow.  Since we have one global lock
	// the controls everything, other threads may be sitting for an equally
	// long time... so long, in fact, that the critical section timeout fires
	// and we get a false stress hit.  So we have a sneaky workaround to
	// prevent that from happening while still maintaining ownership of the
	// object.
	//
	this->SwitchToLongLock();
	fSwitchedToLongLock = TRUE;


	//
	// Try to initialize COM if we weren't instantiated through COM.  It may
	// have already been initialized in a different mode, which is okay.  As
	// long as it has been initialized somehow, we're fine.
	//
	if (this->m_dwFlags & NATHELPUPNPOBJ_NOTCREATEDWITHCOM)
	{
		hr = CoInitializeEx(NULL, (COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE));
		switch (hr)
		{
			case S_OK:
			{
				//
				// Success, that's good.  Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Successfully initialized COM.");
				fUninitializeCOM = TRUE;
				break;
			}

			case S_FALSE:
			{
				//
				// Someone else already initialized COM, but that's okay.
				// Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Initialized COM (again).");
				fUninitializeCOM = TRUE;
				break;
			}

			case RPC_E_CHANGED_MODE:
			{
				//
				// Someone else already initialized COM in a different mode.
				// It should be okay, but we don't have to balance the CoInit
				// call with a CoUninit.
				//
				DPFX(DPFPREP, 8, "Didn't initialize COM, already initialized in a different mode.");
				break;
			}

			default:
			{
				//
				// Hmm, something else is going on.  We can't handle that.
				//
				DPFX(DPFPREP, 0, "Initializing COM failed (err = 0x%lx)!", hr);
				goto Failure;
				break;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Object was instantiated through COM, no need to initialize COM.");
	}


	//
	// Try creating the main HNet manager object.
	//
	hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_INPROC_SERVER,
						IID_IHNetCfgMgr, (PVOID*) (&pHNetCfgMgr));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't create IHNetCfgMgr interface for device 0x%p (err = 0x%lx), assuming firewall control interface unavailable.",
			pDevice, hr);
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// We created the IHNetCfgMgr object as in-proc, so there's no proxy that
	// requires security settings.
	//
	//SETDEFAULTPROXYBLANKET(pHNetCfgMgr);



	//
	// Get the HNetConnection object for this device.
	//
	hr = this->GetIHNetConnectionForDeviceIfFirewalled(pDevice,
														pHNetCfgMgr,
														&pHNetConnection);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't get IHNetConnection interface for device 0x%p (err = 0x%lx), assuming firewall not enabled.",
			pDevice, hr);


		//
		// If the device was previously firewalled, we need to clear our info.
		//
		if (pDevice->IsHNetFirewalled())
		{
			DPFX(DPFPREP, 2, "Firewall is no longer enabled for device 0x%p.",
				pDevice);

			//
			// Since there was a change in the network, go back to polling
			// relatively quickly.
			//
			this->ResetNextPollInterval();


			DNASSERT(pDevice->HasCheckedForFirewallAvailability());


			pBilink = pDevice->m_blOwnedRegPorts.GetNext();
			while (pBilink != &pDevice->m_blOwnedRegPorts)
			{
				DNASSERT(! pBilink->IsEmpty());
				pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

				//
				// Unmap items mapped on the firewall.
				//
				if (pRegisteredPort->IsMappedOnHNetFirewall())
				{
					DPFX(DPFPREP, 1, "Unmapping registered port 0x%p from device 0x%p's disappearing firewall.",
						pRegisteredPort, pDevice);


					hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort,
																	TRUE,
																	pHNetCfgMgr);
					if (hr != DPNH_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't unmap registered port 0x%p from device 0x%p's firewall (err = 0x%lx)!  Ignoring.",
							pRegisteredPort, pDevice, hr);

						pRegisteredPort->NoteNotMappedOnHNetFirewall();
						pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

						//
						// Continue anyway.
						//
						hr = DPNH_OK;
					}


					//
					// Alert the user.
					//
					this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
				}
				else
				{
					DPFX(DPFPREP, 1, "Registered port 0x%p was not mapped on device 0x%p's disappearing firewall, assuming being called within RegisterPorts.",
						pRegisteredPort, pDevice);
				}


				//
				// Go to next port.
				//
				pBilink = pBilink->GetNext();
			}


			//
			// If we used the HomeNet firewall API to open a hole for UPnP
			// discovery multicasts, unmap that, too.
			//
			if (pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall())
			{
				DPFX(DPFPREP, 0, "Device 0x%p's UPnP discovery socket's forcefully unmapped from disappearing firewall.",
					pDevice);

				hr = this->CloseDevicesUPnPDiscoveryPort(pDevice, pHNetCfgMgr);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't close device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring.",
						pDevice, hr);

					//
					// Continue...
					//
					pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
					hr = DPNH_OK;
				}
			}


			//
			// Turn off the flag now that all registered ports have been
			// removed.
			//
			pDevice->NoteNotHNetFirewalled();
		}
		else
		{
			if (! pDevice->HasCheckedForFirewallAvailability())
			{
				//
				// The firewall is not enabled.
				//

				DPFX(DPFPREP, 2, "Firewall is not enabled for device 0x%p.",
					pDevice);

				pDevice->NoteCheckedForFirewallAvailability();


				//
				// Since it is possible to remove mappings even without the
				// firewall enabled, we can be courteous and unmap any stale
				// entries left by previous app crashes when the firewall was
				// still enabled.
				//

				//
				// Pretend that it currently had been firewalled.
				//
				pDevice->NoteHNetFirewalled();


				//
				// Cleanup the mappings.
				//
				hr = this->CleanupInactiveFirewallMappings(pDevice, pHNetCfgMgr);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Failed cleaning up inactive firewall mappings with device 0x%p (firewall not initially enabled)!",
						pDevice);
					goto Failure;
				}


				//
				// Turn off the flag we temporarily enabled while clearing
				// the mappings.
				//
				pDevice->NoteNotHNetFirewalled();
			}
			else
			{
				//
				// The firewall is still not enabled.
				//
				DPFX(DPFPREP, 2, "Firewall is still not enabled for device 0x%p.",
					pDevice);
			}
		}
		
		hr = DPNH_OK;
		goto Exit;
	}


	//
	// If firewalling is enabled now, and wasn't before, we need to map all the
	// existing ports.  If it had been, we're fine.
	//
	if (! pDevice->IsHNetFirewalled())
	{
		DPFX(DPFPREP, 2, "Firewall is now enabled for device 0x%p.",
			pDevice);

		pDevice->NoteCheckedForFirewallAvailability();
		pDevice->NoteHNetFirewalled();

		//
		// Since there was a change in the network, go back to polling
		// relatively quickly.
		//
		this->ResetNextPollInterval();


		//
		// If we're allowed, we need to try opening a hole so that we can
		// receive responses from device discovery multicasts.  We'll
		// ignore failures, since this is only to support the funky case of
		// enabling firewall behind a NAT.
		//
		if ((g_fMapUPnPDiscoverySocket) &&
			(pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) &&
			(this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP))
		{
			hr = this->OpenDevicesUPnPDiscoveryPort(pDevice,
													pHNetCfgMgr,
													pHNetConnection);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't open device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring, NAT may be undetectable.",
					pDevice, hr);
				hr = DPNH_OK;

				//
				// Continue...
				//
			}
		}
		else
		{
			DPFX(DPFPREP, 3, "Not opening device 0x%p's UPnP discovery port (domap = %i, loopback = %i, upnp = %i).",
				pDevice,
				g_fMapUPnPDiscoverySocket,
				((pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) ? FALSE : TRUE),
				((this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP) ? TRUE : FALSE));
		}


		//
		// Try to remove any mappings that were not freed earlier because
		// we crashed.
		//
		hr = this->CleanupInactiveFirewallMappings(pDevice, pHNetCfgMgr);
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 0, "Failed cleaning up inactive firewall mappings with device 0x%p's new firewall!",
				pDevice);
			goto Failure;
		}
	}
	else
	{
		DPFX(DPFPREP, 2, "Firewall is still enabled for device 0x%p.",
			pDevice);

		DNASSERT(pDevice->HasCheckedForFirewallAvailability());

		//
		// Try to map the discovery socket if it hasn't been (and we're allowed
		// & supposed to).
		//
		if ((g_fMapUPnPDiscoverySocket) &&
			(! pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall()) &&
			(pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) &&
			(this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP))
		{
			hr = this->OpenDevicesUPnPDiscoveryPort(pDevice,
													pHNetCfgMgr,
													pHNetConnection);
			if (hr != DPNH_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't open device 0x%p's UPnP discovery socket's port on firewall (err = 0x%lx)!  Ignoring, NAT may be undetectable.",
					pDevice, hr);
				hr = DPNH_OK;

				//
				// Continue...
				//
			}
		}
		else
		{
			DPFX(DPFPREP, 3, "Not opening device 0x%p's UPnP discovery port (domap = %i, already = %i, loopback = %i, upnp = %i).",
				pDevice,
				g_fMapUPnPDiscoverySocket,
				pDevice->IsUPnPDiscoverySocketMappedOnHNetFirewall(),
				((pDevice->GetLocalAddressV4() != NETWORKBYTEORDER_INADDR_LOOPBACK) ? FALSE : TRUE),
				((this->m_dwFlags & NATHELPUPNPOBJ_USEUPNP) ? TRUE : FALSE));
		}
	}


	//
	// Map all the ports that haven't been yet.
	//
	hr = this->MapUnmappedPortsOnLocalHNetFirewall(pDevice,
													pHNetCfgMgr,
													pHNetConnection,
													pDontAlertRegisteredPort);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't map ports on device 0x%p's new firewall (err = 0x%lx)!",
			pDevice, hr);
		goto Failure;
	}


	DNASSERT(hr == DPNH_OK);


Exit:

	if (pHNetConnection != NULL)
	{
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}

	if (pHNetCfgMgr != NULL)
	{
		pHNetCfgMgr->Release();
		pHNetCfgMgr = NULL;
	}

	if (fUninitializeCOM)
	{
		DPFX(DPFPREP, 8, "Uninitializing COM.");
		CoUninitialize();
		fUninitializeCOM = FALSE;
	}

	if (fSwitchedToLongLock)
	{
		this->SwitchFromLongLock();
		fSwitchedToLongLock = FALSE;
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	//
	// Ensure that the device is not considered to be firewalled.
	//
	pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();
	pDevice->NoteNotHNetFirewalled();


	//
	// Make sure no registered ports are marked as firewalled either.
	//
	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);

		if (pRegisteredPort->IsMappedOnHNetFirewall())
		{
			DPFX(DPFPREP, 1, "Registered port 0x%p forcefully marked as not mapped on HomeNet firewall.",
				pRegisteredPort);

			pRegisteredPort->NoteNotMappedOnHNetFirewall();
			pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
		}

		pBilink = pBilink->GetNext();
	}

	goto Exit;
} // CNATHelpUPnP::CheckForLocalHNetFirewallAndMapPorts






#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled"
//=============================================================================
// CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled
//-----------------------------------------------------------------------------
//
// Description:    Returns an IHNetConnection interface for the given device.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice						- Pointer to device whose
//												IHNetConnection interface
//												should be retrieved.
//	IHNetCfgMgr * pHNetCfgMgr				- IHNetCfgMgr interface to use.
//	IHNetConnection ** ppHNetConnection		- Place to store IHetConnection
//												interface retrieved.
//
// Returns: HRESULT
//	DPNH_OK				- Interface retrieved successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled(CDevice * const pDevice,
															IHNetCfgMgr * const pHNetCfgMgr,
															IHNetConnection ** const ppHNetConnection)
{
	HRESULT								hr;
	DWORD								dwError;
	IHNetFirewallSettings *				pHNetFirewallSettings = NULL;
	IEnumHNetFirewalledConnections *	pEnumHNetFirewalledConnections = NULL;
	IHNetFirewalledConnection *			pHNetFirewalledConnection = NULL;
	ULONG								ulNumFound;
	IHNetConnection *					pHNetConnection = NULL;
	HNET_CONN_PROPERTIES *				pHNetConnProperties;
	BOOL								fLanConnection;
	IN_ADDR								inaddrTemp;
	TCHAR								tszDeviceIPAddress[16];	// "nnn.nnn.nnn.nnn" + NULL termination
	BOOL								fHaveDeviceGUID = FALSE;
	TCHAR								tszGuidDevice[GUID_STRING_LENGTH + 1];	// include NULL termination
	TCHAR								tszGuidHNetConnection[GUID_STRING_LENGTH + 1];	// include NULL termination
	GUID *								pguidHNetConnection = NULL;
	WCHAR *								pwszPhonebookPath = NULL;
	WCHAR *								pwszName = NULL;
	HRASCONN							hrasconn;
	RASPPPIP							raspppip;
	DWORD								dwSize;


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr, ppHNetConnection);


	//
	// Convert the IP address right away.  We use it frequently so there's no
	// sense in continually regenerating it.
	//
	inaddrTemp.S_un.S_addr = pDevice->GetLocalAddressV4();
	wsprintf(tszDeviceIPAddress, _T("%u.%u.%u.%u"),
			inaddrTemp.S_un.S_un_b.s_b1,
			inaddrTemp.S_un.S_un_b.s_b2,
			inaddrTemp.S_un.S_un_b.s_b3,
			inaddrTemp.S_un.S_un_b.s_b4);


	//
	// Here is what we're going to do in this function:
	//
	//	IHNetCfgMgr::QueryInterface for IHNetFirewallSettings
	//	IHNetFirewallSettings::EnumFirewalledConnections
	//		IHNetFirewalledConnection::QueryInterface for IHNetConnection
	//		get the IHNetConnection's HNET_CONN_PROPERTIES
	//		if HNET_CONN_PROPERTIES.fLanConnection
	//			IHNetConnection::GetGuid()
	//			if GUID matches IPHLPAPI GUID
	//					We've got the one we want, we're done
	//			else
	//				Keep looping
	//		else
	//			IHNetConnection::GetRasPhonebookPath and IHNetConnection::GetName to pass into RasGetEntryHrasconnW as pszPhonebook and pszEntry, respectively
	//			if got HRASCONN
	//				RasGetProjectionInfo
	//				if IP matches the IP we're looking for
	//					We've got the one we want, we're done
	//				else
	//					Keep looping
	//			else
	//				RAS entry is not dialed, keep looping
	//	if didn't find object
	//		it's not firewalled
	//


	//
	// Get the firewall settings object.
	//
	hr = pHNetCfgMgr->QueryInterface(IID_IHNetFirewallSettings,
									(PVOID*) (&pHNetFirewallSettings));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't query for IHNetFirewallSettings interface (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pHNetFirewallSettings);


	//
	// Get the firewalled connections enumeration via IHNetFirewallSettings.
	//
	hr = pHNetFirewallSettings->EnumFirewalledConnections(&pEnumHNetFirewalledConnections);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't query for IHNetFirewallSettings interface (err = 0x%lx)!",
			hr);

		//
		// Make sure we don't try to release a bogus pointer in case it got
		// set.
		//
		pEnumHNetFirewalledConnections = NULL;

		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pEnumHNetFirewalledConnections);


	//
	// Don't need the IHNetFirewallSettings interface anymore.
	//
	pHNetFirewallSettings->Release();
	pHNetFirewallSettings = NULL;


	//
	// Keep looping until we find the item or run out of items.
	//
	do
	{
		hr = pEnumHNetFirewalledConnections->Next(1,
												&pHNetFirewalledConnection,
												&ulNumFound);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Couldn't get next connection (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// If there aren't any more items, bail.
		//
		if (ulNumFound == 0)
		{
			//
			// pEnumHNetFirewalledConnections->Next might have returned
			// S_FALSE.
			//
			hr = DPNH_OK;
			break;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetFirewalledConnection);


		//
		// Get the IHNetConnection interface.
		//
		hr = pHNetFirewalledConnection->QueryInterface(IID_IHNetConnection,
														(PVOID*) (&pHNetConnection));
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't query for IHNetConnection interface (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetConnection);


		//
		// We don't need the firewalled connection object anymore.
		//
		pHNetFirewalledConnection->Release();
		pHNetFirewalledConnection = NULL;


		//
		// Get the internal properties for this adapter.
		//
		hr = pHNetConnection->GetProperties(&pHNetConnProperties);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get home net connection properties (err = 0x%lx)!",
				hr);
			goto Failure;
		}

		//
		// Be somewhat picky about whether adapters returned by
		// IEnumHNetFirewalledConnections actually be firewalled.
		//
		DNASSERTX(pHNetConnProperties->fFirewalled, 2);


		fLanConnection = pHNetConnProperties->fLanConnection;


		//
		// Free the properties buffer.
		//
		CoTaskMemFree(pHNetConnProperties);
		//pHNetConnProperties = NULL;


		//
		// Now if it's a LAN connection, see if the GUID matches the one
		// returned by IPHLPAPI.
		// If it's a RAS connection, see if this phonebook entry is dialed and
		// has the right IP address.
		//
		if (fLanConnection)
		{
			//
			// LAN case.  If we haven't already retrieved the device's GUID, do
			// so now.
			//
			if (! fHaveDeviceGUID)
			{
				hr = this->GetIPAddressGuidString(tszDeviceIPAddress, tszGuidDevice);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get device 0x%p's GUID (err = 0x%lx)!",
						hr);
					goto Failure;
				}

				fHaveDeviceGUID = TRUE;
			}


			//
			// Get the HNetConnection object's GUID.
			//
			hr = pHNetConnection->GetGuid(&pguidHNetConnection);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection 0x%p's GUID (err = 0x%lx)!",
					pHNetConnection, hr);
				goto Failure;
			}


			//
			// Convert the GUID into a string.
			//
			wsprintf(tszGuidHNetConnection,
					_T("{%-08.8X-%-04.4X-%-04.4X-%02.2X%02.2X-%02.2X%02.2X%02.2X%02.2X%02.2X%02.2X}"),
					pguidHNetConnection->Data1,
					pguidHNetConnection->Data2,
					pguidHNetConnection->Data3,
					pguidHNetConnection->Data4[0],
					pguidHNetConnection->Data4[1],
					pguidHNetConnection->Data4[2],
					pguidHNetConnection->Data4[3],
					pguidHNetConnection->Data4[4],
					pguidHNetConnection->Data4[5],
					pguidHNetConnection->Data4[6],
					pguidHNetConnection->Data4[7]);


			CoTaskMemFree(pguidHNetConnection);
			pguidHNetConnection = NULL;


#ifdef DBG
			//
			// Attempt to get the HNetConnection object's name for debugging
			// purposes.
			//
			hr = pHNetConnection->GetName(&pwszName);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection 0x%p name (err = 0x%lx)!",
					pHNetConnection, hr);
				goto Failure;
			}
#endif // DBG


			//
			// See if we found the object we need.
			//
			if (_tcsicmp(tszGuidHNetConnection, tszGuidDevice) == 0)
			{
				DPFX(DPFPREP, 7, "Matched IHNetConnection object 0x%p \"%ls\" to device 0x%p (LAN GUID %s).",
					pHNetConnection, pwszName, pDevice, tszGuidHNetConnection);

				//
				// Transfer reference to caller.
				//
				(*ppHNetConnection) = pHNetConnection;
				pHNetConnection = NULL;

#ifdef DBG
				CoTaskMemFree(pwszName);
				pwszName = NULL;
#endif // DBG

				//
				// We're done here.
				//
				hr = DPNH_OK;
				goto Exit;
			}

			
			DPFX(DPFPREP, 7, "Non-matching IHNetConnection 0x%p \"%ls\"",
				pHNetConnection, pwszName);
			DPFX(DPFPREP, 7, "\t(LAN GUID %s <> %s).",
				tszGuidHNetConnection, tszGuidDevice);

#ifdef DBG
			CoTaskMemFree(pwszName);
			pwszName = NULL;
#endif // DBG
		}
		else
		{
			//
			// RAS case.
			//
			DNASSERT(this->m_hRasApi32DLL != NULL);

			
			//
			// Get the HNetConnection object's phonebook path.
			//
			hr = pHNetConnection->GetRasPhonebookPath(&pwszPhonebookPath);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection's RAS phonebook path (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// Get the HNetConnection object's name.
			//
			hr = pHNetConnection->GetName(&pwszName);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get HNetConnection's name (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// Look for an active RAS connection from that phonebook with that
			// name.
			//
			dwError = this->m_pfnRasGetEntryHrasconnW(pwszPhonebookPath, pwszName, &hrasconn);
			if (dwError != 0)
			{
				//
				// It's probably ERROR_NO_CONNECTION (668).
				//
				DPFX(DPFPREP, 1, "Couldn't get entry's active RAS connection (err = %u), assuming not dialed",
					dwError);
				DPFX(DPFPREP, 1, "\tname \"%ls\", phonebook \"%ls\".",
					pwszName, pwszPhonebookPath);
			}
			else
			{
				//
				// Get the IP address.
				//

				ZeroMemory(&raspppip, sizeof(raspppip));
				raspppip.dwSize = sizeof(raspppip);
				dwSize = sizeof(raspppip);

				dwError = this->m_pfnRasGetProjectionInfo(hrasconn, RASP_PppIp, &raspppip, &dwSize);
				if (dwError != 0)
				{
					DPFX(DPFPREP, 0, "Couldn't get RAS connection's IP information (err = %u)!",
						dwError);
					hr = DPNHERR_GENERIC;
					goto Failure;
				}


				//
				// See if we found the object we need.
				//
				if (_tcsicmp(raspppip.szIpAddress, tszDeviceIPAddress) == 0)
				{
					DPFX(DPFPREP, 7, "Matched IHNetConnection object 0x%p to device 0x%p (RAS IP %s)",
						pHNetConnection, pDevice, raspppip.szIpAddress);
					DPFX(DPFPREP, 7, "\tname \"%ls\", phonebook \"%ls\".",
						pwszName, pwszPhonebookPath);

					//
					// Transfer reference to caller.
					//
					(*ppHNetConnection) = pHNetConnection;
					pHNetConnection = NULL;

					//
					// We're done here.
					//
					hr = DPNH_OK;
					goto Exit;
				}

				
				DPFX(DPFPREP, 7, "Non-matching IHNetConnection 0x%p (RAS IP %s != %s)",
					pHNetConnection, raspppip.szIpAddress, tszDeviceIPAddress);
				DPFX(DPFPREP, 7, "\tname \"%ls\", phonebook \"%ls\").",
					pwszName, pwszPhonebookPath);
			}


			CoTaskMemFree(pwszPhonebookPath);
			pwszPhonebookPath = NULL;

			CoTaskMemFree(pwszName);
			pwszName = NULL;
		}


		//
		// If we're here, we pHNetConnection is not the one we're looking for.
		//
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}
	while (TRUE);


	//
	// If we're here, then we didn't find a matching firewall connection.
	//
	DPFX(DPFPREP, 3, "Didn't find device 0x%p in list of firewalled connections.",
		pDevice);
	hr = DPNHERR_GENERIC;


Exit:

	if (pEnumHNetFirewalledConnections != NULL)
	{
		pEnumHNetFirewalledConnections->Release();
		pEnumHNetFirewalledConnections = NULL;
	}

	DPFX(DPFPREP, 6, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pwszName != NULL)
	{
		CoTaskMemFree(pwszName);
		pwszName = NULL;
	}
	
	if (pwszPhonebookPath == NULL)
	{
		CoTaskMemFree(pwszPhonebookPath);
		pwszPhonebookPath = NULL;
	}

	if (pHNetConnection != NULL)
	{
		pHNetConnection->Release();
		pHNetConnection = NULL;
	}

	if (pHNetFirewalledConnection != NULL)
	{
		pHNetFirewalledConnection->Release();
		pHNetFirewalledConnection = NULL;
	}

	if (pHNetFirewallSettings != NULL)
	{
		pHNetFirewallSettings->Release();
		pHNetFirewallSettings = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::GetIHNetConnectionForDeviceIfFirewalled





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::GetIPAddressGuidString"
//=============================================================================
// CNATHelpUPnP::GetIPAddressGuidString
//-----------------------------------------------------------------------------
//
// Description:    Retrieves the IPHLPAPI assigned GUID (in string format) for
//				the given IP address string.  ptszGuidString must be able to
//				hold GUID_STRING_LENGTH + 1 characters.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	TCHAR * tszDeviceIPAddress	- IP address string to lookup.
//	TCHAR * ptszGuidString		- Place to store device's GUID string.
//
// Returns: HRESULT
//	DPNH_OK				- Interface retrieved successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::GetIPAddressGuidString(const TCHAR * const tszDeviceIPAddress,
											TCHAR * const ptszGuidString)
{
	HRESULT				hr = DPNH_OK;
	DWORD				dwError;
	PIP_ADAPTER_INFO	pAdaptersBuffer = NULL;
	ULONG				ulSize;
	PIP_ADAPTER_INFO	pAdapterInfo;
	PIP_ADDR_STRING		pIPAddrString;
	char *				pszAdapterGuid = NULL;
#ifdef UNICODE
	char				szDeviceIPAddress[16];	// "nnn.nnn.nnn.nnn" + NULL termination
#endif // UNICODE
#ifdef DBG
	char				szIPList[256];
	char *				pszCurrentIP;
#endif // DBG


	DPFX(DPFPREP, 6, "(0x%p) Parameters: (\"%s\", 0x%p)",
		this, tszDeviceIPAddress, ptszGuidString);


	DNASSERT(this->m_hIpHlpApiDLL != NULL);


	//
	// Keep trying to get the list of adapters until we get ERROR_SUCCESS or a
	// legitimate error (other than ERROR_BUFFER_OVERFLOW or
	// ERROR_INSUFFICIENT_BUFFER).
	//
	ulSize = 0;
	do
	{
		dwError = this->m_pfnGetAdaptersInfo(pAdaptersBuffer, &ulSize);
		if (dwError == ERROR_SUCCESS)
		{
			//
			// We succeeded, we should be set.  But make sure there are
			// adapters for us to use.
			//
			if (ulSize < sizeof(IP_ADAPTER_INFO))
			{
				DPFX(DPFPREP, 0, "Getting adapters info succeeded but didn't return any valid adapters (%u < %u)!",
					ulSize, sizeof(IP_ADAPTER_INFO));
				hr = DPNHERR_GENERIC;
				goto Failure;
			}

			break;
		}

		if ((dwError != ERROR_BUFFER_OVERFLOW) &&
			(dwError != ERROR_INSUFFICIENT_BUFFER))
		{
			DPFX(DPFPREP, 0, "Unable to get adapters info (error = 0x%lx)!",
				dwError);
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// We need more adapter space.  Make sure there are adapters for us to
		// use.
		//
		if (ulSize < sizeof(IP_ADAPTER_INFO))
		{
			DPFX(DPFPREP, 0, "Getting adapters info didn't return any valid adapters (%u < %u)!",
				ulSize, sizeof(IP_ADAPTER_INFO));
			hr = DPNHERR_GENERIC;
			goto Failure;
		}

		//
		// If we previously had a buffer, free it.
		//
		if (pAdaptersBuffer != NULL)
		{
			DNFree(pAdaptersBuffer);
		}

		//
		// Allocate the buffer.
		//
		pAdaptersBuffer = (PIP_ADAPTER_INFO) DNMalloc(ulSize);
		if (pAdaptersBuffer == NULL)
		{
			DPFX(DPFPREP, 0, "Unable to allocate memory for adapters info!");
			hr = DPNHERR_OUTOFMEMORY;
			goto Failure;
		}
	}
	while (TRUE);


#ifdef UNICODE
	STR_jkWideToAnsi(szDeviceIPAddress,
					tszDeviceIPAddress,
					16);
	szDeviceIPAddress[15] = 0; // ensure it's NULL terminated
#endif // UNICODE


	//
	// Now find the device in the adapter list returned.  Loop through all
	// adapters.
	//
	pAdapterInfo = pAdaptersBuffer;
	while (pAdapterInfo != NULL)
	{
#ifdef DBG
		//
		// Initialize IP address list string.
		//
		szIPList[0] = '\0';
		pszCurrentIP = szIPList;
#endif // DBG

		//
		// Loop through all addresses for this adapter looking for the one for
		// the device we have bound.
		//
		pIPAddrString = &pAdapterInfo->IpAddressList;
		while (pIPAddrString != NULL)
		{
#ifdef DBG
			int		iStrLen;


			//
			// Copy the IP address string (if there's enough room), then tack
			// on a space and NULL terminator.
			//
			iStrLen = strlen(pIPAddrString->IpAddress.String);
			if ((pszCurrentIP + iStrLen + 2) < (szIPList + sizeof(szIPList)))
			{
				memcpy(pszCurrentIP, pIPAddrString->IpAddress.String, iStrLen);
				pszCurrentIP += iStrLen;
				(*pszCurrentIP) = ' ';
				pszCurrentIP++;
				(*pszCurrentIP) = '\0';
				pszCurrentIP++;
			}
#endif // DBG

#ifdef UNICODE
			if (strcmp(pIPAddrString->IpAddress.String, szDeviceIPAddress) == 0)
#else // ! UNICODE
			if (strcmp(pIPAddrString->IpAddress.String, tszDeviceIPAddress) == 0)
#endif // ! UNICODE
			{
				DPFX(DPFPREP, 8, "Found %s under adapter index %u (\"%hs\").",
					tszDeviceIPAddress, pAdapterInfo->Index, pAdapterInfo->Description);

				DNASSERT(pszAdapterGuid == NULL);
				pszAdapterGuid = pAdapterInfo->AdapterName;


				//
				// Drop out of the loop in retail, keep going in debug.
				//
#ifndef DBG
				break;
#endif // ! DBG
			}

			pIPAddrString = pIPAddrString->Next;
		}


		//
		// Drop out of the loop in retail, print this entry and keep going in
		// debug.
		//
#ifdef DBG
		DPFX(DPFPREP, 7, "Adapter index %u IPs = %hs, %hs, \"%hs\".",
			pAdapterInfo->Index,
			szIPList,
			pAdapterInfo->AdapterName,
			pAdapterInfo->Description);
#else // ! DBG
		if (pszAdapterGuid != NULL)
		{
			break;
		}
#endif // ! DBG

		pAdapterInfo = pAdapterInfo->Next;
	}


	//
	// pszAdapterGuid will be NULL if we never found the device.
	//
	if (pszAdapterGuid == NULL)
	{
		DPFX(DPFPREP, 0, "Did not find adapter with matching address for address %s!",
			tszDeviceIPAddress);
		hr = DPNHERR_GENERIC;
		goto Failure;
	}


	//
	// Copy the adapter GUID string to the buffer supplied.
	//
#ifdef UNICODE
	STR_jkAnsiToWide(ptszGuidString,
					pszAdapterGuid,
					(GUID_STRING_LENGTH + 1));
#else // ! UNICODE
	strncpy(ptszGuidString, pszAdapterGuid, (GUID_STRING_LENGTH + 1));
#endif // ! UNICODE
	ptszGuidString[GUID_STRING_LENGTH] = 0;	// ensure it's NULL terminated


Exit:

	if (pAdaptersBuffer != NULL)
	{
		DNFree(pAdaptersBuffer);
		pAdaptersBuffer = NULL;
	}

	DPFX(DPFPREP, 6, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::GetIPAddressGuidString





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort"
//=============================================================================
// CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort
//-----------------------------------------------------------------------------
//
// Description:    Maps the UPnP discovery socket's port if a firewall is
//				found.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice					- Pointer to device whose port should
//											be opened.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//	IHNetConnection * pHNetConnection	- Pointer to IHNetConnection interface
//											for the given device.
//
// Returns: HRESULT
//	DPNH_OK				- Mapping completed successfully.  There may or may not
//							be a firewall.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort(CDevice * const pDevice,
													IHNetCfgMgr * const pHNetCfgMgr,
													IHNetConnection * const pHNetConnection)
{
	HRESULT				hr = DPNH_OK;
	CRegisteredPort *	pRegisteredPort = NULL;
	SOCKADDR_IN			saddrinTemp;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr, pHNetConnection);


	DNASSERT(pDevice->IsHNetFirewalled());



	//
	// Create a fake UDP registered port to map.
	//
	pRegisteredPort = new CRegisteredPort(0, 0);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	pRegisteredPort->MakeDeviceOwner(pDevice);


	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinTemp.sin_port				= pDevice->GetUPnPDiscoverySocketPort();
	DNASSERT(saddrinTemp.sin_port != 0);

	hr = pRegisteredPort->SetPrivateAddresses(&saddrinTemp, 1);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set registered port 0x%p's private addresses (err = 0x%lx)!",
			pRegisteredPort, hr);
		goto Failure;
	}


	//
	// Map the port.
	//
	hr = this->MapPortOnLocalHNetFirewall(pRegisteredPort,
										pHNetCfgMgr,
										pHNetConnection,
										FALSE);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't map UPnP discovery socket port (temp regport = 0x%p) on device 0x%p's initial firewall (err = 0x%lx)!",
			pRegisteredPort, pDevice, hr);
		goto Failure;
	}


	//
	// If the port was unavailable, we have to give up on supporting the
	// scenario (firewall enabled behind a NAT).  Otherwise, remember the fact
	// that we mapped the port, and then delete the registered port object.  We
	// will unmap it when we shut down the device.
	//
	if (! pRegisteredPort->IsHNetFirewallPortUnavailable())
	{
		DPFX(DPFPREP, 3, "Mapped UPnP discovery socket for device 0x%p on firewall (removing temp regport 0x%p).",
			pDevice, pRegisteredPort);


		pDevice->NoteUPnPDiscoverySocketMappedOnHNetFirewall();

		//
		// Clear this to prevent an assert.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
	}
	else
	{
		DPFX(DPFPREP, 1, "Could not map UPnP discovery socket on firewall for device 0x%p, unable to support an upstream NAT.",
			pDevice);
	}

	pRegisteredPort->ClearPrivateAddresses();
	pRegisteredPort->ClearDeviceOwner();


	//
	// Delete the item.
	//
	delete pRegisteredPort;
	pRegisteredPort = NULL;


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pRegisteredPort != NULL)
	{
		//
		// Clear any settings that might cause an assert.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
		pRegisteredPort->ClearPrivateAddresses();
		pRegisteredPort->ClearDeviceOwner();


		//
		// Delete the item.
		//
		delete pRegisteredPort;
		pRegisteredPort = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::OpenDevicesUPnPDiscoveryPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort"
//=============================================================================
// CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort
//-----------------------------------------------------------------------------
//
// Description:    Unmaps the UPnP discovery socket's port from the firewall.
//				pHNetCfgMgr can be NULL if it has not previously been obtained.
//
//				   COM is assumed to have been initialized if pHNetCfgMgr is
//				not NULL.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice			- Pointer to device whose port should be
//									close.
//	IHNetCfgMgr * pHNetCfgMgr	- Pointer to IHNetCfgMgr interface to use, or
//									NULL if not previously obtained.
//
// Returns: HRESULT
//	DPNH_OK				- Unmapping completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort(CDevice * const pDevice,
													IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT				hr = DPNH_OK;
	CRegisteredPort *	pRegisteredPort = NULL;
	SOCKADDR_IN			saddrinTemp;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr);


	//
	// Create a fake UDP registered port to unmap.
	//
	pRegisteredPort = new CRegisteredPort(0, 0);
	if (pRegisteredPort == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}

	pRegisteredPort->MakeDeviceOwner(pDevice);
	pRegisteredPort->NoteMappedOnHNetFirewall();


	ZeroMemory(&saddrinTemp, sizeof(saddrinTemp));
	saddrinTemp.sin_family				= AF_INET;
	saddrinTemp.sin_addr.S_un.S_addr	= pDevice->GetLocalAddressV4();
	saddrinTemp.sin_port				= pDevice->GetUPnPDiscoverySocketPort();
	DNASSERT(saddrinTemp.sin_port != 0);

	hr = pRegisteredPort->SetPrivateAddresses(&saddrinTemp, 1);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't set registered port 0x%p's private addresses (err = 0x%lx)!",
			pRegisteredPort, hr);
		goto Failure;
	}


	//
	// Unmap the port using the internal method if possible.
	//
	if (pHNetCfgMgr != NULL)
	{
		hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort, TRUE, pHNetCfgMgr);
	}
	else
	{
		//
		// Don't alert the user since he/she doesn't know about this port.
		//
		hr = this->UnmapPortOnLocalHNetFirewall(pRegisteredPort, TRUE, FALSE);
	}
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't unmap UPnP discovery socket port (temp regport = 0x%p) on device 0x%p's firewall (err = 0x%lx)!",
			pRegisteredPort, pDevice, hr);
		goto Failure;
	}


	//
	// Destroy the registered port object (note that the port mapping still
	// exists).  We will unmap when we shut down the device.
	//
	pRegisteredPort->ClearPrivateAddresses();
	pRegisteredPort->ClearDeviceOwner();


	//
	// Delete the item.
	//
	delete pRegisteredPort;
	pRegisteredPort = NULL;


	pDevice->NoteNotUPnPDiscoverySocketMappedOnHNetFirewall();


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pRegisteredPort != NULL)
	{
		//
		// Clear any settings that might cause an assert.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();
		pRegisteredPort->ClearPrivateAddresses();
		pRegisteredPort->ClearDeviceOwner();


		//
		// Delete the item.
		//
		delete pRegisteredPort;
		pRegisteredPort = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::CloseDevicesUPnPDiscoveryPort





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall"
//=============================================================================
// CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall
//-----------------------------------------------------------------------------
//
// Description:    Maps any ports associated with the given device that have
//				not been mapped with the local firewall yet.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CDevice * pDevice							- Device with (new) firewall.
//	IHNetCfgMgr * pHNetCfgMgr					- Pointer to IHNetCfgMgr
//													interface to use.
//	IHNetConnection * pHNetConnection			- Pointer to IHNetConnection
//													interface for the given
//													device.
//	CRegisteredPort * pDontAlertRegisteredPort	- Pointer to registered port
//													that should not trigger an
//													address update alert, or
//													NULL.
//
// Returns: HRESULT
//	DPNH_OK				- Mapping completed successfully.  Note that the ports
//							may be marked as unavailable.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall(CDevice * const pDevice,
														IHNetCfgMgr * const pHNetCfgMgr,
														IHNetConnection * const pHNetConnection,
														CRegisteredPort * const pDontAlertRegisteredPort)
{
	HRESULT				hr = DPNH_OK;
	CBilink *			pBilink;
	CRegisteredPort *	pRegisteredPort;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, 0x%p)",
		this, pDevice, pHNetCfgMgr, pHNetConnection, pDontAlertRegisteredPort);


	DNASSERT(pDevice->IsHNetFirewalled());



	//
	// Loop through all the registered ports associated with the device.
	//
	pBilink = pDevice->m_blOwnedRegPorts.GetNext();
	while (pBilink != &pDevice->m_blOwnedRegPorts)
	{
		DNASSERT(! pBilink->IsEmpty());
		pRegisteredPort = REGPORT_FROM_DEVICE_BILINK(pBilink);
		pBilink = pBilink->GetNext();


		//
		// If this port has already been mapped, we can skip it.
		//
		if (pRegisteredPort->IsMappedOnHNetFirewall())
		{
			DPFX(DPFPREP, 7, "Registered port 0x%p has already been mapped on the firewall for device 0x%p.",
				pRegisteredPort, pDevice);
			continue;
		}


		//
		// If this port has already been determined to be unavailable, we can
		// skip it.
		//
		if (pRegisteredPort->IsHNetFirewallPortUnavailable())
		{
			DPFX(DPFPREP, 7, "Registered port 0x%p has already been determined to be unavailable on the firewall for device 0x%p.",
				pRegisteredPort, pDevice);
			continue;
		}


		DPFX(DPFPREP, 3, "Mapping registered port 0x%p on firewall for device 0x%p.",
			pRegisteredPort, pDevice);
		

		hr = this->MapPortOnLocalHNetFirewall(pRegisteredPort,
											pHNetCfgMgr,
											pHNetConnection,
											((pRegisteredPort == pDontAlertRegisteredPort) ? FALSE : TRUE));
		if (hr != DPNH_OK)
		{
			DPFX(DPFPREP, 7, "Failed mapping registered port 0x%p on firewall for device 0x%p.",
				pRegisteredPort, pDevice);
			goto Failure;
		}


		//
		// Go to next registered port.
		//
	}


Exit:

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::MapUnmappedPortsOnLocalHNetFirewall





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::MapPortOnLocalHNetFirewall"
//=============================================================================
// CNATHelpUPnP::MapPortOnLocalHNetFirewall
//-----------------------------------------------------------------------------
//
// Description:    Maps the given port with the corresponding firewall.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Port to map.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//	IHNetConnection * pHNetConnection	- Pointer to IHNetConnection interface
//											for the given device.
//	BOOL fNoteAddressChange				- Whether to alert the user of the
//											address change or not.
//
// Returns: HRESULT
//	DPNH_OK				- Mapping completed successfully.  Note that the ports
//							may be marked as unavailable.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::MapPortOnLocalHNetFirewall(CRegisteredPort * const pRegisteredPort,
												IHNetCfgMgr * const pHNetCfgMgr,
												IHNetConnection * const pHNetConnection,
												const BOOL fNoteAddressChange)
{
	HRESULT								hr = DPNH_OK;
	CDevice *							pDevice;
	SOCKADDR_IN *						pasaddrinPrivate;
	UCHAR								ucProtocolToMatch;
	ULONG								ulNumFound;
	BOOLEAN								fTemp;
	IHNetProtocolSettings *				pHNetProtocolSettings = NULL;
	IEnumHNetPortMappingProtocols *		pEnumHNetPortMappingProtocols = NULL;
	IHNetPortMappingProtocol **			papHNetPortMappingProtocol = NULL;
	DWORD								dwTemp;
	BOOL								fCreatedCurrentPortMappingProtocol = FALSE;
	IHNetPortMappingBinding *			pHNetPortMappingBinding = NULL;
	DWORD								dwTargetAddressV4;
	WORD								wPort;
	UCHAR								ucProtocol;
	DWORD								dwDescriptionLength;
	TCHAR								tszPort[32];
	CRegistry							RegObject;
	WCHAR								wszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	DPNHACTIVEFIREWALLMAPPING			dpnhafm;
	BOOLEAN								fBuiltIn = FALSE;
	WCHAR *								pwszPortMappingProtocolName = NULL;
#ifdef UNICODE
	TCHAR *								ptszDescription = wszDescription;
#else // ! UNICODE
	char								szDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE];
	TCHAR *								ptszDescription = szDescription;
#endif // ! UNICODE


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p, 0x%p, %i)",
		this, pRegisteredPort, pHNetCfgMgr, pHNetConnection, fNoteAddressChange);


	DNASSERT(! pRegisteredPort->IsMappedOnHNetFirewall());
	DNASSERT(! pRegisteredPort->IsHNetFirewallPortUnavailable());


	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);
	DNASSERT(pDevice->IsHNetFirewalled());


	//
	// Get a protocol settings interface.
	//
	hr = pHNetCfgMgr->QueryInterface(IID_IHNetProtocolSettings,
									(PVOID*) (&pHNetProtocolSettings));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get IHNetProtocolSettings interface from IHNetCfgMgr 0x%p (err = 0x%lx)!",
			pHNetCfgMgr, hr);
		goto Failure;
	}

	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pHNetProtocolSettings);


	//
	// Get ready to enumerate the existing mappings.
	//

	hr = pHNetProtocolSettings->EnumPortMappingProtocols(&pEnumHNetPortMappingProtocols);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't enumerate port mapping protocols (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pEnumHNetPortMappingProtocols);


	//
	// Allocate an array to keep track of previous ports in case of failure.
	//
	papHNetPortMappingProtocol = (IHNetPortMappingProtocol**) DNMalloc(DPNH_MAX_SIMULTANEOUS_PORTS * sizeof(IHNetPortMappingProtocol*));
	if (papHNetPortMappingProtocol == NULL)
	{
		hr = DPNHERR_OUTOFMEMORY;
		goto Failure;
	}



	pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

	if (pRegisteredPort->IsTCP())
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_TCP;
	}
	else
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_UDP;
	}


	//
	// Map each individual address associated with the port.
	//
	for(dwTemp = 0; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
	{
		DNASSERT(pasaddrinPrivate[dwTemp].sin_port != 0);


		//
		// Loop until we find a duplicate item or run out of items.
		//
		do
		{
			hr = pEnumHNetPortMappingProtocols->Next(1,
													&papHNetPortMappingProtocol[dwTemp],
													&ulNumFound);
			if (FAILED(hr))
			{
				DPFX(DPFPREP, 0, "Couldn't get next port mapping protocol (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// If there aren't any more items, bail.
			//
			if (ulNumFound == 0)
			{
				//
				// pEnumHNetPortMappingProtocols->Next might have returned
				// S_FALSE.
				//
				hr = DPNH_OK;
				break;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(papHNetPortMappingProtocol[dwTemp]);


			//
			// Get the port.
			//
			hr = papHNetPortMappingProtocol[dwTemp]->GetPort(&wPort);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol 0x%p's port (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);

				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetPort!"), 2);

				goto Failure;
			}


			//
			// Get the protocol.
			//
			hr = papHNetPortMappingProtocol[dwTemp]->GetIPProtocol(&ucProtocol);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol 0x%p's IP protocol (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);

				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetIPProtocol!"), 2);

				goto Failure;
			}


#ifdef DBG
			hr = papHNetPortMappingProtocol[dwTemp]->GetName(&pwszPortMappingProtocolName);
			if (hr == S_OK)
			{
				DPFX(DPFPREP, 7, "Found %s port mapping protocol 0x%p (\"%ls\") for port %u.",
					(((wPort == pasaddrinPrivate[dwTemp].sin_port) && (ucProtocol == ucProtocolToMatch)) ? _T("matching") : _T("non-matching")),
					papHNetPortMappingProtocol[dwTemp],
					pwszPortMappingProtocolName,
					NTOHS(wPort));

				CoTaskMemFree(pwszPortMappingProtocolName);
				pwszPortMappingProtocolName = NULL;
			}
			else
			{
				DPFX(DPFPREP, 7, "Found %s port mapping protocol 0x%p for port %u, (unable to retrieve name, err = %0lx).",
					(((wPort == pasaddrinPrivate[dwTemp].sin_port) && (ucProtocol == ucProtocolToMatch)) ? _T("matching") : _T("non-matching")),
					NTOHS(wPort),
					papHNetPortMappingProtocol[dwTemp],
					hr);
			}
#endif // DBG

			//
			// See if we found the object we need.
			//
			if ((wPort == pasaddrinPrivate[dwTemp].sin_port) &&
				(ucProtocol == ucProtocolToMatch))
			{
				break;
			}


			//
			// Get ready for the next object.
			//
			papHNetPortMappingProtocol[dwTemp]->Release();
			papHNetPortMappingProtocol[dwTemp] = NULL;
		}
		while (TRUE);


		//
		// Generate a description for this mapping.  The format is:
		//
		//     [executable_name] nnnnn {"TCP" | "UDP"}
		//
		// unless it's shared, in which case it's
		//
		//     [executable_name] (255.255.255.255:nnnnn) nnnnn {"TCP" | "UDP"}
		//
		// That way nothing needs to be localized.
		//

		wsprintf(tszPort, _T("%u"),
				NTOHS(pasaddrinPrivate[dwTemp].sin_port));

		dwDescriptionLength = GetModuleFileName(NULL,
												ptszDescription,
												(MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1));
		if (dwDescriptionLength != 0)
		{
			//
			// Be paranoid and make sure the description string is valid.
			//
			ptszDescription[MAX_UPNP_MAPPING_DESCRIPTION_SIZE - 1] = 0;

			//
			// Get just the executable name from the path.
			//
#ifdef WINCE
			GetExeName(ptszDescription);
#else // ! WINCE
#ifdef UNICODE
			_wsplitpath(ptszDescription, NULL, NULL, ptszDescription, NULL);
#else // ! UNICODE
			_splitpath(ptszDescription, NULL, NULL, ptszDescription, NULL);
#endif // ! UNICODE
#endif // ! WINCE


			if (pRegisteredPort->IsSharedPort())
			{
				dwDescriptionLength = _tcslen(ptszDescription)		// executable name
									+ strlen(" (255.255.255.255:")	// " (255.255.255.255:"
									+ _tcslen(tszPort)				// port
									+ strlen(") ")					// ") "
									+ _tcslen(tszPort)				// port
									+ 4;							// " TCP" | " UDP"
			}
			else
			{
				dwDescriptionLength = _tcslen(ptszDescription)	// executable name
									+ 1							// " "
									+_tcslen(tszPort)			// port
									+ 4;						// " TCP" | " UDP"
			}

			//
			// Make sure the long string will fit.  If not, use the
			// abbreviated version.
			//
			if (dwDescriptionLength > MAX_UPNP_MAPPING_DESCRIPTION_SIZE)
			{
				dwDescriptionLength = 0;
			}
		}

		if (dwDescriptionLength == 0)
		{
			//
			// Use the abbreviated version we know will fit.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				wsprintf(ptszDescription,
						_T("(255.255.255.255:%s) %s %s"),
						tszPort,
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
			else
			{
				wsprintf(ptszDescription,
						_T("%s %s"),
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
		}
		else
		{
			//
			// There's enough room, tack on the rest of the description.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				wsprintf((ptszDescription + _tcslen(ptszDescription)),
						_T(" (255.255.255.255:%s) %s %s"),
						tszPort,
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
			else
			{
				wsprintf((ptszDescription + _tcslen(ptszDescription)),
						_T(" %s %s"),
						tszPort,
						((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
			}
		}

#ifndef UNICODE
		dwDescriptionLength = MAX_UPNP_MAPPING_DESCRIPTION_SIZE;
		hr = STR_AnsiToWide(szDescription, -1, wszDescription, &dwDescriptionLength);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't convert NAT mapping description to Unicode (err = 0x%lx)!",
				hr);
			goto Failure;
		}
#endif // ! UNICODE



		//
		// If there wasn't a port mapping already, create it.  Otherwise make
		// sure it's not already in use by some other client.
		//
		if (papHNetPortMappingProtocol[dwTemp] == NULL)
		{
			DPFX(DPFPREP, 7, "Creating new port mapping protocol \"%ls\".",
				wszDescription);


			//
			// Create a new port mapping protocol.
			//
			DPFX(DPFPREP, 9, "++ pHNetProtocolSettings(0x%p)->CreatePortMappingProtocol(\"%ls\", %u, 0x%lx, 0x%p)", pHNetProtocolSettings, wszDescription, ucProtocolToMatch, pasaddrinPrivate[dwTemp].sin_port, &papHNetPortMappingProtocol[dwTemp]);
			hr = pHNetProtocolSettings->CreatePortMappingProtocol(wszDescription,
																ucProtocolToMatch,
																pasaddrinPrivate[dwTemp].sin_port,
																&papHNetPortMappingProtocol[dwTemp]);
			DPFX(DPFPREP, 9, "-- pHNetProtocolSettings(0x%p)->CreatePortMappingProtocol = 0x%lx", pHNetProtocolSettings, hr);
			if (hr != S_OK)
			{
				//
				// This might be WBEM_E_ACCESSDENIED (0x80041003), which means
				// the current user doesn't have permissions to open holes in
				// the firewall.
				//

				DPFX(DPFPREP, 0, "Couldn't create new port mapping protocol (err = 0x%lx)!",
					hr);

				goto Failure;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(papHNetPortMappingProtocol[dwTemp]);


			fCreatedCurrentPortMappingProtocol = TRUE;



			//
			// Retrieve its binding.
			//
			DPFX(DPFPREP, 9, "++ pHNetConnection(0x%p)->GetBindingForPortMappingProtocol(0x%p, 0x%p)", pHNetConnection, papHNetPortMappingProtocol[dwTemp], &pHNetPortMappingBinding);
			hr = pHNetConnection->GetBindingForPortMappingProtocol(papHNetPortMappingProtocol[dwTemp],
																&pHNetPortMappingBinding);
			DPFX(DPFPREP, 9, "-- pHNetConnection(0x%p)->GetBindingForPortMappingProtocol = 0x%lx", pHNetConnection, hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get binding for port mapping protocol 0x%p (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);
				goto Failure;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(pHNetPortMappingBinding);


			//
			// Make sure it refers to the local device (or the broadcast
			// address, if shared).  Although shared ports are a strange
			// concept on a firewall, Microsoft's firewall implementation
			// shares mappings with the NAT, so we'd rather be safe than sorry.
			// Mapping it to the broadcast address makes it behave the same if
			// the firewalled adapter also happens to be shared.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress((broadcast) 0x%lx)", pHNetPortMappingBinding, INADDR_BROADCAST);
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(INADDR_BROADCAST);
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}
			else
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress(0x%lx)", pHNetPortMappingBinding, pDevice->GetLocalAddressV4());
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(pDevice->GetLocalAddressV4());
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't set binding 0x%p's target computer address (err = 0x%lx)!",
					pHNetPortMappingBinding, hr);
				goto Failure;
			}
		}
		else
		{
			//
			// Retrieve the existing binding.
			//
			DPFX(DPFPREP, 9, "++ pHNetConnection(0x%p)->GetBindingForPortMappingProtocol(0x%p, 0x%p)", pHNetConnection, papHNetPortMappingProtocol[dwTemp], &pHNetPortMappingBinding);
			hr = pHNetConnection->GetBindingForPortMappingProtocol(papHNetPortMappingProtocol[dwTemp],
																&pHNetPortMappingBinding);
			DPFX(DPFPREP, 9, "-- pHNetConnection(0x%p)->GetBindingForPortMappingProtocol = 0x%lx", pHNetConnection, hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get binding for port mapping protocol 0x%p (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);
				goto Failure;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(pHNetPortMappingBinding);


			//
			// Find out where this mapping goes.
			//
			DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->GetTargetComputerAddress(0x%p)", pHNetPortMappingBinding, &dwTargetAddressV4);
			hr = pHNetPortMappingBinding->GetTargetComputerAddress(&dwTargetAddressV4);
			DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->GetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get binding 0x%p's target computer address (err = 0x%lx)!",
					pHNetPortMappingBinding, hr);
				goto Failure;
			}


			//
			// If it's not for the local device, we may have to leave it alone.
			//
			if ((dwTargetAddressV4 != pDevice->GetLocalAddressV4()) &&
				((! pRegisteredPort->IsSharedPort()) ||
				(dwTargetAddressV4 != INADDR_BROADCAST)))
			{
				//
				// Find out if it's turned on.
				//
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->GetEnabled(0x%p)", pHNetPortMappingBinding, &fTemp);
				hr = pHNetPortMappingBinding->GetEnabled(&fTemp);
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->GetEnabled = 0x%lx", pHNetPortMappingBinding, hr);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get binding 0x%p's target computer address (err = 0x%lx)!",
						pHNetPortMappingBinding, hr);
					goto Failure;
				}


				//
				// If it's currently active, it's better to be safe than sorry.
				// Don't attempt to replace it.
				//
				if (fTemp)
				{
					DPFX(DPFPREP, 1, "Existing active binding points to different target %u.%u.%u.%u, can't reuse for device 0x%p.",
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b1,
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b2,
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b3,
						((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b4,
						pDevice);
					
					//
					// Mark this port as unavailable.
					//
					pRegisteredPort->NoteHNetFirewallPortUnavailable();


					//
					// Cleanup this port mapping.
					//

					pHNetPortMappingBinding->Release();
					pHNetPortMappingBinding = NULL;

					papHNetPortMappingProtocol[dwTemp]->Release();
					papHNetPortMappingProtocol[dwTemp] = NULL;


					//
					// Reset for next port.
					//
					DPFX(DPFPREP, 9, "++ pEnumHNetPortMappingProtocols(0x%p)->Reset()", pEnumHNetPortMappingProtocols);
					hr = pEnumHNetPortMappingProtocols->Reset();
					DPFX(DPFPREP, 9, "-- pEnumHNetPortMappingProtocols(0x%p)->Reset = 0x%lx", pEnumHNetPortMappingProtocols, hr);
					if (hr != S_OK)
					{
						DPFX(DPFPREP, 0, "Couldn't reset port mapping protocol enumeration 0x%p (err = 0x%lx)!",
							pEnumHNetPortMappingProtocols, hr);
						goto Failure;
					}


					//
					// Get out of the loop.
					//
					break;
				}


				//
				// It's inactive.
				//
				DPFX(DPFPREP, 7, "Modifying inactive port mapping protocol (target was %u.%u.%u.%u) for device 0x%p (new name = \"%ls\").",
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b1,
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b2,
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b3,
					((IN_ADDR*) (&dwTargetAddressV4))->S_un.S_un_b.s_b4,
					pDevice,
					wszDescription);
			}
			else
			{
				//
				// It matches the local device, or we're mapping a shared port
				// and the mapping pointed to the broadcast address.
				// Assume it's okay to replace.
				//
				DPFX(DPFPREP, 7, "Modifying existing port mapping protocol (device = 0x%p, new name = \"%ls\" unless built-in).",
					pDevice,
					wszDescription);
			}


			//
			// Otherwise, it's safe to change it.
			//


			//
			// Make sure it refers to the local device (or the broadcast
			// address, if shared).  Although shared ports are a strange
			// concept on a firewall, Microsoft's firewall implementation
			// shares mappings with the NAT, so we'd rather be safe than sorry.
			// Mapping it to the broadcast address makes it behave the same if
			// the firewalled adapter also happens to be shared.
			//
			if (pRegisteredPort->IsSharedPort())
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress((broadcast) 0x%lx)", pHNetPortMappingBinding, INADDR_BROADCAST);
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(INADDR_BROADCAST);
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}
			else
			{
				DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress(0x%lx)", pHNetPortMappingBinding, pDevice->GetLocalAddressV4());
				hr = pHNetPortMappingBinding->SetTargetComputerAddress(pDevice->GetLocalAddressV4());
				DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetTargetComputerAddress = 0x%lx", pHNetPortMappingBinding, hr);
			}

			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't set binding 0x%p's target computer address (err = 0x%lx)!",
					pHNetPortMappingBinding, hr);
				goto Failure;
			}


			//
			// See if this protocol is built-in.
			//
			DPFX(DPFPREP, 9, "++ papHNetPortMappingProtocol[%u](0x%p)->GetBuiltIn(0x%p)", dwTemp, papHNetPortMappingProtocol[dwTemp], &fBuiltIn);
			hr = papHNetPortMappingProtocol[dwTemp]->GetBuiltIn(&fBuiltIn);
			DPFX(DPFPREP, 9, "-- papHNetPortMappingProtocol[%u](0x%p)->GetBuiltIn = 0x%lx", dwTemp, papHNetPortMappingProtocol[dwTemp], hr);
			if (hr != S_OK)
			{
				DPFX(DPFPREP, 0, "Couldn't get protocol 0x%p's built-in status (err = 0x%lx)!",
					papHNetPortMappingProtocol[dwTemp], hr);
				goto Failure;
			}


			//
			// If it's not built-in, we can change the name.
			//
			if (! fBuiltIn)
			{
				//
				// Update the description.
				//
				DPFX(DPFPREP, 9, "++ papHNetPortMappingProtocol[%u](0x%p)->SetName(\"%ls\")", dwTemp, papHNetPortMappingProtocol[dwTemp], wszDescription);
				hr = papHNetPortMappingProtocol[dwTemp]->SetName(wszDescription);
				DPFX(DPFPREP, 9, "-- papHNetPortMappingProtocol[%u](0x%p)->SetName = 0x%lx", dwTemp, papHNetPortMappingProtocol[dwTemp], hr);
				if (hr != S_OK)
				{
					//
					// This might be WBEM_E_ACCESSDENIED (0x80041003), which
					// means the current user doesn't truly have permissions to
					// open holes in the firewall (even though the
					// SetTargetComputerAddress call above succeeded).
					//

					DPFX(DPFPREP, 0, "Couldn't rename existing port mapping protocol 0x%p (err = 0x%lx)!",
						papHNetPortMappingProtocol[dwTemp], hr);
					goto Failure;
				}
			}
			else
			{
				pRegisteredPort->NoteHNetFirewallMappingBuiltIn();


				DPFX(DPFPREP, 9, "++ papHNetPortMappingProtocol[%u](0x%p)->GetName(0x%p)", dwTemp, papHNetPortMappingProtocol[dwTemp], &pwszPortMappingProtocolName);
				hr = papHNetPortMappingProtocol[dwTemp]->GetName(&pwszPortMappingProtocolName);
				DPFX(DPFPREP, 9, "-- papHNetPortMappingProtocol[%u](0x%p)->GetName = 0x%lx", dwTemp, papHNetPortMappingProtocol[dwTemp], hr);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get built-in port mapping protocol 0x%p's name (err = 0x%lx)!",
						papHNetPortMappingProtocol[dwTemp], hr);
					goto Failure;
				}


				DPFX(DPFPREP, 1, "Re-using built in port mapping protocol \"%ls\" (can't rename to \"%ls\").",
					pwszPortMappingProtocolName, wszDescription);
			}
		} // end else (found port mapping protocol)


		//
		// Enable the binding.
		//
		DPFX(DPFPREP, 9, "++ pHNetPortMappingBinding(0x%p)->SetEnabled(TRUE)", pHNetPortMappingBinding);
		hr = pHNetPortMappingBinding->SetEnabled(TRUE);
		DPFX(DPFPREP, 9, "-- pHNetPortMappingBinding(0x%p)->SetEnabled = 0x%lx", pHNetPortMappingBinding, hr);
		if (hr != S_OK)
		{
			//
			// This might be WBEM_E_ACCESSDENIED (0x80041003), which means the
			// current user doesn't truly have permissions to open holes in the
			// firewall (even though the SetTargetComputerAddress call above
			// succeeded).
			//

			DPFX(DPFPREP, 0, "Couldn't enable binding 0x%p (err = 0x%lx)!",
				pHNetPortMappingBinding, hr);
			goto Failure;
		}


		//
		// Remember this firewall mapping, in case we crash before cleaning it
		// up in this session.  That we can clean it up next time we launch.
		// Don't do this if the port is shared, since we can't tell when it's
		// no longer in use.
		//
		if (! pRegisteredPort->IsSharedPort())
		{
			if (fBuiltIn)
			{
				DPFX(DPFPREP, 7, "Remembering built-in firewall mapping \"%ls\" (a.k.a. \"%ls\") in case of crash.",
					pwszPortMappingProtocolName, wszDescription);
			}
			else
			{
				DPFX(DPFPREP, 7, "Remembering regular firewall mapping \"%ls\" in case of crash.",
					wszDescription);
			}

			if (! RegObject.Open(HKEY_LOCAL_MACHINE,
								DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS,
								FALSE,
								TRUE,
								TRUE,
								DPN_KEY_ALL_ACCESS))
			{
				DPFX(DPFPREP, 0, "Couldn't open active firewall mapping key, unable to save in case of crash!");
			}
			else
			{
				DNASSERT(this->m_dwInstanceKey != 0);


				ZeroMemory(&dpnhafm, sizeof(dpnhafm));
				dpnhafm.dwVersion		= ACTIVE_MAPPING_VERSION;
				dpnhafm.dwInstanceKey	= this->m_dwInstanceKey;
				dpnhafm.dwFlags			= pRegisteredPort->GetFlags();
				dpnhafm.dwAddressV4		= pDevice->GetLocalAddressV4();
				dpnhafm.wPort			= pasaddrinPrivate[dwTemp].sin_port;


				//
				// If it's built-in, use its existing name since it couldn't be
				// renamed.  This allows the unmapping code to find it in the
				// registry again.  See UnmapPortOnLocalHNetFirewallInternal.
				//
				RegObject.WriteBlob(((fBuiltIn) ? pwszPortMappingProtocolName : wszDescription),
									(LPBYTE) (&dpnhafm),
									sizeof(dpnhafm));

				RegObject.Close();
			}
		}
		else
		{
			DPFX(DPFPREP, 7, "Not remembering shared port firewall mapping \"%ls\".",
				wszDescription);
		}


		//
		// Cleanup from this port mapping, and get ready for the next one.
		//

		if (fBuiltIn)
		{
			CoTaskMemFree(pwszPortMappingProtocolName);
			pwszPortMappingProtocolName = NULL;
		}

		pHNetPortMappingBinding->Release();
		pHNetPortMappingBinding = NULL;


		fCreatedCurrentPortMappingProtocol = FALSE;


		hr = pEnumHNetPortMappingProtocols->Reset();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't reset port mapping protocol enumeration 0x%p (err = 0x%lx)!",
				pEnumHNetPortMappingProtocols, hr);
			goto Failure;
		}


		//
		// Alert the user to the change the next time GetCaps is called, if
		// requested.
		//
		if (fNoteAddressChange)
		{
			DPFX(DPFPREP, 8, "Noting that addresses changed (for registered port 0x%p).",
				pRegisteredPort);
			this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
		}


		//
		// Go on to the next port.
		//
	}


	//
	// dwTemp == pRegisteredPort->GetNumAddresses() if everything succeeded, or
	// or the index of the item that was unavailable if not.
	//

	//
	// Free all the port mapping protocol objects.  If we successfully bound
	// all of them, that's all we need to do.  If the port was unavailable, we
	// have to unmap any ports that were successful up to the one that failed.
	//
	while (dwTemp > 0)
	{
		dwTemp--;

		//
		// If we failed to map all ports, delete this previous mapping.
		//
		if (pRegisteredPort->IsHNetFirewallPortUnavailable())
		{
			papHNetPortMappingProtocol[dwTemp]->Delete();	// ignore error
		}

		//
		// Free the object.
		// 
		papHNetPortMappingProtocol[dwTemp]->Release();
		papHNetPortMappingProtocol[dwTemp] = NULL;
	}


	//
	// If we succeeded, mark the registered port as mapped.
	//
	if (! pRegisteredPort->IsHNetFirewallPortUnavailable())
	{
		pRegisteredPort->NoteMappedOnHNetFirewall();
	}



	DNFree(papHNetPortMappingProtocol);
	papHNetPortMappingProtocol = NULL;


	DNASSERT(hr == DPNH_OK);


Exit:

	if (pEnumHNetPortMappingProtocols != NULL)
	{
		pEnumHNetPortMappingProtocols->Release();
		pEnumHNetPortMappingProtocols = NULL;
	}

	if (pHNetProtocolSettings != NULL)
	{
		pHNetProtocolSettings->Release();
		pHNetProtocolSettings = NULL;
	}

	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pwszPortMappingProtocolName != NULL)
	{
		CoTaskMemFree(pwszPortMappingProtocolName);
		pwszPortMappingProtocolName = NULL;
	}

	//
	// If we have an array, then we need to clean it up.  dwTemp will still
	// hold the index of the item we were working on.
	//
	if (papHNetPortMappingProtocol != NULL)
	{
		//
		// Delete the one we were working on, if we created it.
		//
		if (papHNetPortMappingProtocol[dwTemp] != NULL)
		{
			if (fCreatedCurrentPortMappingProtocol)
			{
				papHNetPortMappingProtocol[dwTemp]->Delete();	// ignore error
			}

			papHNetPortMappingProtocol[dwTemp]->Release();
			papHNetPortMappingProtocol[dwTemp] = NULL;
		}


		//
		// Delete all the mappings we successfully made up to the last one.
		//
		while (dwTemp > 0)
		{
			dwTemp--;


			DNASSERT(papHNetPortMappingProtocol[dwTemp] != NULL);

			papHNetPortMappingProtocol[dwTemp]->Delete();	// ignore error

			papHNetPortMappingProtocol[dwTemp]->Release();
			papHNetPortMappingProtocol[dwTemp] = NULL;
		}

		DNFree(papHNetPortMappingProtocol);
		papHNetPortMappingProtocol = NULL;
	}

	if (pHNetPortMappingBinding != NULL)
	{
		pHNetPortMappingBinding->Release();
		pHNetPortMappingBinding = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::MapPortOnLocalHNetFirewall





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UnmapPortOnLocalHNetFirewall"
//=============================================================================
// CNATHelpUPnP::UnmapPortOnLocalHNetFirewall
//-----------------------------------------------------------------------------
//
// Description:    Removes the mappings for the given ports from the local
//				firewall.
//
//				   The main object lock is assumed to be held.  It will be
//				converted into the long lock for the duration of this function.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port to be opened on the
//											firewall.
//	BOOL fNeedToDeleteRegValue			- Whether the corresponding crash
//											recovery registry value needs to
//											be deleted as well.
//	BOOL fNoteAddressChange				- Whether to alert the user of the
//											address change or not.
//
// Returns: HRESULT
//	DPNH_OK				- Unmapping completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::UnmapPortOnLocalHNetFirewall(CRegisteredPort * const pRegisteredPort,
												const BOOL fNeedToDeleteRegValue,
												const BOOL fNoteAddressChange)
{
	HRESULT			hr = DPNH_OK;
	BOOL			fSwitchedToLongLock = FALSE;
	BOOL			fUninitializeCOM = FALSE;
	IHNetCfgMgr *	pHNetCfgMgr = NULL;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, %i)",
		this, pRegisteredPort, fNeedToDeleteRegValue, fNoteAddressChange);


	DNASSERT(pRegisteredPort->IsMappedOnHNetFirewall());



	//
	// If the port is shared, leave it mapped since we can't tell when the
	// last person using it is done with it.
	//
	if (pRegisteredPort->IsSharedPort())
	{
		DPFX(DPFPREP, 2, "Leaving shared registered port 0x%p mapped.",
			pRegisteredPort);

		//
		// Pretend like we unmapped it, though.
		//
		pRegisteredPort->NoteNotMappedOnHNetFirewall();
		pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

		goto Exit;
	}


	//
	// Using the HomeNet API (particularly the out-of-proc COM calls) during
	// stress is really, really, painfully slow.  Since we have one global lock
	// the controls everything, other threads may be sitting for an equally
	// long time... so long, in fact, that the critical section timeout fires
	// and we get a false stress hit.  So we have a sneaky workaround to
	// prevent that from happening while still maintaining ownership of the
	// object.
	//
	this->SwitchToLongLock();
	fSwitchedToLongLock = TRUE;


	//
	// Try to initialize COM if we weren't instantiated through COM.  It may
	// have already been initialized in a different mode, which is okay.  As
	// long as it has been initialized somehow, we're fine.
	//
	if (this->m_dwFlags & NATHELPUPNPOBJ_NOTCREATEDWITHCOM)
	{
		hr = CoInitializeEx(NULL, (COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE));
		switch (hr)
		{
			case S_OK:
			{
				//
				// Success, that's good.  Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Successfully initialized COM.");
				fUninitializeCOM = TRUE;
				break;
			}

			case S_FALSE:
			{
				//
				// Someone else already initialized COM, but that's okay.
				// Cleanup when we're done.
				//
				DPFX(DPFPREP, 8, "Initialized COM (again).");
				fUninitializeCOM = TRUE;
				break;
			}

			case RPC_E_CHANGED_MODE:
			{
				//
				// Someone else already initialized COM in a different mode.
				// It should be okay, but we don't have to balance the CoInit
				// call with a CoUninit.
				//
				DPFX(DPFPREP, 8, "Didn't initialize COM, already initialized in a different mode.");
				break;
			}

			default:
			{
				//
				// Hmm, something else is going on.  We can't handle that.
				//
				DPFX(DPFPREP, 0, "Initializing COM failed (err = 0x%lx)!", hr);
				goto Failure;
				break;
			}
		}
	}
	else
	{
		DPFX(DPFPREP, 8, "Object was instantiated through COM, no need to initialize COM.");
	}


	//
	// Create the main HNet manager object.
	//
	hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, CLSCTX_INPROC_SERVER,
						IID_IHNetCfgMgr, (PVOID*) (&pHNetCfgMgr));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 1, "Couldn't create IHNetCfgMgr interface (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// We created the IHNetCfgMgr object as in-proc, so there's no proxy that
	// requires security settings.
	//
	//SETDEFAULTPROXYBLANKET(pHNetCfgMgr);


	//
	// Actually unmap the port(s).
	//
	hr = this->UnmapPortOnLocalHNetFirewallInternal(pRegisteredPort,
													fNeedToDeleteRegValue,
													pHNetCfgMgr);
	if (hr != DPNH_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't unmap ports from local HNet firewall (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	
	//
	// Alert the user to the change the next time GetCaps is called, if requested.
	//
	if (fNoteAddressChange)
	{
		DPFX(DPFPREP, 8, "Noting that addresses changed (for registered port 0x%p).",
			pRegisteredPort);
		this->m_dwFlags |= NATHELPUPNPOBJ_ADDRESSESCHANGED;
	}



Exit:

	if (pHNetCfgMgr != NULL)
	{
		pHNetCfgMgr->Release();
		pHNetCfgMgr = NULL;
	}

	if (fUninitializeCOM)
	{
		DPFX(DPFPREP, 8, "Uninitializing COM.");
		CoUninitialize();
		fUninitializeCOM = FALSE;
	}

	if (fSwitchedToLongLock)
	{
		this->SwitchFromLongLock();
		fSwitchedToLongLock = FALSE;
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	goto Exit;
} // CNATHelpUPnP::UnmapPortOnLocalHNetFirewall





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal"
//=============================================================================
// CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal
//-----------------------------------------------------------------------------
//
// Description:    Removes the mappings for the given ports from the local
//				firewall.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	CRegisteredPort * pRegisteredPort	- Pointer to port to be opened on the
//											firewall.
//	BOOL fNeedToDeleteRegValue			- Whether the corresponding crash
//											recovery registry value needs to
//											be deleted as well.
//	IHNetCfgMgr * pHNetCfgMgr			- Pointer to IHNetCfgMgr interface to
//											use.
//
// Returns: HRESULT
//	DPNH_OK				- Unmapping completed successfully.
//	DPNHERR_GENERIC		- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal(CRegisteredPort * const pRegisteredPort,
															const BOOL fNeedToDeleteRegValue,
															IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT								hr = DPNH_OK;
	CDevice *							pDevice;
	DWORD								dwAttempts = 0;
	IHNetProtocolSettings *				pHNetProtocolSettings = NULL;
	IEnumHNetPortMappingProtocols *		pEnumHNetPortMappingProtocols = NULL;
	SOCKADDR_IN *						pasaddrinPrivate;
	UCHAR								ucProtocolToMatch;
	IHNetPortMappingProtocol *			pHNetPortMappingProtocol = NULL;
	DWORD								dwStartingPort = 0;
	DWORD								dwTemp;
	ULONG								ulNumFound;
	WORD								wPort;
	UCHAR								ucProtocol;
	WCHAR *								pwszName = NULL;
	BOOLEAN								fBuiltIn;
	CRegistry							RegObject;


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, %i, 0x%p)",
		this, pRegisteredPort, fNeedToDeleteRegValue, pHNetCfgMgr);


	DNASSERT(pRegisteredPort->IsMappedOnHNetFirewall());


	pDevice = pRegisteredPort->GetOwningDevice();
	DNASSERT(pDevice != NULL);
	DNASSERT(pDevice->IsHNetFirewalled());


	DNASSERT(this->m_hIpHlpApiDLL != NULL);



Restart:


	//
	// Get a protocol settings interface.
	//
	hr = pHNetCfgMgr->QueryInterface(IID_IHNetProtocolSettings,
									(PVOID*) (&pHNetProtocolSettings));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't get IHNetProtocolSettings interface from IHNetCfgMgr 0x%p (err = 0x%lx)!",
			pHNetCfgMgr, hr);
		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pHNetProtocolSettings);


	//
	// Get ready to enumerate the existing mappings.
	//

	hr = pHNetProtocolSettings->EnumPortMappingProtocols(&pEnumHNetPortMappingProtocols);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't enumerate port mapping protocols (err = 0x%lx)!",
			hr);
		goto Failure;
	}


	//
	// The HNetxxx objects appear to not be proxied...
	//
	//SETDEFAULTPROXYBLANKET(pEnumHNetPortMappingProtocols);


	pasaddrinPrivate = pRegisteredPort->GetPrivateAddressesArray();

	if (pRegisteredPort->IsTCP())
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_TCP;
	}
	else
	{
		ucProtocolToMatch = PORTMAPPINGPROTOCOL_UDP;
	}



	//
	// Loop through all the ports (that we haven't successfully unmapped yet).
	//
	for(dwTemp = dwStartingPort; dwTemp < pRegisteredPort->GetNumAddresses(); dwTemp++)
	{
		//
		// Loop until we find a duplicate item or run out of items.
		//
		do
		{
			hr = pEnumHNetPortMappingProtocols->Next(1,
													&pHNetPortMappingProtocol,
													&ulNumFound);
			if (FAILED(hr))
			{
				dwAttempts++;
				if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
				{
					DPFX(DPFPREP, 0, "Couldn't get next port mapping protocol (err = 0x%lx)!  Trying again after %u ms.",
						hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

					//
					// Dump the object pointers we currently have.
					//

					pEnumHNetPortMappingProtocols->Release();
					pEnumHNetPortMappingProtocols = NULL;

					pHNetProtocolSettings->Release();
					pHNetProtocolSettings = NULL;


					//
					// Sleep, then go back to the top and try again.
					//
					Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
					goto Restart;
				}


				DPFX(DPFPREP, 0, "Couldn't get next port mapping protocol (err = 0x%lx)!",
					hr);
				goto Failure;
			}


			//
			// If there aren't any more items, bail.
			//
			if (ulNumFound == 0)
			{
				//
				// Be sure that IEnumHNetPortMappingProtocols::Next returned
				// the right thing, for PREfix's sake.
				//
				if (pHNetPortMappingProtocol != NULL)
				{
					pHNetPortMappingProtocol->Release();
					pHNetPortMappingProtocol = NULL;
				}


				//
				// pEnumHNetPortMappingProtocols->Next might have returned
				// S_FALSE.
				//
				hr = DPNH_OK;
				break;
			}


			//
			// The HNetxxx objects appear to not be proxied...
			//
			//SETDEFAULTPROXYBLANKET(pHNetPortMappingProtocol);


			//
			// Get the port.
			//
			hr = pHNetPortMappingProtocol->GetPort(&wPort);
			if (hr != S_OK)
			{
				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetPort!"), 2);


				//
				// Dump the unusable mapping object.
				//
				pHNetPortMappingProtocol->Release();
				pHNetPortMappingProtocol = NULL;


				dwAttempts++;
				if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
				{
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol port (err = 0x%lx)!  Trying again after %u ms.",
						hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

					//
					// Dump the object pointers we currently have.
					//

					pEnumHNetPortMappingProtocols->Release();
					pEnumHNetPortMappingProtocols = NULL;

					pHNetProtocolSettings->Release();
					pHNetProtocolSettings = NULL;


					//
					// Sleep, then go back to the top and try again.
					//
					Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
					goto Restart;
				}


				//
				// Break out of the search loop, but continue.
				//
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol port (err = 0x%lx)!",
					hr);
				break;
			}


			//
			// Get the protocol.
			//
			hr = pHNetPortMappingProtocol->GetIPProtocol(&ucProtocol);
			if (hr != S_OK)
			{
				DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetIPProtocol!"), 2);


				//
				// Dump the unusable mapping object.
				//
				pHNetPortMappingProtocol->Release();
				pHNetPortMappingProtocol = NULL;


				dwAttempts++;
				if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
				{
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's IP protocol (err = 0x%lx)!  Trying again after %u ms.",
						hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

					//
					// Dump the object pointers we currently have.
					//

					pEnumHNetPortMappingProtocols->Release();
					pEnumHNetPortMappingProtocols = NULL;

					pHNetProtocolSettings->Release();
					pHNetProtocolSettings = NULL;


					//
					// Sleep, then go back to the top and try again.
					//
					Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
					goto Restart;
				}


				//
				// Break out of the search loop, but continue.
				//
				DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's IP protocol (err = 0x%lx)!",
					hr);
				break;
			}


			//
			// See if we found the object we need.  Note that we don't verify
			// the target address for simplicity (neither does UPnP).
			//
			if ((wPort == pasaddrinPrivate[dwTemp].sin_port) &&
				(ucProtocol == ucProtocolToMatch))
			{
				//
				// Retrieve the mapping name.
				//
				hr = pHNetPortMappingProtocol->GetName(&pwszName);
				if (hr != S_OK)
				{
					DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetName!"), 2);


					//
					// Dump the unusable mapping object.
					//
					pHNetPortMappingProtocol->Release();
					pHNetPortMappingProtocol = NULL;


					dwAttempts++;
					if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
					{
						DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's name (err = 0x%lx)!  Trying again after %u ms.",
							hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

						//
						// Dump the object pointers we currently have.
						//

						pEnumHNetPortMappingProtocols->Release();
						pEnumHNetPortMappingProtocols = NULL;

						pHNetProtocolSettings->Release();
						pHNetProtocolSettings = NULL;


						//
						// Sleep, then go back to the top and try again.
						//
						Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
						goto Restart;
					}


					//
					// Break out of the search loop, but continue.
					//
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's name (err = 0x%lx)!",
						hr);
					break;
				}

				DPFX(DPFPREP, 8, "Found port mapping protocol 0x%p (\"%ls\").",
					pHNetPortMappingProtocol, pwszName);

				//
				// See if this protocol is built-in.
				//
				hr = pHNetPortMappingProtocol->GetBuiltIn(&fBuiltIn);
				if (hr != S_OK)
				{
					DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetBuiltIn!"), 2);


					//
					// Dump the unusable mapping object and its name.
					//
					pHNetPortMappingProtocol->Release();
					pHNetPortMappingProtocol = NULL;

					CoTaskMemFree(pwszName);
					pwszName = NULL;


					dwAttempts++;
					if (dwAttempts < MAX_NUM_HOMENETUNMAP_ATTEMPTS)
					{
						DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's built-in status (err = 0x%lx)!  Trying again after %u ms.",
							hr, (dwAttempts * HOMENETUNMAP_SLEEP_FACTOR));

						//
						// Dump the object pointers we currently have.
						//

						pEnumHNetPortMappingProtocols->Release();
						pEnumHNetPortMappingProtocols = NULL;

						pHNetProtocolSettings->Release();
						pHNetProtocolSettings = NULL;


						//
						// Sleep, then go back to the top and try again.
						//
						Sleep(dwAttempts * HOMENETUNMAP_SLEEP_FACTOR);
						goto Restart;
					}


					//
					// Break out of the search loop, but continue.
					//
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol's built-in status (err = 0x%lx)!",
						hr);
					break;
				}


				break;
			}
#ifdef DBG
			else
			{
				//
				// Try to retrieve the mapping name for informational purposes.
				//
				hr = pHNetPortMappingProtocol->GetName(&pwszName);
				if (hr != S_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't get port mapping protocol 0x%p's name (err = 0x%lx)!",
						pHNetPortMappingProtocol, hr);


					DNASSERTX((! "Got unexpected error executing IHNetPortMappingProtocol::GetName!"), 2);

					//
					// Ignore error...
					//
				}
				else
				{
					DPFX(DPFPREP, 7, "Skipping non-matching port mapping protocol 0x%p (\"%ls\").",
						pHNetPortMappingProtocol, pwszName);

					CoTaskMemFree(pwszName);
					pwszName = NULL;
				}
			}
#endif // DBG


			//
			// Get ready for the next object.
			//
			pHNetPortMappingProtocol->Release();
			pHNetPortMappingProtocol = NULL;
		}
		while (TRUE);


		//
		// Remove the mapping (if we found it).
		//
		if (pHNetPortMappingProtocol != NULL)
		{
			//
			// If the mapping is built-in we can't delete it.  Disabling it is
			// the best we can do.
			//
			if (fBuiltIn)
			{
				DPFX(DPFPREP, 7, "Disabling built-in port mapping protocol \"%ls\".", pwszName);

				DNASSERT(pRegisteredPort->IsHNetFirewallMappingBuiltIn());

				hr = this->DisableAllBindingsForHNetPortMappingProtocol(pHNetPortMappingProtocol,
																		pHNetCfgMgr);
				if (hr != DPNH_OK)
				{
					DPFX(DPFPREP, 0, "Couldn't disable all bindings for built-in port mapping protocol \"%ls\" (err = 0x%lx)!",
						pwszName, hr);
					goto Failure;
				}
			}
			else
			{
				DPFX(DPFPREP, 7, "Deleting port mapping protocol \"%ls\".", pwszName);

				DNASSERT(! pRegisteredPort->IsHNetFirewallMappingBuiltIn());


				hr = pHNetPortMappingProtocol->Delete();
				if (hr != S_OK)
				{
					//
					// This might be WBEM_E_ACCESSDENIED (0x80041003), which
					// means the current user doesn't have permissions to
					// modify firewall mappings.
					//

					DPFX(DPFPREP, 0, "Couldn't delete port mapping protocol (err = 0x%lx)!",
						hr);
					goto Failure;
				}
			}


			if (fNeedToDeleteRegValue)
			{
				//
				// Delete the crash cleanup registry entry.  The mapping
				// description/name will match the registry key name even in
				// the case of built-in mappings with names we didn't generate.
				// See MapPortOnLocalHNetFirewall.
				//
				if (! RegObject.Open(HKEY_LOCAL_MACHINE,
									DIRECTPLAYNATHELP_REGKEY L"\\" REGKEY_COMPONENTSUBKEY L"\\" REGKEY_ACTIVEFIREWALLMAPPINGS,
									FALSE,
									TRUE,
									TRUE,
									DPN_KEY_ALL_ACCESS))
				{
					DPFX(DPFPREP, 0, "Couldn't open active firewall mapping key, unable to remove crash cleanup reference!");
				}
				else
				{
					BOOL	fResult;


					//
					// Ignore error.
					//
					fResult = RegObject.DeleteValue(pwszName);
					if (! fResult)
					{
						DPFX(DPFPREP, 0, "Couldn't delete firewall mapping value \"%ls\"!  Continuing.",
							pwszName);
					}

					RegObject.Close();
				}
			}
			else
			{
				DPFX(DPFPREP, 6, "No need to delete firewall crash cleanup registry key \"%ls\".", pwszName);
			}


			//
			// Cleanup pointers we accumulated.
			//

			CoTaskMemFree(pwszName);
			pwszName = NULL;

			pHNetPortMappingProtocol->Release();
			pHNetPortMappingProtocol = NULL;
		}
		else
		{
			//
			// We didn't find the mapping.
			//
			DPFX(DPFPREP, 0, "Didn't find port mapping protocol for port %u %s!  Continuing.",
				NTOHS(pasaddrinPrivate[dwTemp].sin_port),
				((pRegisteredPort->IsTCP()) ? _T("TCP") : _T("UDP")));
		}



		//
		// Cleanup from this port mapping, and get ready for the next one.
		//

		hr = pEnumHNetPortMappingProtocols->Reset();
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't reset port mapping protocol enumeration 0x%p (err = 0x%lx)!",
				pEnumHNetPortMappingProtocols, hr);
			goto Failure;
		}


		//
		// Go on to the next port, and update the starting counter in case we
		// encounter a failure next time.
		//
		dwStartingPort++;
	}


	pRegisteredPort->NoteNotMappedOnHNetFirewall();
	pRegisteredPort->NoteNotHNetFirewallMappingBuiltIn();

	
	DNASSERT(hr == DPNH_OK);


Exit:

	if (pHNetPortMappingProtocol != NULL)
	{
		pHNetPortMappingProtocol->Release();
		pHNetPortMappingProtocol = NULL;
	}

	if (pEnumHNetPortMappingProtocols != NULL)
	{
		pEnumHNetPortMappingProtocols->Release();
		pEnumHNetPortMappingProtocols = NULL;
	}

	if (pHNetProtocolSettings != NULL)
	{
		pHNetProtocolSettings->Release();
		pHNetProtocolSettings = NULL;
	}


	DPFX(DPFPREP, 5, "(0x%p) Returning: [0x%lx]", this, hr);

	return hr;


Failure:

	if (pwszName != NULL)
	{
		CoTaskMemFree(pwszName);
		pwszName = NULL;
	}

	goto Exit;
} // CNATHelpUPnP::UnmapPortOnLocalHNetFirewallInternal





#undef DPF_MODNAME
#define DPF_MODNAME "CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol"
//=============================================================================
// CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol
//-----------------------------------------------------------------------------
//
// Description:    Disables all HNetPortMappingBindings on all HNetConnection
//				interfaces for the given port mapping protocol object.
//
//				   COM is assumed to have been initialized.
//
//				   The object lock is assumed to be held.
//
// Arguments:
//	IHNetPortMappingProtocol * pHNetPortMappingProtocol		- Pointer to port
//																mapping
//																protocol to
//																disable on all
//																connections.
//	IHNetCfgMgr * pHNetCfgMgr								- Pointer to
//																IHNetCfgMgr
//																interface to
//																use.
//
// Returns: HRESULT
//	DPNH_OK							- Disabling was successful.
//	DPNHERR_GENERIC					- An error occurred.
//=============================================================================
HRESULT CNATHelpUPnP::DisableAllBindingsForHNetPortMappingProtocol(IHNetPortMappingProtocol * const pHNetPortMappingProtocol,
																IHNetCfgMgr * const pHNetCfgMgr)
{
	HRESULT						hr;
	INetConnectionManager *		pNetConnectionManager = NULL;
	IEnumNetConnection *		pEnumNetConnections = NULL;
	ULONG						ulNumFound;
	INetConnection *			pNetConnection = NULL;
	IHNetConnection *			pHNetConnection = NULL;
	IHNetPortMappingBinding *	pHNetPortMappingBinding = NULL;
#ifdef DBG
	WCHAR *						pwszName = NULL;
#endif // DBG


	DPFX(DPFPREP, 5, "(0x%p) Parameters: (0x%p, 0x%p)",
		this, pHNetPortMappingProtocol, pHNetCfgMgr);


	//
	// Try creating the base connection object.
	//
	hr = CoCreateInstance(CLSID_ConnectionManager,
						NULL,
						CLSCTX_SERVER,
						IID_INetConnectionManager,
						(PVOID*) (&pNetConnectionManager));
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't create INetConnectionManager interface (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	SETDEFAULTPROXYBLANKET(pNetConnectionManager);


	DPFX(DPFPREP, 7, "Successfully created net connection manager object 0x%p.",
		pNetConnectionManager);


	//
	// Get the net connection enumeration object.
	//
	hr = pNetConnectionManager->EnumConnections(NCME_DEFAULT, &pEnumNetConnections);
	if (hr != S_OK)
	{
		DPFX(DPFPREP, 0, "Couldn't enum connections (err = 0x%lx)!",
			hr);
		goto Failure;
	}

	SETDEFAULTPROXYBLANKET(pEnumNetConnections);


	//
	// We don't need the base object anymore.
	//
	pNetConnectionManager->Release();
	pNetConnectionManager = NULL;


	//
	// Keep looping until we find the item or run out of items.
	//
	do
	{
		hr = pEnumNetConnections->Next(1, &pNetConnection, &ulNumFound);
		if (FAILED(hr))
		{
			DPFX(DPFPREP, 0, "Couldn't get next connection (err = 0x%lx)!",
				hr);
			goto Failure;
		}


		//
		// If there aren't any more items, bail.
		//
		if (ulNumFound == 0)
		{
			//
			// pEnumNetConnections->Next might have returned S_FALSE.
			//
			hr = DPNH_OK;
			break;
		}


		SETDEFAULTPROXYBLANKET(pNetConnection);


		//
		// Get the HNetConnection object for this NetConnection.
		//
		hr = pHNetCfgMgr->GetIHNetConnectionForINetConnection(pNetConnection,
															&pHNetConnection);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get IHNetConnection interface for INetConnection 0x%p (err = 0x%lx)!",
				pNetConnection, hr);
			goto Failure;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetConnection);


		//
		// Don't need the INetConnection interface anymore.
		//
		pNetConnection->Release();
		pNetConnection = NULL;


#ifdef DBG
		//
		// Retrieve the connection name, for debug printing purposes.
		//
		hr = pHNetConnection->GetName(&pwszName);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get name of HNetConnection 0x%p (err = 0x%lx)!",
				pHNetConnection, hr);
			goto Failure;
		}
#endif // DBG


		//
		// Retrieve the existing binding.
		//
		hr = pHNetConnection->GetBindingForPortMappingProtocol(pHNetPortMappingProtocol,
															&pHNetPortMappingBinding);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't get binding for port mapping protocol 0x%p (err = 0x%lx)!",
				pHNetPortMappingProtocol, hr);
			goto Failure;
		}


		//
		// The HNetxxx objects appear to not be proxied...
		//
		//SETDEFAULTPROXYBLANKET(pHNetPortMappingBinding);


		//
		// Don't need the HomeNet Connection object anymore.
		//
		pHNetConnection->Release();
		pHNetConnection = NULL;


		DPFX(DPFPREP, 6, "Disabling binding 0x%p on connection \"%ls\".",
			pHNetPortMappingBinding, pwszName);

		
		//
		// Disable it.
		//
		hr = pHNetPortMappingBinding->SetEnabled(FALSE);
		if (hr != S_OK)
		{
			DPFX(DPFPREP, 0, "Couldn't disable port mapping binding 0x%p (err = 0x%lx)!",
				pHNetPortMappingBinding, hr);
			goto Failure;
		}

		pHNetPor